<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Synthesizing Software Verifiers from Proof Rules</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sergey</forename><surname>Grebenshchikov</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universität München</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nuno</forename><forename type="middle">P</forename><surname>Lopes</surname></persName>
							<email>nuno.lopes@ist.utl.pt</email>
							<affiliation key="aff1">
								<orgName type="institution">INESC-ID / IST -TU Lisbon</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Corneliu</forename><surname>Popeea</surname></persName>
							<email>popeea@model.in.tum.de</email>
							<affiliation key="aff2">
								<orgName type="institution">Technische Universität München</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrey</forename><surname>Rybalchenko</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Technische Universität München</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Synthesizing Software Verifiers from Proof Rules</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DE2F18F61C8A744132E9AA6D56AC762E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Software Engineering]: Software/Program Verification</term>
					<term>D.4.5 [Operating Systems]: Reliability-Verification</term>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs Proof rules, verification tool synthesis, software verification, software model checking</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Automatically generated tools can significantly improve programmer productivity. For example, parsers and dataflow analyzers can be automatically generated from declarative specifications in the form of grammars, which tremendously simplifies the task of implementing a compiler. In this paper, we present a method for the automatic synthesis of software verification tools. Our synthesis procedure takes as input a description of the employed proof rule, e.g., program safety checking via inductive invariants, and produces a tool that automatically discovers the auxiliary assertions required by the proof rule, e.g., inductive loop invariants and procedure summaries. We rely on a (standard) representation of proof rules using recursive equations over the auxiliary assertions. The discovery of auxiliary assertions, i.e., solving the equations, is based on an iterative process that extrapolates solutions obtained for finitary unrollings of equations. We show how our method synthesizes automatic safety and liveness verifiers for programs with procedures, multi-threaded programs, and functional programs. Our experimental comparison of the resulting verifiers with existing state-of-the-art verification tools confirms the practicality of the approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Developing tools that deal with programs, e.g., parsers, compilers, analyzers, or verifiers, is a difficult yet necessary task for increasing programmer productivity. Programs are complex artifacts and their treatment within a tool requires careful consideration of various intricate aspects of program syntax and semantics. Tool synthesis offers an attractive alternative to manual tool development. Once a Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. PLDI <ref type="bibr">'12, June 11-16, 2012</ref>, Beijing, China. Copyright c 2012 ACM 978-1-4503-1205-9/12/06. . . $10.00 tool generator is developed for a given problem domain, it can be used to synthesize various tools that deal with particular problem instances in the given domain. For example, in the problem domain of parsing, a parser generator allows one to synthesize parsers for particular (programming) languages <ref type="bibr" target="#b0">[1]</ref>. Each parser is synthesized by the generator from a language specification in the form of a grammar. Furthermore, static analyzers (including pointer alias analyzers) can be generated from attribute grammars <ref type="bibr" target="#b46">[47]</ref>, dataflow equations <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b30">31]</ref>, equations in the form of set constraints <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b26">27]</ref>, or equations as Datalog rules <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b50">51]</ref>. These approaches take an analysis specification as a set of equations and produce an analyzer that infers program properties by solving the equations.</p><p>Recently, property verifiers became a target for automated tool construction. For example, the GETAFIX tool for checking Boolean programs was synthesized from a logical formula in µ-calculus using a BDD-based fixpoint solver <ref type="bibr" target="#b48">[49]</ref>. Still, software verification tools such as SLAM <ref type="bibr" target="#b3">[4]</ref>, BLAST <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>, FSOFT <ref type="bibr" target="#b22">[23]</ref>, IMPACT <ref type="bibr" target="#b32">[33]</ref>, TERMINATOR <ref type="bibr" target="#b10">[11]</ref>, CPACHECKER <ref type="bibr" target="#b6">[7]</ref>, or DSOLVE <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b42">43]</ref>, are developed from the ground up in a complex manual effort that takes into account particularities of domain specific reasoning for the applied verification method. The development efforts may need to be repeated to a large extent once a different proof rule is employed, or programs in a different programming language are considered as input. This status quo hinders the advancement of the state-of-the-art in software verification, makes it prohibitively expensive to develop new verification methods and provide verification tools for the growing number of application domains. Without automatic tool support for the development of software verifiers, we cannot deliver required tools for improving software reliability and leave software developers alone in dealing with the increasing complexity of modern software systems.</p><p>In this paper we present a method for automating the development of software verification tools by providing the following key ingredients: a methodology for describing verification methods for reachability and termination properties as constraint solving problems, and an efficient solver for the resulting constraints. As a result, developing a new software verifier will become a twostep process: i) design and specification of a verification method in the form of constraints supported by our methodology, and ii) construction of a frontend that generates constraints from software source code. The main effort will be spent in the formulation of a suitable verification method, which is a creative activity that usually leverages existing methods and adapts them to new application domains. The frontend construction usually requires writing a translator from the compiler's intermediate representation into the language of constraints, which is a well-established routine. We be-int sum(int n) { int s; 1:</p><p>if (n &gt; 0) { 2: s = sum(n-1); 3: return s+n; } else { 4: return 0; } 5: } V = (n, s, ret, pc) init(V ) = (pc = 1) ρ(V, V ) = (n ≥ 1 ∧ move( 1, 2) ∧ skip(n, s, ret)) ∨ (ret = s + n ∧ move( 3, 5) ∧ skip(n, s)) ∨ (n ≤ 0 ∧ move( 1, 4) ∧ skip(n, s, ret)) ∨ (ret = 0 ∧ move( 4, 5) ∧ skip(n, s)) call (V, V ) = (n = n -1 ∧ move( 2, 1)) ret(V, V ) = (s = ret ∧ move( 5, 3)) loc(V, V ) = (skip(n, ret) ∧ move( 2, 3)) Figure <ref type="figure">1</ref>. An example program and its representation as a transition system. skip(v1, . . . , v k ) abbreviates the conjunction</p><formula xml:id="formula_0">v 1 = v1 ∧ • • • ∧ v k = v k . move( , ) abbreviates the conjunction pc = ∧ pc = .</formula><p>lieve that our method offers promising potential to boost the development (and deployment) of software verifiers in the same way the parser generators paved the way to modern approaches to compiler construction.</p><p>Our method focuses on automatic construction of verification tools that implement proof rules for reachability and termination properties in the form of Horn(-like) clauses, see e.g. <ref type="bibr" target="#b29">[30]</ref>. Proof rules in such form are shown to be sufficiently expressive and practically adequate for dealing with a wide range of programming languages (including sequential, concurrent, and functional programs), temporal specifications and verification techniques, see e.g. <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b42">43]</ref>. We present an efficient algorithm for solving Horn-like clauses by generalizing state-of-the-art software verification algorithms, in particular counterexample guided abstraction and refinement schemes. To demonstrate the feasibility of our approach in practice, we apply our solving algorithm in combination with appropriate constraint generation frontends to develop a collection of verifiers for temporal properties of programs with procedures, multi-threaded programs, and functional programs.</p><p>This paper makes the following contributions.</p><p>• Conceptually, we identify a formulation of proof rules for reachability and termination properties in the form of Horn-like clauses suitable for automation using state-of-the-art techniques for software verification. • Technically, we provide an algorithm for solving Horn-like clauses that is based on a generalization of the state-of-the-art counterexample guided abstraction refinement schemes. • Practically, we present an implementation of our approach and its evaluation on important proof rules for the verification of transition systems, programs with procedures, multi-threaded programs, and functional programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Illustration</head><p>We illustrate our verification approach using a simple example for which we prove a safety and a termination property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Verifying programs with procedures</head><p>See Figure <ref type="figure">1</ref> for an example program implementing a sum computation. The procedure sum takes an argument n and returns the sum of the numbers between 1 and n, or 0 if its argument n is not positive. We assume that the program state is given by a valuation of the program variables V = (n, s, ret, pc) . The variable ret models return value passing, while pc is a procedure-local program counter variable that keeps track of the current control location. The initial states of the program are given as an assertion init(V ) , where 1 indicates the program line labeled 1. We use assertions over a tuple of variables V and its primed version V to model program statements as binary relations over states. In our program, ρ(V, V ) represents intra-procedural statements. call (V, V ) and ret(V, V ) model parameter and return value passing, respectively. The last assertion loc(V, V ) ensures that the caller's local data variables are unchanged during the callee's execution, while the caller's program counter moves over the call site. The set of local variables that are kept unchanged by the assertion loc(V, V ) excludes s , which is assigned by the call statement.</p><p>Proving safety We prove that sum always returns a non-negative value and formalize this property by the assertion error (V ) = (pc = 5 ∧ ret &lt; 0) . To prove the property, we rely on a summarization proof rule for programs with procedures <ref type="bibr" target="#b41">[42]</ref>. This proof rule requires the construction of an auxiliary assertion Summ(V, V ) that represents a binary relation between entry states of a procedure and their successors on the same level of recursion. The following constraints over Summ(V, V ) guarantee that all necessary pairs of states are captured.</p><formula xml:id="formula_1">init(V ) ∧ V = V → Summ(V, V ) Summ(V, V ) ∧ ρ(V , V ) → Summ(V, V ) Summ(V, V ) ∧ call (V , V ) ∧ V = V → Summ(V , V ) Summ(V, V ) ∧ call (V , V ) ∧ Summ(V , V ) ∧ ret(V , V ) ∧ loc(V , V ) → Summ(V, V )</formula><p>We obtain a correctness proof if we can find an instance of Summ that satisfies the above constraints together with the implication Summ(V, V ) ∧ error (V ) → false . The following disjunction is a solution that is computed by our proposed Horn solving algorithm.</p><formula xml:id="formula_2">Summ(V, V ) = (pc = 1 ∧ pc ∈ { 1, 4}) ∨ (pc = 1 ∧ pc = 2 ∧ n ≥ 1) ∨ (pc = 1 ∧ pc = 3 ∧ n + s ≥ 1) ∨ (pc = 1 ∧ pc = 5 ∧ ret ≥ 0)</formula><p>Note that the last disjunct ensures the non-negativeness of the return value.</p><p>Proving termination For proving that sum terminates on every input, we require that a so-called recursion relation between entry states of the caller and its immediate callee is well-founded, i.e., it does not admit infinite chains. We obtain the recursion relation by relational composition of the summary with the parameter passing relation. Hence, for proving termination, we need to find an assertion Summ(V, V ) that satisfies the above implications ensuring the summarization property and the following well-foundedness condition.</p><formula xml:id="formula_3">well -founded (Summ(V, V ) ∧ call (V , V ))</formula><p>To prove termination, our previous solution for Summ(V, V ) requires a strengthening n ≤ n that keeps track of changes applied to n and guarantees that n never increases. Our solving algorithm computes the following solution.</p><formula xml:id="formula_4">Summ(V, V ) = (pc = 1 ∧ pc = 1 ∧ n ≥ n ) ∨ (pc = 1 ∧ pc = 2 ∧ n ≥ 1 ∧ n ≥ n ) ∨ (pc = 1 ∧ pc = 3 ∧ n + s ≥ 1) ∨ (pc = 1 ∧ pc = 4) ∨ (pc = 1 ∧ pc = 5 ∧ ret ≥ 0)</formula><p>The composition of the strengthened solution with the parameter passing relation is</p><formula xml:id="formula_5">(move( 1, 1) ∧ n ≥ 0 ∧ n ≤ n -1) .</formula><p>Its well-foundedness follows from the decrease of n at each step and its boundedness from below by n ≥ 0.</p><p>As our example illustrates, we consider proof rules that can be represented as a set of implication constraints over formulas representing the program and "unknown" formulas, e.g. Summ(V, V ) . To provide a basis for efficient solving algorithms, our implication constraints resemble Horn clauses as they may have at most one unknown formula in the consequent part of a clause. We refer to such implications as Horn-like clauses, since we allow arbitrary disjunctions among "known" formulas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Verifying functional programs</head><p>We represent the program from Figure <ref type="figure">1</ref> as a functional program. let rec sum n = if n &gt; 0 then let s = sum (n-1) in s+n else 0</p><p>For functional programs, typing constraints can be used to track value flow through program expressions. They relate refinement types <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b25">26]</ref> that represent assertions over values of expressions and values of identifiers in scope. For example, the type of the above function sum can be represented as follows.</p><p>sum : (n :</p><formula xml:id="formula_6">{ν : int | P1(ν)} → {ν : int | P2(n, ν)})</formula><p>Following recent work on refinement type inference, see e.g., <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b49">50]</ref>, we embed the typing constraints into logical implications and obtain the following set of Horn-like clauses over P1(ν) and P2(n, ν) .</p><formula xml:id="formula_7">true → P1(ν) P1(n) ∧ n &gt; 0 ∧ ν = n -1 → P1(ν) P1(n) ∧ n &gt; 0 ∧ P2(n -1, ν) ∧ ν = n + ν → P2(n, ν ) P1(n) ∧ n ≤ 0 ∧ ν = 0 → P2(n, ν) P2(n, ν) → ν ≥ 0</formula><p>The first clause encodes that there is no restriction on the inputs to sum. The second and third clauses represent data flow if the branching condition succeeds. First, there is data flow due to the parameter passing, which is represented by the second clause.</p><p>Then, the result of the recursive call is represented using the assertion P2(n-1, ν). The sum of ν and n is the return value. The fourth clause encodes return value passing when the branching condition fails. The last clause represents the property that sum returns nonnegative values. If there is a solution to the above clauses then sum satisfies the property. Our solving algorithm computes solutions for P1(ν) and P2(n, ν) , which yields the following type for sum. sum : (n : {ν : int | true} → {ν : int | ν ≥ 0}) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Preliminaries</head><p>In this section we introduce preliminary definitions.</p><p>We write λx ∈ X.e to represent a definition that assigns to each x ∈ X the value obtained by evaluating e. Given a function f , let dom(f ) denote the domain of f , i.e., the set of values for which f is defined. A binary relation is well-founded if it does not admit infinite chains. We write well -founded (ϕ(v, v )) if ϕ(v, v ) is a well-founded relation, i.e., there is no infinite sequence s1, s2, . . . such that ϕ(si, si+1) for all i ≥ 1. Let denote the empty tuple. A relation ϕ(v, v ) is disjunctively well-founded if it is included in a finite union of well-founded relations, i.e., if there exist wellfounded ϕ1(v, v ), . . . , ϕn(v, v ) such that</p><formula xml:id="formula_8">ϕ(v, v ) |=T ϕ1(v, v ) ∨ • • • ∨ ϕn(v, v ).</formula><p>For example, the relation</p><formula xml:id="formula_9">x ≥ 0 ∧ x ≤ x -1 is well-founded, while the relation x ≥ 0 ∧ x ≤ x -1 ∨ y ≤ 0 ∧ y ≥ y + 1 is disjunctively well-founded.</formula><p>Constraints Let T be a first-order theory in a given signature, V be a set of variables, and |=T be the entailment relation with respect to T . We write v to denote a non-empty tuple of variables, i.e., v ∈ V + . We refer to formulas in the given signature as constraints, and let c(v) denote a constraint over the variables v. Let false denote an unsatisfiable constraint.</p><p>For example, let x, y, and z be variables. Then, v = (x, y) and w = (y, z) are tuples of variables. x ≤ 2, y ≤ 1 ∧ x -y ≤ 0, and f (x) + g(x, y) ≤ 3 ∨ z ≤ 0 are example constraints in the theory T of linear inequalities over rationals/reals and uninterpreted functions, where f and g are uninterpreted function symbols. The entailment y</p><formula xml:id="formula_10">≤ 1 ∧ x -y ≤ 0 |=T x ≤ 2 is valid.</formula><p>Queries and dwf-predicates We assume a set of uninterpreted predicate symbols Q that we refer to as query symbols. The arity of a query symbol is encoded in its name. We write q to denote a query symbol. Given q of a non-zero arity n and a tuple of variables v of length n, we define q(v) to be a query. Furthermore, we introduce an interpreted predicate symbol dwf of arity one (dwf stands for disjunctive well-foundedness). Given a query q(v, v ) over tuples of variables with equal length, we refer to dwf (q(v, v )) as a dwfpredicate.</p><p>For example, let Q = {r, s} be query symbols of arity one and two, respectively. Then, r(x) and s(x, y) are queries, and dwf (s(x, y)) is a dwf -predicate.</p><p>Horn-like clauses Let h(v) range over queries and constraints with variables in v. We define a Horn-like clause to be either an implication</p><formula xml:id="formula_11">c(v0) ∧ q1(v1) ∧ • • • ∧ qn(vn) → h(v) or a unit clause dwf (q(v, v ))</formula><p>which consists of a dwf -predicate. The left-hand side of the implication is called the body and the right-hand side is called the head. We use cl to denote a Horn-like clause.</p><p>The following set of clauses C illustrates our definition of Hornlike clauses.</p><formula xml:id="formula_12">C = {x ≤ y ∧ y ≤ -1 → r(x), y = x + 1 ∧ r(x) → s(x, y), r(x) → x ≤ 0, dwf (s(x, y))}</formula><p>To support efficient verification, our Horn-like clauses slightly deviate from the standard notion of Horn clauses since constraints occurring in our clauses can contain disjunctions and conjunctions. For example, we admit clauses such as</p><formula xml:id="formula_13">(x ≤ 0 ∨ y ≤ 0) ∧ s(x, y) → s(x, y) and s(x, y) → (x ≤ 0 ∨ y ≤ 0).</formula><p>While our presentation of the proposed method does not rely on the Boolean structure of constraints occurring in clauses, it is useful in practice to allow disjunction in constraints in order to keep the number of clauses small. (Note that the above two clauses can be translated into logically equivalent Horn clauses x ≤ 0∧s(x, y) → s(x, y), y ≤ 0 ∧ s(x, y) → s(x, y) and s(x, y) ∧ ¬(x ≤ 0) → y ≤ 0.) In contrast, we rely on the fact that there is at most one non-negated query in a clause.</p><p>Clauses in normal form Before formalizing the semantics of the clauses, we introduce assumptions on the syntax of Horn-like clauses that significantly simplify the presentation of the semantics without introducing any proper restrictions.</p><p>First, we assume that for each query symbol q there is a fixed tuple v of variables with the corresponding length and that each query with the symbol q is of the form q(v). That is, each query has an a priori defined tuple of variables. Furthermore, we assume that all variables in v are pairwise distinct, i.e., for the tuple of variables v = (x1, . . . , xn) we have xi and xj are different variables for all</p><formula xml:id="formula_14">1 ≤ i = j ≤ n.</formula><p>Second, we assume that in each clause a query symbol can occur at most once. Formally, for each clause c(v0</p><formula xml:id="formula_15">) ∧ q1(v1) ∧ • • • ∧ qn(vn) → h(v) we assume that qi is different from qj for all 1 ≤ i = j ≤ n, and if the head h(v) is a query q(v) then q is different from each qi for all 1 ≤ i ≤ n.</formula><p>The first assumption can be established by assigning tuples of variables to query symbols, and then translating queries into the desired form by adding corresponding equality constraints into the constraint of a clause. For example, for the query symbols r and s we assign variables vr = (xr) and vs = (xs, ys), respectively. Then, a clause x + y ≤ 0 ∧ r(x) ∧ s(x, x) → y ≤ 0 violates our first assumption but can be transformed to</p><formula xml:id="formula_16">x = xr ∧ x = xs ∧ x = ys ∧ x + y ≤ 0 ∧ r(xr) ∧ s(xs, ys) → y ≤ 0.</formula><p>The first conjunct corresponds to the translation of the query r(x), while the second and third conjuncts correspond to s(x, x).</p><p>The second assumption can be established by introducing auxiliary queries and clauses each time there is a clause with multiple occurrences of some query. The violating clause is transformed by replacing the violating query occurrences in the clause body by the auxiliary queries.</p><p>For example, a clause r(xr) ∧ r(xr) → r(xr) violates the second assumption due to the triple occurrence of r(xr). Hence, we introduce two auxiliary query symbols r1 and r2 of arity one together with the corresponding tuples of variables vr 1 = (xr 1 ) and vr 2 = (xr 2 ), respectively. Then, we express the relation between r(xr) and the introduced queries using the following auxiliary clauses:</p><formula xml:id="formula_17">xr = xr 1 ∧ r(xr) → r1(xr 1 ) and xr = xr 2 ∧ r(xr) → r2(xr 2 ). Finally, we translate the original clause r(xr) ∧ r(xr) → r(xr) to xr = xr 1 ∧ xr = xr 2 ∧ r1(xr 1 ) ∧ r2(xr 2 ) → r(xr).</formula><p>We refer to a set of Horn-like clauses that satisfies the above two conditions as clauses in normal form. In the rest of the paper, we assume that the clauses are Horn-like and in normal form.</p><p>For C defined above we obtain the following normal form CNF .</p><formula xml:id="formula_18">{x = xr ∧ x ≤ y ∧ y ≤ -1 → r(xr), x = xr ∧ x = xs ∧ y = ys ∧ y = x + 1 ∧ r(xr) → s(xs, ys), x = xr ∧ r(xr) → x ≤ 0, dwf (s(xs, ys))}</formula><p>Semantics of Horn-like clauses A set of clauses can be seen as an assertion over the queries that occur in the clauses.</p><p>We consider a function Σ that maps each query q(v) occurring in a given set of clauses into a constraint over v. Such a function is called a solution if the following two conditions hold. First, for each clause c(v0) ∧ q1(v1) ∧ • • • ∧ qn(vn) → h(v) from the given set we require:</p><formula xml:id="formula_19">c(v0) ∧ Σ(q1) ∧ • • • ∧ Σ(qn) |=T    Σ(q) if h(v) is q(v), c h (v) if h(v) is c h (v).</formula><p>Second, for each clause dwf (q(v, v )) in the input set we require that the relation Σ(q) is disjunctively well-founded. Let |=Q be the corresponding satisfaction relation, i.e., Σ |=Q C if Σ is a solution for C.</p><p>For example, the previously defined set of clauses CNF has a solution Σ such that</p><formula xml:id="formula_20">Σ(r) = xr ≤ -1, Σ(s) = xs ≤ 0 ∧ ys ≥ xs + 1.</formula><p>To check Σ |=Q CNF we consider the validity of the entailments</p><formula xml:id="formula_21">x = xr ∧ x ≤ y ∧ y ≤ -1 |=T xr ≤ -1, x = xr ∧ x = xs ∧ y = ys ∧ y = x + 1 ∧ xr ≤ -1 |=T xs ≤ 0 ∧ ys ≥ xs + 1, x = xr ∧ xr ≤ -1 |=T x ≤ 0,</formula><p>and the fact that Σ(s) is a (disjunctively) well-founded relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dependency and recursion-free clauses</head><formula xml:id="formula_22">For a clause cl such that c(v0) ∧ q1(v1) ∧ • • • ∧ qn(vn) → h(v)</formula><p>we define depends(cl ) to be the set of query symbols that appear in the body of cl , i.e., depends(cl ) = {q1, . . . , qn}. A set of clauses defines a binary dependency relation on query symbols. Each clause cl that has a query q(v) (rather than a constraint) in its head contributes the set of pairs {(qi, q) | qi ∈ depends(cl )} to the dependency relation. We say that a set of clauses is recursionfree if the corresponding dependency relation is well-founded.</p><p>For example, the second clause in C depends on the set of query symbols {r}, and the entire set of clauses C defines the dependency relation {(r, s)}. This dependency relation is well-founded, hence C is recursion-free.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solving recursion-free clauses</head><p>We assume an algorithm for solving recursion-free clauses. This algorithm takes as input recursionfree clauses in the theory T and computes a solution Σ when it exists. There already exist such algorithms for the theory of linear arithmetic (see <ref type="bibr" target="#b18">[19]</ref>) and linear arithmetic with uninterpreted functions (see <ref type="bibr" target="#b16">[17]</ref>), which are based on extensions of interpolation algorithms <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b45">46]</ref> to tree-like structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Algorithm HSF</head><p>In this section we present our algorithm HSF for finding solutions to recursive Horn-like clauses.</p><p>Let C be a finite set of clauses that is given as input to HSF. We partition C into inference clauses I and property clauses P. Inference clauses contain queries in their heads, and property clauses contain the rest, i.e.,</p><formula xml:id="formula_23">I = {cl ∈ C | cl = (. . . → q(v))}, P = C \ I.</formula><p>Inference clauses impose a relationship between queries, while property clauses impose absolute assertions on queries.</p><p>HSF finds a solution by following an iterative, abstractionbased approach that relies on (spurious) counterexample derivations to refine the abstraction in case of imprecision. This approach is a generalization of the counterexample-guided abstraction refinement schemes for proving reachability and termination properties of software. Our generalization deals with Horn-like clauses (instead of transition systems/programs with procedures). Our approach inherits the advantages and disadvantages of the existing counterexample-guided abstraction refinement schemes: a sufficiently precise yet not overly detailed abstraction can be discovered automatically, however the abstraction discovery procedure may not terminate. In practice, the non-terminating behavior is sufficiently seldom.</p><p>The iteration proceeds in three main steps.</p><p>1. We find a solution for the inference clauses I. At this step we perform logical inference and rely on abstraction to ensure termination in the presence of recursion and to ensure efficiency in the presence of large sets of clauses.</p><p>2. We check whether the computed solution satisfies the property clauses P. If some property clause, say cl , is not satisfied then we proceed with the analysis of the inference tree computed in the first step. Otherwise, if all property clauses are satisfied, we return the solution.</p><p>3. We check whether the logical inference performed in the first step in the setting without any abstraction yields a solution that still violates the property clause cl . If the violation is present then we return the inference tree as a counterexample derivation. Otherwise we use the obtained solution to refine the abstraction function and go back to the first step.</p><p>The first step is implemented using a procedure INFERABST that applies ADDINFERRED to perform the necessary bookkeeping of the inference tree construction. MAKECEX extracts a relevant subtree of the inference tree in case a solution computed by INFER-ABST violates some property clause. We rely on existing procedures for the analysis of the obtained subtree. ADDPREDS converts solutions obtained by the successful subtree analysis into a refinement of the abstraction function. The procedure HSF puts the steps together in a loop (Figure <ref type="figure" target="#fig_1">4</ref>). Next we present the procedures that implement the three steps.</p><p>(Predicate) abstraction We use predicate abstraction as an approximation technique employed by HSF. Let α be a function that takes as input a constraint ϕ(v) together with a finite set {c1(v), . . . , cn(v)} of predicates, i.e., atomic constraints, over v. The output is an over-approximation of ϕ(v) that is constructed from the given predicates using Boolean operators. We use the following definition (which is called Cartesian abstraction in the literature <ref type="bibr" target="#b4">[5]</ref>).</p><formula xml:id="formula_24">α(ϕ(v), {c1(v), . . . , cn(v)}) = {ci(v) | i ∈ 1..n ∧ ϕ(v) |=T ci(v)}</formula><p>For example, given the constraint x ≤ y ∧ y ≤ z ∧ z ≤ 0 and the predicates {x ≤ z, x ≥ 0, x ≤ 0} , the predicate abstraction function returns the conjunction x ≤ z ∧ x ≤ 0 .</p><p>We rely on two properties of the abstraction function: over-approximation and monotonicity. That is, for each pair of constraints ϕ(v), ψ(v) and each set of predicates Preds we have i) ϕ(v) entails α(ϕ(v), Preds) and ii) if ϕ(v) entails ψ(v) then α(ϕ(v), Preds) entails α(ψ(v), Preds) . The over-approximation will guarantee that combining logical inference with abstraction will yield solutions to inference clauses and the monotonicity will guarantee that such solutions can be computed using fixpoint iteration techniques.</p><p>Inference and abstraction Before presenting the procedure IN-FERABST, which performs logical inference, abstraction, and</p><formula xml:id="formula_25">RINIT c(v0) → q(v) ∈ I α(c(v0), Preds(q)) ∈ Inferred (q) RSTEP ϕ1(v1) ∈ Inferred (q1) . . . ϕn(vn) ∈ Inferred (qn) c(v0) ∧ n i=1 qi(vi) → q(v) ∈ I α(c(v0) ∧ n i=1 ϕi(vi), Preds(q)) ∈ Inferred (q) Figure 2.</formula><p>Abstract inference rules for a given set of clauses I and a predicate abstraction function with the set of predicates Preds(q) for each query symbol q.</p><p>bookkeeping, we first present a characterization of what it computes in the form of inference rules. See Figure <ref type="figure">2</ref>. The presented rules RINIT and RSTEP define a relation between a possibly empty sequence of constraints in the premise and a constraint in the consequence such that the relation satisfies some inference clause from the input set I.</p><p>We keep track of the inferred constraints in the set Inferred that we partition according to the query symbols of these constraints. The inference process applies the rules as long as the derived constraints are not subsumed by the previously derived ones. A constraint ϕ(v) derived by applying a clause with the query q(v) in its head is subsumed if there is a constraint ψ(v) in Inferred (q) such that ϕ(v) entails ψ(v). (This subsumption definition is called local entailment in the literature.)</p><p>We observe that the inference process terminates since the range of the abstraction function is finite, i.e., there are only finitely many different constraints that can be added to Inferred , and the abstraction function is monotonic. Furthermore, the resulting constraints yield a solution for the inference clauses. Formally, we define Σ = λq ∈ dom(Inferred ). Inferred (q) and obtain Σ |=Q I.</p><p>Procedure INFERABST We turn the inference rules RINIT and RSTEP into a worklist-based iteration procedure INFERABST that also keeps track between inferred constraints and corresponding clauses. See Figure <ref type="figure" target="#fig_0">3</ref>.</p><p>INFERABST takes as input the inference clauses I and a function Preds that assigns to each query symbol q (and the corresponding tuple of variables v) a finite set of predicates over v. The output of INFERABST consists of the inferred constraints Inferred and a function Parent that represent the bookkeeping results. Parent assigns to each inferred constraint ϕ(v) a sequence of constraints and a clause that were used in the rule application that produced ϕ(v). INFERABST maintains a worklist WL containing inference clauses that may infer new constraints.</p><p>The inference starts with applying all clauses that do not depend on any queries, and are hence applicable when no constraints are yet inferred. Each clause application follows the rule RINIT and applies ADDINFERRED to process the application result. Then, INFERABST iteratively applies the clauses from the worklist until no more non-subsumed constraints can be computed, i.e., until the worklist becomes empty. At every iteration step, INFERABST takes a clause from the worklist and exhaustively applies the clause following the rule RSTEP.</p><p>Example For the set of clauses CNF defined in the previous section, we consider the predicates Preds(r) = {xr ≤ 0} and Preds(s) = {xs ≤ ys} . For brevity, we denote the four clauses from CNF as cl 1 , cl 2 , cl 3, and cl 4 , respectively. Our algorithm initially processes the clauses that do not depend on any queries,  i.e., cl 1 (see lines 8-10 from Figure <ref type="figure" target="#fig_0">3</ref>). The computation of a new constraint at line 9 proceeds as follows:</p><formula xml:id="formula_26">= (. . . → q(v)) -parent clause with head q(v) begin if ¬(∃ψ(v) ∈ Inferred (q) : ϕ(v) |=T ψ(v)) then Inferred (q) := {ϕ(v)} ∪ Inferred (q) Parent(ϕ(v)) := ((ϕ1(v1), . . . , ϕn(vn)), cl ) WL := {cl ∈ I | q ∈ depends(cl )} ∪ WL end begin Inferred := λq ∈ Q.∅ Parent := ∅ WL := ∅ for each c(v0) → q(v) ∈ I do ϕ(v) := α(c(v0), Preds(q)) ADDINFERRED(ϕ(v), , c(v0) → q(v)) while WL = ∅ do c(v0) ∧ q1(v1) ∧ • • • ∧ qn(vn) → q(v) := take</formula><formula xml:id="formula_27">ϕ(xr) = α(x = xr ∧ x ≤ y ∧ y ≤ -1, {xr ≤ 0}) = (xr ≤ 0) .</formula><p>Procedure ADDINFERRED The procedure ADDINFERRED is shown in Figure <ref type="figure" target="#fig_0">3</ref>. Since ADDINFERRED is defined within INFER-ABST, Inferred , Parent, and WL are in scope of ADDINFERRED.</p><p>The input to ADDINFERRED is an inferred constraint ϕ(v) that was computed by applying a clause cl with the head q(v) on the possibly empty sequence of constraints ϕ1(v1), . . , ϕn(vn), i.e., n may be equal to zero. First, ADDINFERRED checks if ϕ(v) is subsumed by already inferred constraints. If no subsumption takes place then we add it to the set of inferred constraints Inferred , extend Parent with a corresponding bookkeeping record, and add inference clauses that depend on q to the worklist.</p><p>Example (cont.) After computing the constraint ϕ(xr) = xr ≤ 0 , the inference algorithm calls ADDINFERRED(xr ≤ 0, , cl 1) (see line 10 of Figure <ref type="figure" target="#fig_0">3</ref>) and records the information about the newly inferred constraint as follows:</p><formula xml:id="formula_28">Inferred (r) = {xr ≤ 0} , Parent(xr ≤ 0) = ( , cl 1) , WL = {cl 2} .</formula><p>After adding the clause cl 2 to the worklist, it will be processed in the loop at lines 11-15 and a call ADDINFERRED(xs ≤ ys, (xr ≤ 0), cl 2) leads to a second inferred constraint as follows:</p><formula xml:id="formula_29">Inferred (s) = {xs ≤ ys} , Parent(xs ≤ ys) = ((xr ≤ 0), cl 2) , WL = ∅ .</formula><p>For the given sets of predicates, i.e., Preds(r) = {xr ≤ 0} and Preds(s) = {xs ≤ ys} , the computation of inferred constraints finishes here since the worklist is empty.</p><p>Procedure HSF The main procedure of our algorithm is HSF. It is shown in Figure <ref type="figure" target="#fig_1">4</ref>. HSF takes as input a finite set of Hornlike clauses C = I P and iteratively computes a solution for the inference clauses I that also satisfies the property clauses P. HSF computes solution candidates from the constraints in Inferred that are inferred using INFERABST. The obtained candidate is guaranteed to satisfy I, while satisfaction of P requires finding a sufficiently precise abstraction function. The abstraction function α is determined by a set of predicates Preds that is partitioned between query symbols.</p><p>A sufficiently precise abstraction function is computed by HSF iteratively by adding predicates to Preds, which is empty initially. For the given Preds, we first use INFERABST to compute inferred constraints Inferred and Parent. Then we check whether the solution for I defined by Inferred also satisfies P. We distinguish between violation of a clause that has a constraint in its head from the violation of a clause consisting of a dwf -predicate.</p><p>If</p><formula xml:id="formula_30">a clause cl = c(v0) ∧ q1(v1) ∧ • • • ∧ qn(vn) → c h (v)</formula><p>is not satisfied by some sequence of inferred constraints, say ϕ1(v1) ∈ Inferred (q1), . . . , ϕn(vn) ∈ Inferred (qn), then we check if repeating the same inference steps without applying the abstraction function computes a sequence of constraints that satisfies cl .</p><p>We reconstruct the inference steps that produced ϕ1(v1), . . . , ϕn(vn) by using the procedure MAKECEX. The output of MAKECEX is a set of recursion-free clauses X whose queries correspond to the constraints that were involved, as recorded by Parent, in the computation of ϕ1(v1), . . . , ϕn(vn). We record the correspondence using the function Sym that assigns query symbols of the involved constraints to the fresh query symbols that represent constraints derived without abstraction. We also include into X a clause imposing an assertion on the queries that correspond to ϕ1(v1), . . . , ϕn(vn). Now, we solve X using an existing tool for solving recursionfree clauses <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19]</ref>. If a solution exists then we use it to extract additional predicates for Preds. The function Sym translates query symbols from the domain of the solution into the query symbols in our clauses C. In this case, after refining the abstraction we continue with another attempt to find a solution for C. If a solution does not exist, we return the clauses X as a witness of the property violation.</p><p>Example (cont.) The set of clauses CNF contains the property clause cl 3, i.e., x = xr ∧ r(xr) → x ≤ 0, which is satisfied by the candidate solution: Inferred (r) = (xr ≤ 0) .</p><p>If a clause dwf (q(v, v )) is not satisfied by some of the inferred constraints, say ϕ(v, v ) ∈ Inferred (q), then we proceed in a similar way as in the above case. First, we use MAKECEX to construct a set of recursion-free clauses X that reconstructs the inference steps leading to ϕ(v, v ). Then, we rely on an existing solver for recursion-free clauses to find a solution for X that assigns </p><formula xml:id="formula_31">) ∧ n i=1 qi(vi) → h(v)) := Parent(ϕ(v)) Sym := {"ϕ1(v1)" → q1, . . . , "ϕn(vn)" → qn} ∪ Sym return {c(v0) ∧ n i=1 "ϕi(vi)"(vi) → "ϕ(v)"(v)} ∪ n i=1 MAKECEX(ϕi(vi), Parent) end procedure ADDPREDS input Σ -solution function begin for each "ϕ(v)" ∈ dom(Σ) do q := Sym("ϕ(v)") Preds(q) := Σ("ϕ(v)") ∪ Preds(q) end begin Preds := λq ∈ Q.∅ repeat (Inferred , Parent) := INFERABST(I, Preds) if exist c(v0) ∧ n i=1 qi(vi) → c h (v) ∈ P and ϕi(vi) ∈ Inferred (qi) for each i ∈ 1..n such that c(v0) ∧ n i=1 ϕi(vi) |=T c h (v) then Sym := {"ϕ1(v1)" → q1, . . . , "ϕn(vn)" → qn} X := {c(v0) ∧ n i=1 "ϕi(vi)"(vi) → c h (v)} ∪ n i=1 MAKECEX(ϕi(vi), Parent) if exists Σ such that Σ |=Q X then ADDPREDS(Σ) else return "error derivation X " else if exist dwf (q(v, v )) ∈ P and ϕ(v, v ) ∈ Inferred (q) such that ¬well -founded (ϕ(v, v )) then Sym := {"ϕ(v, v )" → q} X := MAKECEX(ϕ(v, v ), Parent) if exists Σ such that Σ |=Q X and</formula><p>well -founded (Σ("ϕ(v, v )")) then ADDPREDS(Σ) else return "error derivation X " else return "solution λq ∈ dom(Inferred ). Inferred (q)" end. a well-founded relation to q(v, v ) <ref type="bibr" target="#b38">[39]</ref>. If INFERABST infers a set of constraints Inferred that defines a solution for P then we return this solution.</p><p>Example (cont.) The set of clauses CNF contains a second property clause, i.e., dwf (s(xs, ys)) . The conditions at line 20 of Figure <ref type="figure" target="#fig_1">4</ref> are satisfied for the inferred constraint xs ≤ ys : dwf (s(xs, ys)) ∈ CNF , xs ≤ ys ∈ Inferred (s) and ¬well -founded (xs ≤ ys) . In this case, the inferred constraint does not correspond to a well-founded relation.</p><p>Procedure MAKECEX The procedure MAKECEX is shown in Figure <ref type="figure" target="#fig_1">4</ref>. Its scope contains Sym and Preds from HSF. MAKE-CEX takes as input an inferred constraint ϕ(v) and bookkeeping records Parent such that ϕ(v) ∈ dom(Parent).</p><p>Then, MAKECEX creates a clause that records the fact that ϕ(v) was derived using the constraints and the clause in Parent(ϕ(v)). Let Parent(ϕ(v)) be the pair of ϕ1(v1), . . . , ϕn(vn) and c(v0</p><formula xml:id="formula_32">) ∧ q1(v1) ∧ • • • ∧ qn(vn) → h(v).</formula><p>This dependency is modeled by introducing auxiliary queries "ϕ1(v1)"(v1), . . . , "ϕn(vn)"(vn). These auxiliary queries stay in one-to-one correspondence with the constraints, i.e., "ϕi(vi)"(vi) corresponds to qi for all 1 ≤ i ≤ n. This correspondence is established by applying a bijective quotation function " • " that translates a constraint into a query symbol. Finally, we recursively apply MAKECEX on the constraints that produced ϕ(v) and return all constructed clauses. </p><formula xml:id="formula_33">Inferred (r) = {xr ≤ 0} Inferred (s) = {xs ≤ ys ∧ xs &lt; ys}</formula><p>Correctness Upon termination, the algorithm HSF computes a solution for the input clauses. The soundness of the approach is guaranteed by the fact that the abstraction function is overapproximating. Our abstraction refinement method guarantees that a set of counterexample clauses X is never analyzed twice, i.e., our refinement method satisfies the progress of refinement property. Such soundness and progress of refinement properties are standard for counterexample guided abstraction refinement schemes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>For assertions {T</head><formula xml:id="formula_34">f over V f and V f | f ∈ Procs(P )} , CP1 : init(Vmain ) ∧ Vmain = V main → Tmain (Vmain , V main ) CP2 : T f (V f , V f ) ∧ ρ f (V f , V f ) → T f (V f , V f ) CP3 : T f (V f , V f ) ∧ call f ,g (V f , V g ) ∧ V g = V g → Tg (V g , V g ) f , g ∈ Procs(P ) such that f calls g CP4 : T f (V f , V f ) ∧ call f ,g (V f , V g ) ∧ Tg (V g , V g ) ∧ ret f ,g (V g , V f ) ∧ loc f (V f , V f ) → T f (V f , V f ) f , g ∈ Procs(P ) such that f calls g CP5 : T f (V f , V f ) ∧ error (V f ) →</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Proof rules as Horn-like clauses</head><p>In this section, we show a collection of proof rules that can be automated using our verification approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Transition systems</head><p>We consider a transition system with variables V , a set of initial states init(V ), a transition relation ρ(V, V ), and a standard semantics.</p><p>Safety Let error (V ) represent a set of error states. To verify safety the transition system, we use an invariance proof rule with conditions over a query R(V ) that characterizes reachable states as follows.</p><p>For assertion R over V ,</p><formula xml:id="formula_35">CR1 : init(V ) → R(V ) CR2 : R(V ) ∧ ρ(V, V ) → R(V ) CR3 : R(V ) ∧ error (V ) → false</formula><p>transition system P is safe Condition CR1 requires that all initial states are present in R(V ). Condition CR2 states that a program transition starting from a state in R(V ) ends in a state that is in R(V ). Finally, CR3 states that the intersection of reachable and error states is empty. Our algorithm HSF finds a solution for the query R(V ).</p><p>Termination To reason about termination properties of transition systems, we use a proof rule based on transition invariants <ref type="bibr" target="#b36">[37]</ref>. The assertion T represents a transition invariant, which is a superset of the transitive closure of the transition relation ρ .</p><p>For assertion R over V that satisfies CR1 and CR2 and assertion T over V and V ,</p><formula xml:id="formula_36">CT1 : R(V ) ∧ ρ(V, V ) → T (V, V ) CT2 : T (V, V ) ∧ ρ(V , V ) → T (V, V ) CT3 : dwf (T (V, V ))</formula><p>transition system P terminates We restrict the assertion T (V, V ) to states that are reachable using CT1, CT2 and two clauses from the invariance proof rule, CR1 and CR2 . The last clause, CT3, uses a predicate symbol dwf of arity one that requires a disjunctive well-founded argument T (V, V ) . The existence of a (disjunctive well-founded) transition invariant guarantees program termination, cf. <ref type="bibr" target="#b36">[37]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Programs with procedures</head><p>We consider programs with a set of recursive procedures Procs(P ). Let main ∈ Procs(P ) be the procedure that starts the program execution. For each f ∈ Procs(P ), let V f the set of variables that are in scope, ρ f (V f , V f ) be the intra-procedural transition relation. If f calls a procedure g ∈ Procs(P ), then let call f ,g (V f , V g ) and ret f ,g (V f , V g ) be parameter and return value passing relations, respectively. The relation loc f (V f , V f ) states which local variables of f are not modified during a call to g. Safety We prove safety properties of procedural programs using a rule based on context-free language reachability <ref type="bibr" target="#b41">[42]</ref>. See Figure <ref type="figure">5</ref> for the proof rule that consists of constraints over assertions T f , one for each program procedure. A query T f (V f , V f ) represents a summary of the procedure f , which is a binary relation between entry states of f and their successors on the same level of recursion. For simplicity, our formulation does not adopt the common distinction between path edges and summaries, see, e.g., <ref type="bibr" target="#b41">[42]</ref>.</p><p>The first condition CP1 of the proof rule requires that the initial states constraint implies the query corresponding to the entry procedure main . The condition CP2 extends a query T f (V f , V f ) with a transition relation from the same procedure. The third and fourth conditions handle procedure calls. In CP3, given a query T f (V f , V f ) of the caller and the calling context passed from the variables V f to V g , the result is used to seed the summary of the callee procedure g . The condition CP4 is the most complex clause of the proof rule and ensures procedure-modular reasoning. It uses a query from the caller T f (V f , V f ) , links the calling context with the parameter passing relation call f ,g (V f , V g ) , uses the summary of the callee Tg (V g , V g ), passes the return value back in the scope of the caller with ret f ,g (V g , V f ) and links local variables not affected by the call with loc f (V f , V f ) . Finally, the condition CP5 requires that states reachable at an arbitrary location in some procedure f do not intersect error states.</p><p>Termination For proving termination properties, we use the proof rule from Figure <ref type="figure">5</ref> with an additional well-foundedness condition that no infinite recursion is feasible. This condition is imposed on a transition relation that describes recursive descent by composing procedure summaries with call relations following <ref type="bibr" target="#b11">[12]</ref>. Let VP = f ∈Procs(P ) V f be the set of variables that occur in all procedures. The technique of <ref type="bibr" target="#b11">[12]</ref> constructs an assertion Descent(VP , V P ) such that the program P terminates if and only if Descent(VP , V P ) is well-founded. By taking a transitive closure of Descent(VP , V P ) as described above, we can replace wellfoundedness condition by a disjunctive well-foundedness condition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Multi-threaded programs</head><p>We consider a multi-threaded program that consists of N threads as a tuple (V, init, ρ1, . . . , ρN ), where ρi is the transition relation of the thread i. The transition relation of the program ρ is the disjoint union of the N transition relations of the threads.</p><p>Owicki-Gries rule for proving safety Based on Owicki-Gries method <ref type="bibr" target="#b35">[36]</ref>, we present the following proof rule for verifying safety of multi-threaded programs. This proof rule lists conditions over N query symbols Ri that characterize reachable states for each thread i ∈ 1..N .</p><p>For assertions R1, . . . , RN over V ,</p><formula xml:id="formula_37">CO1 : init(V ) → Ri(V ) CO2 : Ri(V ) ∧ ρi(V, V ) → Ri(V ) CO3 : Ri(V ) ∧ ( i∈1..N \{j} Rj(V )∧ρj(V, V )) → Ri(V ) CO4 : R1(V ) ∧ . . . RN (V ) ∧ error (V ) → false multi-threaded program P is safe</formula><p>The conditions CO1, CO2 and CO4 resemble those from the invariance proof rule, while the additional condition CO3 ensures that the query Ri(V, V ) corresponding to thread i is free from interference from the transitions of other threads j . The presence of distinct query symbols for the reachable states of each thread allows our HSF algorithm to perform abstraction at the thread boundaries and leads to more scalable verification compared to the monolithic proof rule.</p><p>Rely-guarantee rule for proving safety As an alternative to the above proof rule, we can use a proof rule based on rely-guarantee reasoning method <ref type="bibr" target="#b24">[25]</ref>. The proof rule uses assertions Ri and Ei that characterize reachable states of each thread i ∈ 1..N and environment transitions of each thread i ∈ 1..N , respectively, following <ref type="bibr" target="#b18">[19]</ref>.</p><p>Each assertion Ri(V ) includes the initial states due to CM1. States reachable after executing a transition of thread i or an environment transition Ei(V, V ) are in Ri(V ) due to CM2 and CM4 , where ρ = i requires that the local variables of thread i do not change during an environment step of thread i . CM3 requires that every step of thread i starting from a reachable state is captured by the environment transitions of each other thread j. CM5 ensures that the intersection of reachable states and error states is empty.</p><p>For assertions R1, . . . , RN over V and E1, . . . , EN over V, V ,</p><formula xml:id="formula_38">CM1 : init(V ) → Ri(V ) CM2 : Ri(V ) ∧ ρi(V, V ) → Ri(V ) CM3 : ( i∈1..N \{j} Ri(V ) ∧ ρi(V, V )) → Ej(V, V ) CM4 : Ri(V ) ∧ Ei(V, V ) ∧ ρ = i (V, V ) → Ri(V ) CM5 : R1(V ) ∧ • • • ∧ RN (V ) ∧ error (V ) → false multi-threaded program P is safe</formula><p>Rely-guarantee rule for proving termination Rely-guarantee reasoning <ref type="bibr" target="#b24">[25]</ref> can be combined with the transition invariance proof rule <ref type="bibr" target="#b36">[37]</ref> to prove termination properties of multi-threaded programs. The proof rule uses assertions Ti for transition invariants and Ei for environment transitions <ref type="bibr" target="#b38">[39]</ref>.</p><p>For assertions T1, . . . , TN and E1, . . . , EN over V, V ,</p><formula xml:id="formula_39">CG1 : init(V ) ∧ ρi(V, V ) → Ti(V, V ) CG2 : Ti(V, V ) ∧ ρi(V , V ) → Ti(V , V ) CG3 : Ti(V, V ) ∧ ρi(V , V ) → Ti(V, V ) CG4 : ( j∈1..N \{i} init(V ) ∧ ρj(V, V )) → Ei(V, V ) CG5 : ( j∈1..N \{i} Ti(V, V ) ∧ ρj(V , V )) → Ei(V , V ) CG6 : init(V ) ∧ Ei(V, V ) ∧ ρ = i (V, V ) → Ti(V, V ) CG7 : Ti(V, V ) ∧ Ei(V , V ) ∧ ρ = i (V, V ) → Ti(V , V ) CG8 : Ti(V, V ) ∧ Ei(V , V ) ∧ ρ = i (V, V ) → Ti(V, V ) CG9 : dwf (T1(V, V ) ∧ • • • ∧ TN (V, V ))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>multi-threaded program P terminates</head><p>The conditions CG1 and CG2 require that Ti over-approximates the transition relation of the thread i restricted to initial states and to arbitrary reachable states. The condition CG3 extends Ti with a relation from ρi . The conditions CG4 and CG5 populate the environment transitions of thread i with steps of all threads other than i . The three conditions CG6, CG7 and CG8 are similar to the first three conditions except local transitions from ρi are replaced by environment transitions Ei ∧ρ = i . As before, ρ = i requires that the local variables of thread i do not change during an environment step of thread i . The final condition CG9 ensures that the conjunction of the transition invariant queries, T1(V, V ) ∧ • • • ∧ TN (V, V ) , is disjunctively well-founded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Experiments</head><p>In this section we present an experimental comparison between verifiers developed using our HSF algorithm and state-of-the-art verification tools developed using traditional methods.</p><p>Our tool HSF is implemented in Prolog and compiled with the SICStus Prolog 4.2.0 compiler. The implementation relies on a built-in constraint solver for linear arithmetic. For C programs, we use the CIL library <ref type="bibr" target="#b34">[35]</ref> and an additional frontend step that produces clauses for various proof rules. For verifying OCaml programs, we use DSolve <ref type="bibr" target="#b42">[43]</ref> to generate automatically subtyping constraints and then our code translates these constraints to Hornlike clauses.</p><p>Benchmarks We used several sets of benchmarks for our experiments. Table <ref type="table">1</ref>. Timings for the benchmarks. The left-side of the page shows statistics for sequential programs, with multi-threaded programs, functional programs and terminating loops on the right-side of the page. "T/O" stands for time out after 10 minutes, while "FAIL" indicates that the tool failed to return a verification result.</p><p>For verification of sequential programs, we used a set of programs from the Numerical Recipes book <ref type="bibr" target="#b39">[40]</ref>, with array bound checking being the safety property to verify. This set of benchmarks includes simulated annealing (amebsa), evaluate a trial point using simulated annealing (amotsa), fast fourier transform (four1), or polynomial extrapolation (pzextr). We also used two sets of benchmarks (ntdrivers and ssh-simplified) from the test suite of CPAchecker <ref type="bibr" target="#b6">[7]</ref>.</p><p>We collected multi-threaded and functional programs from the test suites of specialized verification tools, i.e., Threader <ref type="bibr" target="#b17">[18]</ref> and HMC <ref type="bibr" target="#b23">[24]</ref>. For termination checking, we used a set of programs from the Numerical Recipes book, including a secant method program (broydn), and a program to reduce a matrix to the Hessenberg form (elmhes).</p><p>Our benchmark suite includes both safe and non-safe programs. Non-safe programs have the word "BUG" attached to their name. For termination checking, all the benchmarks are terminating and we report the number of cutpoints as a measure for the effort to verify program termination.</p><p>Evaluation Our experiments were run on an Intel Core 2 Duo machine, clocked at 3.0 GHz, with 4 GB of RAM, and running Linux 2.6.38. See Table <ref type="table">1</ref> for the results.</p><p>For the first three categories of benchmarks (Numerical Recipes, ntdrivers and ssh-simplified), we used HSF with the summarization proof rule described in Section 2. For the verification of these sequential C programs, we compare HSF with BLAST <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref> and CPAchecker <ref type="bibr" target="#b6">[7]</ref>. For ntdrivers and sshsimplified, we used BLAST 2.5 with the MathSat solver <ref type="bibr" target="#b8">[9]</ref> and the following standard options: -craig 2 -dfs -predH 7 -nosimplemem -alias "", as suggested by the tool's authors. The use of the MathSat solver led to Blast failing all the Numerical Recipes benchmarks, so instead we report statistics using the latest publicly available version of Blast that uses the Simplify solver. For CPAchecker, we used the revision r3842 from the tool repository and used the predicate abstraction with large block encoding configuration as suggested by the tool's authors.</p><p>For verification of multi-threaded programs, we used HSF with a proof rule based on rely-guarantee reasoning <ref type="bibr" target="#b24">[25]</ref>. We compare HSF with Threader using a reasoning style that is equivalent to the proof rule mentioned above.</p><p>For the verification of functional OCaml programs, we compare HSF with HMC <ref type="bibr" target="#b23">[24]</ref>. The techniques used in HMC extend a liquid type system (i.e., <ref type="bibr" target="#b42">[43]</ref> that requires user-provided logical qualifiers) to enable automatic verification of OCaml programs.</p><p>We used HSF with a termination proof rule for the programs from the last table, Terminating loops. We do not have access to any public tool that can handle termination properties for these C benchmarks.</p><p>In general, HSF is comparable and sometimes significantly faster than state-of-the-art tools specialized to a particular verification proof rule. For all our experiments, the verification tools (including HSF) were run starting with an empty set of predicates, i.e., all predicates needed for verification were discovered automatically. Two limitations of our implementation lead to HSF being slower for the ntdrivers benchmarks: no direct support for equality predicates and the program representation with the transition relation in disjunctive normal form. For example, instead of a single equality predicate (say x = y), HSF tracks two predicates, i.e., x ≥ y and x ≤ y , both during abstraction and refinement. We plan to implement heuristics to handle the high level of branching present in this set of benchmarks. On the other hand, we leverage the uniform representation of the Horn clauses for simplification and inlining steps before the start of the verification process. These transformations lead to substantial savings that are particularly effective in the Numerical Recipes, multi-threaded, and OCaml benchmarks. In total, HSF took approximately 48 minutes to analyze 35 kloc (we exclude the lines of code for the two programs on which HSF timed out).</p><p>We applied our tool on benchmarks from various classes of verification problems, which are usually approached using specialized tools.</p><p>Verification competition HSF(C) is a verifier for C programs developed using the HSF algorithm and based on the summarization proof rule. HSF(C) participated in the TACAS2012 software verification competition <ref type="bibr" target="#b5">[6]</ref> and reached the 3rd place in the largest category ControlFlowInteger and it competed with recent implementations of Blast, CPAchecker and 6 more verification tools. (HSF(C) did not participate in the other categories that required bit-precise reasoning or pointer analysis features not supported by our CIL frontend.) For the ControlFlowInteger category, HSF(C) analyzed 96 benchmarks from five groups: locks, ntdrivers, ntdrivers-simplified, ssh and ssh-simplified. Each of these benchmarks consists of a C program and a safety property, which may or may not hold. HSF timed out on 2 of these programs, verifying and finding counterexamples correctly for all the others, in total 207.2 kloc analyzed in 80 minutes. More details about HSF(C) can be found in the related competition report <ref type="bibr" target="#b15">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related work</head><p>Section 1 points to existing approaches to generate various analyses based on dataflow domains that led to powerful program analysis frameworks <ref type="bibr">[3, 27-29, 31, 34, 47, 51]</ref>.</p><p>Verifiers have also been a target for automated tool construction. XSB <ref type="bibr" target="#b40">[41]</ref> is a programmable fixed-point engine used for implementing model checkers for a concurrent language based on CCS with properties specified in a fragment of mu-calculus. Model checkers have been generated from algebraic specifications of a source language and various fragments of temporal logic <ref type="bibr" target="#b44">[45]</ref>. More recently, verifier generators have been developed for Boolean programs (GETAFIX <ref type="bibr" target="#b48">[49]</ref>) and programs for which Datalog style bottom up inference terminates (µZ <ref type="bibr" target="#b21">[22]</ref>). For programs with unbounded data domains, MatchC <ref type="bibr" target="#b43">[44]</ref> provides a verifier based on matching logic specifications that directly build upon the operational semantics of the source language. The verification is facilitated by (pattern) loop invariants provided by the programmer. In comparison, our approach adds an abstraction refinement loop, which is crucial for handling unbounded datatypes, and allows automation of proof rules for termination and liveness properties.</p><p>HSF synthesizes verifiers that are competitive with state-ofthe-art tools from a recent verification competition, while benefiting from a series of verification algorithms. We build upon predicate abstraction <ref type="bibr" target="#b14">[15]</ref>, counterexample guided abstraction refinement <ref type="bibr" target="#b9">[10]</ref>, interpolation <ref type="bibr" target="#b31">[32]</ref>, ranking function generation <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b37">38]</ref>, and constraint solvers for recursion-free Horn clauses <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b38">39]</ref>.</p><p>Our work provides an intermediate representation for verification tasks in the form of Horn-like clauses with the support for a dwf -predicate. This representation was inspired by the usage of Horn clauses for the inference of environment assumptions of multi-threaded programs <ref type="bibr" target="#b18">[19]</ref>. Boogie provides a different intermediate representation for procedural and object-oriented programs. Boogie represents programs and therefore it requires an intermediate step to generate verification conditions, while Horn clauses encode verification tasks directly as constraints. We believe that generation of Horn clauses from Boogie programs will yield yet another verification tool for Boogie and all of its input languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>We presented a next logical step towards the automatic generation of software verification tools. Our verifier generator takes as input a proof rule written as Horn-like clauses and produces a verifier that automates the proof rule. The experimental evaluation shows that automatically generated verifiers are competitive with existing state-of-the-art verification tools that are manually developed and tuned.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Abstract inference algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Abstract inference, checking, and refinement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Example (cont.) For the inferred constraint s = xs ≤ ys, the procedure MAKECEX(xs ≤ ys, Parent) is invoked at line 22 from Figure 4. As a result, a function Sym is constructed to keep track of the quoted query symbols: {"xs ≤ ys" → s, "xr ≤ 0" → r}. Finally, the procedure MAKECEX returns the following set of recursion-free clauses: {x = xr ∧ x = xs ∧ y = ys ∧ y = x + 1 ∧ "xr ≤ 0"(xr) → "xs ≤ ys"(xs, ys), x = xr ∧ x ≤ y ∧ y ≤ -1 → "xr ≤ 0"(xr)} Procedure ADDPREDS The procedure ADDPREDS is shown in Figure 4. It has Sym in scope and takes as input a solution function whose domain consists of quoted constraints. ADDPREDS uses Sym to translate quoted constraints into original query symbols and add the solution constraints into the corresponding partitions of Preds. Example (cont.) Let us assume that the following solution Σ is returned at line 23 of Figure 4: {"xr ≤ 0"(xr) → xr ≤ 0, "xs ≤ ys"(xs, ys) → xs &lt; ys} . The solution constraints are partitioned as follows: Preds(r) = {xr ≤ 0} and Preds(s) = {xs ≤ ys, xs &lt; ys} . Given these predicates, the next iteration of the abstract inference algorithm computes abstract constraints precise enough to satisfy both property clauses cl 3 and cl 4 from our example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>false program P is safe Figure 5. Summarization rule for programs with procedures.Alternative solving methods In this paper we use predicate abstraction and refinement to solve Horn-like clauses. Predicate abstraction allows us to formulate a practical algorithm, yet the presented formulation is sufficiently general such that a different approximation techniques can be employed instead without any significant changes to HSF. For example, abstract domains based on widening can be used to compute a solution to inference clauses, by choosing the corresponding abstraction function for INFER-</figDesc><table /><note><p><p><p>ABST. Alternatively, we could use model checking techniques, e.g., bounded model checking, to explore the clauses up to a finite bound. Usually, predicates are atomic constraints; however recent approaches to predicate abstraction show that predicates containing Boolean operators can be useful</p><ref type="bibr" target="#b6">[7]</ref></p>.</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Jasmin Blanchette for comments and suggestions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sethi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Compilers: Principles, Techniques, and Tools</title>
		<imprint>
			<publisher>Pearson</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Introduction to set constraint-based program analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A toolkit for constructing type-and constraint-based program analyses</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Types in Compilation</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The SLAM project: debugging system software via static analysis</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Boolean and cartesian abstraction for model checking C programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Competition on software verification -(SV-COMP)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">CPAchecker: A tool for configurable software verification</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Keremoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Linear ranking with reachability</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Bradley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Sipma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Bruttomesso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Franzén</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Griggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
		<title level="m">The MathSAT 4SMT solver</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>CAV</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Counterexample-guided abstraction refinement</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Termination proofs for systems code</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Summarization for termination: no return! Formal Methods in System Design</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">35</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Thread-modular model checking</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Refinement types for ML</title>
		<author>
			<persName><forename type="first">T</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Construction of abstract state graphs with PVS</title>
		<author>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Saïdi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A software verifier based on Horn clauses -(competition contribution)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Grebenshchikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Popeea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
		<author>
			<persName><surname>Hsf(c)</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Solving recursion-free horn clauses over LI+UIF</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Popeea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">APLAS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Threader: A constraintbased verifier for multi-threaded programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Popeea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Predicate abstraction and refinement for verifying multi-threaded programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Popeea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Lazy abstraction</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sutre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Abstractions from proofs</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">µZ-an efficient engine for fixed points with constraints</title>
		<author>
			<persName><forename type="first">K</forename><surname>Hoder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">F-Soft: Software verification platform</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ivancic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Ganai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Shlyakhter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ashar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">HMC: Verifying functional programs using abstract interpreters</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Tentative steps toward a development method for interfering programs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Type reconstruction for general refinement types</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Knowles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Banshee: A scalable constraint-based analysis toolkit</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kodumal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Context-sensitive program analysis as database queries</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Whaley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">B</forename><surname>Livshits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Avots</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Unkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automated soundness proofs for dataflow analyses and transformations via local rules</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">D</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Temporal verification of reactive systems: safety</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">PAG -An efficient program analyzer generator</title>
		<author>
			<persName><forename type="first">F</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">STTT</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">An interpolating theorem prover</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Lazy abstraction with interpolants</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Effective static race detection for Java</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Whaley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">CIL: Intermediate language and tools for analysis and transformation of C programs</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Rahul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CC</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An axiomatic proof technique for parallel programs I</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Owicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Transition invariants</title>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">A complete method for the synthesis of linear ranking functions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
		<editor>VMCAI</editor>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Compositional termination proofs for multi-threaded programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Popeea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">H</forename><surname>Press</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Flannery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Teukolsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">T</forename><surname>Vetterling</surname></persName>
		</author>
		<title level="m">Numerical Recipes in C: The Art of Scientific Computing</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Efficient model checking using tabled resolution</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">S</forename><surname>Ramakrishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">V</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Smolka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Precise interprocedural dataflow analysis via graph reachability</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Horwitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Liquid types</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Rondon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kawaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Matching logic: a new program verification approach</title>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stefanescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Generating model checkers from algebraic specifications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Rus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">V</forename><surname>Wyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Halverson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Constraint solving for interpolation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sofronie-Stokkermans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">High Level Formalisms for Program Flow Analysis and their use in Compiling</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
	<note type="report_type">Technion</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Dependent types from counterexamples</title>
		<author>
			<persName><forename type="first">T</forename><surname>Terauchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Analyzing recursive programs using a fixed-point calculus</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Torre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Parlato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Dependent type inference with interpolants</title>
		<author>
			<persName><forename type="first">H</forename><surname>Unno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PPDP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Cloning-based context-sensitive pointer alias analysis using binary decision diagrams</title>
		<author>
			<persName><forename type="first">J</forename><surname>Whaley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
