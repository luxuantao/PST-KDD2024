<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scala Macros: Let Our Powers Combine! On How Rich Syntax and Static Types Work with Metaprogramming</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Eugene</forename><surname>Burmako</surname></persName>
							<email>eugene.burmako@epfl.ch</email>
							<affiliation key="aff0">
								<orgName type="institution">EPFL</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scala Macros: Let Our Powers Combine! On How Rich Syntax and Static Types Work with Metaprogramming</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8CD504B61925F40F2A7072DBBBEA1945</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features Compile-Time Metaprogramming</term>
					<term>Type Classes</term>
					<term>Domain-Specific Languages</term>
					<term>Scala</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Compile-time metaprogramming has been proven immensely useful enabling programming techniques such as language virtualization, embedding of external domain-specific languages, self-optimization, and boilerplate generation among many others.</p><p>In the recent production release of Scala 2.10 we have introduced macros, an experimental facility which gives its users compile-time metaprogramming powers. Alongside of the mainline release of Scala Macros, we have also introduced other macro flavors, which provide their users with different interfaces and capabilities for interacting with the Scala compiler.</p><p>In this paper, we show how the rich syntax and static types of Scala synergize with macros, through a number of real case studies using our macros (some of which are production systems) such as language virtualization, type providers, materialization of type class instances, type-level programming, and embedding of external DSLs. We explore how macros enable new and unique ways to use pre-existing language features such as implicits, dynamics, annotations, string interpolation and others, showing along the way how these synergies open up new ways of dealing with software development challenges.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Scala '13, Montpellier, France Copyright 2013 ACM 978-1-4503-2064-1 ...$15.00.</p><p>Compile-time metaprogramming can be thought of as the algorithmic construction of programs at compile-time. It's often used with the intent of allowing programmers to generate parts of their programs rather than having to write these program portions themselves. Thus, metaprograms are programs who have a knowledge of other programs, and which can manipulate them.</p><p>Across languages and paradigms, this sort of metaprogramming has been proven immensely useful, acting as an enabling force behind a number of programming techniques, such as: language virtualization (overloading/overriding semantics of the original programming language) <ref type="bibr" target="#b12">[12]</ref>, embedding of external domain-specific languages (tight integration of external DSLs into the host language) <ref type="bibr" target="#b40">[40,</ref><ref type="bibr" target="#b48">48]</ref>, self-optimization (self-application of optimizations based on analysis of the program's own code) <ref type="bibr" target="#b35">[35]</ref>, and boilerplate generation (automatizing repetitive patterns which cannot be readily abstracted away by underlying language) <ref type="bibr" target="#b36">[36,</ref><ref type="bibr" target="#b30">30]</ref>.</p><p>In the recent production release of Scala 2.10 we have introduced Scala Macros <ref type="bibr">[6]</ref> as a new experimental language feature-Scala's realization of compile-time metaprogramming. This new feature enables the compiler to recognize certain methods in Scala programs as metaprograms, or macros, which are then themselves invoked at certain points of compilation. When invoked, macros are provided with a compiler context, which exposes the compiler's representation of the program being compiled along with an API providing certain compiler functionality such as parsing, typechecking and error reporting. Using the API available in the context, macros can influence compilation by, for example, changing the code being compiled or affecting type inference performed by the typechecker.</p><p>The most basic form of compile-time metaprogramming in our system is achieved by def macros, plain methods whose invocations are expanded during compilation. In addition to these def macros, we have identified, implemented, and experimented with different macro flavors: dynamic macros, string interpolation macros, implicit macros, type macros, and macro annotations. Each of these flavors encompasses some different way in which macros are presented to, and can be used by users. We will go on to explore a number of applications, which have proven markedly difficult or impossible to achieve via other means, each of which exercise one of these macro flavors.</p><p>Our contributions are as follows:</p><p>• We describe a number of macro flavors, which are integrated in a principled way alongside of Scala's rich syntax and strong static type system.</p><p>• We provide a comprehensive validation of the utility of these macro flavors through a number of real case studies. We show that macros (a) enable language virtualization, (b) can implement a form of type providers, (c) can be used to automatically generate type class instances, (d) simplify type-level programming, and (e) enable embedding of external domain-specific languages. We additionally go on to show that macros can re-implement non-trivial language features such as code lifting and materialization of type class instances.</p><p>The rest of the paper is organized as follows. Section 2 provides a basic introduction to Scala macros. Section 3 introduces the macro flavors we have experimented with, setting the stage for Section 4, which outlines some of the use cases that these flavors enable and discusses alternative ways of achieving similar functionality. Throughout the paper we deliberately avoid going into the details of our macro system (expansion semantics, integration with the typechecker, handling of hygiene, interplay between macros, etc) in order to focus specifically on how macros work together with Scala's rich syntax and static type system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">INTUITION</head><p>To get acquainted with metaprogramming in Scala, let us explore the simplest flavor of Scala macros, def macros, which were inspired by macros in Lisp <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b13">13]</ref> and Nemerle <ref type="bibr" target="#b36">[36]</ref>.</p><p>Def macros are methods, whose calls are expanded at compile time. Here, expansion means transformation into a code snippet derived from the method being called and its arguments. When such macros are expanded, they operate with a context, which exposes the code to be expanded and routines to manipulate code snippets.</p><p>The def macro context provides the opaque type Code representing untyped code snippets, exposes the macroApplication method, which returns the call being expanded, and defines the q string interpolator, which makes it possible to create and pattern match snippets using the convenient string literal syntax. For example, q"$x + $y" creates a snippet which represents addition of two arguments specified by snippets x and y, and val q"$x + $y" = z pattern matches z as addition and binds x and y to summands. Asserts are the canonical example of familiar functionality, which can be enhanced with def macros. The assert function evaluates the provided boolean expression and raises an error if the result of evaluation is false. The listing below shows a possible implementation of the assert macro: def assert(cond: Boolean, msg: String) = macro impl def impl(c: Context) = { import c.universe._ val q"assert($cond, $msg)" = c.macroApplication q"if (!$cond) raise($msg)" } Here the assert function serves as a façade for the as-sertImpl metaprogram, which takes applications of assert and transforms them into equivalent conditionals. For example, assert(2 + 2 == 4, "does not compute") would be replaced with if (!(2 + 2 == 4)) raise("does not compute").</p><p>Even in this simple form, the macro is arguably more useful than a corresponding function in an eager language such as Scala, because it does not calculate the message unless the asserted condition is violated. The necessity to shield the evaluation of the message for performance reasons usually produces noticeable amounts of boilerplate, which cannot be easily abstracted away. Scala does support lazy evaluation with by-name parameters, but the inner workings of their internal representation might also degrade performance. Macros are able to address the performance problem without downsides.</p><p>In addition to def macros, introduced in Scala 2.10, we have created a fork of Scala <ref type="bibr" target="#b5">[5]</ref>, where we have conceived, implemented, and experimented with a number of other macro flavors-macros which provide different interfaces and capabilities for interacting with the Scala compiler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">HAMMERS: THE MACRO FLAVORS</head><p>Macros realize the notion of textual abstraction <ref type="bibr" target="#b17">[17]</ref>, which consists of recognizing pieces of text that match a specification and replacing them according to a procedure. In Lisp, the origin of macros, programs are represented in a homogeneous way with S-expressions. Therefore recognition and replacement of program fragments can be done uniformly, regardless of whether a transformed fragment represents e.g. an arithmetic expression or a function definition.</p><p>In Scala, a language with rich syntax and static types, compile-time transformations of code naturally distinguish terms and types, expressions and definitions, following the architecture of scalac, the Scala compiler. Therefore it makes sense to recognize the following three realizations of textual abstraction in Scala: term macros, which expand terms, type macros, which expand types, and macro annotations, which expand definitions. In this section we will highlight these three kinds of macros along with their flavors, which appear on the intersection with other language features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Def macros</head><p>The most natural flavor of term macros are def macros, briefly covered in the Section 2. To the programmer, def macros look like regular Scala methods with an unusual property-when a method call in a Scala program is resolved to represent an application of a def macro, that macro definition is expanded by invoking a corresponding metaprogram, called macro implementation. As a convenience, the macro engine automatically destructures the method call being expanded and binds type and value arguments of the call to the corresponding parameters of the metaprogram. The parameters and return type of the macro implementation may be typed, as is the case in the snippet below. In this case, the types of the parameters and the return type will be used to typecheck the arguments and the result of the macro: .. printf("hello %s", "world") Just like regular methods, def macros can be declared either inside or outside of classes, can be monomorphic or polymorphic, and can participate in type inference and implicit search. The only fundamental difference with regular methods is that macros are resolved at compile time, which precludes dynamic dispatch and eta expansion.</p><p>Outside of the context of macros, many existing Scala features are typically desugared to method calls-either to calls to methods with special names like selectDynamic and applyDynamic, or to methods with special meaning like implicits. Existing features that are desugared to method calls are thus unchanged with the exception of the added capability that the inserted method calls may additionally be expanded at compile time. This makes it possible to retain the same user interface and semantics for all of these existing Scala features, while also gaining code generation and compile-time programmability powers provided by macros.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Dynamic macros</head><p>Beginning with version 2.9, Scala has provided a static proxying facility by rewriting operations with non-existent fields and calls to non-existent methods on targets extending the Dynamic trait, into corresponding calls to select-Dynamic, updateDynamic and applyDynamic.</p><p>For example, the following code snippet will print hi.</p><p>class JObject(fs: Map[String, Any]) extends Dynamic { def selectDynamic(name: String) = fs(name) } val jo = new JObject(Map("greeting" -&gt; "hi")) println(jo.greeting)</p><p>If one turns one of the aforementioned methods corresponding to the Dynamic trait into a def macro, it becomes possible to perform on-demand code generation. For example, dynamic macros can be used to reduce the amount of generated code for the situations when comprehensive code generation is impractical <ref type="bibr" target="#b37">[37]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">String interpolation</head><p>String interpolation is a new feature in Scala 2.10, which introduces extensible string literal syntax and establishes desugaring rules to standardize programmability of such literals. val world = "world" s"hello $world" // desugars: StringContext("hello ", "").s(world)</p><p>String interpolation was specifically designed with macros in mind. On the one hand, defined as a regular method, a string interpolator has to perform potentially costly parsing, validation and interpolation at runtime. On the other hand, implementing an interpolator as a macro allows the programmer to optimize these typical tasks of handling external domain-specific languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Implicit macros</head><p>Implicit macros have been discovered to enable materialization of type class instances encoded with implicits <ref type="bibr" target="#b9">[9]</ref>, enabling boilerplate-free generic programming <ref type="bibr" target="#b15">[15]</ref>.</p><p>In the example below, in order to overcome type erasure, the generic method requires an instance of the Manifest type class to be passed along with the x argument. Manifests exist so as to carry the information about static types prior to erasure at compile-time, along to runtime. This makes it possible to know, at runtime, what x's static type is.</p><p>Of course, having to manually provide manifests to call generic methods that need to work around erasure is not an option. Therefore, since version 2.8, implicit search in scalac is hardcoded to automatically synthesize instances of the Manifest type class when no suitable implicit value can be found in scope</p><formula xml:id="formula_0">def generic[T](x: T)(implicit m: Manifest[T]) = ..</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. generic(2) // what the user writes generic(2)(Manifest.Int) // happens under the covers</head><p>By declaring an appropriate implicit def as a macro, as described in Section 4, it becomes possible to unhardcode the part of the compiler that performs materialization of implicits, simplifying the language and reducing maintenance efforts. An important point about this technique is that it naturally scales to arbitrary type classes and target types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Type macros</head><p>Type macros are to types as def macros are to terms. Whenever scalac encounters an occurrence of a type macro, possibly applied, it expands this occurrence according to the underlying macro implementation. In a sense, type macros generalize upon type aliases (which are already capable of type-level expansion), by allowing not only type arguments, but also value arguments, and supporting arbitrary expansion logic.</p><p>In the example below, the Db object extends H2Db("..."). H2Db is a type macro, therefore its application expands by taking a database connection string, generating a trait containing classes and values corresponding to the tables in the database, and returning a reference to the generated trait. As a result, Db ends up inheriting from a synthetic trait, which encapsulates the given database. type H2Db(connString: String) = macro impl def impl(c: Context)(connString: c.Code) = { val schema = loadSchema(connString) val name = schema.dbName + "H2Db" val members = generateCode(schema) c.introduce(q"@synthetic trait $name{ $members }") q"$name" } object Db extends H2Db("jdbc:h2:coffees.h2.db") // expands into: // @synthetic trait CoffeesH2Db$1 { // case class Coffee(...) // val Coffees: Table [</p><formula xml:id="formula_1">Coffee] = ... // ... // } // object Db extends CoffeesH2Db$1 println(Db.Coffees.all)</formula><p>The main use case of type macros is to enable code generation from a schema that's fully available at compile time. Another useful application of type macros is giving terms a promotion to the type level <ref type="bibr" target="#b47">[47]</ref>, either explicitly or triggered by implicit conversions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Macro annotations</head><p>Despite being able to support a fair share of use cases, term macros and type macros alone are not enough to exhaustively cover the syntax of Scala. Along with the need for expression-level and type-level rewritings, there is a necessity in macros that transform definitions.</p><p>Note that the notion of a definition transformer, even though usually in a different form, is available in other languages. For example, Python has decorators <ref type="bibr" target="#b4">[4]</ref> that alter the functionality of functions, methods and classes they are attached to, .NET languages have custom attributes which provide static metadata for their annottees, and the JVM also supports something like custom attributes under the name of annotations.</p><p>Inspired by Nemerle, which makes it possible for specially defined .NET macro attributes to transform annotated definitions, we have developed the notion of macro annotations, definition-transforming macros.</p><formula xml:id="formula_2">class serializable extends MacroAnnotation { def transform = macro impl } def impl(c: Context) = {</formula><p>val q"class $name($params){$members}" = c.annottee val logic = generateCode(c.annottee) val serialize = q"def serialize = $logic" q"class $name($params){ ${members :+ serialize} }" } @serializable class C(x: Int) // expands into: // class C(x: Int) { // def serialize = ... // } A motivational use case for macro annotations is the modularization of the implementations of lazy vals and case classes so as to be able to migrate from the compiler, to the Scala standard library as macros.</p><p>Another use of macro annotations involves transformations necessary to support other macros. For instance, serialization macros in the scala-pickling project <ref type="bibr" target="#b26">[26]</ref> can sometimes benefit from helper methods defined in serialized classes. As another example, LINQ-like techniques <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b43">42</ref>] that rely on compile-time code lifting often have problems with externally defined methods, because such methods might have already been compiled without lifting support. In such cases macro annotations can be used to generate the necessary boilerplate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">NAILS: THE MACRO APPLICATIONS</head><p>In the previous section, we introduced macro flavors exposed to Scala programmers, and now we elaborate on the use cases and techniques enabled by these available macro flavors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Language virtualization</head><p>Language virtualization was historically the first use case for Scala macros and also the direct motivator for adding macros to the language. Since macros have access to code snippets representing their arguments, it becomes possible to analyze these snippets and then overload/override the usual semantics of Scala for them, achieving language virtualization and enabling deep embedding of internal domainspecific languages <ref type="bibr" target="#b43">[42,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b44">44,</ref><ref type="bibr" target="#b16">16]</ref> In particular, language virtualization with macros enables language-integrated queries without the necessity to introduce additional language features such as type-directed lifting <ref type="bibr" target="#b25">[25]</ref> or quotations <ref type="bibr" target="#b8">[8]</ref>.</p><p>By implementing query combinators as def macros, data providers can obtain code snippets representing queries at compile-time (like pred in the example), remember them for runtime (by using either a standard or a custom-written function, which takes a snippet and generates its runtime representation) and then translate lifted queries to a representation specific to the underlying datasource (like in toList in the example).  <ref type="bibr" target="#b38">[38,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b8">8]</ref> with language virtualization is quite interesting, as both techniques have different strengths, which we illustrate below for the use case of language-integrated queries.</p><p>On the one hand, macros allow for earlier error detection (query fragments can be partially validated at compile-time) and have simpler syntax (lifting of queries is done automatically due to the fact that macros operate on code snippets, which are already lifted, and that makes stage annotations unnecessary).</p><p>On the other hand, staging provides superior composability, because macro-based query translation can only transparently lift code inside DSL blocks (i.e. in our case, only the arguments to query combinators). In the example below, the second invocation of the filter macro will only see Ident(TermName("isAffordable")), but not the body of the exernally defined isAffordable function. It is for that reason that the authors of Slick <ref type="bibr" target="#b43">[42]</ref>, a macro-powered data access framework for Scala, support both macro-based and staged query embeddings, with the former being conciser and the latter being more extensible.</p><p>There are also middle-ground approaches, which try to get the best of two worlds. Yin-Yang <ref type="bibr" target="#b16">[16]</ref> uses macros to transparently rewrite shallow DSL programs into equivalent deep DSL programs. Lancet <ref type="bibr" target="#b32">[32]</ref> employs bytecode interpretation and symbolic execution to achieve staging within a JIT compiler. This approach allows to sometimes omit stage annotations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Type providers</head><p>Type providers <ref type="bibr" target="#b37">[37]</ref> are a strongly-typed type-bridging mechanism, which enables information-rich programming in F# 3.0. A type provider is a compile-time facility, which is capable of generating definitions based on static parameters describing datasources. In the example below taken from <ref type="bibr" target="#b37">[37]</ref>, the programmer uses the OData type provider, supplying it with a URL pointing to the data schema, creating a strongly-typed representation of the datasource, which is then used to write a strongly-typed query.</p><p>type NetFlix = ODataService&lt;"..."&gt; let netflix = NetFlix.GetDataContext() let avatarTitles = query { for t in netflix.Titles do where (t.Name.Contains "Avatar") sortBy t.Name take 100 }</p><p>In Scala, type macros provide a way to generate traits, classes and objects containing arbitrary Scala code. Generated definitions can, for example, contain inner classes that represent database table schemas and lazy values that represent tables themselves. When encapsulated in an object, generated inner definitions can then be made visible to the outer world using the standard import mechanism.</p><p>An important feature of type providers in F# is that they generate datasource representations lazily, providing types and their members only when explicitly requested by the compiler. This becomes crucial when generating stronglytyped wrappers for datasource entities is either redundant (from performance and/or reflection standpoints) or infeasible (authors of <ref type="bibr" target="#b37">[37]</ref> mention cases where the generated code is too large for the limits of a .NET process).</p><p>The notion of erased type providers cannot be readily implemented with Scala macros, but there are ways to avoid some of the undesired code generation burden. Instead of generating a class per each entity in a datasource it might be enough to generate a single class for all the entities powered by dynamic macros. As described in Section 3, extending the Dynamic trait and implementing corresponding methods with macros allows for on-demand code generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Materialization of type class instances</head><p>Type classes, originally introduced in <ref type="bibr" target="#b46">[46]</ref> as a principled approach to ad-hoc polymorphism, have proven to be useful to support such techniques as retroactive extension, generic programming and type-level computations.</p><p>As codified in <ref type="bibr" target="#b9">[9]</ref>, type classes can be expressed in Scala using a type-directed implicit parameter passing mechanism. In fact, type classes are very popular in Scala, used to work around erasure <ref type="bibr" target="#b28">[28]</ref>, express generic numeric computations <ref type="bibr" target="#b29">[29]</ref>, support generic programming <ref type="bibr" target="#b33">[33]</ref>, implement serialization <ref type="bibr" target="#b45">[45,</ref><ref type="bibr" target="#b26">26]</ref>, and so on.</p><p>The example below defines the Showable type class, which abstracts over a prettyprinting strategy. The accompanying show method takes two parameters: an explicit one, the target, and an implicit one, which carries the instance of Showable. After being declared like that, show can be called with only the target provided, and scalac will try to infer the corresponding type class instance from the scope of the call site based on the type of the target. If there is a matching implicit value in scope, it will be inferred and compilation will succeed, otherwise a compilation error will occur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>trait Showable[T] { def show(x: T): String } def show[T](x: T)(implicit s: Showable[T]) = s show x</head><p>implicit object IntShowable { def show(x: Int) = x.toString } show(42) // "42" show("42") // compilation error One of the well-known problems with type classes, in general and in particular in Scala, is that instance definitions for similar types are frequently very similar, which leads to proliferation of boilerplate code.</p><p>For example, for a lot of objects prettyprinting means printing the name of their class and the names and values of the fields. Even though this and similar recipes are very concise, in practice it is often impossible to implement them concisely, so the programmer is forced to repeat himself over and over again. The use case at hand can be implemented with runtime reflection, which is available in the Java Virtual Machine, but oftentimes reflection is either too imprecise because of erasure or too slow because of the overhead it imposes. Instead of writing multiple instance definitions, the programmer defines a single materializeShowable macro in the companion object of the Showable type class. Members of a companion object belong to the implicit scope of an associated type class, which means that in cases when the programmer does not provide an instance of Showable, the materializer will be called. Upon being invoked, the materializer can acquire a representation of T and generate the appropriate instance of the Showable type class.</p><p>A nice thing about implicit macros is that they seamlessly meld into the pre-existing infrastructure of implicit search. Such standard features of Scala implicits as multiparametricity and overlapping instances are available to implicit macros without any special effort from the programmer. For example, it is possible to define a non-macro prettyprinter for lists of prettyprintable elements and have it transparently integrated with the macro-based materializer.</p><formula xml:id="formula_3">implicit def listShowable[T] (implicit s: Showable[T]) = new Showable[List[T]] { def show(x: List[T]) = {</formula><p>x.map(s.show).mkString("List(", ", ", ")") } } show(List( <ref type="formula">42</ref>)) // prints: List <ref type="bibr" target="#b43">(42)</ref> In this case, the required instance Showable[List <ref type="bibr">[Int]</ref>] will be provided by listShowable depending on the instance Showable[Int] that will be generated by the materializing macro defined above. Thus, by making macros implicit, they can be used to automate the materialization of type class instances, while at the same time seamlessly integrating with non-macro implicits.</p><p>Related work. It is interesting to compare the macrobased approach with a generic deriving mechanism proposed for Haskell in <ref type="bibr" target="#b20">[20]</ref>.</p><p>Given that the programmer defines an isomorphism between datatypes in the program and their type representations, the deriving mechanism makes it possible to write a generic function that provides an implementation of a derived type class and works across arbitrary isomorphic datatypes. This eliminates most of the boilerplate associated with type class instantiations, and the rest (autogeneration of isomorphisms and the necessity to define trivial type class instances, which delegate to the generic implementation) can be implemented in the compiler.</p><p>If we compare materialization to the aforementioned technique of type class instance generation, it can be seen that in the isomorphism-based approach derived instances are interpreted, relying on a generic programming framework to execute the underlying generic function while traversing the representation of the underlying type. To the contrast, in the macro-based approach the instances are compiled, being specialized to the underlying type at compile time, removing the overhead of interpretation. This brings a natural question of whether it is possible to automatically produce compiled instances from interpreted ones.</p><p>[1] elaborates on a manual translation technique based on compile-time metaprogramming capabilities of Haskell and a collection of code generating combinators, while <ref type="bibr" target="#b21">[21]</ref> outlines a semi-automatic facility that leverages advanced optimization features of Glasgow Haskell Compiler. However, to the best of our knowledge, the question of fully automatic translation remains open.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Type-level programming</head><p>Type-level programming is a technique that involves writing functions that operate on types and using these functions to encode advanced type constraints and achieve precision in type signatures. With this technique it is, for example, possible to express functional dependencies <ref type="bibr" target="#b9">[9]</ref>, something which cannot be achieved in typical variations of System F.</p><p>While type-level programming has proven to be useful in Scala, being a fundamental feature enabling the design of standard collections <ref type="bibr" target="#b28">[28]</ref>, its applications remain limited.</p><p>In our opinion one of the reasons for this is that typelevel functions can only be written using implicits, which provide a clever yet awkward domain-specific language <ref type="bibr" target="#b9">[9]</ref> for expressing general-purpose computations. With implicits being traditionally underspecified and relying on multiple typechecker features playing in concert to express non-trivial computations, it is hard to write robust and portable typelevel functions. Finally there is a problem of performance, which is a consequence of the fact that implicit-based type functions are interpreted, and that interpretation is done by a launching a series of implicit searches, which repeatedly scan the entire implicit scope.</p><p>Compile-time metaprogramming provides an alternative approach to type-level computations, allowing the programmer to encode type manipulations in macros, written in fullfledged Scala, which has simpler semantics and predictable performance in comparison with the language of implicits.</p><p>As an example, we now explore how type-level computations help to verify communication between actors in distributed systems. In Akka [43], a toolkit and runtime for realizing message-passing concurrency on the JVM, actors typically interact using an untyped tell method. Since actors are able to send messages of arbitrary types to one another, type information is lost on the receiver side, and can typically only be recovered using pattern matching, loosening type guarantees. abstract class ActorRef { ... def tell(msg: Any, sender: ActorRef): Unit = ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>... }</head><p>To address the type unsafety problem, Akka provides a channel abstraction and introduces type specifications for channels <ref type="bibr" target="#b19">[19]</ref>. As actors sometimes need to work with multiple message types (e.g. a main communications channel might support both payload messages forwarded to workers and administrative messages overseeing routing or throttling), a simple Channel[Input, Output] signature is not enough. Type specification of a channel should be a typelevel multimap from request types to response types. In Akka such multimaps are represented as heterogenerous lists of tuples. For example, the (A, B) :+: (C, D) :+: TNil type specifies a channel, which can receive messages of types A and C, responding with messages of types B and D correspondingly.</p><p>The challenge in the design of typed channels is to devise a mechanism of typechecking tell, which would check its arguments against the multimap describing the receiver. The facts about the arguments that one might wish to verify range from simple ones such as "does the receiver support a given message type?" and "does the sender support all the reply types of the receiver?" (the reply problem) to more complex ones like "is there a guarantee that on every step of every possible communication between the sender and the receiver, corresponding message types are supported by the corresponding actors?" (the ping-pong problem).</p><p>In order to implement the required type-level predicates, typed channels turn the tell method into a macro. Being able to get a hold of compile-time representations of the types in question (the type of the message and specifications of the sender and the receiver), the tell macro analyzes these types using the straightforward pattern matching and collection operations.</p><p>For example, the replyChannels function presented below takes a channel specification along with a message type and returns a list of possible reply types. replyChannels is then used in ping-pong analysis; if at a certain iteration of the analysis the resulting list is empty, meaning that at some step of some possible communication between the sender and the receiver, some possible message type is not supported by its addressee, the tell macro reports an error. Related work. Despite being easy to implement and debug in comparison with implicits, macros as they stand now are however not necessarily the ultimate type-level programming technique. On the one hand, type-level computations with macros are more natural and more powerful than when written with implicits. Also, an important practical advantage of the macro-based approach is the quality of error messages, which can be tailored to precisely identify and present the problem to the user, in comparison with variations on the generic "could not find implicit value of type X" error, typical to implicit-based designs. But on the other hand, straightforward manipulations with raw type representations (such as e.g. TypeRef deconstructions in the implementation of are quite low-level. The balance between declarativeness of implicits and simplicity of macros has yet to be found.</p><p>An alternative approach to simplification of type-level programming involves incorporating some of features present in dependently-typed languages such as Coq <ref type="bibr" target="#b39">[39]</ref> and Agda <ref type="bibr" target="#b27">[27]</ref> to make certain term-level constructs usable on the type level. In <ref type="bibr" target="#b47">[47]</ref> authors present an extension to Haskell, which automatically promotes value and type constructors to become type and kind constructors, offering considerable gains in expressiveness. It would be interesting to see whether it is possible to use macros, which already know their way around the typechecker, as a vehicle for implementing a similar extension to Scala.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">External domain-specific languages</head><p>External domain-specific languages are relevant even in languages like Scala that were designed to be friendly to internal DSLs. Regular expressions, XML, JSON, HTML, SQL, text templates; all of these can be succinctly represented as programs in external DSLs.</p><p>Without special language or tool support, programs view external DSLs as passive strings, which can be parsed and interpreted, but cannot communicate with the main program. Compile-time metaprogramming provides a way to animate external DSLs, making them able to analyze and possibly influence the enclosing program <ref type="bibr" target="#b40">[40]</ref>.</p><p>In Scala, external DSLs can be embedded into code by the virtue of string interpolation, which standardizes exten-sible string literals and the notion of interpolation both for construction and pattern matching purposes.</p><p>For example, with string interpolation it is possible to define a domain-specific language for JSON, having the convenient json"..." syntax for JSON objects. After the programmer defines the StringContext.json extension method, as shown on the snippet above, scalac will desugar json"..." and json"""...""" literals into calls to that method. Static parts of literals (like brackets and commas in json"[$foo, $bar]") are then available in the parts field of the string context, while interpolated parts (like foo and bar in the previous example) are passed as arguments to the extension method. String interpolation additionally supports pattern matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>implicit class</head><p>Turning the json method into a macro opens a number of possibilities to the DSL author. First of all, it allows to move the cost of parsing to compile-time and to report previously runtime errors at compile time. Secondly, it is often possible to statically validate interpolated expressions against the locations they are interpolated into. For example, the json macro can catch the following typo at compile time by figuring out that it does not make sense to interpolate a number into a location that expects a string: val name = "answer" val value = 42 json"{$value: $value}" Moreover, by the virtue of being run inside the compiler, interpolation macros can interact with the typechecker, asking it for information and even influencing typing. For example, the quasiquoting interpolator <ref type="bibr" target="#b34">[34]</ref> uses the types of its arguments to resolve occasional ambiguities in the grammar of interpolated Scala and also conveys the exact types of the variables bound during pattern matching to the typechecker.</p><p>Integration with the typechecker of the host program can be used to typecheck external DSLs (this direction of research is very appealing in the context of quasiquoting, but one could also imagine interpolations used to generate programs in other programming languages also benefitting from a typechecking facility). This is however non-trivial, because unlike MetaML-like quotations <ref type="bibr" target="#b38">[38,</ref><ref type="bibr" target="#b8">8]</ref>, interpolation-based quasiquotes do not come with the guarantees of typeability (e.g. with such quasiquotes a well-typed program can be assembled from smaller fragments that do not make sense on their own) and can have holes that preclude typechecking.</p><p>The example provided below receives a definition of a method, takes it apart and creates its asynchronous analog by changing the name, wrapping the body in a future and adjusting the return type accordingly. val q"def $name($params): $tpt = $body" = methodDef val tpt1 = if (tpt.isEmpty) tpt else q"Future[$tpt]" val name1 = TermName("async" + name.capitalize) q"def $name1($params): $tpt1 = future { $body }" Note that none of the quasiquotes in the example are typeable as is, yet there is still some room for typechecking by validating whether the future function and the Future type constructor are imported and have appropriate type signatures.</p><p>Related work. Similar approaches to embedding DSLs have been explored in Haskell <ref type="bibr" target="#b22">[22]</ref> and Ocaml <ref type="bibr" target="#b48">[48]</ref>, which also provide ways to declare isolated blocks of code written in an external language and use those blocks for construction and deconstruction of domain-specific objects.</p><p>However it remains to be explored how to integrate external languages into the type system of the host. As shown by the experiences of Template Haskell <ref type="bibr" target="#b35">[35]</ref> and Nemerle <ref type="bibr" target="#b36">[36]</ref>, this is possible for the particular case of quasiquotes, though both approaches are tightly integrated into the corresponding macro systems, so it is not immediately obvious how to generalize them. <ref type="bibr" target="#b10">[10]</ref> introduces SoundExt, an automated and modular mechanism to specify typing rules for domainspecific languages in a framework for language extensibility.</p><p>A promising direction of research into integration of external domain-specific languages involves syntactic language extensibility. Replacing the string interpolation front-end with a more sophisticated mechanism akin to the one described in <ref type="bibr" target="#b11">[11]</ref>, would retain the power of compile-time programmability and integration with the typechecker and also gain the flexibility and modularity of the recent developments in parsers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Language extensibility</head><p>One man's language feature is another man's macro. This principle is well-known to the practitioners of lisps <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b12">12]</ref>, and we have also put it in action in Scala. There already is a handful of pre-existing or suggested language features that we were able or plan to implement with macros, simplifying the Scala compiler: type-directed lifting, autogeneration of type manifests, xml literals, source locations, case classes, lazy values, enumerations, implicit classes and asynchronous computations <ref type="bibr" target="#b42">[41,</ref><ref type="bibr" target="#b44">44]</ref>.</p><p>In the example below we illustrate idiom brackets <ref type="bibr" target="#b24">[24]</ref> for Scala, implemented in a library <ref type="bibr" target="#b18">[18]</ref> with a pair of macros named idiom and $.</p><p>The idiom macro takes a type constructor, which represents an idiom instance, and a code block, which will get some of its subexpressions transformed. The $ macro demarcates transformation boundaries. Inside it, all non-idiom values are wrapped in the pure function defined by the current idiom introduced by the enclosing idiom macro, and all function applications are routed to go through app, again defined by the current idiom (the actual transformation rules are a bit more complicated, but it does not matter for the purposes of the demonstration). Implementations of pure and app are looked up by the $ macro via an implicit search for an instance of the Idiom type class for the current idiom type constructor. $(Some(42) + 1) should equal (Some(43)) $(Some(10) + Some( <ref type="formula">5</ref>)) should equal (Some( <ref type="formula">15</ref>)) } Note how macros have been able to implement functionality, which requires extensions to Haskell <ref type="bibr" target="#b23">[23]</ref> and Idris <ref type="bibr" target="#b3">[3]</ref>, and how implicits make the macro modular and configurable by the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSION AND FUTURE WORK</head><p>We have designed and implemented a compile-time metaprogramming system for Scala, a language with rich syntax and static types.</p><p>The most important aspect of our design is that we have been able to naturally integrate macros with pre-existing language features, preserving their familiar interface and semantics, while at the same time empowering them with code generation and compile-time programmability capabilities.</p><p>Case studies show that with Scala macros it is possible to achieve language virtualization, emulate type providers, materialize type class instances, simplify type-level programming, embed external domain-specific languages and implement non-trivial language features.</p><p>Having experimented with a number of macro flavors and use cases that these flavors enable, we now plan to proceed with finding a minimalistic system which would retain the useful properties of the current design in a flexible and tractable framework. Among the design issues that need to be solved along the way are determining the appropriate detail of the compiler API, specifying hygiene and referential transparency of code manipulations, standardizing the protocol of communication between macros, and coming up with a predictable yet flexible execution model for macros.</p><p>Another interesting direction of future research is exploration of compile-time capabilities that don't quite fit into the model of textual abstraction. For instance, we would like to find a robust way for macros to interact with the compiler's symbol table in order to provide macro writers with predictable APIs to add new classes, change existing ones, introduce variables shared between macro expansions, etc. And yet another topic is finding a robust and predictable way to deeply integrate macros with the typechecker, e.g. granting macros powers to influence type inference.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>def printf(format: String, params: Any*): Unit = macro impl def impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>case class Queryable[T](val query: Query) { def filter(p: T =&gt; Boolean): Queryable[T] = macro QueryableMacros.filter[T] ... def toList: List[T] = { val translatedQuery = query.translate translatedQuery.execute.asInstanceOf[List[T]] } } object QueryableMacros { def filter[T: c.TypeTag](c: Context)(p: c.Code) = { import c.universe._ val T: c.Type = typeOf[T] val callee: c.Code = c.prefix val lifted: c.Code = QueryableMacros.lift(p) q"Queryable[$T]($callee.query.filter($lifted))" } ... } Related work. The comparison of staged approaches</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>case class Coffee(name: String, price: Double) val coffees: Queryable[Coffee] = Db.coffees // closed world coffees.filter(c =&gt; c.price &lt; 10) // open world def isAffordable(c: Coffee) = c.price &lt; 10 coffees.filter(isAffordable)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>class C(x: Int) implicit def cShowable = new Showable[C] { def show(c: C) = "C(" + c.x + ")" } class D(x: Int) implicit def dShowable = new Showable[D] { def show(d: D) = "D(" + d.x + ")" } With implicit macros it becomes possible to eliminate the boilerplate by completely removing the need to manually define type class instances. trait Showable[T] { def show(x: T): String } object Showable { implicit def materialize[T]: Showable[T] = macro .. }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>def replyChannels(l: Type, msg: Type): List[Type] = { def rec(l: Type, acc: List[Type]): List[Type] = { l match { case TypeRef(_, _, TypeRef(_, _, in :: out :: Nil) :: tl :: Nil) if msg &lt;:&lt; in =&gt; rec(tl, if (acc contains out) acc else out :: acc) case TypeRef(_, _, _ :: tl :: Nil) =&gt; rec(tl, acc) case _ =&gt; acc.reverse } } val n = typeOf[Nothing] if (msg =:= n) List(n) else rec(list, Nil) }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>implicit val option = new Idiom[Option] { def pure[A](a: =&gt; A) = Option(a) def app[A, B](ff: Option[A =&gt; B]) = aa =&gt; for (f &lt;-ff; a &lt;-aa) yield f(a) } idiom[Option] {</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Template your boilerplate: using template haskell for efficient generic programming</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dubuisson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012-09-13">2012. 13 September 2012. 2012</date>
			<biblScope unit="page" from="13" to="24" />
			<pubPlace>Copenhagen, Denmark</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Behnke</surname></persName>
		</author>
		<ptr target="https://www.learnscala.de/2013/01/28/en/scala-macros-use-case-teaching-scala" />
		<title level="m">Scala macros use case: Teaching scala</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Implementation of a general purpose programming language with dependent types</title>
		<author>
			<persName><forename type="first">E</forename><surname>Brady</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Optimal syntax for python decorators</title>
		<author>
			<persName><forename type="first">R</forename><surname>Brewer</surname></persName>
		</author>
		<ptr target="http://www.aminus.org/rbre/python/pydec.html" />
		<imprint>
			<date type="published" when="2004-08">Aug. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Burmako</surname></persName>
		</author>
		<ptr target="http://docs.scala-lang.org/overviews/macros/paradise.html" />
		<title level="m">Macro paradise</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Scala macros, a technical report</title>
		<author>
			<persName><forename type="first">E</forename><surname>Burmako</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third International Valentin Turchin Workshop on Metacomputation</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Butcher</surname></persName>
		</author>
		<ptr target="https://github.com/paulbutcher/ScalaMock" />
		<title level="m">Scalamock, native scala mocking framework</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The essence of language-integrated query</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lindley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-03">Mar. 2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Type classes as objects and implicits</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C D S</forename><surname>Oliveira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moors</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="341" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Modular and automated type-soundness verification for language extensions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Erdweg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lorenzen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">SugarJ: library-based syntactic language extensibility</title>
		<author>
			<persName><forename type="first">S</forename><surname>Erdweg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rendel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA &apos;11 proceedings</title>
		<imprint>
			<date type="published" when="2011-10">Oct. 2011</date>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="391" to="406" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Adding types to untyped languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TLDI 2010</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Kennedy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Benton</surname></persName>
		</editor>
		<meeting><address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010-01-23">January 23, 2010. 2010</date>
			<biblScope unit="page" from="1" to="2" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Macros that work together -compile-time bindings, partial expansion, and definition contexts</title>
		<author>
			<persName><forename type="first">M</forename><surname>Flatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Culpepper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Darais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Findler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Funct. Program</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="181" to="216" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scheme with classes, mixins, and traits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Flatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Findler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APLAS 2006</title>
		<meeting><address><addrLine>Sydney, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">November 8-10, 2006. 2006</date>
			<biblScope unit="volume">4279</biblScope>
			<biblScope unit="page" from="270" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Scrap your boilerplate</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L P</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lämmel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APLAS 2003</title>
		<meeting><address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">November 27-29, 2003, 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Yin-yang: Transparent deep embedding of dsls</title>
		<author>
			<persName><forename type="first">V</forename><surname>Jovanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nikolaev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ureche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Stucki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<idno>EPFL-REPORT-185832</idno>
	</analytic>
	<monogr>
		<title level="j">EPFL</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<pubPlace>Lausanne, Switzerland</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Syntactic Extensions in the Programming Language Lisp</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Kohlbecker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986-08">Aug. 1986</date>
			<pubPlace>Bloomington, IN</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Indiana University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Kotelnikov</surname></persName>
		</author>
		<ptr target="https://github.com/aztek/scala-idioms" />
		<title level="m">Scala-idioms, idiom brackets for scala</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Akka, typed channels (experimental), version 2.2-snapshot</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kuhn</surname></persName>
		</author>
		<ptr target="http://doc.akka.io/docs/akka/snapshot/scala/typed-channels.html" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">A generic deriving mechanism for haskell</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Magalhães</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dijkstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jeuring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Löh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010-09-30">2010. 30 September 2010. 2010</date>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="37" to="48" />
			<pubPlace>Baltimore, MD, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Optimizing generics is easy</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Magalhães</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Holdermans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jeuring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Löh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PEPM 2010</title>
		<meeting><address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">January 18-19, 2010. 2010</date>
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Why it&apos;s nice to be quoted: quasiquoting for haskell</title>
		<author>
			<persName><forename type="first">G</forename><surname>Mainland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-09-30">2007. September 30, 2007. 2007</date>
			<biblScope unit="page" from="73" to="82" />
			<pubPlace>Freiburg, Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Mcbride</surname></persName>
		</author>
		<ptr target="https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/" />
		<title level="m">The strathclyde haskell enhancement</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Applicative programming with effects</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mcbride</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Funct. Program</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">LINQ: Reconciling object, relations and XML in the .NET framework</title>
		<author>
			<persName><forename type="first">E</forename><surname>Meijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Beckman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bierman</surname></persName>
		</author>
		<editor>S. Vansummeren</editor>
		<imprint>
			<date type="published" when="2006-06">2006. June 2006</date>
			<biblScope unit="volume">706</biblScope>
			<pubPlace>Chicago, Illinois</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Object-oriented pickler combinators and an extensible generation framework</title>
		<author>
			<persName><forename type="first">H</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Haller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Burmako</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-03">Mar. 2013</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Towards a practical programming language based on dependent type theory</title>
		<author>
			<persName><forename type="first">U</forename><surname>Norell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
		<respStmt>
			<orgName>Chalmers University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Fighting bit rot with types (experience report: Scala collections)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moors</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSTTCS 2009</title>
		<meeting><address><addrLine>India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">December 15-17, 2009. 2009</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="427" to="451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Osheim</surname></persName>
		</author>
		<ptr target="https://github.com/non/spire" />
		<title level="m">Spire, powerful new number types and numeric abstractions for scala</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Producing high-quality software with aspect-oriented programming</title>
		<author>
			<persName><forename type="first">Postsharp</forename><surname>Technologies</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011-07">July 2011</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Lightweight modular staging: a pragmatic approach to runtime code generation and compiled DSLs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Rompf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="127" to="136" />
			<date type="published" when="2011-02">Feb. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Project lancet: Surgical precision jit compilers</title>
		<author>
			<persName><forename type="first">T</forename><surname>Rompf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Sujeeth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-03">Mar. 2013</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">An exploration of generic/polytypic programming in scala</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sabin</surname></persName>
		</author>
		<ptr target="https://github.com/milessabin/shapeless" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Quasiquotes for scala</title>
		<author>
			<persName><forename type="first">D</forename><surname>Shabalin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Burmako</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<idno>EPFL-REPORT-185242</idno>
	</analytic>
	<monogr>
		<title level="j">EPFL</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<pubPlace>Lausanne, Switzerland</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Template metaprogramming for Haskell</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sheard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Peyton</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Haskell Workshop 02</title>
		<imprint>
			<date type="published" when="2002-10">Oct. 2002</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Syntax-extending and type-reflecting macros in an object-oriented language</title>
		<author>
			<persName><forename type="first">K</forename><surname>Skalski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>University of Warsaw, Poland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">F# 3.0 -strongly-typed language support for internet-scale information sources</title>
		<author>
			<persName><forename type="first">D</forename><surname>Syme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Battocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Malayeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mcnamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Quirk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Taveggia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chae</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Matsveyeu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Petricek</surname></persName>
		</author>
		<idno>MSR-TR-2012-101</idno>
		<imprint>
			<date type="published" when="2012-09">september 2012</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><surname>Taha</surname></persName>
		</author>
		<title level="m">Multi-Stage Programming : Its Theory and Applications</title>
		<meeting><address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Oregon Graduate Institute of Science and Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Team</surname></persName>
		</author>
		<ptr target="http://coq.inria.fr" />
		<title level="m">The coq proof assistant</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Tobin-Hochstadt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>St-Amour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Culpepper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Flatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
		<title level="m">Languages as libraries</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title/>
		<author>
			<persName><surname>Pldi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993. 2010</date>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="132" to="141" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Asynchronous programming in c# and vb.net</title>
		<author>
			<persName><forename type="first">M</forename><surname>Torgersen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<ptr target="https://github.com/slick/slick" />
		<title level="m">Scala language integrated connection kit</title>
		<imprint>
			<publisher>Typesafe Inc</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">An asynchronous programming facility for scala</title>
		<ptr target="https://github.com/scala/async" />
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Typesafe Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Unveiling play 2.1 json api -bonus : Json inception</title>
		<author>
			<persName><forename type="first">P</forename><surname>Voitot</surname></persName>
		</author>
		<ptr target="http://mandubian.com/2012/11/11/JSON-inception/" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>based on scala 2.10 macros</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">How to make ad-hoc polymorphism less ad hoc</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Blott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="60" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Giving haskell a promotion</title>
		<author>
			<persName><forename type="first">S</forename><surname>Weirich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Yorgey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cretin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vytiniotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Magalhaes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">Jan. 28 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Fan: compile-time metaprogramming for ocaml</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-04">Apr. 2013</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
