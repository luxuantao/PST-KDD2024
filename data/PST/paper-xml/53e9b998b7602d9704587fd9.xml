<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">INFERRING A TREE FROM LOWEST COMMON ANCESTORS WITH AN APPLICATION TO THE OPTIMIZATION OF RELATIONAL EXPRESSIONS*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Ahoy'</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Y</forename><surname>Sagiv$</surname></persName>
						</author>
						<author>
							<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Szymanskh</surname></persName>
						</author>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois, at Urbana-Champaign</orgName>
								<address>
									<addrLine>5&quot; Bell Laboratories</addrLine>
									<postCode>07974, 61801</postCode>
									<settlement>Murray Hill, Urbana</settlement>
									<region>Illinois</region>
									<country>New Jersey</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
								<address>
									<settlement>Stanford</settlement>
									<region>California</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">INFERRING A TREE FROM LOWEST COMMON ANCESTORS WITH AN APPLICATION TO THE OPTIMIZATION OF RELATIONAL EXPRESSIONS*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6BAF4CD7997D10CE4F809116A06E6B11</idno>
					<note type="submission">Received by the editors July 10, 1979, and in revised form June 3, 1980.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:57+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present an algorithm for constructing a tree to satisfy a set of lineage constraints on common ancestors. We then apply this algorithm to synthesize a relational algebra expression from a simple tableau, a problem arising in the theory of relational databases. Key words, tree algorithms, lowest common ancestors, relational databases, relational algebra, tableaux, query optimization, join minimization 1. A tree discovery problem. In a rooted tree, the lowest common ancestor of two nodes x and y, denoted (x, y), is the node a that is an ancestor of both x and y such that no proper descendant of a is also an ancestor of both x and y. Suppose we are told a tree *</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>T has leaves numbered 1, 2, .., n, and we are given a set of constraints on the lowest common ancestors of certain pairs of leaves. In particular, suppose the constraints are of the form (i,/) &lt; (k, l) where /" and k 1, meaning that the lowest common ancestor of and j is a proper descendant of the lowest common ancestor of k and l. Note that the order of and j in (i, j) and of k and in (k, l) are irrelevant. From a set of constraints of this form, can we reconstruct T, or determine that no such tree exists?</p><p>Example 1. Suppose we are given the constraints (1.1)</p><p>(1, 2) &lt; (1, 3), (3, 4) &lt; (1, 5), (3, 5)&lt; (2, 4). One possible tree T consonant with these constraints is shown in Fig. <ref type="figure">1</ref>. However, if we add the constraint (4, 5) &lt; (1, 2), then it can be shown that no tree can simultaneously satisfy all these constraints. In this paper we give an efficient algorithm for solving this problem. We then present an application of this algorithm to the problem of synthesizing a relational algebra expression from a simple tableau.</p><p>2. Finding the tree. The central idea behind the solution is to determine for a potential tree T the sets of leaves that are descendants of each child of the root of T. Call these sets $1, $2,'", St. We may assume r=&gt;2, since if a tree satisfying a set of constraints exists, we can find another tree satisfying the same set of constraints if we merge each node having one child with that child. In Example 1, we have $1 {1, 2} and Sz {3, 4, 5}.</p><p>There are two conditions that these sets must satisfy for each constraint (i, ])&lt; (k, t).</p><p>(1) and ] must be in the same set. Otherwise (i,/') is the root of T, and the root cannot be a proper descendant of (k, l).</p><p>(2) Either k and are in different sets, or i,/', k and are all together in one set.</p><p>Otherwise (i, ]) cannot be a proper descendant of (k, l). We shall also show that conditions (1) and (2) are sufficient. Thus, if we can partition the nodes into two or more sets satisfying (1) and (2), and if we can recursively build trees for each set, then a tree exists; otherwise, one does not.</p><p>Given a set of constraints C, we define a partition rrc on the leaves 1, 2,..., n using the following rules"</p><p>(1) If (i, ])&lt; (k, l) is a constraint, then and ] are in one block of rrc.</p><p>(2) If (i, ]) &lt; (k, l) is a constraint, and k and are in one block, then i,/', k and are all in the same block.</p><p>(3) No two leaves are in the same block of rrc unless it follows from (1) and <ref type="bibr" target="#b1">(2)</ref>. Example 2. rrc for the constraints given in Example 1 is {1, 2}, {3, 4, 5}. Note that no instance of rule <ref type="bibr" target="#b1">(2)</ref> is used. If we add to (1.1) the constraint <ref type="bibr" target="#b3">(4,</ref><ref type="bibr" target="#b4">5)</ref> &lt; (1, 2), to obtain the set (1, 2) &lt; (1, 3), (3, 4) &lt; (1, 5), (3, 5)&lt; (2, 4), (4, 5) &lt; (1, 2), then by rule (2) the two blocks must be merged, yielding a trivial partition. Since a necessary condition for the existence of a tree is that rrc have more than one block, we can immediately infer that this new set of constraints is not satisfied by any tree.</p><p>In Fig. <ref type="figure">2</ref> we present a recursive algorithm to build a tree T satisfying a set of constraints C on a nonempty set of nodes S. It returns the null tree if no tree exists. The basic idea is to compute the partition rrc, check that it has at least two blocks $1, $2, ', &amp;, r -&gt; 2, and construct the sets of constraints C,,, 1 _-&lt; rn _&lt;-r, such that C, is C restricted to those constraints that involve members of S, only.</p><p>THeOReM 1. If BUILD(S, C) returns a nonnull tree T, then T satisfies the constraint set C.</p><p>Proof. We proceed by induction on the size of S. The basis, one node, is trivial. Suppose then that the theorem is true for all sets smaller than S. Because every recursive invocation of BUILD is applied to a set of strictly smaller size than S, we can assume that all recursive calls of BUILD obey the inductive hypothesis.</p><p>We must show that all constraints in C are satisfied by T. Accordingly, let (i, ]) &lt; (k, l) be an arbitrary member of C. Two cases arise depending on whether k and are in the same or in different blocks.</p><p>Case 1. If k and are in the same block, then all of i,/', k and are in some set S,, by rule (2) in the definition of rrc. Also, (i, ])&lt; (k, 1) is in C,,. By the inductive hypothesis, BUILD(S,, C,,) produces a tree that satisfies (i, ]) &lt; (k, l), so the final tree satisfies that constraint also.</p><p>Case 2. If k and are in different blocks, then (k, l) is the root of T. By rule (1) in the definition of rrc, and ] are in the same block, and therefore (i, ]) is not the root. Thus (i,/') &lt; (k, I) is surely satisfied. procedure BUILD(S, C); if S consists of a single node then return the tree consisting of node alone else begin compute Zrc $1, $2, , Sr;</p><p>if r 1 then return the null tree else for m:= 1 to r do begin C. := {(i, j) &lt; (k, l) in C]i,f,k,1 are in S.};</p><p>Tn := BUILD(S,., C.); if T. the null tree then return the null tree end;</p><p>/. if we reach here a tree exists ./ let T be the tree with a new node for its root and whose children are the roots of T,., 1 =&lt; m -&lt;_ r; return T end end BUILD FIG. 2. The procedure BUILD.</p><p>LEMMA 1. Let T be any tree satisfying constraint set C. Then each block of 7rc is wholly contained within a subtree rooted at some child of the root of T.  Proof. Let us consider any fixed order in which we may apply rules (1) and (2) to construct 7r:, starting with each leaf in a block by itself. We shall show, by induction on the number of applications of the rules, that each block of the partition being formed always lies wholly within the subtree of some child of the root of T.</p><p>Basis. Zero applications. Each leaf is in a block by itself, so the result is trivial. Induction. Case 1. Rule (1) is applied to a constraint (i, f)&lt;(k, l) causing the blocks containing and j, say B1 and B2, to be merged. By induction, all the nodes in B1 and B2 are contained, respectively, in the subtrees rooted at n and nz, two children of the root. If n n2, then (i, j) is the root of T. But then no constraint of the form (i, ) &lt; (k, l) can be satisfied by T, violating our assumption that T satisfied C. We must therefore have rtx n: and all the nodes in B tO Bz are descendants of the same child of the root. Case 2. Rule (2) is applied to constraint (i, )&lt; (k, l) because k and are in the same block. Let B and Bz be the blocks containing and/', and let B3 be the block containing k and I. By induction, there exist nodes nx, nz and n3, children of the root of T, that are the roots of subtrees containing all the nodes of B1, Bz and B3 respectively.</p><p>Clearly, n l-nz, for otherwise (i, ) is the root of T and cannot possibly be a proper descendant of (k, l) as required by the constraint. If nx n3, then (i, j) and (k, l) are descendants of different children of the root, again violating the constraint. We must therefore have n-n2 n3 and all the nodes in Ba LIBz LIB3 are descendants of the same child of the root. [3 TI-IEOREM 2. If there is a tree satisfying the constraint set C, then BUILD(S, C) returns some nonnull tree. Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php Proof. Suppose not, and assume that T with the constraint set C is as small a counterexample as there is. Suppose BUILD(S, C) returns the null tree. Then either 7rc has only one block, or BUILD(S,, C,) returns the null tree for some m. In the first case, it follows from Lemma 1 that the root of T has only one child. But then T', which is T with the root removed, provides a smaller counterexample to the theorem.</p><p>In the second case, where BUILD(S,, C,,) returns the null tree, let S,, be contained in the subtree rooted at child n of the root of T. Define T' to be the subtree of T with root n, after deleting all leaves not in $,, and any interior nodes none of whose descendant leaves are in $,,. Then T' satisfies C,,, T' is smaller than T, yet BUILD(S,, C,,) does not construct a nonnull tree. Thus T together with C was not the smallest counterexample to the theorem, as supposed.</p><p>As a single node cannot be counterexample to the theorem, we conclude that the theorem has no smallest counterexample. Since a counterexample, if one exists, is finite, there can be no counterexample at all, from which we conclude the theorem.</p><p>Example 3. Suppose we are given the constraints (1,3)&lt;(2,5)</p><p>(1, 4)&lt; (3, 7)  (2, 6) &lt; (4, 8) (3, 4) &lt; (2, 6) (4, 5) &lt; (1, 9) (7, 8) &lt; (2, 10) (7, 8) &lt; (7, 10) (8,10) &lt; (5, 9).</p><p>Rule (1) produces partition {1, 3, 4, 5}, {2, 6}, {7, 8, 10}, {9}. By Rule (2), we must merge the first two blocks because of constraint (3, 4) &lt; (2, 6). Thus the tree constructed top down begins as in Fig. <ref type="figure" target="#fig_1">3</ref>(a). The constraints germane to {1, 2, , 6} are (1, 3) &lt; (2, 5)</p><p>and (3, 4)&lt; (2, 6), while only (7, 8)&lt; (7, 10) is germane to {7, 8, 10}. The partition for the former is {1, 3, 4}, {2}, {5}, {6}, and for the latter {7, 8}, {10}. The second level of tree construction is shown in Fig. <ref type="figure" target="#fig_1">3(b)</ref>. No constraints are applicable to any of the remaining blocks, so at the next level, each block of more than one leaf is partitioned into singletons. The final tree is shown in Fig. <ref type="figure" target="#fig_1">3</ref>(c). I-1 3. Complexity of the tree synthesis algorithm. The running time of the tree synthesis algorithm of 2 is highly dependent on the method used to partition the set of constraints. In this section, we shall first analyze the running time of BUILD as a Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php function of n, the number of constraints, and f, a function specifying the time needed to partition a set of constraints. We shall see that the use of the naive partitioning algorithm leads to an O(n3) implementation of BUILD. By using a more sophisticated partitioning algorithm, the overall running time can be reduced to O(n 2 log n).</p><p>Moreover, by imposing the restriction that all constraints be of the form (i, ]) &lt; (i, k), we can further reduce the running time to O(n2). Section 4 of this paper presents a database application in which problems of this restricted form arise naturally. LEMMA 2. Let f(n) be the time needed to partition a set of n constraints subject to rules (1) and (2) of the previous section. Iff is monotonically nondecreasing, then the time consumed by BUILD when applied to a set of n constraints is O(nf(n)).</p><p>Proof. The worst-case running time occurs when the algorithm succeeds in synthesizing a nonnull tree, so we shall restrict our attention to analyzing this case. We shall proceed by assigning a cost to each node of the tree and summing the costs.</p><p>Since the top level call on BUILD involves n constraints, each of which can introduce at most 4n leaves into the tree, the synthesized tree has at most 4n leaves. (Leaves not mentioned in any constraint can be made children of the root of the final tree.) Because the branching factor at each internal node is at least 2, the number of internal nodes cannot exceed 4n 1.</p><p>At each internal node, BUILD partitions some subset of the original constraints and then spends a constant amount of time (exclusive of recursive calls) processing each block of the partition. Since f is monotonic, f(n) is certainly an upper bound on the cost of performing each partition. Moreover, since f must grow at least linearly with its argument, we can neglect the cost of distributing the constraints over the blocks of the partition when compared with f(n) and charge each internal node O(f(n)) units of time. Thus the time charged to all internal nodes is O((4n 1)f(n)) O(nf(n)). Since BUILD spends a constant amount of time at each leaf, the contribution of the leaves to the running time is O(n) for a total over all nodes of O(nf(n)). 71  The problem of producing a fast implementation of BUILD thus reduces to one of producing a fast partitioning algorithm. Let us first address this problem for the special case mentioned earlier.</p><p>THEOREM 3. If all constraints are of the form (i, ])&lt; (i, k), then BUILD can be implemented to run in O(n 2) time, where n is the number of constraints.</p><p>Proof. By Lemma 2, it suffices to show how to partition a set of n constraints in O(n) time. When all constraints are of the form (i, ])&lt; (i, k), rule (2) of the partition constructing algorithm of 2 need never be applied explicitly. To see this, suppose that and k are in the same block. By rule (1), and ] must also be in the same block, and thus by transitivity, i, ], and k are all in the same block. Accordingly, it suffices to implement rule (1) alone.</p><p>If we take each leaf appearing in one or more constraints to be a node, and each constraint (i, ]) &lt; (i, k) to represent an edge between and ], then we shall have a graph (actually, a multigraph) whose connected components represent the blocks of the partition we are looking for. Since it is easy to find connected components in time proportional to the number of edges [1], and the graph described above has at most n edges, we conclude that partitioning can be done in O(n) time. (3   THEOREM 4. If no restrictions are placed on the form of the constraints, then BUILD can be implemented to run in O(n 2 log n) time.</p><p>Proof. By Lemma 2, it suffices to show how to partition a set of n constraints in O(n log n) time. Blocks of the partition will be maintained using a set merging algorithm that supports the following operations"</p><p>(1) Given an element i, find the set that currently belongs to.</p><p>(2) Given two sets, merge them together and assign them a common name. The particular set merging algorithm we need was originally described in <ref type="bibr" target="#b6">[7]</ref> and operates as follows. An array S is maintained so that at all times S[i] gives the name of the set currently containing element i. This allows each find operation to be performed in constant time. Each set is represented by a linked list of the current members of the set and an integer specifying the cardinality of the set. Now suppose we want to merge sets and ]. Without loss of generality, let set have more members than set/'. Change S[k to for each element k in set/'. Then append the list of elements of set/" to the list of elements for set i. Finally, update the length of the new set i. It is easy to see that a merge operation can be performed in time proportional to the size of the smaller of the two sets being merged. Thus, starting with a collection of singleton sets, a sequence of n merges can be performed in time O(n log n).</p><p>Returning to the constraint partitioning algorithm, we can use the rules defining the partition zrc to transform a given set of constraints into a set of commands of the form ], which means that and/" must appear in the same block, and a set of implications of the form p =-q =), r--s, which means that if p is in the same block as q, then r must be in the same block as s. In the algorithm, each block B of the partition will be associated with a list Ln consisting of all those implications of the form p q =&gt; r s for which either p or q is currently in B. We assume that the length of each list is stored with it and is available in constant time. We shall also employ a queue O of commands that remain to be processed. A command is processed by checking that the nodes involved are in the same block of the partition. If not, a merge operation is performed on the appropriate blocks and the algorithm then examines (by traversing the appro- priate list Ln) all implications, whose left side involves nodes in the blocks being merged. When an implication is examined, it can cause another command (i.e., its right side) to be generated and placed on O. The algorithm is shown in Fig. <ref type="figure">4</ref>.</p><p>Before proceeding, notice that each constraint gives rise to one command, which is immediately placed on O in step (2), and two copies of an implication, say p q =), r s, which are placed on different lists. At most one of these copies will eventually cause the command r s to be placed on Q, and this will happen when a merge operation first causes p and q to become elements of the same block. Thus the total number of commands enqueued is at most 2n (n in step (2) and n in step (3)).</p><p>The time spent in steps (1) and ( <ref type="formula">2</ref>) is clearly O(n). The time expended by the inner for loop of Step (3) is O(n log n) because each copy of an implication is only considered in this loop when it is being moved from a shorter to a longer list. Since no more than n-1 merges can be performed, no implication can be moved more than log: n-1 times. Thus the amount of work done in the inner for loop is O(n log n). The time spent in the rest of step (3), exclusive of the inner for loop, is expended in removing at most 2n commands from Q, doing at most O(n) finds and comparisons, and performing at most n 1 merges. This clearly requires O(n log n) time, and so the total time used by the algorithm in O(n log n). 71</p><p>Extensions. The tree synthesis algorithm of 2 and 3 can be extended to handle a more general set of constraints than the ones considered so far. More specifically, we can handle any collection of constraints of the following types'</p><p>(1) (i, j) &lt; (k, l), (2) (i,/') _-&lt; (k, l), (3) (i, j)= (k, l) (4) (i, j) is comparable to (k, l), (5) (i, j) is incomparable to (k, l). In the above constraints, two nodes of a tree are said to be comparable if one is the ancestor of the other, and incomparable otherwise. (1) for each leaf mentioned in a constraint do begin set Ll to the empty list; set S[l] to l; end;</p><p>(2) for each constraint (i, j) &lt; (k, l) do begin let c be the implication k =-=), l; add c to Lskl; add c to Lst; add the command =/' to Q; end;</p><p>(3) while Q is not empty do begin remove a command p---q from Q; if Sip] S[q] then begin let L be the shorter of Ls and Ls;</p><p>for each implication u -= v ==&gt; x =-y on L do if one of u and v is in and the other is in S[q] then add the command x y to append Lstp to Ls[q]; merge Sip] and S[q]; end; end; FIG. 4. The general case partitioning algorithm.</p><p>As before, there exists a set of rules for partitioning the leaves of the tree into disjoint sets so that the leaves in each set are descendants of a different child of the root. The appropriate set of rules are" (1) If (i, ])&lt; (k, l) is a constraint, then and/" are in the same block of rc.</p><p>(2) If (i,/') &lt; (k, l) is a constraint, and k and are in the same block, then i,/', k and are all in the same block.</p><p>(3) If (i,/') &lt;-(k, l) is a constraint, and k and are in the same block, then i,/', k and all in the same block.</p><p>(4) If (i,/') (k, l) is a constraint, and and/' are in the same block (or k and are in the same block), then i,/', k and are all in the same block.</p><p>(5) If (i, ]) is comparable to (k, l) is a constraint, and j are all in the same block, and k and are in the same block, then i, j, k and are all in the same block. (6) If (i, ]) is incomparable to (k, l) is a constraint, then is in the same block as ], and k is in the same block as I.</p><p>(7) No two leaves are in the same block of 7rc unless it follows from (1) through <ref type="bibr" target="#b5">(6)</ref>.</p><p>These rules can shown to be both necessary and sufficient conditions for construc- ting a tree obeying a set of constraints (if one exists) using the procedure BUILD. Each rule involves adding one case to each of Theorem 1 and Lemma 1. A straightforward modification of the partitioning algorithm in 3 allows us to handle this wider class of constraints without increasing the running time claimed in Theorem 3. For a further generalization of this problem, see <ref type="bibr" target="#b5">[6]</ref>. 4. An application to relational database queries. In <ref type="bibr" target="#b4">[5]</ref>, Codd introduced rela- tional algebra as a notation for expressing database queries. In <ref type="bibr" target="#b1">[2]</ref>, [3] a class of relational expressions called SPJ-expressions was investigated in which the operands of an expression are relations and the operators are the relational algebra operations select, project and natural join.</p><p>In <ref type="bibr" target="#b2">[3]</ref> it was shown that the value of an SPJ-expression can be represented in terms of a two-dimensional matrix called a tableau. A join-minimization procedure for SPJ-expressions was outlined in which a tableau is constructed from a given SPJexpression E. The tableau is then transformed into an equivalent minimum row tableau. From this minimum row tableau we can then construct an SPJ-expression that has the fewest joins of any relational expression equivalent to the original expression E.</p><p>Unfortunately, this optimization procedure may be computationally expensive in that it is NP-complete to minimize the number of rows in a tableau. However, for the important special case of SPJ-expressions with simple tableaux this optimization method can be carried out efficiently. A simple tableau can be minimized in polynomial time <ref type="bibr" target="#b2">[3]</ref>. In the remainder of this paper we shall complete the details of the optimization procedure by showing how to use the tree discovery algorithm of 2 to construct an SPJ-expression from a simple tableau in polynomial time. By way of contrast, Yannak- akis and Papadimitriou have shown that it is NP-complete to determine whether an arbitrary tableau has an equivalent SPJ-expression <ref type="bibr" target="#b10">[11]</ref>.</p><p>SPJ-expressions. We assume a data base consisting of a set of two-dimensional tables called relations. The columns of a table are labeled by distinct attributes and the entries in each column are drawn from a fixed domain for that column's attribute. The ordering of the columns of a table is unimportant. Each row of a table is a mapping from the table's attributes to their respective domains. A row is often called a tuple or record. If r is a relation that is defined on a set of attributes that includes A, and if/x is a tuple of r, then/x (A) is the value of the A-component of A relation scheme is the set of attributes labeling the columns of a table. When there is no ambiguity, we shall use the relation scheme itself as the name of the table. A relation is just the "current value" of a relation scheme. The relation is said to be defined on the set of attributes of the relation scheme. The operators select, project and join are defined as follows.</p><p>(1) Select. Let r be a relation on a set of attributes X, A an attribute in X, and c a value from the domain of A. Then the selection A c applied to r, written O'A= (r), is the subset of r having value c for attribute A.</p><p>(2) Project. Let r be a relation on a set of attributes X. Let Y be a subset of X. We define y(r), the projection of r onto Y, to be the relation obtained by removing all the components of the tuples of r that do not belong to Y and removing duplicate tuples.</p><p>(3) Join. The join operator, denoted by N, permits two relations to be combined into a single relation whose attributes are the union of the attributes of the two argument relations. Let R1 and RE be two relation schemes with values rl and rE.</p><p>Then rl N r2 {/xl/x is a tuple defined on the attributes in R1 [-J R2, and there exist tuples vl in rl and v2 in r2, such that vl(A)= (A) for all A in R1 and v2(A)= (A) for all A in R2}. An SPJ-expression is an expression in which the operands are relation schemes and the operators are select, project and join. An SPJ-expression with operands RI, R2," ",Rn evaluates to a single relation when relations are assigned to R1, R2, ,R,. A tableau is a matrix in which the columns correspond to the attributes of the universe in a fixed order. The first row of the matrix is called the summary of the tableau. The remaining rows are exclusively called rows. The general idea is that a tableau is a shorthand for a set former {al''' anlO(al,"', an)} that defines the value of a relational expression. In the set former 0 does not have any ai's as bound variables. To simplify later discussion we shall adopt the following conventions regarding tableaux. The symbols appearing in a tableau are chosen from"</p><p>(1) Distinguished variables, for which we use a's, possibly with subscripts. These correspond to the symbols to the left of the bar in .</p><p>(2) Nondistinguished variables, for which we generally use b's. These are the bound variables appearing in the set former.</p><p>(3) Constants, for which we use c's or nonnegative integers. (4) Blank.</p><p>The summary of a tableau may contain only distinguished variables, constants, and blanks. The rows of a tableau may contain variables (distinguished and nondistin- guished) and constants. When tableaux represent SPJ-expressions, we can assume that the same variable does not appear in two different columns of a tableau, and that a distinguished variable does not appear in a column unless it also appears in the summary of that column.</p><p>Let Tbe a tableau and let $ be the set of all symbols appearing in T (i.e., variables and constants). A valuation p for T associates with each symbol of $ a constant, such that if c is a constant in $, then p (c) c. We extend p to the summary and rows of T as follows. Let Wo be the summary of T, and wl, w2, , wn the rows. Then p(wi) is the tuple obtained by substituting p(v) for every variable v that appears in wi.</p><p>A tableau defines a mapping from universal instances (relations over ttie set of all attributes) to relations over a certain subset of the attributes, called the target relation scheme, in the following way. If T is a tableau and I an instance, then T(I) is the relation on the attributes whose columns are nonblank in the summary, such that T(I) {p(Wo)[for some valuation p we have p(wi) in I for 1 &lt;_--&lt; n}. We conventionally show the summary first, with a line below it. We can interpret this tableau as defining the relation on AB T(I) {aa21(::lbl)(:lb2)(:lb3)(:lb4) such that alblb3 is in I and b2a21 is in I and b2btb4 is in I} given any universal instance L Equivalence. Two SPJ-expressions EI(RI,'", R,) and E2($1,'"', Sn) are said to be equivalent if, for all universal instances L E(r, , r,) E2(s, , sn), where r ZrR, (I), 1 --&lt; --&lt; m, and s 7rs, (I), 1 -&lt; -&lt; n. In words, Et is equivalent to E2 if they represent the same mapping on universal instances.</p><p>Similarly, two tableaux T1 and T2 are equivalent if, for all L T(I)= T:(I). Likewise, a tableau T is equivalent to an expression E(R,..., R) if, for all L T(I) E(r,. ., r) where ri 7rR,(I) for 1 &lt;--&lt;--n.</p><p>Representation oI SPJ-expressions by tableaux. Given an SPJ-expression E, we can construct a tableau T to represent the expression in the following manner. The construction proceeds inductively on the form of E.</p><p>(1) If E is a single relation scheme R, then the tableau T for E has one row and a summary such that: (i) If A is an attribute in R, then in the column for A tableau T has the same distinguished variable in the summary and row.</p><p>(ii) If A is not in R, then its column has a blank in the summary and a new nondistinguished variable in the row.</p><p>(2a) Suppose E is of the form O'A=c(E1), and we have constructed T, the tableau for El.</p><p>(i) if the summary for E has blank in the column for A, then T T, where T is a tableau that maps any universal instance into the empty set.</p><p>(ii) If there is a constant c' c in the summary column for A, then T-T. If c c', then T T1.</p><p>(iii) If T has a distinguished variable a in the summary column for A, the tableau T for E is constructed by replacing a by c wherever it appears in T1.</p><p>(2b) Suppose E is of the form 7rx(E), and T1 is the tableau for E. The tableau T for E is constructed by replacing nonblank symbols by blanks in the summary of T for those columns whose attributes are not in X. Distinguished variables in the rows of those columns are consistently replaced with new nondistinguished variables.</p><p>(2c) Suppose E is of the form Ex NEE and T and T2 are the tableaux for E and E2, respectively. Let Sx and $2 be the symbols of T and T2, respectively. Without loss of generality, we may take S and $2 to have disjoint sets of nondistinguished variables, but identical distinguished variables in corresponding columns.</p><p>(i) If T and T2 have some column in which their summaries have distinct constants, then T-Te.</p><p>(ii) If no corresponding positions in the summaries have distinct constants, the set of rows of the tableau T for E consists of the union of all the rows of T and T2. The summary of T has in a given column:</p><p>(a) The constant c if one or both of TI and T2 have c in that column's summary. In this case we also replace any distinguished variable in that column by c.</p><p>(b) The distinguished variable a if (a) does not apply, but one or both of T and T2 have a in that column's summary.</p><p>(c) Blank, otherwise. It is not hard to show that the tableau constructed by this procedure is equivalent to the given expression. Note that the number of rows in the resulting tableau is one more than the number of join operators in the original expression.</p><p>Example 5. Let A, B and C be the attributes, in that order, and suppose we are given the expression 7rA(o'=o(ABNBC)). By Rule (1), the tableaux for AB and BC  A tableau is simple if in any column with a repeated nondistin- guished variable there is no other symbol that appears in more than one row. For simple tableaux there exists a polynomial-time equivalence algorithm, whereas for general tableaux the equivalence problem is NP-complete <ref type="bibr" target="#b2">[3]</ref>. In practice, it is not easy to find an SPJ-expression with a nonsimple tableau. The expression zrAc(ABBC)N(ABNBD) is a minimal expression that gives rise to a nonsimple tableau. The tableau is shown in Fig. <ref type="figure" target="#fig_6">5</ref>. The rows in the column for B have repeated nondistinguished and distinguished variables. 5. Synthesis of relational expressions |rom tableaux. In this section we shall present an algorithm for constructing a relational expression from a simple tableau. To help clarify the presentation, we shall portray a relational expression by its parse tree. Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php Although many relational expressions can be synthesized from the same tableau, the relational expression produced by our algorithm has a parse tree with the following properties:</p><p>(1) Each project operation is done as soon as possible (i.e., is as low in the parse tree as possible).</p><p>(2) Each select operation is applied to a leaf.</p><p>These two points are motivated by efficiency considerations; performing projections and selections as early as possible can significantly reduce the size of intermediate relations computed in the evaluation of a relational expression. We should point out, however, that to evaluate a relational expression efficiently in practice, one must take into account many parameters of the database environment such as the costs of the various data access methods that are available and the nature of the data structures used to store the relations. See <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b11">[12]</ref> for more discussion of query evaluation strategies.</p><p>We shall assume the leaves of a parse tree are labeled by relation schemes. In the absence of other information, we can choose as leaf labels relation schemes having as few attributes as possible. For example, the expressions 7"g A (A), 7"l'A (AB), 7rA (A C), and 7"gA (ABC) all have the same tableau. Of these expressions, 71"3 (A) is minimal in that the other expressions can be produced from it by simply adding one or more attributes to the relation scheme which is the operand of the expression.</p><p>For the application considered here, however, the problem of deciding which relation scheme corresponds to which leaf of the tree vanishes. Here we are interested in minimizing the number of joins in a given SPJ-expression. One way to perform this optimization is to construct a tableau for the given expression, minimize the number of rows in the tableau using the procedure in <ref type="bibr" target="#b1">[2]</ref>, and then convert the resulting tableau back to an SPJ-expression. The number of rows in the tableau is one more than the number of joins in the associated expression. In the process, it is easy to keep track of which rows correspond to which operands of the original expression. Since the tableau minimization algorithm of <ref type="bibr" target="#b1">[2]</ref> can only delete rows but never change one, we can associate each leaf of the tree eventually produced with a relation scheme appearing in the original expression. Accordingly, we shall henceforth assume that each row of the tableaux under consideration is identified with some given relation scheme.</p><p>Let us initially consider a simple tableau T with no constants in the summary, although constants may appear in the rows. Let A be a column in which rows and/" have the same nondistinguished variable, and k a row with a distinguished variable in column A 1. If T comes from an expression, consider the parse tree P of that expression.</p><p>Each leaf of P corresponds to an operand relation scheme associated with some row of the tableau. Suppose that in P (i, ]) is not a proper descendant of (i, k). Since (i, j) and (i, k) cannot be independent, it follows that (i, k) must be a descendant of (i,/'). Then consider the tableau constructed for the subexpression rooted at the node (i, k) of P. In particular, which rows have the distinguished variable in column A ? Surely k does, as the distinguished variable appears there in tableau T, and in the tableau construction algorithm a nondistinguished variable is never changed into a distinguished variable. If row does not also have the distinguished variable in column A, then the variables in In a simple tableau, k will be unique, but we can relax the "simple" constraint to the point that a column with a repeated nondistinguished variable can have a repeated distinguished variable or constant, but not another repeated nondistinguished variable. Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php rows and /" cannot be equated when we create the tableau for the expression represented by node (i,f). However, if both rows and k have the distinguished variable, then they must have the same variable in T, a contradiction. We can therefore infer that (i, f) &lt; (i, k). Arguing similarly, we can show that (i, j) &lt; (j, k). From these two observations we are led to the conclusion" (*) Suppose P is the parse tree of an expression yielding tableau T. If rows and j of T have the same nondistinguished variable in column A, and row k has a distinguished variable in column A, then we must have (i,/') &lt; (i, k) and hence (i, j) &lt; (j, k) in P.</p><p>That this is sufficient for simple tableaux is expressed in the next theorem.</p><p>THEOREM 5. Let Tbe a tableau having no constants in the summary and no column with two or more repeated nondistinguished variables. Then Tcomes from an expression if and only if the set of constraints defined in (*) determines a tree. Proof. Only if. We argued above that if T comes from an expression, the constraints (*) must be satisfied.</p><p>If. Using the algorithm of 2, suppose (*) determines a tree P. We shall show how to convert this tree into an expression for T. This expression may use join as an n-ary operator. But since binary join is associative and commutative, nothing is lost by doing so, and the n-ary joins can be replaced by binary joins in any order.</p><p>The construction proceeds by induction on the height of a node in the tree P. For the inductive hypothesis we shall construct for each subtree an expression yielding a tableau whose rows are the rows of T that are leaves of the subtree, but with repeated nondistinguished variables, all of whose occurrences do not appear among these rows, replaced by distinguished variables. The conditions on T guarantee that no conflicts arise, that is, no column needs more than one distinguished variable.</p><p>Basis. Height O. The node is a leaf labeled by a relation scheme R, and identified with some row i. Row cannot have a constant or distinguished variable in columns other than those for attributes in R. (We assume the relation scheme R containing all attributes in which row has a distinguished variable, constant, or repeated nondistin- guished variable is a legitimate operand. If not all relation schemes are permissible, then it is easy to check for tableaux with illegal rows.)</p><p>If row has constant c in column A, then apply rA--c to R. Then project onto those attributes in whose column row has either a distinguished variable or a repeated nondistinguished variable. The result is an expression whose tableau has one row, which is row with repeated nondistinguished variables replaced by distinguished variable,s. Induction. We construct the expression for node n from the expressions El, E2, E, representing the children of node n. Begin by joining El, E2, E.</p><p>Then project onto those attributes A in whose columns either (1) some descendant leaf of n is a row with a distinguished variable in column A, or (2) some, but not all, of the occurrences of the repeated nondistinguished variable in column A are found in rows which are descendants of n. The result is easily seen to satisfy the inductive hypothesis, as in each column A, variables that appear in two or more of the E's and that must become the repeated nondistinguished variable for column A are distinguished in the tableaux for the Ei's and are therefore equated in the join.</p><p>Finally, the inductive hypothesis applied to the root implies that the constructed expression has tableau T. The proof of Theorem 5 contains the algorithm to construct an expression from a tableau. The following example illustrates the procedure. We assume that rows 1, 2, 3 and 4 come from relation schemes (AB), (BC), (CD) and (BC), respectively. Since bl is the only repeated nondistinguished variable in the tableau, the only constraints are (1, 2)&lt; (1, 4) and (1, 2)&lt; (2, 4). Applying the pro- cedure BUILD to these constraints we obtain the tree shown in Fig. <ref type="figure" target="#fig_8">6</ref>. Using the construction in the basis for node n5 we obtain the expression zrB(crA=o(AB)), while for the leaves//6,//3 and//4, the expressions (BC), (CD) and (BC)</p><p>suffice. Using the construction in the inductive step for node n2 we obtain the expression zrc(zrB(rA=o(AB))N(BC)). We project onto column C because only column C has a distinguished variable in rows 1 or 2, and all occurrences of the repeated nondistin- guished variable b are found in these rows. The expression for n is obtained by joining the above expression with (CD) and (BC) in any order. We should then project onto BCD, but this projection is seen to be superfluous, since the final join produces a relation over only those attributes. The parse tree for the final expression is shown in Fig. Extension to the case where constants appear in the summary. If there is a constant c in column A of the summary of a tableau, then c must appear in some row of column A, else the tableau can be shown not to come from an expression. If c appears in only one row k of column A, we may treat c as a distinguished variable, introducing the constraints (i, f)&lt; (i, k) and (i, f)&lt; (f, k) for each pair of rows and f having a repeated nondistinguished variable in column A. If c appears in more than one row of column A, we have choices. For all but one of these rows we can select A c and then project A out. But for one row we must treat c as if it were distinguished, and introduce the appropriate constraints. Since we may have a choice for each column that has a constant in the summary, we apparently have a combinatorial problem. However, we may adopt the simple expedient of permitting a new operator augment, defined by CeA=c (r) {/z ]/ (A)= c and there exists v in r such that for all attributes B on which r is defined,/x (B) v(B)}. Note that we may assume that r is not defined on A; otherwise augment is the same as select. Then we may synthesize an expression from a tableau with constants in the summary by"</p><p>(1) deleting constants from the summary, (2) synthesizing an expression for the resulting tableau, if it exists, and then (3) using the augment operator to introduce the constants into the tuples of the relation resulting from application of the expression from (2).</p><p>6. Finding a minimal expression equivalent to a given tableau. We should also consider a variant of the problem of finding an expression that yields a given tableau. In most circumstances it will be sufficient to find an expression that yields an equivalent tableau, that is, an expression defining the same mapping from universal instances to target relations as the tableau.</p><p>It turns out that this question is no harder than the original problem, as we can show that a tableau comes from an expression only if its minimal equivalent tableau does. Thus, if we minimize the number of rows in a tableau, then we can obtain an expression with the fewest joins equivalent to a given tableau since the number of rows in the tableau is one more than the number of joins in the resulting expression. THEOREM 6. If a tableau comes from an expression, then its minimal equivalent tableau comes from an expression.</p><p>Proof. It follows from [4] that any given tableau T has a minimal equivalent tableau T' (one with the fewest number of rows) such that each row of T' is a row of T.</p><p>Given an expression E yielding tableau T, we can delete the operands of E correspond- ing to rows of T that are not in T'.</p><p>Nodes that apply unary operators (select and project) to a deleted operand, and nodes that join two deleted operands are themselves deleted. Nodes that join a deleted operand with one that is not deleted are identified with the nondeleted operand. The resulting expression will yield tableau T'. We may prove by an easy induction on the A B C D  height of a node remaining in the expression that the tableau for this node is the same as the tableau for the corresponding node in E, with rows that do not eventually become rows in T' deleted. [3  Example 7. The tableau in Fig. <ref type="figure">8</ref> implies constraints (1, 2) &lt; (1, 3), (1, 2) &lt; (2, 3), (1, 2)&lt; (1, 4), and (1, 2)&lt; (2, 4), so we may synthesize the expression of Fig. <ref type="figure" target="#fig_11">9</ref>. The minimal equivalent tableau for Fig. <ref type="figure">8</ref> has only rows 3 and 4. To synthesize an expression for the minimal tableau, we delete nodes n8 and n9, which correspond to rows 1 and 2. This causes nodes n7 and n5 to be deleted and node n4 to be merged with r/6. The resulting expression is shown in Fig. 10  7. Summary. In this paper we have presented an 0(/,/2 log n) algorithm that will construct, whenever possible, a tree to satisfy n given constraints on common ancestors of a set of nodes. The constraints specify lineage restrictions on lowest common ancestors of pairs of nodes. We have also shown that the tree construction algorithm can be used as part of a process to minimize the number of joins in a certain class of rela- tional algebra expressions containing only select, project and join operators.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>FIG.1. A solution to constraints (1.1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FIG. 3 .</head><label>3</label><figDesc>FIG. 3. Construction of a tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Downloaded 12 /</head><label>12</label><figDesc>25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Downloaded 12 /</head><label>12</label><figDesc>25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>AFIG. 5 .</head><label>5</label><figDesc>FIG. 5. A nonsimple tableau.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>FIG. 6 .</head><label>6</label><figDesc>FIG. 6. Initial tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>b6 b8 a:z a3 b9</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>FIG. 9 .</head><label>9</label><figDesc>FIG. 9. An expression for the tableau ofFig. 8.   </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php Definition of a tableau.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php By Rule (2c), the tableau for AB N BC is A B C</figDesc><table><row><cell>al</cell><cell>a2</cell><cell>a3</cell></row><row><cell cols="3">a a2 bl</cell></row><row><cell cols="3">b2 a2 a3</cell></row><row><cell cols="3">By Rule (2a), the tableau for crB=o(AB N BC) is</cell></row><row><cell cols="3">A B C</cell></row><row><cell>al</cell><cell>0</cell><cell>a3</cell></row><row><cell>al</cell><cell>0</cell><cell>bl</cell></row><row><cell cols="3">be 0 a3</cell></row><row><cell cols="3">Finally, by Rule (2b), the tableau for 7rA(rB=o(ABNBC)) is</cell></row><row><cell cols="3">A B C</cell></row><row><cell>al</cell><cell></cell><cell></cell></row><row><cell cols="2">ax 0</cell><cell></cell></row><row><cell cols="3">b2 0 b3</cell></row><row><cell>Simple tableaux.</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc><table><row><cell>7. fi</cell></row><row><cell>(mc)</cell></row><row><cell>(CD)</cell></row><row><cell>(BC)</cell></row><row><cell>(AB)</cell></row><row><cell>FIG. 7. Synthesized expression.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>FIG. 8. A tableau. Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Downloaded 12/25/12 to 128.148.252.35. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The work of this author was supported in part by the National Science Foundation under grant MCS-76-15255.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Computer Algorithms</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient optimization of a class of relational expressions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">O</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="435" to="454" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Equivalences among relational expressions</title>
	</analytic>
	<monogr>
		<title level="j">Journal</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="218" to="246" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Optimal implementation of conjunctive queries in relational databases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Merlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Ninth Annual ACM Symposium on Theory of Computing</title>
		<meeting>Ninth Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="77" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A relational model for large shared data banks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="377" to="387" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Variations on the common subexpression problem</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Downey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Sethi And R</surname></persName>
		</author>
		<author>
			<persName><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="758" to="771" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Set merging algorithms</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="294" to="303" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Access path selection in a relational database management system</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Selinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Astrahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Cham3erlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Price</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Conference on Management of Data</title>
		<meeting>ACM SIGMOD Conference on Management of Data<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="23" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Principles o&apos;Database Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>Computer Science Press</publisher>
			<pubPlace>Potomac, MD</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Decomposition--a strategy for query processing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Youssefi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="page" from="223" to="241" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Algebraic dependencies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st Annual IEEE Symposium on Foundations of Computer Science</title>
		<meeting>21st Annual IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="328" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimization of query evaluation algorithms</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="133" to="155" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Redistribution subject to SIAM license or copyright</title>
		<idno>Downloaded 12/25/12 to 128.148</idno>
		<ptr target="http://www.siam.org/journals/ojsa.php" />
		<imprint>
			<biblScope unit="volume">252</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
