<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Procera: A Language for High-Level Reactive Network Control</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Voellmy</surname></persName>
							<email>andreas.voellmy@yale.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Yale University</orgName>
								<address>
									<addrLine>51 Prospect ST</addrLine>
									<settlement>New Haven</settlement>
									<region>CT</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hyojoon</forename><surname>Kim</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science</orgName>
								<address>
									<addrLine>266 Ferst Drive Atlanta</addrLine>
									<region>GA</region>
									<country>Georgia Tech, U.S.A</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nick</forename><surname>Feamster</surname></persName>
							<email>feamster@cs.umd.edu</email>
							<affiliation key="aff2">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<settlement>College Park</settlement>
									<region>MD</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Procera: A Language for High-Level Reactive Network Control</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0E21DAB9C8C0B8BF574E0CDEBA3B7677</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.1 [Computer-Communication Networks]: Network Architecture and Design-Centralized networks</term>
					<term>C.2.3 [Computer-Communication Networks]: Network Operations-Network Management</term>
					<term>C.3 [Special Purpose and Application-Based Systems]: []</term>
					<term>D.3.2 [Programming Languages]: Language Classifications-Applicative (functional) languages, Haskell OpenFlow, Software-defined Networking, Network Configuration, Functional Reactive Programming, Haskell</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Our previous experience building systems for implementing network policies in home and enterprise networks has revealed that the intuitive notion of network policy in these domains is inherently dynamic and stateful. Current configuration languages, both in traditional network architectures and in OpenFlow systems, are not expressive enough to capture these policies. As a result, most prototype OpenFlow systems lack a configurable interface and instead require operators to program in the system implementation language, often C++. We describe Procera, a control architecture for software-defined networking (SDN) that includes a declarative policy language based on the notion of functional reactive programming; we extend this formalism with both signals relevant for expressing high-level network policies in a variety of network settings, including home and enterprise networks, and a collection of constructs expressing temporal queries over event streams that occur frequently in network policies. Although sophisticated users can take advantage of Procera's full expressiveness by expressing network policies directly in Procera, simpler configuration interfaces (e.g., graphical user interfaces) can also easily be built on top of this formalism.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Network operators and researchers have often discussed the need for a network configuration language that can express high-level network policies, in contrast to the status quo, whereby configuration is low-level, mechanism-focused, and vendor specific <ref type="bibr" target="#b2">[5,</ref><ref type="bibr" target="#b4">7,</ref><ref type="bibr" target="#b15">18]</ref>. Conventional methods result in systems that are complex, errorprone, and hard to manage <ref type="bibr" target="#b3">[6,</ref><ref type="bibr" target="#b6">9,</ref><ref type="bibr" target="#b11">14,</ref><ref type="bibr" target="#b16">19]</ref>. Software defined networking (SDN) offers the opportunity to make networks easier to configure by providing richer configuration methods, and indeed such systems have been proposed. As an example, Flow Management Language (FML) <ref type="bibr" target="#b10">[13]</ref> provides a simple rule-based formalism for controlling OpenFlow <ref type="bibr" target="#b18">[21]</ref> networks.</p><p>Many network systems implement policies that are inherently dynamic and depend on temporal conditions defined in terms of external events such as measurements of bandwidth use of hosts, intrusion detections, or specific time events. For example, intrusion detection and prevention systems detect certain sequences of events and trigger actions <ref type="bibr" target="#b20">[23]</ref>; load balancing systems can choose a server based on load <ref type="bibr" target="#b9">[12]</ref>; and campus networks can deny access when certain complex temporal bandwidth usage conditions occur <ref type="bibr" target="#b0">[1]</ref>.</p><p>We present Procera, a controller architecture and high-level network control language that allows operators to express the kinds of policies that we have described above, without resorting to generalpurpose programming of a network controller. We have designed Procera to be reactive because many realistic network policies react to dynamic changes in network conditions. Procera also incorporates events that originate from sources other than OpenFlow switches, allowing it to express policy that reacts to conditions such as user authentications, time of day, bandwidth use, or server load. Procera is both expressive and extensible, so users can easily extend the language by adding new constructs.</p><p>Procera has the following features:</p><p>• Procera controllers output flow constraint functions that a lower-level network controller uses to constrain its own behavior, thereby allowing the high-level control to be simple and to cleanly separate lower-level network issues, such as routing and flow-table management.</p><p>• Procera applies the principles of functional reactive programming (FRP) <ref type="bibr" target="#b23">[26]</ref>, which provides a declarative, expressive, and compositional framework for describing reactive and temporal behaviors. Procera includes a collection of domain-specific temporal operators that allow users to easily express the values of time-varying sets and dictionaries in terms of event histories.</p><p>• Procera can be customized with a collection of primitive event streams, but does not by default have access to Open-Flow events, such as flow request events. This func-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sensors</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UIs</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• • • Config Files</head><p>Policy Layer (e.g., FML, Procera)</p><p>Network Controller (e.g., NOX, Floodlight, Frenetic...)</p><p>Programmable Switches (e.g., OpenFlow)</p><p>Figure <ref type="figure">1</ref>: System Architecture.</p><p>tional division permits scalable implementations that process OpenFlow events in parallel, even while processing non-OpenFlow events sequentially.</p><p>This paper illustrates the need for a high-level, reactive policy language; presents Procera, a language that permits operators to express high-level, reactive network policies; and illustrates how Procera can help operators express these policies through a series of examples that are motivated from our experience with configurations in both campus networks and home networks. We are developing a version of Procera that can instantiate policies in our underlying Lithium controller <ref type="bibr" target="#b13">[16]</ref>.</p><p>The rest of this paper is organized as follows. Section 2 defines the notion of a policy layer that enables a network controller to respond to higher-level events, and explains Procera in the context of existing network control technologies. Section 3 motivates the need for a reactive policy layer with several examples and shows that existing languages and control models do not allow network operators to easily express even simple reactive network policies. Sections 4 and 5 describe the Procera language and its use, through a series of examples. Section 6 describes related work, and Section 7 concludes with a summary and agenda for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">CONTROL SYSTEM ARCHITECTURE</head><p>Figure <ref type="figure">1</ref> shows our system architecture. The lowest layer consists of programmable OpenFlow <ref type="bibr" target="#b18">[21]</ref> switches that ultimately perform forwarding actions on the flows. On top of this layer, the network control layer exchanges messages with OpenFlow switches to configure flow tables and gather statistics. There are many examples of network controllers today, for example NOX <ref type="bibr" target="#b8">[11]</ref>, Maestro <ref type="bibr" target="#b24">[27]</ref>, Floodlight [2], Nettle <ref type="bibr" target="#b22">[25]</ref>, and Frenetic <ref type="bibr" target="#b7">[10]</ref>. This layer is responsible for performing network-related tasks, such as routing and topology discovery.</p><p>The policy layer resides above the network control layer and is the focus on this paper. The policy layer acts as a supervisor, reacting to signals about relevant network events and out-of-band signals from users, administrators, and other sensors such as intrusion detection devices. In turn, the policy layer provides guidance and directives to the network controller. This guidance should be declarative to keep the supervisor simple and abstract so that the network layer may implement the guidance efficiently and flexibly. We envision that this policy layer may in fact be a policy engine that can be customized with user-specified supervisor code. FML is an example of a language that resides at the policy layer: it generates a data structure used by the network controller to handle flow requests. Similarly, Procera allows network operators to define how a network controller should react to higher-level network events. Procera could act as a language and runtime component of the Lithium event-based OpenFlow controller, which we describe in an accompanying technical report <ref type="bibr" target="#b13">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE NEED FOR REACTIVE POLICY</head><p>We describe some simple examples that illustrate the need for a declarative, reactive, operator-facing network programming language, We do this by highlighting the problems that arise when using an existing policy language, FML, to specify and implement policies that arise in real-world systems.</p><p>FML provides a high-level declarative policy language based on logic programming. An FML program consists of a collection of inference rules that collectively defines a function that assigns a set of flow constraints to each packet. The constraints typically include "allow" and "deny" constraints, but may include others as well. The logic is simple, permitting neither recursion nor arithmetic constraints or functions. The FML engine maintains some state, including the users associated with particular devices, and FML policy may predicate packet constraints based on this state. This state space is fixed by the FML implementation and therefore not modifiable by the author of the network policy.</p><p>Consider the following examples, which illustrate the limitations of FML's logic. The first policy is "ban a device if its usage over the last five days exceeds 10 GB". Unfortunately, we cannot write this policy in FML directly because FML does not provide device usage data or allow arithmetic constraints. Assume for the moment, though, that we have extended FML with arithmetic inequalities and a predicate usage(D,T,B) which holds when device D has consumed B gigabytes of bandwidth over the last T days. Then we could write the above policy in FML as: deny(Us, D, As, Ut, Ht, At, P, R) &lt;-over(D). over(D) &lt;-usage(D,T,B), T=5, B &gt; 10.</p><p>These rules should be read as implications from right to left. For example, the first line, expresses the implication that whenever a device D satisfies predicate over, then deny(...) holds with device D in the source Ethernet address field of a packet; that is, all packets from D should be denied.</p><p>Expressing even a minor variation on this policy, such as "permanently ban the device as soon as its usage over the last five days exceeds 10 GB", is much more difficult. The difficulty arises from the fact that the policy requires that the violating user to be banned from the network, even if later his five-day usage drops below the maximum allowed (which will certainly occur, since the user is banned). In other words, the policy requires that when the condition becomes true, the policy itself must change. We could try to work around this, by adding a predicate usageOnceExceeded(Hs,Ds,Amt), so that we could write</p><formula xml:id="formula_0">over(D) &lt;-usageOnceExceeded(D,T,B), T=5, B=10.</formula><p>Such a function is fairly special-purpose for a general network policy language, but if it were the only such exception, we could live with it. Unfortunately, another minor variation to the policy causes yet more difficulties: "ban a device as soon as its last five-day usage exceeds 10 GB, and remove their ban when and only when an adminstrator resets that device". This time, a different temporal condition changes the state of the system and affects the desired policy. We could again extend FML with a predicate usageOnceExceededAndNoResetSince(D,T,B), but it should clear at this point that there is no end to these variations, and that we need a more general notation for denoting any of these variations.</p><p>The key feature missing from FML is the ability for the userdefined policy logic to affect the state. Instead, in FML, the policy logic is passive and can only observe the state. While there are approaches, such as McCarthy's frame calculus <ref type="bibr" target="#b17">[20]</ref> and Kowalski's event calculus <ref type="bibr" target="#b14">[17]</ref>, to enhance the logic programming approach with state-changing actions, these models substantially complicate the logic.</p><p>We instead pursue a different path, based on functional reactive programming (FRP). Using this approach, users describe timevarying values by describing how their current value depends on event histories and current and prior values of other quantities. In particular, we instantiate FRP with temporal operators that produce event histories and define commonly occurring functions that determine the value of sets and dictionaries in terms of these event histories. For example, we will be able to define a dictionary mapping devices to their five-day usage simply by writing the following:</p><formula xml:id="formula_1">proc world → do recent ← since (daysAgo 5) -≺ add (usageEvents world ) usageTable ← group sum -≺ recent returnA -≺ usageTable</formula><p>FRP is well-established and has been applied to a wide range of domains, including user interfaces, robotics, and network control <ref type="bibr" target="#b7">[10,</ref><ref type="bibr" target="#b22">25]</ref>; many efficient and practical FRP implementations exist. These languages allow the user to specify and invoke arbitrary functions, so we can easily support policies that involve arithmetic constraints and other functions, which would require substantial extensions to FML.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PROCERA: REACTIVE POLICY</head><p>The key features of the Procera policy language are (1) a core language based on functional reactive programming, (2) event comprehensions to manipulate event streams, (3) windowing and aggregation signal functions, (4) the use of function values to represent high-level policy. Each of these ideas borrows heavily from previous systems: the core reactive language is based on the ideas of Yampa <ref type="bibr" target="#b5">[8]</ref>, a domain-neutral FRP language, event comprehensions are inspired by list and monad comprehensions in Haskell, and the windowing and aggregation constructs are inspired by streaming database systems <ref type="bibr" target="#b1">[4]</ref>.</p><p>Procera is an embedded domain-specific language (EDSL) in Haskell. This allows Procera to reuse various general-purpose datatypes and constructs, such as numbers, lists, and functions. It also allows users to mix Haskell expressions with Procera constructs, provided the expressions satisfy appropriate type constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Signals, Signal Functions, and Events</head><p>The main reactive concepts of Procera are signals and signal functions. A signal is conceptually a function of continuous time into some range. Often the range of a signal is numeric, but in Procera signals can range over any data type. Although the domain of a signal is conceptually continuous time, discrete time signals are supported by allowing missing values. Values have an option type, which is either present with a value or missing.</p><p>On the other hand, signal functions (also known as "systems" in other contexts) transform signals. The name emphasizes the fact that signal functions are in fact mathematical functions and therefore describe deterministic transformations of input signals to output signals. By acting on signals, signal functions can implement time-varying behavior, and in particular, can exhibit hysteresis. A simple example of this behavior is an edge detector, which outputs an event whenever its boolean input signal rises from False to True. This signal function exhibits hysteresis because the value of the output signal does not depend solely on the value of input signal at the same time; in other words, the signal function edge has internal state.</p><p>In Procera, the programmer defines signal functions using the arrow syntax <ref type="bibr" target="#b19">[22]</ref>, which provides a syntactic analog of signals and systems diagrams consisting of boxes and wires. For example,</p><formula xml:id="formula_2">proc x → do y ← integral -≺ x z ← integral -≺ y returnA -≺ z + y + 1</formula><p>defines a signal function that integrates the input signal (named x ) twice and scales the result (this example is only illustrative: integral is not in Procera). The notation allows users to bind variables to stand for instantaneous values of signals, as in x , y, and z above, and these can be used in expressions to denote other instantaneous values (e.g., z + y + 1 above) and to wire-up to signal functions (e.g., y is fed into integral ). Note that the instantaneous values are all synchronous; for example, the output of the signal function at time t above involves adding the values of z and y taken at that same time t.</p><p>As we mentioned earlier, Procera supports discrete signals by having the signals carry values of the Event data type. Procera provides an event algebra that allows operations for filtering, transforming, merging, and joining event streams. For example, merging of two event streams e1 and e2 is written e1.|.e2 and denotes the events that occur in either of the event streams. Most of this algebra is accessed most conveniently using event comprehensions, a notation very similar to list comprehensions that supports transforming, filtering and joining event streams. For example, if e stands for the instaneous values of an event stream carrying natural numbers, we could write:</p><formula xml:id="formula_3">[n + 1 | n ← e, prime n ]</formula><p>to stand for the instantaneous values of an event stream which keeps just those events from e that carry prime numbers, and adds one to the values of the filtered event stream.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Windowing and Aggregating</head><p>We introduce a collection of signal functions and abstract data types that allow users to conveniently describe commonly occurring reactive policies. Table <ref type="table" target="#tab_0">1</ref> enumerates these constructs.</p><p>The constructs fall into two groups. The members of the first group produce windowed event histories. In particular, since dt, limit size, and limitBy attribute size implement timebased, count-based, and partitioned-count-based windowing. The clockResetWindow next construct accumulates a window until the next clock event given by next , when the window is cleared. Each of these constructs consumes and produces event histories, and therefore can be composed. For example, since and limit can be used together to define a windowed history that includes only the last few events that occur within a given time window. We will provide example uses of these constructs in Section 5.</p><p>The second group of constructs includes accumSet , accumList , and group. These signal functions take event histories as input and compute some value of the input history. For example, the value of the output signal of accumSet at any time is the set whose members are currently in the input history. The group op construct outputs a time-varying dictionary from an event history of key-value pairs using the given operation op to aggregate values of the same key.</p><p>History signals carry their history incrementally, in the form of additions and removals from the history. This design allows window and aggregation operations to incrementally compute re- sults. It also allows the same aggregation operations to act on input signals of event additions and removals other than those produced by window operators. Section 5 will show example uses of these operations. Procera includes an abstract data type AddRemoveEvent a, and functions add , remove, and ⊕ to insert and remove events and to merge two AddRemoveEvent a streams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Input Signals &amp; Flow Constraints</head><p>The input to the main Procera signal function is a world signal whose instantaneous values have the abstract World type. While the exact details of this data type are application-specific, it is typically a record of attributes of the environment, and includes components that indicate the presence or absence of external events. For example, in the following section we write authEvents world to denote the authentication events that might be present in the current world value.</p><p>The output of a Procera controller is a signal carrying flow constraint functions. A flow constraint function determines the constraints that are applied to a flow. The constraints will typically include constructs to allow or deny flows, but may include other constraints according to the needs of the particular system. Table 2 lists some constraints useful in home and campus network management systems. For convenience, we include a constraint combination operation denoted with ⊙, which hides the detailed representation of the constraint data type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PROCERA IN ACTION</head><p>We now present several Procera controllers, beginning with simple ones that explain the syntax. We then proceed to describe more complex examples that demonstrate the expressive power of the language.</p><p>Example: Static Policy. Our first example is the "hello world" of network access control examples. It simply allows all network traffic flows.</p><formula xml:id="formula_4">proc world → do returnA -≺ λreq → allow</formula><p>Here we simply ignore the world signal and always output the same flow constraint function (the expression λreq → allow is a lambda-expression, i.e. an anonymous function, with parameter req ). The flow constraint function itself ignores its argument and simply allows all requests. A variant of this example is one that denies all flow requests:</p><formula xml:id="formula_5">proc world → do returnA -≺ λreq → deny</formula><p>Many networks use static access control policies which limit access to some devices or services on the network. For example, a policy might allow only http traffic to IP addresses in subnet 128.36.5.0 / 24: proc world → do returnA -≺ λreq → if destIP req 'inSubnet ' ipAddr 128 36 5 0 / / 24 then allow else deny Many more static policies, for example accessing other packet fields, can be written in Procera. We omit the details here due to space limitations.</p><p>Example: Device registration. In many home and campus networks, network access is limited to some set of registered or authenticated devices, and in many networks, the set of authenticated devices varies over time, as a result both of administrative actions (e.g., through user interface actions or configuration file edits), or through user actions (e.g., authenticating with a portal).</p><p>To express policy related to administrative device authentication events, we add these events to the World data type and add functions authEvents and deAuthEvents to refer to authentication events. Then we can, for example, define a set whose members at any time are exactly those devices which have a more recent authentication than deauthentication, and use that in our policy function:</p><formula xml:id="formula_6">proc world → do authDevs ← accumSet -≺ add (authEvents world ) ⊕ remove (deAuthEvents world ) returnA -≺</formula><p>λreq → if srcEthAddr req 'member ' authDevs then allow else deny</p><p>We feed a stream of AddRemoveEvent values into accumSet which accumulates the set arising from the addition or removal of values. We create the stream of AddRemoveEvent s using add , remove, and ⊕ functions. The policy function varies over time, because it refers to the time-varying set of authenticated devices.</p><p>Example: Device Usage Caps. We now consider policies inspired by the uCap system <ref type="bibr" target="#b12">[15]</ref>, which allows home network administrators to limit the network access to devices and users based on maximum bandwidth usage settings, or caps. In uCap, users configure monthly usage caps via a user interface and the system collects device usage logs from routers every few seconds. A (simplified) uCap controller ensures that any device whose usage for the current month exceeds its monthly cap is barred from using the network until the following month.</p><p>To express this logic, we add events to our World data type for cap settings and usage reports. These events are denoted by usageEvents world and capSetEvents world , respectively. We can then track the cap settings by keeping track of the last setting per device, using the last1PerGroup signal function, which outputs a dictionary mapping keys to the value of the last event for that key: capTableSF = proc world → do last1PerGroup -≺ add (capSetEvents world )</p><p>(The arrows notation allows the last statement to be either returnA as in earlier examples, or a signal function, as in this example.)</p><p>The controller can then track the monthly usage by using the clockResetWindow nextMonth signal function, which accumulates events until the next month, and then groups by the key and sums values for the same key: useTableSF = proc world → do recent ← clockResetWindow nextMonth -≺ add (usageEvents world ) group sum -≺ recent nextMonth , whose straightforward definition we omit here, is a function which maps a given date into the beginning of the month following the date. Other functions could be used here to reset usage in other ways, for example by week or by time of day.</p><p>We can then define our overall uCap controller by using the above signal functions (we omit the straightforward definitions of lookupUse and lookupCap): In this example, the event comprehension attaches the usage amount of each usage event to the user who is currently authenticated at the device at the time of the event. These events are then windowed and grouped as in the previous example.</p><formula xml:id="formula_7">proc</formula><p>Example: Usage Caps on a Campus Network. We return to the policy mentioned in Section 3 and which is inspired by the publicly available campus network policies from Carnegie Mellon <ref type="bibr" target="#b0">[1]</ref>. A simplified version of the policy states that a device is permanently barred from the network if it exceeds a five-day sliding cap, until an adminstrator reinstates the device. This policy differs from the previous example in two ways: (1) usage is aggregated over a sliding window and (2) devices can be explicitly reinstated. To express this policy, we add another event source to the World data type for administrative resets, letting adminResets world denote these events. We then express the policy in two steps, first writing the signal function to track usage over the sliding window and second writing the signal function which tracks users that have exceeded their cap and have not yet been reinstated: In overSetSF we use the .|. operation, which merges two events in order to let devEv stand for any event changing the usage or cap setting of a device. We then use an event comprehension to check whether the usage for any device for which an event occurred now exceeds its usage cap. We omit the policy that simply checks that the sender of a packet is not a member of set provided by overSetSF .</p><formula xml:id="formula_8">useTableSF = proc world → do recent ← since (daysAgo</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>We discuss related work in terms of the distinctions made in our system architecture in Figure <ref type="figure">1</ref>. There are many OpenFlow controller frameworks available, such as NOX <ref type="bibr" target="#b8">[11]</ref>, Maestro <ref type="bibr" target="#b24">[27]</ref> and Floodlight [2], and POX [3]. These frameworks provide low-level control over switch flow tables and are typically imperative and object-oriented. Nettle <ref type="bibr" target="#b21">[24,</ref><ref type="bibr" target="#b22">25]</ref> is also a network controller, but differs from the above systems by allowing the low-level control programs to be written in a domain specific language based on FRP and embedded in a functional programming language.</p><p>Flow-based Management Language (FML) <ref type="bibr" target="#b10">[13]</ref> is a policy language for the NOX controller that allows operators to declaratively specify network policies and therefore serves a similar purpose as Procera. We compare Procera with FML in detail in Section 3.</p><p>Frenetic <ref type="bibr" target="#b7">[10]</ref> is a network programming language built on NOX; it has two sub-languages: (1) a declarative network query language, and (2) a functional and reactive network policy management library based on FRP. Frenetic occupies a role somewhere between a policy layer and a network controller: it deals with network details such as routing and switch rules, but also introduces an abstraction that allows multiple network management programs to compose without interfering. Frenetic and Procera have some similar language constructs, such as time windowing; While Frenetic applies these operations only to packets, Procera allows these to be applied to any event stream.</p><p>Declarative routing <ref type="bibr" target="#b15">[18]</ref> is recursive query language for network routing. It is designed to simplify distributed router programming, rather than logically centralized controllers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">SUMMARY</head><p>We have introduced Procera, a language that allows network operators to specify high-level, reactive network control policies that cannot easily be expressed in today's languages for softwaredefined network control. Procera applies the principles of functional reactive programming to provide a declarative, expressive, and compositional framework that allows operators to express network policies based on both reactive and temporal behaviors, which are typically necessary to express common, simple network policies. In our ongoing work, we are implementing a scalable Procera controller and exploring how the composability that FRP facilitates might make it easier to compose orthogonal network policies (e.g., traffic load balance and access control) in a common policy control framework. We are also deploying Procera on BISmark home routers; we plan to use it to enable home network users to express policies such those we have described in this paper, either directly, or indirectly via a graphical user interface.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Key Procera constructs.</head><label>1</label><figDesc></figDesc><table><row><cell>since dt</cell><cell></cell><cell>Windows a history to the past</cell></row><row><cell></cell><cell></cell><cell>dt seconds</cell></row><row><cell>limit size</cell><cell></cell><cell>Windows a history to the last</cell></row><row><cell></cell><cell></cell><cell>size number of events.</cell></row><row><cell cols="2">limitBy attribute size</cell><cell>Limits the input history by</cell></row><row><cell></cell><cell></cell><cell>keeping only the last size num-</cell></row><row><cell></cell><cell></cell><cell>ber of events for each value of</cell></row><row><cell></cell><cell></cell><cell>the attribute.</cell></row><row><cell cols="2">clockResetWindow next</cell><cell>Windowed history that is</cell></row><row><cell></cell><cell></cell><cell>cleared at the time indicated</cell></row><row><cell></cell><cell></cell><cell>by next .</cell></row><row><cell>accumList</cell><cell></cell><cell>Accumulates a sequence of</cell></row><row><cell></cell><cell></cell><cell>events from a windowed his-</cell></row><row><cell></cell><cell></cell><cell>tory.</cell></row><row><cell>accumSet</cell><cell></cell><cell>Accumulates a set of events</cell></row><row><cell></cell><cell></cell><cell>from a windowed history.</cell></row><row><cell>group op</cell><cell></cell><cell>Accumulates a dictionary from</cell></row><row><cell></cell><cell></cell><cell>a history of key-value pairs, us-</cell></row><row><cell></cell><cell></cell><cell>ing op to combine values for</cell></row><row><cell></cell><cell></cell><cell>the same key.</cell></row><row><cell>last1PerGroup</cell><cell></cell><cell>Accumulates a dictionary from</cell></row><row><cell></cell><cell></cell><cell>a history, mapping keys to the</cell></row><row><cell></cell><cell></cell><cell>last occurring value for the key.</cell></row><row><cell cols="3">add e,remove e, ar 1 ⊕ ar 2 Event additions, removals, and</cell></row><row><cell></cell><cell></cell><cell>combinations thereof.</cell></row><row><cell>allow</cell><cell cols="2">Allow the packet</cell></row><row><cell>deny</cell><cell cols="2">Do not allow the packet</cell></row><row><cell cols="3">rateLimit rate Rate limit the flow to the given rate</cell></row><row><cell>redirect host</cell><cell cols="2">Redirect the flow to the specified host</cell></row><row><cell>x ⊙ y</cell><cell cols="2">Constrain according to both x and y</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Constraints.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Example: Per-User Usage Caps</head><label></label><figDesc>. A variant of the above controller keeps track of usage by user rather than by device. Procera can also accomodate this policy, despite the input signals only including usage by device. The policy correlates the usage events with the authentication table, by associating the device of each usage event with the user id given in the authentication table. The following example demonstrates how this can be done (we assume that authTableSF , which provides the authentication table, has been defined previously):</figDesc><table><row><cell>world → do</cell></row><row><cell>useTable ← useTableSF -≺ world</cell></row><row><cell>capTable ← capTableSF -≺ world</cell></row><row><cell>let policy req =</cell></row><row><cell>let src = srcEthAddr req</cell></row><row><cell>use = lookupUse src useTable</cell></row><row><cell>cap = lookupCap src capTable</cell></row><row><cell>in if use &lt; cap then allow else deny</cell></row><row><cell>returnA -≺ policy</cell></row><row><cell>useTableByUserSF =</cell></row><row><cell>proc world → do</cell></row></table><note><p>authTable ← authTableSF -≺ world let evs = [(lookupUser ddev authTable, use) | (dev , use) ← usageEvents world ] recent ← clockResetWindow nextMonth -≺ add evs group sum -≺ recent</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported in part by a gift from Microsoft Research, NSF Awards CNS-1018021, CNS-1040715, and a grant from the GENI Project Office, "GENI OpenFlow Campus Buildout".</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://www.cmu.edu/computing/network/connect/guidelines/bandwidth.html" />
		<title level="m">CMU network bandwidth usage guildline</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The cql continuous query language: semantic foundations and query execution</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arasu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Babu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="121" to="142" />
			<date type="published" when="2006-06">June 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Conman: a step towards network manageability</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ballani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 conference on Applications, technologies, architectures, and protocols for computer communications, SIGCOMM &apos;07</title>
		<meeting>the 2007 conference on Applications, technologies, architectures, and protocols for computer communications, SIGCOMM &apos;07<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="205" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Demystifying configuration challenges and trade-offs in network-based isp services</title>
		<author>
			<persName><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shaikh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. Rev</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="302" to="313" />
			<date type="published" when="2011-08">Aug. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Declarative configuration management for complex and dynamic networks</title>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Der Merwe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International COnference, Co-NEXT &apos;10</title>
		<meeting>the 6th International COnference, Co-NEXT &apos;10<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The yampa arcade</title>
		<author>
			<persName><forename type="first">A</forename><surname>Courtney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nilsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM SIGPLAN workshop on Haskell, Haskell &apos;03</title>
		<meeting>the 2003 ACM SIGPLAN workshop on Haskell, Haskell &apos;03<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="7" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Detecting BGP Configuration Faults with Static Analysis</title>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Symposium on Networked Systems Design and Implementation</title>
		<meeting>2nd Symposium on Networked Systems Design and Implementation<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-05">May 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Frenetic: A network programming language</title>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Story</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Functional Programming</title>
		<imprint>
			<date type="published" when="2011-09">Sept. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">NOX: towards an operating system for networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pettit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="105" to="110" />
			<date type="published" when="2008-07">July 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Plug-n-serve: Load-balancing web traffic using openflow</title>
		<author>
			<persName><forename type="first">N</forename><surname>Handigol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seetharaman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Flajslik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johari</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Sigcomm Demonstration</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Practical declarative network management</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Hinrichs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM workshop on Research on enterprise networking, WREN &apos;09</title>
		<meeting>the 1st ACM workshop on Research on enterprise networking, WREN &apos;09<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The evolution of network configuration: a tale of two campuses</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 ACM SIGCOMM conference on Internet measurement conference, IMC &apos;11</title>
		<meeting>the 2011 ACM SIGCOMM conference on Internet measurement conference, IMC &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="499" to="514" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Communicating with caps: managing usage caps in home networks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chetty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Edwards</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGCOMM 2011 conference on SIGCOMM, SIGCOMM &apos;11</title>
		<meeting>the ACM SIGCOMM 2011 conference on SIGCOMM, SIGCOMM &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="470" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Lithium: Event-driven network control</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voellmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Burnett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Clark</surname></persName>
		</author>
		<idno>GT-CS-12-03</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>Georgia Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A logic-based calculus of events</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sergot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="67" to="95" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Declarative routing: extensible routing with declarative queries</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 conference on Applications, technologies, architectures, and protocols for computer communications, SIGCOMM &apos;05</title>
		<meeting>the 2005 conference on Applications, technologies, architectures, and protocols for computer communications, SIGCOMM &apos;05<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="289" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Understanding BGP misconfiguration</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM<address><addrLine>Pittsburgh, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-08">Aug. 2002</date>
			<biblScope unit="page" from="3" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Situations, actions, and causal laws</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantic Information Processing</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Minsky</surname></persName>
		</editor>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1968">1968</date>
			<biblScope unit="page" from="410" to="417" />
		</imprint>
		<respStmt>
			<orgName>Stanford University Artificial Intelligence Project, Stanford University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">OpenFlow: Enabling innovation in campus networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Parulkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Communications Review</title>
		<imprint>
			<date type="published" when="2008-04">Apr. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A new notation for arrows</title>
		<author>
			<persName><forename type="first">R</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the sixth ACM SIGPLAN international conference on Functional programming, ICFP &apos;01</title>
		<meeting>the sixth ACM SIGPLAN international conference on Functional programming, ICFP &apos;01<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="229" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Bro: a System for Detecting Network Intruders in Real-Time</title>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="2435" to="2463" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><surname>Rocha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Launchbury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Practical Aspects of Declarative Languages -13th International Symposium, PADL 2011</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Austin, TX, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">January 24-25, 2011. 2011</date>
			<biblScope unit="volume">6539</biblScope>
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Nettle: Taking the sting out of programming network routers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Voellmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Rocha and Launchbury</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="235" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Functional Reactive Programming from first principles</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN&apos;00 Conference on Programming Language Design and Implementation (PLDI&apos;00)</title>
		<meeting>ACM SIGPLAN&apos;00 Conference on Programming Language Design and Implementation (PLDI&apos;00)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Maestro: A System for Scalable OpenFlow Control</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S E N</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">L</forename><surname>Cox</surname></persName>
		</author>
		<ptr target="http://www.cs.rice.edu/~eugeneng/papers/TR10-11.pdf" />
		<imprint>
			<date type="published" when="2010-12">December 2010</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
