<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CockroachDB: The Resilient Geo-Distributed SQL Database</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rebecca</forename><surname>Taft</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Irfan</forename><surname>Sharif</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Andrei</forename><surname>Matei</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Nathan</forename><surname>Vanbenschoten</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jordan</forename><surname>Lewis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Tobias</forename><surname>Grieger</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Kai</forename><surname>Niemi</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Andy</forename><surname>Woods</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Anne</forename><surname>Birzin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Raphael</forename><surname>Poss</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Paul</forename><surname>Bardea</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Amruta</forename><surname>Ranade</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ben</forename><surname>Darnell</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Bram</forename><surname>Gruneir</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Justin</forename><surname>Jaffray</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Lucy</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><forename type="middle">2020</forename><surname>Mattis</surname></persName>
						</author>
						<author>
							<persName><surname>Cock</surname></persName>
						</author>
						<title level="a" type="main">CockroachDB: The Resilient Geo-Distributed SQL Database</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">415CDED89EEEC8F774EB1E49F6ECB65A</idno>
					<idno type="DOI">10.1145/3318464.3386134</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We live in an increasingly interconnected world, with many organizations operating across countries or even continents. To serve their global user base, organizations are replacing their legacy DBMSs with cloud-based systems capable of scaling OLTP workloads to millions of users.</p><p>CockroachDB is a scalable SQL DBMS that was built from the ground up to support these global OLTP workloads while maintaining high availability and strong consistency. Just like its namesake, CockroachDB is resilient to disasters through replication and automatic recovery mechanisms.</p><p>This paper presents the design of CockroachDB and its novel transaction model that supports consistent geo-distributed transactions on commodity hardware. We describe how CockroachDB replicates and distributes data to achieve fault tolerance and high performance, as well as how its distributed SQL layer automatically scales with the size of the database cluster while providing the standard SQL interface that users expect. Finally, we present a comprehensive performance evaluation and share a couple of case studies of CockroachDB users. We conclude by describing lessons learned while building CockroachDB over the last five years.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Modern transaction processing workloads are increasingly geo-distributed. This trend is fueled by the desire of global companies to not only build scalable applications, but also control with fine-granularity where data resides for performance and regulatory reasons.</p><p>Consider, for example, a large company with a core user base in Europe and Australia and a fast growing user base in the US. To power its global platform while reducing operational costs, the company has made the strategic decision to migrate to a cloud-based database management system (DBMS). It has the following requirements: to comply with the EU's General Data Protection Regulation (GDPR), personal data for its European users must be domiciled within the EU. To avoid high latencies due to cross-continental communication, data should reside close to the users accessing it most frequently, and follow them (within regulatory limits) if they travel. Users expect an łalways onž experience, so the DBMS must be fault tolerant, even surviving a full regional failure. Finally, to avoid data anomalies and to simplify application development, the DBMS must support SQL with serializable transactions. CockroachDB (abbrev. CRDB) is a commercial DBMS designed to support all of the aforementioned requirements. As a case in point, the company described above is a real organization in the process of migrating their global platform to CRDB, and Fig. <ref type="figure">1</ref> shows the strategic vision for their CRDB deployment. In this paper, we present the design and implementation of CRDB and explain in detail the rationale for the decisions we made, as well as some lessons learned along the way. We explain how CRDB supports the requirements of global companies such as the one above by focusing on the following features:</p><p>(1) Fault tolerance and high availability To provide fault tolerance, CRDB maintains at least three replicas of every partition in the database across diverse geographic zones. It maintains high availability through automatic recovery mechanisms whenever a node fails. (2) Geo-distributed partitioning and replica placement CRDB is horizontally scalable, automatically increasing capacity and migrating data as nodes are added. By default it uses a set of heuristics for data placement (see Section 2.2.3), but it also allows users to control, at a fine granularity, how data is partitioned across nodes and where replicas should be located. We will describe how users can use this feature for performance optimization or as part of a data domiciling strategy. (3) High-performance transactions CRDB's novel transaction protocol supports performant geo-distributed transactions that can span multiple partitions. It provides serializable isolation using no specialized hardware; a standard clock synchronization mechanism such as NTP is sufficient. As a result, CRDB can be run on off-the-shelf servers, including those of public and private clouds.</p><p>CRDB is a production-grade system that was designed to łmake data easyž, so in addition to the above, CRDB supports the SQL standard with a state-of-the-art query optimizer and distributed SQL execution engine. It also includes all the features necessary for our users to run CRDB in production as a system of record, including online schema changes, backup and restore, fast imports, JSON support, and integration with external analytics systems. All of the source code of CRDB is available on GitHub <ref type="bibr" target="#b11">[12]</ref>. The core features of the database are under a Business Source License (BSL), which converts to a fully open-source Apache 2.0 license after three years <ref type="bibr" target="#b12">[13]</ref>. Additionally, CRDB is łcloudneutralž, meaning a single CRDB cluster can span an arbitrary number of different public and private clouds. These two features enable users to mitigate the risks of vendor lockin, such as reliance on proprietary extensions of SQL <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b22">23]</ref> or exposure to cloud provider outages <ref type="bibr" target="#b69">[70]</ref>.</p><p>The remainder of the paper is organized as follows: In Section 2, we present an overview of CRDB, summarizing how the database provides fault tolerance and high availability through replication and strategic data placement. Section 3 provides a deep-dive into CRDB's transaction model. Section 4 explains how we use timestamp ordering to achieve strong consistency, even with loosely synchronized clocks on commodity hardware. Section 5 describes the SQL data model, planning, execution, and schema changes. Section 6 evaluates the performance of CRDB and contains two case studies of CRDB usage. Section 7 summarizes our lessons learned while building CRDB. Section 8 describes related work, and Section 9 presents conclusions and future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">SYSTEM OVERVIEW</head><p>This section begins with an overview of CRDB's architecture in Section 2.1. Sections 2.2 and 2.3 describe how the system replicates and distributes data to provide fault tolerance, high availability, and geo-distributed partitioning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Architecture of CockroachDB</head><p>CRDB uses a standard shared-nothing <ref type="bibr" target="#b61">[62]</ref> architecture, in which all nodes are used for both data storage and computation. A CRDB cluster consists of an arbitrary number of nodes, which may be colocated in the same datacenter or spread across the globe. Clients can connect to any node in the cluster.</p><p>Within a single node, CRDB has a layered architecture. We now introduce each of the layers, including concepts and terminology used throughout the paper. 2.1.1 SQL. At the highest level is the SQL layer, which is the interface for all user interactions with the database. It includes the parser, optimizer, and the SQL execution engine, which convert high-level SQL statements to low-level read and write requests to the underlying key-value (KV) store.</p><p>In general, the SQL layer is not aware of how data is partitioned or distributed, because the layers below present the abstraction of a single, monolithic KV store. Section 5 will describe how certain queries break this abstraction, however, for more efficient distributed SQL computation. 2.1.2 Transactional KV. Requests from the SQL layer are passed to the Transactional KV layer that ensures atomicity of changes spanning multiple KV pairs. It is also largely responsible for CRDB's isolation guarantees. These atomicity and isolation guarantees will be described in detail in Sections 3 and 4. 2.1.3 Distribution. This layer presents the abstraction of a monolithic logical key space ordered by key. All data is addressable within this key space, whether it be system data (used for internal data structures and metadata) or user data (SQL tables and indexes).</p><p>CRDB uses range-partitioning on the keys to divide the data into contiguous ordered chunks of size ~64 MiB, that are stored across the cluster. We call these chunks łRangesž.</p><p>Ordering between Ranges is maintained in a two-level indexing structure inside a set of system Ranges, which are cached aggressively for fast key lookups. The Distribution layer is responsible for identifying which Ranges should handle which subset of each query, and routes the subsets accordingly.</p><p>Ranges are ~64 MiB because it is a size small enough to allow Ranges to quickly move between nodes but large enough to store a contiguous set of data likely to be accessed together. Ranges start empty, grow, split when they get too large, and merge when they get too small. Ranges also split based on load to reduce hotspots and imbalances in CPU usage. 2.1.4 Replication. By default, each Range is replicated three ways, with each replica stored on a different node. In Section 2.2, we describe how the Replication layer ensures durability of modifications using consensus-based replication. 2.1.5 Storage. This is the bottommost level, and represents a local disk-backed KV store. It provides efficient writes and range scans to enable performant SQL execution. At the time of writing, we rely on RocksDB <ref type="bibr" target="#b53">[54]</ref>, which is welldocumented elsewhere, and which we treat as a black box throughout the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Fault Tolerance and High Availability</head><p>CRDB guarantees fault tolerance and high availability through replication of data (Section 2.2.1), automatic recovery mechanisms in case of failure (Section 2.2.2), and strategic data placement (Section 2.2.3). 2.2.1 Replication using Raft. CRDB uses the Raft consensus algorithm <ref type="bibr" target="#b45">[46]</ref> for consistent replication. Replicas of a Range form a Raft group, where each replica is either a long-lived leader coordinating all writes to the Raft group, or a follower. The unit of replication in CRDB is a command, which represents a sequence of low-level edits to be made to the storage engine. Raft maintains a consistent, ordered log of updates across a Range's replicas, and each replica individually applies commands to the storage engine as Raft declares them to be committed to the Range's log.</p><p>CRDB uses Range-level leases, where a single replica in the Raft group (usually the Raft group leader) acts as the leaseholder. It is the only replica allowed to serve authoritative up-to-date reads or propose writes to the Raft group leader. Because all writes go through the leaseholder, reads can bypass networking round trips required by Raft without sacrificing consistency. Leases for user Ranges are tied to the liveness of the node the leaseholder is on; to signal liveness, nodes heartbeat a special record in a system Range every 4.5 seconds. System Ranges in turn use expiration based leases which must be renewed every 9 seconds. If a replica detects that the leaseholder is not live, it tries to acquire the lease.</p><p>To ensure that only one replica holds a lease at a time, lease acquisitions piggyback on Raft; replicas attempting to acquire a lease do so by committing a special lease acquisition log entry. To prevent two replicas from acquiring leases overlapping in time, lease acquisition requests include a copy of the lease believed to be valid at the time of request. As we will discuss in Section 4, ensuring disjoint leases is essential for CRDB's isolation guarantees. 2.2.2 Membership changes and automatic load (re)balancing. Nodes can be added to or removed from running CRDB clusters, and can fail temporarily or even permanently. CRDB treats all of these scenarios similarly: they all cause load to be redistributed across the new and/or remaining live nodes.</p><p>For short-term failures, CRDB uses Raft to operate seamlessly as long as a majority of replicas remain available. Raft ensures the election of a new leader for the Raft group if the leader fails so that transactions can continue. Affected replicas can rejoin their group once back online, and peers help them catch up on missed updates by either (1) sending a snapshot of the full Range data, or (2) sending a set of missing Raft log entries to be applied. The method used is determined based on the number of writes that occurred while the replica was unavailable.</p><p>For longer-term failures, CRDB automatically creates new replicas of under-replicated Ranges (using the unaffected replicas as sources), and determines placement as described in the next section. The node liveness data and cluster metrics required to make this determination are disseminated across the cluster using a peer-to-peer gossip protocol. 2.2.3 Replica placement. CRDB has both manual and automatic mechanisms to control replica placement.</p><p>To control placement manually, users configure individual nodes in CRDB with a set of attributes. These attributes may specify node capability (such as specialized hardware, RAM, disk type, etc.) and/or node locality (such as country, region, availability zone, etc.). When creating tables in the database, users can specify placement constraints and preferences as part of the schema of the table. For example, users may include a łregionž column in a table, which can be used to define the partitioning for the table and also map partitions to specific geographic regions.</p><p>The other mechanism for replica placement is automatic: CRDB spreads replicas across failure domains (while adhering to the specified constraints and preferences), to tolerate varying severities of failure modes (disk, rack, data center, or region failures). CRDB also uses various heuristics to balance load and disk utilization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Data Placement Policies</head><p>CRDB's replica and leaseholder placement mechanisms allow for a wide range of possible data placement policies that allow users to comply with data domiciling requirements and also make trade-offs between performance and fault tolerance. Some multi-region patterns we support are listed below.</p><p>• Geo-Partitioned Replicas For data with geographic access locality, tables can be partitioned by access location with each partition (set of Ranges) pinned to a specific region. This makes for fast intra-region reads and intraregion writes, as well as survival of availability zone (AZ) failures. Region-wide failures result in unavailability for data localized to the region. This policy can also be used for enforcing data domiciling requirements. • Geo-Partitioned Leaseholders Leaseholders for partitions in a geo-partitioned table can be pinned to the region of access with the remaining replicas pinned to the remaining regions. This policy enables fast intra-region reads and survival of regional failures, but comes at a cost of slower cross-region writes. • Duplicated Indexes Like all other data in CRDB, Indexes are stored in Ranges that can be pinned to specific regions. By duplicating indexes on a table and pinning each index's leaseholder to a specific region, the database can serve fast local reads while retaining the ability to survive regional failures. This comes with higher write amplification and slower cross-region writes, but is useful for data that is infrequently updated or cannot be tied to specific geographies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">TRANSACTIONS</head><p>CRDB transactions can span the entire key space, touching data resident across a distributed cluster while providing ACID guarantees. CRDB uses a variation of multi-version concurrency control (MVCC) to provide serializable isolation.</p><p>We begin by providing an overview of the transaction model in Section 3.1. Section 3.2 describes how we guarantee transactional atomicity. In Sections 3.3 and 3.4, we describe the concurrency control mechanisms that guarantee serializable isolation. Finally, Section 3.5 gives an overview of how follower replicas can serve consistent historical reads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>A SQL transaction starts at the gateway node for the SQL connection. This node interactively receives from and responds to the SQL client and acts as the transaction coordinator (orchestrating and ultimately committing/aborting the associated transaction). Applications typically connect to a geographically close gateway to minimize latency. In the following subsection, we describe the coordinator algorithm. 3.1.1 Execution at the transaction coordinator. Algorithm 1 shows the high-level steps of the transaction from the perspective of the coordinator. Over the course of the transaction, the coordinator receives a series of requested KV operations from the SQL layer (Line 2).</p><p>SQL requires that a response to the current operation must be returned before the next operation is issued. To avoid stalling the transaction while operations are being replicated, the coordinator employs two important optimizations: Write Pipelining and Parallel Commits. Write Pipelining allows returning a result without waiting for the replication of the current operation, and Parallel Commits lets the commit operation and the write pipeline replicate in parallel. Combined, they allow many multi-statement SQL transactions to complete with the latency of just one round of replication.</p><p>To enable the aforementioned optimizations, the coordinator tracks operations which may not have fully replicated yet (Line 1). It also maintains the transaction timestamp, which is initialized to the current time but may move forward over the course of the transaction. Since CRDB uses MVCC, the timestamp selects the point at which the transaction performs its reads and writes (which, thereafter, are visible to other transactions).</p><p>Write Pipelining. Each operation includes the key that must be read or updated, as well as metadata indicating if the transaction should commit with the current operation. In case an operation does not attempt to commit (Line 6), it's possible to execute it immediately if it does not overlap any earlier operation (Line 7). In this way, multiple operations on different keys can be łpipelinedž. If an operation depends on an earlier in-flight operation, execution must wait for the earlier operation to be replicated; such dependencies introduce a łpipeline stallž. The pipelining logic is outlined in Algorithm 2 (discussed below), but relies on the dependencies calculated here. Additionally, the coordinator tracks the current operation as in-flight (Line 8).</p><p>Next the coordinator sends the operation to the leaseholder for execution and waits for a response (Line 9). The response may contain an incremented timestamp (Line 10), which indicates that another transaction's read forced the This is achieved by verifying (via a round of RPCs) that repeating the previous reads in the transaction at the new timestamp will return the same value (Lines 11 and 12). If not, the transaction fails (Lines 13 and 14) and may have to be retried. This mechanism is described in detail in Section 3.4.</p><p>Parallel Commits. Now we consider what happens when the transaction wants to commit. Naively, it can only do so once all of its writes are known to have replicated, requiring at least two sequential rounds of consensus. Instead, the Parallel Commits protocol employs a staging transaction status which makes the true status of the transaction conditional on whether all of its writes have been replicated. This avoids the extra round of consensus because the coordinator is free to initiate the replication of the staging status in parallel with the verification of the outstanding writes, which are also being replicated (Line 5). Assuming both succeed, the coordinator can immediately acknowledge the transaction as committed to the SQL layer (Line 15). Before terminating, the coordinator asynchronously records the transaction status as being explicitly committed (Lines 16 and 17). This is done for performance reasons, and is discussed in Section 3.2, where we also explain how a staging record is resolved after an untimely crash of the coordinator.</p><p>We formally verified the safety properties of Parallel Commits using TLA+ <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b37">38]</ref>. Specifically we verified atomicity by asserting that every staging transaction was eventually either explicitly committed or aborted, regardless of coordinator failure, and no clients were told otherwise. We also verified durability by asserting that committed transactions stayed committed. The verification code is available on GitHub <ref type="bibr" target="#b13">[14]</ref>.</p><p>To demonstrate the benefits of Parallel Commits empirically, we run a microbenchmark on three servers spread across three regions. The workload consists of single-row writes to a table with ten columns and a variable number of secondary indexes on those columns. Fig. <ref type="figure" target="#fig_0">2</ref> shows that for this workload, Parallel Commits improves throughput by up to 72% and reduces p50 latency by up to 47% when the table has one or more secondary indexes, since index updates require multi-Range transactions. This shows that even as transactions require cross-Range coordination, their latency profiles remain constant. 3.1.2 Execution at the leaseholder. When the leaseholder receives an operation from the coordinator (Algorithm 2), it first checks that its own lease is still valid (Line 2). Then it acquires latches on the keys of op and all the operations op depends on (Line 3), thus providing mutual exclusion between concurrent, overlapping requests. Next it verifies that the operations op depends on have succeeded (Line 4). If it is performing a write, it also ensures that the timestamp of op is after any conflicting readers, incrementing it if necessary (Lines 5 and 6), so as not to invalidate those transactions.</p><p>Once the initial checks are complete, the leaseholder evaluates the operation to determine what data modifications are needed in the storage engine without actually making the changes (Line 7). This results in a low level command detailing the necessary changes, as well as a response for the client (e.g., success in case of a write, or the value in case of a read). If this operation is not committing the transaction, the leaseholder can respond to the coordinator without waiting for replication (Lines 9 and 10). Write operations are then replicated. After consensus is reached, each replica applies the command to its local storage engine (Lines 11 and 12). Finally, the leaseholder releases its latches and responds to the coordinator if it hasn't already done so (Lines 13 to 15).</p><p>Note that Algorithm 2 does not delve into any details about the various scenarios that may occur during the evaluation phase (Line 7). This is the period of time when a transaction may encounter uncommitted writes from other transactions or writes so close in time to the transaction's read timestamp that it is not possible to determine the correct order of transactions. The next sections discuss these scenarios, and how CRDB guarantees both atomicity and serializable isolation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Atomicity Guarantees</head><p>An atomic commit for a transaction is achieved by considering all of its writes provisional until commit time. CRDB calls these provisional values write intents. An intent is a regular MVCC KV pair, except that it is preceded by metadata indicating that what follows is an intent. This metadata points to a transaction record, which is a special key (unique per transaction) that stores the current disposition of the transaction: pending, staging, committed or aborted. The transaction record serves to atomically change the visibility of all the intents at once, and is durably stored in the same Range as the first write of the transaction (see Section 3.1 for the protocol details). For long-running transactions, the coordinator periodically heartbeats the transaction record in the pending state to assure contending transactions that it is still making progress.</p><p>Upon encountering an intent, a reader follows the indirection and reads the intent's transaction record. If the record indicates that the transaction is committed, the reader considers the intent as a regular value (and additionally deletes the intent metadata). If the transaction is aborted, the intent is ignored (and cleanup is performed to remove it). If the transaction is found to be pending (indicating that the transaction is still ongoing), then the reader blocks, waiting for it to finalize. If the coordinator node fails, contending transactions eventually detect that the transaction record has expired, and mark it aborted. If the transaction is in the staging state (which indicates that the transaction has either been committed or aborted, but the reader is unsure which), the reader attempts to abort the transaction by preventing one of its writes from being replicated. If all writes are already replicated, the transaction is in fact committed, and is updated to reflect that.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Concurrency Control</head><p>As discussed in Section 3.1, CRDB is an MVCC system and each transaction performs its reads and writes at its commit timestamp. This results in a total ordering of all transactions in the system, representing a serializable execution.</p><p>However, conflicts between transactions may require adjustments of the commit timestamp. We describe the situations in which they arise below, and note that whenever the commit timestamp does change, the transaction typically tries to prove that its prior reads remain valid at the new timestamp (Section 3.4), in which case it can simply continue forward at the updated timestamp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Write-read conflicts.</head><p>A read running into an uncommitted intent with a lower timestamp will wait for the earlier transaction to finalize. Waiting is implemented using in-memory queue structures. A read running into an uncommitted intent with a higher timestamp ignores the intent and does not need to wait.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Read-write conflicts.</head><p>A write to a key at timestamp t a cannot be performed if there's already been a read on the same key at a higher timestamp t b &gt;= t a . CRDB forces the writing transaction to advance its commit timestamp past t b . 3.3.3 Write-write conflicts. A write running into an uncommitted intent with a lower timestamp will wait for the earlier transaction to finalize (similar to write-read conflicts). If it runs into a committed value at a higher timestamp, it advances its timestamp past it (similar to read-write conflicts). Write-write conflicts may also lead to deadlocks in cases where different transactions have written intents in different orders. CRDB employs a distributed deadlock-detection algorithm to abort one transaction from a cycle of waiters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Read Refreshes</head><p>Certain types of conflicts described above require advancing the commit timestamp of a transaction. To maintain serializability, the read timestamp must be advanced to match the commit timestamp.</p><p>Advancing a transaction's read timestamp from t a to t b &gt; t a is possible if we can prove that none of the data that the transaction read at t a has been updated in the interval (t a , t b ].</p><p>If the data has changed, the transaction needs to be restarted. If no results from the transaction have been delivered to the client, CRDB retries the transaction internally<ref type="foot" target="#foot_0">1</ref> . If results have been delivered, the client is informed to discard them and restart the transaction.</p><p>To determine whether the read timestamp can be advanced, CRDB maintains the set of keys in the transaction's read set (up to a memory budget). A łread refreshž request validates that the keys have not been updated in a given timestamp interval (Algorithm 1, Lines 11 to 14). This involves re-scanning the read set and checking whether any MVCC values fall in the given interval. This process is equivalent to detecting the rw-antidependencies that PostgreSQL tracks for its implementation of SSI <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b48">49]</ref>. Similar to Post-greSQL, our implementation may allow false positives (forcing a transaction to abort when not strictly necessary) to avoid the overhead of maintaining a full dependency graph.</p><p>Advancing the transaction's read timestamp is also required when a scan encounters an uncertain value: a value whose timestamp makes it unclear if it falls in the reader's past or future (see Section 4.2). In this case we also attempt to perform a refresh. Assuming it is successful, the value will now be returned by the read.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Follower Reads</head><p>CRDB allows non-leaseholder replicas to serve requests for read-only queries with timestamps sufficiently in the past through a special 'AS OF SYSTEM TIME' query modifier. To enable this functionality safely, a non-leaseholder replica asked to perform a read at a given timestampT needs to know that no future writes can invalidate the read retroactively. It also needs to ensure that it has all the data necessary to serve the read. These conditions mean that if a follower read at timestamp T is to be served, the leaseholder must no longer be accepting writes for timestamps T ′ ≤ T , and the follower must have caught up on the prefix of the Raft log affecting the MVCC snapshot at T .</p><p>To this end, each leaseholder tracks the timestamps of all incoming requests and periodically emits a closed timestamp, the timestamp below which no further writes will be accepted. Closed timestamps, alongside Raft log indexes at the time, are exchanged periodically between replicas. Follower replicas use the state built up from received updates to determine if they have all the data needed to serve consistent reads at a given timestamp. For efficiency reasons the closed timestamp and the corresponding log indexes are generated at the node level (as opposed to the Range level).</p><p>Every node keeps a record of its latency with all other nodes in the system. When a node in the cluster receives a read request at a sufficiently old timestamp (closed timestamps typically trail current time by ~2 seconds), it forwards the request to the closest node with a replica of the data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CLOCK SYNCHRONIZATION</head><p>CRDB does not rely on specialized hardware for clock synchronization, so it can run on off-the-shelf servers in public and private clouds with software-level clock synchronization services such as NTP or Amazon Time Sync Service.</p><p>In this section, we introduce the hybrid-logical clock scheme CRDB uses to talk about timestamp ordering (Section 4.1). We then discuss how this clock scheme allows loosely synchronized clocks to efficiently provide single-key linearizability between transactions (Section 4.2). Finally, we explore the behavior of CRDB when configurable clock synchronization bounds are violated (Section 4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Hybrid-Logical Clocks</head><p>Each node within a CRDB cluster maintains a hybridlogical clock (HLC) <ref type="bibr" target="#b19">[20]</ref>, which provides timestamps that are a combination of physical and logical time. Physical time is based on a node's coarsely-synchronized system clock, and logical time is based on Lamport's clocks <ref type="bibr" target="#b36">[37]</ref>.</p><p>HLCs within a CRDB deployment are configured with a maximum allowable offset between their physical time component and that of other HLCs in the cluster. This offset configuration defaults to a conservative value of 500 ms. Hybrid-logical clocks provide a few important properties:</p><p>(1) HLCs provide causality tracking through their logical component upon each inter-node exchange. Nodes attach HLC timestamps to each message that they send and use HLC timestamps from each message that they receive to update their local clock.</p><p>Capturing causal relationships between events on different nodes is critical for enforcing invariants within CRDB. The most important of these is a lease disjointness invariant similar to that in Spanner: for each Range, each lease interval is disjoint from every other lease interval. This is enforced on cooperative lease handoff with causality transfer through the HLC and is enforced on non-cooperative lease acquisition through a delay equal to the maximum clock offset between lease intervals.</p><p>(2) HLCs provide strict monotonicity within and across restarts on a single node. Within a continuous process, providing this property is trivial. Across restarts, this property is enforced by waiting out the maximum clock offset upon process startup before serving any requests.</p><p>Strictly monotonic timestamp allocation ensures that two causally dependent transactions originating from the same node are given timestamps that reflect their ordering in real time.</p><p>(3) HLCs provide self-stabilization in the presence of isolated transient clock skew fluctuations. As stated above, a node forwards its HLC upon its receipt of a network message. The effect of this is that given sufficient intra-cluster communication, HLCs across nodes tend to converge and stabilize even if their individual physical clocks diverge. This provides no strong guarantees but can mask clock synchronization errors in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Uncertainty Intervals</head><p>We have already discussed how the transaction model in CRDB provides serializable isolation between transactions. However, serializability on its own says nothing about how transaction ordering in the system relates to the ordering in real time. For that, we must talk about the consistency level that CRDB offers.</p><p>Under normal conditions, CRDB satisfies single-key linearizability for reads and writes. This means that every operation on a given key appears to take place atomically and in some total linear order consistent with the real-time ordering of those operations. Under single-key linearizability, stale read anomalies are not possible. This is true even with loosely synchronized clocks, as long as those clocks stay within the configured maximum clock offset from one another.</p><p>Note that CRDB does not support strict serializability because there is no guarantee that the ordering of transactions touching disjoint key sets will match their ordering in real time. In practice, this is not a problem for applications unless there is an external low-latency communication channel between clients that could potentially impact activity on the DBMS.</p><p>The single-key linearizability property is satisfied in CRDB by tracking an uncertainty interval for each transaction, within which the causal ordering between two transactions is indeterminate. Upon its creation, a transaction is given a provisional commit timestamp commit_ts from the transaction coordinator's local HLC and an uncertainty interval of [commit_ts, commit_ts + max_offset].</p><p>When a transaction encounters a value on a key at a timestamp below its provisional commit timestamp, it trivially observes the value during reads and overwrites the value at a higher timestamp during writes. This alone would satisfy single-key linearizability if transactions had access to a perfectly synchronized global clock.</p><p>Without global synchronization, the uncertainty interval is needed because it is possible for a transaction to receive a provisional commit timestamp up to the cluster's max_offset earlier than a transaction that causally preceded this new transaction in real time. When a transaction encounters a value on a key at a timestamp above its provisional commit timestamp but within its uncertainty interval, it performs an uncertainty restart, moving its provisional commit timestamp above the uncertain value but keeping the upper bound of its uncertainty interval fixed.</p><p>This corresponds to treating all values in a transaction's uncertainty window as past writes. As a result, the operations on each key performed by transactions take place in an order consistent with the real time ordering of those transactions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Behavior under Clock Skew</head><p>To this point, we have only considered the behavior of CRDB when the configured maximum clock offset bounds are respected. It is worth also considering the behavior of the system when these clock offset bounds are violated.</p><p>Within a single Range, consistency is maintained through Raft. Raft does not have a clock dependency, so the ordering of changes it constructs for a single Range will remain linearizable regardless of clock skew. If all reads and writes were written to the Raft log, this would be enough to ensure consistency under arbitrary clock skew. However, Range leases allow reads to be served from a leaseholder without going through Raft. This causes complications because under sufficient clock skew, it is possible for multiple nodes to think they each hold the lease for a given Range. Without extra protection, this could lead to conflicting operations being permitted on the two leaseholders, resulting in client-visible isolation anomalies.</p><p>CRDB employs two safeguards to ensure that such situations do not affect transaction isolation.</p><p>(1) Range leases contain a start and an end timestamp. A leaseholder cannot serve reads for MVCC timestamps above its lease interval or writes for MVCC timestamps outside its lease interval. The lease disjointness invariant discussed earlier ensures that within a Range, each lease interval is disjoint from every other lease interval. (2) Each write to a Range's Raft log includes the sequence number of the Range lease that it was proposed under. Upon successful replication, the sequence number is checked against the currently active lease. If they do not match, the write is rejected. Because lease changes for a Range are themselves written to the Range's Raft log, only a single leaseholder is ever able to make changes to a Range at a time. This is true even if multiple nodes believe they hold a valid lease simultaneously. These two safeguards ensure that a pair of leaseholders that are active concurrently cannot serve requests that would violate serializable isolation. The first safeguard ensures that an incoming leaseholder cannot serve a write that invalidates a read served by an outgoing leaseholder. The second safeguard ensures that an outgoing leaseholder cannot serve a write that invalidates a read or a write served by an incoming leaseholder. Together, these safeguards ensure that even under severe clock skew that violates maximum clock offset bounds, CRDB provides serializable isolation.</p><p>While isolation is maintained regardless of clock skew, clock skew outside of the configured clock offset bounds can result in violations of single-key linearizability between causally-dependent transactions. This is possible if the transactions are issued through different gateway nodes whose clocks are skewed by more than the clock offset bounds. If the gateway node for the second transaction is assigned a commit_ts more than max_offset below the timestamp of the first transaction, it is possible for values written by the first transaction to be outside of the uncertainty interval of the second. This would allow the second transaction to read keys overlapping the write set of the first without actually observing the writes. Stale reads represent a violation of single-key linearizability and are only prevented when clocks remain within offset bounds.</p><p>To reduce the likelihood of stale reads, nodes periodically measure their clock's offset from other nodes. If any node exceeds the configured maximum offset by more than 80% compared to a majority of other nodes, it self-terminates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SQL</head><p>So far we have discussed the technical details of the Transactional KV layer and layers below, but all user interaction with the database passes through the SQL layer. CRDB supports much of the PostgreSQL dialect of ANSI standard SQL <ref type="bibr" target="#b50">[51]</ref> with some extensions (e.g., needed to support the geo-distributed nature of the database).</p><p>This section describes the SQL data model and how it maps to the layers below (Section 5.1), the technical details of SQL planning and execution (Sections 5.2 and 5.3), and schema changes (Section 5.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">SQL Data Model</head><p>Every SQL table and index is stored in one or more Ranges, as described in Section 2.1. Furthermore, all user data is stored in one or more ordered indexes, of which one is designated as the łprimaryž index. The primary index is keyed on the primary key, and all other columns are stored in the value (primary keys are automatically generated if not explicitly specified by the schema). Secondary indexes are keyed on the index key, and store the primary key columns as well as any number of additional columns specified by the index schema. CRDB also supports hash indexes, which can help avoid hot spots by distributing load across multiple Ranges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Query Optimizer</head><p>SQL query planning is performed by a Cascades-style <ref type="bibr" target="#b26">[27]</ref> query optimizer that uses over 200 transformation rules to explore the space of possible query execution plans. 5.2.1 Optgen, a DSL for query transformations. Transformation rules in CRDB are written in a domain-specific language (DSL) called Optgen that provides an intuitive syntax for defining, matching, and replacing operators in a query plan tree. Optgen compiles to Go so that the transformation rules can integrate seamlessly with the rest of the CRDB codebase (all of CRDB, with the exception of the storage layer, is implemented in Go).</p><p>For example, consider a simple Optgen rule EliminateNot:</p><p>[ E l i m i n a t e N o t , N o r m a l i z e ] ( Not ( Not $ i n p u t : * ) ) =&gt; $ i n p u t It matches scalar expressions containing two nested NOT operators, and replaces them with the input to the inner NOT. Transformation rules for relational expressions are more complex (e.g. they can call out to arbitrary Go methods), but all have the same structure with a łmatch patternž and a logically equivalent łreplace patternž separated by an arrow.</p><p>EliminateNot is an example of a Normalization (rewrite) rule, in which the source expression is replaced with the transformed expression. Exploration rules (such as join reordering and join algorithm selection) preserve both expressions so that the optimizer can select whichever one has a lower estimated cost. Consistent with the Cascades model, CRDB's optimizer uses a unified search in which application of Normalization and Exploration rules are interleaved. The generated code ensures that minimal memory is allocated for an operator until all applicable normalization rules have been applied. 5.2.2 Optimizer is distribution-aware. Many of CRDB's transformation rules can be found in other state-of-the-art query optimizers, but some are specific to the geo-distributed and partitioned nature of CRDB. For example, the optimizer can use information about a table's partitioning to infer additional filters and enable more selective index scans. Consider an index idx(region, id) on a table t partitioned across two regions, east and west. In this case, the query SELECT * FROM t WHERE id = 5 can be rewritten as SELECT * FROM t WHERE id = 5 AND (region = 'east' OR region = 'west'), thus enabling use of the index. This is similar to Oracle's index skip scan <ref type="bibr" target="#b28">[29]</ref>, but filters are determined statically from the schema rather than from histograms.</p><p>The optimizer also takes data distribution into account as part of its cost model. For some workloads, it may be beneficial to replicate a secondary index such that each region has its own copy (see Duplicated Indexes in Section 2.3). The optimizer minimizes cross-region data shuffling by assigning a cost to each index replica based on how close it is to the gateway node of a query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Query Planning and Execution</head><p>SQL query execution in CRDB is executed in one of two modes: (1) gateway-only mode, in which the node that planned the query is responsible for all SQL processing for the query, or (2) distributed mode, in which other nodes in the cluster participate in SQL processing. At the time of writing, only read-only queries can execute in distributed mode.</p><p>Since the Distribution layer presents the abstraction of a single, monolithic key space, the SQL layer can perform read and write operations for any Range on any node. This allows SQL operators to behave identically whether planned in gateway-only or distributed mode.</p><p>The decision to distribute is made by a heuristic estimating the quantity of data that would need to be sent over the network. Queries that only read a small number of rows are executed in gateway-only mode. To produce a distributed query plan when necessary, CRDB performs a physical planning stage that transforms the query optimizer's plan into a directed acyclic graph (DAG) of physical SQL operators.</p><p>Physical planning splits logical scan operations into multiple TableReader operators, one for each node containing a Range read by the scan. Once the scans are segmented, the remaining logical operators are scheduled on the same nodes as the TableReaders, thus pushing down filters, joins, and aggregations as close to the physical data as possible. Fig. <ref type="figure" target="#fig_1">3</ref> shows an example of a distributed hash join across the primary indexes of two tables, a and b, on a 3 node cluster in which node 2 holds the requested Ranges of b, but the Ranges of a are split between nodes 1 and 3. The scanned data is shuffled by hash to all nodes involved in the scan, joined with a node-local hash join operator, and sent back to the gateway node, which unions the results and returns them to the SQL client. This kind of figure can be produced by the database for any query using the EXPLAIN(distsql) command on the query.</p><p>Within a data stream, CRDB uses one of two different execution engines depending on input cardinality and plan complexity: a row-at-a-time engine or a vectorized engine. <ref type="bibr" target="#b25">[26]</ref> iterator model and processes a single row at a time. Every supported SQL feature in CRDB is implemented in this execution engine, including joins, aggregations, sorts, window functions, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Row-at-a-time execution engine. CRDB's primary execution engine is based on the Volcano</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Vectorized execution engine.</head><p>CRDB can execute a subset of SQL queries using a vectorized execution engine that was inspired by MonetDB/X100 <ref type="bibr" target="#b6">[7]</ref>. The vectorized engine operates on column-oriented batches of data instead of rows.</p><p>If the vectorized engine is chosen, data from disk is transposed from row to column format as it is being read from CRDB's KV layer, and transposed again from column to row format right before it is sent back to the end user. The overhead of this process is minimal.</p><p>In contrast to the row-at-a-time engine, operators implemented in the vectorized engine are monomorphized on all SQL data types that they support to drastically reduce the interpreter overhead inherent in the row-at-a-time iterator model. Since CRDB is written in Go, which does not support generics with specialization, this monomorphization is done using templated code generation.</p><p>All of CRDB's vectorized operators can handle the presence of a selection vector, a tightly-packed array of indices into the data columns that have not yet been filtered out by previous operators. The selection vector is used to avoid expensive physical removal of data after selection operators. Complex operators such as merge joins use monomorphization to generate multiple inner loops depending on whether a selection vector is present or not.</p><p>The optimizations described above result in a speedup of over two orders of magnitude for individual operators, and up to 4x on queries in the TPC-H [69] benchmark.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Schema Changes</head><p>CRDB performs schema changes, such as the addition of columns or secondary indexes, using a protocol that allows tables to remain online (i.e., able to serve reads and writes) during the schema change, and allows different nodes to CRDB implements the solution used by F1 <ref type="bibr" target="#b51">[52]</ref> by following a protocol that decomposes each schema change into a sequence of incremental changes. In this protocol, the addition of a secondary index requires two intermediate schema versions between the initial and final ones to ensure that the index is being updated on writes across the entire cluster before it becomes available for reads. If we enforce the invariant that there are at most two successive versions of a schema used in the cluster at all times, then the database will remain in a consistent state throughout the schema change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EVALUATION</head><p>This section evaluates the performance of CRDB along a number of axes. We begin by examining the scalability of CRDB with various workload characteristics (Section 6.1). We follow with a study of CRDB's performance in a multiregion deployment under various disaster scenarios (Section 6.2). Next, we compare the performance of CRDB to Spanner (Section 6.3). We conclude with several examples of external CRDB usage (Section 6.4). Unless otherwise noted, we use CRDB v19.2.2 in all experiments.</p><p>6.1 Scalability of CockroachDB 6.1.1 Vertical and horizontal scalability. We evaluate the vertical and horizontal scalability of CRDB on łembarrassingly parallelž workloads by running two benchmarks from the Sysbench OLTP suite <ref type="bibr" target="#b32">[33]</ref>. Fig. <ref type="figure">4</ref> shows that throughput per vCPU (for both reads and writes) stays nearly constant as the number of vCPUs increases. The left-hand side of the chart demonstrates vertical scalability, with experiments run on a three node cluster with varying AWS instance types (c5d.large, c5d.xlarge, c5d.2xlarge, c5d.4xlarge, and c5d.9xlarge with 2, 4, 8, 16, and 36 vCPUs respectively). The right-hand side of the chart demonstrates horizontal scalability, with experiments run on c5d.9xlarge instances with the cluster size varying from 3 to 48 nodes. All clusters span three AZs in us-east-1, and each point represents the average over three runs. Each experiment uses 4 tables per node and 1,000,000 rows per table, resulting in ~38 GB of data on the 48 node cluster.    <ref type="table">1</ref>: TPC-C benchmark environment and results</p><formula xml:id="formula_0">• • • • • • • • • • • 0 25,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">Scalability with cross-node coordination.</head><p>To evaluate the scalability of CRDB with varying amounts of cross-node coordination, we run TPC-C <ref type="bibr" target="#b67">[68]</ref> with a variable percentage of remote warehouses in New Order transactions. Since replication also causes cross-node coordination, we additionally vary the replication factor. Fig. <ref type="figure">5</ref> shows that in these experiments, the overhead of replication can reduce throughput by up to 48% for three replicas or 57% for five replicas, and distributed transactions may further reduce throughput by up to 46%. Despite these overheads, all workloads scale linearly with increasing cluster sizes. This experiment uses n1-standard-4 GCP machines <ref type="bibr" target="#b24">[25]</ref> (4 vCPUs each). Each point represents the average over three runs, where each run finds the maximum tpmC sustained for at least ten minutes. Since throughput in TPC-C scales with data size, the largest experiments shown here use 10,000 warehouses, corresponding to 800 GB of data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.3">TPC-C performance comparison with Amazon Aurora.</head><p>To demonstrate scalability on an industry-standard benchmark, we run TPC-C with 1,000, 10,000 and 100,000 warehouses on CRDB v19.2.0. As shown in Table <ref type="table">1</ref>, CRDB scales to support up to 100,000 warehouses, corresponding to 50 billion rows and 8 TB of data, at near-maximum efficiency. All experiments comply with the TPC-C spec (including wait times and the use of foreign keys). Amazon Aurora is a commercial database for OLTP workloads that is also designed to be scalable and fault tolerant <ref type="bibr" target="#b71">[72]</ref>. In contrast to CRDB, single-master Aurora only achieves 7.3% efficiency with 10,000 warehouses <ref type="bibr" target="#b54">[55]</ref>. AWS has not published TPC-C numbers for multi-master Aurora <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Multi-region Availability and Performance</head><p>To illustrate the trade-offs made between performance and fault tolerance by different data placement policies (Section 2.3), we measure TPC-C 1,000 performance against a multi-region CRDB cluster as we induce AZ and region failures. This experiment uses 9 n1-standard-4 GCP machines deployed across three regions in the US, in addition to workload generators per region.</p><p>The periods between the dashed lines in Fig. <ref type="figure" target="#fig_3">6</ref> represent, in order, an AZ failure and recovery, and a region-wide failure and recovery. On failure, requests are routed to fallback AZs (either in the same region or another, depending on the policy). Tables and indexes are partitioned by warehouse for partitioned policies. For the duplicated indexes policy, the read-only items table is replicated to every region.</p><p>We verify that all policies are able to tolerate AZ failures. The slight performance degradation during an AZ failure is due to the remaining AZs being overloaded. Of the four policies, only geo-partitioned leaseholders is tolerant to region-wide failures. This translates to a higher sustained throughput during region-wide failures, but comes at a cost of higher p90 latencies during stable operation and recovery (compared to the geo-partitioned replicas variants). The slower recovery period is due to the primary region catching up on missed writes. The performance degradation during region failures, depending on the policy, can be attributed to either blocked remote warehouse transactions, or clients having to cross region boundaries to issue queries. Under stable conditions, the duplicated indexes policy maintains the lowest p90 latencies.  <ref type="bibr" target="#b15">[16]</ref> benchmark suite<ref type="foot" target="#foot_1">2</ref> . As Spanner is a managed service, it does not reveal its hardware configuration. We therefore compare against several CRDB configurations (4, 8 and 16 vCPUs per node). For reference, three n2-standard-8 GCP VMs (8 vCPUs each) with local storage cost within 0.2% of a one łnodež Spanner instance (consisting of three replicas). In all tests, replicas are spread across three AZs in a single region.</p><p>For most YSCB workloads, CRDB shows significantly higher throughput. Both systems demonstrate horizontal scalability as the cluster size increases. One exception is Workload A (update-heavy, zipfian distribution of keys), on which CRDB does not scale well because of the workload's high contention profile <ref type="foot" target="#foot_2">3</ref> . We also include a test of the latency of reads and writes performed by YCSB under light load. CRDB shows significantly lower latencies at all percentiles, which we attribute in part to Spanner's commit-wait. Latency results under heavy load are noisy but show a similar trend, so we omit them due to space constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Usage Case Studies</head><p>CRDB is used by thousands of organizations. In this section we outline two specific case studies of CRDB usage. 6.4.1 Virtual customer support agent for a telecom provider. A US-based telecom provider wanted to reduce its customer service costs by building a virtual agent to provide 24/7 support to their customers. The agent relied on recording customer conversation metadata in a sessions database. The team chose CRDB for this system due to its strong consistency, regional failure tolerance, and performance for geodistributed clusters.</p><p>For financial reasons, the team deployed a multi-region CRDB cluster split across their own on-prem data center and AWS regions. CRDB's support for hybrid deployments made this feasible. To survive regional failure, they opted for the geo-partitioned leaseholders policy. Writes would need to cross region boundaries to achieve quorum, but read performance would be local. 6.4.2 Global platform for an online gaming company. An online gaming company processing 30-40 million financial transactions per day was looking for a database for their global platform. They had strict requirements on data compliance, consistency, performance and service availability. With their core user base in Europe and Australia, and a fast growing user base in the US, they sought to isolate failure domains and pin user data to specific localities for compliance and low latencies.</p><p>CRDB's architecture was a good fit for their requirements, and is now a strategic component in their long term roadmap. Fig. <ref type="figure">1</ref> shows the vision for their CRDB deployment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">LESSONS LEARNED</head><p>This section details some lessons learned over the last five years of building CRDB and hardening it as a productiongrade system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Raft Made Live</head><p>We initially chose Raft as the consensus algorithm for CRDB due to its supposed ease of use and the precise description of its implementation <ref type="bibr" target="#b45">[46]</ref>. In practice, we have found there are several challenges in using Raft in a complex system like CRDB. 7.1.1 Reducing the Chatter. Raft leaders send periodic heartbeats to each follower to maintain their leadership. As a large CRDB deployment may need to maintain hundreds of thousands of consensus groups (one per Range), this communication becomes expensive. To mitigate this overhead, we made two changes to the basic protocol: (1) we coalesce the heartbeat messages into one per node to save on the per-RPC overhead, and (2) we pause Raft groups which have seen no recent write activity. 7.1.2 Joint Consensus. Raft's default membership change protocol is simple to implement but allows for only a single addition or removal of a member at a time. It turns out that this is problematic for availability guarantees during rebalancing operations (i.e. moving a replica from one node to another). For example, in a three-region deployment constrained to one replica per region, rebalancing requires either (1) temporarily dropping down to two replicas, or (2) temporarily increasing to four replicas, with two in one region. Both intermediate configurations lose availability during a single region outage.</p><p>To solve this problem, we implemented atomic replication changes (called Joint Consensus) as detailed in <ref type="bibr" target="#b45">[46]</ref>. In Joint Consensus, an intermediate configuration exists, but requires instead the quorum of both the old and new majority for writes; this means unavailability will result only if either the old or new majority fails. The reconfiguration protocol used by Apache ZooKeeper <ref type="bibr" target="#b58">[59]</ref> is similar.</p><p>We found that implementation of Joint Consensus was not significantly more complex than the default protocol, so we recommend that all production-grade Raft-based systems use Joint Consensus instead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Removal of Snapshot Isolation</head><p>CRDB originally offered two isolation levels, SNAPSHOT and SERIALIZABLE. We made SERIALIZABLE the default because we believe that application developers should not have to worry about write skew anomalies, and in our implementation the performance advantage of the weaker isolation level was small. Still, we wanted to make the option of snapshot isolation available for users who wanted to use it to minimize the need for transaction retries.</p><p>Since CRDB was primarily designed for SERIALIZABLE, we initially expected that offering just snapshot isolation by removing the check for write skews would be simple. However, this proved not to be the case. The only safe mechanism to enforce strong consistency under snapshot isolation is pessimistic locking, via the explicit locking modifiers FOR SHARE and FOR UPDATE on queries. To guarantee strong consistency across concurrent mixed isolation levels, CRDB would need to introduce pessimistic locking for any row updates, even for SERIALIZABLE transactions. To avoid this pessimization of the common path, we opted to eschew true support for SNAPSHOT, keeping it as an alias to SERIALIZABLE instead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Postgres Compatibility</head><p>We chose to adopt PostgreSQL's SQL dialect and network protocol in CRDB to capitalize on the ecosystem of client drivers. This choice initially boosted adoption and still results today in enhanced focus and decision-making in the engineering team <ref type="bibr" target="#b49">[50]</ref>. However, CRDB behaves differently from PostgreSQL in ways that require intervention in client-side code. For example, clients must perform transaction retries after an MVCC conflict and configure result paging. Reusing PostgreSQL drivers as-is requires us to teach developers how to deploy CRDB-specific code at a higher level, anew in every application. This is a recurring source of friction which we had not anticipated. As a result, we are now considering the gradual introduction of CRDB-specific client drivers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Pitfalls of Version Upgrades</head><p>A clear upgrade path between versions with near-zerodowntime is an indispensable property of a system that prides itself on its operational simplicity. In CRDB, an upgrade consists of a rolling restart into the new binary. Running a mixed-version cluster introduces additional complexity into an already complex system and can potentially introduce serious bugs.</p><p>Early versions of CRDB replicated requests received via the KV API directly and evaluated them locally on each peer. That is, each request was: (1) proposed to raft (on the leaseholder), ( <ref type="formula">2</ref>) evaluated (on each replica), and (3) applied (on each replica).</p><p>To maintain consistency, a Range's replicas must contain identical data. Unfortunately, code changes in (2) and (3) were likely to introduce divergences between replicas running on old and new versions of the system. To address this class of problems, we moved the evaluation stage first, and now propose the effect of an evaluated request, rather than the request itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Follow the Workload</head><p>łFollow the Workloadž is a mechanism we built to automatically move leaseholders physically closer to users accessing the data. It was designed for workloads with shifting access localities where CRDB would attempt to dynamically optimize read latency, but we've found it to be rarely used in practice. CRDB's manual controls over replica placement prove sufficient for most operators who can fine tune access patterns for expected workloads. Adaptive techniques in databases <ref type="bibr" target="#b46">[47]</ref> are difficult to get right for a general purpose system, and are either too aggressive or too slow to respond. Operators favor consistency in performance; the unpredictability in this dynamic scheme hindered adoption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RELATED WORK</head><p>Distributed transaction models. There has been a great deal of work both in industry and in the literature to support distributed transactions with varying levels of consistency and scalability. Over the years, many systems with reduced consistency levels have been proposed with the goal of overcoming the scalability challenges of traditional relational database systems <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b60">61,</ref><ref type="bibr" target="#b63">64,</ref><ref type="bibr" target="#b70">71]</ref>. For many applications, however, isolation levels below serializable permit dangerous anomalies, which may manifest as security vulnerabilities <ref type="bibr" target="#b72">[73]</ref>. CRDB was designed with the philosophy that it is better to eliminate these anomalies altogether than expect developers to handle them at the application level.</p><p>Spanner <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref> is a SQL system that provides the strongest isolation level, strict serializability <ref type="bibr" target="#b29">[30]</ref>. It achieves this by acquiring read locks in all read-write transactions and waiting out the clock uncertainty window (the maximum clock offset between nodes in the cluster) on every commit. CRDB's transaction protocol is significantly different from Spanner's; it uses pessimistic write locks, but otherwise it is an optimistic protocol with a łread refreshž mechanism that increases the commit timestamp of a transaction if it observes a conflicting write within the clock uncertainty window. This approach provides serializable isolation and has lower latency than Spanner's protocol for workloads with low contention. It may require more transaction retries for highly contended workloads, however, and for this reason future versions of CRDB will include support for pessimistic read locks. Note that Spanner's protocol is only practical in environments where specialized hardware is available to bound the uncertainty window to a few milliseconds. CRDB's protocol functions in any public or private cloud.</p><p>Calvin <ref type="bibr" target="#b65">[66]</ref>, FaunaDB <ref type="bibr" target="#b21">[22]</ref> and SLOG <ref type="bibr" target="#b52">[53]</ref> provide strict serializability, but because their deterministic execution framework requires the read/write sets up front, they do not support conversational SQL. H-Store <ref type="bibr" target="#b30">[31]</ref> and VoltDB <ref type="bibr" target="#b62">[63]</ref> are main-memory databases that support serializable isolation and are optimized for partitionable workloads, but perform poorly on workloads with many cross-partition transactions since distributed transactions are processed by a single thread <ref type="bibr" target="#b78">[79]</ref>. L-Store <ref type="bibr" target="#b38">[39]</ref> and G-Store <ref type="bibr" target="#b17">[18]</ref> alleviate this problem by committing all transactions locally, but require relocating data on-the-fly if it is not already colocated.</p><p>Recent work has explored minimizing the commit time of geo-distributed transactions <ref type="bibr">[21, 28, 34, 41ś43, 75, 78]</ref>. Similar to many of these approaches, CRDB can commit transactions in one round-trip between data centers in the common case, corresponding to one round-trip of distributed consensus. Unlike systems that require global consensus or a single master region for ordering multi-partition transactions <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b52">53,</ref><ref type="bibr" target="#b65">66]</ref>, CRDB requires consensus only from partitions written in the transaction.</p><p>Distributed data placement. Several papers have considered how to place data in a geo-distributed cluster. Some <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b57">58,</ref><ref type="bibr" target="#b76">77]</ref> minimize transaction latency while maximizing availability, adhering to fault tolerance requirements, and/or balancing load. Others <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b73">74]</ref> minimize cost while adhering to latency SLOs. CRDB gives users control by supporting different data placement policies.</p><p>Another body of work considers load-based re-partitioning and placement of data. Slicer <ref type="bibr" target="#b0">[1]</ref> performs range partitioning of hashed keys, and splits/merges ranges based on load. Other systems <ref type="bibr" target="#b55">[56,</ref><ref type="bibr" target="#b56">57,</ref><ref type="bibr" target="#b64">65]</ref> support fine-grained repartitioning to alleviate hot spots and/or colocate frequently co-accessed data. Similar to that work, CRDB range-partitions based on the original keys, resulting in better locality for range scans than Slicer, but susceptibility to hot spots. To alleviate hot spots, it can also partition on hashed keys. Like Slicer, CRDB splits, merges, and moves Ranges to balance load.</p><p>Commercial Distributed OLTP DBMSs. CRDB is one of many distributed DBMS offerings on the market today for OLTP workloads, each providing different features and consistency guarantees. Spanner, FaunaDB, and VoltDB, as well as the various NoSQL systems were discussed above. Amazon Aurora <ref type="bibr" target="#b71">[72]</ref> is a distributed SQL DBMS which replicates by writing the database's redo log to shared storage. It supports high availability of read requests with six replicas spanning three AZs, but until recently <ref type="bibr" target="#b2">[3]</ref>, a single failure could cause the database to become temporarily unavailable for writes. It can only be deployed on AWS. F1 <ref type="bibr" target="#b51">[52,</ref><ref type="bibr" target="#b59">60]</ref> is a federated SQL query processing platform from Google, and was a source of inspiration for CRDB's distributed execution engine and online schema change infrastructure. F1 is not publicly available on GCP, but is used internally throughout Google. TiDB <ref type="bibr" target="#b66">[67]</ref> is an open-source distributed SQL DBMS that is compatible with the MySQL wire protocol and is designed to support HTAP workloads. NuoDB <ref type="bibr" target="#b44">[45]</ref> is a proprietary NewSQL database that scales storage independently from the transaction and caching layer. Unlike CRDB, these systems are not optimized for geo-distributed workloads and only support snapshot isolation. FoundationDB <ref type="bibr" target="#b23">[24]</ref> is an open-source key-value store from Apple that supports strictly serializable isolation. Apple's FoundationDB Record Layer <ref type="bibr" target="#b9">[10]</ref> supports a subset of SQL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION AND FUTURE OUTLOOK</head><p>CockroachDB is a source-available, scalable SQL database designed to łmake data easyž. Our novel transaction protocol achieves serializable isolation at scale without the use of specialized hardware. Consensus-based replication provides fault tolerance and high availability, as well as performance optimizations for local reads from both the leaseholder (leader) and follower replicas. Geo-partitioning and follow-the-workload features ensure that data is located closest to the users accessing it, minimizing latency due to WAN round trip requests. Finally, CockroachDB's SQL layer provides users the flexibility and familiarity of SQL, while still taking advantage of the distributed nature of CockroachDB for scalability and performance.</p><p>CockroachDB is already providing value to thousands of organizations, but we are continuing to iterate on the design and improve the software with each release. Our upcoming releases will include a completely redesigned storage layer, geo-aware query optimizations, and numerous improvements to other parts of the system. Looking further ahead, we plan to improve support for operational automation, paving the way for a future in which databases can be truly łserverlessž from a user's perspective. We have already released a fully managed service <ref type="bibr" target="#b10">[11]</ref>, but much work remains to insulate users from the operational details. Disaggregated storage, on-demand scaling, and usage-based pricing are just some of the areas we will need to develop. Making a geo-distributed database perform well in such an environment is a problem ripe for independent research. We look forward to supporting and participating in it, and furthering our mission to łmake data easyž.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Performance impact of Parallel Commits</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Physical plan for a distributed hash join</figDesc><graphic coords="9,317.96,83.69,240.22,120.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Industry 3 :</head><label>3</label><figDesc>Cloud and Distributed Databases SIGMOD '20, June 14-19, 2020, Portland, OR, USA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Multi-region cluster performance with various placement policies and AZ/region failures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Throughput of CRDB and Spanner on YCSB A-F, Latency of CRDB and Spanner under light load 6.3 Comparison with SpannerFig. 7 compares CRDB's performance against Cloud Spanner's on the YCSB<ref type="bibr" target="#b15">[16]</ref> benchmark suite 2 . As Spanner is a managed service, it does not reveal its hardware configuration. We therefore compare against several CRDB configurations (4, 8 and 16 vCPUs per node). For reference, three n2-standard-8 GCP VMs (8 vCPUs each) with local storage cost within 0.2% of a one łnodež Spanner instance (consisting of three replicas). In all tests, replicas are spread across three AZs in a single region.For most YSCB workloads, CRDB shows significantly higher throughput. Both systems demonstrate horizontal scalability as the cluster size increases. One exception is Workload A (update-heavy, zipfian distribution of keys), on which CRDB does not scale well because of the workload's high contention profile3 . We also include a test of the latency of reads and writes performed by YCSB under light load. CRDB shows significantly lower latencies at all percentiles, which we attribute in part to Spanner's commit-wait. Latency results under heavy load are noisy but show a similar trend, so we omit them due to space constraints.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>CRDB increases the likelihood that a restarted transaction will succeed by deferring the restart so the original transaction can first place write locks (in the form of write intents) on the keys it intends to write to.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>We use the official YCSB generator<ref type="bibr" target="#b75">[76]</ref> with Spanner and JDBC clients.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>We expect significant improvement for such workloads with optional read locking upcoming in the 20.1 release.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Slicer: Auto-sharding for datacenter applications</title>
		<author>
			<persName><forename type="first">Atul</forename><surname>Adya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Meek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vishesh</forename><surname>Khemani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Fulger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pan</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lakshminath</forename><surname>Bhuvanagiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Hunter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX Symposium on Operating Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="739" to="753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Volley: Automated data placement for geo-distributed cloud services</title>
		<author>
			<persName><forename type="first">Sharad</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Dunagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Navendu</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Saroiu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
	<note>Alec Wolman, and Habinder Bhogan</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Aurora</forename><surname>Amazon</surname></persName>
		</author>
		<author>
			<persName><surname>Multi-Master</surname></persName>
		</author>
		<ptr target="https://aws.amazon.com/about-aws/whats-new/2019/08/amazon-aurora-multimaster-now-generally-available/" />
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Spanner: Becoming a SQL system</title>
		<author>
			<persName><forename type="first">Nathan</forename><surname>David F Bacon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nico</forename><surname>Bales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">F</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Dickinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Campbell</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Milind</forename><surname>Gubarev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eugene</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><surname>Kogan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data</title>
		<meeting>the 2017 ACM International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">331</biblScope>
			<biblScope unit="page">343</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Bolt-on causal consistency</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Bailis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2013 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="761" to="772" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">Itzik</forename><surname>Ben-Gan</surname></persName>
		</author>
		<title level="m">Microsoft SQL Server 2012 T-SQL Fundamentals</title>
		<imprint>
			<publisher>Pearson Education</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Peter</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcin</forename><surname>Zukowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niels</forename><surname>Nes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Hyper-Pipelining Query Execution. Cidr</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="225" to="237" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
	<note>MonetDB/X</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Serializable Isolation for Snapshot Databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uwe</forename><surname>Cahill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">D</forename><surname>Röhm</surname></persName>
		</author>
		<author>
			<persName><surname>Fekete</surname></persName>
		</author>
		<idno type="DOI">10.1145/1376616.1376690</idno>
		<ptr target="https://doi.org/10.1145/1376616.1376690" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 ACM SIGMOD International Conference on Management of Data (SIGMOD &apos;08)</title>
		<meeting>the 2008 ACM SIGMOD International Conference on Management of Data (SIGMOD &apos;08)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="729" to="738" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Adapting to Access Locality via Live Data Migration in Globally Distributed Datastores</title>
		<author>
			<persName><forename type="first">Aleksey</forename><surname>Charapko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ailidani</forename><surname>Ailijiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Murat</forename><surname>Demirbas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE International Conference on Big Data (Big Data)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page">3330</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">FoundationDB Record Layer: A Multi-Tenant Structured Datastore</title>
		<author>
			<persName><forename type="first">Christos</forename><surname>Chrysafis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Dugas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jay</forename><surname>Dunkelberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moussa</forename><surname>Ehsan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alec</forename><surname>Grieser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ori</forename><surname>Herrnstadt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kfir</forename><surname>Lev-Ari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tao</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data</title>
		<meeting>the 2019 International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2019">2019. 1787ś1802</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><surname>Cockroachcloud</surname></persName>
		</author>
		<ptr target="https://www.cockroachlabs.com/product/cockroachcloud" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><surname>Cockroachdb</surname></persName>
		</author>
		<ptr target="https://github.com/cockroachdb/cockroach" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><surname>Cockroachdb</surname></persName>
		</author>
		<ptr target="https://github.com/cockroachdb/cockroach/tree/v19.2.0/licenses" />
		<title level="m">Business Source License</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><surname>Cockroachdb</surname></persName>
		</author>
		<ptr target="https://github.com/cockroachdb/cockroach/tree/master/docs/tla-plus/ParallelCommits" />
		<title level="m">TLA+ Verification of Parallel Commits</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">PNUTS: Yahoo!&apos;s hosted data serving platform</title>
		<author>
			<persName><forename type="first">Brian F</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghu</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Utkarsh</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans-Arno</forename><surname>Jacobsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Puz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramana</forename><surname>Yerneni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1277" to="1288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Benchmarking cloud serving systems with YCSB</title>
		<author>
			<persName><forename type="first">Brian F</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erwin</forename><surname>Tam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghu</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Russell</forename><surname>Sears</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM symposium on Cloud computing</title>
		<meeting>the 1st ACM symposium on Cloud computing</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="143" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Spanner: Google&apos;s Globally-distributed Database</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubarev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Hochschild</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wilson</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Kanthak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eugene</forename><surname>Kogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongyi</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergey</forename><surname>Melnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mwaura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Nagle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Quinlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajesh</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lindsay</forename><surname>Rolig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yasushi</forename><surname>Saito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michal</forename><surname>Szymaniak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruth</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dale</forename><surname>Woodford</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=2387880.2387905" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12)</title>
		<meeting>the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12)<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="251" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">G-store: a scalable data store for transactional multi key access in the cloud</title>
		<author>
			<persName><forename type="first">Sudipto</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divyakant</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amr</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM Symposium on Cloud Computing</title>
		<meeting>the 1st ACM Symposium on Cloud Computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="163" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Swaminathan Sivasubramanian, Peter Vosshall, and Werner Vogels</title>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Decandia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deniz</forename><surname>Hastorun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madan</forename><surname>Jampani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gunavardhan</forename><surname>Kakulapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avinash</forename><surname>Lakshman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Pilchin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGOPS operating systems review</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<date type="published" when="2007">2007. 205ś220</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
	<note>Dynamo: amazon&apos;s highly available key-value store</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Logical physical clocks and consistent snapshots in globally distributed databases</title>
		<author>
			<persName><forename type="first">Murat</forename><surname>Demirbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bharadwaj</forename><surname>Avva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deepak</forename><surname>Madeppa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandeep</forename><surname>Kulkarni</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Ocean vista: gossip-based visibility control for speedy geo-distributed transactions</title>
		<author>
			<persName><forename type="first">Hua</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Golab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1471" to="1484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><surname>Faunadb</surname></persName>
		</author>
		<ptr target="https://fauna.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Oracle pl/sql Programming</title>
		<author>
			<persName><forename type="first">Steven</forename><surname>Feuerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bill</forename><surname>Pribyl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Reilly Media, Inc. ž</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><surname>Foundationdb</surname></persName>
		</author>
		<ptr target="https://www.foundationdb.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">Google</forename><surname>Cloud</surname></persName>
		</author>
		<ptr target="https://cloud.google.com/compute/docs/machine-types" />
		<title level="m">Machine Types</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Volcano/spl minus/an extensible and parallel query evaluation system</title>
		<author>
			<persName><forename type="first">Goetz</forename><surname>Graefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="120" to="135" />
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The cascades framework for query optimization</title>
		<author>
			<persName><surname>Goetz Graefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="19" to="29" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">How fast can a distributed transaction commit</title>
		<author>
			<persName><forename type="first">Rachid</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jingjing</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="107" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Tim</forename><surname>Hall</surname></persName>
		</author>
		<ptr target="https://oracle-base.com/articles/9i/index-skip-scanning" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Linearizability: A correctness condition for concurrent objects</title>
		<author>
			<persName><forename type="first">P</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeannette</forename><forename type="middle">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="463" to="492" />
			<date type="published" when="1990">1990. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">H-store: a highperformance, distributed main memory transaction processing system</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Kallman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hideaki</forename><surname>Kimura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Natkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Pavlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Rasin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stanley</forename><surname>Zdonik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evan</forename><forename type="middle">Pc</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1496" to="1499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Riak core: Building distributed applications without shared state</title>
		<author>
			<persName><forename type="first">Rusty</forename><surname>Klophaus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Commercial Users of Functional Programming</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<author>
			<persName><forename type="first">Alexey</forename><surname>Kopytov</surname></persName>
		</author>
		<ptr target="http://imysql.com/wp-content/uploads/2014/10/sysbench-manual.pdf" />
	</analytic>
	<monogr>
		<title level="m">SysBench manual</title>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">MDCC: Multi-data center consistency</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Kraska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gene</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM European Conference on Computer Systems</title>
		<meeting>the 8th ACM European Conference on Computer Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="113" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Cassandra: a decentralized structured storage system</title>
		<author>
			<persName><forename type="first">Avinash</forename><surname>Lakshman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prashant</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
		<ptr target="http://lamport.azurewebsites.net/tla/tla.html" />
		<title level="m">The TLA+ Home Page</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978">1978. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The temporal logic of actions</title>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="872" to="923" />
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Towards a non-2pc transaction management in distributed database systems</title>
		<author>
			<persName><forename type="first">Qian</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pengfei</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Beng</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Chin</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kian-Lee</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhengkui</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data</title>
		<meeting>the 2016 International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016. 1659ś1674</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Minimum-cost cloud storage service across multiple cloud providers</title>
		<author>
			<persName><forename type="first">Guoxin</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haiying</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking (TON)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2498" to="2513" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Low-latency multi-datacenter databases using replicated commit</title>
		<author>
			<persName><forename type="first">Hatem</forename><surname>Mahmoud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Faisal</forename><surname>Nawab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Pucher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divyakant</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amr</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="661" to="672" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Dpaxos: Managing data closer to users for low-latency and mobile applications</title>
		<author>
			<persName><forename type="first">Faisal</forename><surname>Nawab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divyakant</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amr</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 International Conference on Management of Data</title>
		<meeting>the 2018 International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018. 1221ś1236</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Minimizing commit latency of transactions in geo-replicated data stores</title>
		<author>
			<persName><forename type="first">Faisal</forename><surname>Nawab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vaibhav</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divyakant</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amr</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2015 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015. 1279ś1294</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Scaling memcache at facebook</title>
		<author>
			<persName><forename type="first">Rajesh</forename><surname>Nishtala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans</forename><surname>Fugal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Grimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Kwiatkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Herman</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Harry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Mcelroy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Paleczny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Peek</surname></persName>
		</author>
		<author>
			<persName><surname>Saab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Presented as part of the 10th USENIX Symposium on Networked Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="385" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title/>
		<author>
			<persName><surname>Nuodb</surname></persName>
		</author>
		<ptr target="https://www.nuodb.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">In search of an understandable consensus algorithm</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Ongaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Ousterhout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 USENIX Annual Technical Conference</title>
		<title level="s">USENIX ATC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="305" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Self-Driving Database Management Systems</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Pavlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gustavo</forename><surname>Angulo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joy</forename><surname>Arulraj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haibin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiexi</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lin</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prashanth</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Perron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Quah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Wide area placement of data replicas for fast and highly available data access</title>
		<author>
			<persName><forename type="first">Fan</forename><surname>Ping</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong-Hyon</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaohu</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Mcconnell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rohini</forename><surname>Vabbalareddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fourth international workshop on Data-intensive distributed computing</title>
		<meeting>the fourth international workshop on Data-intensive distributed computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Serializable snapshot isolation in PostgreSQL</title>
		<author>
			<persName><forename type="first">Dan Rk Ports</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Grittner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">1861</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">The łPostgreSQLž in CockroachDB Ð Why?</title>
		<author>
			<persName><surname>Raphael 'kena' Poss</surname></persName>
		</author>
		<ptr target="https://dr-knz.net/postgresql-cockroachdb-why.html" />
		<imprint>
			<date type="published" when="2018-05">2018. May 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title/>
		<author>
			<persName><surname>Postgresql</surname></persName>
		</author>
		<ptr target="https://www.postgresql.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Online, Asynchronous Schema Change in F1</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Rae</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Rollins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Shute</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sukhdeep</forename><surname>Sodhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radek</forename><surname>Vingralek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1045" to="1056" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">SLOG: serializable, low-latency, geo-replicated transactions</title>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Kun Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1747" to="1761" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title/>
		<author>
			<persName><surname>Rocksdb</surname></persName>
		</author>
		<ptr target="https://rocksdb.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<author>
			<persName><forename type="first">Debanjan</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gurmit</forename><surname>Singh Ghatore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brandon O'</forename><surname>Brien</surname></persName>
		</author>
		<ptr target="https://www.slideshare.net/AmazonWebServices/dat202getting-started-with-amazon-aurora/14.AWSre" />
	</analytic>
	<monogr>
		<title level="m">Getting started with Amazon Aurora</title>
		<imprint>
			<publisher>Invent</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">202</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Accordion: Elastic scalability for database systems supporting distributed transactions</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Essam</forename><surname>Mansour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashraf</forename><surname>Aboulnaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kenneth</forename><surname>Salem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taha</forename><surname>Rafiq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Umar</forename><surname>Farooq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minhas</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1035" to="1046" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Clay: Fine-grained adaptive partitioning for general database schemas</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rebecca</forename><surname>Taft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><forename type="middle">J</forename><surname>Elmore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Pavlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashraf</forename><surname>Aboulnaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="445" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Take me to your leader!: online optimization of distributed storage configurations</title>
		<author>
			<persName><forename type="first">Artyom</forename><surname>Sharov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Shraer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arif</forename><surname>Merchant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Murray</forename><surname>Stokely</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2015">2015. 2015. 1490ś1501</date>
			<biblScope unit="volume">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Dynamic Reconfiguration of Primary/Backup Clusters</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Shraer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dahlia</forename><surname>Malkhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Flavio</forename><forename type="middle">P</forename><surname>Junqueira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Presented as part of the 2012 USENIX Annual Technical Conference</title>
		<title level="s">USENIX ATC</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="425" to="437" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">F1: A distributed SQL database that scales</title>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Shute</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radek</forename><surname>Vingralek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Samwel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>Handy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chad</forename><surname>Whipkey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Rollins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mircea</forename><surname>Oancea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyle</forename><surname>Littlefield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Menestrina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Ellner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1068" to="1079" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Wren: Nonblocking reads in a partitioned transactional causally consistent data store</title>
		<author>
			<persName><forename type="first">Kristina</forename><surname>Spirovska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Didona</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Willy</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">The case for shared nothing</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Database Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="4" to="9" />
			<date type="published" when="1986">1986. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">The VoltDB Main Memory DBMS</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Weisberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="21" to="27" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Serving large-scale batch computed data with project voldemort</title>
		<author>
			<persName><forename type="first">Roshan</forename><surname>Sumbaly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jay</forename><surname>Kreps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lei</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Feinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chinmay</forename><surname>Soman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Shah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX conference on File and Storage Technologies. USENIX Association</title>
		<meeting>the 10th USENIX conference on File and Storage Technologies. USENIX Association</meeting>
		<imprint>
			<date type="published" when="2012">2012. 18ś18</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">E-store: Fine-grained elastic partitioning for distributed transaction processing systems</title>
		<author>
			<persName><forename type="first">Rebecca</forename><surname>Taft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Essam</forename><surname>Mansour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennie</forename><surname>Duggan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><forename type="middle">J</forename><surname>Elmore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashraf</forename><surname>Aboulnaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Pavlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="245" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Calvin: fast distributed transactions for partitioned database systems</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Thomson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thaddeus</forename><surname>Diamond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shu-Chun</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kun</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2012 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title/>
		<author>
			<persName><surname>Tidb</surname></persName>
		</author>
		<ptr target="https://pingcap.com/en/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<title/>
		<author>
			<persName><surname>Tpc-C</surname></persName>
		</author>
		<ptr target="http://www.tpc.org/tpcc/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title/>
		<author>
			<persName><surname>Tpc-H</surname></persName>
		</author>
		<ptr target="http://www.tpc.org/tpch/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">An update on Sunday&apos;s service disruption</title>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Treynor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sloss</forename></persName>
		</author>
		<ptr target="https://cloud.google.com/blog/topics/inside-google-cloud/an-update-on-sundays-service-disruption" />
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Implementation of Cluster-wide Logical Clock and Causal Consistency in MongoDB</title>
		<author>
			<persName><forename type="first">Misha</forename><surname>Tyulenev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Schwerin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Asya</forename><surname>Kamsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Randolph</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alyson</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Mulrow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data</title>
		<meeting>the 2019 International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="636" to="650" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Amazon aurora: Design considerations for high throughput cloud-native relational databases</title>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Verbitski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anurag</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Debanjan</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Murali</forename><surname>Brahmadesam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kamal</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raman</forename><surname>Mittal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sailesh</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandor</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tengiz</forename><surname>Kharatishvili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaofeng</forename><surname>Bao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data</title>
		<meeting>the 2017 ACM International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017. 1041ś1052</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">ACIDRain: Concurrencyrelated attacks on database-backed web applications</title>
		<author>
			<persName><forename type="first">Todd</forename><surname>Warszawski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Bailis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data</title>
		<meeting>the 2017 ACM International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017. 5ś20</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Spanstore: Cost-effective geo-replicated storage spanning multiple cloud services</title>
		<author>
			<persName><forename type="first">Zhe</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Butkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dorian</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ethan</forename><surname>Katz-Bassett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harsha</forename><forename type="middle">V</forename><surname>Madhyastha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles</title>
		<meeting>the Twenty-Fourth ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="292" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Carousel: low-latency transaction processing for globally-distributed data</title>
		<author>
			<persName><forename type="first">Xinan</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Linguan</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongbo</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiayue</forename><surname>Charles Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernard</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kenneth</forename><surname>Salem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Brecht</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 International Conference on Management of Data</title>
		<meeting>the 2018 International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="231" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ycsb</surname></persName>
		</author>
		<ptr target="https://ycsb.site" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Global-Scale Placement of Transactional Data Stores</title>
		<author>
			<persName><forename type="first">Victor</forename><surname>Zakhary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Faisal</forename><surname>Nawab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divy</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amr</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="385" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Building consistent transactions with inconsistent replication</title>
		<author>
			<persName><forename type="first">Irene</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naveen Kr</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adriana</forename><surname>Szekeres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><forename type="middle">Rk</forename><surname>Ports</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems (TOCS)</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Solar: towards a shared-everything database on distributed log-structured storage</title>
		<author>
			<persName><forename type="first">Tao</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhuoyue</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feifei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weining</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aoying</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dong</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><surname>Stutsman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haining</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huiqi</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 USENIX Annual Technical Conference</title>
		<title level="s">USENIX ATC</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="795" to="807" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
