<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast Multiparty Threshold ECDSA with Fast Trustless Setup</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
							<email>rosario@cs.ccny.cuny.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">City University of New York</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Steven</forename><surname>Goldfeder</surname></persName>
							<email>stevenag@cs.princeton.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Fast Multiparty Threshold ECDSA with Fast Trustless Setup</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DC507AD42D9612D0953BC618E451CA5C</idno>
					<idno type="DOI">10.1145/3243734.3243859</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A threshold signature scheme enables distributed signing among n players such that any subgroup of size t + 1 can sign, whereas any group with t or fewer players cannot. While there exist previous threshold schemes for the ECDSA signature scheme, we are the first protocol that supports multiparty signatures for any t ≤ n with an efficient dealerless key generation. Our protocol is faster than previous solutions and significantly reduces the communication complexity as well. We prove our scheme secure against malicious adversaries with a dishonest majority. We implemented our protocol, demonstrating its efficiency and suitability to be deployed in practice.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>A threshold signature scheme enables n parties to share the power to issue digital signatures under a single public key. A threshold t is specified such that any subset of t + 1 players can jointly sign, but any smaller subset cannot. Generally, the goal is to produce signatures that are compatible with an existing centralized. In a threshold scheme the key generation and signature algorithm are replaced by a communication protocol between the parties, but the signatures produces are compatible with the centralized scheme and the verification algorithm is therefore unchanged.</p><p>In recent years there has been renewed attention to this topic, in particular to the threshold generation of ECDSA signatures, mostly due to the use of ECDSA in Bitcoin and other digital currencies. Cryptocurrency transactions are authorized by digital signatures, and thus proper key storage is critical for security. With a (t, n) threshold signature scheme, control of a cryptocurrency wallet can be distributed among n servers (or players) such that t + 1 of them are required to produce a signature. Crucially, the funds will remain secure even if up to t of these servers are compromised.</p><p>The study of DSA/ECDSA threshold signature schemes predates Bitcoin. Gennaro et al. <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> present a threshold scheme for DSA, but their scheme assumes an honest majority and thus requires that t &lt; n/2. Moreover, their scheme requires 2t + 1 players to participate to generate a signature. This is not ideal for several reasons. Firstly, it rules out the possibility of an n-of-n threshold signing scheme. Secondly, it provides an attacker with additional targets: while an attacker only needs to compromise t + 1 servers, the scheme requires 2t + 1 servers to generate a signature.</p><p>As Gennaro et al.'s scheme did not suport the n-of-n case, Mackenzie and Reiter built a scheme specifically for the 2-of-2 case (i.e. t = 1 and n = 2) <ref type="bibr" target="#b26">[27]</ref>. Recently much improved 2-out-of-2 schemes have been presented <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b25">26]</ref>. However 2-out-of-2 sharing is very limited and can't express more flexible sharing policies that might be required in certain applications.</p><p>Gennaro and others in <ref type="bibr" target="#b16">[17]</ref> (improved in <ref type="bibr" target="#b3">[4]</ref>) address the more general (t, n) case in the threshold optimal case, meaning n ≥ t + 1 and that only t +1 players are needed to sign. However, their scheme too has a setback in that the distributed key generation protocol is very costly and impractical.</p><p>Our Result: We present a new threshold-optimal protocol for ECDSA that improves in many significant ways over <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref>. Our protocol supports a highly efficient distributed key generation; it also supports faster signing than <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref>, and requires far less data to be transmitted between the parties (details of the comparison appear below).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Overview of our solution</head><p>Consider a "generic" DSA signature algorithm that works over any cyclic group G of prime order q generated by an element д. It uses a hash function H defined from arbitrary strings into Z q , and another hash function H ′ defined from G to Z q . The secret key is x chosen uniformly at random in Z q , with a matching public key y = д x . To sign a message M, the signer computes m = H (M) ∈ Z q , chooses k uniformly at random in Z q and computes R = д k -1 in G and r = H ′ (R) ∈ Z q . Then she computes s = k(m + xr ) mod q. The signature on M is the pair (r , s) which is verified by computing R ′ = д ms -1 mod q y r s -1 mod q in G and accepting if H ′ (R ′ ) = r .</p><p>The technical complication with sharing DSA signatures comes from having to jointly compute R (which requires raising д to the inverse of a secret value k) and to compute s which requires multiplying two secret values k, x. As shown in <ref type="bibr" target="#b17">[18]</ref> it is sufficient to show how to compute two multiplication over secret values that are shared among the players. In <ref type="bibr" target="#b17">[18]</ref> the values are shared via Shamir's secret sharing, i.e. as points on a polynomial of degree t with free term the secret. The effect of multiplication is that the degree of the polynomial is doubled, which explains why the <ref type="bibr" target="#b17">[18]</ref> solution requires at least 2t + 1 players to participate. To address this problem <ref type="bibr" target="#b26">[27]</ref> use a multiplicative sharing of the secret key x as x = x 1 • x 2 (an approach taken also in <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b25">26]</ref>) which is however hard to generalize to t &gt; 2.</p><p>A different approach was taken in <ref type="bibr" target="#b16">[17]</ref>: the secret key x is encrypted under a public key encryption scheme E, and it is the secret key of E that is shared among the players, effectively providing a secret sharing of x. If E is an additively homomorphic encryption scheme (e.g. Paillier's <ref type="bibr" target="#b28">[29]</ref>) they show that it is possible to construct a reasonably efficient protocol, with a few troubling bottlenecks. The major one is that the protocol requires a joint generation of the public key/secret key pair for the additively homomorphic encryption E by the parties. When E is instantiated using Paillier, this requires the distributed generation of an RSA modulus. Although solutions are known for this problem (e.g. <ref type="bibr" target="#b21">[22]</ref>), they are far from scalable and efficient. To our knowledge the protocol from <ref type="bibr" target="#b21">[22]</ref> has never been implemented for the malicious multiparty case. The only benchmark we are aware of for this protocol is that for the two-party semi-honest case it takes 15 minutes <ref type="bibr" target="#b25">[26]</ref>, and we can extrapolate that it would take significantly longer in the multiparty malicious setting. Moreover the signature generation protocols in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref> require long messages and complicated ZK proofs.</p><p>In this paper we take a different path inspired by the SPDZ approach to multiparty computation <ref type="bibr" target="#b8">[9]</ref>. Given two secrets a, b shared additively among the players, i.e. a = a 1 + . . . + a n and b = b 1 + . . . + b n where P i holds a i , b i , we want to generate an additive sharing of c = ab. We note that ab = i, j a i b j and therefore to get an additive sharing of ab, it is sufficient to obtain an additive sharing of each individual term a i b j . To that extent we use a 2-party protocol that allows two parties to transform multiplicative shares of a secret to additive shares of the same secret. The players engage in this protocol in a pairwise fashion to obtain an additive sharing of the product ab.</p><p>Using this approach, we build a simple and elegant threshold ECDSA protocol for the general multiparty setting. The players start with a (t, n) Shamir sharing of the secret key x. When t + 1 players want to sign, they generate an additive sharing of two random values k = i k i and γ = i γ i and they use the above idea to compute additive sharings of the products δ = kγ (which is reconstructed in the clear) and σ = kx = i w i (which is kept shared). By multiplying the local shares of γ by the public value δ -<ref type="foot" target="#foot_0">1</ref> the players end up with an additive sharing 1 </p><formula xml:id="formula_0">of k -1 . The value R is then easily computed in the exponent R = i д γ i δ -1</formula><p>. The value s is shared additively among the players since each player holds s i = k i m + w i r and s = i s i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Avoid expensive ZK Proofs in case of a Malicious Adversary</head><p>Following <ref type="bibr" target="#b25">[26]</ref> we make minimal use of ZK proofs to detect malicious behavior by the players. Instead we take an "optimistic" approach and run the protocol assuming everybody is honest. We then check the validity of the resulting signature to detect if there were players who deviated from the protocol (if the signature does not verify then obviously at least one player did not follow the instructions).</p><p>At that point, because we possibly have a dishonest majority among the players, there is no guarantee that we can generate a correct signature so the protocol stops and aborts. This creates a technical complication in the proof as we have to make sure that the values revealed by the good players do not leak any valuable information, not only in the case of good executions, but also in the case of aborting executions. As we will see, this will require us to "distributively" check that the shares s i reconstruct a valid signature before revealing them. This check is somewhat reminiscent of the way Canetti and Goldwasser solve a similar problem in <ref type="bibr" target="#b6">[7]</ref> to construct threshold CCA secure encryption based on the Cramer-Shoup scheme.</p><p>Range Proofs. Even when using the signature verification step to detect cheating, we have to run two relatively expensive ZK proofs during the share conversion protocol:</p><p>• a "range proof" that a value a encrypted under Paillier's encryption scheme is "small"; • a proof that a party knows x such that c = E(x) and y = д x where E is Paillier's encryption scheme.</p><p>As we discuss later, removing these ZK proofs creates an attack that leaks some information about the DSA secret key (and the randomizer k used in each signature) shared among the servers. We conjecture that this information is so limited that the protocol remains secure even without them (see Section 6 for details).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Experimental Results</head><p>We implemented our scheme and found both the key generation and signing protocols to be very efficient.</p><p>The key generation protocol is easy to implement and is quite fast (under a second for any reasonable choice of parameters). This is in stark contrast to <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref> for which the key generation protocol has never been implemented, and it is hard to estimate what the actual running time would be.</p><p>Our signing protocol is also extremely efficient, and is a significant improvement over previous works both in terms of data transferred and running time.</p><p>With the combination of an efficient key generation and signing protocol, our scheme is suitable to be deployed in practice. We present full benchmarks and evaluations in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>Communication Model. We assume the existence of a broadcast channel as well as point-to-point channels connecting every pair of players.</p><p>The Adversary. We assume a probabilistic polynomial time malicious adversary, who may deviate from the protocol description arbitrarily. The adversary can corrupt up to t players, and it learns the private state of all corrupted players. As in previous threshold ECDSA schemes <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b25">26]</ref>, we limit ourselves to static corruptions, meaning the adversary must choose which players to corrupt at the beginning of the protocol. There are standard techniques for converting a protocol secure against static corruptions to secure against adaptive corruptions <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b22">23]</ref>, but these will incur an overhead.</p><p>We assume a rushing adversary, meaning that the adversary gets to speak last in a given round and, in particular, can choose his message after seeing the honest parties' messages.</p><p>Following <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref> (but unlike <ref type="bibr" target="#b17">[18]</ref>), we assume a dishonest majority, meaning t, the number of players the adversary corrupts, can be up to n-1. In this case, there is no guarantee that the protocol will complete, and we therefore do not attempt to achieve robustness, or the ability to complete the protocol even in the presence of some misbehaving participants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Signature Schemes</head><p>A digital signature scheme S consists of three efficient algorithms:</p><p>• (sk, pk)←Key-Gen(1 λ ), the randomized key generation algorithm which takes as input the security parameter and returns the private signing key sk and public verification key pk. • σ ←Sig(sk, m), the possibly randomized signing algorithm which takes as input the private key sk and the message to be signed m and outputs a signature, σ . As the signature may be randomized, there may be multiple valid signatures. We denote the set of valid signatures as {Sig(sk, m)} and require that σ ∈ {Sig(sk, m)}. • b ←Ver (pk, m, σ ), the deterministic verification algorithm, which takes as input a public key pk, a message m and a signature σ and outputs a bit b which equals 1 if and only if σ is a valid signature on m under pk.</p><p>To prove a signature scheme secure, we recall the standard notion of existential unforgeability against chosen message attacks (EU-CMA) as introduced in <ref type="bibr" target="#b20">[21]</ref>.</p><p>Definition 2.1 (Existential unforgeability). Consider a PPT adversary A who is given public key pk output by Key-Gen and oracle access to the signing algorithm Sig(sk, •) with which it can receive signatures on adaptively chosen messages of its choosing. Let M be the set of messages queried by A. A digital signature scheme S =(Key-Gen,Sig,Ver) is said to be existentially unforgeable if there is no such PPT adversary A that can produce a signature on a message m M, except with negligible probability in λ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Threshold Signatures</head><p>Threshold secret sharing. A (t, n)-threshold secret sharing of a secret x consists of n shares x 1 , . . . , x n such that an efficient algorithm exists that takes as input t + 1 of these shares and outputs the secret, but t or fewer shares do not reveal any information about the secret.</p><p>Threshold signature schemes. Consider a signature scheme, S=(Key-Gen, Sig, Ver). A (t, n)-threshold signature scheme T S for S enables distributing the signing among a group of n players, P 1 , . . . , P n such that any group of at least t + 1 of these players can jointly generate a signature, whereas groups of size t or fewer cannot. More formally, T S consists of two protocols:</p><p>• Thresh-Key-Gen, the distributed key generation protocol, which takes as input the security parameter 1 λ . Each player P i receives as output the public key pk as well as a private output sk i , which is P i 's share of the private key. The values sk 1 , . . . , sk n constitute a (t, n) threshold secret sharing of the private key sk.</p><p>• Thresh-Sig, the distributed signing protocol which takes as public input a message m to be signed as well as a private input sk i from each player. It outputs a signature σ ∈ {Sig(sk, m)}. Notice that the signature output by Thresh-Sig is a valid signature under Sig, the centralized signing protocol. Thus we do not specify a threshold variant of the verification algorithm as we will use the centralized verification algorithm, Ver.</p><p>In some applications, it may be acceptable to have a trusted dealer generate the private key shares for each party. In this case, Thresh-Key-Gen would not be run.</p><p>Following <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>, we present a game-based definition of security analogous to EU-CMA. Definition 2.2 (Unforgeable threshold signature scheme <ref type="bibr" target="#b17">[18]</ref>). We say that a (t, n)-threshold signature scheme T S =(Thresh-Key-Gen,Thresh-Sig) is unforgeable, if no malicious adversary who corrupts at most t players can produce, with non-negligible (in λ) probability, the signature on any new (i.e., previously unsigned) message m, given the view of the protocol Thresh-Key-Gen and of the protocol Thresh-Sig on input messages m 1 , . . . , m k which the adversary adaptively chose as well as signatures on those messages. This is a game-based definition of security which is analogous to the notion of existential unforgeability under chosen message attack as defined by Goldwasser, Micali, and Rivest <ref type="bibr" target="#b20">[21]</ref>. Unlike in the centralized EU-CMA definition, the adversary is additionally given the corrupted players' views of the key generation protocol as well as their views in the signing protocol for the messages it chooses. A stronger simulation-based definition is also possible (see e.g. <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b25">26]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Additively Homomorphic Encryption</head><p>Our protocol relies on an encryption scheme E that is additively homomorphic modulo a large integer N . Let E pk (•) denote the encryption algorithm for E using public key pk. Given ciphertexts c 1 = E pk (a) and c 2 = E pk (b), there is an efficiently computable function + E such that</p><formula xml:id="formula_1">c 1 + E c 2 = E pk (a + b mod N )</formula><p>The existence of a ciphertext addition operation also implies a scalar multiplication operation, which we denote by × E . Given an integer s ∈ N and a ciphertext c = E pk (a), then we have</p><formula xml:id="formula_2">c × E s -E pk (as mod N )</formula><p>Informally, we say that E is semantically secure if for the probability distributions of the encryptions of any two messages are computationally indistinguishable.</p><p>We instantiate our protocol using the additively homomorphic encryption scheme of Paillier <ref type="bibr" target="#b28">[29]</ref>, and we recall the details here:</p><p>• Key-Gen: generate two large primes P, Q of equal length, and set N = PQ. Let λ(N ) = lcm(P -1, Q -1) be the Carmichael function of N . Finally choose Γ ∈ Z * N 2 such that its order is a multiple of N . The public key is (N , Γ) and the secret key is λ(N ).</p><formula xml:id="formula_3">• Encryption: to encrypt a message m ∈ Z N , select x ∈ R Z * N and return c = Γ m x N mod N 2 .</formula><p>• Decryption: to decrypt a ciphertext c ∈ Z N 2 , let L be a function defined over the set {u ∈ Z N 2 : u = 1 mod N } computed as L(u) = (u -1)/N . Then the decryption of c is computed as L(c λ(N ) )/L(Γ λ(N ) ) mod N . • Homomorphic Properties:</p><formula xml:id="formula_4">Given two ciphertexts c 1 , c 2 ∈ Z N 2 define c 1 + E c 2 = c 1 c 2 mod N 2 . If c i = E(m i ) then c 1 + E c 2 = E(m 1 + m 2 mod N ). Similarly, given a ciphertext c = E(m) ∈ Z N 2 and a number a ∈ Z n we have that a × E c = c a mod N 2 = E(am mod N ).</formula><p>The security of Paillier's cryptosystem relies on the N -residuosity decisional assumption <ref type="bibr" target="#b28">[29]</ref>, which informally says that it is infeasible to distinguish random N -residues from random group elements in Z * N 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Non-Malleable Equivocable Commitments</head><p>A trapdoor commitment scheme allows a sender to commit to a message with information-theoretic privacy. i.e., given the transcript of the commitment phase the receiver, even with infinite computing power, cannot guess the committed message better than at random. On the other hand when it comes to opening the message, the sender is only computationally bound to the committed message. Indeed the scheme admits a trapdoor whose knowledge allows to open a commitment in any possible way (we will refer to this also as equivocate the commitment). This trapdoor should be hard to compute efficiently. Formally a (non-interactive) trapdoor commitment scheme consists of four algorithms KG, Com, Ver, Equiv with the following properties:</p><p>• KG is the key generation algorithm, on input the security parameter it outputs a pair pk, tk where pk is the public key associated with the commitment scheme, and tk is called the trapdoor. and M M ′ . We require that for all efficient algorithms A, the probability that A wins is negligible in the security parameter.</p><formula xml:id="formula_5">•</formula><p>Such a commitment is non-malleable <ref type="bibr" target="#b12">[13]</ref> if no adversary A, given a commitment C to a messages m, is able to produce another commitment C ′ such that after seeing the opening of C to m, A can successfully decommit to a related message m ′ (this is actually the notion of non-malleability with respect to opening introduced in <ref type="bibr" target="#b9">[10]</ref>).</p><p>The non-malleable commitment schemes in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> are not suitable for our purpose because they are not "concurrently" secure, in the sense that the security definition holds only for t = 1 (i.e. the adversary sees only 1 commitment).</p><p>The stronger concurrent security notion of non-malleability for t &gt; 1 is achieved by the schemes presented in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b27">28]</ref>), and any of them can be used in our threshold DSA scheme.</p><p>However in practice one can use any secure hash function H and define the commitment to x as h = H (x, r ), for a uniformly chosen r of length λ and assume that H behaves as a random oracle. We use this efficient random oracle version in our implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">The Digital Signature Standard</head><p>The Digital Signature Algorithm (DSA) was proposed by Karivtz in 1991, and adopted by NIST in 1994 as the Digital Signature Standard (DSS) <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b24">25]</ref> . ECDSA, the elliptic curve variant of DSA, has become quite popular in recent years, especially in cryptocurruencies.</p><p>All of our results in this paper apply to both the traditional DSA and ECDSA. We present our results using the generic G-DSA notaiion from <ref type="bibr" target="#b16">[17]</ref>, which we recall here.</p><p>The Public Parameters consist of a cyclic group G of prime order q, a generator д for G, a hash function H : {0, 1} * → Z q , and another hash function</p><formula xml:id="formula_6">H ′ : G → Z q .</formula><p>. Key-Gen On input the security parameter, outputs a private key x chosen uniformly at random in Z q , and a public key</p><formula xml:id="formula_7">y = д x computed in G. Sig On input an arbitrary message M, -compute m = H (M) ∈ Z q -choose k ∈ R Z q -compute R = д k -1 in G and r = H ′ (R) ∈ Z q -compute s = k(m + xr ) mod q -output σ = (r, s) Ver On input M, σ and y, -check that r , s ∈ Z q -compute R ′ = д ms -1 mod q y r s -1 mod q in G -Accept (output 1) iff H ′ (R ′ ) = r .</formula><p>The traditional DSA algorithm is obtained by choosing large primes p, q such that q|(p -1) and setting G to be the order q subgroup of Z * p . In this case the multiplication operation in G is multiplication modulo p. The function H ′ is defined as</p><formula xml:id="formula_8">H ′ (R) = R mod q.</formula><p>The ECDSA scheme is obtained by choosing G as a group of points on an elliptic curve of cardinality q. In this case the multiplication operation in G is the group operation over the curve. The function H ′ is defined as H ′ (R) = R x mod q where R x is the x-coordinate of the point R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Feldman's VSS Protocol</head><p>Recall that in Shamir's scheme <ref type="bibr" target="#b32">[33]</ref>, the secret shares are evaluations of a polynomial</p><formula xml:id="formula_9">p(x) = σ + a 1 x + a 2 x 2 + • • • + a t x t mod q</formula><p>In a verifiable secret sharing scheme, auxiliary information is published that allows players to check that their shares consistently define a unique secret.</p><p>Feldman's VSS <ref type="bibr" target="#b13">[14]</ref> is an extension of Shamir's secret sharing in which the dealer also publishes</p><formula xml:id="formula_10">v i = д a i in G for all i ∈ [1, t].</formula><p>Using this auxiliary information, each player can check its share σ i for consistency by verifying:</p><formula xml:id="formula_11">д σ i ? = t 0 v z i i in G</formula><p>If the check does not hold for any player, it raises a complaint and the protocol terminates. Note that this is different than the way Feldman VSS was originally presented as it assumed an honest majority and could recover if a dishonest player raised a complaint. However, since we assume dishonest majority in this paper, the protocol will abort if a complaint is raised. While Feldman's scheme does leak д σ , it can be shown via a simulation argument that nothing else is leaked, but we omit the details here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Assumptions</head><p>DDH. Let G be a cyclic group of prime order q, generated by д. The DDH Assumption states that the following two distributions over G 3 are computationally indistinguishable:</p><formula xml:id="formula_12">DH = {(д a , д b , д ab ) for a, b ∈ R Z q } and R = {(д a , д b , д c ) for a, b, c ∈ R Z q }.</formula><p>Strong-RSA. Let N be the product of two safe primes, N = pq, with p = 2p ′ + 1 and q = 2q ′ + 1 with p ′ , q ′ primes. With ϕ(N ) we denote the Euler function of N , i.e. ϕ(N ) = (p -1)(q -1) = p ′ q ′ . With Z * N we denote the set of integers between 0 and N -1 and relatively prime to N .</p><p>Let e be an integer relatively prime to ϕ(N ). The RSA Assumption <ref type="bibr" target="#b30">[31]</ref> states that it is infeasible to compute e-roots in Z * N . That is, given a random element s ∈ R Z * N it is hard to find x such that x e = s mod N .</p><p>The Strong RSA Assumption (introduced in <ref type="bibr" target="#b1">[2]</ref>) states that given a random element s in Z * N it is hard to find x, e 1 such that x e = s mod N . The assumption differs from the traditional RSA assumption in that we allow the adversary to freely choose the exponent e for which she will be able to compute e-roots.</p><p>We now give formal definitions. Let SRSA(n) be the set of integers N , such that N is the product of two n/2-bit safe primes. Assumption 1. We say that the Strong RSA Assumption holds, if for all probabilistic polynomial time adversaries A the following probability</p><formula xml:id="formula_13">Prob[ N ← SRSA(n) ; s ← Z * N : A(N , s) = (x, e) s.t. x e = s mod N ]</formula><p>is negligible in n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A SHARE CONVERSION PROTOCOL</head><p>Assume that we have two parties Alice and Bob holding two secrets a, b ∈ Z q respectively which we can think of as multiplicative shares of a secret x = ab mod q. Alice and Bob would like to compute secret additive shares α, β of x, that is random values such that α + β = x = ab mod q with Alice holding a and Bob holding b.</p><p>Here we show a protocol based on an additively homomorphic scheme which has appeared many times before in the literature (e.g. <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b26">27]</ref> but that we adapt to our needs. We assume that Alice is associated with a public key E A for an additively homomorphic scheme E over an integer N . Let K &gt; q also be a bound which will be specified later.</p><p>In the following we will refer to this protocol as an MtA (for Multiplicative to Additive) share conversion protocol. In our protocol we also assume that B = д b might be public. In this case an extra check for Bob is used to force him to use the correct value b. We refer to this enhanced protocol as MtAwc (as MtA "with check").</p><p>(1) Alice initiates the protocol by</p><formula xml:id="formula_14">• sending c A = E A (a) to Bob • proving in ZK that a &lt; K via a range proof (2) Bob computes the ciphertext c B = b × E c A + E E A (β ′ ) = E A (ab + β ′ ) where β ′ is chosen uniformly at random in Z N .</formula><p>Bob sets his share to β = -β ′ mod q. He responds to Alice by</p><formula xml:id="formula_15">• sending c B • proving in ZK that b &lt; K • only if B = д b is public proving in ZK that he knows b, β ′ such that B = д b and c B = b × E c A + E E A (β ′ )<label>(3</label></formula><p>) Alice decrypts c B to obtain α ′ and sets α = α ′ mod q Correctness. Assume both players are honest and N &gt; K 2 q. Then note that Alice decrypts the value α ′ = ab + β ′ mod N . Note that if β ′ &lt; Nab the reduction modN is not executed. Conditioned to this event, then the protocol correctly computes α, β such that α + β = x mod q.</p><p>Since ab ≤ K 2 and N &gt; K 2 q we have that β ′ ≥ Nab with probability at most 1/q (i.e. negligible).</p><p>Simulation. We first point out that as a stand-alone protocol, we can prove security even without the range proofs. Indeed, if the adversary corrupts Alice, then Bob's message can be simulated without knowledge of its input b. Indeed a simulator can just choose a random b ′ ∈ Z q and act as Bob. The distribution of the message decrypted by Alice in this simulation is identically to the message decrypted when Bob uses the real b, because the "noise" β ′ is uniformly distributed in Z N .</p><p>If the adversary corrupts Bob, then Alice's message can be simulated without knowledge of its input a. Indeed a simulator can just choose a random a ′ ∈ Z q and act as Alice. In this case the view of Bob is computationally indistinguishable from the real one due to the semantic security of the encryption scheme E.</p><p>However if the range proofs are not used, a malicious Alice or Bob can cause the protocol to "fail" by choosing large inputs. As a stand-alone protocol this is not an issue since the parties are not even aware that the reduction modN took place and no information is leaked about the other party's input. However, when used inside our threshold DSA protocol, this attack will cause the signature verification to fail, and this information is linked to the size of the other party's input.</p><p>Consider for example the case of Alice running the protocol with input a ′ = q<ref type="foot" target="#foot_1">2</ref> +a. If Bob's input is "small" then the reduction mod N wil not take place and the protocol will succeed, and eventually the signature produced by our threshold DSA protocol will verify (since a ′ = a mod q). But if Bob's input is large the protocol will fail.</p><p>So we need security in the presence of an oracle that tells the parties if the reduction mod N happens or not, but due to the ZK "range proofs" such reduction will only happen with negligible probability and security holds.</p><p>Remark. An alternative approach. The above protocol is overwhelmingly correct, and hides b perfectly. We could modify it so that β ′ is always chosen uniformly at random in [0...N -K 2 ]. This distribution is statistically close to the uniform one over Z N (since K &gt; q), therefore the value b is now hidden in a statistical sense. On the other hand the protocol is always correct.</p><p>Remark. On the ZK proofs and the size of the modulus N . For the ZK proofs required in the protocol we use simplified versions of similar ZK proofs presented in <ref type="bibr" target="#b26">[27]</ref> and already used in <ref type="bibr" target="#b16">[17]</ref>).</p><p>These are ZK arguments with security holding under the Strong RSA Assumption. Moreover they require K q<ref type="foot" target="#foot_2">3</ref> which in turns require N &gt; q 7 . We point out that for typical choices of parameter N is approximately q 8 (since q is typically 256-bit long while N is a 2048-bit RSA modulus), so this requirement is not problematic 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">OUR SCHEME</head><p>We now describe our protocol. The players run on input G, д the cyclic group used by the DSA signature scheme. We assume that each player P i is associated with a public key E i for an additively homomorphic encryption scheme E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Key generation protocol</head><formula xml:id="formula_16">• Phase 1. Each Player P i selects u i ∈ R Z q ; computes [KGC i , KGD i ] =</formula><p>Com(д u i ) and broadcast KGC i . Each Player P i broadcasts E i the public key for Paillier's cryptosystem. • Phase 2. Each Player P i broadcasts KGD i . Let y i be the value decommitted by P i . The player P i performs a (t, n) Feldman-VSS of the value u i , with y i as the "free term in the exponent" The public key is set to y = i y i . Each player adds the private shares received during the n Feldman VSS protocols. The resulting values x i are a (t, n) Shamir's secret sharing of the secret key x = i u i . Note that the values X i = д x i are public. • Phase 3 Let N i = p i q i be the RSA modulus associated with E i . Each player P i proves in ZK that he knows x i using Schnorr's protocol <ref type="bibr" target="#b31">[32]</ref> and that he knows p i , q i using any proof of knowledge of integer factorization (e.g. <ref type="bibr" target="#b29">[30]</ref>)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Signature Generation</head><p>We now describe the signature generation protocol, which is run on input m (the hash of the message M being signed) and the output of the key generation protocol described above. We note that the latter protocol is a t-out-of-n protocol (and thus the secret key x is shared using (t, n) Shamir secret-sharing).</p><p>Let S ⊆ [1.</p><p>.n] be the set of players participating in the signature protocol. We assume that |S | = t ′ where t &lt; t ′ ≤ n. For the signing protocol we can share any ephemeral secrets using a (t ′ , t ′ ) secret sharing scheme, and do not need to use the general (t, n) structure. We note that using the appropriate Lagrangian coefficients λ i,S each player in S can locally map its own (t, n) share</p><formula xml:id="formula_17">x i of x into a (t ′ , t ′ ) share w i = λ i,S x i of x, i.e. x = i ∈S w i . Since X i = д x i and λ i,S</formula><p>are public values all the players can compute</p><formula xml:id="formula_18">W i = д w i = X λ i, S i . • Phase 1. Each Player P i selects k i , γ i ∈ R Z q ; computes [C i , D i ] = Com(д γ i ) and broadcast C i . Define k = i ∈S k i , γ = i ∈S γ i . Note that kγ = i, j ∈S k i γ j mod q kx = i, j ∈S k i w j mod q</formula><p>• Phase 2. Every pair of players P i , P j engages in two multiplicativeto-additive share conversion subprotocols -P i , P j run MtA with shares k i , γ j respectively. Let α i j [resp. β i j ] be the share received by player P i [resp. P j ] at the end of this protocol, i.e. k i γ j = α i j + β i j Player P i sets δ i = k i γ i + j i α i j + j i β ji . Note that the δ i are a (t ′ , t ′ ) additive sharing of kγ = i ∈S δ i -P i , P j run MtAwc with shares k i , w j respectively. Let µ i j</p><p>[resp. ν i j ] be the share received by player P i [resp. P j ] at the end of this protocol, i.e. k i w j = µ i j + ν i j Player P i sets σ i = k i w i + j i µ i j + j i ν ji . Note that the σ i are a (t ′ , t ′ ) additive sharing of kx = i ∈S σ i • Phase 3. Every player P i broadcasts δ i and the players reconstruct δ = i ∈S δ i = kγ . The players compute δ -1 mod q. • Phase 4. Each Player P i broadcasts D i . Let Γ i be the values decommitted by P i who proves in ZK that he knows γ i s.t. Γ i = д γ i using Schnorr's protocol <ref type="bibr" target="#b31">[32]</ref>.</p><p>The players compute</p><formula xml:id="formula_19">R = [ i ∈S Γ i ] δ -1 = д ( i ∈S γ i )k -1 γ -1 = д γ k -1 γ -1 = д k -1</formula><p>and r = H (R). • Phase 5. Each player P i sets s i = mk i + rσ i . Note that i ∈S</p><formula xml:id="formula_20">s i = m i ∈S k i + r i ∈S σ i = mk + rkx = k(m + xr ) = s i.e. the s i are a (t ′ , t ′ ) sharing of s. -(5A) Player P i chooses ℓ i , ρ i ∈ R Z q computes V i = R s i д ℓ i , A i = д ρ i , B i = д ℓ i ρ i and and [ Ĉi , Di ] = Com(V i , A i , B i )</formula><p>and broadcasts Ĉi . Let ℓ = i ℓ i and ρ = i ρ i .</p><p>-(5B) Player P i broadcasts Di and proves in ZK that he</p><formula xml:id="formula_21">knows s i , ℓ i such that V i = R s i д ℓ i and B i = A ℓ i i . If a ZK proof fails, the protocol aborts. Let V = д -m y -r i ∈S V i (this should be V = д ℓ ) -(5C) Player P i computes U i = V ρ i and T i = [ j i A j ] ℓ i = д ℓ i (ρ-ρ i ) . It commits [ Ci , Di ] = Com(U i ,T i ) and broad- casts Ci . -(5D) Player P i broadcasts Di to decommit to U i ,T i If i ∈S [T i B i ]</formula><p>i ∈S U i the protocol aborts. -(5E) Otherwise player P i broadcasts s i . The players compute s = i ∈S s i . If (r , s) is not a valid signature the players abort, otherwise they accept and end the protocol. Let us explain the intuition behind Phase 5. To avoid expensive ZK proofs, we are potentially reconstructing an incorrect signature, which is then checked and possibly rejected. A naive approach to the last phase is for the players to reveal s i and reconstruct s = i s i . But, for reasons that will become clear in the proof, this is not provably secure -the intuitive reason being that if the adversary makes the protocol fail by outputting an invalid signature the values s i held by the good players may give him valuable information. 3   Naively this could be done by first broadcasting S i = R s i and check that i S i = R s = д m y r according to the DSA verification algorithm. But for similar reasons, this step makes the proof fail. So in our protocol the players mask R s i with a random value</p><formula xml:id="formula_22">д ℓ i . Let V i = R s i д ℓ i . Then i V i = R s д ℓ and therefore V = д ℓ .</formula><p>The players cannot reveal д ℓ i to check the correctness of V as this would "de-mask" R s i so we "randomize" the "aggregate" value to U = д ℓρ . Alongside the players compute д ℓρ via pairwise "Diffie-Hellman" exchanges. If this distributed randomized signature verification carries out, then it is safe to release the shares s i , but if the signature does not verify then the protocol aborts here and the values s i held by the good players are never revealed in the clear.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The Zero-Knowledge Proofs</head><p>In step (5B) a player P outputs V = R s д ℓ and A, B = A ℓ and must prove that he knows s, ℓ satisfying the above relationship. A classic (honest-verifier) ZK proof for this task is as follows:</p><p>• The Prover chooses a, b ∈ R Z q and sends α = R a д b and β = A b • The Verifier sends a random challenge c ∈ R Z q • The Prover answers with t = a + cs mod q and u = b + cℓ mod q. • The Verifier checks that R t д u = αV c and A u = βB c</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Security Proof</head><p>In this section we prove the following Theorem 4.1. Assuming that • The DSA signature scheme is unforgeable;</p><p>• The Strong RSA Assumption holds;</p><p>• KG, Com, Ver, Equiv is a non-malleable equivocable commitment scheme; • the DDH Assumption holds then our threshold DSA scheme in the previous section is unforgeable. 3 We do not have an attack but we do not see a way to make a proof work either.</p><p>The proof of this theorem will proceed by a traditional simulation argument, in which we show that if there is an adversary A that forges in the threshold scheme with a significant probability, then we can build a forger F that forges in the centralized DSA scheme also with a significant probability. So let's assume that there is an adversary A that forges in the threshold scheme with probability larger than ϵ ≥ λ -c .</p><p>We assume that the adversary controls players P 2 , . . . , P t +1 and that P 1 is the honest player. We point out that because we use concurrently non-malleable commitments (where the adversary can see many commitments from the honest players) the proof also holds if the adversary controls less than t players and we have more than 1 honest player. So the above assumption is without loss of generality.</p><p>Because we are assuming a rushing adversary, P 1 always speaks first at each round. Our simulator will act on behalf of P 1 and interact with the adversary controlling P 2 , . . . , P n . Recall how A works: it first participates in the key generation protocol to generate a public key y for the threshold scheme. Then it requests the group of players to sign several messages m 1 , . . . , m ℓ , and the group engages in the signing protocol on those messages. At the end with probability at least ϵ the adversary outputs a message m m i and a valid signature (r , s) for it under the DSA key y. This probability is taken over the random tape τ A of A and the random tape τ 1 of P 1 . If we denote with A(τ A ) P 1 (τ 1 ) the output of A at the end of the experiment described above, we can write</p><formula xml:id="formula_23">Prob τ 1 ,τ A [ A(τ A ) P 1 (τ 1 ) is a forgery ] ≥ ϵ</formula><p>We say that an adversary random tape τ A is good if</p><formula xml:id="formula_24">Prob τ 1 [ A(τ A ) P 1 (τ 1 ) is a forgery ] ≥ ϵ 2</formula><p>By a standard application of Markov's inequality we know that if τ A is chosen uniformly at random, the probability of choosing a good one is at least ϵ 2 . We now turn to building the adversary F that forges in the centralized scheme. This forger will use A as a subroutine in a "simulated" version of the threshold scheme: F will play the role of P 1 while A will control the other players. F will choose a random tape τ A for A: we know that with probability at least ϵ 2 it will be a good tape. From now on we assume that A runs on a good random tape.</p><p>F runs on input a public key y for the centralized DSA scheme, which is chosen according to the uniform distribution in G. The first task for F is to set up an indistinguishable simulation of the key generation protocol to result in the same public key y.</p><p>Similarly every time A requests the signature of a message m i , the forger F will receive the real signature (r i , s i ) from its signature oracle. It will then simulate, in an indistinguishable fashion, an execution of the threshold signature protocol that on input m i results in the signature (r i , s i ).</p><p>Because these simulations are indistinguishable from the real protocol for A, the adversary will output a forgery with the same probability as in real life. Such a forgery m, r , s is a signature on a message that was never queried by F to its signature oracle and therefore a valid forgery for F as well. We now turn to the details of the simulations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Simulating the key generation protocol</head><p>The simulation Sim-Key-Gen is described below. On input a public key y = д x for DSA the forger F plays the role of P 1 as follows.</p><p>The forger F also runs on input a public key E for which he does not know the matching secret key (this is necessary for when we have to make a reduction to the semantic security of the Paillier encryption scheme).</p><p>Simulation: Repeat the following steps (by rewinding A) until A sends valid messages (i.e. a correct decommitment) for P 2 , . . . , P n on both iterations.</p><p>• F (as P 1 ) selects a random value u 1 ∈ Z q , computes [KGC 1 , KGD 1 ]= Com(д u 1 ) and broadcasts KGC 1 . A broadcast commitments KCG i for i &gt; 1; • Each player P i broadcasts KGD i ; let y i be the decommitted value and the accompanying Feldman-VSS (F will follow the protocol instructions). Each player broadcasts E i . F broacasts E 1 = E. • Let y i the revealed commitment values of each party. F rewinds the adversary to the decommitment step and changes the opening of P 1 to KGD 1 so that the committed value revealed is now ŷ1 = y • n i=2 y -1 i .</p><p>simulates the Feldman-VSS with free term ŷ1 • The adversary A will broadcasts KGD i . Let ŷi be the committed value revealed by A at this point (this could be ⊥ if the adversary refused to decommit). • The players compute ŷ = t +1 i=1 ŷi (set to ⊥ if any of the ŷi are set to ⊥ in the previous step). We now prove a few lemmas about this simulation. Lemma 4.2. The simulation terminates in expected polynomial time and is indistinguishable from the real protocol.</p><p>Proof of Lemma 4.2. Since A is running on a good random tape, we know that the probability over the random choices of F , that A will correctly decommit is at least ϵ 2 &gt; 1 2λ c . Therefore we will need to repeat the loop only a polynomial number of times in expectation.</p><p>The only differences between the real and the simulated views is that P 1 runs a simulated Feldman-VSS with free term in the exponent ŷ1 for which it does not know the discrete log. But we have shown in Section 2.6 that this simulation is identically distributed from the real Feldman-VSS. So the simulation of the protocol is perfect. □ Lemma 4.3. For a polynomially large fraction of inputs y, the simulation terminates with output y except with negligible probability.</p><p>Proof of Lemma 4.3. First we prove that if the simulation terminates on an output which is not ⊥, then it terminates with output y except with negligible probability. This is a consequence of the non-malleability property of the commitment scheme. Indeed, if A correctly decommits KGC i twice it must do so with the same string, no matter what P 1 decommits too (except with negligible probability) 4 . Therefore ŷi = y i for i &gt; 1 and therefore ŷ = y. 4 This property is actually referred to as independence. This is introduced in <ref type="bibr" target="#b19">[20]</ref> as a stronger version of non-malleability and then proven equivalent to non-malleability in <ref type="bibr" target="#b3">[4]</ref>).</p><p>Then we prove that this happens for a polynomially large fractions of input y. Let y A = t +1 i=2 y i , i.e.the contribution of the adversary to the output of the protocol. Note that because of nonmalleability this value is determined and known to F by the time it rewinds the adversary. At that point F rewinds the adversary and chooses ŷ1 = yy -1</p><p>A . Since y is uniformly distributed, we have that ŷ1 is also uniformly distributed. Because A is running on a good random tape we know that at this point there is an ϵ 2 &gt; 1 2λ c fraction of ŷ1 for which A will correctly decommit. Since there is a 1-to-1 correspondence between y and ŷ1 we can conclude that for a ϵ 2 &gt; 1 2λ c fraction of the input y the protocol will successfully terminate. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Signature generation simulation</head><p>After the key generation is over, F must handle the signature queries issued by the adversary A. When A requests to sign a message m, our forger F will engage in a simulation of the threshold signature protocol. During this simulation F will have access to a signing oracle that produces DSA signatures under the public key y issued earlier to F .</p><p>Semi-Correct Executions. Let k be such that R = д k -1 and let k be the value defined by the inputs of the players in the MtA and MtAwc protocols. More specifically if c i is the encryption sent by player P i in the first round of those protocols, then define ki = Dec i (c i ) and k = i ki .</p><p>We say that a protocol execution is semi-correct if in step ( <ref type="formula">4</ref>) it holds that k = k. Note that this condition is well defined since the values k, k are uniquely determined by step (4). It is however not feasible to decide if an execution is semi-correct or not.</p><p>Note that an execution is not semi-correct if the adversary "messes" up the computation of R by revealing wrong shares in the computation of δ .</p><p>Bird-Eye View of Simulation. First we note that for semi-correct executions the adversary, after Step 4 can already detect if the value R s 1 which will be broadcast in Step <ref type="bibr" target="#b4">(5)</ref> by the good player is correct or not. In fact by this point the adversary has s i for i &gt; 1 and for a "candidate"</p><formula xml:id="formula_25">R s 1 can check if i R s i = R s = д m y r</formula><p>Moreover in such executions when we arrive to step (5A) the simulator will be able to "extract" the value s 1 for the good player, which will allow the simulation to terminate successfully.</p><p>Second, we show that a simulation that is not semi-correct will fail at step (5D) with high probability since the value U 1 contributed by the good player is indistinguishable from random. This allows us to simulate Phase (5) by simply using a random s1 for P 1 .</p><p>The final question is how do we detect if an execution is semicorrect or not. Here we use an idea from <ref type="bibr" target="#b25">[26]</ref>: the forging simulator will guess which one (if any) of the Q signature queries result in an execution which is not semi-correct. Since this execution will be an aborting execution, the simulation will stop there. With probability 1/(Q + 1) the guess will be correct and the simulation will succeed, and the forger will be able to produce a forgery.</p><p>We now proceed with the details.</p><p>Session 6C: Crypto 3 CCS'18, October 15-19, 2018, Toronto, ON, Canada</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Semi-correct executions</head><p>We now present a simulation that works for a semi-correct execution. We point out that F does not know the secret values associated with P 1 : its correct share w 1 of the secret key, and the secret key of its public key E 1 . The latter is necessary in order to reduce unforgeability to the semantic security of the encryption scheme. However F knows the secret keys of all the other players, and their shares w j . It also knows the "public key" of P 1 , W 1 = д w 1 from the simulation of the key generation protocol.</p><p>In the following simulation F aborts whenever the protocol is supposed to abort, i.e. if the adversary (i) refuses to decommit in steps 4, 5B or 5D or (ii) fails the ZK proof in Step 2 or 5 or (iii) the signature (r, s) does not verify.</p><p>• Phase 1 All the players execute the protocol by broadcasting C i (F runs the protocol correctly for P 1 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Phase 2</head><p>-All the players execute the MtA protocol for k and γ . F runs the protocol correctly for P 1 but it cannot decrypt the share α 1j during the execution of the protocol with P j on input k 1 , γ j , so F sets α i j to a random value in Z q -All the players execute the MtAwc protocol for k and x.</p><p>Here F simulates P 1 according to the simulation described in Section 3. Moreover it extracts P j resulting share ν 1j from his ZK proof.</p><p>In the protocol with P j on input k j , w 1 , F does not know w 1 so it just sends a random µ j1 to P j Note that at this point F knows σ i for the bad players. Indeed</p><formula xml:id="formula_26">σ i = k i w i + j µ i j + j ν ji</formula><p>and F knows all the values on the right end side of the equation. • Phase 3 All the players execute the protocol by revealing δ i .</p><p>Let δ = i δ i (F runs the protocol correctly for P 1 with the random shares it chose in step 2 -therefore F is effectively broadcasting a random δ 1 ). • Phase 4</p><p>(1) Each player reveals D i to decommit to Γ i (2) F queries its signature oracle and receives a signature (r , s) on m.</p><formula xml:id="formula_27">It computes R = д ms -1 y r s -1 ∈ G (note that H ′ (R) = r ∈ Z q ).</formula><p>(3) F rewinds A to the decommitment step, and for</p><formula xml:id="formula_28">P 1 changes the decommitment to Γ1 = R δ i &gt;1 Γ -1 i . Note that [ Γ1 i &gt;1 Γ i ] δ -1 = R</formula><p>Note that at this point F knows the value s i held by the bad players since s i = k i m + σ i r . So F can compute the correct s 1 held by P 1 as si &gt;1 s i .</p><p>• Phase 5 All players execute all the steps in this phase. F uses s 1 as the share for P 1</p><p>We prove the following Lemma about the simulation. then the simulation has the following properties</p><p>• on input m it outputs a valid signature (r , s) or aborts.</p><p>• it is computationally indistinguishable from a semi-correct real execution</p><p>Proof of Lemma 4.4. The only differences between the real and the simulated views is the following: In the MtA protocol the values</p><formula xml:id="formula_29">c i = E i (k i ) are published and in the real protocol R = д k -1 where k = i k i , while in the simulated execution R = д k -1</formula><p>for the k chosen by the signature oracle. This is easily seen to be computationally indistinguishable under the semantic security of Paillier's encryption.</p><p>Indeed, when F rewinds the adversary to "fix" the value of R, it implicitly changes the value k 1 that F contributes for</p><formula xml:id="formula_30">P 1 to R. If R = д k -1 , let (implicitly) k1 = k -i &gt;1 k i . Note that R k1 is known since R k1 + i &gt;1 k i = д, therefore R k1 = дR -k 2 .</formula><p>So to distinguish between the real execution and the simulated one the adversary should detect if the ciphertext sent by F for P 1 in the first round of the MtAwc protocol contains a random k 1 or the random k1 determined as log R (дR -k 2 ) which is infeasible under the semantic security of Paillier's encryption (given that all values are proven to be "small" and no wraparound modN happens).</p><p>Note that we are simulating a semi-correct execution with an execution which is not semi-correct, but that's OK because the two are indistinguishable.</p><p>However, because the real execution is a semi-correct one, we know that the correct shares of k for the adversary are the k i that the simulator knows. Therefore the value s 1 computed by the simulator is consistent with a correct share for P 1 for a valid signature (r , s), which makes Phase 5 indistinguishable from the real execution to the adversary.</p><p>Let (r, s) be the signature that F receives by its signature oracle in Step 2 of Phase 4. This is a valid signature for m. We prove that if the protocol terminates, it does so with output (r , s). This is a consequence of the non-malleability property of the commitment scheme. Indeed, if the adversary correctly decommits, its openings must be the same except with negligible probability. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.8">Simulation of a non semi-correct execution</head><p>We now show how to simulate the last execution for a non semicorrect execution when k k. Details follow.</p><p>• Phases 1 to 3 The simulator runs the semi-correct simulation through Phase 3 (including aborting at Phase 4 if the adversary fails to decommit). • Phase 4 F does not rewind the adversary to "fix" the value of R, but runs the protocol normally for P 1 . • sf Phase (5) F chooses s1 ∈ R Z q and runs Phase 5 with this value instead of s 1 .</p><p>Before we prove that this simulation is indistinguishable for nonsemi-correct executions let us give an intuition. Note that the only difference with the previous simulation is that here F uses a random share s1 instead of the s 1 that it computed in the other simulation. The reason is that the value s 1 computed in the previous simulation is only guaranteed to be the "correct" share of s if the execution is semi-correct. If the adversary shares k i don't match anymore the value R then s 1 is incorrect, and therefore F chooses a random value instead. In turns this causes U 1 to be uniformly distributed and the check in step (5D) to fail.</p><p>The main point of the proof is that if the execution is not semicorrect then the value U 1 is (given the view of the adversary) computationally indistinguishable from uniform even in the real execution (under the DDH assumption).</p><p>Our proof reflects the above intuition. First we prove that a real non-semi-correct execution is indistinguishable from one in which P 1 outputs a random S 1 . And then we prove that this is indistinguishable from the simulation above. Lemma 4.5. Assuming that</p><p>• KG, Com, Ver, Equiv is a non-malleable equivocable commitment; • the DDH Assumptions holds then the simulation is computationally indistinguishable from a nonsemi-correct real execution Proof of Lemma 4.5. We construct three games between the simulator (running P 1 ) and the adversary (running all the other players). In G 0 the simulator will just run the real protocol. In G 1 the simulator will follow the real protocol but will choose S 1 as a random group element. In G 2 the simulator will run the above simulation.</p><p>Indistinguishability of G 0 and G 1 Let us assume that there is an adversary A 0 that can distinguish between G 0 and G 1 . We show how this contradicts the DDH Assumption.</p><p>Let A = д a , B = д b , C = д c be the DDH challenge where c = ab or random in Z q .</p><p>The distinguisher F 0 runs A 0 , simulating the key generation phase so that y = B = д b . It does that by rewinding the adversary at the end of Phase 2 of the key generation protocol and changing the decommitment of P 1 to y 1 = b i &gt;1 y -1 i . F 0 also extracts the values x i from the adversary. Note that at this point y = B and F 0 knows x i , but not b and therefore not x 1 . Moreover F 0 extracts the secret key for the encryption keys E i for i &gt; 1. In this simulation F 0 also knows the secret key matching E 1 (since we are not making any reduction to the security of the encryption scheme).</p><p>Then F 0 runs the signature generation protocol for a not-semicorrect execution. Remember here we assume that we have a (t ′ , t ′ ) sharing of the secret key. So b = i ∈S w i with F 0 knowing w i for i &gt; 1 but not knowing w 1 . Denote with w A = i &gt;1 w i (which is known to F 0 ) and therefore w 1 = bw A .</p><p>F 0 runs the protocol normally for Phases 1,2,3,4. It extracts the value γ i for i &gt; 1 from the adversary (and he knows γ 1 since he ran P 1 normally). Therefore F 0 knows k such that R = д k -1 since k = ( i γ i )δ -1 . It also knows k 1 since it was chosen normally according to the protocol. Before moving to the simulation of Phase 5, let's look at the MtAwc protocol for the computation of the shares σ i .</p><p>We note that since F 0 knows the decryption key for E 1 he also knows all the shares µ 1j from the invocation of the MtAwc protocol between P 1 and P j on input k 1 and w j respectively <ref type="foot" target="#foot_3">5</ref> .</p><p>For the MtAwc protocol between P 1 and P j on input w 1 and k j respectively, F 0 knows the value k j input by P j since he has extracted the secret key of E j . However F 0 does not know w 1 therefore he sends a random µ j1 to P j and sets (implicitly) ν j1 = k j w 1 -α j1 .</p><p>At the end we have that the share σ 1 held by P 1 is</p><formula xml:id="formula_31">σ 1 = k 1 w 1 + j &gt;1 µ 1j + j &gt;1 ν j1</formula><p>by rearranging the terms and substituting the above we get</p><formula xml:id="formula_32">σ 1 = kw 1 + j &gt;1 µ 1j - j &gt;1 µ j1</formula><p>where k = i k i . Remember that since this is not a semi-correct execution then k k where R = д k -1 . Since w 1 = bw A we have</p><formula xml:id="formula_33">σ 1 = kb + µ 1 where µ 1 = j &gt;1 µ 1j - j &gt;1 µ j1 -kw A with µ 1 , k known to F 0 .</formula><p>Note that this allows F 0 to compute the correct value</p><formula xml:id="formula_34">д σ 1 = B k д µ 1</formula><p>and therefore the correct value of R s 1 as</p><formula xml:id="formula_35">R s 1 = R k 1 m+r σ 1 = д k -1 (k 1 m+r σ 1 ) = д k -1 (k 1 m+r µ 1 ) B k -1 kr or R s 1 = д μ1 B β1</formula><p>where μ1 = k -1 (k 1 m + r µ 1 ) and β1 = k -1 kr and μ1 and β1 are known to F 0 . We now continue the simulation</p><formula xml:id="formula_36">• 5A/5B F 0 selects a random ℓ 1 and sets V 1 = R s 1 д ℓ 1 A 1 = д ρ 1 = A = д a and B 1 = д ρ 1 ℓ 1 = A ℓ 1 .</formula><p>It simulates the ZK proof (since it does not know ρ 1 or s 1 ). It extracts s i , ℓ i from the adversary such that</p><formula xml:id="formula_37">V i = R s i д ℓ i = д k -1 s i д ℓ i . Let s A = i &gt;1 k -1 s i Note that V = д -m y -r i V i = д -m y -r V 1 i &gt;1 V i</formula><p>and therefore substituting the above relations (and setting</p><formula xml:id="formula_38">ℓ = i ℓ i ) V = д ℓ R s 1 д s A -m y -r</formula><p>Note that y = B so y -r = B -r . Therefore</p><formula xml:id="formula_39">V = д ℓ д μ1 B β1 д s A -m B -r or V = д ℓ д θ B κ</formula><p>where θ = μ1 + s A -m and κ = β1 -r known to F 0 . Note that for executions that are not semi-correct 0 • 5C/5D F 0 computes T 1 correctly (which he can do since he knows ℓ 1 ) but for U 1 outputs U 1 = A θ C κ and it aborts.</p><p>Note what happens when C = д ab . By our choice of a = ρ 1 and b = x we have that U 1 = V ρ 1 as in Game G 0 . However when C is a random group element, U 1 is uniformly distributed as in G 1 .</p><p>Therefore under the DDH assumption G 0 and G 1 are indistinguishable.</p><p>Indistinguishability of G 1 and G 2 We note that in G 2 the simulator really computes U 1 as V ρ 1 (rather than outputting a random group element). However since s1 is chosen at random we have that U 1 follows a uniform distribution in both games.</p><p>In Phase (5B) F broadcasts a random Ṽ1 = R s1 д ℓ 1 which is indistinguishable from the correct V 1 = R s 1 д ℓ 1 because of the "mask" д ℓ 1 which (under the DDH) is computationally indistinguishable from a random value, given that the adversary only has A 1 , B 1 .</p><p>Therefore under the DDH assumption the games G 1 and G 2 are indistinguishable. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.9">Finishing up the proof</head><p>Before we conclude the proof we note that our protocol detects the presence of a malicious adversary by noticing that the signature does not verify. As pointed out by Lindell in <ref type="bibr" target="#b25">[26]</ref> this strategy is not immediately simulatable against a malicious adversary for the following reason. Consider what happens in Phase 5: In the semicorrect simulation F rewinds the adversary to "hit" the correct s.</p><p>But if the adversary had decided to be malicious and terminate the protocol with an invalid signature, then the protocol would not be simulatable. If F hits an invalid signature "on purpose" (e.g. by not rewinding), then the simulation is distinguishable by a semi-honest adversary who does hit the correct signature.</p><p>Luckily for a "game-based" definition of security, this is not an issue as discussed in <ref type="bibr" target="#b25">[26]</ref>. Let Q &lt; λ c the maximum number of signature queries that the adversary makes. In the real protocol, the adversary will output a forgery after ℓ &lt; Q queries, either because it stops submitting queries, or because the protocol aborts. Therefore in our simulation, following Lindell <ref type="bibr" target="#b25">[26]</ref>, we choose a random index ι ∈ [0...Q]:</p><p>• if ι = 0 we assume that all executions are semi-correct. In this case we can always simulates as in the previous section • otherwise we assume that the first ι -1 executions are semicorrect, but at the ι t h execution the value V is not equal to д ℓ .</p><p>With probability 1/(Q + 1) ≥ λ -c this is a correct guess.</p><p>We can now complete the proof.</p><p>Proof of Theorem 4.1. Unforgeability. The forger F described above produces an indistinguishable view for the adversary A, and therefore, A will produce a forgery with the same probability as in real life. The success probability of F is at least ϵ 3 8Q where Q is the maximum number of queries. That's because F has to succeed in</p><p>• choosing a good random tape for A (this happens with probability larger than ϵ 2 ) • hitting a good public key y (this also happens with probability larger than ϵ 2 ) • guessing the correct index query ℓ (this happens with probability larger than 1/Q Under those conditions, the adversary A will output a forgery with probability at least ϵ 2 . Under the security of the DSA signature scheme, the probability of success of F must be negligible, which implies that ϵ must also be negligible, contradicting the assumption that A has a non-negligible probability of forging. Correctness. If all players are honest, the protocol fails only if one of the MtA protocols fails. Since we have a total of 4n 2 such sub-protocols executed during a run of our signature protocol, we have that our protocol fails with probability at most 4n 2 q which is negligible. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXTENSIONS</head><p>In the final version of the paper we will present the following natural extensions to our result.</p><p>Other additively homomorphic schemes. Our optimistic scheme works with any additively homomorphic scheme with no modification. It requires an assumption analogous to the Paillier-EC (or an efficient ZK Proof for the statement in the MtAwc protocol).</p><p>Other multiplicative to share conversions. Again, our optimistic protocol works with any protocol that allows two parties to convert their multiplicative shares of a secret into additive shares.</p><p>In particular protocols based on oblivious transfer can be used (see the literature on SPDZ or the recent work on threshold DSA in <ref type="bibr" target="#b11">[12]</ref>).</p><p>Deterministic Key Generation A very popular feature of Bitcoin wallets is deterministic key generation. Introduced in Bitcoin-Improvement-Proposal 32 (BIP32), the idea of this scheme is to allow one to deterministicly generate many keys from a single ECDSA key. Our key sharing is compatible with BIP32 public derivations, and we leave it as future work to prove security in this setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">REMOVING THE ZK PROOFS FROM THE MTA PROTOCOL</head><p>As we mentioned in the Introduction, the ZK proofs in the MtA protocol are the most expensive step of our protocol due not only to the fact that these are ZK proofs over the Paillier cryptosystem, but also that every player has to run n of them (since they are specific to each execution of the MtA protocol).</p><p>We consider what happens if the range proofs are eliminated. As we discussed in Section 3 the MtA protocol needs to be secure in the presence of an oracle that tells the parties if a reduction mod N happens during the execution. Note that in reality the oracle represents the failure of the verification of the signature generated by the protocol, and if that happens the system is reset. So the oracle is a very weak oracle, which stops the working the moment it tells you that a reduction modN happened.</p><p>We conjecture that our protocol remains secure even if the ZK proofs are eliminated for Alice and simplified for Bob in the MtA protocol and simplified in the MtAwc protocol. More precisely both the MtA and MtAwc protocol work as follow:</p><p>• Neither party proves that their values a, b are "small"</p><formula xml:id="formula_40">• Bob broadcasts B = д b , B ′ = д β ′</formula><p>together with a ZK proof of knowledge for b, β ′ mod q using Schnorr's prooof <ref type="bibr" target="#b31">[32]</ref>. Alice also checks that д α = B a B ′ . We point out that B = д b is public in our threshold DSA protocol. Indeed in one case b = w i , the share of the secret key x held by player P i and B = д b is public at the end of the key generation phase together with a ZK proof of knowledge. In the other case b = γ i , and B = д b will be public at the end of following round which is when Alice performs the above check.</p><p>To support our conjecture we propose some "ad-hoc" computational assumptions which if true, they would guarantee the security of the protocol. The assumptions are new and non-standard, yet they look reasonable. We discuss them informally below -a full proof of security will appear in the final version.</p><p>Information Leaked to Alice by removing the Range Proof. If we remove the proofs that the input a used by Alice is small, we leak information about the input used by Bob via the knowledge that a reduction modN happened or not. Notice that Bob's inputs to the MtA and MtAwc protocols are the share of ρ (the mask for the inversion of k) and the share of x (the secret key).</p><p>Note that these values are all "high entropy" secrets and that a reduction modN can only happen once, since if that happens the protocol ends.</p><p>Therefore the following stronger assumption on the unforgeability of DSA would suffice. We define a game between a Challenger and an Attacker:</p><p>• The Challenger gives to the Attacker a DSA public key y = д x and a random number x ∈ R Z q . Let x ′ = xx mod q.</p><p>The Attacker chooses an RSA modulus N &gt; q 3 . • The Attacker submits a message m and three arbitrary numbers λ 1 , λ 2 , ρ1. • The Challenger chooses ρ ′ ∈ R Z q and β 1 , β 2 ∈ R Z N . If λ 1 x ′ + β 1 and λ 2 ρ ′ + β 2 are less than N , the Attacker receives (r, s) a valid DSA signature on m and also α = ρk mod q</p><p>where k ∈ R Z q and r = д k -1 . Otherwise the game stops.</p><p>The Attacker wins if he forges a signature on a message for which the Challenger did not output a signature. The assumption is that winning this game is infeasible.</p><p>We believe this assumption to be reasonable because it appears that the Attacker receives only limited information about the values x, k.</p><p>Note that we can't simulate Alice's view in this case, but we are arguing that the information leaked is minimal and does not affect security in a game-based definition of unforgeability.</p><p>Information Leaked to Bob by removing the ZK Consistency Proof. Here instead we are able to simulate Bob's view under a stronger assumption on the Paillier cryptosystem.</p><p>If Bob is corrupted, then the simulated Alice sends the encryption of a random value c A = E( â). But then it must decide if to accept or reject at the end of step (2) (where the real Alice checks that д α = B a B ′ ) without knowing â. Here we assume that the simulator is provided with an oracle Ω c A (c B , b, β) which answers 1 if and only if Dec(c B ) = b • Dec(c A ) + β mod q. Then the simulator will extract b, β from the malicious Bob's proof of knowledge, and query Ω c A (c B , b, β) and accepts if the oracle answers 1.</p><p>Security cannot be based on the semantic security of the Paillier's encryption scheme anymore since the presence of the oracle immediately implies that Paillier is not semantically secure anymore. However consider the following experiment:</p><p>• Generate a Paillier key (E, D)</p><p>• Generate two random values a 0 , a 1 ∈ R Z q and publish A = д a 0 • Choose a random bit b and publish c = E(a b ) • Let b ′ be the output of the adversary who is allowed restricted access to the oracle Ω c -by restricted we mean that the oracle will stop working after it outputs 0.</p><p>We say that the Paillier-ECR assumption holds if for every PPT adversary, the probability that b = b ′ is negligible. Under the Paillier-ECR assumption we can prove that no adversary given д a 0 can distinguish if the MtA protocol was run with a 0 or a 1 (with both values being "high entropy" in particularly randomly chosen). This is sufficient to simulate MtA with high entropy inputs, which is what is needed to prove security of our threshold DSA protocol. We note that our Paillier-ECR assumption is a weaker version of the Paillier-EC assumption in <ref type="bibr" target="#b25">[26]</ref>. In the latter the oracle access is not restricted, which makes the assumption much stronger. In our case it is sufficient to consider the restricted oracle since the real protocol stops if Alice detects cheating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">IMPLEMENTATION, BENCHMARKS, AND EVALUATION</head><p>We implemented both the key generation and signature generation of our protocol, and we confirm that they are highly efficient and fast enough to be used in practice. We benchmarked the version of our protocol from Section 6 that does not contain the range proofs, but relies on the Paillier-ECR assumption. We compare the performance of our protocol to the runtimes of Gennaro et al. <ref type="bibr" target="#b16">[17]</ref> and Boneh et al. <ref type="bibr" target="#b3">[4]</ref>. All benchmarks were single-threaded and run on an an Intel quad-core i7-6700 CPU @ 3.40GHz and 64GB of RAM. We ran the code <ref type="bibr" target="#b16">[17]</ref> and <ref type="bibr" target="#b3">[4]</ref> on our benchmark machine to get an accurate comparison. It should be noted that we implemented our scheme in C while theirs is a Java implementation which calls native C libraries for the heaviest arithmetic computations. All benchmarks were taken over the secp256k1 curve, which is is the curve used in Bitcoin and more recently a NIST standard.</p><p>For the curve operations, we used libsecp256k1. <ref type="foot" target="#foot_4">6</ref> We implemented the MtA protocol with Paillier using the implementation from libhcs. <ref type="foot" target="#foot_5">7</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Benchmarking the data complexity</head><p>When compared to <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref>, we reduce the amount of data transmitted. All figures in this section were measured empirically from the respective implementations, and thus it is possible that they may be further optimized in practice. <ref type="foot" target="#foot_6">8</ref> For a threshold of t (i.e. when there are t + 1 participants in the signing protocol), the total data d in bytes sent and received by a given player to/from all other players during the signing protocol is given by: d our s (t) = 2, 328 + t × 5, 024 Bytes In contrast, the data sent to/from a given player in <ref type="bibr" target="#b16">[17]</ref> is given by: d Gennar o (t) = (t + 1) × 34, 578 Bytes</p><p>And the data transmitted per player in <ref type="bibr" target="#b3">[4]</ref> is given by: d Boneh (t) = (t + 1) × 38, 189 Bytes Lastly, we mention that for the 2-of-n case, we have d our s (t = 1) = 3, 976 B. In contrast, the recent protocol of <ref type="bibr" target="#b11">[12]</ref> requires far more than that with 86.7 KiB for 2-of-2 signing and 106.7 KiB for 2-of-n signing. Lindell's scheme <ref type="bibr" target="#b25">[26]</ref> only requires 769 B to be communicated in the 2-of-2 case (but does not support 2-of-n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Benchmarking signature generation time</head><p>Following the methodology of <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref>, we benchmark the raw computation time of a single player without counting network costs. Since each player runs their computation in parallel, this represents the running time of the entire protocol other than network latency. We find that our protocol significantly outperforms both of <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref> when using this metric.</p><p>As in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref>, the protocol running time has a fixed cost that is independent of the number of players plus a linear marginal cost as the threshold increases. We stress that the signing time only depends on the number of active participants (t + 1), but does not depend on n, the total number of players. All times are given on a single core, and were averaged over 1000 iterations.</p><p>Our protocols running time is given by: r our s (t) = 29 + (t) × 24 milliseconds</p><p>The running time of <ref type="bibr" target="#b16">[17]</ref> is given by: r Gennar o (t) = 142 + (t) × 52 milliseconds</p><p>The running time of <ref type="bibr" target="#b3">[4]</ref> is given by: r Boneh (t) = 397 + (t) × 91 milliseconds</p><p>We can see that our protocol significantly outperforms both previous schemes. See Figure <ref type="figure" target="#fig_2">1</ref> for a comparison of the concrete raw computation times for thresholds up to 20.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We have presented a threshold ECDSA protocol that is an improvement over the existing schemes by every metric. Although <ref type="bibr" target="#b16">[17]</ref> has been available for some time, there are still to our knowledge no Bitcoin services or user wallets that offer threshold-signature security. We believe that this is due to the impracticality of their distributed key generation protocol. Having to rely on a trusted dealer to distribute key shares exposes a single point of failure for the system and in doing so runs contrary to the entire premise of using threshold signatures in the first place. and far too high. Even with our own more favorable benchmarks of <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref>, our scheme is still a significant improvement. We solve this problem by presenting and implementing a new scheme with a highly efficient distributed key generation protocol. Together with our reduction in running time and data transferred, we believe that ECDSA threshold signatures are finally mature enough for adoption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A THE ZK PROOFS FOR THE MTA PROTOCOL</head><p>In this section we describe the ZK proofs that are needed in the MtA protocol (see Section 3). The proofs are based on similar ones from <ref type="bibr" target="#b26">[27]</ref>: specifically we prove statements that are simpler than the ones needed in <ref type="bibr" target="#b26">[27]</ref>.</p><p>In these proofs the Verifier uses an auxiliary RSA modulus Ñ which is the product of two safe primes P = 2 p + 1 and Q = 2 q + 1 with p, q primes. The Verifier also uses two values h 1 , h 2 ∈ Z * Ñ according to the commitment scheme in <ref type="bibr" target="#b14">[15]</ref>. Security is based on the assumption that the Prover cannot solve the Strong RSA problem over Ñ .</p><p>Therefore our initialization protocol must be augmented with each player P i generating an additional RSA modulus Ñi , and values h 1i , h 2i , together with a proof that they are of the correct form (see <ref type="bibr" target="#b14">[15]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Range Proof</head><p>This proof is run by Alice (the initiator) in both MtA and MtAwc protocols.</p><p>The input for this proof is a Paillier public key N , Γ and a value c ∈ Z N 2 . The prover knows m ∈ Z q and r ∈ Z * N such that c = Γ m r N mod N 2 , where q is the order of the DSA group.</p><p>At the end of the protocol the Verifier is convinced that m ∈ [-q 3 , q 3 ].</p><p>• The Prover selects α ∈ R Z q 3 , β ∈ R Z * N , γ ∈ R Z q 3 Ñ and ρ ∈ R Z q Ñ . The Prover computes z = h m 1 h ρ 2 mod Ñ , u = Γ α β N mod N 2 , w = h α 1 h γ 2 mod Ñ . The Prover sends z, u, w to the Verifier.</p><p>• The Verifier selects a challenge e ∈ R Z q and sends it to the Prover. • The Prover computes s = r e β mod N , s 1 = em + α and s 2 = eρ + γ and sends s, s 1 , s 2 to the Verifier. • The verifier checks that s 1 ≤ q 3 , u = Γ s 1 s N c -e mod N 2 and h s 1 1 h s 2 2 z -e = w mod Ñ . Completeness. By inspection.</p><p>Soundness. Let Ñ , s be our Strong RSA challenge. We show how to solve it using a Prover who succeeds on incorrect instances (i.e. where |m| &gt; q 3 ).</p><p>Let h 2 = s and h 1 = h χ 2 for a random χ ∈ Z q Ñ . It is not hard to see that the distribution of these values is indistinguishable from the real one with sufficiently high probability.</p><p>Run the prover on a successful execution over a challenge e and then rewind him and find a successful execution with challenge ê. Therefore we have the same first message z, u, w and two set of answers s, s 1 , s 2 for challenge e, and ŝ, ŝ1 , ŝ2 for challenge ê both satisfing the verification equations. Let ∆ E = eê, ∆ s1 = s 1 -ŝ1 and ∆ s2 = s 2 -ŝ2 .</p><p>Let λ = GCD(∆ s2 + χ ∆ s1 , ∆ E ). Assume λ ∆ E : denote with λ s = (∆ s2 + χ ∆ s1 )/λ and λ E = ∆ E /λ &gt; 1. Then we find µ, ν such that µλ s + νλ E = 1.</p><p>Then the solution to the Strong RSA challenge is x = z µ sν mod Ñ , λ E . Indeed note that </p><formula xml:id="formula_41">w = h s 1 1 h s 2 2 z -e = h ŝ1 1 h ŝ2 2 z -ê mod Ñ therefore z ∆ E = h ∆ s 1 1 h ∆ s 2 2 =</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Com is the commitment algorithm. On input pk and a message M it outputs [C(M), D(M)] = Com(pk, M, R) where r are the coin tosses. C(M) is the commitment string, while D(M) is the decommitment string which is kept secret until opening time. • Ver is the verification algorithm. On input C, D and pk it either outputs a message M or ⊥. • Equiv is the algorithm that opens a commitment in any possible way given the trapdoor information. It takes as input pk, strings M, R with [C(M), D(M)] = Com(pk, M, R), a message M ′ M and a string T . If T = tk then Equiv outputs D ′ such that Ver(pk, C(M), D ′ ) = M ′ . We note that if the sender refuses to open a commitment we can set D = ⊥ and Ver(pk, C, ⊥) = ⊥. Trapdoor commitments must satisfy the following properties Correctness If [C(M), D(M)] = Com(pk, M, R) then Ver(pk, C(M), D(M)) = M. Information Theoretic Security For every message pair M, M ′ the distributions C(M) and C(M ′ ) are statistically close. Secure Binding We say that an adversary A wins if it outputs C, D, D ′ such that Ver(pk, C, D) = M, Ver(pk, C, D ′ ) = M ′</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 4 . 4 .</head><label>44</label><figDesc>Assuming that • The Strong RSA Assumption holds • KG, Com, Ver, Equiv is a non-malleable equivocable commitment;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Comparison of the raw computation time as the threshold increases between this work and previous schemes.</figDesc><graphic coords="13,353.99,83.69,168.17,112.11" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>s∆ s 2 +χ ∆ s 1 mod</figDesc><table><row><cell>Ñ</cell></row><row><cell>which implies</cell></row><row><cell>z λ</cell></row></table><note><p>E = sλ S mod Ñ Concluding s = s µ λ s +ν λ E = [z µ sν ] λ E mod Ñ</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This is the famous Bar-Ilan and Beaver inversion trick<ref type="bibr" target="#b0">[1]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For the simple range proof that a, b &lt; K one could alternatively use a variation of Boudot's proof<ref type="bibr" target="#b4">[5]</ref> which establish K q which sets N q</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>. This proof is less efficient that the ones from<ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b26">27]</ref> which are anyway required for Bob in the MtAwc protocol. Moreover as we said earlier, N &gt; q 8 in practice anyway so the improvement in the size of N is irrelevean for ECDSA.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>In this case we do not need to extract anything from P j 's ZK proof, but we still need to check that the value sent by P j is correct.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>https://github.com/bitcoin-core/secp256k1</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>https://github.com/tiehuis/libhcs</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_6"><p>We note that in<ref type="bibr" target="#b11">[12]</ref> they give size benchmarks for<ref type="bibr" target="#b16">[17]</ref> and<ref type="bibr" target="#b3">[4]</ref> that are far worse than the numbers we gave-nearly 2 Megabytes for the two party case alone. However, when we ran the benchmarks ourselves, we found that their numbers were incorrect</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">ACKNOWLEDGEMENTS</head><p>We thank Harry Kalodner, Yehuda Lindell, Ariel Nof, and Ben Riva for useful feedback and discussions and for pointing out errors in earlier drafts.</p><p>Rosario Gennaro is supported by NSF Grant 1565403. Steven Goldfeder is supported by an NSF Graduate Research Fellowship under grant number DGE 1148900 and NSF award CNS-1651938.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We now need to prove that the case λ = ∆ E cannot happen with high probability.</p><p>Consider first the case λ = ∆ E but ∆ E does not divide ∆ s1 . Write χ = χ 0 + χ 1 p q with χ 1 chosen uniformly at random from a set of size &gt; q. Note that the value χ 1 is information theoretically secret from the adversary (who only has h 1 , h 2 ). We have that</p><p>Then there is a prime power a b (with a ≥ 2) such that a b |∆ E , a b-1 |∆ s1 but a b does not divide ∆ s1 . Note that this implies that a b-1 |∆ s2 . Set c 0 = (∆ s2 + χ 0 ∆ s1 )/a b-1 and c 1 = ∆ s1 p q/a b-1 . We have that c 0 + χ 1 c 1 = 0 mod a and c 1 0 mod a. The number of elements χ 1 for which this equivalence holds is at most q/a + 1 and thus the probability of this holding for a random choice of χ 1 is at most 1 a + 1 q which is at most 1 2 + 1 q . Otherwise we are in the case above with λ ∆ E . Now consider the case λ = ∆ E and ∆ E |∆ s1 . Note that this implies that ∆ E |∆ s2 as well. Define</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finally denote with m</head><p>At this point we know the following facts</p><p>Honest-Verifier Zero-Knowledge. The simulator proceeds as in <ref type="bibr" target="#b26">[27]</ref>. Choose z, s, s 1 , s 2 , e according to the appropriate distribution and set u = Γ s 1 s N c -e mod N and w = h s 1 1 h s 2 2 z -e mod Ñ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Respondent ZK Proof for MtAwc</head><p>This proof is run by Bob (the responder) in the MtAwc protocol. For the MtA protocol a simpler version of this proof if needed, which we present later. The input for this proof is a Paillier public key N , Γ and two values c 1 , c 2 ∈ Z N 2 , together with a value X in G the DSA group.</p><p>The prover knows</p><p>, and X = д x ∈ G, where q is the order of the DSA group.</p><p>At the end of the protocol the Verifier is convinced of the above and that x ∈ [-q 3 , q 3 ].</p><p>• The Prover selects</p><p>2 mod Ñ . The Prover sends u, z.z ′ , t, v, w to the Verifier.</p><p>• The Verifier selects a challenge e ∈ R Z q and sends it to the Prover. • The Prover computes s = r e β mod N , s 1 = ex + α, s 2 = eρ + ρ ′ , t 1 = ey + γ and t 2 = eσ + τ .</p><p>The Prover sends s, s 1 , s 2 , t 1 , t 2 to the Verifier.</p><p>= t e w mod Ñ , and</p><p>Completeness. By inspection.</p><p>Soundness. Let Ñ , s be our Strong RSA challenge. We show how to solve it using a Prover who succeeds on incorrect instances (i.e. where |x | &gt; q 3 ).</p><p>Let h 2 = s and h 1 = h χ 2 for a random χ ∈ Z q Ñ . It is not hard to see that the distribution of these values is indistinguishable from the real one with sufficiently high probability.</p><p>Run the prover on a successful execution over a challenge e and then rewind him and find a successful execution with challenge ê. Therefore we have the same first message u, z, z ′ , t, v, w and two set of answers s, s 1 , s 2 , t 1 , t 2 for challenge e, and ŝ, ŝ1 , ŝ2 , t1 , t2 for challenge ê both satisfing theverification equations. Let ∆ E = eê,</p><p>Then the solution to the Strong RSA challenge is x = z µ sν mod Ñ , λ E . Indeed note that</p><p>In a similar way as above we can prove that if λ ′ ∆ E then we can solve our Strong RSA challenge.</p><p>Therefore we can limit ourselves to the case λ = λ ′ = ∆ E . Consider first the case λ = λ ′ = ∆ E but ∆ E does not divide ∆ s1 . Write χ = χ 0 + χ 1 p q with χ 1 chosen uniformly at random from a set of size &gt; q. Note that the value χ 1 is information theoretically secret from the adversary (who only has h 1 , h 2 ). We have that</p><p>Then there is a prime power a b (with a ≥ 2) such that a b |∆ E , a b-1 |∆ s1 but a b does not divide ∆ s1 . Note that this implies that a b-1 |∆ s2 . Set c 0 = (∆ s2 + χ 0 ∆ s1 )/a b-1 and c 1 = ∆ s1 p q/a b-1 . We have that c 0 + χ 1 c 1 = 0 mod a and c 1 0 mod a. The number of elements χ 1 for which this equivalence holds is at most q/a + 1 and thus the probability of this holding for a random choice of χ 1 is at most 1 a + 1 q which is at most 1 2 + 1 q . Otherwise we are in the case above with λ ∆ E .</p><p>In a similar fashion we can remove the case in which</p><p>Note that this implies that ∆ E |∆ s2 and ∆ E |∆ t 2 as well.</p><p>Define</p><p>Define x ′ 1 = x 1 mod N and y ′ 1 = y 1 mod N . Note that by definition c</p><p>x ′ 1 1 Γ y ′ 1 κ N = c 2 mod N 2 for some κ as needed. And д x 1 = X ∈ G. So we have extracted the required x, y. As in the previous proof we can establish that x 1 , x ′ 1 ∈ [-q 3 , q 3 ]. Honest-Verifier Zero-Knowledge. The simulator proceeds as in <ref type="bibr" target="#b26">[27]</ref> and in the previous ZK proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Respondent ZK Proof for MtA</head><p>This proof is run by Bob (the responder) in the MtA protocol. It is a simpler version of the previous protocol where Bob only proves that x is small (without proving that it is the discrete log of any public value).</p><p>The input for this proof is a Paillier public key N , Γ and two values c 1 , c 2 ∈ Z N 2 .</p><p>The prover knows x ∈ Z q , y ∈ Z N and r ∈ Z * N such that c 2 = c x 1 Γ y r N mod N 2 where q is the order of the DSA group. At the end of the protocol the Verifier is convinced of the above and that x ∈ [-q 3 , q 3 ].</p><p>• The Prover selects α</p><p>The Prover computes z = h x 1 h</p><p>, and w = h γ 1 h τ 2 mod Ñ . The Prover sends z, z ′ , t, v, w to the Verifier.</p><p>• The Verifier selects a challenge e ∈ R Z q and sends it to the Prover. • The Prover computes s = r e β mod N , s 1 = ex + α, s 2 = eρ + ρ ′ , t 1 = ey + γ and t 2 = eσ + τ .</p><p>The Prover sends s, s 1 , s 2 , t 1 , t 2 to the Verifier. • The verifier checks that s 1 ≤ q 3 , h s 1 1 h s 2 2 = z e z ′ mod Ñ , h t 1 1 h t 2 2 = t e w mod Ñ , and c s 1 1 s N Γ t 1 = c e 2 v mod N 2 . The proof is immediate from the previous one.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Non-cryptographic fault-tolerant computing in constant number of rounds of interaction</title>
		<author>
			<persName><forename type="first">Judit</forename><surname>Bar-Ilan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the eighth annual ACM Symposium on Principles of distributed computing</title>
		<meeting>the eighth annual ACM Symposium on Principles of distributed computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="201" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Collision-free accumulators and fail-stop signature schemes without trees</title>
		<author>
			<persName><forename type="first">Niko</forename><surname>Barić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Birgit</forename><surname>Pfitzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="480" to="494" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Digital signature standard</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Encyclopedia of cryptography and security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="347" to="347" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Using level-1 homomorphic encryption to improve threshold dsa signatures for bitcoin wallet security</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Goldfeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Latincrypt</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient proofs that a committed number lies in an interval</title>
		<author>
			<persName><forename type="first">Fabrice</forename><surname>Boudot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="431" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Adaptive security for threshold cryptosystems</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stanisław</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugo</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="98" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An Efficient Threshold Public Key Cryptosystem Secure Against Adaptive Chosen Ciphertext Attack</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT &apos;99, International Conference on the Theory and Application of Cryptographic Techniques</title>
		<meeting><address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-05-02">1999. May 2-6, 1999</date>
			<biblScope unit="page" from="90" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Non-interactive and reusable non-malleable commitment schemes</title>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Damgard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Groth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the thirty-fifth annual ACM symposium on Theory of computing</title>
		<meeting>the thirty-fifth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="426" to="437" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Implementing AES via an actively/covertly secure dishonest-majority MPC protocol</title>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcel</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Enrique</forename><surname>Larraia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Miles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nigel</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Security and Cryptography for Networks</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="241" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Non-interactive and non-malleable commitment</title>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Di Crescenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the thirtieth annual ACM symposium on Theory of computing</title>
		<meeting>the thirtieth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient and non-interactive non-malleable commitment</title>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Di Crescenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="40" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Secure Two-party Threshold ECDSA from ECDSA Assumptions</title>
		<author>
			<persName><forename type="first">Jack</forename><surname>Doerner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yashvanth</forename><surname>Kondi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eysa</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page">0</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Non-malleable cryptography</title>
		<author>
			<persName><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd Annual Symposium on the Theory of Computing</title>
		<meeting>the 23rd Annual Symposium on the Theory of Computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A practical scheme for non-interactive verifiable secret sharing</title>
		<author>
			<persName><forename type="first">Paul</forename><surname>Feldman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Computer Science, 1987., 28th Annual Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="427" to="438" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Statistical zero knowledge protocols to prove modular polynomial relations</title>
		<author>
			<persName><forename type="first">Eiichiro</forename><surname>Fujisaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="16" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Multi-trapdoor commitments and their applications to proofs of knowledge secure under concurrent man-in-the-middle attacks</title>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="220" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Thresholdoptimal DSA/ECDSA signatures and an application to Bitcoin wallet security</title>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Goldfeder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename><surname>Narayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Applied Cryptography and Network Security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="156" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Robust threshold DSS signatures</title>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stanisław</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugo</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="354" to="371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Robust threshold DSS signatures</title>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stanisław</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugo</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">164</biblScope>
			<biblScope unit="page" from="54" to="84" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Independent zero-knowledge sets</title>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Colloquium on Automata, Languages, and Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="34" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A digital signature scheme secure against adaptive chosen-message attacks</title>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronald</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="281" to="308" />
			<date type="published" when="1988">1988. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient RSA key generation and threshold paillier in the two-party setting</title>
		<author>
			<persName><forename type="first">Carmit</forename><surname>Hazay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gert</forename><surname>Laessøe Mikkelsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tomas</forename><surname>Toft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographers&apos; Track at the RSA Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="313" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Adaptively secure threshold cryptography: Introducing concurrency, removing erasures</title>
		<author>
			<persName><forename type="first">Stanisław</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anna</forename><surname>Lysyanskaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="221" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Overdrive: making SPDZ great again</title>
		<author>
			<persName><forename type="first">Marcel</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valerio</forename><surname>Pastro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dragos</forename><surname>Rotaru</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="158" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">W</forename><surname>Kravitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital signature algorithm</title>
		<imprint>
			<date type="published" when="1993-07-27">1993. July 27 1993</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">668</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fast Secure Two-Party ECDSA Signing</title>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="613" to="644" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Two-party generation of DSA signatures</title>
		<author>
			<persName><forename type="first">Philip</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="137" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On simulation-sound trapdoor commitments</title>
		<author>
			<persName><forename type="first">Philip</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ke</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="382" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems based on composite degree residuosity classes</title>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Paillier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Short Proofs of Knowledge for Factoring</title>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Poupard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography, Third International Workshop on Practice and Theory in Public Key Cryptography, PKC 2000</title>
		<meeting><address><addrLine>Melbourne, Victoria, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-01-18">2000. January 18-20, 2000</date>
			<biblScope unit="page" from="147" to="166" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A method for obtaining digital signatures and public-key cryptosystems</title>
		<author>
			<persName><forename type="first">Adi</forename><surname>Ronald L Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonard</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><surname>Adleman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="120" to="126" />
			<date type="published" when="1978">1978. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficient Signature Generation by Smart Cards</title>
		<author>
			<persName><forename type="first">Claus-Peter</forename><surname>Schnorr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="161" to="174" />
			<date type="published" when="1991">1991. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">How to share a secret</title>
		<author>
			<persName><forename type="first">Adi</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="612" to="613" />
			<date type="published" when="1979">1979. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
