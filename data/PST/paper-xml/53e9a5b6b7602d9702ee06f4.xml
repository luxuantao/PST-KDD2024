<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Robust Bloom Filters for Large Multilabel Classification Tasks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Moustapha</forename><surname>Cissé</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LIP6</orgName>
								<orgName type="institution">UPMC</orgName>
								<address>
									<settlement>Sorbonne Université Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Nicolas</forename><surname>Usunier</surname></persName>
							<email>nusunier@utc.fr</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">UT Compiègne</orgName>
								<orgName type="institution" key="instit2">CNRS Heudiasyc UMR</orgName>
								<address>
									<postCode>7253</postCode>
									<settlement>Compiègne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thierry</forename><surname>Artieres</surname></persName>
							<affiliation key="aff2">
								<orgName type="laboratory">LIP6</orgName>
								<orgName type="institution">UPMC</orgName>
								<address>
									<settlement>Sorbonne Université Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Patrick</forename><surname>Gallinari</surname></persName>
							<affiliation key="aff2">
								<orgName type="laboratory">LIP6</orgName>
								<orgName type="institution">UPMC</orgName>
								<address>
									<settlement>Sorbonne Université Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Robust Bloom Filters for Large Multilabel Classification Tasks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6997B5C5386D9128D36C31CCC0623AEB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents an approach to multilabel classification (MLC) with a large number of labels. Our approach is a reduction to binary classification in which label sets are represented by low dimensional binary vectors. This representation follows the principle of Bloom filters, a space-efficient data structure originally designed for approximate membership testing. We show that a naive application of Bloom filters in MLC is not robust to individual binary classifiers' errors. We then present an approach that exploits a specific feature of real-world datasets when the number of labels is large: many labels (almost) never appear together. Our approach is provably robust, has sublinear training and inference complexity with respect to the number of labels, and compares favorably to state-of-the-art algorithms on two large scale multilabel datasets.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Multilabel classification (MLC) is a classification task where each input may be associated to several class labels, and the goal is to predict the label set given the input. This label set may, for instance, correspond to the different topics covered by a text document, or to the different objects that appear in an image. The standard approach to MLC is the one-vs-all reduction, also called Binary Relevance (BR) <ref type="bibr" target="#b15">[16]</ref>, in which one binary classifier is trained for each label to predict whether the label should be predicted for that input. While BR remains the standard baseline for MLC problems, a lot of attention has recently been given to improve on it. The first main issue that has been addressed is to improve prediction performances at the expense of computational complexity by learning correlations between labels <ref type="bibr" target="#b4">[5]</ref>  <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref> or considering MLC as an unstructured classification problem over label sets in order to optimize the subset 0/1 loss (a loss of 1 is incurred as soon as the method gets one label wrong) <ref type="bibr" target="#b15">[16]</ref>. The second issue is to design methods that scale to a large number of labels (e.g. thousands or more), potentially at the expense of prediction performances, by learning compressed representations of labels sets with lossy compression schemes that are efficient when label sets have small cardinality <ref type="bibr" target="#b5">[6]</ref>. We propose here a new approach to MLC in this latter line of work. A "MLC dataset" refers here to a dataset with a large number of labels (at least hundreds to thousands), in which the target label sets are smaller than the number of labels by one or several orders of magnitude, which is the common in large-scale MLC datasets collected from the Web.</p><p>The major difficulty in large-scale MLC problems is that the computational complexity of training and inference of standard methods is at least linear in the number of labels L. In order to scale better with L, our approach to MLC is to encode individual labels on K-sparse bit vectors of dimension B, where B L, and use a disjunctive encoding of label sets (i.e. bitwise-OR of the codes of the labels that appear in the label set). Then, we learn one binary classifier for each of the B bits of the coding vector, similarly to BR (where K = 1 and B = L). By setting K &gt; 1, one can encode individual labels unambiguously on far less than L bits while keeping the disjunctive encoding unambiguous for a large number of labels sets of small cardinality. Compared to BR, our scheme learns only B binary classifiers instead of L, while conserving the desirable property that the classifiers can be trained independently and thus in parallel, making our approach suitable for large-scale problems.</p><p>The critical point of our method is a simple scheme to select the K representative bits (i.e. those set to 1) of each label with two desirable properties. First, the encoding of "relevant" label sets are unambiguous with the disjunctive encoding. Secondly, the decoding step, which recovers a label set from an encoding vector, is robust to prediction errors in the encoding vector: in particular, we prove that the number of incorrectly predicted labels is no more than twice the number of incorrectly predicted bits. Our (label) encoding scheme relies on the existence of mutually exclusive clusters of labels in real-life MLC datasets, where labels in different clusters (almost) never appear in the same label set, but labels from the same clusters can. Our encoding scheme makes that B becomes smaller as more clusters of similar size can be found. In practice, a strict partitioning of the labels into mutually exclusive clusters does not exist, but it can be fairly well approximated by removing a few of the most frequent labels, which are then dealt with the standard BR approach, and clustering the remaining labels based on their co-occurrence matrix. That way, we can control the encoding dimension B and deal with the computational cost/prediction accuracy tradeoff.</p><p>Our approach was inspired and motivated by Bloom filters <ref type="bibr" target="#b1">[2]</ref>, a well-known space-efficient randomized data structure designed for approximate membership testing. Bloom filters use exactly the principle of encoding objects (in our case, labels) by K-sparse vectors and encode a set with the disjunctive encoding of its members. The filter can be queried with one object and the answer is correct up to a small error probability. The data structure is randomized because the representative bits of each object are obtained by random hash functions; under uniform probability assumptions for the encoded set and the queries, the encoding size B of the Bloom filter is close to the information theoretic limit for the desired error rate. Such "random" Bloom filter encodings are our main baseline, and we consider our approach as a new design of the hash functions and of the decoding algorithm to make Bloom filter robust to errors in the encoding vector. Some background on (random) Bloom filters, as well as how to apply them for MLC is given in the next section. The design of hash functions and the decoding algorithm are then described in Section 3, where we also discuss the properties of our method compared to related works of <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b3">4]</ref>. Finally, in Section 4, we present experimental results on two benchmark MLC datasets with a large number of classes, which show that our approach obtains promising performances compared to existing approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Bloom Filters for Multilabel Classification</head><p>Our approach is a reduction from MLC to binary classification, where the rules of the reduction follow a scheme inspired by the encoding/decoding of sets used in Bloom filters. We first describe the formal framework to fix the notation and the goal of our approach, and then give some background on Bloom filters. The main contribution of the paper is described in the next section.</p><p>Framework Given a set of labels L of size L, MLC is the problem of learning a prediction function c that, for each possible input x, predicts a subset of L. Throughout the paper, the letter y is used for label sets, while the letter is used for individual labels. Learning is carried out on a training set ((x 1 , y 1 ), ..., (x n , y n )) of inputs for which the desired label sets are known; we assume the examples are drawn i.i.d. from the data distribution D.</p><p>A reduction from MLC to binary classification relies on an encoding function e : y ⊆ L → (e 1 (y), ..., e B (y)) ∈ {0, 1}</p><p>B , which maps subsets of L to bit vectors of size B. Then, each of the B bits are learnt independently by training a sequence of binary classifiers ê = (ê 1 , ..., êB ), where each êj is trained on ((x 1 , e j (y 1 )), ..., (x n , e j (y n ))). Given a new instance x, the encoding ê(x) is predicted, and the final multilabel classifier c is obtained by decoding ê(x), i.e. ∀x, c(x) = d(ê(x)). The goal of this paper is to design the encoding and decoding functions so that two conditions are met. First, the code size B should be small compared to L, in order to improve the computational cost of training and inference relatively to BR. Second, the reduction should be robust in the sense that the final performance, measured by the expected Hamming loss H L (c) between the target label sets y and the predictions c(x) is not much larger than H B (ê), the average error of the classifiers we learn. Using ∆ to denote the symmetric difference between sets, H L and H B are defined by: e({ 1 })</p><formula xml:id="formula_0">H L (c) = E (x,y)∼D |c(x)∆y| L and H B (ê) = 1 B B j=1 E (x,y)∼D 1 {ej(y) =êj(y)} .<label>(1)</label></formula><formula xml:id="formula_1">0 1 1 0 1 0 h 1 ( 1 ) h 2 ( 1 ) h 3 ( 1 )</formula><p>e({ 4 }) Bloom Filters Given the set of labels L, a Bloom filter (BF) of size B uses K hash functions from L to {1, ..., B}, which we denote h k : L → {1, ..., B} for k ∈ {1, ..., K} (in a standard approach, each value h k ( ) is chosen uniformly at random in {1, ..., B}). These hash functions define the representative bits (i.e. non-zero bits) of each label: each singleton { } for ∈ L is encoded by a bit vector of size B with at most K non-zero bits, and each hash function gives the index of one of these nonzero bits in the bit vector. Then, the Bloom filter encodes a subset y ⊆ L by a bit vector of size B, defined by the bitwise OR of the bit vectors of the elements of y. Given the encoding of a set, the Bloom filter can be queried to test the membership of any label ; the filter answers positively if all the representative bits of are set to 1, and negatively otherwise. A negative answer of the Bloom filter is always correct; however, the bitwise OR of label set encodings leads to the possibility of false positives, because even though any two labels have different encodings, the representative bits of one label can be included in the union of the representative bits of two or more other labels. Bloom Filters for MLC The encoding and decoding schemes of BFs are appealing to define the encoder e and the decoder d in a reduction of MLC to binary classification (decoding consists in querying each label), because they are extremely simple and computationally efficient, but also because, if we assume that B L and that the random hash functions are perfect, then, given a random subset of size C L, the false positive rate of a BF encoding this set is in O(</p><formula xml:id="formula_2">1 0 1 0 1 0 e({ 1 , 3 , 4 }) = e({ 1 , 4 }) 1 1 1 0 1 0 3 example: (x, { 1 , 4 }) c(x) = d(ê(x)) = { 3 } 1 1 0 0 1 0 ê1 (x) ê2 (x) ê3 (x) ê4 (x) ê5 (x) ê6 (x)</formula><formula xml:id="formula_3">1 2 C B ln(2)</formula><p>) for the optimal number of hash functions. This rate is, up to a constant factor, the information theoretic limit <ref type="bibr" target="#b2">[3]</ref>. Indeed, as shown in Section 4 the use of Bloom filters with random hash functions for MLC (denoted S-BF for Standard BF hereafter) leads to rather good results in practice.</p><p>Nonetheless, there is much room for improvement with respect to the standard approach above. First, the distribution of label sets in usual MLC datasets is far from uniform. On the one hand, this leads to a substantial increase in the error rate of the BF compared to the theoretical calculation, but, on the other hand, it is an opportunity to make sure that false positive answers only occur in cases that are detectable from the observed distribution of label sets: if y is a label set and ∈ y is a false positive given e(y), can be detected as a false positive if we know that never (or rarely) appears together with the labels in y. Second and more importantly, the decoding approach of BFs is far from robust to errors in the predicted representation. Indeed, BFs are able to encode subsets on B L bits because each bit is representative for several labels. In the context of MLC, the consequence is that any single bit incorrectly predicted may include in (or exclude from) the predicted label set all the labels for which it is representative. Figure <ref type="figure" target="#fig_1">1</ref> (right) gives an example of the situation, where a single error in the predicted encoding, added with a false positive, results in 3 errors in the final prediction. Our main contribution, which we detail in the next section, is to use the non-uniform distribution of label sets to design the hash functions and a decoding algorithm to make sure that any incorrectly predicted bit has a limited impact on the predicted label set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">From Label Clustering to Hash Functions and Robust Decoding</head><p>We present a new method that we call Robust Bloom Filters (R-BF). It improves over random hash functions by relying on a structural feature of the label sets in MLC datasets: many labels are never observed in the same target set, or co-occur with a probability that is small enough to be neglected. We first formalize the structural feature we use, which is a notion of mutually exclusive clusters of labels, then we describe the hash functions and the robust decoding algorithm that we propose.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Label Clustering</head><p>The strict formal property on which our approach is based is the following: given P subsets L 1 , ..., L P of L, we say that (L 1 , ..., L P ) are mutually exclusive clusters if no target set contains labels from more than one of each L p , p = 1..P , or, equivalently, if the following condition holds:</p><formula xml:id="formula_4">∀p ∈ {1, ..., P }, P y∼D Y y ∩ L p = ∅ and y ∩ p =p L p = ∅ = 0 . (<label>2</label></formula><formula xml:id="formula_5">)</formula><p>where D Y is the marginal distribution over label sets. For the disjunctive encoding of Bloom filters, this assumption implies that if we design the hash functions such that the false positives for a label set y belong to a cluster that is mutually exclusive with (at least one) label in y, then the decoding step can detect and correct it. To that end, it is sufficient to ensure that for each bit of the Bloom filter, all the labels for which this bit is representative belong to mutually exclusive clusters. This will lead us to a simple two-step decoding algorithm cluster identification/label set prediction in the cluster.</p><p>In terms of compression ratio B L , we can directly see that the more mutually exclusive clusters, the more labels can share a single bit of the Bloom filter. Thus, more (balanced) mutually exclusive clusters will result in smaller encoding vectors B, making our method more efficient overall. This notion of mutually exclusive clusters is much stronger than our basic observation that some pair of labels rarely or never co-occur with each other, and in practice it may be difficult to find a partition of L into mutually exclusive clusters because the co-occurrence graph of labels is connected. However, as we shall see in the experiments, after removing the few most central labels (which we call hubs, and in practice roughly correspond to the most frequent labels), the labels can be clustered into (almost) mutually exclusive labels using a standard clustering algorithm for weighted graph.</p><p>In our approach, the hubs are dealt with outside the Bloom filter, with a standard binary relevance scheme. The prediction for the remaining labels is then constrained to predict labels from at most one of the clusters. From the point of view of prediction performance, we loose the possibility of predicting arbitrary label sets, but gain the possibility of correcting a non-negligible part of the incorrectly predicted bits. As we shall see in the experiments, the trade-off is very favorable. We would like to note at this point that dealing with the hubs or the most frequent labels with binary relevance may not particularly be a drawback of our approach: the occurrence probabilities of the labels is long-tailed, and the first few labels may be sufficiently important to deserve a special treatment. What really needs to be compressed is the large set of labels that occur rarely.</p><p>To find the label clustering, we first build the co-occurrence graph and remove the hubs using the degree centrality measure. The remaining labels are then clustered using Louvain algorithm <ref type="bibr" target="#b0">[1]</ref>; to control the number of clusters, a maximum size is fixed and larger clusters are recursively clustered until they reach the desired size. Finally, to obtain (almost) balanced clusters, the smallest clusters are merged. Both the number of hubs and the cluster size are parameters of the algorithm, and, in Section 4, we show how to choose them before training at negligible computational cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Hash functions and decoding</head><p>From now on, we assume that we have access to a partition of L into mutually exclusive clusters (in practice, this corresponds to the labels that remain after removal of the hubs).</p><p>Hash functions Given the parameter K, constructing K-sparse encodings follows two conditions:</p><p>1. two labels from the same cluster cannot share any representative bit; 2. two labels from different clusters can share at most K -1 representative bits. Finding an encoding that satisfies the conditions above is not difficult if we consider, for each label, the set of its representative bits. In the rest of the paragraph, we say that a bit of the Bloom filter "is used for the encoding of a label" when this bit may be a representative bit of the label. If the bit "is not used for the encoding of a label", then it cannot be a representative bit of the label.</p><p>Let us consider the P mutually exclusive label clusters, and denote by R the size of the largest cluster. To satisfy Condition 1., we find an encoding on B = R.Q bits for Q ≥ K and P ≤ Q K as follows. For a given r ∈ {1, ..., R}, the r-th batch of Q successive bits (i.e. the bits of index (r -1)Q + 1, (r -1)Q + 2, ..., rQ) is used only for the encoding of the r-th label of each cluster. That way, each batch of Q bits is used for the encoding of a single label per cluster (enforcing the first condition) but can be used for the encoding of P labels overall. For the Condition 2., we notice that given a batch of Q bits, there are Q K different subsets of K bits. We then injectively map the (at most) P labels to the subsets of size K to define the K representative bits of these labels. In the end, with a Bloom filter of size B = R.Q, we have K-sparse encodings that satisfy the two conditions above for L ≤ R. Q K labels partitioned into P ≤ Q K mutually exclusive clusters of size at most R. Figure <ref type="figure">2</ref> gives an example of such an encoding. In the end, the scheme is most efficient (in terms of the compression ratio B/L) when the clusters are perfectly balanced and when P is exactly equal to Q K for some Q. For instance, for K = 2 that we use in our experiments, if P = Q(Q+1) 2 for some integer Q, and if the clusters are almost perfectly balanced, then B/L ≈ 2/P . The ratio becomes more and more favorable as both Q increases and K increases up to Q/2, but the number of different clusters P must also be large. Thus, the method should be most efficient on datasets with a very large number of labels, assuming that P increases with L in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Decoding and Robustness</head><p>We now present the decoding algorithm, followed by a theoretical guarantee that each incorrectly predicted bit in the Bloom filter cannot imply more than 2 incorrectly predicted labels.</p><p>Given an example x and its predicted encoding ê(x), the predicted label set d(ê(x)) is computed with the following two-step process, in which we say that a bit is "representative of one cluster" if it is a representative bit of one label in the cluster: a. (Cluster Identification) For each cluster L p , compute its cluster score s p defined as the number of its representative bits that are set to 1 in ê(x). Choose L p for p ∈ arg max In case of ties in the cluster identification, the tie-breaking rule can be arbitrary. For instance, in our experiments, we use logistic regression as base learners for binary classifiers, so we have access to posterior probabilities of being 1 for each bit of the Bloom filter. In case of ties in the cluster identification, we restrict our attention to the clusters that maximize the cluster score, and we recompute their cluster scores using the posterior probabilities instead of the binary decision. The cluster which maximizes the new cluster score is chosen. The choice of a randomized prediction for the labels avoids a single incorrectly predicted bit to result in too many incorrectly predicted labels. The robustness of the encoding/decoding scheme is proved below:</p><p>Theorem 1 Let the label set L , and let (L 1 , ..., L P ) be a partition of L satisfying (2). Assume that the encoding function satisfies Conditions 1. and 2., and that decoding is performed in the two-step process a.-b. Then, using the definitions of H L and H B of (1), we have:</p><formula xml:id="formula_6">H L (d • ê) ≤ 2B L H B (ê)</formula><p>for a K-sparse encoding, where the expectation in H L is also taken over the randomized predictions.</p><p>Sketch of proof Let (x, y) be an example. We compare the expected number of incorrectly predicted labels H L (y, d(ê(x))) = E |d(ê(x)) ∆ y| (expectation taken over the randomized prediction) and the number of incorrectly predicted bits H B (ê(x) , e(y)) = B j=1 1 {êj (x) =ej(y)} . Let us denote by p * the index of the cluster in which y is included, and p the index of the cluster chosen in step a. We consider the two following cases: p = p * : if the cluster is correctly identified then each incorrectly predicted bit that is representative for the cluster costs 1 K in H L (y, d(ê(x))). All other bits do not matter. We thus have</p><formula xml:id="formula_7">H L (y, d(ê(x))) ≤ 1 K H B (ê(x) , e(y)).</formula><p>p = p * : If the cluster is not correctly identified, then H L (y, d(ê(x))) is the sum of (1) the number of labels that should be predicted but are not (|y|), and (2) the labels that are in the predicted label set but that should not. To bound the ratio H L (</p><p>) , we first notice that there are at least as much representative bits predicted as 1 for L p than for L p * . Since each label of L p shares at most K -1 representative bits with a label of L p * , there are at least |y| incorrect bits. Moreover, the maximum contribution to labels predicted in the incorrect cluster by correctly predicted bits is at most</p><formula xml:id="formula_9">K-1 K |y|. Each additional contribution of 1 K in H L (y, d(ê(x))</formula><p>) comes from a bit that is incorrectly predicted to 1 instead of 0 (and is representative for L p). Let us denote by k the number of such contributions. Then, the most defavorable ratio H L (y,d(ê(x))) H B (ê(x),e(y)) is smaller than max</p><formula xml:id="formula_10">k≥0 k K +|y|(1+ K-1 K ) max(|y|,k) = |y| K +|y|(1+ K-1 K ) |y| = 2.</formula><p>Taking the expectation over (x, y) completes the proof ( B L comes from normalization factors).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Comparison to Related Works</head><p>The use of correlations between labels has a long history in MLC <ref type="bibr" target="#b10">[11]</ref> [8] <ref type="bibr" target="#b13">[14]</ref>, but correlations are most often used to improve prediction performances at the expense of computational complexity through increasingly complex models, rather than to improve computational complexity using strong negative correlations as we do here.</p><p>The most closely related works to ours is that of Hsu et al. <ref type="bibr" target="#b11">[12]</ref>, where the authors propose an approach based on compressed sensing to obtain low-dimension encodings of label sets. Their approach has the advantage of a theoretical guarantee in terms of regret (rather than error as we do), without strong structural assumptions on the label sets; the complexity of learning scales in O(C ln(L)) where C is the number of labels in label sets. For our approach, since</p><formula xml:id="formula_11">Q Q 2 ∼ Q→∞ 4 Q/2 / √ 8πQ</formula><p>, it could be possible to obtain a logarithmic rate under the rather strong assumption that the number of clusters P increases linearly with L. As we shall see in our experiments, however, even with a rather large number of labels (e.g. 1 000), the asymptotic logarithmic rate is far from being achieved for all methods. In practice, the main drawback of their method is that they need to know the size of the label set to predict. This is an extremely strong requirement when classification decisions are needed (less strong when only a ranking of the labels is needed), in contrast to our method which is inherently designed for classification.</p><p>Another related work is that of <ref type="bibr" target="#b3">[4]</ref>, which is based on SVD for dimensionality reduction rather than compressed sensing. Their method can exploit correlations between labels, and take classification decisions. However, their approach is purely heuristic, and no theoretical guarantee is given. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>We performed experiments on two large-scale real world datasets: RCV-Industries, which is a subset of the RCV1 dataset <ref type="bibr" target="#b12">[13]</ref> that considers the industry categories only (we used the first testing set file from the RCV1 site instead of the original training set since it is larger), and Wikipedia1k, which is a subsample of the wikipedia dataset release of the 2012 large scale hierarchical text classification challenge <ref type="bibr" target="#b16">[17]</ref>. On both datasets, the labels are originally organized in a hierarchy, but we transformed them into plain MLC datasets by keeping only leaf labels We compared our methods, the standard (i.e. with random hash function) BF (S-BF) and the Robust BF (R-BF) presented in section 3, to binary relevance (BR) and to three MLC algorithms designed for MLC problems with a large number of labels: a pruned version of BR proposed in <ref type="bibr" target="#b6">[7]</ref> (called BR-Dekel from now on), the compressed sensing approach (CS) of <ref type="bibr" target="#b11">[12]</ref> and the principal label space transformation (PLST) <ref type="bibr" target="#b3">[4]</ref>. BR-Dekel consists in removing from the prediction all the labels whose probability of a true positive (PTP) on the validation set is smaller than the probability of a false positive (PFP). To control the code size B in BR-Dekel, we rank the labels based on the ratio P T P/P F P and keep the top B labels. In that case, the inference complexity is similar to BF models, but the training complexity is still linear in L. For CS, following <ref type="bibr" target="#b3">[4]</ref>, we used orthogonal matching poursuit (CS-OMP) for decoding and selected the number of labels to predict in the range {1, 2, . . . , 30}, on the validation set. For S-BF, the number of (random) hash functions K is also chosen on the validation set among {1, 2, . . . , 10}. For R-BF, we use K = 2 hash functions.</p><p>The code size B can be freely set for all methods except for Robust BF, where different settings of the maximum cluster size and the number of hubs may lead to the same code size. Since the use of a label clustering in R-BF leads to unrecoverable errors even if the classifiers perform perfectly well (because labels of different clusters cannot be predicted together), we chose the max cluster size among {10, 20, . . . , 50} and the number of hubs (among {0, 10, 20, 30, . . . , 100} for RCV-Industries and {0, 50, 100, . . . , 300} for Wikipedia1k) that minimize the resulting unrecoverable Hamming loss (UHL), computed on the train set. Figure <ref type="figure" target="#fig_0">3</ref> (left) shows how the UHL naturally decreases when the number of hubs increases since then the method becomes closer to BR, but at the same time the overall code size B increases because it is the sum of the filter's size and the number of hubs. Nonetheless, we can observe on the figure that the UHL rapidly reaches a very low value, confirming that the label clustering assumption is reasonable in practice.</p><p>All the methods involve training binary classifiers or regression functions. On both datasets, we used linear functions with L 2 regularization (the global regularization factor in PLST and CS-OMP, as well as the regularization factor of each binary classifier in BF and BR approaches, were chosen on the validation set among {0, 0.1, . . . , 10 -5 }), and unit-nom normalized TF-IDF features. We used the Liblinear <ref type="bibr" target="#b9">[10]</ref> implementation of logistic regression as base binary classifier. Results Table <ref type="table" target="#tab_2">1</ref> gives the test performances of all the methods on both datasets for different code sizes. We are mostly interested in the Hamming loss but we also provide the micro and macro F-measure. The results are averaged over 10 random splits of train/validation/test of the datasets, respectively containing 50%/25%/25% of the data. The standard deviations of the values are negligible (smaller than 10 -3 times the value of the performance measure). Our BF methods seem to clearly outperform all other methods and R-BF yields significant improvements over S-BF. On Wikipedia1k, with 500 classifiers, the Hamming loss (in %) of S-BF is 0.0734 while it is only 0.0705 for RBF. This performance is similar to that of BR's (0.0711) which uses twice as many classifiers.</p><p>The simple pruning strategy BR-Dekel is the worst baseline on both datasets, confirming that considering all classes is necessary on these datasets. CS-OMP reaches a much higher Hamming loss (about 23% worst than BR on both datasets when using 50% less classifiers). CS-OMP achieves the best performance on the macro-F measure though. This is because the size of the predicted label sets is fixed for CS, which increases recall but leads to poor precision. We used OMP as decoding procedure for CS since it seemed to perform better than Lasso and Correlation decoding (CD) <ref type="bibr" target="#b11">[12]</ref>( for instance, on RCV-Industries with a code size of 500, OMP achieves a Hamming loss of 0.0875 while the Hamming loss is 0.0894 for Lasso and 0.1005 for CD). PLST improves over CS-OMP but its performances are lower than those of S-BF (about 3.5% on RCV-industries and 13% and Wikipedia when using 50% less classifiers than BR). The macro F-measure indicates that PLST likely suffers from class imbalance (only the most frequent labels are predicted), probably because the label set matrix on which SVD is performed is dominated by the most frequent labels. Figure <ref type="figure" target="#fig_0">3</ref> (right) gives the general picture of the Hamming loss of the methods on a larger range of code sizes. Overall, R-BF has the best performances except for very small code sizes because the UHL becomes too high.</p><p>Runtime analysis Experiments were performed on a computer with 24 intel Xeon 2.6 GHz CPUs. For all methods, the overall training time is dominated by the time to train the binary classifiers or regressors, which depends linearly on the code size. For test, the time is also dominated by the classifiers' predictions, and the decoding algorithm of R-BF is the fastest. For instance, on Wikipedia1k, training one binary classifier takes 12.35s on average, and inference with one classifier (for the whole test dataset) takes 3.18s. Thus, BR requires about 206 minutes (1000 × 12.35s) for training and 53m for testing on the whole test set. With B = 500, R-BF requires about half that time, including the selection of the number of hubs and the max. cluster size at training time, which is small (computing the UHL of a R-BF configuration takes 9.85s, including the label clustering step, and we try less than 50 of them). For the same B, encoding for CS takes 6.24s and the SVD in PSLT takes 81.03s, while decoding takes 24.39s at test time for CS and 7.86s for PSLT.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>label h 1 h 2 h 3</head><label>3</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Examples of a Bloom filter for a set L = { 1 , ..., 8 } with 8 elements, using 3 hash functions and 6 bits). (left) The table gives the hash values for each label. (middle-left) For each label, the hash functions give the index of the bits that are set to 1 in the 6-bit boolean vector. The examples of the encodings for { 1 } and { 4 } are given. (middle-right) Example of a false positive: the representation of the subset { 1 , 4 } includes all the representative bits of label 3 so that is 3 would be decoded erroneously. (right) Example of propagation of errors: a single erroneous bit in the label set encoding, together with a false positive, leads to three label errors in the final prediction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 (</head><label>1</label><figDesc>left) to (middle-right) give representative examples of the encoding/querying scheme of Bloom filters and an example of false positive.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Label Set Prediction) For each label ∈ L p, let s be the number of representative bits of set to 1 in ê(x); add to d(ê(x)) with probability s K .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: (left) Unrecoverable Hamming loss (UHL) due to label clustering of the R-BF as a function of the code size B on RCV-Industries (similar behavior on the Wikipedia1k dataset). The optimal curve represents the best UHL over different settings (number of hubs,max cluster size) for a given code size. (right) Hamming loss vs code size on RCV-Industries for different methods.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Representative bits for 30 labels partitioned into P = 15 mutually exclusive label clusters of size R = 2, using K = 2 representative bits per label and batches of Q = 6 bits. The table on the right gives the label clustering. The injective mapping between labels and subsets of bits is defined by g : → {g 1 ( ) = (1 + )/6, g 2 ( ) = 1 + mod 6} for ∈ {1, ..., 15} and, for ∈ {15, ..., 30}, it is defined by → {(6 + g 1 ( -15), 6 + g 1 ( -15)}.</figDesc><table><row><cell cols="2">bit representative</cell><cell>bit</cell><cell>representative</cell><cell cols="4">cluster labels in cluster labels in</cell></row><row><cell>index</cell><cell>for labels</cell><cell>index</cell><cell>for labels</cell><cell>index</cell><cell>cluster</cell><cell>index</cell><cell>cluster</cell></row><row><cell>1 2</cell><cell>{1, 2, 3, 4, 5} {1, 6, 7, 8, 9}</cell><cell>7 8</cell><cell>{16, 17, 18, 19, 20} {16, 21, 22, 23, 24}</cell><cell>1 2 3</cell><cell>{1, 15} {2, 16} {3, 17}</cell><cell>9 10 11</cell><cell>{9, 23} {10, 24} {11, 25}</cell></row><row><cell>3</cell><cell>{2, 6, 10, 11, 12}</cell><cell>9</cell><cell>{17, 21, 25, 26, 27}</cell><cell>4</cell><cell>{4, 18}</cell><cell>12</cell><cell>{12, 26}</cell></row><row><cell>4</cell><cell>{3, 7, 10, 13, 14}</cell><cell>10</cell><cell>{18, 22, 25, 28, 29}</cell><cell>5</cell><cell>{5, 19}</cell><cell>13</cell><cell>{13, 27}</cell></row><row><cell>5 6</cell><cell>{4, 8, 11, 13, 15} {5, 9, 12, 14, 15}</cell><cell>11 12</cell><cell>{19, 23, 26, 28, 30} {20, 24, 27, 29, 30}</cell><cell>6 7 8</cell><cell>{6, 20} {7, 21} {8, 22}</cell><cell>14 15</cell><cell>{14, 28} {15, 29}</cell></row><row><cell cols="2">Figure 2:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>. For RCV-Industries, we obtain 303 labels for 72, 334 examples. The average cardinality of label sets is 1.73 with a maximum of 30; 20% of the examples have label sets of cardinality ≥ 2. For Wikipedia1k, we kept the 1, 000 most represented leaf labels, which leads to 110, 530 examples with an average label set cardinality of 1.11 (max. 5). 10% of the examples have label sets of cardinality ≥ 2.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Test Hamming loss (HL, in %), micro (m-F1) and macro (M-F1) F1-scores. B is code size. The results of the significance test for a p-value less than 5% are denoted † to indicate the best performing method using the same B and * to indicate the best performing method overall.</figDesc><table><row><cell>Classifier</cell><cell>B</cell><cell cols="2">HL RCV-Industries m-F1</cell><cell>M-F1</cell><cell>B</cell><cell cols="2">HL Wikipedia1K m-F1</cell><cell>M-F1</cell></row><row><cell>BR</cell><cell>303</cell><cell>0.200  *</cell><cell>72.43  *</cell><cell>47.82  *</cell><cell>1000</cell><cell>0.0711</cell><cell>55.96</cell><cell>34.7</cell></row><row><cell>BR-Dekel</cell><cell>150 200</cell><cell>0.308 0.233</cell><cell>46.98 65.78</cell><cell>30.14 40.09</cell><cell>250 500</cell><cell>0.0984 0.0868</cell><cell>22.18 38.33</cell><cell>12.16 24.52</cell></row><row><cell>S-BF</cell><cell>150 200</cell><cell>0.223 0.217</cell><cell>67.45 68.32</cell><cell>40.29 40.95</cell><cell>250 500</cell><cell>0.0742 0.0734</cell><cell>53.02 53.90</cell><cell>31.41 32.57</cell></row><row><cell>R-BF</cell><cell>150 200</cell><cell>0.210  † 0.205  †</cell><cell>71.31  † 71.86  †</cell><cell>43.44 44.57</cell><cell>240 500</cell><cell>0.0728  † 0.0705  † *</cell><cell>55.85 57.31</cell><cell>34.65 36.85</cell></row><row><cell>CS-OMP</cell><cell>150 200</cell><cell>0.246 0.245</cell><cell>67.59 67.71</cell><cell>45.22  † 45.82  †</cell><cell>250 500</cell><cell>0.0886 0.0875</cell><cell cols="2">57.96  † 58.46  † *  42.52  † *  41.84  †</cell></row><row><cell>PLST</cell><cell>150 200</cell><cell>0.226 0.221</cell><cell>68.87 70.35</cell><cell>32.36 40.78</cell><cell>250 500</cell><cell>0.0854 0.0828</cell><cell>42.45 45.95</cell><cell>09.53 16.73</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was partially supported by the French ANR as part of the project Class-Y (ANR-10-BLAN-02) and carried out in the framework of the Labex MS2T (ANR-11-IDEX-0004-02).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fast unfolding of communities in large networks</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Blondel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-L</forename><surname>Guillaume</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lambiotte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lefebvre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Statistical Mechanics: Theory and Experiment</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Space/time trade-offs in hash coding with allowable errors</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Bloom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="422" to="426" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Exact and approximate membership testers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Markowsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wegman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the tenth annual ACM symposium on Theory of computing, STOC &apos;78</title>
		<meeting>the tenth annual ACM symposium on Theory of computing, STOC &apos;78<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="59" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Feature-aware label space dimension reduction for multi-label classification</title>
		<author>
			<persName><forename type="first">Y.-N</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-T</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1538" to="1546" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Combining instance-based learning and logistic regression for multilabel classification</title>
		<author>
			<persName><forename type="first">W</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hüllermeier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="211" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A new analysis of the false positive rate of a bloom filter</title>
		<author>
			<persName><forename type="first">K</forename><surname>Christensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roginsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jimeno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="issue">21</biblScope>
			<biblScope unit="page" from="944" to="949" />
			<date type="published" when="2010-10">Oct. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Multiclass-multilabel classification with more classes than examples</title>
		<author>
			<persName><forename type="first">O</forename><surname>Dekel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Shamir</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="137" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bayes optimal multilabel classification via probabilistic classifier chains</title>
		<author>
			<persName><forename type="first">K</forename><surname>Dembczynski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hüllermeier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="279" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On label dependence and loss minimization in multi-label classification</title>
		<author>
			<persName><forename type="first">K</forename><surname>Dembczynski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Waegeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hüllermeier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="5" to="45" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Liblinear: A library for large linear classification</title>
		<author>
			<persName><forename type="first">R.-E</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-W</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-J</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X.-R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-J</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mach. Learn. Res</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1871" to="1874" />
			<date type="published" when="2008-06">June 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Large Scale Max-Margin Multi-Label Classification with Prior Knowledge about Densely Correlated Labels</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hariharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V N</forename><surname>Vishwanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Varma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Machine Learning</title>
		<meeting>International Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multi-label prediction via compressed sensing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kakade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Langford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="772" to="780" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<ptr target="http://www.daviddlewis.com/resources/testcollections/rcv1/" />
		<title level="m">RCV1. RCV1 Dataset</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Classifier chains for multi-label classification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Read</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfah Ringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Holmes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Frank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Machine Learning and Knowledge Discovery in Databases: Part II, ECML PKDD &apos;09</title>
		<meeting>the European Conference on Machine Learning and Knowledge Discovery in Databases: Part II, ECML PKDD &apos;09<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="254" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Multilabel classification with principal label space transformation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Tai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-T</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Computation</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2508" to="2542" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Review of Multi-Label Classification Methods</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tsoumakas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Katakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Vlahavas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd ADBIS Workshop on Data Mining and Knowledge Discovery (ADMKD 2006)</title>
		<meeting>the 2nd ADBIS Workshop on Data Mining and Knowledge Discovery (ADMKD 2006)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="99" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="middle">Wikipedia</forename><surname>Wikipedia</surname></persName>
		</author>
		<author>
			<persName><surname>Dataset</surname></persName>
		</author>
		<ptr target="http://lshtc.iit.demokritos.gr/" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
