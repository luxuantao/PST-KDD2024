<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Language-Independent and Automated Software Composition: The FEATUREHOUSE Experience</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sven</forename><surname>Apel</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics and Mathematics</orgName>
								<orgName type="institution">University of Passau</orgName>
								<address>
									<addrLine>Innstr. 33</addrLine>
									<postCode>94032</postCode>
									<settlement>Passau</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><forename type="middle">Ka</forename><surname>¨stner</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics and Mathematics</orgName>
								<orgName type="institution">University of Passau</orgName>
								<address>
									<addrLine>Innstr. 33</addrLine>
									<postCode>94032</postCode>
									<settlement>Passau</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><surname>Lengauer</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics and Mathematics</orgName>
								<orgName type="institution">University of Passau</orgName>
								<address>
									<addrLine>Innstr. 33</addrLine>
									<postCode>94032</postCode>
									<settlement>Passau</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="middle">C</forename><surname>Ka¨stner</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Institute for Software Research</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<addrLine>5000 Forbes Avenue</addrLine>
									<postCode>15213</postCode>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Language-Independent and Automated Software Composition: The FEATUREHOUSE Experience</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EBC0324F2C7512F0B647775EB091B025</idno>
					<idno type="DOI">10.1109/TSE.2011.120</idno>
					<note type="submission">Manuscript received 21 Oct. 2010; revised 26 Oct. 2011; accepted 29 Nov. 2011; published online 5 Dec. 2011.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>FEATUREHOUSE</term>
					<term>feature structure trees</term>
					<term>software composition</term>
					<term>superimposition</term>
					<term>language independence</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Superimposition is a composition technique that has been applied successfully in many areas of software development. Although superimposition is a general-purpose concept, it has been (re)invented and implemented individually for various kinds of software artifacts. We unify languages and tools that rely on superimposition by using the language-independent model of feature structure trees (FSTs). On the basis of the FST model, we propose a general approach to the composition of software artifacts written in different languages. Furthermore, we offer a supporting framework and tool chain, called FEATUREHOUSE. We use attribute grammars to automate the integration of additional languages. In particular, we have integrated Java, C#, C, Haskell, Alloy, and JavaCC. A substantial number of case studies demonstrate the practicality and scalability of our approach and reveal insights into the properties that a language must have in order to be ready for superimposition. We discuss perspectives of our approach and demonstrate how we extended FEATUREHOUSE with support for XML languages (in particular, XHTML, XMI/UML, and Ant) and alternative composition approaches (in particular, aspect weaving). Rounding off our previous work, we provide here a holistic view of the FEATUREHOUSE approach based on rich experience with numerous languages and case studies and reflections on several years of research</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>S OFTWARE composition is the process of constructing software systems from a set of software artifacts. An artifact can be any kind of information that is part of or related to software, for example, code units (packages, classes, methods, etc.) or supporting documents (models, documentation, makefiles, etc.). One popular approach to software composition is superimposition. Superimposition is the process of composing software artifacts by merging their corresponding substructures. For example, when composing two Java files, two constituent classes with the same name, say Foo, are merged, and the result is called again Foo. The substructures of Foo are merged in turn recursively.</p><p>Superimposition has been applied successfully to the composition of class hierarchies in multiteam software development <ref type="bibr" target="#b0">[1]</ref>, the extension of distributed programs <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, the implementation of collaboration-based designs <ref type="bibr" target="#b3">[4]</ref>, feature-oriented programming <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, multidimensional separation of concerns <ref type="bibr" target="#b6">[7]</ref>, aspect-oriented programming <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, and software component adaptation <ref type="bibr" target="#b9">[10]</ref>. Although diverse, all these applications pursue superimposition of hierarchically organized program constructs on the basis of their nominal and structural similarities.</p><p>It has been noted that, when composing software, not only so code artifacts-possibly written in different programming languages-have to be considered, but also noncode artifacts, for example, models, documentation, grammar files, or makefiles <ref type="bibr" target="#b5">[6]</ref>. Thus, as a composition technique, superimposition should be applicable to a wide range of software artifacts. While there are various tools that support superimposition of code artifacts <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref> and noncode artifacts <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b22">[23]</ref>, they all appear different, they are dedicated to and embedded individually in their respective host languages, and their implementation and integration require a major effort. Usually, the developers of languages and tools did not address (or realize) the general nature of superimposition. This hinders coordinated efforts to advance composition technology.</p><p>We propose a structural approach to the composition of software artifacts written in different languages, and we offer a supporting framework and tool chain, called FEATUREHOUSE. FEATUREHOUSE follows the ideas of Batory's AHEAD program generator <ref type="bibr" target="#b5">[6]</ref> and builds on our previous work on language-independent software representation <ref type="bibr" target="#b23">[24]</ref> and composition <ref type="bibr" target="#b24">[25]</ref>, as we will explain.</p><p>In a nutshell, FEATUREHOUSE is a framework for software composition on the basis of superimposition into which new languages can be plugged on demand. The integration of a new language, say C# or Haskell, requires only a few hours of effort, in contrast to expensive manual implementations. Technically, FEATUREHOUSE is based on three ingredients: 1) a language-independent model of software artifacts, 2) superimposition as a language-independent composition paradigm, and 3) an artifact-language specification based on attribute grammars.</p><p>We have used FEATUREHOUSE in a number of case studies to demonstrate that our approach of software composition is indeed general. In particular, we have integrated several, different languages into FEATURE-HOUSE: Java, C, C#, Haskell, Alloy, JavaCC, XHTML, XMI/UML, and Ant. That is, FEATUREHOUSE can be used to compose software artifacts written in these languages. We did not need to extend the languages themselves (e.g., by introducing new syntax and extending the compiler), as would be necessary in related approaches and tools such as AHEAD <ref type="bibr" target="#b5">[6]</ref>, CaesarJ <ref type="bibr" target="#b25">[26]</ref>, Classbox/J <ref type="bibr" target="#b13">[14]</ref>, FeatureC++ <ref type="bibr" target="#b16">[17]</ref>, or Fuji <ref type="bibr" target="#b17">[18]</ref>. This saved us a lot of tedious and errorprone implementation work.</p><p>The integration of a new language is almost entirely based on the language's grammar, plus some attributes added as annotations and some concise composition rules (usually not more than 10 to 20 lines of code). We have applied FEATUREHOUSE in the composition of over 50 software systems of different sizes (1 to 64 thousand lines of code), written in different languages (Java, C#, C, Haskell, Alloy, and JavaCC). Our studies demonstrate the practicality and scalability of our approach and tools and provide insight into mandatory and desirable properties that a language must have in order to be ready for superimposition.</p><p>In summary, we make the following contributions:</p><p>1. We propose a general approach to software composition, based on superimposition, that is applicable to a wide variety of software languages. 2. We provide a framework and tool chain for language-independent, automated software composition and report on experiments with six languages and 50 software systems. 3. We discuss experience and insight gained in our case studies, especially with regard to composition granularity, uniqueness of identifiers, and ordering of elements. 4. We present two substantial extensions of FEATURE-HOUSE (support for XML-based languages and an integration of aspect weaving as an additional composition operator) which demonstrate the generality and potential of our approach. 5. We discuss perspectives of our approach, especially with regard to type checking and formal foundations. This paper subsumes and extends our previous work on language-independent, automated software composition <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref>. For the first time, we provide a coherent and complete overview of our experience and insight gained with FEATUREHOUSE. Compared to previous work, we report on experience with a substantial number of further case studies (42 new case studies, as compared to <ref type="bibr" target="#b26">[27]</ref>), new kinds of languages (including functional, specification, and XML-based languages), a number of extensions of our approach (e.g., a further composition operator), and perspectives that arise from our holistic and retrospective view on the FEATUREHOUSE approach. None of these contributions could have been made in earlier work, which concentrated on individual aspects, but neglected the big picture and its implications. These contributions arise from our experience and the ability to step back and look at practical applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">FEATUREHOUSE</head><p>FEATUREHOUSE is a framework for software composition supported by a corresponding tool chain. It provides facilities for software composition based on a languageindependent model of software artifacts and an automatic plugin mechanism for the integration of new artifact languages. FEATUREHOUSE generalizes and subsumes a previous software composition tool, called FSTCOMPOSER <ref type="bibr" target="#b24">[25]</ref>, and exceeds prior work on AHEAD in that it implements software composition language-independently. <ref type="foot" target="#foot_0">1</ref> The code of FEATUREHOUSE, as well as examples and all case studies, can be downloaded from the project's Web site: http://www.fosd.net/fh.</p><p>We begin with a brief review of FSTCOMPOSER and proceed with a description of the overall FEATUREHOUSE architecture and how it integrates FSTCOMPOSER.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Representation and Composition</head><p>FSTCOMPOSER relies on a general model of the structure of software artifacts, called the feature structure tree (FST) model. An FST represents the essential structure of a software artifact and abstracts from language-specific details. For example, an artifact written in Java contains packages, classes, methods, and so forth, which are represented by nodes in its FST; a Haskell program contains equations, algebraic data types, type classes, etc., which contain further elements; a makefile or build script consists of definitions and rules that may be nested.</p><p>Each node of an FST has 1) a name that is the name of the corresponding structural element and 2) a type that represents the syntactic category of the corresponding structural element. For example, a Java class Foo is represented by a node Foo of type Java class. Essentially, an FST is a stripped-down abstract syntax tree: It contains only information that is necessary for the specification of the modular structure of an artifact and for its composition with other artifacts. The inner nodes of an FST denote modules (e.g., classes and packages) and the leaves carry the modules' content (e.g., method bodies and field initializers). We call the inner nodes nonterminals and the leaves terminals. For illustration, Fig. <ref type="figure">1</ref> depicts an excerpt of a class of a database system, taken from one of our case studies (Section 3.1). The complete class is located in a subpackage structure and contains 13 fields, 2 constructors, 58 methods, and 4 inner classes.</p><p>What code elements are represented as inner nodes and leaves? This depends on the language and on the level of granularity at which software artifacts are to be composed <ref type="bibr" target="#b30">[31]</ref>. Different granularities are possible and might be desired in different contexts. For Java, we might represent only packages and classes but not methods or fields as FST nodes (a coarse granularity), or we might also represent statements or expressions as FST nodes (a fine granularity). In any case, the structural elements not represented in the FST are stored as text content of terminal nodes (e.g., the body of a method). In our experience, the granularity of Fig. <ref type="figure">1</ref> is usually appropriate for composition. We will return to the issue of granularity in Section 2.2.</p><p>The composition of software artifacts proceeds by the superimposition of the corresponding FSTs, henceforth denoted by "". Two FSTs are superimposed by merging their nodes, identified by their names, types, and relative positions, starting from the root and descending recursively. Fig. <ref type="figure">2</ref> illustrates the process of FST superimposition with the database example. The artifact BaseDB is superimposed with an artifact called Latches, of which again only a subset is shown. Their composition results in a class Database consisting of the union of the members of its instances in BaseDB and Latches. Basically, composing Latches with BaseDB adds two new methods acquireReadLock and releaseReadLock and extends method notifyTriggers of BaseDB via overriding (original defines how two method bodies are composed, which is similar to Java's super or AspectJ's proceed).</p><p>Generally, the composition of two leaves of an FST that contain further content (e.g., the two bodies of notifyTriggers) demands special treatment. The reason is that the content is not represented as a subtree but as plain text. Java method bodies are composed differently from fields, Haskell functions, or JavaCC grammar productions. Depending on the artifact language and node type, different rules for the composition of terminals apply. Often simple rules such as replacement, concatenation, specialization, or overriding suffice, but the approach is open to more sophisticated rules known from multidimensional separation of concerns <ref type="bibr" target="#b15">[16]</ref> or software merging <ref type="bibr" target="#b31">[32]</ref>. For example, in our case studies, we merge two method bodies via overriding, in which original defines how the bodies are merged. Note that original is not a new keyword added to the grammar of Java. We use a regular Java parser, which classifies original as a method name. FEATUREHOUSE searches for occurrences of original during the composition of two method bodies and substitutes each occurrence by the original method body (in the case of name clashes, with some semantics-preserving renaming). The only restriction is that original must not be used as a method name (or as any other kind of identifier). So, actually we have restricted the Java semantics minimally to support the composition of method bodies. As a result of the composition, we receive a syntactically correct Java program.</p><p>Technically, multiple software artifacts (e.g., code and corresponding documentation) can be aggregated in a composition unit. FSTCOMPOSER expects a list of units to be composed. The artifacts of a composition unit may be organized in a subdirectory structure. Without any further preparation, FSTCOMPOSER interprets subdirectories as nonterminals and the files located inside a subdirectory as terminals. Of course, if we intend to achieve a finer composition granularity than at the level of entire files (e.g., at the level of functions, classes and methods, and grammar rules, as in Fig. <ref type="figure">2</ref>), we add further levels of nonterminals representing the artifacts' substructures, as we will explain next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Generation and Automation</head><p>New languages can be easily plugged into FEATUREHOUSE. The idea is that, although artifact languages are very different, the process of software composition by superimposition is very similar. For example, the developers of AHEAD <ref type="bibr" target="#b5">[6]</ref> and FeatureC++ <ref type="bibr" target="#b16">[17]</ref> have extended the artifact languages Java and C++ by constructs (e.g., refines or Super) and mechanisms for composition. They have each implemented a parser, a superimposition algorithm, and a pretty printer 2 -all specific to the artifact language. We have introduced the FST model to be able to express superimposition independently of an artifact language <ref type="bibr" target="#b24">[25]</ref>. Nevertheless, without automation, we had to provide, for each language (at the time, for Java and C#):</p><p>1. a parser and corresponding framework classes representing the parse tree, 2. an adapter that maps the parse tree to the FST, 3. language-specific composition rules (e.g., for merging method bodies), and 4. a pretty printer for writing superimposed FSTs to disk. Overall, the process of implementing and integrating language support manually was time-consuming and errorprone. Usually, we (or our students) spent several weeks on making the parsers, adapters, and pretty printers work. Often, the initial versions of the manually implemented and integrated parsers, adapters, and pretty printers contained numerous bugs, so we had to spend significant time on debugging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Generation</head><p>These problems motivated us to automate the integration of further languages and base it largely on the languages' grammars. This allows us to generate most of the code that must otherwise be provided and integrated manually (parser, adapter, pretty printer) and to experiment with different representations of software artifacts, as we will illustrate shortly. Our tool FSTGENERATOR expects the grammar of the language to be integrated in a specific format, called FEATUREBNF, and generates parser, adapter, and pretty printer accordingly. FEATUREBNF is similar to the Backus-Naur-Form but supports a number of extensions <ref type="bibr" target="#b32">[33]</ref> and annotations, some of which are used by FSTGE-NERATOR, as we will explain. Using a grammar written in FEATUREBNF, FSTGENERATOR generates 1) an LL(k) parser that directly produces FST nodes and 2) a corresponding pretty printer. After the generation step, composition proceeds as follows: 1) the generated parser receives artifacts written in the target language and produces one FST per artifact, 2) FSTCOMPOSER performs the composition, and 3) the generated pretty printer writes the composed artifacts to disk. For the composition of the content of terminal nodes, we have developed and integrated a library of composition rules (e.g., rules for method overriding and for the concatenation of the statements of two constructors). Fig. <ref type="figure" target="#fig_1">3</ref> illustrates the interplay between FSTGENERATOR and FSTCOMPOSER; Table <ref type="table" target="#tab_0">1</ref> lists the composition rules we have implemented so far (Section 3.1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Attributes</head><p>To specify how artifacts of a language are represented as FSTs, programmers annotate the language's grammar with attributes. We explain the role of attributes using a simplified Java grammar. In Fig. <ref type="figure" target="#fig_2">4</ref>, we depict an excerpt of the corresponding FEATUREBNF grammar that is relevant for classes and methods. For example, rule ClassDecl defines the structure of classes containing fields (VarDecl), constructors (ClassConstr), and methods (MethodDecl).</p><p>Without any attributes, FSTGENERATOR would create a single terminal node for each file; in our case, beside nonterminals denoting the enclosing directories and the enclosing Java file, there would only be a terminal node per class, and the class' members would appear as text in the terminal's content. Since this granularity is too coarse for our purposes (recall: we would like to exploit the internal structure of a Java file, as shown in Figs. <ref type="figure">1</ref> and<ref type="figure">2</ref>), we use attributes to annotate the production rules that correspond to nonterminals (i.e., that contain further nodes).</p><p>Fig. <ref type="figure">5</ref> depicts an annotated version of our simple Java grammar. Attribute @FSTNonTerminal above rule Class-Decl states that classes are nonterminals that contain further 2. With "pretty printer" we refer to a tool, also known as unparser, that takes a parse tree or an FST and generates source code. elements; all productions that follow and that are not annotated are automatically interpreted as terminals. It follows from the grammar that a node representing a class may have children representing its name, supertype, fields, constructors, and methods. The attribute's parameter, name, is used to assign the name of a class to the FST node representing the class.</p><p>With a single attribute, we have refined the composition granularity of Java artifacts. Now, Java FSTs have three levels (omitting packages and imports, for simplicity): 1) a root that represents the Java file, 2) a class that is a nonterminal, and 3) type names, methods, constructors, and fields that are terminals. Without the attribute, a Java FST consists only of a single node representing the corresponding Java file. In Fig. <ref type="figure">6</ref>, we illustrate the difference between the two levels of granularity.</p><p>Besides @FSTNonTerminal, FSTGENERATOR supports several further kinds of attributes. For example, attribute @FSTTerminal is used to mark terminal nodes, as could be useful for representing classes as FST nodes. Although all production rules that are not annotated are interpreted as terminals or as text content of terminals, this attribute allows a programmer to define the name that appears in the FST node and the composition rule for merging the content of two corresponding terminals. For example, in Fig. <ref type="figure">7</ref> we specify that the name of a node representing a Java method receives the method's name (ID) followed by its formal parameters (FormalParamList). Production rules without explicitly assigned names receive proper default names.</p><p>Note that, without the possibility of specifying the name of an FST node, in many cases a superimposition would not be feasible. Recall that two nodes are superimposed if and only if their names (and types) are identical. For example, we can use parameter name to define that two classes are composed if their identifiers are identical (name="{Type}") or only if their identifiers and their supertypes are identical (name="{Type} {ExtType}").</p><p>Using parameter compose, we define which composition rule from the library is used when composing terminal nodes. In our simple Java grammar of Fig. <ref type="figure">7</ref>, we define that methods are composed via method overriding. The value JavaMethodOverriding refers to an artifact-specific composition rule that is part of the library of composition rules.</p><p>In Fig. <ref type="figure">8</ref>, we depict the interface of rule JavaMethod Overriding. A composition rule takes the terminal nodes to be composed as well as the result node as arguments. Then, it constructs the body of the result node such that it represents the composition of the two input nodes to be composed. This example illustrates the simplicity of writing composition rules. Of course, it is possible to write more    sophisticated composition rules, for example, by parsing the individual bodies and performing syntax-tree transformations and type analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EVALUATION AND EXPERIENCE</head><p>To evaluate the generality, practicality, and scalability of our approach and to reveal open issues, we integrated six languages into FEATUREHOUSE and used it in the composition of 50 software systems of different sizes and domains. We report on key observations made and lessons learned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Sample Languages and Systems</head><p>We integrated three imperative languages, two of them object-oriented (C, Java, and C#), one functional language (Haskell), one specification and modeling language (Alloy), and one domain-specific language for grammar specifications (JavaCC). In Table <ref type="table" target="#tab_1">2</ref>, we provide a summary of the overall number of grammar rules, the number of rules annotated to represent nonterminals, the number of rules annotated to represent terminals, and the overall number of attributes per language. FEATUREHOUSE, including all language plugins, is available on the project's Web site.</p><p>All of our 50 sample systems have been decomposed into composition units for different purposes, mostly by others. In our experiments, we composed them in different variants (reaching from one to hundreds). This was an incremental process during the last four years. The rationale of selecting such a large sample was to gain practical experience with FEATUREHOUSE and to address issues such as scalability and composition granularity. In Table <ref type="table">3</ref>, we summarize information on the sample software systems and their compositions. The source code of all software systems of our study is available on the FEATURE-HOUSE Web site.</p><p>Note that some of the sample systems are related. BCJAK2JAVA, JAK2JAVA, JAMPACK, JRENAME, MIXIN, MMATRIX, and UNMIXIN belong to the AHEAD tool suite <ref type="bibr" target="#b33">[34]</ref>. They share certain basic functionality such as parsers. Similarly, BALI2JAK, BALI2JAVACC, BALI2LAYER, and BALICOMPOSER belong to the BALI tool suite <ref type="bibr" target="#b33">[34]</ref>. Furthermore, CHATSYSTEM comes in eight different variants. The variants have been developed independently in a course on software product-line engineering at the University of Magdeburg. The same applies to NOTEPAD, which comes in seven variants, independently developed in a course on feature-oriented design at The University of Texas at Austin. Next, we discuss our key observations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Mandatory Properties</head><p>Our case studies demonstrate that FEATUREHOUSE is a very general tool and approach. We were able to integrate a number of different languages into FEATUREHOUSE, including languages of different programming paradigms as well as specification and domain-specific languages. Despite the considerable variety of the languages integrated, we identified a set of properties that are mandatory for a language to be plugged into FEATUREHOUSE:</p><p>1. The substructure of a software artifact must be a tree. 2. Every element of an artifact must provide a name that becomes the node's name and must belong to a syntactic category that becomes the node's type; an element must not contain two or more direct child elements with the same name and type. 3. Elements that do not have a hierarchical substructure represented in the FST (terminals) must come with composition rules in order to be composable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Generality</head><p>Superimposition is only one of several composition approaches. It is especially useful in scenarios in which the code of components is available and their structures are compatible. Other scenarios such as black-box composition or the integration of structurally incompatible components are less suited for superimposition and should be handled by alternative composition approaches such as on-demand remodularization <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b34">[35]</ref> and component aggregation <ref type="bibr" target="#b35">[36]</ref>.</p><p>Our case studies have all been designed with superimposition in mind. Most of them are product lines whose features systematically refine the code of other features. Hence, we are not able to draw sound conclusions on the suitability of superimposition as compared to other composition techniques. This issue is outside the scope of this paper and is addressed partially by previous work <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b37">[38]</ref>. Nevertheless, an extension of FEATUREHOUSE for quantification and weaving is motivated by this work and is discussed in Section 4.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Granularity</head><p>FEATUREHOUSE enables developers to adjust the granularity of composition by annotating the corresponding grammars. This way, we were able to experiment with different levels of granularity. For example, in Haskell, it was not clear which degree of granularity of superimposition is appropriate. It was clear that function definitions should be terminals, but not whether data type definitions should be terminals or nonterminals. After playing with some examples, we realized that it is quite useful to represent data types as nonterminals so that data type definitions can be extended by adding new type constructors. For example in Fig. <ref type="figure" target="#fig_5">9</ref>, we compose two data-type declarations for the representation of binary operations by merging their corresponding type constructors (Sub for subtraction and Add addition; a deriving clause defines to which type class a data type belongs).</p><p>The flexibility in adjusting the composition granularity even makes it possible to compose unstructured text when it is viewed as a single terminal node. In this case, two text nodes could be merged via string concatenation. However, the more structure is exposed in an FST, the finer grained the composition can be (which typically makes the composition more expressive and easier to implement), but there is usually a limit. For example, representing and superimposing arithmetic expressions is certainly not useful because expressions do not have unique names and the order or their evaluation matters, as we explain next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Uniqueness of Names</head><p>Unique names are central to composition with FEATURE-HOUSE. Without unique names, superimposition does not work. For each sample language, we identified a proper level </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE 3 Overview of the Sample Systems</head><p>of granularity at which elements have unique names and their composition is useful (i.e., there is enough structure for superimposition). In all languages, there are syntactic elements with unique names (in the scope of their parent elements), especially at coarse granularities (e.g., at the level of Java classes and Alloy signatures). However, as the granularity becomes finer, syntactic elements tend to have no or ambiguous names (e.g., at the level of Java statements or Alloy expressions). That is, the syntactic structure of the language affects the granularity at which artifacts can be meaningfully composed. Often, a fine granularity prohibits superimposition. There are two ways of attaining uniqueness of names: 1) adjust the attributes of the corresponding grammar to make composition coarser grained, and use a specific composition rule to compose the corresponding elements properly, as we have done, for example, for Java statements; 2) assign unique names manually, which may require changes to the language's syntax. Note that these approaches are related to each other: Refining the grain of composition often requires assigning proper names.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Element Order</head><p>An issue related to unique names is the order of elements. In our evaluation, we found that, typically, at a coarse granularity, the order of elements does not affect the program's or document's semantics (e.g., the order of Java methods or Alloy functions does not matter). As we made the granularity finer (by annotating the grammar), we observed that the elements' order becomes important in most languages (e.g., in the case of Java statements and Alloy expressions; in C, already at the level of functions). Superimposition is particularly useful at a level at which the elements' order may vary, which makes it is easy to add new elements (e.g., a new production rule to a JavaCC grammar). If the elements' order matters, it is difficult to insert elements between two existing elements (e.g., a statement in the middle of Java method). In this case, workarounds such as sandwiching are necessary. <ref type="foot" target="#foot_1">3</ref> When the elements' order matters, we can adjust the attributes of the corresponding grammar to make the composition coarser-grained and the elements' order immaterial, and use a specific composition rule to compose the corresponding elements properly. A classic example is the composition of two method bodies via a specific composition rule in which keyword original controls the order in which the statements of the bodies are merged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Tradeoffs</head><p>Apparently, there is a tradeoff between granularity, expressiveness, and simplicity. At a fine granularity, we gain compositional expressiveness, but face problems regarding uniqueness of names and element ordering, which require complex and language-specific composition rules. At a coarse granularity, we lose compositional expressiveness but face fewer or no problems regarding names and order, and need less complex and fewer language-specific composition rules. For the languages we looked at, we found an acceptable balance between granularity, expressiveness, and simplicity because they provide a sufficient amount of structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Scalability</head><p>To learn about scalability, we included a number of software systems of substantial size in our sample. For example, we have composed 99 composition units of Berkeley DB with 64,000 lines of code. Our study shows that FEATUREHOUSE, even though it is an unoptimized prototype, scales well with the number of composition units and lines of code (24 seconds composition time). The numbers for other systems are similar or smaller. Note that composition granularity may influence composition time. In our case studies, a typical FST has only a low depth (3-10), which does not influence performance significantly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.9">Integration Effort</head><p>In earlier work, we developed a parser adapter (to bridge the gap between parse tree and FST) and a pretty printer manually for each language <ref type="bibr" target="#b24">[25]</ref>; we call this the manual approach. With FEATUREHOUSE, we generate both automatically, based on attribute grammars; we call this the generative approach. In the manual approach, the effort of integrating a language was considerable-on the order of weeks. In contrast, in the generative approach, we usually spent only a few hours. For all languages, we were able either to rewrite an existing grammar given in EBNF, JavaCC, or ANTLR to the FEATUREBNF format (for Java, C#, Alloy, and JavaCC) or to write our own grammar based on the language specification (for C and Haskell). In Table <ref type="table">4</ref>, we list the amount of code we had to write in the manual and the generative approach for integrating Java and C#. We did not count generated code (in both approaches, we generated the parsers) and the code of the grammar specifications, which were publicly available. The generative approach reduces the need for code writing for Java to 11 percent and for C# to 3 percent of that in the manual approach.</p><p>In the manual approach, the granularity of composition is fixed. The adapter that translates a parse tree to an FST sets the granularity (i.e., decides which structural elements are represented as nonterminals and terminals) and is difficult and error-prone to write and change. In the generative approach, the attributes of the grammar define which structural elements are represented by nonterminals and terminals. Changing the attributes is a matter of minutes. This enabled us to experiment with different granularities.</p><p>Anyhow, if, for whatever reason, there is no grammar available for a particular language, the developer can resort to the manual approach and integrate an existing parser by means of an adapter. C++, with its inherently complex and ambiguous grammar, may be an example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.10">Composition Rules</head><p>Based on our experience, we have developed a number terminal composition rules and collected them in a library. These rules were reused in the integration of languages. Specifically, we have implemented composition rules for method overriding, grammar-rule overriding, constructor concatenation, field specialization, implements-list union, modifier specialization, replacement, and text-content concatenation (see Table <ref type="table" target="#tab_0">1</ref>). We can specify declaratively via grammar attributes for which kind of terminal we use which library composition rule, for example, compose=" JavaMethodOverriding" (see Section 2.2).</p><p>The interesting point is that we needed only a few rules, and the rules are very simple. The rule for method overriding is the most complex one. In Alloy-and later XML-we did not need specific composition rules at all. Superimposition and generic composition rules such as simple replacement sufficed in the case studies.</p><p>Another notable observation is that it was always sufficient to define a composition rule that is identical for all instances of a structural element of a language, for example, one rule that applies to all method bodies. Rules that differ from one element instance to another are possible but we refrained from implementing such rules as it would add considerable complexity and we did not encounter the need.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.11">Tool Reliability</head><p>Finally, writing adapter code and a pretty printer is errorprone. After the manual integration of the Java parser into the initial version of FSTCOMPOSER, we detected lots of errors caused by bugs in the adapter code and in the pretty printer or by misconceptions regarding the role of some structural elements in the FST. For example, in the manual approach, we forgot to represent inner Java classes as nonterminals. In the generative approach, we stumbled over this issue early since it was exposed by the grammar because we annotated grammars top-down, starting from the root production and, at some point, reached inner classes and interfaces. Another example is the merge of initializer blocks of Java classes. In the manual integration, we simply did not think of this option until needed in BERKELEY DB. When annotating the grammar top-down, it became obvious.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.12">Lessons Learned</head><p>Let us summarize the most significant observations we made and insights we gained during the integration of different languages and the composition of different software systems.</p><p>1. Superimposition is applicable to a wide range of code and noncode languages including objectoriented languages, functional languages, imperative languages, specification and modeling languages, and domain-specific languages. 2. Superimposition of FSTs scales to software projects of substantial size. 3. The time for preparing and annotating grammars is moderate compared to implementing adapters and pretty printers from scratch; varying the annotations varies the composition granularity and helps to cope with naming and ordering issues.</p><p>4. At fine granularities, elements often do not have unique identifiers (they are distinguished by the lexical order), which disallows superimposition. There are two solutions to this problem:</p><p>a. adjust the attributes of the corresponding grammar to make composition coarser-grained, and use expressive but possibly languagedependent composition rules to compose the corresponding elements properly; b. assign unique names manually, which may require changes to the language's syntax. 5. The order of program elements and thus of FST nodes may matter. This makes superimposition difficult because, in some situations, workarounds such as sandwiching are necessary. Usually, this problem arises at a fine granularity. A solution is to adjust the attributes of the corresponding grammar to coarsen the granularity such that the parent node of the ordered elements becomes a terminal and then to compose the ordered elements properly by applying a composition rule. 6. In practice, only a few composition rules are needed; they can be reused by different languages and follow even fewer rule patterns. 7. The generative approach leads to more reliable tools than the manual approach. Developing a combination of a parser, adapter, and pretty printer from scratch is tedious and error-prone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.13">Threats to Validity</head><p>Note that our study was not designed to draw quantitative conclusions based on descriptive statistics, for example, regarding the frequency and feasibility of using superimposition. Rather, our goal was to demonstrate the practicality and generality of our approach and to gain insight into issues such as granularity and scalability. Nevertheless, we would like to comment on possible threats to validity in this context. As always, the selection of sample systems may threaten validity. Hence, we deliberately chose a large sample size, including systems of different domains and written in different languages. While we do not expect that further sample systems will change the big picture, we cannot generalize our findings to all kinds of languages. However, our experience suggests a catalog of mandatory properties that a language must have to be supported by FEATUREHOUSE (Section 3.2). A further threat to validity is that all sample systems have been developed with superimposition in mind, albeit mostly for different purposes. It would be interesting to see how FEATUREHOUSE performs in scenarios designed for other composition approaches such as aspect weaving, but this would require considerable effort to avoid bias and an entirely different study design to answer an entirely different set of research questions outside the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXTENSIONS</head><p>After the initial development of FEATUREHOUSE, the integration of a number of languages, and various case studies, we made a set of extensions and improvements to FEATUREHOUSE, which were motivated by new requirements and which diverge partly from the original approach and architecture. This is the reason why we discuss them separately, which also reflects the history of the FEATURE-HOUSE project.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">XML-Based Languages</head><p>Beside the six languages we had integrated into FEATURE-HOUSE, we aimed at integrating XML and XML-based languages. XML is widely used to represent semistructured data, so supporting it would open FEATUREHOUSE for a whole new set of application scenarios. In a first attempt, we naively developed a grammar of XML in FEATUREBNF. We annotated the grammar such that XML elements were the nonterminal nodes and unstructured text content and element attributes were the terminal nodes. But we realized quickly that this approach would not succeed.</p><p>Integrating XML in general is not very interesting (and difficult due to missing names and relevant order). More interesting are XML-based languages, which are specified with XML Schema. XML Schema is used to define the grammar of an XML-based language. Popular examples are XHTML for Web sites and XMI for data exchange. To integrate a particular XML-based language into FEATURE-HOUSE, we need its specific grammar (specifying which types of elements have which types of attributes and are allowed in which places, etc.)-using the plain XML grammar only is not sufficient because it is too unspecific.</p><p>There are two ways to integrate the grammar of an XMLbased language, which we explain by means of XHTML. First, we can write a FEATUREBNF grammar that captures specifically the syntax of XHTML. This is a laborious task since the lexical structure of XML-based languages is quite special, and the resulting grammar becomes huge and very complex. XML Schema has been invented for describing the structure of XML-based languages, and there are various industrial-strength tools available. So, actually, XML Schema should play the role of FEATUREBNF. Second, we could extend FEATUREHOUSE such that new languages are plugged in not only using FEATUREBNF but also using annotated XML Schema. To this end, we have to enrich XML Schema with the possibility of annotating it with the attributes defining terminals and nonterminals. This way, we can describe the syntax of XHTML quite easily and annotate it like FEATUREBNF-based languages.</p><p>In Fig. <ref type="figure">10</ref>, we illustrate how we extended FEATURE-HOUSE to support XML-based languages. Technically, we used a combination of XML attributes (to represent grammar annotations) and XSLT (to generate FSTs). In Fig. <ref type="figure">11</ref>, we show an FST of a simple XHTML document that lists software companies; it consists of a head, a body, and an unnumbered list with two items. We define which elements are nonterminals and which are terminals (the corresponding XML elements are defined in an XML schema). Note that, while we use default names for the head and the body of an XHTML document (separated by ":"), we define additionally application-specific names for the list and the list items (separated by "::"). Technically, we define default names in the corresponding XML schema, as we illustrate in Fig. <ref type="figure" target="#fig_0">12</ref> for unordered lists, and we assign application-specific names via XSLT. Then, superimposition is performed as with any other language. We did not implement any composition rules specific to XML. Technical details are described elsewhere <ref type="bibr" target="#b29">[30]</ref>.</p><p>Based on the extended version of FEATUREHOUSE, we conducted a number of further case studies. In a first step, we integrated three languages: XHTML, XMI/UML, 4 and Ant for controlling build processes. Apart from the use of XML Schema, the integration is similar to that of FEATUREBNF-based languages. Note that, for Ant, we used a manual approach (cf. Section 3.9) as there is no static XML schema available.</p><p>Overall, we (de)composed six software systems, each of which is written in one of the three languages. Specifically, we decomposed the XHTML documentation of our GPL case study into features and composed them again depending on the feature selection. We decomposed the UML class, state, and sequence diagrams of the designs of  4. XMI is a general document format for data exchange. There is a special namespace for the representation of UML diagrams in XMI.</p><p>a phone system, an audio control system, a conference management system, and a gas boiler system into features and composed them in different combinations generating different designs. Of course, we did not write XMI/UML code manually, but used ArgoUML 5 as a UML editor, which was only possible because we did not extend the syntax of XMI/UML-a strength of our approach. Finally, we decomposed an Ant build script into features and composed them such that the resulting build scripts control the build process according to the feature selection. Table <ref type="table" target="#tab_2">5</ref> provides an overview of the XML-based case studies available on the FEATUREHOUSE Web site.</p><p>In summary, our findings were similar to those in the other case studies. Superimposition worked well at coarse and medium granularities at which XML elements have unique names and their order does not matter. At finer granularities, we had to assign names manually, which is especially easy in XML-based languages. For example, in the XHTML documentation of GPL, we assigned unique names to structural elements such as lists and list elements (using attribute fstname) to be able to extend them subsequently by other features.</p><p>A key insight is that our approach and architecture is general enough to integrate languages with a special syntax such as XML seamlessly. This makes it usable for a wide variety of composition problems outside conventional programming and specification languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Quantification and Weaving</head><p>Besides superimposition, other techniques for software composition have also been proposed, most notably composition by quantification and weaving <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b37">[38]</ref>, in which, when expressing changes, we specify declaratively the points at which the changes are applied. This idea has been explored in depth in work on multidimensional separation of concerns <ref type="bibr" target="#b6">[7]</ref>, aspect-oriented programming <ref type="bibr" target="#b39">[40]</ref>, adaptive programming <ref type="bibr" target="#b40">[41]</ref>, and strategic programming <ref type="bibr" target="#b41">[42]</ref>. Quantification is the ability to apply the same generic change in multiple places <ref type="bibr" target="#b39">[40]</ref>. In our approach, this means that we have to determine the locations in the FST where changes are to be applied. Applying the actual changes then corresponds to weaving in aspect orientation <ref type="bibr" target="#b39">[40]</ref>.</p><p>In the past, researchers identified complementary strengths and weaknesses of superimposition, on the one hand, and quantification and weaving on the other <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b42">[43]</ref>. To integrate composition by quantification and weaving in our approach, we introduce the concept of a modification. A modification consists of two parts:</p><p>1. Traversal specification. A characterization of the FST nodes that will be affected during composition. 2. Rewrite specification. A specification of how these nodes will be affected. A modification is performed by an FST traversal that determines the nodes to be modified and applies the necessary changes to them. A modification takes an FST as input and produces a modified FST as output. A traversal specification can yield a set of FST nodes as a result. This allows us to specify the modification of multiple nodes at once rather than each set member individually.</p><p>An advantage of composition by quantification and weaving is that it enables us to address parts of a program more generically than superimposition, which always is applied at a root of an FST. That is, we can locate the places of change by a pattern on FST nodes that the structural elements of a program have to satisfy to be affected by a modification (e.g., "all methods in package util whose names begin with set"). For example, a feature could add a new field to every Java class of a package, regardless of the name of the class. Naturally, such a modification can be applied to a wide variety of programs. With superimposition, we have to specify each single target node, even though we change them all in the same way, which can result in considerable code replication <ref type="bibr" target="#b37">[38]</ref>. Nevertheless, once the points of change are known, the two kinds of composition become equivalent. That is, once we have chosen a program, we can find an equivalent FST for every modification that, when superimposed with the program, produces the same results as applying the modification. Fig. <ref type="figure" target="#fig_8">13</ref> illustrates this similarity. In previous work, it has been shown that both kinds of composition have complementary strengths <ref type="bibr" target="#b37">[38]</ref>, so we include both of them in our model.</p><p>The extension of our FST model by support for quantification and weaving can be formulated again independently of a particular language. This illustrates that the FST model is very general. Another point is that, like  with superimposition, the FST variant of quantification and weaving helps to condense the essence of related programming language mechanisms such as aspect weaving, which we discuss in Section 5.2 in the context of feature algebra. However, language independence always impairs expressiveness and so composition by quantification and weaving is not able to model all mechanisms of fully fledged languages such as AspectJ. We get back to this issue when describing one of our case studies later in this section.</p><p>We have implemented support for quantification and weaving on top of FEATUREHOUSE. To select a set of target nodes, a programmer can specify patterns such as "Database. * : JavaMethod" for selecting all methods of class Database. The pattern language is inspired by AspectJ but allows modifications to quantify also over syntactic categories (i.e., FST node types). In Table <ref type="table" target="#tab_4">6</ref>, we provide an overview of the most important constructs of the pattern language by means of examples. Technical details of the language are described elsewhere <ref type="bibr" target="#b28">[29]</ref>.</p><p>There are two types of rewrites: a rewrite that defines which new elements are added to the nodes selected by the corresponding traversal, and a rewrite that defines which new elements are composed with the selected nodes via terminal composition. In the current implementation, the nodes are given in text form (i.e., the code of the element to add or compose with).</p><p>Technically, traversal and rewrite specifications are embedded in an XML document, as illustrated in Fig. <ref type="figure" target="#fig_2">14</ref>. Traversals and rewrites are straightforwardly implemented on top of FEATUREHOUSE's FST classes using visitors, pattern matching, and terminal composition rules.</p><p>In three case studies, we implemented modifications for four software systems of different sizes written in two different languages. Table <ref type="table" target="#tab_3">7</ref> lists relevant information on the case studies. The source code of all case studies is available on the FEATUREHOUSE Web site.</p><p>In a first study, we implemented several modifications that add new features to our GPL case study. To demonstrate the language independence of modifications, we implemented five new features with, in total, 12 modifications on top of the Java and a C# implementation of GPL (see Table <ref type="table">3</ref>). Although the quantification mechanism is language-independent, individual modifications are not. Hence, we created similar but different traversal and rewrite specifications in both languages.</p><p>In a second study, we implemented a generic tracing feature for BERKELEY DB. The tracing feature consists of four modifications. With over 300 classes, the four modifications affect large parts of the code base of BERKELEY DB. This indicates the high degree of genericity that can be achieved in the implementation of modifications as well as a certain scalability of our approach and tool. With superimposition, we would have to specify an FST consisting of extensions of all target classes.</p><p>In a third study, we explored to what extent it is possible to reimplement the aspects of AJHOTDRAW 6 with modifications. AJHOTDRAW is a Java/AspectJ framework for 2D graphics. Since modifications in FEATUREHOUSE support only a limited set of changes, we were not able to reimplement all of the 42 aspects. (Specifically, we were able to reimplement 23 aspects completely and 13 aspects partially. For example, the FST model does not capture dynamic crosscuts as implemented with cflow, which is due to the static nature of FSTs.) Overall, the three case studies demonstrate that quantification and weaving are indeed language-independent mechanisms that can be implemented as part of FEATURE-HOUSE. Although we did not aim at discussing the strengths and weaknesses of superimposition as compared to quantification and weaving, we observed that, especially for extensions that are identical for a number of program locations, modifications can decrease the amount of code replication considerably. We also found that, due to its syntactic nature, FST-based quantification and weaving is less expressive than control-flow-based mechanisms of aspect-oriented languages such as AspectJ. Apparently, there is a tradeoff between language independence and expressiveness. As control-flow-based language mechanisms are used rather infrequently <ref type="bibr" target="#b43">[44]</ref>, we decided in favor Examples Traversal Patterns along with Descriptions for Java FSTs Fig. <ref type="figure" target="#fig_2">14</ref>. A modification introducing a field to every class.</p><p>6. http://sourceforge.net/projects/ajhotdraw. of language independence, accepting the need for workarounds to mimic control-flow-based program extensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Summary</head><p>The two extensions of FEATUREHOUSE illustrate that the tool suite has considerable potential to be used in further application scenarios. Besides further composition operators and language families, we envision tools for visualization, documentation, and analysis, to name a few.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PERSPECTIVES</head><p>In this section, we present ongoing work that aims at improving software composition with FEATUREHOUSE. In particular, we discuss perspectives of the FEATUREHOUSE approach with regard to reliability, formalization, and automation based on our practical experience. Due to the lack of space, we must be more cursory here than in the previous sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Type System</head><p>An issue not addressed so far in FEATUREHOUSE is how we can assess correctness beyond syntactic and structural properties. As a challenge, we would like to guarantee that every composed system is well typed. In our database example, Latches refers to BaseDB. If the latter is not present in a composed system, Latches does not work properly and, due to dangling references, several type errors are reported for Latches at compile time. Specifically, there are two challenges of guaranteeing type correctness in FEATURE-HOUSE. First, FEATUREHOUSE is language-independent. That is, we cannot use a type system tailored to a particular language. We need an at least partially language-independent solution. Second, in many projects there is variability in how to compose composition units. We may select specific combinations of composition units, for example, from optional and alternative units, and produce different variants of a product, as is common in software product lines <ref type="bibr" target="#b44">[45]</ref>. Instead of type checking all possible combinations (an exponential number), we seek possibilities to type check individual composition units or closed sets of composition units in isolation.</p><p>With regard to the first challenge (language independence), we developed a formal calculus for software composition, called gDEEP <ref type="bibr" target="#b45">[46]</ref>. The key idea of gDEEP is to model the structure of a composition unit as a nested record independently of a particular language, which is a representation equivalent to FSTs. Furthermore, gDEEP comes with a set of well-formedness and subtyping rules that define uniformly how units are composed type-safely. However, these language-independent rules alone cannot ensure type safety. They have to be complemented with language-specific type rules. In fact, there are two parts to type checking: the language-independent part checking compositions at the level of the module structure (nonterminal and terminal structure) and the language-dependent part checking terms written in artifact languages (content of terminals). We have shown that it is feasible to combine gDEEP with different languages such as Java and Haskell <ref type="bibr" target="#b45">[46]</ref>. The distinction between a language-independent and a language-dependent part is analogous to the distinction between language-independent superimposition and language-dependent composition rules in FEATUREHOUSE, as illustrated in Fig. <ref type="figure" target="#fig_9">15</ref>. Hence, we are confident that a fully fledged type system based on gDEEP is not unrealistic.</p><p>With regard to the second challenge (type checking all composition units once, instead of all valid combinations), we developed a prototype of a language-independent checker, called FEATURETWEEZER, that takes a set of composition units and a description of their valid combinations (e.g., Latches requires BaseDB) and checks, without generating all valid products, whether there is any valid product that contains a type error <ref type="bibr" target="#b46">[47]</ref>. Currently, we concentrate on a specific class of type errors: dangling references. The reason for this limitation is that a fully fledged, language-independent type system is not available. To this end, we have extended the FST model by cross-tree edges that represent references between program elements.</p><p>A reference is a very general concept. Modeling references as cross-tree edges is a common denominator for most languages. For example, a Java method invocation (i.e., the language-independent part of method lookup) is represented by an edge from the caller to the callee; a JavaCC reference is represented by an edge from a nonterminal to the corresponding production rule. Based on this representation, FEATURETWEEZER checks a set of composition units once and guarantees, given that the check has been successful, that no valid combination contains a dangling reference. This saves especially much time if there are many valid combinations, such as in software product lines, and checking all of them individually is infeasible. The algorithm is a straightforward extension of previous work on type checking product lines <ref type="bibr" target="#b47">[48]</ref>, <ref type="bibr" target="#b48">[49]</ref>, <ref type="bibr" target="#b49">[50]</ref>, <ref type="bibr" target="#b50">[51]</ref>, adapted to a language-independent model. In a nutshell, FEATURE-TWEEZER checks, for every reference, whether the target node (e.g., the called method) is present in every valid product in which also the source node (the calling method) is present. To this end, FEATURETWEEZER uses propositional logic and SAT solver technology to check references. We envision to extend FEATURETWEEZER to a fully fledged type system based on the insight we gained with gDEEP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Feature Algebra</head><p>The gDEEP calculus is a first step toward formalizing and reasoning about feature composition. In a parallel line of work, we have been exploring how feature composition can be formalized using algebra <ref type="bibr" target="#b23">[24]</ref>. A motivation of this work is to raise the abstraction level further, from logic (as in gDEEP) to simple algebraic structures such as semigroups and semimodules. Again, the FST model is the foundation. To enable formal reasoning, the feature algebra describes features as algebraic terms and feature composition as a fundamental operation. Actually, there are several atomic operations that resemble different composition mechanisms, including superimposition and quantification and weaving. For example, feature BaseDB of Fig. <ref type="figure">1</ref> is represented as a sum (denoted with È) of introductions: Each introduction represents a path in the FST beginning from the root (prefixes represent paths; FST node types are not shown here for brevity). Superimposition is represented by adding new introductions to a given introduction sum. So, composing feature Latches with feature BasedDB is achieved by the sum of their introductions.</p><p>Quantification and weaving is represented by the operation of modification application (denoted with ). A modification m is applied to a sum i 1 È Á Á Á È i n of introductions by applying it to all of its summands, which is captured by a distributivity law:</p><formula xml:id="formula_0">m ði 1 È Á Á Á È i n Þ ¼ ðm i 1 Þ È Á Á Á È ðm i n Þ:</formula><p>Feature algebra is a means of exploring the design decisions we implemented in FEATUREHOUSE formally. Interestingly, we came to very similar conclusions as with our work on FEATUREHOUSE, especially with regard to the properties that are mandatory to make a language featureready (elements must have unique names, etc.). The feature algebra helps to analyze the effects of certain design decisions formally. For example, under which circumstances is feature composition associative, idempotent, or even commutative? We gained insight that was difficult to gain with tools like FEATUREHOUSE, which contains a lot of distracting functionality. For example, we found that composition by quantification and weaving results in a reduction of compositional flexibility compared to superimposition, which is counterintuitive since changes can be expressed more generically and declaratively than with superimposition. Supporting the full power of quantification (each composition unit may affect every other unit) leads to a composition operator that is not even associative. (We consider associativity an important property of composition.) Also, the algebra helped us to compare different composition tools such as AspectJ, CaesarJ, and FeatureC++ <ref type="bibr" target="#b23">[24]</ref>. For example, we found that, in principle, CaesarJ and FeatureC++ are similar, whereas AspectJ is different as it does not support (symmetric) superimposition. Feature algebra provides a means of extracting the essence of the difference.</p><p>In the long term, we intend to use the feature algebra not only to describe the mechanisms implemented in FEATURE-HOUSE, but also as intermediate language to specify the behavior of our composition tool. Software components are translated to algebraic expressions that can be manipulated based on algebraic laws. Algebraic optimization facilitates design optimization. That is, by manipulating featurealgebraic terms we manipulate programs and their designs. This approach is called architectural metaprogramming <ref type="bibr" target="#b51">[52]</ref> because it lifts metaprogramming (programs manipulate programs) to the architectural level (programs manipulate algebraic expressions that represent programs). Our work on feature algebra and FEATUREHOUSE is an important step toward realizing the vision of architectural metaprogramming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK</head><p>Although manifested and implemented differently, several languages provide support for superimposition of different kinds of artifacts, for example, Jiazzi <ref type="bibr" target="#b10">[11]</ref>, Classbox/J <ref type="bibr" target="#b13">[14]</ref>, Hyper/J <ref type="bibr" target="#b15">[16]</ref>, and Jak <ref type="bibr" target="#b5">[6]</ref> for Java, FeatureC++ <ref type="bibr" target="#b16">[17]</ref> for C++, Xak <ref type="bibr" target="#b18">[19]</ref> for XML, and others <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b52">[53]</ref>. In turn, superimposition is based on a large corpus of work on extending objects and classes noninvasively, for example, mixins <ref type="bibr" target="#b53">[54]</ref>, traits <ref type="bibr" target="#b54">[55]</ref>, virtual classes <ref type="bibr" target="#b55">[56]</ref>, and object composition <ref type="bibr" target="#b56">[57]</ref>. Work on superimposition builds on these approaches, generalizes them to different kinds of software artifacts, and applies extensions consistently to entire sets of entities.</p><p>While it has been noted that there is a unique core common to all composition mechanisms based on superimposition <ref type="bibr" target="#b5">[6]</ref>, researchers have not condensed the essence of superimposition into a general methodology and tool chain for software composition. A notable exception is the work of Batory et al. who, for the first time, stressed the language-independent nature of software composition by superimposition <ref type="bibr" target="#b5">[6]</ref>. Batory et al. have proposed the AHEAD model for superimposition, based on nested records, that was a starting point for our work. We have adapted and evolved the model toward our FST model. In contrast to AHEAD's nested records, the FST model distinguishes between terminals and nonterminals and presume a fixed order of elements. This and the tree structure place the FST model closer to the implementation level and allowed us to directly derive an implementation, which has not been done by AHEAD (each AHEAD tool for each language has been developed from scratch). So, we believe that our FST model captures the essence of superimposition more precisely. It is language-independent and automates the integration of new languages. We envision further algorithms to be integrated in FEATUREHOUSE that operate on FSTs and their algebraic representations to compose, visualize, optimize, and verify software. Thus, FEATUREHOUSE provides a general framework not only for different languages but also for different algorithms that aim at reasoning about software composition language-independently.</p><p>In the context of our FST model, quantification is modeled as a tree walk in which each node is visited and a predicate specifies whether the node is modified or not. Harrison et al. <ref type="bibr" target="#b57">[58]</ref> propose a sophisticated set of rewriting rules that are based on tree walks. Much like in our earlier work (manual approach; cf. Section 3.9) <ref type="bibr" target="#b24">[25]</ref>, they define a general, language-independent composition algorithm that parses and prints the code of artifacts by calling languagespecific plug-ins, which are analogous to the adapters and pretty printers in the manual approach. They applied their approach to Java (source and binary) and Ant.</p><p>Recent work in model composition <ref type="bibr" target="#b58">[59]</ref>, <ref type="bibr" target="#b59">[60]</ref>, <ref type="bibr" target="#b60">[61]</ref>, <ref type="bibr" target="#b61">[62]</ref> aims at developing a general framework for composing different kinds of models. Our approach can be applied to models (see Section 4.1), but aims also at nonmodeling languages. Like FEATUREHOUSE, Hyper/J, CaesarJ, Xak, and FeatureC++ support the combination of superimposition and quantification, but not independent of the language.</p><p>Software composition is related to the broad field of software merging, whose goal is to merge different versions of a software system not only at the module level but at all levels of granularity by using syntactic, semantic, and evolutionary information <ref type="bibr" target="#b31">[32]</ref>. Especially for the implementation of artifact-specific composition rules, superimposition can benefit from these developments.</p><p>In a parallel line of research, we have implemented a product-line tool, called CIDE, that allows a developer to decompose legacy software into a product line, type check all products of a product line, and visualize and resolve feature interactions <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b50">[51]</ref>. CIDE also pursues a generative approach of integrating new languages <ref type="bibr" target="#b62">[63]</ref> based on the same grammar format as in FEATUREHOUSE but using different attributes; initially, FEATUREBNF was developed for CIDE. CIDE uses the entire parse tree; thus, it does not require a mapping to terminals and nonterminals of an FST. The coordinated development of FEATURE-HOUSE and CIDE allows us to use grammars in both projects. CIDE has been used to decompose some of our case studies into superimposable units <ref type="bibr" target="#b63">[64]</ref>.</p><p>Delta-oriented programming is partially based on superimposition <ref type="bibr" target="#b64">[65]</ref>. A delta encapsulates all changes that a feature makes to a program. In contrast to our composition units, deltas can even specify the removal of elements of a given program. Hence, delta-oriented programming diverges from the concept of superimposition and also of quantification and weaving. Recently, it has been shown that the feature algebra can be embedded in an algebra that describes delta composition <ref type="bibr" target="#b65">[66]</ref>. It would be interesting to explore whether and how FEATUREHOUSE could be extended to support delta composition. For example, it seems quite straightforward to allow programmers to remove nodes from an FST, which is a basic delta operation.</p><p>Azanza et al. present a general approach to the incremental development of model-based software <ref type="bibr" target="#b61">[62]</ref>. They describe transformations as model deltas that, when composed, deliver a complete model. They establish a relationship between a metamodel and its corresponding delta metamodel, show how model deltas can be defined as model changes (additions), explain how deltas can be composed using domain-specific composition algorithms, and propose metamodel annotations to specify these algorithms. On the one hand, the key innovation is that the approach of Azanza et al. allows programmers to plug in new composition algorithms. On the other hand, the authors do not focus on language independence in the sense of FEATUREHOUSE.</p><p>Finally, we extended FEATUREHOUSE to also support, besides composition via superimposition and quantification and weaving, software merging in revision control systems <ref type="bibr" target="#b66">[67]</ref>. While this extension diverged in certain aspects substantially from the FEATUREHOUSE approach, we were able to build a merge engine on the FST model. This facilitated an easy integration of support for multiple languages (Java, C#, and Python) as well as the enrichment of the merge process with information (via grammar attributes) on how certain code fragments are merged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>We provided a coherent and complete view of our experience and insight gained with FEATUREHOUSE. This paper subsumes and extends our previous work on language-independent, automated software composition <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref>. Compared to previous work, we report on experience in a substantial number of case studies, a diverse selection of languages, a number of extensions of our approach, and perspectives that arise from our holistic and retrospective view on the FEATUREHOUSE approach.</p><p>FEATUREHOUSE is an approach and a set of accompanying tools for language-independent software composition.</p><p>In FEATUREHOUSE, we model software artifacts by tree structures and composition by tree superimposition as well as tree traversals and rewrites. The FST model abstracts from the specifics of a particular programming language or tool. Any reasonably structured software artifact that can be represented as an FST can be composed by our approach.</p><p>FSTGENERATOR generates, on the basis of an attribute grammar, an FST representation and a pretty printer for a given language. FSTCOMPOSER composes FSTs generically via both superimposition and quantification and weaving. From the integration of various languages (including programming, specification and modeling, and domainspecific languages) and the application to several programs of different sizes, written in different languages, we learned much about our approach and the properties and problems of languages to be integrated. In particular, we found that the composition granularity is influenced by the language's syntactic structure. A fine granularity is expressive but may be infeasible because of naming and ordering issues. Composing artifacts at a coarser grain alleviates these problems but decreases expressiveness. The generative approach of FEATUREHOUSE allows developers to easily adjust the granularity to find a proper balance per language.</p><p>In the future, we would like to extend FEATUREHOUSE by further languages, composition operators, a type system, and tools, for example, for visualization, documentation, and analysis. Our work on feature algebra and on languageindependent type checking is a foundation for this endeavor.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>Fig. 1. Java code and FST of the artifact BaseDB, taken from the BERKELEY DB case study.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The architecture of FEATUREHOUSE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig.4. An excerpt of a simplified Java grammar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Fig. 5. An excerpt of a simplified Java grammar with annotations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .Fig. 8 .</head><label>78</label><figDesc>Fig. 7. Annotating a method declaration with a name and a composition rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 9 .</head><label>9</label><figDesc>Fig.9. Composing data type declarations via superimposition, taken from the ARITH case study (no new composition rules are needed).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10 .Fig. 11 .</head><label>1011</label><figDesc>Fig. 10. The extended architecture of FEATUREHOUSE with support for XML-based languages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 12 .</head><label>12</label><figDesc>Fig.<ref type="bibr" target="#b11">12</ref>. Annotating XML schema to treat unordered lists as nonterminals with application-specific names.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Dual notions of composition: superimposition (top) and quantification and weaving (bottom).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 15 .</head><label>15</label><figDesc>Fig.<ref type="bibr" target="#b14">15</ref>. The interplay between the language-independent and languagedependent parts of type checking in gDEEP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE 1 Composition</head><label>1</label><figDesc>Rules Implemented in FEATUREHOUSE</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 2</head><label>2</label><figDesc>Overview of the Languages Integrated in FEATUREHOUSE with FSTGENERATOR</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 5</head><label>5</label><figDesc>Overview of the XML-Based Case Studies</figDesc><table /><note><p><p>5.</p>A graphical UML editor: http://argouml.tigris.org/.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 7</head><label>7</label><figDesc>Overview of Case Studies on Quantification and Weaving</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE 6</head><label>6</label><figDesc></figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Although AHEAD provides a language-independent model based on nested records, the support for different languages has been implemented for each language individually from scratch (see Section 6).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Sandwiching is the process of dividing artifacts into parts to be able to add something in between<ref type="bibr" target="#b38">[39]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors are grateful to Don Batory for helpful comments on earlier drafts of this paper, Sebastian Scharinger and Alexander von Rhein for implementing the Java and C# parsers of FSTCOMPOSER, Stefan Boxleitner for integrating quantification and weaving, Jens Do ¨rre for adding XMLbased languages, Marko Rosenmu ¨ller and Norbert Siegmund for their support in developing the C grammar, Wolfgang Scholz for implementing FEATURETWEEZER, and the anonymous reviewers of this article and earlier conference versions. Apel's and Lengauer's work is supported by the German Research Foundation (DFG-AP 206/2, AP 206/4, and LE 912/13). Ka ¨stner's work was supported by the European Research Council (ERC #203099) while he was working as a postdoctoral researcher in the Programming Language Group of Klaus Ostermann at Philipps University Marburg, Germany.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>. For more information on this or any other computing topic, please visit our Digital Library at www.computer.org/publications/dlib.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Combination of Inheritance Hierarchies</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Harrison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="25" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Compositional Approach to Superimposition</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bouge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Francez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Int&apos;l Symp. Principles of Programming Languages</title>
		<meeting>15th Int&apos;l Symp. Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="240" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Superimposition Control Construct for Distributed Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="337" to="356" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Mixin Layers: An Object-Oriented Implementation Technique for Refinements and Collaboration-Based Designs</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Smaragdakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Software Eng. and Methodology</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="215" to="255" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Feature-Oriented Programming: A Fresh Look at Objects</title>
		<author>
			<persName><forename type="first">C</forename><surname>Prehofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Conf. Object-Oriented Programming</title>
		<meeting>European Conf. Object-Oriented Programming</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="419" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Scaling Step-Wise Refinement</title>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sarvela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rauschmayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="355" to="371" />
			<date type="published" when="2004-06">June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">N Degrees of Separation: Multi-Dimensional Separation of Concerns</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tarr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sutton</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st Int&apos;l Conf. Software Eng</title>
		<meeting>21st Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="107" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Variability Management with Feature-Oriented Programming and Aspects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mezini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int&apos;l Symp. Foundations of Software Eng</title>
		<meeting>12th Int&apos;l Symp. Foundations of Software Eng</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="127" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Superimpositions and Aspect-Oriented Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sihman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer J</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="529" to="541" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Super-Imposition: A Component Adaptation Technique</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="257" to="273" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Aspect-Oriented Programming with Jiazzi</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mcdirmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hsieh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int&apos;l Conf. Aspect-Oriented Software Development</title>
		<meeting>Second Int&apos;l Conf. Aspect-Oriented Software Development</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="70" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scalable Extensibility via Nested Inheritance</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nystrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>19th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="99" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Scalable Component Abstractions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>20th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="41" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Classbox/J: Controlling the Scope of Change in Java</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bergel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ducasse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>20th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="177" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Eliminating Distinctions of Class: Using Prototypes to Model Virtual Classes</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hutchins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>21st Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="1" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Hyper/J: Multi-Dimensional Separation of Concerns for Java</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tarr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22nd Int&apos;l Conf. Software Eng</title>
		<meeting>22nd Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="734" to="737" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">FeatureC++: On the Symbiosis of Feature-Oriented and Aspect-Oriented Programming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenmu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Fourth Int&apos;l Conf. Generative Programming and Component Eng</title>
		<imprint>
			<biblScope unit="page" from="125" to="140" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Access Control in Feature-Oriented Programming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liebig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhlemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming, special issue on feature-oriented software development</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="174" to="187" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On Refining XML Artifacts</title>
		<author>
			<persName><forename type="first">F</forename><surname>Anfurrutia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Dı</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Trujillo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Seventh Int&apos;l Conf. Web Eng</title>
		<imprint>
			<biblScope unit="page" from="473" to="478" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Subject-Oriented Design: Towards Improved Alignment of Requirements, Design, and Code</title>
		<author>
			<persName><forename type="first">S</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tarr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>14th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="325" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mapping Features to Models: A Template Approach Based on Superimposed Variants</title>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Antkiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fourth Int&apos;l Conf. Generative Programming and Component Eng</title>
		<meeting>Fourth Int&apos;l Conf. Generative Programming and Component Eng</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="422" to="437" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Lightweight Scalable Components</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kamina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tamai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Sixth Int&apos;l Conf. Generative Programming and Component Eng</title>
		<imprint>
			<biblScope unit="page" from="145" to="154" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Lifting Transformational Models of Product Lines: A Case Study</title>
		<author>
			<persName><forename type="first">G</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lavender</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First Int&apos;l Conf. Model Transformation</title>
		<meeting>First Int&apos;l Conf. Model Transformation</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="16" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An Algebraic Foundation for Automatic Feature-Based Program Synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1022" to="1047" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Superimposition: A Language-Independent Approach to Software Composition</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Seventh Int&apos;l Symp. Software Composition</title>
		<imprint>
			<biblScope unit="page" from="20" to="35" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An Overview of CaesarJ</title>
		<author>
			<persName><forename type="first">I</forename><surname>Aracic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Gasiunas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mezini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Aspect-Oriented Software Development I</title>
		<imprint>
			<biblScope unit="volume">3880</biblScope>
			<biblScope unit="page" from="135" to="173" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">FeatureHouse: Language-Independent, Automated Software Composition</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 31st. IEEE Int&apos;l Conf. Software Eng</title>
		<meeting>31st. IEEE Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="221" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Feature (De)Composition in Functional Programming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Eight Int&apos;l Conf. Software Composition</title>
		<imprint>
			<biblScope unit="page" from="9" to="26" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Language-Independent Quantification and Weaving for Feature Composition</title>
		<author>
			<persName><forename type="first">S</forename><surname>Boxleitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eight Int&apos;l Conf. Software Composition</title>
		<meeting>Eight Int&apos;l Conf. Software Composition</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="45" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Feature-Oriented Composition of XML Artifacts</title>
		<author>
			<persName><forename type="first">J</forename><surname>Do ¨rre</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Informatics and Math., Univ. of Passau</orgName>
		</respStmt>
	</monogr>
	<note>master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Granularity in Software Product Lines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhlemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th Int&apos;l Conf. Software Eng</title>
		<meeting>30th Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="311" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A State-of-the-Art Survey on Software Merging</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="449" to="462" />
			<date type="published" when="2002-05">May 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Abstract Syntax from Concrete Syntax</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wile</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th Int&apos;l Conf. Software Eng</title>
		<meeting>19th Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="472" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Refinements and Multi-Dimensional Separation of Concerns</title>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sarvela</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Ninth European Software Eng. Conf. and the Int&apos;l Symp. Foundations of Software Eng</title>
		<meeting>Ninth European Software Eng. Conf. and the Int&apos;l Symp. Foundations of Software Eng</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="48" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Integrating Independent Components with On-Demand Remodularization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mezini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>17th Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="52" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Component Software: Beyond Object-Oriented Programming</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szyperski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gruntz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Murer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Addision-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Evaluating Support for Features in Advanced Modularization Technologies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lopez-Herrejon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th European Conf. Object-Oriented Programming</title>
		<meeting>19th European Conf. Object-Oriented Programming</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="169" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Aspectual Feature Modules</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="162" to="180" />
			<date type="published" when="2008-04">Mar./Apr. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Designing Software for Ease of Extension and Contraction</title>
		<author>
			<persName><forename type="first">D</forename><surname>Parnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Int&apos;l Conf. Software Eng</title>
		<meeting>Third Int&apos;l Conf. Software Eng</meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="264" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Modeling Crosscutting in Aspect-Oriented Mechanisms</title>
		<author>
			<persName><forename type="first">H</forename><surname>Masuhara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Conf. Object-Oriented Programming</title>
		<meeting>European Conf. Object-Oriented Programming</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="2" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Traversals of Object Structures: Specification and Efficient Implementation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lieberherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Patt-Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Orleans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="370" to="412" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Strategic Programming Meets Adaptive Programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>La ¨mmel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int&apos;l Conf. Aspect-Oriented Software Development</title>
		<meeting>Second Int&apos;l Conf. Aspect-Oriented Software Development</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="168" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Large-Scale AOSD for Middleware</title>
		<author>
			<persName><forename type="first">A</forename><surname>Colyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Int&apos;l Conf. Aspect-Oriented Software Development</title>
		<meeting>Third Int&apos;l Conf. Aspect-Oriented Software Development</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="56" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">How AspectJ is Used: An Analysis of Eleven AspectJ Programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Object Technology</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="117" to="142" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Northrop</surname></persName>
		</author>
		<title level="m">Software Product Lines: Practices and Patterns</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A Calculus for Uniform Feature Composition</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hutchins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="33" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Language-Independent Reference Checking in Software Product Lines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Scholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Second Int&apos;l Workshop Feature-Oriented Software Development</title>
		<imprint>
			<biblScope unit="page" from="65" to="71" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Safe Composition of Product Lines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kitchin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Sixth Int&apos;l Conf. Generative Programming and Component Eng</title>
		<imprint>
			<biblScope unit="page" from="95" to="104" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Fitting the Pieces Together: A Machine-Checked Model of Safe Composition</title>
		<author>
			<persName><forename type="first">B</forename><surname>Delaware</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Seventh European Software Eng. Conf. and the Int&apos;l Symp. Foundations of Software ng</title>
		<meeting>Seventh European Software Eng. Conf. and the Int&apos;l Symp. Foundations of Software ng</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="243" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Type Safety for Feature-Oriented Product Lines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automated Software Eng</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="251" to="300" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Type Checking Annotation-Based Product Lines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Thu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Software Eng. and Methodology</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="39" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Program Refactorings, Program Synthesis, and Model-Driven Design (Keynote)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Compiler Construction</title>
		<meeting>Int&apos;l Conf. Compiler Construction</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="156" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Composing Crosscutting Concerns Using Composition Filters</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bergmans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aksit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="51" to="57" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Classes and Mixins</title>
		<author>
			<persName><forename type="first">M</forename><surname>Flatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamurthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 25th Int&apos;l Symp. Principles of Programming Languages</title>
		<meeting>25th Int&apos;l Symp. Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="171" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Traits: A Mechanism for Fine-Grained Reuse</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ducasse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Scha ¨rli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wuyts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Black</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="331" to="388" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Virtual Classes: A Powerful Mechanism in Object-Oriented Programming</title>
		<author>
			<persName><forename type="first">O</forename><surname>Madsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moller-Pedersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>Int&apos;l Conf. Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="397" to="406" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Delegation by Object Composition</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Bono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Venneri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="992" to="1014" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">General Composition of Software Artifacts</title>
		<author>
			<persName><forename type="first">W</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tarr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fifth Int&apos;l Symp. Software Composition</title>
		<meeting>Fifth Int&apos;l Symp. Software Composition</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="194" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">A Vision for Management of Complex Models</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pottinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="55" to="63" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Merging Models with the Epsilon Merging Language (EML)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Polack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Ninth Int&apos;l Conf. Model-Driven Eng., Languages, and Systems</title>
		<meeting>Ninth Int&apos;l Conf. Model-Driven Eng., Languages, and Systems</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="215" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Understanding and Improving UML Package Merge</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dingel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Diskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software and Systems Modeling</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="443" to="467" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Domain-Specific Composition of Model Deltas</title>
		<author>
			<persName><forename type="first">M</forename><surname>Azanza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Diaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Trujillo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Int&apos;l Conf. Model Transformation</title>
		<meeting>Third Int&apos;l Conf. Model Transformation</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="16" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Guaranteeing Syntactic Correctness for all Product Line Variants: A Language-Independent Approach</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Trujillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhlemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Objects, Models, Components, Patterns</title>
		<meeting>Int&apos;l Conf. Objects, Models, Components, Patterns</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="174" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">A Model of Refactoring Physically and Virtually Separated Features</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhlemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Eight Int&apos;l Conf. Generative Programming and Component Eng</title>
		<imprint>
			<biblScope unit="page" from="157" to="166" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Delta-Oriented Programming of Software Product Lines</title>
		<author>
			<persName><forename type="first">I</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Bono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Damiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tanzarella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int&apos;l Software Product Line Conf</title>
		<meeting>14th Int&apos;l Software Product Line Conf</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="77" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Abstract Delta Modeling</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Helvensteijn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Schaefer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Ninth Int&apos;l Conf. Generative Programming and Component Eng</title>
		<imprint>
			<biblScope unit="page" from="13" to="22" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Semistructured Merge: Rethinking Merge in Revision Control Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liebig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Brandl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ka ¨stner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th European Software Eng. Conf. and the Int&apos;l Symp. Foundations of Software Eng</title>
		<meeting>19th European Software Eng. Conf. and the Int&apos;l Symp. Foundations of Software Eng</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="190" to="200" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
