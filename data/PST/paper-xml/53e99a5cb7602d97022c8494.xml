<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="de">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Metamodel</forename><surname>Metrics</surname></persName>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">92BAAB3244F70AD28FFAD06BC85AD87A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:08+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>&lt; Property</term>
					<term>Label</term>
					<term>Property.assoc == null …&gt; Arrow</term>
					<term>Label Node Class Property</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Danksagung</head><p>Diese Arbeit wäre ohne die Unterstützung und Hilfe von KollegInnen, BetreuerInnen, Fre-undInnen und Familie nicht möglich gewesen. Mein besonderer Dank gilt meinen beiden BetreuerInnen Gerti Kappel und Christian Huemer die mich bei der Wahl des Themas und der Durchführung der Dissertation unterstützt haben. Meinen Kollegen Manuel Wimmer und Horst Kargl möchte ich für die zahlreichen Diskussionen danken, die immer wieder spannende Ergebnisse geliefert haben. Manuel Wimmer möchte ich besonders für die Idee zu dem Thema dieser Dissertation danken.</p><p>Meinen beiden Diplomanden Abraham und Gerald Müller gilt mein Dank für ihre Unterstützung bei der Implementierung eines Prototyps.</p><p>Natürlich möchte ich mich auch ganz besonders bei meinen Eltern Eva und Norbert Strommer sowie meinen Freunden bedanken die immer ein offenes Ohr für meine Anliegen und Probleme hatten. Und zuletzt möchte ich noch meinem Freund Jürgen Falb für seine Geduld und Hilfsbereitschaft in den letzten Jahren danken. i In this chapter we give an overview of the research and work that is related most in the context of this thesis. The two major fields of related work are already visible in the title of the thesis -Model Transformation By-Example. We first focus on model transformation approaches in general. Next we present tried and tested work of common by-example approaches.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="de">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract</head><p>Model-Driven Engineering (MDE) is getting more and more attention as a viable alternative to the traditional code-centric software development paradigm. With its progress, several model transformation approaches and languages have been developed in the past years. Most of these approaches are metamodel-based and, therefore, require knowledge of the abstract syntax of the modeling languages, which in contrast is not necessary for defining domain models using the concrete syntax of the respective languages.</p><p>Based on the by-example paradigm, we propose Model Transformation By-Example (MTBE), to cope with shortcomings of current model transformation approaches. Our approach allows the user to define semantic correspondences between concrete syntax elements with the help of special mapping operators. This is more user-friendly than directly specifying model transformation rules and mappings on the metamodel level. In general, the user's knowledge about the notation of the modeling language and the meaning of mapping operators is sufficient for the definition of model transformations. The definition of mapping operators is subject to extension, which has been applied for the definition of mapping operators for the structural and the behavioral modeling domain. However, to keep things transparent and user-friendly, only a minimal set of mapping operators has been implemented. To compensate for the additional expressiveness inherent in common model transformation languages we apply reasoning algorithms on the models represented in concrete as well as in abstract syntax and on the metamodels generating adequate transformation code.</p><p>In order to fulfill the requirements for a user-friendly application of MTBE, proper tool support and methods to guide the mapping and model transformation generation tasks are a must. Hence, a framework for MTBE was designed that builds on state-of-the-art MDE tools on the Eclipse platform, such as the Eclipse Modeling Framework (EMF), the Graphical Modeling Framework (GMF), the Atlas Transformation Language (ATL), and the Atlas Model Weaver (AMW). The decision to base our implementation on top of Eclipse and further Eclipse projects was driven by the fact, that there is a huge community we can address with our MTBE plug-in.</p><p>Finally, we evaluate our approach by means of two case studies covering the structural as well as behavioral modeling language domain.</p><p>iii</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kurzfassung</head><p>Die modellgetriebene Softwareentwicklung kann immer mehr als ernst zu nehmende Alternative zur klassischen Softwareentwicklung angesehen werden. Im Zuge des Entwicklungsprozesses der modellgetriebenen Softwareentwicklung sind in den letzten Jahren auch zahlreiche Methoden zur Modelltransformation entwickelt worden. Viele dieser Ansätze basieren auf den Metamodellen der jeweiligen Modellierungssprachen und setzen daher ein Wissen über die abstrakte Syntax voraus, das für die Modellierung von Modellen mit eben diesen Sprachen nicht notwendig ist.</p><p>Aufgrund dieser Einschränkungen heutiger Modelltransformationsansätze entstand die Idee zu Model Transformation By-Example (MTBE), welches auf beispielgetriebenen Methoden basiert. Dieser Ansatz ermöglicht BenutzerInnen mit geeigneten Mappingoperatoren semantische Beziehungen zwischen Elementen, definiert in einer konkreten Syntax, zu spezifizieren. Auf diese Weise lassen sich Modelltransformationen und semantische Beziehungen benutzerfreundlicher spezifizieren als dies auf der Metamodellebene der Fall wäre. Das Wissen der BenutzerInnen über die konkrete Syntax einer Modellierungssprache und die Bedeutung der Mappingoperatoren genügen in den meisten Fällen, um Modelltransformationen zu erzeugen. Der MTBE-Ansatz unterstützt die Spezifikation von weiteren Mapping-Operatoren. Im Rahmen der Dissertation wurden Mapping-Operatoren für Sprachen zur Strukturmodellierung und zur Verhaltensmodellierung entwickelt. Die Anzahl der Mappingoperatoren wurde bewusst niedrig gehalten, um die Überschaubarkeit und Benutzerfreundlichkeit nicht zu gefährden. Der dadurch entstandene Verlust an Ausdrucksstärke wurde durch Reasoningalgorithmen, sowohl auf der Metamodell-als auch auf der Modellebene größtenteils kompensiert, um ausführbaren Transformationscode generieren zu können.</p><p>Neben der konzeptuellen Definition von MTBE ist für den Nachweis der Praxistauglichkeit auch eine Werkzeugunterstützung gefordert, welche die Möglichkeit zum Modellmapping und zur Generierung von Transformationscode bietet. Daher wurde ein Framework konzipiert und umgesetzt, das auf bewährten Modellierungsanwendungen der Eclipse-Umgebung aufbaut. Zu diesen Anwendungen zählen etwa das Eclipse Modeling Framework (EMF), das Graphical Modeling Framework (GMF), die Atlas Transformation Language (ATL) und der Atlas Model Weaver (AMW).</p><p>Schließlich wurde MTBE anhand von zwei Fallstudien getestet und evaluiert. Diese beiden Fallstudien decken sowohl Struktur-als auch Verhaltensmodellierung ab. v </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>List of Figures</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Motivation</head><p>Software development is a complex task. Developers have tried to overcome complexities by different kinds of methodologies (e.g., object oriented programming, domain specific languages, patterns, etc.) and technologies (e.g., CASE-Tools, XML, etc.). One of the latest paradigms is Model-Driven Engineering (MDE) <ref type="bibr">[8]</ref>, which aims at defining a framework for modeling, metamodeling and model transformation. Model transformations are used to transform between any kinds of models, no matter what domain they cover, as long as these models fulfill the requirements of a specific model transformation approach. In general, corresponding modeling language definitions in form of metamodels are required in a model transformation process. How model transformation approaches work is best explained fol- </p><note type="other">Figure 1</note><p>.1: Model transformation pattern according to <ref type="bibr" target="#b33">[21]</ref>.</p><p>lowing the basic model transformation pattern shown in Figure <ref type="figure" target="#fig_0">1</ref>.1. First, we distinguish between layers M1 and M2 introduced by the OMG in <ref type="bibr" target="#b80">[68]</ref>. M1 contains the models, which are instances of metamodels that reside on M2. Second, transformation rules between so called source and target metamodel are specified. Third, a transformation engine reads one source model conforming to the source metamodel and writes a target model conforming</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 1 Introduction</head><p>to the target metamodel. A model can be transformed into a semantically corresponding model (horizontal transformation) or into a model on another level of abstraction (vertical transformation). This thesis focuses on horizontal model transformations that are used in various metamodel-based tool integration scenarios, e.g., exchanging models in different languages via model transformations. Horizontal model transformations are also considered by a special kind of MDE, namely Model-Driven Architecture (MDA) <ref type="bibr" target="#b76">[64]</ref>, an Object Management Group (OMG) initiative. MDA delivers concepts for metamodels representing both an abstract syntax of the corresponding modeling language and also a data structure for storing models in repositories. However, this implementation specific focus does not result in a user-friendly approach to model transformations due to two major reasons: Concept Hiding. First, metamodels are not only based on first class concepts, but usually include constraints that are hidden in textual descriptions or, in best case, as formal constraint in special section. However, non-first class, i.e. hidden, concepts are available for notation purposes. For example, in the core of the UML metamodel (defined in the UML Infrastructure <ref type="bibr" target="#b77">[65]</ref>) the concept attribute is hidden in the class Property. Properties can only be attributes, if the property has a relationship owningClass to a class. When the user has to define model transformations these hidden concepts must be re-engineered and expressed in complex rules by a manual process. Metamodel vs. Model. Second, defining model transfromations using state-of-the-art technologies like ATL (ATLAS Transformation Language) <ref type="bibr" target="#b53">[40]</ref> require a software engineer or designer to be familiar with metamodeling concepts. Furthermore, she must be aware of language specialties in the abstract syntax (AS) and how these specialties are mapped to the model using the concrete syntax (CS). In most cases a software engineer is neither an expert in metamodeling nor in specifying the CS of a modeling language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Existing Work</head><p>Model Transformation Approaches. Model transformation is considered as one of the key technologies in MDE. Therefore, a lot of research efforts address this subject to expedite the dissemination of the MDE paradigm. A good overview of current model transformation technologies is given in <ref type="bibr" target="#b33">[21]</ref>. All of these approaches are based on metamodels. As a consequence, the user needs to be experienced in metamodeling. In addition, she must understand the metamodels involved in a transformation scenario in order to specify transformation rules with common model transformation approaches such as ATL and graph transformation approaches. This complexity is shown on top of Figure <ref type="figure" target="#fig_0">1</ref>.2. The three big question marks indicate the places where a lack of knowledge is commonly prevalent. This lack has then to be compensated by rarely available specialists knowing the corresponding modeling languages by hard. To summarize, the definition of model transformations is a complex and time consuming task since the user needs detailed know-how in the following 1.3 Contribution of the Thesis three areas:</p><p>1. Metamodeling in general, i.e., to know the concepts used in the metamodeling language.</p><p>2. A sound understanding of the modeling languages and of their concepts.</p><p>3. An excellent command of the transformation language being used for the purpose of model transformation.</p><p>By-Example Approaches. By-Example approaches have a long tradition and originated in the early 1970ies <ref type="bibr" target="#b32">[20]</ref>. These approaches promote the use of examples in one way or the other to overcome complexity of selected problems in the field of computer science. The most prominent by-example approach is definitely Query By Example (QBE) <ref type="bibr" target="#b105">[93]</ref>, which is presented in detail in Section 2.4. The basic idea of QBE is using a simple notation for defining queries on database tables. The notation is based on a table-like visualization of a database schemes, where sample instances are defined by the user. The user's knowledge of notation elements and their meaning is reused by using such a language design approach. It is rather is to learn the additional semantics for the QBE language needed for specifying proper queries compared to learning the fairly complex declarative query language SQL. Besides QBE we present several other example favoring approaches in Section 2.4. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Contribution of the Thesis</head><p>In this thesis we propose Model Transformation By-Example (MTBE) following the idea of the by-example approaches. MTBE emerged during the realization of the ModelCVS project <ref type="bibr" target="#b55">[42]</ref> that fosters model and tool integration by means of metamodel mapping and model Chapter 1 Introduction transformation. In contrast to MTBE, the ModelCVS approach focuses on the metamodels and does not take the models and their concrete syntax into consideration. By our MTBE approach we allow the definition of inter-model mappings representing semantic correspondences between concrete domain models (M1 layer). This is more user-friendly than directly specifying model transformation rules based on metamodels (M2 layer). This advantage of MTBE is illustrated at the bottom of Figure <ref type="figure" target="#fig_0">1</ref>.2 where we show two models as instances of two metamodels. The lights in the bubbles indicate that the user knows how to correctly interpret the concrete syntax elements. It follows that the user is able to define adequate mappings between these CS elements. The inter-model mappings are used to generate the transformation rules in by-example manner, taking into account the existing mapping (notation) between abstract and concrete syntax elements. The notation includes the constraints how elements from the abstract syntax (metamodel) are related to the concrete syntax. By applying MTBE to the Eclipse Modeling Framework (EMF) <ref type="bibr">[12]</ref> and to the Graphical Modeling Framework (GMF) <ref type="bibr" target="#b36">[23]</ref> it is possible to reuse the already available constraints to derive transformation rules expressed in ATL. The user's knowledge about the CS of the modeling language is sufficient for the definition of semantically corresponding model transformations. Hence, neither a detailed understanding about the abstract syntax (metamodel) nor about the notation are required. However, it is essential to align two models of the the same problem domain, to automatically derive the transformation rules.</p><p>This leads to the following hypothesis:</p><p>It is feasible to develop model transformations in a by-example manner by:</p><p>1. Defining a conceptual foundation for MTBE.</p><p>2. Building a solid prototype on these conceptual foundations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Evaluating MTBE by means of case studies.</head><p>We identified two major contributions of this thesis: Leveraging Model Transformations. Our MTBE approach helps to ease the production of transformation code by (semi-)automatically generating ATL rules from mappings on the model layer. Although we cannot provide a solution for fully-automatically code generation, we deliver a MTBE process that helps the software engineer safe a considerable amount of time. Especially, the ATL code generation promotes the generation of declarative code and does not mix it with imperative code fragments. This increases readability.</p><p>Implementing MTBE. In the literature we find two conceptual approaches to MTBE, which have been developed around the same time. The first one has been developed by ourselves <ref type="bibr" target="#b101">[89]</ref>, the other one has been proposed by Varro <ref type="bibr" target="#b96">[84]</ref>. At the time of starting the thesis no tool support and framework design was available. In this thesis we present a framework design and a functioning proof-of-concept prototype that follows our conceptual approach. It allows the definition of model mappings, the reasoning on these mappings In Figure <ref type="figure" target="#fig_0">1</ref>.3 we provide an overview of the research topics addressed in this thesis. By this figure it becomes evident that the thesis is structured according to the arguments presented in the hypothesis. Each of the five colored blocks is discussed in its own chapter. The figure has to be read from top to bottom because lower concpets in an upper area are further elaborated in a lower area. In addition, dashed gray lines with arrows show strong dependencies from one part of the thesis to another one.</p><p>On top of this figure we show technologies and approaches that significantly influenced our MTBE approach. An overview of these technologies and approaches is given in Chapter 3. We present work on metamodeling by means of Ecore, metamodel heterogeneities, refactoring patterns for metamodels, and our model metric for measuring the explicitness of metamodels. There is a strong dependency between heterogeneities and both, model metrics and refactoring because the latter two specifically face the problem of the former one.</p><p>Chapter 4 MBTE basics represents the core of our MTBE approach. We address the con-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 1 Introduction</head><p>ceptual MTBE process consisting of five different steps, each of which is discussed in subsequent sections.</p><p>Based on the basic concepts of MTBE, we discuss advanced extensions in Chapter 5. We give a detailed description of advanced concepts and useful extensions in order to maximize the amount of code, which is automatically generated. These concepts comprise, for example, special reasoning algorithms to cope with troublesome metamodel heterogeneities. Hence, our findings about heterogeneities play a major role for the contribution of this chapter.</p><p>The second major contribution of this thesis , i.e., the implementation of MTBE, is described in Chapter 6. We present employed technologies and frameworks that provide the basis for our MTBE framework. Furthermore, we explain the implementation aspects in detail. In Chapter 7 we elaborate on two case studies having proved the advantages of our approach. This chapter also covers a critical reflection of our work on MTBE. This critical reflection also leads to directions for future work and enhancements for our implementation being discussed in Chapter 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 2</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>State of the Art</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Introduction to Model Transformation</head><p>A key technique for automatic management of modeling artifacts are model transformations <ref type="bibr" target="#b66">[54]</ref>. Several model transformation approaches and languages have been proposed in the past six years <ref type="bibr" target="#b33">[21]</ref>. Czarnecki and Helsen provide a very comprehensive and detailed categorization of various model transformation approaches. Following <ref type="bibr" target="#b33">[21]</ref> we define the basic concepts of model transformation as follows:</p><p>• A source model that conforms to a given source metamodel.</p><p>• A target model that conforms to a given target metamodel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 2 State of the Art</head><p>• Some sort of transformation definition that is based on the source and target metamodels.</p><p>• A transformation engine that executes the transformation and produces a target model from some source model.</p><p>Note that these basic concepts may be further extended. For example, one could allow for the use of more than one source and target (meta)models. Areas for model transformations are manifold. There are horizontal as well as vertical model transformation scenarios possible. We face a vertical transformation when moving from platform independent models to platform dependent models or even to code. When switching or migrating to other modeling languages at the same level we are designing horizontal model transformations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Some Model Transformation Approaches in Detail</head><p>After this brief and very basic introduction to model transformations we continue by describing three of the latest model transformation technologies and approaches. To foster a better understanding of these approaches we underpin our explanations by small examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">QVT</head><p>QVT stands for Query/Views/Transformations and represents a specification for model transformations still under development by the OMG <ref type="bibr" target="#b82">[70]</ref>. The goal of this specification is to standardize model transformations. Besides the outstanding final version there is no tool implementation available supporting the complete QVT standard so far. QVT defines four different ways of specifying model transformations as depicted in Figure <ref type="figure" target="#fig_9">2</ref>.1, i.e., four different transformation languages. Relations and Core are of a declarative style whereas Operational Mappings and the Black Box are languages favoring the imperative style. The complete Operational Mappings language is supported by the SmartQVT<ref type="foot" target="#foot_0">1</ref> tool, which is available as Eclipse plug-in. Another tool implementation of QVT supporting imperative as well as the declarative Relations language is ATL<ref type="foot" target="#foot_1">2</ref> described in the next subsection. In Example 1 we briefly demonstrate the use of the Relations approach, which is then mapped automatically to the Core, acting as operational semantic basis for Relations.</p><p>Example 1. Assume we have two metamodels SimpleUML and SimpleRDBMS and want to transform instances of these metamodels. The first mapping that needs to be defined is PackageToSchema as is shown in Listing 2.1. The direction of model transformation is specified during runtime, which makes relation PackageToSchema directionless. The domain in a relation is just a typed variable, that originates from a given metamodel. This may be seen as a pattern that is going to be matched within input and output models. Both name attributes are bound to the same variable pn, which acts as a condition forcing them to be the same in both models in order to let the pattern match. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Some Model Transformation Approaches in Detail</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Relations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Black Box</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RelationsToCore</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">ATL</head><p>The Atlas Transformation Language (ATL) was introduced by the Atlas Group and the TNI-Valiosys Company in 2003 <ref type="bibr" target="#b26">[14]</ref>. ATL aims at providing a practical implementation for the MOV/QVT <ref type="bibr" target="#b82">[70]</ref> standard. As such it provides a transformation engine able to transform any given source model to a specified target model. However, before the engine can however perform the transformation the user has to specify a proper ATL program based on some valid and executable metamodels. ATL supports queries, views and transformations. The transformation language is based on rules that are either matched in a declarative way or called in an imperative way. Besides rules, ATL provides so called helpers that are similar to e.g. Java methods in declarative style. For a complete description of the abstract syntax of ATL and its execution semantics we refer to the ATL user manual <ref type="bibr">[5]</ref> as well as the project site <ref type="bibr">[4]</ref>. To illustrate ATL we will give a small example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 2 State of the Art</head><p>Example 2. Assume we have two metamodels M M 1 and M M 2 as well as two model instances M 1 and M 2 such that the instance of functions M 1 l t M M 1 and M 2 l t M M 2 hold. M M 1 defines just one meta class, say Operation with one attribute String : name. On the other hand M M 2 also just defines one meta class, i.e., M ethod, which contains the attribute String : signature. We now define an ATL transformation program that transforms any given M 1 into M 2. The code that transforms these simple models is depicted in Listing 2.2. The first two lines define the header section of an ATL program. This primarily determines input metamodels and conforming models as well as output metamodels and conforming models. What follows is an ATL matched rule that matches elements from the source model in its source pattern ("from part") and transforms them into elements form the target model with its target pattern ("to part"). Matched elements are bound to variables that can be used throughout the current rule, e.g. in the "to part" in order to assign attributes. Variables are also bound to target elements that are created by this rule. This makes sense if a rule contains multiple target pattern elements. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Graph Grammars</head><p>Besides the above presented approaches to define model transformations, we want to elaborate on graph transformations. Several approaches have been developed that use graph grammars to transform from source to target models <ref type="bibr" target="#b98">[86,</ref><ref type="bibr" target="#b95">83,</ref><ref type="bibr" target="#b65">53,</ref><ref type="bibr" target="#b88">76]</ref>. The description of basic concepts of graph grammars are based on the very intuitive presentation in <ref type="bibr" target="#b47">[34]</ref>. As the name already suggests, graph transformations are highly based on graphs, which consist of vertices V and edges E. A vertex v1 in V is connected to say v2 through an edge e such that s(e) yields the source v1 and t(e) yields the target v2. Also, we can distinguish between two different kinds of graphs, i.e., type graphs and instance graphs. Type graphs capture concepts from the real world, which have been derived by generalization of real world entities. Based on these types specified in a type graph, we can build instance graphs that represent snapshots of possible realizations. We could also think of type and instance graphs as metamodels and models, respectively. Having specified the modeling space for very basic graph transformations, we now turn to the transformation rules that operate on the instance graphs. The specifications of these rules is also done by means of graphs. The concrete syntax for specifying these rules is the same as the one used to specify instance  graphs, which in turn is based on UML object diagram concrete syntax. In order to explain basic semantics of these graph transformation rules we give a small example. The example is again taken from <ref type="bibr" target="#b47">[34]</ref> due to simplicity and didactic reasons.  These generic transformations are supported by the VIATRA2 framework, implemented as an Eclipse plug-in. In contrary to our approach VIATRA2 does not foster an easy to debug execution model. Graph transformation rules in VIATRA2 may be further extended by Abstract State Machine rules to introduce control mechanisms for graph transformation rules and, hence, formulate complex transformation programs. This introduces an additional formalism within the framework. In addition there exists no explicit mapping model between source and target model. Transformation Patterns. Very similar to the idea of generic transformation is the definition of reusable idioms and design patterns for transformation rules described in <ref type="bibr">[1]</ref>. Instead of claiming to have generic rules, the authors propose the documentation and description of recurring problems in a general way, i.e. the definition of patterns. These patterns, which are independent of any type system in terms of a metamodel, may be reused by the transformation engineer in a concrete scenario. Summarizing, this approach solely targets documentation, whereas implementation issues on how these patterns could be implemented in a generic way -remain open. <ref type="bibr">[1]</ref> does support idioms, which describe recurring design problems specific to a certain application domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Some Model Transformation Approaches in Detail</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4">Advanced Model Transformation Features</head><p>Mappings for bridging metamodels. Another way of reuse can be achieved by the abstraction from transformation rules to model mappings as is done in our framework or by the ATLAS Model Weaver (AMW) <ref type="bibr" target="#b39">[26]</ref>. AMW lets the user extend a very generic weaving</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Why We Benefit from Examples?</head><p>metamodel, which allows the definition of correspondences between any two metamodels. Through the extension of the base weaving metamodel one can easily define new weaving operators or reuse existing ones of other weaving languages. The semantics, of these weaving operators is determined by the transformation model that takes the concrete weavings as input and generates a transformation model operating on the concrete models of two modeling languages. This transformation model acting upon the weaving model and producing a transformation model by itself is called Higher Order Transformation (HOT). For an application of the combination of AMW and HOT using Atlas Transformation Language <ref type="bibr">[2]</ref> see <ref type="bibr" target="#b40">[27]</ref>. The semantic of weaving operators, is specified by means of the HOT. This makes it very difficult to debug a possibly unintended result of the transformation process.</p><p>Weaving models as introduced by <ref type="bibr" target="#b39">[26]</ref> are considered as specialization of the more general concept of a mapping model. In <ref type="bibr">[33]</ref> the authors present an approach, which allows the definition of inter-model mappings using UML. They build on the semantics of mathematical relations and apply those definitions on model mappings in the software engineering field. With these formal foundations they define the visual syntax and the semantics of model mappings by relying on and extending the UML.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Why We Benefit from Examples?</head><p>Examples play a key role in the human learning process. There exist numerous theories on learning styles in some of which examples are to be seen as major artifact. For a description of today's popular learning style theories see for example <ref type="bibr" target="#b72">[60,</ref><ref type="bibr" target="#b41">28,</ref><ref type="bibr" target="#b57">44]</ref>. All these theories, especially the referenced ones, are quite similar concerning their notion of a learning dimension, e.g., visual, sensing, active, and reflective. The sensing dimension promotes the use of examples.</p><p>Examples have proven to be helpful in the deduction of general rules, as exemplified in <ref type="bibr" target="#b75">[63]</ref>. It is therefore by no accident that instructive and intuitive examples are common tools in teaching of computer science. Especially in those fields that are strongly driven by algorithms and mathematics. Examples help to introduce abstract terms and definition such as a state space. Nievergelt and Behr <ref type="bibr" target="#b75">[63]</ref> use the cannibal and missionary puzzle to introduce state spaces and in succession generalization from a concrete problem. This way of presenting complex and abstract theories and models makes them understandable to beginners and therefore targets the needs of students.</p><p>In order to better understand this example-based strategy to the understanding of complex scientific results we will motivate the field of modal logic by Example 4.</p><p>Example 4. When trying to introduce modal logic to students, often the same intuitive and simple example is chosen. In the literature this example is referred to as "'wise-men puzzle"' <ref type="bibr" target="#b49">[36]</ref>. Basically the problem situation looks as follows. There are three wise men and five hats, which three of them are red and two of them are white colored. Each wise men now gets one hat put on, but does not see Suppose now that the first two wise men say they don't know which color their hat has. The question remains: Does the third man know, which color his head is made of? A solution for this problem can be easily found by first writing down all possible states as is shown in Table <ref type="table" target="#tab_2">2</ref>.1. M1...M3 denotes each of the wise men and W and R stand for white and red, respectively. In order to solve the problem we can eliminate solutions that can't be true, assuming that the first two wise men have said the truth and are indeed wise concerning their reasoning capabilities. Solution number 3 and 7 can be deleted right away as one of the two wise men would know the color of his hat. We can delete one more possible solution, if we let the second wise man take the first man's statement into account. His not knowing the solution too, we can also exclude number 2. Because if 2 was the solution the second man could reason about the first man's statement and conclude that his own hat was red. But he does not know his hat, so we can erase 2 as possible solution. This last step is of course most difficult and needs usually some time to think about. Now that we have only solutions number 1,4,5 and 6 left we can say for sure that the third man wears a red hat.</p><formula xml:id="formula_0">Chapter 2 State of the Art M1 M2 M3 1. R R R 2. R R W 3. R W W 4. W R R 5. W W R 6. R W R 7. W R W</formula><p>This relatively simple example of reasoning about knowledge has approved itself in lectures about modal logic as a starting point. The intuitive way of finding a solution, e.g., for the wise men puzzle may serve as basis for a more general, formal way of solving such problems in computer logics. One modal logic capable of formalizing and solving the wise men puzzle would be KT 45 n <ref type="bibr" target="#b49">[36]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Common By-Example Approaches</head><p>MTBE was inspired by popular by example approaches, some of which we present briefly in the following subsections. But what does by example really mean? What do all these approaches have in common? The main idea, as the name already suggests, is to give the software kind of examples, how things are done or what the user expects, and let it do the rest automatically. In fact this idea is closely related to fields such as machine learning or speech recognition. Common to all by example approaches is the strong emphasis on user friendliness and a "short" learning curve. According to <ref type="bibr" target="#b32">[20]</ref> the by example paradigm dates</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Common By-Example Approaches</head><p>back to 1970 -see "Learning Structure Descriptions from Examples" in <ref type="bibr" target="#b102">[90]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1">Query By Example</head><p>One of the most well known by example approaches was developed by Zloof in 1975. It is called Query by Example (QBE) <ref type="bibr" target="#b105">[93]</ref> and acts as a visual language for relational data base management and manipulation like SQL. Data base operations originally supported by this approach are:</p><p>• queries on tables,</p><p>• insertions on tables,</p><p>• deletions on tables,</p><p>• updates on tables,</p><formula xml:id="formula_1">• table creations, • table updates,</formula><p>• query data base meta information.</p><p>The main advantage of QBE lies in its simplicity, which makes QBE easy to learn and use. This is achieved by imitating the user's thought process, when it comes to formulating a request to the data base. Also, this concrete syntax for the formulation of requests has the same style and uses the same operations throughout QBE, i.e., for each of the above mentioned data base operations. The functionality is however limited compared to data base query languages, such as SQL. With the rise of abstractness and reduction of complexity one looses flexibility in the design of problem solutions. QBE is therefore not used for any data base management scenario. The central syntactical artifact in QBE is the skeleton table, which is empty at the beginning of every QBE application. An arbitrary number of such empty tables will be instantiated upon one working canvas, if operations on more than one table is required by the user. These tables serve as open space for examples given by the user. Tables in QBE allow for two different inputs:</p><p>• constant elements (e.g. 1980-01-27 in Figure <ref type="figure" target="#fig_9">2</ref>.5) and</p><p>• example elements also called variables (e.g. ANY in Figure <ref type="figure" target="#fig_9">2</ref>.5). Note that example elements are always underlined. P. has the meaning of print and therefore selects all the columns that should be presented in the result set of the query. Example elements or variables are -as the name suggests -placeholders for any single tuples stored in a specific column in that table. It follows that for every column a variable preceded by a print operation P. is defined the result table for those columns is returned. This is of course equivalent to projection π column,... (T able) in relational algebra. Constant elements on the contrary represent a concrete value of an attribute that has to be matched in order to return a result set. Moreover QBE allows the specification of conditions upon attribute values that must be satisfied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 2 State of the Art</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5.</head><p>Having these syntactic and semantic definitions in mind one can easily understand the example given in Figure <ref type="figure" target="#fig_9">2</ref>.5(a). This QBE query selects the tuples consisting of <ref type="bibr">SSN</ref>  From these two examples one recognizes that the query formulation in QBE is more intuitive and easier to learn in comparison to the query language SQL. Especially when more</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Common By-Example Approaches</head><p>complex tasks, such as grouping, are used, SQL queries soon get harder to grasp and maintain. The prime target audience of QBE are of course people who are not familiar with programming languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2">Programming By-Example</head><p>Programming by Example (PBE) is also known in literature as Programming by Demonstration. In any case the paradigm of programming by means of visual tool support aims to simplify the task of creating a computer program. Instead of hand coding every single instruction of an executable program, a tool supports the user by visual abstractions from common programming languages. There exist various approaches how these abstractions take place. In the following we give a few examples that illustrate some of these approaches.</p><p>Example 7. The Stagecast Creator<ref type="foot" target="#foot_2">3</ref>  <ref type="bibr" target="#b91">[79,</ref><ref type="bibr" target="#b89">77]</ref> is kind of an integrated development environment (IDE) that lets one create simulations and games without a programming language just by knowing semantics of visual abstractions and rules. This tool originated from KidSim developed by <ref type="bibr">Cypher et al. in 1994 [78]</ref>. The major contribution of the Stagecast Craeator is the combination of the programming by demonstration (PBD) and the visual before-after rules paradigms. The former is concerned about the way the user can record a certain behavior of the future program whereas the latter is concerned about the visualization of the instructions recorded in this PBD manner.</p><p>Example 8. Consider Excel macros, which record every step the user takes to later automatically do exactly the same again without user input. No command of Visual Basic is needed in order to perform complex tasks. This approach is best described by the metaphor: "Watch what I do". Example 9. Another example for PBE could be the flash timeline and its support for enabling automatic animation creation. Flash also implements visual before-after rules as the user specifies some sort of pre and post conditions for Flash instances on different keyframes, which represent discrete points in time. Figure <ref type="figure" target="#fig_9">2</ref>.6 shows various screenshots demonstrating this way of specifying animations. At first the user inserts a keyframe at the beginning and draws a circle. Next she creates another keyframe some moments ahead and moves the circle, which has automatically been pasted at the same position as the first one, to some place on right side of the canvas. Finally a motion tween is inserted between these two points in time and the frames in between, capturing the movement of the circle, are interpolated accordingly. This is in fact a major relief in the development of animations. The Flash Actionscript 3.0 code, which would do this animation, is depicted in Listing 2.3. &lt;Source frameRate= " 12 " x= " 150 " y= " 151 " s c a l e X = " 1 " s c a l e Y = " 1 " 6 r o t a t i o n = " 0 " elementType= " movie c l i p " instanceName= " t e s t " symbolName= " wheel " &gt; Chapter 2 State of the Art  &lt;Keyframe index= " 0 " tweenSnap= " t r u e " tweenSync= " t r u e " &gt; Example 10. Besides the paradigm of PBE there exists the one of visual programming languages, which seems to be closely related to PBE as it also fosters the development of complex programs by means of visual abstractions. An example of these visual programming languages would be Quartz Composer of Apple Inc. coming along since Mac OS X v10.4 Tiger. Quartz Composer is used for efficient creation and prototyping of animations and simulations. A domain specific modeling language (DSL) is used to represent the data that is then rendered with OpenGl. These animations can later be easily integrated in other development environments such as Apples Cocoa or Carbon.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.3">Web-Scheme Transformers By-Example</head><p>Lechner et al. <ref type="bibr" target="#b60">[47]</ref> follow the original approach of QBE, but with extensions for defining scheme transformers, which is demonstrated in the area of web application modeling with WebML <ref type="bibr" target="#b27">[15]</ref>. Therefore, the original QBE approach is extended by introducing a generation part (WebML model after transformation) in the template definitions in addition to the query part (WebML model before transformation). Finally, XSLT code is generated to transform the WebML models, which are represented as XML files within the accompanying tool WebRatio. This approach is called transformers by-example (TBE).</p><p>Example 11. Figure <ref type="figure" target="#fig_9">2</ref>.7 shows the transformer graphical concrete syntax of the TBE approach. On top of the rectangle appears the name of the transformer. On the left marked with a Q resides the query template of the transformer. And on the right marked with a G we find the generative template. Within those parts we find elements from the WebML language specification. Our query part now selects all entity types ENT that are composed of an attribute ATT called SSN and transforms them into a page class containing an index unit for a specific entity type. This entity type is however connected to those entity types ENT from the query part, which have at least one attribute with name SSN. We have highlighted this relationship with a dashed line.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 3</head><p>Prerequisites for MTBE Before we introduce our MTBE approach we provide a detailed discussion on the terms and technologies used to realize MTBE, both conceptually and practically. Metamodeling may be performed in various ways leading to heterogeneities or hidden concepts on the metamodel and model layer. Therefore, any MTBE approach needs to be aware of these heterogeneities because of their strong impact on the model transformation code. One way to cope with these heterogeneities and to solve them is based on refactoring patterns. This is shown in this chapter. Additionally, we present a metamodel metric that is used to detect Chapter 3 Prerequisites for MTBE some heterogeneities or give an overview to what extent they are prevailing. Furthermore, we explain the difference between concrete syntax and notation, as these two concepts are central to the MTBE approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Metamodeling Stack</head><p>Model Transformation By-Example defines not a new transformation language but instead relies on existing implementations of such languages. Those implementations in turn rely on the metamodeling structures of the development environment, such as Eclipse. In the case of MTBE we build upon the Eclipse Modeling Framework (EMF) <ref type="bibr">[12]</ref>. The EMF defines Ecore, which acts as a basic modeling language for the creation of metamodels. Ecore is basically an implementation of the OMG's Meta Object Facility (MOF) <ref type="bibr" target="#b80">[68]</ref>. However, instead of implementing all details of MOF, Ecore comprises just the EMOF specification and, thus, leaves out many of the core constructs of UML 2.0. The Ecore model is depicted in Figure <ref type="figure">3</ref>.2 and is described in more detail in Subsection 3.1.1.</p><p>The UML Infrastructure specification <ref type="bibr" target="#b77">[65]</ref> presents a four-level metamodel hierarchy that relates MOF to UML, Models of UML and runtime instances based on these UML models. The levels are labeled as M3, M2, M1 and M0. Between these layers there exist so called «instanceOf » relationships. The metamodeling architecture is also shown in Figure <ref type="figure">3</ref>.1. In the context of MTBE we refer to the metamodeling structure as modelware technical space. We replaced the MOF model on M3 by Ecore that acts as our metametamodel for defining metamodels, e.g. M M 1, to represent modeling languages. The relation among models on different layers is stereotyped by the label «conf ormsT o» as suggested in Bézivin <ref type="bibr" target="#b25">[13]</ref>. The MTBE approach is concerned with the modeling languages and their models. Since, we do not include runtime instances in our work, we shaded this layer in Figure <ref type="figure">3</ref>.1. The major artifacts in MTBE are therefore metamodels and models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">The Ecore Model -Core Concepts Reviewed</head><p>As mentioned earlier the Ecore model is an implementation of the EMOF specification with a focus on tool integration and interoperability issues, in contrast to the OMG's focus on meta data repositories. Figure <ref type="figure">3</ref>.2 shows nearly all class definitions of Ecore. Meta classes in gray represent abstract classes. References in blue depict so called derived EReferences and are computed automatically from other existing and required EReferences. The core concepts of Ecore and for the building of metamodels are the metaclasses EClassifier and EStructuralFeature with their concrete specializations EClass, EAttribute and EReference, respectively. As described in the figure EAttribute and EReference inherit both from the super class EStructuralFeature and are contained via the eStructuralFeature reference in an EClass instance. Ecore supports all simple Java types like boolean, int, float as well as various  <ref type="bibr" target="#b80">[68]</ref> object types such as java.util.Date. For the definition of modeling languages also metaclasses for Operations or Packages for structuring are provided. The EFactory reflects an implementation specific design pattern as the name already suggests. EModelElement and ENamedElement may be seen as convenience classes encapsulating common features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Differences between Ecore and MOF</head><p>Although the above presented model strongly relates to MOF, there exist some major differences in the design of these two meta modeling languages, which are briefly discussed in this subsection.</p><p>• References vs. Associations EMOF does not support the modeling of relationships between elements. CMOF on the other side imports UML constructs to attain the concept of an Association. This Association class is responsible for navigability expressed by ownedEnd and navigableOwnedEnd features pointing to Properties acting as roles. For a visualization in terms of a UML class diagram see <ref type="bibr" target="#b80">[68]</ref>. Because of the use of UML association this also includes the concept of a role. Formal Semantics for both are found in <ref type="bibr" target="#b68">[56]</ref>. In general, UML associations are bidirectional allowing to obtain the classes on each end. In Ecore we have the concept of an EReference in terms of a meta class to establish links or edges between modeling entities or nodes. An EReference is Chapter 3 Prerequisites for MTBE Figure <ref type="figure">3</ref>.2: The Ecore metamodel for creating models <ref type="bibr" target="#b34">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Metamodeling Stack</head><p>always part of an EClass an has an eType, which points to one specific EClass including the one it is contained within to allow for self references. In contrast to MOF ,an EReference only allows navigating in one direction, i.e., an instance of EClass containg the EReference, navigates to the the other EClass but not vice versa. In order to allow navigating both directions one has to define a second EReference on the other EClass and to declare the two separate EReferences opposite to each other with the eOpposite feature. Another difference is that Ecore does not explicitly support the concept of a role. EReferences do have attributes for name and multiplicity, but this is not a compensation for UML roles.</p><p>• Generalization When modeling generalization among EClasses one has to be aware of the fact, that although Ecore allows multiple inheritance by defining eSuperTypes with multiplicity 0..n, Java does not. However, Java offers an alternative for multiple inheritance by providing the construct of an interface that is implemented by sub classes acting as kind of a super class. But we can specify, whenever inheriting from at least two EClasses, which of the EClasses shall be the one getting extended in Java. In graphical concrete syntax this is annotated in a concrete metamodel with the stereotype «extends» at one generalization link.</p><p>• Data Types At the data type level, Ecore provides Java simple types and some object types as explained above. MOF on the other hand imports the UML PrimitiveTypes package from the UML infrastructure, which consists of four basic primitive types that shall be reused.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Models and Transformations</head><p>Now that we have introduced a language for meta modeling and have explained its core constructs, we turn to the field of model transformations and how they fit into our modelware technical space. Bézivin et. al. <ref type="bibr">[9]</ref> argue for model transformations being just another kind of models, i.e., transformation models. They say:</p><p>"Model transformations can be abstracted to a transformation model." concepts of these models, i.e., the instances of these metamodels. A model transformation is interpreted as a transformation model, e.g., T M in Figure <ref type="figure">3</ref>.3, which is an instance of a transformation metamodel T M M M . This metamodel for defining model transformations is in turn an instance of the metametamodel Ecore. In Figure <ref type="figure">3</ref>.3 following <ref type="bibr">[9]</ref> we introduce two new association types. These are «transf orms» and «knows». So a transformation model needs to know at least two different metamodels and transforms at least between two models. Note that we do not differentiate between source and target models. In general, we believe a transformation should not have a distinct direction. Instead, it should be possible to apply a transformation model both directions. However, this does not apply to lots of transformation language implementations. We also point out that a transformation model can be applied to various input models and can generate more than one output models at a time.  two different metamodels as input MTBE can also be applied to vertical model transformations if desired. The reason why vertical model transformations are not the main objective of MTBE is, that there are typically no such big differences between the two metamodels neither in graphical notations nor in the concepts being used. We think that automated matching tools such as Coma++ <ref type="bibr">[6]</ref> produce faster mapping results than manually defined correspondences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Metamodel Heterogeneities</head><p>There has been a tremendous amount of work on analyzing and classifying different types of structural integration conflicts between schemas which represent the same "real world" domain. For this work, we reuse classifications of structural integration conflicts from [Kim], [KashyapSheth], [Härder], [Conrad], [NaumannLegler], and [Schmitt] as a basis for our classification of model integration conflicts.</p><p>When using a meta modeling language, such as MOF, it is quite likely that semantically equivalent modeling concepts are defined in different ways with different MOF concepts. Therefore, in the next paragraphs we look at integration conflicts between semantically Chapter 3 Prerequisites for MTBE equivalent metamodels which are not identically defined. Instead, they are defined using different MOF modeling concepts and modeling styles. Nevertheless, they present the same modeling concepts. Figure <ref type="figure">3</ref>.4 represents our taxonomy of schema integration conflicts which are classified into the following three main categories:</p><p>• Attribute Conflicts: This category covers conflicts which may occur between two corresponding attributes, i.e., the attributes are equivalent but not identically defined.</p><p>Consequently, the values of the attributes are not the same, although the represent the same information.</p><p>• Structure Conflicts: Different structures representing equivalent modeling languages are the result either of defining properties of modeling concepts in different ways or of defining properties as concepts and vice versa.</p><p>• Semantic Conflicts: This category covers conflicts due to using different names for the same concept (synonyms) or same names for different concepts (homonyms). Furthermore, a concept may be a subset of another one or concepts may overlap. These four conflicts are with regards to extensional conflicts. In addition, we look at intensional conflicts such as (implicitly) missing properties.</p><p>In the following subsections, we elaborate on each category in more detail. In particular, we first describe the integration conflict in general and then discuss a typical integration example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Attribute Conflicts</head><p>An attribute conflict occurs, when a semantic relationship between values of two attributes exists, but the attributes are representing the same information with different values or the attributes have different meta-properties. When using MOF-based metamodels, the following mismatches between attributes may occur:   • Default value: If default values are varying and the multiplicity of at least one attribute is optional, i.e., zero-to-one multiplicity, it must be ensured that the default values correspond to each other or a proper mapping function for the default values is provided.</p><p>Example 13. Mapping 3 in Figure <ref type="figure">3</ref>.5 represents a default value mismatch for the attributes minMulti and minCard, whose default values are 0 and 1, respectively. As these defaults are not identical a separate mapping function has to be provided for the an integration task.</p><p>• Multiplicity: An attribute has an upper and lower multiplicity which are typically zero-to-one, one-to-one, zero-to-many, or one-to-many. The default value for an attribute's multiplicity constraint is one-to-one. Conflicts may occur when two corresponding attributes have different upper or lower multiplicities. For example, when one attribute has a multiplicity zero-to-one and the other one-to-one, it must be ensured that the oneto-one attribute is set in any case, also when the zero-to-one attribute is not set.</p><p>Example 14. The attribute visibility in Figure <ref type="figure">3</ref>.5(a) has a multiplicity of zero-to-one in contrast to isPrivate in (b), which is required.</p><p>• Scaling: Attributes are often differently defined with respect to the meaning of scales. Furthermore, this category also comprises cases in which one domain is a subset of another one or domains are overlapping. Mappings between attributes having different scales can be expressed in terms of functions or lookup tables. However, this conflict is often responsible for applying injective instead of bijective mappings. • Value representation: It is also possible that semantic equivalent attribute values are varying in their representation. This is typically the case when different symbols are used for the same concepts.</p><p>Example 16. The data type mismatch in mapping 1 of Figure <ref type="figure">3</ref>.5 also has value representation mismatch as consequence as different symbols are used for specifying upper bounds of multiplicities. In (a) we could encode unbounded multiplicity by the value -1 whereas in language (b) we could use a * to allow for an arbitrary number of elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Structural Conflicts</head><p>This category comprises integration conflicts arising when equivalent modeling concepts are expressed with different metamodel structures. Different structures mainly result on the one hand from properties of equivalent modeling concepts defined with different modeling elements (cf. Figure <ref type="figure">3</ref>.6a property definition conflicts) and on the other hand from the fact that concepts may be represented by attributes or references instead of classes (cf. Figure <ref type="figure">3</ref>.6b concept definition conflicts). In the following, we elaborate on these two conflict subcategories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property Definition Conflicts</head><p>Discriminator/Attribute/Reference Conflict: MOF allows many ways to define properties of modeling concepts. In practice, three distinct variants of property definitions are often occurring in metamodels. The first variant is that a property can be expressed via a discriminator of an inheritance branch and at runtime the property can be derived by looking up the instantiated class. The second variant is that the property is defined with an additional attribute, and finally the third variant is that the property can be expressed by using an additional reference. Example 17. In Figure <ref type="figure">3</ref>.6 the mentioned variants are shown by a concrete example. Each variant represent the same information, namely that an attribute is either identifying or descriptive, however the metamodels have quite different structures. Figure <ref type="figure">3</ref>.6(a) shows that a Class can have arbitrary Attributes whereas Attribute is an abstract class and only the concrete subclasses DescAtt and IDAtt can be instantiated. In Figure <ref type="figure">3</ref>.6(b) an equivalent definition is illustrated by using the attribute isID in the class Attribute which is used as a flag, instead of using additional subclasses. Finally, Figure <ref type="figure">3</ref>.6(c) uses an additional reference IDs to mark the set of identifiable attributes. Even though, each metamodel leads to different abstract syntaxes of the models, they represents the same information. Consequently, there exists an isomorphism for transformation models between these representations without loosing information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Metamodel Heterogeneities</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Domain/Range Conflict:</head><p>This integration conflict results from the fact that in MOF only uni-directional references can be modeled, i.e., no bi-directional association as in UML are possible, and in most cases it does not make any difference, if a reference is modeled from the class A to the class B or vice versa. For example, when one wants to define the concept of inheritance between classes in a metamodel, this can be done by saying "a class has arbitrary subclasses" or alternatively "a class has arbitrary superclasses". It has to be mentioned that independent which alternative is chosen, it is possible to compute the inverse reference. An analogous computation has to be done when moving form the right to left hand side for the reference subclasses as shown below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 3 Prerequisites for MTBE</head><p>Reference subClasses:= Class.allInstances() -&gt;select(e|e.superClasses = obj1); 1:n Property Conflict 1:n Reference Conflict: This kind of conflict category represents the case that one reference of a metamodel corresponds to more than one references of another metamodel. The additional complexity of these conflicts is that when moving from one to n references, we have to split the single reference in several subsets by looking at attribute values or reference links of the referenced objects. Consequently, when moving form n references to one reference, the reference sets must be united to one set. Example 19. Figure <ref type="figure">3</ref>.7 illustrates the mismatch of sets in mapping 3. In (a) a Class can have two different sets of attribute types, i.e., DescAtt and IDAtt, whereas in (b) Class just references Attributes. Due to mapping 3 these we have to merge the sets of DescAtts and IDAtts when transforming from (a) to (b) or split the set of Attributes when transforming from (b) to (a). Note, that in the latter case a proper constraint has to be defined on the Attribute of (b), which allows for splitting up a single set into two.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1:n Attribute Conflict:</head><p>An attribute value normally contain one information unit, however, sometimes, one attribute value represents several information units. This typically is a design decision if one attribute is used to store more information units or if for each information unit a separate attribute is modeled. If an attribute is used to hold more than one information units and corresponds to a set of attributes, the single value must be split into several values, which are then assigned to n attributes. Going the other way round, several values must be concatenated into one.</p><p>Example 20. In Figure <ref type="figure">3</ref>.7 an attribute conflict is shown in mapping 2. Here we have a two-to-one mapping from attributes prefix and name to name. Prefix and name must therefore be concatenated when moving from (a) to (b) and name must be split properly when moving from (b) to (a). For the latter case a meaningful mapping must also specify proper tokens or constraints, which allow to split up a single value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property/Concept Conflicts</head><p>Attribute/Class Conflict: An attribute/class mismatch occurs, when a concept is modelled as an attribute in one metamodel and in another metamodel as a class, which contains the attribute. This means, on the instance level, the attribute values must be converted into objects and also the structure must be ensured by linking the two objects.</p><p>Example 21. As an example consider mapping 1 in Figure <ref type="figure">3</ref>.8, where on one side of the mapping attributes maxCard and minCard are contained in the "main" class Attribute itself (cf. a), but on the other side these attributes are separated into the class Multiplicity.  Reference/Class Conflict: In one metamodel, only a reference is modeled and in another metamodel a class is defined, which can be seen similar to an association class in UML. This means, on the instance level, the reference link must be converted into an object and for ensuring the structure the object must be linked with the containing and referencing objects of the source reference. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Metamodel Heterogeneities</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Semantic Conflicts Naming Conflicts</head><p>Under the category naming conflicts we subsume conflicts due to lexical representation of element names. This kind of conflict only complicates the discovery of semantically related elements, i.e., matching phase, however, after recognizing naming conflicts, no additional complexity results in the mapping phase.</p><p>Synonym Synonyms describe the same concept, however, they use different terms. In metamodels, attributes, references, and classes can be named differently, although they represent the same concept.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 3 Prerequisites for MTBE</head><p>Homonym Homonyms use the same terms, however, they elements stand for different concepts. This means, in metamodels, elements with the same name can stand for different concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Extension Conflicts</head><p>The extension of a set is its members or contents. This means, talking about metamodel classes, the extension defines all instances of a class. When comparing the extensions of two semantically related classes, the following situations may occur: equal, distinct, subset, and overlapping. The first two situations are no source for integration conflicts; however, the second two are.</p><p>No Conflict Cases Equal: This means, two concepts are semantically equivalent and also the extensions of the two concepts are the same. In such cases, a simple one-to-one correspondence is enough for describing the mappings, which typically do not lead to an integration conflict. Distinct: If the extensions of two concepts have no intersection, then no semantic relationship should exist between the two concepts. Consequently, no mappings should occur between the two concepts not leading to an integration conflict.</p><p>Conflict Cases Subset: Two concepts can be semantically related, however, the extension of one concept may be only a subset of the extension of the other concept. This means, a condition is necessary in order to identify the subset which is actually semantically equivalent.</p><p>Overlapping: This case is even more complicated than the subset case, because both sides require conditions to identify which parts actually match.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intension</head><p>The intension of a set is its description or defining properties. This means, when we are talking about the intension of a class, we talk about the properties of the class. In MOF attributes and references represent properties of classes. When two classes which are semantically related are compared, also the attributes and the references of the classes should match. However, due to different viewpoints and slightly different modeling domains, not all attributes and references matches.</p><p>Missing Properties It may occur that two semantically related classes have different properties. Sometimes the properties can be derived from other information, like the type of the object (cf. c2) or other properties (derived properties), but often they cannot be automatically computed, because the information is simply not present in the metamodel. The resulting problem of missing properties is 0:1 mappings. The problem is that the values of  these kind of features cannot be set with values of the DSL models. In order to produce valid UML models, we must distinguish between optional and mandatory features. The first case is that the feature is optional leading to no problems because a null value can be assigned. The second case is the more problematic, namely if the UML attribute is mandatory. We can check if a default value is available for this attribute. If no default value is defined for the feature, the user must specify a value in the mapping model which is automatically assigned for this particular feature. In case, properties have standard values, these values can be implied. If this is not possible, then in the integration solution the user must give values for such integration scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implicit Missing Properties When comparing two semantically equivalent classes, even</head><p>if one class has one property missing compared to the other, often it is possible that this property can be inferred via the type and can be seen as implicitly available with a standard constant. This problem is related to Property Definition Conflicts of Section 3.2.1. Example: When we are comparing the metamodels in Figure <ref type="figure">3</ref>.9(a) and (b), it seems that the class Class in Figure <ref type="figure">3</ref>.9(b) has one additional property, namely isAbstract. However, this information can be expressed with the type information in Figure <ref type="figure">3</ref>.9(a), thus it can be seen, that the two subclasses have an additional attribute with a constant value, e.g. DescAtt has a derived constant attribute isID with the value false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Model Heterogeneities</head><p>In data engineering additionally to schema conflicts also conflicts on the data layer have been studied. Since the integration scenario was merging two or more schemas into one integrated schema as well as merging data from various sources into one representation, typing errors, outdated data, or different representations have been taken into consideration. Our primary tool integration scenario is the transformation of one model into another. More specifically, we have to create a new target model from an existing source model. Therefore, the reported data integration conflicts are not relevant. Nevertheless, some inte- gration issues cannot be answered by looking at the metamodel layer only. Even if metamodels are identically defined, differences between languages are possible, which can only be determined with the help of instances of the metamodels, i.e., the models, and their use and interpretation. This is due to the fact that the semantics of the modeling languages are not defined within language definitions; instead they are only implemented in tool support such as code generators or simulation environments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Refactoring Patterns</head><p>The aim of metamodeling lies primarily in defining modeling languages in an object oriented manner leading to efficient repository implementations. This means that in a metamodel not necessarily all modeling concepts are represented as first-class citi-zens. Instead, the concepts are frequently hidden in attributes or in association ends. We call this phenomenon concept hiding. In order to overcome this problem, we propose refactoring as a second step in the lifting process, which semi-automatically generates an additional and semantically enriched view of the conversion step's output, i.e., a what we call pseudo-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Refactoring Patterns</head><p>ontology. For a detailed discussion on this conversion step and the term pseudo-ontology we refer the interested reader to <ref type="bibr" target="#b54">[41]</ref>. However, the motivation for the shift from metamodels to ontologies is the available tool support for matching and the reasoning possibilities coming along with ontologies. Generally, we do not distinguish between metamodels and ontologies. We present the refactoring work we have done for ontologies in this section as the refactoring step can of course be directly applied to metamodels. Thus, refactoring also is of relevance to MTBE. First, with refactoring it is possible to solve heterogeneity problems. And second, one needs to be aware of possible refactorings when defining the CS, because many hidden concepts have a distinct representation in the CS, though.</p><p>Figure 3.10 gives an example of how concept hiding is achieved in metamodels. In the upper part it shows a simplified version of the UML metamodel kernel which is defined in the UML Infrastructure <ref type="bibr" target="#b31">[19]</ref>, represented as a pseudo-ontology. As we see in Figure <ref type="figure">3</ref>.10 the pseudo-ontology covers twelve modeling concepts but uses only four classes. Hence, most of the modeling concepts are implicitly defined, only. To tackle the concept hiding problem, we propose certain refactoring patterns for identifying where possible hiding places for concepts in metamodels are and also how these structures can be rearranged to explicit knowledge representations. The refactoring patterns given in the following subsections are classified into four categories. The description of each pattern is based on <ref type="bibr" target="#b23">[11]</ref> and consists of pattern name, problem description, solution mechanism, and finally, of an example based on the UML kernel. The kernel is shown in the upper part of Figure <ref type="figure">3</ref>.10 as a pseudoontology (before applying the patterns) and in the lower part of Figure <ref type="figure">3</ref>.10 as a refactored ontology (after applying the patterns). The numbers in the figure identify where a certain pattern can be applied and how that structure is refactored, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Patterns for Reification of Concepts a) Association Class Introduction</head><p>A modeling concept might not be directly represented by object properties but rather hidden within an association. In particular, it might be represented by the combination of both properties representing the context in which these object properties occur.</p><p>Refactoring: A new class is introduced in the ontology similar to an association class in UML to explicitly describe the hidden concept. Since there is no language construct for association classes in OWL, the association is split up into two parts which are linked by the introduced class. The cardinalities of the new association ends are fixed to one and the previously existing association ends remain unchanged.</p><p>Example 23. The combination of the roles of the recursive relationship of Class, sub-class and superclass, occurs in the context generalization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 3 Prerequisites for MTBE b) Concept Elicitation from Properties</head><p>In metamodels it is often sufficient to implement modeling concepts as attributes of primitive data types, because the primary aim is to be able to represent models as data in repositories. This approach is in contradiction with ontology engineering which focuses on knowledge representation and not on how concepts are representable as data.</p><p>Refactoring: Datatype properties which actually represent concepts are extracted into separate classes. These classes are connected by an object property to the source class and the cardinality of that object property is set to the cardinality of the original datatype property. The introduced classes are extended by a datatype property for covering the value of the original datatype property.</p><p>Example 24. The properties Property.lower and Property.upper represent the concept Multiplicity which is used for defining cardinality constraints on a Property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Patterns for Elimination of Abstract Concepts c) Abstract Class Elimination</head><p>In metamodeling, generalization and abstract classes are used as a means to gain smart object oriented language definitions. However, this benefit is traded against additional indirection layers and it is well-known that the use of inheritance does not solely entail advantages. Furthermore, in metamodels, the use of abstract classes which do not represent modeling concepts is quite common. In such cases generalization is applied for implementation inheritance and not for specialization inheritance. However, one consequence of this procedure is a fragmentation of knowledge about the concrete modeling concepts.</p><p>Refactoring: In order to defragment the knowledge of modeling constructs, the datatype properties and object properties of abstract classes are moved downwards to their concrete subclasses. This refactoring pattern yields multiple definitions of properties and might be seen as an anti-pattern of object oriented modeling practice. However, the properties can be redefined with more expressive names (e.g. hyponyms) in their subclasses.</p><p>Example 25. The property NamedElement.name is used for class name, attribute name, association name and role name.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3">Patterns for Explicit Specialization of Concepts d) Datatype Property Elimination</head><p>In metamodeling it is convenient to represent similar modeling concepts with a single class and use attribute values to identify the particular concept represented by an instance of that class. This metamodeling practice keeps the number of classes in metamodels low by hiding multiple concepts in a single class. These concepts are equal in terms of owned attributes and associations but differ in their intended semantic meaning. For this purpose, attributes of arbitrary data types can be utilized but in particular two widespread refinement patterns are through booleans and enumerations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Refactoring Patterns</head><p>d1) Refactoring for Boolean Elimination Concepts hidden in boolean attribute are unfolded by introducing two new subclasses of the class owning the boolean, and defining the subclasses as disjoint due to the duality of the boolean data type range. The subclasses might be named in an x and non-x manner but descriptive names should be introduced into the ontology by the user.</p><p>Example 26. Class.isAbstract is either true or false, representing an abstract or a concrete class, respectively. d2) Refactoring for Enumeration Elimination Implicit concepts hidden in an enumeration of literals are unfolded by introducing a separate class for each literal. The introduced classes are subclasses of the class owning the attribute of type enumeration and are defined as disjoint, if the cardinality of the datatype property is one, or overlapping if the cardinality is not restricted.</p><p>Example 27. Property.aggregation is either none, shared, or composite, representing a nonCompo-sitionProperty, a sharedCompositionProperty or a CompositionProperty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>e) Zero-or-one Object Property Differentiation</head><p>In a metamodel the reification of a concept is often determined by the occurrence of a certain relationship on the in-stance layer. In such cases, the association end in the metamodel has a multiplicity of zero-or-one which implicitly contains a concept refinement.</p><p>Refactoring: Two subclasses of the class owning the object property with cardinality of zero-or-one are introduced. The subclass which represents the concept that realizes the relationship on the instance layer receives the object property from its superclass while the other subclass does not receive the object property under consideration. Furthermore, the object property of the original class is deleted and the cardinality of the shifted object property is restricted to exactly one.</p><p>Example 28. Property.association has a multiplicity of zero-or-one, distinguishing between a role and a nonRole, respectively. f) Xor-Association Differentiation Xor-constraints between n associations (we call such associations xor-associations) with association ends of multiplicity zero-or-one restrict models such that only one of the n possible links is allowed to occur on the instance layer. This pattern can be used to refine concepts with n sub-concepts in a similar way like enumeration attributes are used to distinguish between n sub-concepts. Thus, xor-associations bind a lot of implicit semantics, namely n mutually excluding sub-concepts which should be explicitly expressed in ontologies.</p><p>Refactoring: This pattern is resolvable similar to the enumeration pattern by introducing n new subclasses, but in addition the subclasses are responsible for taking care of the xorconstraint. This means each class receives one out of the n object properties, thus each Chapter 3 Prerequisites for MTBE subclass represents exactly one sub-concept. Hence, the cardinality of each object property is fixed from zero-to-one to exactly one.</p><p>Example 29. Property.owningAssociation and Property.owingClass are both object properties with cardinality zero-or-one. At the instance layer it is determined if an instance of the class Property is representing an attribute (contained by a class) or a nonAttribute (contained by an association).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.4">Patterns for Exploring Combinations of Refactored Concepts</head><p>Refactorings that introduce additional subclasses, i.e., patterns from category Specialization of Concepts, must always adopt a class from the original ontology as starting point since the basic assumption is that different concept specializations are independent of each other. Hence, in the case of multiple refactorings of one particular class, subclasses introduced by different refactorings are overlapping. In Figure <ref type="figure">3</ref>.10 this is denoted using a separate generalization set for each refactoring. However, this approach requires an additional refactoring pattern for discovering possible relation-ships between combinations of sub-concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>g) Concept Recombination</head><p>In order to identify concepts which are hidden in the ontology as mentioned above, the user has to extend the ontology by complex classes which describe the concepts resulting from possible sub-concept combinations.</p><p>Refactoring: User interactions are required for identifying the concepts behind the combination of concepts by evaluating the combinations in a matrix where the dimensions of the matrix are the overlapping generalization sets in consideration.</p><p>Example 30. When studying the textual descriptions of the semantics of UML one finds out that some relationships between the different kinds of properties define additional concepts which are not explicitly represented in the ontology. In particular, the evaluation of role/nonRole and attribute/nonAttribute combinations leads to the additional intersection classes depicted in the lower part of Figure <ref type="figure">3</ref>.10.</p><p>Summarizing, the results of the refactoring step, either of ontologis or metamodels are characterized as follows:</p><p>• Only datatype properties which represent semantics of the real world domain (ontological properties) are contained, e.g. Class.className, Multiplicity.upper. This means no datatype properties for the reification of modeling constructs (linguistic properties) are part of the refactored ontology.</p><p>• Most object properties have cardinalities different from zero-or-one, such that no concepts are hidden in object properties.</p><p>• Excessive use of classes and is-a relations turns an ontology or a metamodel into a taxonomy. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Concrete Syntax vs. Notation</head><p>So far we have been addressing the definition of the abstract syntax (AS) of a modeling language by means of metamodels, only. However, modeling languages often also comprise graphical concrete syntax. We then talk about visual modeling languages. In what follows we simply talk about concrete syntax (CS), but in general we mean graphical concrete syntax unless stated otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition</head><p>The graphical concrete syntax is part of a visual modeling language and defines in a formal way how abstract syntax (AS) elements are rendered to the screen. This formal definition for CS elements includes for example shape, appearance, layout and position.</p><p>For an in depth discussion on the topic of CS see <ref type="bibr" target="#b44">[31,</ref><ref type="bibr">7,</ref><ref type="bibr" target="#b43">30]</ref>. Also Fondement <ref type="bibr" target="#b43">[30]</ref> discusses not only graphical concrete syntax but also textual concrete syntax, which we do not cope with in our MTBE approach. We want to embed the notion of CS within our modelware technical space, though. As already mentioned in the above definition we need a formal way to define our CS elements. The probably most intuitive way of defining these elements is by using again the well known meta modeling paradigm.</p><p>Figure <ref type="figure">3</ref>.11 shows how the CS metamodel CS M M , which is again based on Ecore, is contained in our metamodeling stack. Because CS M M acts as our modeling language for visually rendered elements we are able to define models that actually represent those visual objects. Model CS M defines all CS elements for the modeling language M M 1. But the definition of the CS is not enough for the implementation of a visual modeling language. What is left is the defintion of how metamodel elements of the modeling language and Chapter 3 Prerequisites for MTBE instances of the CS M M relate to each other. The relationship of all those elements can be captured by a mapping model, which formally specifies model correspondences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition</head><p>The mapping model relating AS and CS we call notation. The notation may be defined as follows:</p><p>T riple :=&lt; as_E, cs_E, const(as_E)? &gt;</p><p>. In this basic definition we can relate one AS element as_E from MM1 with one CS element cs_E from the model CS. In addition one may give an optional constraint operating on as_E.</p><p>We have introduced a mapping mechanism for AS and CS and must finally provide the language definition for the mapping models, i.e., the notations, themselves. This is again done by a proper metamodel for mapping models that we call M ap M M in Figure <ref type="figure">3</ref>.11. The references the notation must have to the AS and the CS are depicted as «relates» stereotyped references. So we have one meta layer crossing relationship between M M 1 and M ap M . Technically this can be achieved by importing Ecore in the M ap M M and directly use concepts of Ecore.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notation in the Light of MTBE</head><p>In this subsection we show how we make use of the concept of notation in our MTBE approach. In Section 6.1 we show how the concept of notation has been implemented within state of the art modeling environments.</p><p>The primary idea of MTBE is to exploit the concrete notation of modeling languages, which is well known by the user, for defining mappings between semantically corresponding model elements on the M1 layer. In order to further discuss the by-example approach for model transformations, the interrelationships between the abstract syntax, concrete syntax and the mapping between them, which describes the notation of the modeling language, have to be clarified. In accordance with MMF <ref type="bibr" target="#b29">[17]</ref> and GMF <ref type="bibr" target="#b36">[23]</ref> Figure <ref type="figure">3</ref>.12 depicts how these three parts of a formal language definition are interrelated in terms of an UML package diagram.</p><p>The package abstract syntax summarizes elements of the abstract syntax, i.e., the metamodel. For example for UML these would be concepts such as property, class and association. In contrast, the package concrete syntax covers graphical elements, e.g., ellipse, label, and rectangle, which can be further combined to more complex forms, e.g., ClassRectangle, At-tributeLabel. Finally, how elements of the abstract syntax are mapped to elements of the concrete syntax is defined in the package as_2_cs which mainly consists of triples defined in Equation <ref type="formula" target="#formula_2">3</ref>.1. The optional constraint part (const(as_E)) of the triple is the most relevant part for this work. In case no constraint is defined, there is a one-to-one mapping between an abstract syntax element and a concrete syntax element, i.e., the concept defined in the metamodel is directly represented by one concrete notation element. However, the other Figure <ref type="figure">3</ref>.12: Relationship between abstract and concrete syntax. case is the more interesting in context of solving the concept hiding problem. The presence of a constraint defines a new sub-concept for the notation layer, which is not explicitly represented by one of the metamodel classes. Consequently, when defining model transformations based on the abstract syntax, the constraints for these sub-concepts must be defined by the user in the query part or when going the other way round by setting the property values correctly in the generation part of the transformation rules. This is a tedious and error-prone task that requires excellent knowledge about the metamodel.</p><p>With MTBE this circumstance can be improved by incorporating the existing constraints defined in the triples (cf. Defintion 3.1) of the as_2_cs package (cf. Figure <ref type="figure">3</ref>.12) into the model transformation generation process in order to minimize the effort for re-engineering and defining these constraints by hand.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Metamodel Metrics</head><p>Evaluation of models is a hard and ambiguous task. Whether a model can be asserted as semantically correct within a certain domain of discourse always depends on the viewpoint of the observer. In order to gather objective facts about models, the use of metrics is necessary. Metrics have a long history in software development as a quality measure. Measured value can be interpreted for itself, or it can be combined to create aggregated metrics for stating a more abstract conclusions. During the triumphal procession of Object Oriented Programming (OOP) in the last one and a half decades and the subsequent development of Object Oriented Modeling (OOM) techniques, a lot of effort was made to develop metrics for object-oriented models (OO-metrics). OO-metrics allow to make statements about the quality of software models <ref type="bibr" target="#b63">[51]</ref>[91] <ref type="bibr" target="#b62">[50]</ref>.</p><p>With the advent of Model Driven Engineering (MDE) <ref type="bibr" target="#b87">[75]</ref>, the need of formal metamod- els for modeling languages arises and consequently the need for metrics for metamodels. Basically a metamodel can be seen a s a model; it also consists of classes, relations, inheritance, etc. However, the intension of a metamodel (the AS) is different from that of most M1 models. A metamodel is an object oriented language definition. Therefore the instances of a metamodel are again models with a graphical notation, the CS. Nevertheless, metamodels can be treated as models for a specific domain, the domain of modeling language definition. Hence, most of the metrics for OOM can be applied to metamodels <ref type="bibr" target="#b61">[49]</ref>.</p><p>In this section we introduce a new metric, which discovers the explicitness of a metamodel. We define explicitness in the context of metamodels as the number of concepts in the modeling language that are first class concepts in the metamodel. This definition is based on the assertion that the number of first class concepts in the abstract syntax can differ from that in the concrete syntax. For example consider the modeling concept Attribute in the UML class diagram. In the UML 2.0 class diagram metamodel there exists no first class definition for Attribute . It is hidden in the class Property <ref type="bibr" target="#b54">[41]</ref>. But in the concrete syntax of UML 2.0 class diagrams, there exists a notation for the concept Attribute.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.1">Calculating the Explicitness of Metamodels</head><p>Modeling languages have specific modeling concepts, which can be expressed with its CS elements. The composition of modeling concepts is defined in the metamodel (the abstract syntax). These modeling concepts, which are used in the concrete syntax, do not necessarily have an exact counter part in the abstract syntax. Concepts in the metamodel are often reused with the help of attributes and associations to other concepts. We call this phenomenon concept hiding <ref type="bibr" target="#b54">[41]</ref>. Our aim is to get a metric to estimate the explicitness of metamodels. The Explicitness of MetaModel (EM 2 ) metric can be calculated by counting all concrete classes of a metamodel and dividing it by the number of CS elements. A metamodel does not only consist of concrete classes but of abstract classes as well. Since abstract classes have no conceptual representation on the concrete syntax, they cannot be instantiated. For this reason abstract classes are not counted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interpretation of the Metric EM 2</head><p>In general, we can make three assertions about the ratio between the number of concrete classes in the metamodel and the number of CS elements.</p><formula xml:id="formula_3">EM 2 value Interpretation &lt; 1 Concept deficit = 1 Concept equilibrium &gt; 1 Concept redundancy | overload</formula><p>A graphical representation is given in figure <ref type="figure">3</ref>.13. The ellipses represent the metamodels with their first class concepts. The clouds represent the semantic concepts of the modeling language. The diamonds represent the CS elements. The links between these three elements depict the reference between the metamodel and its CS. The top right fraction (cf. counting in figure <ref type="figure">3</ref>.13) represents the ratio by counting MM-concepts and CS elements without including further information. The bottom right fraction (cf. semantic in figure <ref type="figure">3</ref>.13) represents the semantically correct ratio that describes the ratio of concepts and their representation on the concrete syntax. To determine the bottom right fraction, further information is necessary, that is included in the links between metamodel and CS. In the following we discuss the three aforementioned distinct cases of the EM 2 metric.</p><p>• Concept deficit: An EM 2 value smaller than one means that there exist more concepts in the concrete syntax than in the abstract one (see figure <ref type="figure">3</ref>.13b). The reason for this is that the concepts are hidden in the metamodel. In the field of model transformations, which are defined on the metamodel, it is easier to map one metamodel to another if no hidden concepts exist in the metamodel. A balance smaller than one is an indicator for the need of refactoring <ref type="bibr" target="#b54">[41]</ref>.</p><p>• Concept equilibrium: An EM 2 value of one means that there are exactly as many concepts in the metamodel as in the concrete syntax (see figure <ref type="figure">3</ref>.13a).</p><p>• Concept overload: An EM 2 value greater than one can have two reasons. The first one is a CS element with more than one concept in the metamodel. Two concepts in the metamodel with similar semantics is a non-realistic assumption and can be left out.</p><p>The second reason are metamodel concepts, which do not represent a CS element (see figure <ref type="figure">3</ref>.13c).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Side Effects of the Metric</head><p>Automatically applying the metric to a modeling language may entail some side effects.</p><p>Only concrete classes of the metamodel and all CS elements that form the concrete syntax are counted. Depending on the metamodel, a concrete class must not necessarily have a CS element. This increases the denominator of the fraction and results in a higher EM 2 (the upper right fraction in figure <ref type="figure">3</ref>.13c). This would be interpreted as a more explicit metamodel. The bottom right fraction in figure <ref type="figure">3</ref>.13(c) depicts the semantic ratio between concepts, metamodel classes and its CS elements.</p><p>Counting metamodel classes with no representation in the concrete syntax can be prevented by following the mapping between a metamodel concept and its CS. If there is a link with no constraint, the metamodel class has a CS element. Otherwise, the class hides some information and is not a first class element for this concept. A constraint link is a mapping between a metamodel class and a CS element having further restrictions, e.g., that a association to another metamodel class ought to be set, or that an attribute of the metamodel class must have a specific value. With this further information, most of the side effects and the resulting misinterpretation of the balance can be avoided.</p><p>On the level of the concrete syntax, it is possible that a language concept has two or more CS elements, like the interface CS in UML. By counting all these CS elements, the numerator of the fraction increases and the balance becomes lower, see figure <ref type="figure">3</ref>.14x. This would lead to interpret the metamodel as less explicit, with more hidden concepts. Evaluating the mappings between the CS and the metamodel, as aforementioned, can avoid this circumstance. If there exists a link without a constraint between a metamodel class and two CS elements this two CS elements are counted as one.</p><p>One and the same CS elements can be used for different concepts <ref type="bibr">(3.14y)</ref>. This result in a lower numerator of the fraction and leads to the interpretation of an overspecified 3.6 Metamodel Metrics metamodel. Again following the links between CS elements and metamodel elements is a solution to this problem.</p><p>CS elements represent a concept of the modeling language, but it is possible that the combination of two or more CS elements stands for a different concept which has no explicit CS. This changes the balance to a higher ratio if the concept is explicit in the metamodel but could not be counted on the concrete syntax because combined CS elements are not countable <ref type="bibr">(3.14z)</ref>. In this case following the links between metamodel concepts and CS elements provides no solution. An approach to cope with this problem is to analyze one or more concrete examples (M1 models) and analyze how CS elements can be combined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.2">Analysing UML 1.4 and UML 2.1</head><p>The UML metamodel 1.4.2 <ref type="bibr" target="#b78">[66]</ref> and 2.1 <ref type="bibr" target="#b81">[69]</ref> for class modeling were chosen as test cases for the EM 2 metric. Strictly counting concrete classes in the metamodel and predefined CS elements from the specifications, we found the following estimates for the EM 2 value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Metamodel version EM</head><formula xml:id="formula_4">2 value UML 1.4.2 ≈ 0, 77 UML 2.1 ≈ 0, 64</formula><p>These estimations have however to be taken with care because of possible inaccuracies in counting CS elements. There exist several CS elements where it is not clear whether to count them as one or each separately, as we did in our evaluation scenario. As an example for this kind of problem you might consider the Dependency relationship and its various stereotyped CS elements attached to it. Also we have not eliminated arising side effects, except for the CS combination side effect. Due to lack of space we only present a notation table for UML 2.1 in Figure <ref type="figure">3</ref>.15, which helps reproduce the numbers of our metric.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Discussion of the Metric Results</head><p>Although the results are not totally unbiased they seduce that both metamodels rely on implicit concepts. Furthermore, we can say there is a greater implicitness incorporated into the UML 2.1 metamodel than in the UML 1.4.2 metamodel. The class Attribute represents just one concept in UML 1.4.2 that has been made implicit in UML 2.1. In the following we now go more into details and illustrate the characteristics and side effects of our metric.</p><p>As a potential source of implicitness of concepts we discovered the usage of enumerations, which are heavily applied in both metamodels. The definition of the EM 2 metric does not involve the count of enumerations and their literals. But these literals often represent a CS element, often in combination with some classes. For example, the enumeration AggregationKind is used in both metamodels to distinguish between three different CS elements, that is to say regular association, aggregation, and composition. The depicted side effect notation overload in figure <ref type="figure">3</ref>.14, appeared in the UML 2.1 metamodel in the case of the meta classes ElementImport and PackageImport. Both classes make use of the same CS element. The meaning between the two can only be made unambiguous when considering the connected model elements, i.e., Classes or Packages.</p><p>Notation redundancy could also be recognized in both metamodels. Consider the interface class as an example, which can be graphically represented by two different means. Another example would be the various possible CS forms of an association (with a diamond in the middle or without, or with an arrow or without). The algorithm described above would filter such redundancies to eliminate the problem and concentrate on concepts instead of graphical representations.</p><p>We also encountered the problem of unused concrete meta classes that do not define a general notation. The responsibility is instead delegated to some other classes, that can be subclasses of the class under consideration. For example, the class Parameter in UML 2.1 has no direct link to any CS element. The class Operation therefore defines the CS for its parameters. Similar to the count of unused meta classes is the count of general CS elements that have no concrete class in the metamodel. The class MultiplicityElement, that is declared abstract, specifies a general CS for multiplicities, which can be further specialized in corresponding subclasses. The EM 2 metric takes the CS into account, but omits the abstract class, leading to a rare side effect, that we call standalone notation.</p><p>Combining CS elements is common practice in the UML metamodels. Take as an example the CS for a stereotype, that is composed of the CS of a simple class and the name of the stereotype within guillemets. When computing our metric for the two metamodels we counted each combined CS element as individual to avoid the side effect resulting from notation combination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Metamodel Metrics</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.3">Metrics-Related Work</head><p>Best to our knowledge, there has been no work on metrics for explicitness of metamodels and our work is the first study on this topic. However, our work is mainly influenced by two orthogonal research directions, on the one hand by metrics for UML class diagrams and on the other hand by metrics for Ontologies.</p><p>Metrics for UML class diagrams are mostly based on metrics for OO programs. This is due to the close connection of UML class diagrams to OO programming languages like Java. In <ref type="bibr" target="#b103">[91]</ref> six different metrics for UML class diagrams are analyzed and compared whereas the question arises which model elements, e.g., classes, attributes, and associations, have impact on the complexity of a class diagram. In <ref type="bibr" target="#b67">[55]</ref> the metrics are more generically defined based on graph structures. Again, the metrics operate on quantitative characteristics, e.g., node count, edge count, and path length, and then these single metrics are combined to higherorder metrics.</p><p>Summarizing these proposed metrics for UML class diagrams mostly focus on the quantitative analysis of model elements, thus the metrics only measure the explicit definitions. Our work is different, because we look for implicit concepts which are hidden in combinations of model elements. In addition, we are analyzing language definitions and therefore we study the relation between modeling concepts, abstract syntax, and concrete syntax, which is certainly not applicable to UML class diagram models.</p><p>In <ref type="bibr" target="#b104">[92]</ref> and <ref type="bibr" target="#b30">[18]</ref> various metrics for ontologies are discussed which mainly measure the structural dimension in the same way as with OO models reflecting the fact that most ontologies are also represented in an object-oriented manner. Additionally to the structural measurement in Gangemi et al. <ref type="bibr" target="#b45">[32]</ref> measurements for the functional dimension and usability, as well as a NLP-driven evaluation are introduced. Furthermore, the OntoClean approach <ref type="bibr" target="#b99">[87]</ref> tries to detect both formal and semantic inconsistencies in an ontology. This perception goes along with our that counting the number of elements of certain types is not sufficient to specify the complexity of a model.</p><p>Our work is different to the proposed ontology metrics in that with our metric we are able to indicate how many concepts are implicitly represented which is due to the exploitation of the abstract to concrete syntax mapping which is metamodeling depending and not an ontology topic. Nevertheless, many ontology techniques are promising for the semantic evaluation of models and metamodels which is subject to future work.</p><p>The most related work is <ref type="bibr" target="#b51">[38]</ref> in which OO metrics are applied to assess five versions of UML metamodels. The authors propose metrics for the stability of UML metamodels and for the design quality of UML metamodels such as reusability, flexibility, and understandability, which are computed from single measures.</p><p>Our work is different due to two facts. First, we also incorporate the CS of the modeling language, and second, we analyze which modeling concepts are missing in the abstract syntax as first class definitions. However, it is interesting that in <ref type="bibr" target="#b51">[38]</ref> the computed value for understandability of UML 2 is much worse compared to its predecessor. Furthermore, it would be very interesting to compute the measurements for the design quality before and after applying our proposed refactoring patterns as introduced in <ref type="bibr" target="#b54">[41]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Requirements for Example Models</head><p>So far we have not explained how our MTBE approach works in detail. However, we have to discuss the requirements we put on our example models in order to generate transformation code nearly without any user interaction, i.e., on a semi-automatic basis. Basically there is no limitation on the number of example models the user may want to specify for a specific transformation scenario between two different modeling languages. There can be either one big example or many small ones to foster clarity and traceability. Information from all examples is gathered and reasoned, though. A must in any case is the coverage of all relevant concepts available in the modeling languages. We also assume that tooling exists, which fully supports a modeling language. This means that a complete mapping between AS and CS is available by a proper notation as described earlier in Section 3.5. A concept on the modeling layer M1 must therefore be represented by a tool creating a CS element, which has a 1-to-1 or 1-to-many mapping to some AS elements. Special forms of implicit concepts on the modeling layer is discussed in Section 7.2. Besides this simple rule of using every concepts available in the example models we have experienced problems when using modeling structures made possible by the use of links between objects. Sometimes it is not sure how elements should be linked together or what linking structures should be supported. In the following example we deal with a nesting problem.</p><p>Example 31. Figure <ref type="figure">3</ref>. <ref type="bibr" target="#b28">16</ref> shows two examples of modeling languages simpleUML on the left and simpleER on the right side. Below these examples we show the corresponding metamodels that slightly differ in size. But excepts for this difference in meta elements used for modeling the two languages, we can in general model the same problem domains in either simpleUML or simpleER. As a consequence we do not loose any relevant information when transforming from simpleUML models to simpleER models and vice versa. By the blue dashed lines we depict the notation for the CS and AS elements of interest, only. We omitted to map the concepts of Attribute and also to define the Enum by a proper EEnum instance in the simpleUML metamodel. Notational mappings 3 and 4 can be seen as equivalent, as are the concepts of Class and Entity. So we can define or generate a rule, which transforms Classes into Entities with their corresponding name Attribute, see Listing 3.1, second ATL rule. In Ecore models we must have a model root element, which can be for example the name of a diagram. In our case we simply named it Root for both languages. There can be just one instance of Root containing all other modeling objcts. So the first challenge is to assign proper values to the containment references of these Root elements during transformation. We can use ATL's built-in resolve algorithms for this challenge. Line 7 demonstrates how reference sets can be correctly assigned and bypass instances of Package, which lie between a Root instance and some Class instances in simpleUml. The output of this transformation is depicted in Listing 3.2, which shows the output simpleER model serialized as XMI. As can be seen we have transformed all classes from the source simpleUML model into Entities but the intended containment structure has been broken. This arises from the fact that we do not cope with subpackages and their child Classes. Figure <ref type="figure">3</ref>.17 shows an nearly identical example as in Figure <ref type="figure">3</ref>.16. Though, they differ in the sim-pleUML model. In Figure <ref type="figure">3</ref>.17 we provide an additional subpackage called Space within our basepackage StarWars on M1. The notation of this subpackage concept is given by mapping number 4. With this additional element in our example model we can derive proper ATL code, which includes the subpackage concept. We do not go into reasoning details in this section but in 5. The contribution of this chapter is to lay out basic concepts for MTBE for defining mappings on the M1 layer between concrete domain models. Based on these user mappings between concrete syntax elements and the notation included in the modeling languages we are able to derive model transformation code based on the M2 layer. In addition, challenges are discussed which are encountered, when generating model transformation code from the user defined inter-model mappings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Requirements for Example Models</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Shortcomings of Current Model Transformation Approaches</head><p>In the MDE research field various model transformation approaches have been proposed in the previous 5 years, mostly based on either a mixture of declarative and imperative rules such as ATL <ref type="bibr" target="#b53">[40]</ref>, or on graph transformations such as AGG <ref type="bibr" target="#b94">[82]</ref>, Fujaba <ref type="bibr" target="#b74">[62]</ref>, <ref type="bibr" target="#b73">[61]</ref>,</p><p>and BOTL <ref type="bibr" target="#b23">[11]</ref>, or on relations such as MTF <ref type="bibr" target="#b50">[37]</ref>. Moreover, the Object Management Group (OMG) has published a first version of QVT <ref type="bibr" target="#b82">[70]</ref> which should become the standard model transformation language. Summarizing all these approaches, it can be said that state of the art for defining model transformations is to describe model transformation rules between a source and a target metamodel (M2 layer), whereas the rules are executed on the model layer (M1 layer) for transforming a source model into a target model. Consequently, each of these approaches is based on the abstract syntax of modeling languages, i.e., on their metamodels, only, and the notation of the modeling language is totally ignored.</p><p>In collaboration with the Austrian Ministry of Defense and based on experiences gained in former integration scenarios <ref type="bibr" target="#b100">[88]</ref>, <ref type="bibr" target="#b86">[74]</ref> we are currently realizing a system called Mod-elCVS <ref type="bibr" target="#b55">[42]</ref> which aims at enabling tool integration through transparent transformation of models between metamodels representing different tools' modeling languages. Hence, we developed various model transformation examples for tool integration purposes using some of the aforementioned approaches, and in doing so, we discovered two main issues which prevent the user-friendly definition of model transformations. On the one hand there is a gap between how the modeler reasons about aligning two models and how the corresponding rules are defined in order to be executable by the computer, and on the other hand not all concepts of a modeling language supported by the concrete notation are explicitly represented in the metamodel. In the following we discuss these two issues in more detail.</p><p>Issue 1: There is a huge gap between the user's intention of aligning two languages and the way model transformation rules are defined for being automatically executable by the computer. Mostly, the user reasons on models representing real world examples shown by concrete notation elements and mappings between semantically corresponding model elements. However, this way of thinking is not appropriate for defining model transformations with currently available model transformation languages, because they support defining model transformation rules based on the abstract syntax, only.  <ref type="figure" target="#fig_35">4</ref>.1 depicts that for the user it is appropriate to reason on models representing real world examples expressed in concrete notation of the modeling language to find the semantic equivalent parts. In contrast, the lower half of Figure <ref type="figure" target="#fig_35">4</ref>.1 shows the same domain model in abstract syntax visualized as an UML object model. As one can see, the abstract syntax is designed for the computer in order to process the models efficiently and not for the visualization of the domain knowledge in an easy understandable way. Hence, when trying to understand a domain model in abstract syntax one has to explore more model elements compared to the concrete notation representation, and furthermore, one has to know all relevant details of the metamodel, i.e., the language definition. Moreover, this problem is further aggravated by the following issue.</p><p>Issue 2: The aim of metamodeling lies primarily in defining modeling languages in an object-oriented manner leading to efficient repository implementations. This means that in a metamodel not necessarily all modeling concepts are represented as first-class citizens. Instead, the concepts are frequently hidden in attributes or in association ends. We call this phenomenon concept hiding. For an in-depth discussion of concept hiding and how concepts can be hidden see <ref type="bibr" target="#b54">[41]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Shortcomings of Current Model Transformation Approaches</head><p>As an example for concept hiding in metamodels consider Figure <ref type="figure" target="#fig_35">4</ref>.2. In the upper part it shows a simplified version of the UML metamodel kernel which is defined in the UML Infrastructure <ref type="bibr" target="#b77">[65]</ref>. In the lower part a domain model is shown in concrete UML syntax as defined by the notation tables in the UML Superstructure <ref type="bibr" target="#b79">[67]</ref>. As one can see in Figure <ref type="figure" target="#fig_35">4</ref>.2, the metamodel covers more than 10 modeling concepts but uses only four classes. Hence, most of the modeling concepts are implicitly defined, only. It is left as an exercise to the reader to find out where and how the concepts attribute, navigable role, non-navigable role, and multiplicity are defined in the metamodel. These two issues mainly circumvent the user-friendly definition of model transformations. Therefore, we propose an orthogonal and extending approach to existing model transformation approaches for defining semantic correspondences in the concrete syntax of the models and the automatic generation of model transformations for the abstract syntax. This procedure allows a more user-friendly development of model transformations. Before going into details about the by-example approach we have to discuss which tasks are currently involved when model transformations are developed.</p><p>In general, before actually formalizing the model transformation rules in a model trans-  formation language the user has to acquire knowledge about semantic correspondences between the concepts of the modeling languages as incorporated in their metamodels. One appropriate way to gain this knowledge is to start modeling the same problem domain with both modeling languages. By comparing the two resulting models the semantic correspondences between model elements can be easily found which again can be used to derive the correspondences between the metamodel elements. In addition, these models entail another benefit -they can be deployed for testing purposes as input for the expected model transformation and for comparing the output of the model transformation execution.</p><p>After clarifying all necessary semantic correspondences the user has to implement the gained mapping knowledge in the model transformation rules. For this task the user has to understand how the notation is represented in abstract syntax elements and how missing concepts in the abstract syntax can be reconstructed, e.g., by setting attribute values and links to other objects. Here comes MTBE into play. First, the mappings are explicitly definable between the domain models shown in concrete syntax which allows also the documentation of the semantic equivalences. Second, these mappings are a good starting point for automatically generating the required model transformation code which is more efficient in contrast to current approaches where the user has to implement all of them by hand.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">A Five Step Process for MTBE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">A Five Step Process for MTBE</head><p>This section discusses a conceptual five step process for MTBE at a glance. The key focus of this process is the automatic generation of transformation programs regarding semantic correspondences between two languages as can be seen in Figure <ref type="figure" target="#fig_35">4</ref>.3. In this framework the model transformation generation process requires 5 steps, that are explained in the following. Each step is thereby marked properly in Figure <ref type="figure" target="#fig_35">4</ref>.3.</p><p>• Step 1. The initial step is the definition of models of the same problem domain in both modeling languages (cf. left and right of the lower half of Figure <ref type="figure" target="#fig_35">4</ref>.3 1). The user can decide if a single model, which covers all aspects of the languages, or several examples, each focusing on one particular aspect. Presumably the second approach is more preferable. The requirements on the models are twofold. First, certainly they must conform to their metamodels. Second, concerning completeness, all available modeling concepts of the modeling languages should be covered by the models. The second issue is closely related to the question of what appropriate test cases for model transformations are, which is e.g. discussed in <ref type="bibr" target="#b42">[29]</ref>. However, the requirements for example models and what difficulties arise in conjunction with model and metamodel heterogeneities have been already discussed in Section 3.2.</p><p>• Step 2. The second step in the framework is that the user has to align the domain models (M1) by defining semantic correspondences (mappings) between model elements of the left and right side (cf. middle of the lower half of Figure <ref type="figure" target="#fig_35">4</ref>.3). For simplicity, it is assumed that the models on the left and on the right side represent the same problem domain, as explained in step 1. In this Chapter of basic MTBE concepts we assume full equivalence mappings, only. However, in Chapter 5.1 we introduce other mapping language concepts, which allow for more expressiveness and dealing with more complex mapping scenarios.</p><p>Concerning the example models, general reference models for several modeling domains such as structural, interaction, and process modeling can ease the development of the required examples. However, this part is also subject to future work.</p><p>• Step 3. After finishing the mapping task, the third step is that the MTBE Generator (cf. MTBEGen in Figure <ref type="figure" target="#fig_35">4</ref>.3) takes the user-defined mappings as input and produces equivalences between metamodel elements. The output of this particular task should be a complete mapping model between the two given metamodels.</p><p>• Step 4. Based on the generated metamodel mappings the MTBEGen component has to produce an executable transformation program, which is based on metamodel elements. The resulting model transformation programs can transform any source model, which conforms to the source metamodel, into a target model, which conforms to the target metamodel. However, as we explain later in this Chapter , the generation process may need some user interactions for resolving ambiguities in the mappings, arising from heterogeneities concerning the extend of the modeling languages. Another necessary condition for the transformation generation process is that the MTBEGen needs access to the package as_2_cs (cf. Figure <ref type="figure">3</ref>.12 Section 3.5) in order to compute all necessary conditions for the query and property values for the generation parts of the transformation rules.</p><p>• Step 5. At last the generated transformation programs may need some user refinement for resolving ambiguities in the mappings, arising from heterogeneities concerning the extent of the modeling languages. Also it is possible to subsequently test the generated model transformation programs or transformation models on the the models, that were already used for defining the mappings between the two languages. This is another benefit of the by-example approach, as the input and output models for testing the model transformations are already available and no extra work for developing test cases is necessary. The target models generated by the transformation program can be compared to the already existing models. When some differences between the two models arise, the user can decide if the mappings on M1 should be revised and a newer version of the model transformation program should be generated or if the mappings on M1 are correct and the model transformation needs some fine-tuning directly in the transformation code. To act as a good test case is one of the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">A Running Example</head><p>User-defined Mapping </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">A Running Example</head><p>We exemplify the operating mode of MTBE by a concrete running example. In order to do so, consider the situation in which we have two UML classes Professor and Student as well as a one-to-many relationship between them. This simple UML class diagram is depicted in the upper left corner of In the following subsections the steps 2 and 3 of the MTBE framework (cf. Figure <ref type="figure">6</ref>.3) are discussed in more detail. Step 2 has to be carried out by users themselves and concerns the alignment of two domain models shown in concrete syntax (cf. subsection 4.4.2). Step 3 is split into 4 sub-steps, to give an in-depth discussion of the work the MTGen has to do. In particular, we explain how the abstract syntax is analyzed to collect all necessary data for the model transformations. Therefore, we interpret the models shown in abstract syntax as object models consisting of objects, attribute values and links, because these models can be seen as instances of the metamodel, which again can be seen as a simple class diagram. Consequently, we first explain the creation of objects (cf. subsection 4.5.1), then the placement of attribute values (cf. subsection 4.5.1), and finally the linking of objects (cf. subsection 4.5.1). By collecting the data of these three sub-steps, it is possible to derive all necessary information in order to define the query parts (e.g., the from part of ATL rules) and also the generation parts (e.g., the to part of ATL rules) of the model transformation rules (cf. subsection 4.5.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">MTBE Frontend -The Black-Box View</head><p>By MTBE frontend we mean the graphical user interface, i.e., the workbench the user is confronted, when she decides to apply MTBE on some transformation scenario. Figure <ref type="figure" target="#fig_35">4</ref>.5 shows the basic workbench vision that acts as our design prototype for an Eclipse-based implementation. We have identified four major views that have to be presented to the user in some perspective or view. The top level view and most important to the transformation designer is the model mapping view, which she can draw the mappings between graphical CS elements in an appropriate editor. After a reasoning process the produced metamodel mappings can be viewed in a separate editor. This not only allow the view of metamodel mappings but also their modification. The third part of the MTBE perspective shows the generated transformation code, i.e., the ATL code automatically produced from the metamodel mappings. And our last view component is associated with the models that have been the outcome of the generated model transformation program. This allows the testing of the ATL code and eases the correction of errors by manual refinements in one of the upper three view components depicted in Figure <ref type="figure" target="#fig_35">4</ref>.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Model Mapping</head><p>The main purpose of our frontend is to allow the definition of model mappings, i.e., to map elements of different modeling languages.</p><p>But what is a model mapping? Naumann and Leser [48] define a schema mapping to be a set of correspondences between an arbitrary number of attributes of different schemas.</p><p>Following this definition we can use the term correspondence and mapping equally. Furthermore, such mappings define a semantic correlation between mapped elements. There exist basically two ways to obtain mappings between models and schemas. One of these techniques is matching, which is an automatic task done by a tool following predefined matching strategies. See for example <ref type="bibr">[6]</ref>. The second technique is defining mappings manually. This is the procedure we have chosen in our MTBE frontend. There are four different value correspondences available, i.e., 1 : 1, 1 : n (split), n : 1 (merge) and m : n. Value correspondences can further be annotated with transformation functions, which can perform some calculations or string manipulations.</p><p>Naumann defines two kinds of usage for mappings in general that can be directly adopted for model mappings. First, we can use mappings for the representation of knowledge and thus for some model integration task. And second, we can use value correspondences as the basis for a more complex task, i.e., the transformation of models. Often a fundamental problem of correspondences stems from the lack of a semantic foundation. Without having the semantics of mappings defined tool support is often not reliable in terms of transformation correctness criteria.</p><p>In MTBE we basically face the same problem of lacking semantics for model mappings. But we can argue first that a model mapping has not always one specific semantic meaning 4.4 MTBE Frontend -The Black-Box View these mappings can be regarded as bidirectional in contrast to other by-example transformation approaches, e.g., <ref type="bibr" target="#b60">[47]</ref>. Hence, model transformation code can be generated for both directions, namely from UML to ER, and vice versa.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.3">Validation of Transformation Code and Produced Output Models</head><p>The task of validation is very closely related to testing. First we have to ask: what can be validated? We can validate transformation code, i.e., the transformation model produced by MTBE, and the (meta)models involved in the transformaton process. However we can only check for syntactical correctness with models. Semantic validation is not possible as their exists in most cases no formal specification of metamodels yet. Most prominent example for a missing formal semantic specification is the UML. Hence, we can only check for syntactic correctness.</p><p>Validation can either be done manually by the user or automatically with tool support. We briefly discuss both ways, but won't go into detail as the validation and testing field for transformations and their are research areas of its own. However these topics are vital for the success of model transformation approaches and can be seen as major requirements.</p><p>Manual Validation. Generated transfromationcode can be reviewed by the programmers themselves and validated by executing the code with some input models and afterwards comparing with the output models. By again executing the transformation the other direction having now the output models as inputs one can aim at a full round trip. If information gets lost this is directly visible and the user can start with a refinement process, which may start at the model mapping layer and can finally reach the code layer, i.e., the transformation model derived by MTBE. A great benefit stems from the fact that test models are already available as they have been specified during step 1 of the MTBE process. Therefore the cost of time creating proper test cases for transformation code testing is reduced. However, additional critical test cases must be provided if they exist. Automatic Validation. Automated testing is one of the key features in model transformations. Especially the graph grammar based approaches suffer from termination and uniqueness issues arising during rule execution. For an in depth discussion on syntactical correctness criteria, termination and confluence see for example <ref type="bibr" target="#b58">[45]</ref>. In this work Küster presents a graph transformation approach and how validation on the transformation rules can be achieved. Sadilek et al. <ref type="bibr" target="#b85">[73]</ref> are especially concerned with the testing of metamodels, but similar approaches acting upon models are possible. In Fleurey et al. <ref type="bibr" target="#b42">[29]</ref>, the authors discuss the usefulness and appropriateness of input models of some model transformation program. They define rules and a framework that help the user to design sound input models. These rules could be integrated into MTBE as supporting technology.</p><p>But there are several tasks the user can perform independently from these rather sophisticated approaches in order to test the transformation code. Input and output models must Chapter 4 Basic MTBE Concepts conform to their respective metamodels. If any model is produced that does not conform to the well-formedness rules of the metamodel we have indication for an error in the transformation code. Similarly the transformation model can be checked against the transformation metamodel or the textual concrete syntax can be parsed for syntax errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">MTBE Backend -The White-Box View</head><p>In contrary to the frontend presented in the previous Section, we now take a closer look at what happens behind the curtain. It is about the MTBE "engine", that tries to generate executable transformation code. The aim of this Section is to layout how this automatic process works and what the basic ideas have been at the beginning of the development of our MTBE approach. The term white-box view refers intuitively to everything that is part of the program, the internal system.</p><p>The MTBE process outline in Figure <ref type="figure">6</ref>.3 shows the backend related tasks or process steps 3 and 4. Step 3 can now be split up into 4 sub-steps, to give an in-depth discussion of the work the MTBEGen has to do. In particular, we explain how the abstract syntax is analyzed to collect all necessary data for the model transformations. Therefore, we interpret the models shown in abstract syntax as object models consisting of objects, attribute values and links, because these models can be seen as instances of the metamodel, which again can be seen as a simple class diagram. Consequently, we first explain the creation of objects (cf. subsection 4.5.1), then the placement of attribute values (cf. subsection 4.5.1), and finally the linking of objects (cf. subsection 4.5.1). By collecting the data of these three sub-steps, it is possible to derive all necessary information in order to define the query parts (e.g., the from part of ATL rules) and also the generation parts (e.g., the to part of ATL rules) of the model transformation rules (cf. subsection 4.5.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.1">Basic Reasoning on User Mappings By-Example</head><p>Second, we need to know how the model elements shown by the concrete syntax correspond to the model elements shown by the abstract syntax. These definitions are provided by the package as_2_cs as described in section 3.5. The links between concrete syntax and abstract syntax are illustrated in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61 as thin solid arrows for the right and for the left side, respectively. Again we left out some of the links to focus on the mapping definitions which are relevant for the following discussions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Object Creation</head><p>As we defined semantic correspondences between model elements of the two domain models in the previous step, we can now move on to the object creation process. Assume first 4.5 MTBE Backend -The White-Box View that we want to transform the UML class diagram into an ER diagram. Therefore, the algorithm has to analyze the abstract syntax of both models and additionally the user-defined mappings. In particular, the algorithm has to check if a certain type of object in the UML model is mapped to a certain type of object in the ER model. If this is the case, there is also a full equivalence mapping on the abstract syntax layer and a simple transformation rule without a condition can be generated for this object type. For example, objects of type class are mapped to objects of type entity (cf., mapping a in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61), only. However, some objects of the same type are mapped to different object types depending on their attribute values and links. In this case, an additional mapping operator is available for the abstract syntax layer, namely conditional equivalence mapping. The conditions for the conditional equivalence links are derived from the as_2_cs package, i.e., the concept hiding is resolved, and finally these conditions manifests in the query part of the model transformation rules. For example, property objects of the UML class diagram are mapped to both attribute objects (cf., mapping b in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61) and role objects (cf., mapping d in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61) of the ER model. Taking the constraints property.owningClass != null and property.association == null of the as_2_cs package into account, we can assure that only an ER attribute is generated when the property actually represents an attribute in the UML class diagram. The same procedure can be applied for properties representing roles.</p><p>After completion of this step we have created all necessary objects for an ER diagram from a UML class diagram, which are the basis for our next steps to be performed. The same procedure can also be applied for a ER diagram to an UML class diagram transformation as our transformations can be generated in either direction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Placement of Attribute Values</head><p>This step constitutes the placement of attributes values for the created objects. In contrast to the object creation step where primary the query parts of the transformation rules were relevant, this subsection focuses on the generation parts, i.e., how to set the attribute values. First of all, we have to differentiate between two different kinds of attributes which occur in metamodels, namely ontological attributes and linguistic attributes.</p><p>Ontological attributes represent semantics of the real world domain which can be incorporated by the user by setting the values explicitly in the concrete syntax. Examples for ontological attributes are Class.name and Attribute.name. In order to set the ontological attributes in the generation part of the transformation rules we use heuristics, e.g., string matching. In our example, we can conclude that the name of a class should be the name of an entity when considering the class professor and the entity professor (cf., mapping b in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61), because these two attributes have the same value. Linguistic attributes are used for the reification of modeling constructs which cannot be set explicitly by the user in the concrete syntax, e.g., Class.isAbstract or Property.aggregation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 4 Basic MTBE Concepts</head><p>Hence, these attributes have predefined ranges of values as they are fixed elements of the language definition. When dealing with linguistic attributes in context of MTBE we need to exploit the information stored in the as_2_cs mappings, because in these mappings the concepts become explicit by defining the required condition, i.e., how the values have to be set to fulfill the requirements for the sub-concept. For example, when transforming an ER attribute to an UML property, we also have to set the linguistic attributes of the property class (e.g. Property.aggregation) which can be done by incorporating the information stored in the as_2_cs mapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Linking Objects</head><p>Finally the links between the created objects have to be deduced from the metamodel, from our triples of the as_2_cs mappings containing OCL constraints, from the user-defined mappings, and user interaction as the last choice when the last three mentioned options are not sufficient. This part of the transformation step is obviously the most interesting one, as most difficulties arise at this stage. In particular, the user-defined mappings on the concrete syntax can result in ambiguous mappings, i.e., mappings that are controversial and it is not automatically decidable which case should be chosen for the general model transformation. Especially 0..1 associations in combination with xor-constraints in the metamodel are relevant in this context, as they might entail some hidden concepts. Another reason of unambiguous mappings is the heterogeneity of the expressiveness of the modeling languages.</p><p>In the following the creation of object links is described, whereby we classify some interesting cases regarding to multiplicity of the association ends of the metamodel, namely 1..1, 0..1 and 0..1 in combination with xor-constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Unambiguous Mappings</head><p>Concerning unambiguous mappings, we discovered two interesting cases, namely association ends with multiplicity 1..1 and 0..1.</p><p>• 1..1 association ends: We encounter such association ends in our ER metamodel between Entity and Attribute as can be seen in the bottom of Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61. In addition, when looking at the middle of Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61, one can see, that each ER attribute is linked to an ER entity as this is the mentioned constraint of the ER metamodel. Furthermore, one can see that each UML attribute is linked to an ER attribute and that the containing UML class is linked to the containing ER entity, respectively. Consequently, if we transform an UML property, that is actually an attribute, into an ER attribute, we can automatically create the link between entity and attribute.</p><p>• 0..1 association ends: This kind of association ends in the metamodel allows concept hiding, as is done in the UML metamodel for the class Property. A property can either be a special kind of role or an attribute belonging to a certain class. As we will 4.5 MTBE Backend -The White-Box View see, association ends of this kinds are not as easy decidable as 1..1 association ends are, because the links are not required on the abstract syntax layer and can vary, also within the same example. However, in case of unambiguous mappings, i.e., the link is always or never present on the abstract syntax layer, a general model transformation rule can be derived. For example, ER relationship has two links to its roles and UML association has two links to its properties. Furthermore, ER relationship is mapped to UML association (cf., mapping c in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61) and the ER roles are mapped to the UML properties of the association (cf., mappings d and e in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61).</p><p>When going from ER to UML, we can deduce that each corresponding association should have links to the properties which correspond from the roles of the ER relationship. However, the second possible kind of link between association and role (cf. concerning association end owningAssociation in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61) is not automatically decidable as we see in the next subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ambiguous Mappings</head><p>In this part we describe an example that shows that especially for object linking some ambiguities can occur which have to be resolved by user interactions.</p><p>In Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61 two user-defined mappings are shown, which are the source for ambiguity mappings on the abstract syntax layer. In this example the role examinee in the ER model is mapped to the navigable role examinee in the UML class diagram, but the role examiner is mapped to the non-navigable role examiner in the UML class diagram. Now we want to discuss the impacts on the abstract syntax layer mappings. The problem arises that it is not decidable which general transformation rule should be derived, because one role of the ER model is mapped to an UML property, which has a link to an class object (cf., mapping e in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61), and another role of the ER model is mapped to an UML property which has instead an link to an association object (cf., mapping d in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61). This unambiguity results from the metamodel of UML where an xor-constraint exists between owningAssocation and owningClass, as can be seen in Figure <ref type="figure" target="#fig_35">4</ref>.4 page 61, and from the fact that UML differentiates between navigable role and non-navigable role without supporting the general role concept. As our definition of the ER metamodel does not allow for two different kinds of roles as the UML metamodel does, we cannot derive an general transformation rule. Instead the user must decide on how to deal with roles from the ER model in the UML model. This example shows that in general it is not possible to automatically derive all model transformation rules, not even between modeling languages, which share the same modeling domain. Instead, for some rules the user has to interact and decide, which alternative is appropriate, such as in our example to generate navigable roles in the UML model for roles of the ER model. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.2">Metamodel Mapping</head><p>Abstract Syntax. In the above we have already discussed how we can derive metamodel mappings based on the information given by the user and how these mappings look like. For the sake of completeness and we present the AS for our metamodel mapping language in Figure <ref type="figure" target="#fig_35">4</ref>.8. Also we explain in the next chapter how this language can be extended to ease the generation of model transformation code. Figure <ref type="figure" target="#fig_35">4</ref>.8 shows that the central mapping element is the abstract class EquivalenceMapping, which concrete mapping classes inherit from, i.e., ConditionalEquivalenceMapping and FullEquivalenceMapping. So this abstract root class acts as extension point for more specialized metamodel mapping operators. We also include the Ecore package here to be able to reference any AS element used in our metamodels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.3">Transformation Model Generation By-Example</head><p>At last all gathered information can be aggregated to generate proper ATL transformations. In the following, two examples are shown just to give an idea how the query parts and generation parts of the ATL transformations are generated.</p><p>The first example as presented in Listing 4.1 is a transformation from ER attributes to UML properties, which actually represent UML attributes in the concrete syntax. Note that the generation part of this rule is the most interesting part, because the attribute value assignments for ontological and linguistic attributes have been automatically generated. The second example shown in Listing 4.2 is an ATL rule that incorporates the condition of the abstract to concrete syntax mapping for UML in its query part in order to produce ER attributes for UML properties which are actually representing UML attributes on the concrete syntax layer, only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">MTBE-Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">MTBE-Related Work</head><p>With respect to our approach of defining inter-model mappings between domain models (M1) and the derivation of model transformation code from these mappings we distinguish between three kinds of related work: first, related work concerning on linking model elements between models within a separate model (model weaving), second, declarative and example-based transformation rules mainly supported by graph transformations and third, related by-example approaches starting from their origin approach, namely queryby-example.</p><p>In general, our approach of defining similarities between modeling languages and models is related to model transformation. Model transformation in the context of MDE is a rapid emerging topic as can be seen in the model transformation workshop at the MoDELS/UML 2005 conference. One of the first and nowadays one of the most matured approaches is the ATLAS Model Weaver (AMW) <ref type="bibr" target="#b39">[26]</ref> and the ATLAS Transformation Language ATL <ref type="bibr" target="#b53">[40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 4 Basic MTBE Concepts</head><p>The idea behind model weaving is to define a relationship between a left model (or metamodel) and a right model (or metamodel) with certain kind of mapping operators which can also be user-defined. This approach is related to the mapping between two concrete domain models of two different modeling languages, however, the difference lies in the representation of the models and in the level of the mappings. AMW works with the abstract syntax representation of a model, while our approach works with mappings between models represented with the concrete syntax of the modeling languages. The benefit of mapping examples shown in concrete syntax is the absence of hidden concepts which occur quite often in metamodels. Our work is also different to the AMW in that the model transformation generation process of the AMW currently focuses on using mappings between metamodels (M2 mappings) and therefore based on the abstract syntax as input to derive ATL code <ref type="bibr" target="#b52">[39]</ref>, while our approach aims at generating model transformation code from M1 mappings. Hence, we have shifted the definition of the mappings from the abstract syntax to the concrete syntax and from the metamodel layer to the model layer.</p><p>Our proposed MTBE approach follows the main principles of the query by example (QBE) approach introduced in <ref type="bibr" target="#b105">[93]</ref>. The aim of QBE is to have a language for querying and manipulating relational data. This is achieved by skeleton tables, which consists of example rows filled out with constants, constraints, and variables, combined with commands. Commands describe what to do with the selected tuples that match the defined queries, such as deletion or selection of the tuples. In order to operate on relational data stored in DBMS, real queries (e.g., SQL scripts) are derived from the skeleton tables and can be executed on relational models. Lechner et al. <ref type="bibr" target="#b60">[47]</ref> follow this original approach of QBE, but with extensions for defining scheme transformers, which is demonstrated in the area of web application modeling with WebML <ref type="bibr" target="#b27">[15]</ref>. Therefore, the original QBE approach is extended by introducing in addition to the query part (WebML model before transformation) also a generation part (WebML model after transformation) in the template definitions. Finally, XSLT code is generated to transform the WebML models which are represented within the accompanying tool WebRatio as XML files.</p><p>Our work reuses the main idea of the aforementioned by-example approach <ref type="bibr" target="#b60">[47]</ref>, but our work is different to this work in that first, we propose the use of real world examples instead of using abstract examples, second, we introduce bi-directional mappings in contrast to uni-directional template based examples, third, our domain for applying a by-example approach is the modeling technical space <ref type="bibr" target="#b59">[46]</ref>, while the others are based on relational data, and fourth, we also consider the abstract syntax to concrete syntax mappings to tackle the problem of implicitly defined modeling concepts and are therefore able to make them explicit.</p><p>Other by-example based approaches related to our proposed MTBE approach are programming by-example <ref type="bibr" target="#b84">[72]</ref>, <ref type="bibr">[3]</ref>, and <ref type="bibr" target="#b37">[24]</ref> as well as XSLT style sheet generation by-example <ref type="bibr" target="#b83">[71]</ref>. The objective of these approaches is to facilitate the end user to be able to perform tasks 4.7 Summary which normally need more knowledge, e.g., knowledge about programming languages like Visual Basic, Java or even XSLT. The way PBE tries to to achieve this objective is to record the users actions (e.g., by a trace model) maybe in more than one iteration, and generate a program from the trace models to automatically perform the afore manually performed task by the computer.</p><p>The difference to the programming by-example approaches is that we statically define the mappings between two models instead of the iterative adaptation of the examples to get the resulting code, in our case the ATL code.</p><p>Parallel to our MTBE approach Dániel Varró proposed in <ref type="bibr" target="#b96">[84]</ref> a similar approach. The overall aim of Varró's approach is comparable to ours, but the concrete realizations differ from each other. With our basic MTBE approach we describe the definition of semantic correspondences on the concrete syntax, which are propagated to the abstract syntax. From these mappings ATL rules can then be derived. Varró's approach uses the abstract syntax to define the mappings between source and target models, only. The definition of the mapping is done with reference nodes leading to a mapping graph. To transform one model into the other, graph transformation formalisms <ref type="bibr" target="#b38">[25]</ref> are used. However, both approaches generate model transformation rules semi-automatically leading to an interactive and iterative process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Summary</head><p>In this chapter we have introduced a basic by-example approach for defining semantic correspondences between domain models shown in their concrete notation, that allows the derivation of model transformation code. This approach tackles concept hiding in metamodels, which results in complex query and generation parts of model transformation rules. Furthermore, the user can reason about semantic correspondences in a notation and with concepts the user is familiar with. Hence, metamodel details resulting from the need for efficient API and repository implementations are hidden from the user.</p><p>We have presented relevant issues concerning MTBE, however, various extensions of the presented concepts are discussed in the following chapters, e.g., application on larger modeling languages, also from other modeling domains and full elaboration of the so far gained insights. In particular, MTBE requires proper tool support and methods guiding the mapping and transformation code generation tasks in order to fulfill the requirements for the user-friendly application of MTBE. Therefore, Chapter 6 then elaborates on an implementation of a prototype in order to be able to evaluate our proposed approach in the large. In the previous chapter we have introduced MTBE and how it is split up into five distinct task comprising the MTBE process. Nevertheless, extensions and advanced concepts for MTBE are needed to face more complex integration scenarios than the one considered in Section 4.3. In particular, we develop additional mapping operators, both on the M1 layer and the M2 layer to capture and store more integration knowledge for the final code generation using higher order transformations. Also, we do reasoning on models and metamodels by means of pattern matching in a heuristic way and by means of reasoning algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 5</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Advanced MTBE Concepts</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Adding Expressiveness to the Model Mapping Language</head><p>In this section, we present a refined version of our model mapping language by first introducing its AS and subsequently its CS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract Syntax.</head><p>The metamodel for the model mapping language defines all mapping concepts that may be applied by the user to accomplish the task of bridging two modeling languages by means of mapping example models shown in their concrete syntax. The abstract root class ViewElement, depicted in Figure <ref type="figure">5</ref>.1, is in fact only for implementation convenience and to visualize that inheriting classes have an associated element on the view. The central class is the abstract class Mapping, that serves as basis for all kinds of connections relating two graphical model elements of source and target languages. The design of mapping ends in the metamodel (cf. references lhs and reference rhs) allows for all kinds  of mappings, i.e., one-to-one, one-to-many, and many-to-many. Elements of the languages to be integrated must have the corresponding abstract class LeftViewElement or RightViewElement as superclasses. How these requirements are realized within our MTBE approach is discussed in Subsection 6.2.2.</p><p>Actually, the remaining concrete classes form the bases for the concrete syntax of the mapping language, for which we defined a notation. However, the specification provided in Figure <ref type="figure">5</ref>.1 is not sufficient to completely determine the abstract syntax of our mapping language. There exist further well-formedness rules for model which have to be defined with the Object Constraint Language (OCL) for each concrete subclass of class Mapping.</p><p>Simple Mapping. The concept that allows the user to draw simple one-to-one mappings between any two concrete syntax elements is represented by the SimpleMapping class. Additionally, to restrict on 1..1 multiplicities, the following constraint is necessary.</p><p>context SimpleMapping inv: self.lhs -&gt; size() = 1 and self.rhs -&gt; size() = 1 Compound Mapping. To allow for one-to-many and many-to-many mappings, we introduced the CompoundMapping class. In order to complete the syntax specification the following constraint must hold for compound mappings.</p><p>context CompoundMapping inv: self.lhs -&gt; size() &gt; 1 or self.rhs -&gt; size() &gt; 1</p><p>Value Mapping. The classes ValueMapping and Expression constitute what was introduced as string manipulation operator <ref type="bibr" target="#b93">[81]</ref>. Whenever attribute values represented by 5.1 Adding Expressiveness to the Model Mapping Language labels are part of a mapping, it would be nice to have some sort of functions that can be applied to modify the participating attribute values appropriately. The container, which encapsulates the actual value mappings is the ValueMapping class, able to manage two lists whose elements point to a label. For each of these two lists, a function may be applied to. This function is stored within instances of Expression that supports e.g. the concatenation of values by accessing list elements through their index. A ValueMapping is however not self-dependent and thus must have a context specified, which can be either of type SimpleMapping or CompoundMapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XOR.</head><p>The last operator we have to specify is the XOR. While experience has shown, that an explicit XOR operator on the concrete syntax layer is not desirable in common use cases as it can be derived on the metamodel layer automatically, we include it in the mapping language description for sake of completeness. The Role mappings of XOR must be unique. For xor-ed simple mappings we must further specify context XOR inv: self.mappings-&gt; forAll(m | m.oclIsTypeOf(SimpleMapping)) inv: self.mappings.lhs-&gt; asSet()-&gt; size() = 1 xor self.mappings.rhs-&gt; asSet()-&gt; size() = 1 as a constraint. The first invariant says that this constraint can only be applied on mappings of type SimpleMapping. The second invariant is needed to further restrict the way XOR may be applied to SimpleMappings. More specifically we have to ensure that all SimpleMappings have on one side, i.e., either left-hand side or right-hand side, exactly one ViewElement in common. Example 32. An example of a wrong usage scenario of the XOR operator is given in Figure <ref type="figure">5</ref>.2(b). Figure <ref type="figure">5</ref>.2 also shows a valid application of XOR in (a). In (c) we depict the corresponding Object Diagram, which shows how serialization is done and gives a notion of how domain elements are mapped to ViewElements. In Chapter 6 we demonstrate how this mapping is done in tool support in practice.</p><p>For the type CompoundMapping a similar constraint may be specified.</p><p>Concrete Syntax. Above we have described the AS of our model mapping language. Now we briefly present what the corresponding CS of the model mapping language looks like. Figure <ref type="figure">5</ref>.3 depicts the notation tables for our mapping language. Each concrete class of our mapping language has a distinct CS element for defining model mappings. How these elements may be used in real world examples has been already presented in our previous work <ref type="bibr" target="#b93">[81]</ref> for business process models. In this thesis, see Section 7.1, we present a concrete application of the model mapping language for bridging structural modeling languages as well as business modeling languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Reasoning based Pattern Matching</head><p>Note this CS approach acts as a guideline. Implementation may slightly differ in some aspects. Also the semantic of our mapping language is only defined in natural language. A formal semantics is still missing and it is not clear yet in which way to define it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Reasoning based Pattern Matching</head><p>This subsection covers the conceptual step number three outlined in Subsection 4.2. Model transformations operate on the model level but need to be defined having knowledge how metamodel elements semantically correspond to each other. This is why we have to perform a movement from model mappings defined by the user up to metamodel mappings. Unfortunately, user mappings are in general not as accurate as metamodel mappings have to be in order to be used as input for the generation of model transformations. Model mappings usually consist of ambiguities mainly because of various structural and semantical heterogeneities occurring between different modeling languages and due to the userfriendly model mapping language.</p><p>To cope with the shift in "mapping space", we propose reasoning based on pattern matching. By applying any kind of predefined or custom-defined model pattern, we aim to create metamodel mappings from model mappings on an automatic basis. These metamodel mappings can be made persistent in a so-called mapping model, which allows to relate all kinds of metamodel elements. In the following, we present six core patterns that are illustrated in Figure <ref type="figure">5</ref>.4. The first three patterns operate on the model level (cf. M ⇔ M in Figure <ref type="figure">5</ref>.4) and produce an initial mapping model, whereas the last three patterns are based on the metamodel level (cf. M M ⇔ M M in Figure <ref type="figure">5</ref>.4) and aim at the refinement of the initial mapping model.</p><p>Initializer Pattern. The first pattern matches if classes, attributes, and references in metamodels are identical resulting in full equivalence mappings between metamodel elements. The basis for this pattern represents simple mappings between model elements and reasoning capabilities to check whether mapped objects (e.g., instance of class A and instance of class B in Figure <ref type="figure">5</ref>.4) have equivalent attribute values and links. With the help of this pattern, all simple equivalence mappings between two metamodels can be found. However, with this pattern it is not possible to resolve structural or semantical heterogeneities between modeling languages. For resolving such problems, we propose the following five patterns.</p><p>Pathway Pattern. The second pattern poses a challenge as alternate paths have to be found if someone wants to set the link from an instance of A to an instance of B when transforming from M to M . Analysis of the metamodel alone would not be sufficient, because metamodels might be nearly identical but the reference semantics are different. An analysis of both models represented in AS has to be performed to check for the existence of an equivalent path in M between an instance of C and an instance of D. Split/Merge Pattern. The third pattern illustrates the case, where two concepts are represented as two classes explicitly in one language, whereas these two concepts are nested within one class in the other language. As an example consider the UML class Property, that specifies the concept multiplicity as attributes, whereas in the ER metamodel the concept multiplicity is expressed explicitly as a class. This means, in transformations there is either a merge of objects and values or a split into separate objects. In principal, there is no restriction on the number of classes that need to be merged or splitted as long as they are somehow related and connected through references. Note that a merge of classes leads to concept hiding whereas a split makes concepts explicit.</p><p>Compound Pattern 1 -no structural connection. This pattern reasons about metamodel mappings which have been produced from compound mappings of the model level. In case no structural connection between instances of class A and class B can be found in the example model, then we simply define two independent classes A and B to be equivalent with one class C. This is the most trivial form of one-to-many mappings and leads to transformation rules which simply create two unrelated instances from one instance of class C.</p><p>Compound Pattern 2 -structural connection. This pattern also reasons about metamodel mappings produced for compound mappings of the model level and represents the opposite case of Compound Pattern 1 in the sense that a structural connection between instances of class A and class B can be found in the example model. Consequently, this pattern produces metamodel mappings which lead to transformation rules for creating two linked instances from one instance of class C. Choice Pattern. We encountered the case in which two distinct classes, such as class A and class B, are mapped to the one class C. This kind of metamodel mappings is produced for simple model mappings pointing from instances of one class to instances of several classes. Whenever this pattern is matched, further reasoning on the model represented in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Adding Expressiveness to the Metamodel Mapping Language</head><p>AS in combination with the CS definition is needed trying to distinguish between the concepts which are hidden. Again, consider our simple UML to ER integration scenario of Figure <ref type="figure" target="#fig_35">4</ref>.4. Instances of class Property represent on the one hand attributes when no link to an association instance is set and on the other hand roles when a link is set. This distinction is also represented in the CS of UML, thus the constraints can be reused to build the xor constraint between the metamodel mappings. If the feature comparison in combination with the CS definition does not yield any result, the user has to decide and adjust the metamodel mappings or transformation code manually.</p><p>The application of these core patterns is vital for the generation and refinement of the metamodel mapping model. The metamodel mapping language, see Figure <ref type="figure">5</ref>.5, allows at the moment only for full or conditional equivalence mappings. However, for model transformation generation purposes this metamodel can be extended with additional mappings to be able to contain further information generated by the analyzer component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Adding Expressiveness to the Metamodel Mapping Language</head><p>After applying the pattern matching on the model layer and the metamodel layer, we have to provide some way to store the retrieved information about semantic correspondences between metamodel elements. Conceptually, we have however spotted three possibilities to move from user mappings to executable transformation code:</p><p>1. Generate model transformation code in the course of pattern matching using a template based approach as supported by code generation frameworks.</p><p>2. Apply a Higher Order Transformation (HOT) <ref type="bibr" target="#b40">[27]</ref> containing the pattern matching capabilities for analyzing the model mappings and generate a transformation model.</p><p>3. Run the pattern matching on model mappings and produce an intermediate mapping model upon a HOT is executed for producing a transformation model.</p><p>We believe that an intermediate mapping model capturing the derived correspondences between metamodel elements is well suitable for MTBE due to the following reasons.</p><p>• Existing implementations using mapping models between metamodels (e.g., HOTs and graphical editors) can be reused.</p><p>• Using a HOT ensures that we do not leave the "modeling technical space".</p><p>• A mapping model between metamodels allows to keep track of the actual model transformation code generation. Thus, debugging is made easier. • Complexity is reduced by separation of concerns by splitting the task moving from model mappings to model transformation code into two separate tasks.</p><p>• Customized HOTs may be easily applied leading to extensibility.</p><p>Figure <ref type="figure">5</ref>.5 shows our basic mapping language for metamodels. The central concepts in this metamodel are represented by the classes ConditionalEquivalence and FullEquivalence used to distinguish between conditional equivalence mappings and full equivalence mappings. Equivalence mappings can additionally contain other mappings for specifying which reference mappings and attribute mappings belong to a certain class mapping. Note, that we do not categorize the mappings according to the types they reference. The task to interpret and act properly according to the types the mappings reference, is carried out by the HOT in a subsequent step. Furthermore, the metamodel for metamodel mappings is quite different in its structure compared to the model mapping metamodel shown in Figure <ref type="figure">5</ref>.1. The metamodel mapping language needs not to incorporate any usability and user-friendliness issues and can therefore contain any relevant information concerning the transformation model generation. For example, complex OCL conditions are also contained in the metamodel mapping model, cf. attribute condition in Figure <ref type="figure">5</ref>.5.</p><p>In fact, one has to make sure that no information reasoned during the pattern matching process is lost. The metamodel in Figure <ref type="figure">5</ref>.5 is to be seen as a core mapping language specification open for extension if necessary. This can be simply achieved by introducing additional subclasses of the abstract class EquivalenceMapping.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Advanced Reasoning Algorithms</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Advanced Reasoning Algorithms</head><p>There exist rudimentary reasoning mechanism for deriving simple object, attribute, and association equivalences from the abstract syntax of the models, the user defined mappings on the concrete syntax, and the mappings between the abstract and concrete syntax definitions. However, in the meantime we discovered, that these basic mechanisms are not applicable for all abstract syntax hetereogenities. Especially for association equivalences further reasoning mechanisms are required -also for models which have nearly the same metamodel structures. This topic has only be touched in Section 5.2 very briefly by the Pathway Pattern. Hence, in this section we discuss one instance of the additional reasoning algorithms, namely for finding equivalent queries for describing derived associations based on the example depicted in Figure <ref type="figure">5</ref>.6.</p><p>The upper part of Figure <ref type="figure">5</ref>.6 (M2 layer) illustrates simple metamodels for ER and UML, respectively. As one can see, the metamodel structures are nearly identical. The lower part of Figure <ref type="figure">5</ref>.6 (M1 layer) shows possible ER and UML models in abstract (M1(AS)) and concrete syntax (M1(CS)). In addition, in the concrete syntax layer the user defined mappings (grey dashed lines in Figure <ref type="figure">5</ref>.6), which are shown to explain how the reasoning algorithm works. Again, the structures of the models are nearly identical, but one important difference in the abstract syntax can be identified, which is not directly visible in the metamodel layer. In ER an EntityType is linked to its adjacent Role in contrast to UML where a Class is linked to its opposite Property, e.g, examinee:Role is linked to Student:EntityType in the ER model, but in the UML model the corresponding element examinee:Property is linked to Professor:Class and not directly to Student:Class which is the corresponding element for Student:EntityType. This linking convention is not accurately defined in both metamodel structures, however, some hint may be given by association end names such as owningClass in the UML metamodel or type in the ER metamodel. However, in order to explicitly define such linking conventions some informal natural languages description are necessary, for example as is done in the UML 2 specification <ref type="bibr" target="#b79">[67]</ref>. To tackle the automatical recognition of such linking conventions, which have an impact on finding equivalent associations in our MTBE approach, we have to introduce an advanced reasoning mechanism for finding derived associations. In the following we describe this mechanism based on the introduced example.</p><p>Assume we move from ER to UML and the user mapped examinee:Role to examinee:Property in the concrete syntax. This mapping is directly transferable to the corresponding abstract syntax elements, because no constraint is defined in the abstract to concrete syntax mapping of the modeling language. When transforming examinee:Role to examinee:Property we have to set the link to Professor:Class (cf. arrow 1 in Figure <ref type="figure">5</ref>.6). But in the ER model there is no direct link between examine:Role and Professor:EntityType. At this point we have to start a search in the ER model to find out if it is possible to indirectly navigate from examinee:Role to Professer:EntityType. As it is illustrated in Figure <ref type="figure">5</ref>.6 there is a path 1a → 1b → 1c which can be used to derive the required information for generating the desired UML model. The same procedure is applicable to produce the link between examiner:Property and Student:Class in the UML model. Furthermore, when moving from UML to ER we also need to find derived associations, e.g., when generating the link between examine:Role and Student:EntityType (cf. arrow 2 in Figure <ref type="figure">5</ref>.6). This link is derivable from the path 2a → 2b → 2c in the UML model.</p><p>The above mentioned example shows the potential of an example based approach for deriving model transformations. The reasoning on the abstract syntax of models (M1) allows to detect syntactic heterogeneities which are not explicitly visible on the metamodel level and furthermore provides the requisite information for a solution (mechanism). Another benefit of this procedure is that the reasoning is totally transparent for the user who has to map domain models in concrete syntax only. However, we believe that it is important to search for other reasoning mechanisms and to provide a set of reasoning mechanisms from which the user may choose.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">A Two Step Transformation Process</head><p>As we have already discussed in the previous chapter the refinement of model transformation code is part of the MTBE process. This refinement step is necessary in transformation scenarios where fully automatic generation of transformation code is not possible. There- fore the user-friendly adaption of generated model transformation code is a requirement for a more advanced MTBE approach. The MTBE framework in its current state has one major drawback concerning the one-step model transformation generation based on the abstract syntax when the user needs to adapt the generated transformation by hand. This drawback is due to hidden concepts in the metamodel, that are explicit in the concrete syntax.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">A Two Step Transformation Process</head><p>Hence, the user has to deal with the used constraints from the notation when adapting ATL rules. We are to tackle this problem by applying higher-order transformations as introduced in <ref type="bibr" target="#b97">[85]</ref> in combination with using models of models whereas each particular model has a particular purpose as introduced in <ref type="bibr">[10]</ref>.</p><p>In particular, we combine these two techniques in a two-step model transformation generation process with an intermediate layer as illustrated in Figure <ref type="figure">5</ref>.7.</p><p>Step 1: Starting from the mappings between concrete domain model elements, in a first step, a model transformation is generated in which the concepts available in the notation are explicitly represented to hide complexities of the original metamodel from the user. For this intermediate step, a metamodel has to be generated from the original metamodel which in addition to concepts from the original metamodel covers concepts introduced by the notation. Hence, the purpose of this generated metamodel is explicit knowledge representation allowing easier development of model generation code. The generation of the ex-Chapter 5 Advanced MTBE Concepts tended metamodel is realized by automatically transforming the original metamodel combined with mapping conditions of the package as2cs into a new metamodel which explicitly represents the concepts.</p><p>Step 2: In a second step, the transformation code adapted with additional user extensions is transformed into a model transformation which operates on the abstract syntax. For this step we adopt the fact that also a transformation is a model, which allows the transformation, of a transformation to reduce to model transformation. In the transformation of the transformation, the sub-concepts introduced by the notation are reduced to their superconcepts and expressed in the transformation rules with complex conditions in the query parts. So far, the MTBE approach has been introduced on the conceptual level, only. Its practical relevance may only be explored with proper tool support. The contribution of this chapter is to explain how MTBE concepts have been integrated into existing state-of-the-art graphical modeling and model transformation frameworks. We conclude with a critical discussion on our implementation approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Overview of the Graphical Modeling Framework How GMF Works</head><p>With the existence of the EMF the need for constructing visual editors used to be met with the Graphical Editing Framework (GEF). The effort it takes to build a visual editor for one's own from scratch is remarkable and the learning curve coming along with the GEF API is quite steep. This is why the Graphical Modeling Framework (GMF) project was set up. It aims at automatically generating basically GEF code from certain modeling artifacts. This generation functionality is encapsulated into the GMF Tooling components. Besides GMF Tooling there exist runtime components, that provide common editor properties and a general look and feel. Related to MTBE primarily the tooling components are of interest to us, as they are enabling the MTBE visual frontend as will be explained later in this section. In Figure <ref type="figure">6</ref>.1 we give a brief outline of the modeling artifacts defined and used by GMF.</p><p>For a better understanding of how smoothly GMF fits into model engineering paradigm we have categorized each modeling artifact according to its position in the 4-layer architecture proposed by the OMG's MDA approach. On the meta-metamodeling layer M3 we have the ECORE meta-metamodel introduced by EMF and based on a subset of MOF, i.e. EMOF. On M2 we find five metamodels, which the first one (MM) can be any user specified language based on ECORE and the other four metamodels are specified by GMF as they are needed in the process of editor code generation. The GraphMM defines any view elements and how they can be related to while the ToolingMM sets possible language constructs for toolbar specification. Similarly, MapMM and GenMM define mapping and generation model constructs. In order to generate an GMF based visual editor the user has to create three separate models, i.e. the GraphM, the ToolingM and the MapM located on M1. Most interesting however is the MapM, whose intention is to link the graphical definition, the tooling definition and the existing user metamodel elements together. The mapping model simply states what tool creates which domain element and how it looks like on the canvas. After the definition of these model element correspondences a transformation takes care of the generation of a so called GenModel (Generation Model). The GenModel then serves as input for the code generator templates (model-to-code transformation), that produce fully functional editor code. The GMF runtime is however designed such that the generated code </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MTBE Related Notation Issues</head><p>In Section 3.5 we have already discussed the difference between notation and CS and how the notation can be formally defined. GMF has chosen a very similar approach to capture the notation and thus keep AS and CS elements separated from each other to maintain flexibility. As mentioned above GMF maintains a mapping model called GMFMap referred to as MapMM in the formal specification in the previous subsection. This metamodel defines proper concepts to align domain elements, graphical view elements and tooling elements. Basically there exist 5 major mapping elements, i.e., LabelMapping, CanvasMapping, NodeMapping, CompartmentMapping and LinkMapping. Furthermore, there exist two concrete meta classes called TopNodeReference and ChildReference for the task of mapping references from the metamodel to the view. Figure 6.2 gives an example of how the notation is implemented in GMF. In the left upper corner we show a very simple SimpleER metamodel with only three concepts and a standard EMF root element. These concepts are Entity, Attribute and weak entity, which is implemented through a containment reference called weak. The way this latter concept is implemented here can be regarded as concept hiding or metamodel heterogeneity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 6 Implementation</head><p>To the left we depict the same metamodel in AS using the UML object diagram notation. The reason for this shift in presentation of the SimpleEr language is that we have now all meta concepts explicitly represented as UML instance specifications, which we can refer to from the GMFMap model. This means that our EReferences in the metamodel are now explicitly expressed as instances maintaining links to other instances, which they are connecting. Links to other objects may also reflect the role names of the corresponding EReferences in the metametamodel, i.e., Ecore. In most cases role names are negligible but to distinguish between source and target objects of an EReference we labeled one link with eType. If we had some EAttributes specified in our SimpleER metamodel their instance specifications would then also be easy to link with our example GMFMap model.</p><p>At the bottom of Figure <ref type="figure">6</ref>.2 all GMF related elements are drawn as colored instances of their corresponding GMF tooling models explained in the previous subsubsection. For the sake of clarity we omit some details like the compartment mapping for Attributes and some graphical definitions. The point we want to emphasis in this object diagram is the way GMF deals with ambiguities in the AS and hence in the CS. The concept of weak entity is only reflected by an additional containment reference from Root to Entity and shares the same metaclass with the concept Entity. GMF defines NodeMapping as the view relevant concept. Both instances NM1 and NM2 are linked to the same EClass making it for the GMF runtime impossible to distinguish between these two distinct view elements. To solve this problem GMF provides for the definition of OCL constraints to handle ambiguities on the CS level.</p><p>In our example we therefore specify Constraint instances C1 and C2 containing the proper OCL constraints, which make the differences in the AS visible, i.e., the different EReferences to the container metaclass Root.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Model Operators</head><p>The automatic MTBE editor code generation needs to have the following modeling artifacts available: {M M 1 , M M 2 , GraphM 1 , GraphM 2 , T oolingM 1 , T oolingM 2 , M apM 1 , M apM 2 }. Afterwards four distinct model operations have to be carried out.</p><formula xml:id="formula_5">1. JointM M = M M 1 ∪ M M 2 ∪ M M M L = merge(M M 1 , M M 2 , M M M L) . 2. JointM apM = M apM 1 ∪ M apM 2 = merge(M apM 1 , M apM 2 ) having</formula><p>JointM M, GraphM 1 , GraphM 2 , T oolingM 1 , T oolingM 2 available for reference.</p><p>3. JointGenM = transf orm(JointM apM ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Code = transf orm(JointGenM ).</head><p>This is of course seen from a high level perspective and shall only briefly give an overview how modeling artifacts of GMF are handled to foster the aim of having tool support for the visual, concrete syntax part of MTBE. The transform operations in step 3 and 4 are a model</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">An Eclipse Based Implementation for MTBE</head><p>transformation using Java and model to code transformation using templates respectively. These two steps are basically determined by GMF itself. Steps 1 and 2 have been implemented by us using simply Java as transformation language. We could have also decided to use ATL instead and define model transformation rules in a declarative way. The next two paragraphs describe how we implemented steps 1 and 2 in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">An Eclipse Based Implementation for MTBE</head><p>Our MTBE framework comprises several components. As can be seen in Figure <ref type="figure">6</ref>.3(1), our implementation heavily relies on major Eclipse projects, providing essential functionalities our components are based upon. These components are the Eclipse Modeling Framework (EMF) <ref type="bibr">[12]</ref>, the Graphical Modeling Framework (GMF) and Eclipse serving as IDE. The components within Figure <ref type="figure">6</ref>.3(2) comprise the user front-end and match with conceptual</p><p>Step 2 of the MTBE process. In Figure <ref type="figure">6</ref>.3(3) all components facilitating the task of metamodel mapping modeled in Step 3 are depicted. Figure <ref type="figure">6</ref>.3(4) components correspond to</p><p>Step 4, i.e., the code generation. Note that we omitted dependencies and interfaces among non-MTBE components to preserve readability. In what follows we will give a short description on each of the modules and will focus on the user front-end in subsequent sections. Model Mapping Language. The MappingLanguage component provides a specification of several alignment operators in terms of an Ecore based metamodel, cf. ML MM in Figure <ref type="figure">6</ref>.3. The implementation of this component allows the user to map different kinds of visual model elements as described in Subsection 5.1. The definition of this mapping language is central to the MTBE framework as it is directly or indirectly used by other components.</p><p>Merge Components. To be able to define mappings between model elements in a graphical way certain artifacts have to be available a priori in one or the other way. Therefore, it is assumed that at least a language definition in terms of a metamodel, a graphical definition of the concrete syntax, and a mapping between these two exist for every modeling language. To allow for mapping two metamodels within the Eclipse environment we decided to merge existing artifacts and build a single editor for both languages. This merging procedure is described in Subsection 6.2.2. The MapMerger component also takes care of the MTBE Mapping Editor component generation with the help of GMF Tooling. MTBE Mapping Editor. Our graphical editor prototype uses the GMF Runtime and is built solely from GMF Tooling at the moment.</p><p>Analyzer Component. The Analyzer takes the output model of the GMF editor, i.e., the user defined model mappings, as well as the corresponding metamodels and tries to match various kinds of patterns as presented in Section 5.2. The user can decide which of the available patterns shall be applied in order to translate the manual mappings into an AMW <ref type="bibr" target="#b39">[26]</ref> weaving model conforming to the MTBE weaving metamodel, which basically captures the concepts presented in Subsection 5.3. This module will be designed in such a </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">An Eclipse Based Implementation for MTBE</head><p>way to allow for several pattern extensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MTBE HOT Component.</head><p>On top of our framework lies the MTBE HOT component. This component takes the generated weaving model as input and produces an ATL model conforming to the ATL 2006 metamodel <ref type="bibr" target="#b52">[39]</ref>. The built in ATL transformation model can be used to generate transformations in both directions. After generation of the transformation models the AM3 extractor can be run to get the user readable ATL code. The advantage of this approach stems from the fact that all artifacts used in the code generation are models. No hand-coded templates or Java programs are involved to produce the ATL code. The output of the Analyzer module shall serve as input for several kinds of transformation code generators, depending on the use case, so we are not limited to ATL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">MTBE Workbench</head><p>The MTBE prototype is implemented as Eclipse plug-in. The workbench is to consists of four different views. The first view is composed with our MTBE Mapping Editor, that operates on the notation and lets the user define mappings. In the second view, the bridging between the two metamodels is presented to the user with the help of the Atlas Model Weaver, which is extended by our MTBE weaving metamodel. The third view presents an editor, that shows all so far generated ATL code as textual representation. It's left to the user whether to refine the code or not. The last view can then be utilized to test the transformation code and see its results immediately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2">Integration of GMF</head><p>Our MTBE approach poses a novel idea as it moves the task of developing model transformation away from the complex structures of abstract syntax to the well known notation elements of modeling languages. To achieve this increased usability for model engineers we decided to integrate the Graphical Modeling Framework (GMF) to be able to generate a graphical editor. The advantage of this decision is that we can use the capabilities of an emerging framework, supported by a rather big community. In order to apply GMF to create an editor out of a simple generation model we have to provide for some model merging components in our MTBE framework. In the following we describe the merging process in more detail and explain how the generated editor can be used to define (appropriate) mappings between notation elements. In the context of MTBE we assume that a graphical editor for some modeling language can be fully generated from GMF (and EMF models). We do not cope with any editor specific changes made to the generated code. Therefore we rely on the declarative power of GMF models and their limitations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">An Eclipse Based Implementation for MTBE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ecore File Sharing</head><p>The GMF mapping definition model, that constitutes the mapping from AS to CS, relies on an Ecore based metamodel besides a graphical as well as a tooling definition model. The latter two we do not have to cope with in our merging process as they represent highly reusable elements. But for the Ecore model our MTBE framework needs a merging component which we call EcoreMerger, as shown in Figure <ref type="figure">6</ref>.3. This component takes two Ecore models, representing different modeling languages, as input and generates a single Ecore file (cf. Figure <ref type="figure">6</ref>.4b on the left). Each language is represented by its own package, which is a child of a common root package. The root package itself has to contain a single class that owns all required containment references to classes from the original metamodels. These required references can easily be extracted from the two Ecore files, as these also have to consist of a single class acting as a container, which is a specialty of EMF. We introduced another type of class in the root package, because of GMF limitations, the GMFElement{language name}. This class serves as supertype from which all classes of a modeling language have to inherit. Our EcoreMerger therefore has to modify all classes in these language packages accordingly. However, this design decision then allows us to have mappings defined between every two classes in the two modeling languages. To define these mappings in our graphical editor we also have to add mapping meta classes to our merged Ecore metamodel. This is done in the mapping package, that includes the SimpleMapping class with source and target references of type of the superclass GMFElement{name}. After the work of the EcoreMerger is completed, the created Ecore file can be used to generate the EMF generation model as well as the EMF model and edit code, that are prerequisites for the GMF diagram code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mapping Definitions Merging</head><p>Similar to the joint Ecore file we have to provide a component that merges the two mapping definition models (GMFMap models) to a single model, the GMF generation part can handle to create diagram code, see Figure <ref type="figure">6</ref>.4(b) on the right. The algorithm for solving this task simply copies the different kinds of mapping elements from both mapping models into a single one and adjusts the XPath expressions for domain model elements to point to the newly created Ecore file. XPath expressions for tooling and graphics can be reused. After execution of our MapMerger (cf. Figure <ref type="figure">6</ref>.3) tool the GMF generation model is produced from the merged mapping model to facilitate diagram code generation.</p><p>Chapter 6 Implementation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Critical Discussion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Implementation Status</head><p>Currently the development of our first experimental prototype is completed. So far we have implemented a mapping language for general mapping scenarios only. Based on our Mapping Language we fully implemented the EcoreMerger as well as the MapMerger. After the user finishes the merging processes a wizard guides through the generation of all required Mapping Editor plug-ins. The plug-ins are placed directly into the plug-ins folder of eclipse and are ready to use after a workbench restart. The generated Mapping Editor possesses all modeling features of the two input editors as long as the latter have been solely created with GMF Tooling. A detailed description and a user manual can be found in <ref type="bibr" target="#b69">[57]</ref>. The prototype can be found and downloaded at www.modelcvs.org.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">Discussing the GMF Approach</head><p>For every two modeling languages a user wants to define model transformations, a unique editor with its own domain, graphics, tooling and mapping models has to be generated.</p><p>There is no possibility to reuse already generated code. Before one can begin to define mappings on the concrete syntax, the merging and generation components of the MTBE framework have to be executed. In order to reduce the cost of time we have provided for an implementation that can do things nearly without user interaction. Another drawback of the current approach is that we are not able to cope with custom code in an available editor, which limits our design possibilities. For example UML roles are contained in a Class and not directly shown at an Association in our simple UML GMF editor.</p><p>In order to fully support our MTBE approach we would like to be able to map labels, such as role names of associations explicitly. GMF does not support such a mapping scenario. In most cases such mappings are given implicitly and can be deduced by simple string comparison algorithms or available matching tools. But there might be situations in which the user wants to explicitly define mappings.</p><p>Also GMF suffers from minor bugs at the moment, which primarily have an impact on the editor view and how elements are rendered or not. But these are well known bugs that will most likely be removed in future versions of this very promising framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.3">Alternative Implementation Approaches</head><p>MTBE in its described implementation lacks to take custom GMF editor code into account. It is in most cases however not satisfactory to have only GMF tooling and its declarative models available. It is also not the aim of GMF to provide modeling artifacts that are powerful enough to replace programming languages completely. The aim of GMF is to reduce 6.4 Summary the cost of time to build a comprehensive modeling editor. Consequently, we have been thinking of alternatives capable of handling custom code refinements and still use the GMF framework as well as the proposed MTBE framework design for model alignment and code generation. Separation of Editors. Basically there is no need to have only one editor allowing to draw correspondences between CS elements between two different modeling languages. We could also have two separate editors active at a time and only put those CS elements on the canvas, which are equivalent and therefore should be mapped. This mapping of elements can then however be done implicitly by just storing the elements on the canvas in some XMI serialization and establishing the mapping automatically. We do lose the visualization of mappings this way and have to cope with some other problems, e.g., we cannot draw connections without corresponding nodes on the canvas, but we could use editors having defined custom code sections. The Aspect Way. Another way to reuse already implemented GMF modeling editors is to use aspects and the OSGI component model to relate various plug-ins among each other as described by <ref type="bibr" target="#b48">[35,</ref><ref type="bibr" target="#b70">58]</ref>. Their work is based on an aspect-oriented programming language called Object Teams/Java and the Eclipse implementation of the OSGI standard Equinox. The basic idea is to have an arbitrary number of plug-ins that can be handled as aspects for other plug-ins through proper binding methods. Following this approach we could implement one central GMF editor that handles only the user mapping language. The two other editors enabling the model creation can then be simply bound as aspects to the base plug-in, i.e., our GMF mapping language editor. This would be done dynamically by the user and because of this simple binding custom code would not get lost. There are some difficulties concerning the binding of different GMF editors because there are some classes, which have to be handled with care. According to <ref type="bibr" target="#b70">[58]</ref> these issues will be overcome in the near future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Summary</head><p>In this chapter we have introduced our prototype for MTBE, which has been implemented as Eclipse plug-in. This prototype allows for defining semantic correspondences between domain models (M1) shown in their concrete notation, from which model transformation code can be generated. Our framework is based on emerging technologies, such as the Graphical Modeling Framework, which are based on Eclipse and the Eclipse Modeling Framework. Our early prototype has shown that it possible to realize our framework based on the current versions of the underlying technologies. However, one important drawback of the proposed framework must be mentioned, namely the strong dependency on the success and the usability of the underlying technologies. The aim of this chapter is to prove the practical relevance of MBTE with the help of our prototypical implementation presented above. For this reason we have conducted two different case studies in the domains of structural and behavioral modeling. The results of the two case studies are critically reflected and directions to improve the implementation of MTBE in future work are presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 7</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Applications of MTBE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Application to Structural Modeling Languages</head><p>In this section, the functionality of our prototype is demonstrated by a small case study. The aim is to be able to transform UML models into Entity Relationship (ER) diagrams and vice versa. Note, that these two modeling languages have already been used in <ref type="bibr" target="#b101">[89]</ref> to exemplify our MTBE approach. However, we had no implementation at hand to underpin our conceptual findings. With our prototype we are now in the position to demonstrate general MTBE concepts in practice. The MTBE plug-in as well as various artifacts and examples can be downloaded from our ModelCVS project site<ref type="foot" target="#foot_4">1</ref> . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Integration Problem: ER2UML</head><p>Figure <ref type="figure">7</ref>.1 illustrates two simplified metamodels of the ER diagram and UML class diagram, respectively. Generally speaking, both languages are semantically nearly equivalent and thus the corresponding metamodels cover the same modeling concepts. Note that the metamodels for the two languages are designed such that their concrete syntax can be fully specified by declarative GMF components. Most important to us is that we can define the notation by means of the GMFMap model.</p><p>ER. The ER metamodel covers the basic concepts of Entity, Relationship, Attribute, Role, and Multiplicity. Diagram acts as the basic root element and is an implementation-specific of EMF. Entities are connected via Relationships through their sourceEntity and targetEntity references. Entities can further contain an arbitrary number of Attributes. Relationships can be assigned two distinct Roles through their ownedRoles reference. Roles are not contained in their corresponding Relationship but in the root element itself. Furthermore, a Role must be assigned to a certain Entity, which is done through the type reference. Roles are further enforced to contain a Multiplicity that consists of a single attribute called upper specifying the upper bound multiplicity of a role.</p><p>UML. The UML metamodel in turn consists of Classes, Properties and Associations. The abstract class NamedElement is for convenience only. The root element DiagramRoot is equivalent to Diagram in the ER metamodel. We introduced concept hiding in the UML metamodel by representing attributes and roles by the same class, namely by the class Property. One can only distinguish between these two concepts by the optional reference association, whose inverse reference is memberEnd. More specifically, an instance of class Property represents a role when the reference association is set. In case the reference association is not set Mostly all concepts presented in the ER metamodel are also covered in the UML metamodel. Although, the two metamodels can be considered semantically equivalent, there exist structural heterogeneities between them, that would complicate the manual creation of model transformations. These structural heterogeneities entail further reasoning upon the model mappings in order to generate a semantically richer mapping model, which is the basis for the model transformation generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">User defined Model Mappings</head><note type="other">Figure 7</note><p>.2 depicts the mappings between the ER example model and the UML example model established by the user. Each GMF tool provided in the palette, see right side of Figure <ref type="figure">7</ref>.2, has been used and therefore all concepts are covered by the models. Table <ref type="table">1</ref> summarizes the mappings specified by the user. In particular, we have mostly used simple mappings, however, for mapping roles in combination with multiplicities of ER models to properties of UML models, we employ a compound mapping. Furthermore, we need to attach a value mapping to the simple mapping between relationship and association in order to set the name of an association (note that in our ER metamodel the relationship itself does not have a name).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.3">Reasoning and Metamodel Mappings</head><p>Based on the model mappings, the Analyzer generates a mapping model capturing as many metamodel mappings as possible. Concerning our core patterns presented in Section 5.2, the Analyzer component can apply pattern 1, 3, and 6 shown in Figure <ref type="figure">5</ref>.4 for finding equivalent classes as is summarized in Table <ref type="table" target="#tab_2">2</ref>. Pattern 1 generates the mappings C2 and C3, while mapping C1 has been additionally reasoned from GMF configurations to find the equivalent root classes which represent the modeling canvas. Pattern 3 is used to reason about the compound mapping (cf. model mapping ( <ref type="formula">4</ref>)) which results in mapping C4 from Property to the join of Role and Multiplicity. Furthermore, pattern 6 is able to generate the conditions for splitting properties into attributes and roles. From these class mappings, most of the attribute and reference mappings can be derived which are necessary for the model transformation. Due to brevity reasons, we only show the reference mappings necessary for transforming ER models into UML models. As one can see in Table <ref type="table" target="#tab_2">2</ref>, only one user interaction is necessary for completing the model transformations, namely the Class.ownedAttributes reference must be split in two subsets, one can be reasoned, however, the other has to be defined by the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.4">ATL Code Generation</head><p>Based on the metamodel mappings, we show how our HOT produces valid ATL model transformations. The ATL code for transforming ER models into UML models depicted in Listing 7.1 comprises both, the automatically generated code by our HOT implementation and some user refined code fragments.   <ref type="figure">--------------------HELPER BEGIN--------------------------------------------------</ref>  <ref type="figure">--------------------HELPER END --------------------------------------------------r</ref>    proceed. Whereas the AFN marks the end of the whole process which means if it is reached the remaining tokens in the process are killed immediately. The only kind of Activity Edge we consider in this work is the Control Flow, which is used to connect the Activity Nodes to form the flow of control of a process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Event-driven Process Chains</head><p>Event-driven Process Chains (EPCs) <ref type="bibr" target="#b56">[43]</ref> have been introduced by Keller et al in 1992 as a formalism to model processes. We focus on the main elements, which are used to model the control flow aspect of a BP model. The metamodel and concrete syntax of EPCs are illustrated in Figure <ref type="figure">7</ref>.4.</p><p>The Function represents an activity. It creates and changes information objects within a certain time. The Event represents a BP state and is related to a point in time, it could be seen as passive element compared to the Function as an active element <ref type="bibr" target="#b64">[52]</ref>. To model a sub process call the Complex Function is used. The Logical Operators elements are used to structure the proceed of the BP model.</p><p>When dealing with EPCs some special modeling restrictions must be considered which are not directly represented in the metamodel. EPCs do not provide a specific element to indicate the begin and the end of a BP model, instead the Event is used. Event elements are not allowed to be in front of an OR and XOR element.  of the EPC language is in fact a static semantic constraint, which is not specified in the metamodel illustrated in Figure <ref type="figure">7</ref>.4. Another restriction in EPCs is that parallel branches as well as alternative branches must be split and merged with the same kind of Logial Operator. Again we have to face a static semantic constraint in the context of Logical Operators, when it comes to specifying model transformations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Dealing with Heterogeneities in Business Procss Models</head><p>During our investigation of BP models we discovered, that there are considerable differences compared to structural models concerning the requirements for MTBE. To transform structural models, one has to be familiar with the notation and hidden concepts in the metamodels, especially when dealing with UML diagrams. Resulting ambiguities on the metamodel layer have to be solved either by reasoning algorithms or user input, as we described in detail in our previous work. Now, with the task of transforming BP models we have to deal with quite different issues, in order to apply our MTBE approach. A lot of interesting aspects concerning the heterogeneity of BP models have been identified in <ref type="bibr" target="#b71">[59]</ref>.</p><p>One of the special requirements coming along with BP models has its root in the mapping from concrete to abstract syntax layer (notation) and the number of modeling elements involved on each layer. In UML AD we have for example the notation:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Application to Behavioral Modeling Languages</head><p>&lt; {M ergeN ode, ControlF low, DecisionN ode} , {DecisionM ergeF igure} , {} &gt; as is illustrated in Figure <ref type="figure">7</ref>.5(c) for the CS modeling element on the very top. Note, that the used modeling construct is here just an abbreviation on the CS layer and could be equivalently expressed by the following pattern of notation triples:</p><formula xml:id="formula_6">&lt; {DecisionN ode} , {DecisionF igure} , {} &gt; &lt; {ControlF low} , {ConnectionF igure} , {} &gt; &lt; {M ergeN ode} , {M ergeF igure} , {} &gt;</formula><p>We also observed several heterogeneities between modeling languages, which pose further requirements for MTBE. Figure <ref type="figure">7</ref>.5 gives four examples for the peculiarities we found in the two BP modeling languages we introduced in Section 7.2.1. Examples (a) and (b) in Figure <ref type="figure">7</ref>.5 depict the case of so called CS overloading in UML AD and EPC. In example (a) we encounter no problems because with the help of the notation we can distinguish between the two concepts join and fork despite the CS overloading. In example (b) CS overloading represents a real challenge for MTBE as two equal CS elements, but in fact featuring two different meanings, are mapped to the same AS element.</p><p>When we have to deal with alternative representations in the CS, see Figure <ref type="figure">7</ref>.5(c), we can use the notation in MTBE to find them. The challenge arises not until we have to map two languages, where one consists of such variation points in the CS. Example (d) in Figure <ref type="figure">7</ref>.5 shows the possibility in UML AD to merge parallel flows implicitly by omitting a merge/join node, i.e., we have no mapping from the AS to the CS.</p><p>In the following we apply our advanced mapping operators, which have indeed been influenced and inspired by BP models, and transformation heuristics which resolve het-Chapter 7 Applications of MTBE erogeneities, as expressed in the examples (a),(b), and (c), in Figure <ref type="figure">7</ref>.5 are faced. Unfortunately, up to now we are not able to cope in MTBE with implicit elements as shown in example (d). The problem here is twofold. First we have to address the question how to map these implicit elements on the concrete syntax layer. And second we have to adjust the code generation process accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">Integration Problem: UML AD and EPC</head><p>Our MTBE approach for the domain of Business Process modeling can be best explained in a by-example manner. Therefore, we use the two BP languages EPC and UML AD described in Section 7.2.1. For demonstration purposes we show what the generated code would look like in ATL. Although the example given in Figure <ref type="figure">7</ref>.6 is rather simple, it still covers a lot of interesting aspects for MTBE.</p><p>For the case study we assume that on the concrete syntax layer in EPC's Events and Basic Functions to always occur pairwise connected through a Control Flow edge. Furthermore, in UML AD modeling it could be possible to omit a Join node and therefore model joins implicitly. However, in our first MTBE approach for BPM we do not jet cope with implicit joins or merges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.4">Model Mappings and Metamodel Mappings</head><p>As a first step one has to define manual mappings between two languages, which the transformation model shall be derived from. In the example in Figure <ref type="figure">7</ref>.6 we specified six mappings that capture all concepts being used in the two sample models. Mappings a,b,c,d,f, and g are of type simple mapping.</p><p>Mapping e is of type compound mapping with multiplicity 1:3. Consequently, whenever the pattern Event, Control Flow, Basic Function is matched this corresponds to a single Opaque Action. We also marked the Basic Function C in our compound mapping as anchor element, which has implications specific to transformation code generation. In our case the ATL code generator would use this Basic Functions metamodel element as single source pattern element instead of using multiple source pattern elements. During our implementation attempts we realized, that an anchor feature can be desirable in some transformation scenarios. Mapping h in our example takes care of the labels used in Events, Basic Functions and Opaque Actions. To maintain usability this string manipulation operator is used in a separate modeling element and references the involved labels. To define string equivalences one can use only unidirectional mappings, which are applied transforming from one set of labels to another. An optional expression allows us for example in mapping h to apply a toLowerCase() operation on the first mapping of the right hand side set of labels.   can be best compared to Architecture-Centric MDSD <ref type="bibr" target="#b92">[80]</ref>. First of all we have implemented correct ATL transformation code, which acts as reference implementation. Thereby we have avoided imperative code sections and concentrate on coding in a declarative fashion.</p><p>In the next step we have developed the mapping operators described in Section 7.2.2. During this step we have turned our attention to the user-friendliness.</p><p>Next we have looked at the example models, the user mappings and the metamodels and tried to deduce the reference implementation. Code segments that could not be deduced automatically then lead to further refinement of the underlying heuristics. After refinement we tried again to deduce the reference implementation. This process can be seen as an iterative way to deduce heuristics on how to generate ATL transformation rules from a given set of models, metamodels and user mappings. The aim of this process is to optimize the relation between user-friendly mapping operators and the ability to generate executable transformation rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ATL Code Generation</head><p>Due to space limitations we will not expand on every aspect of the ATL code generation for the example in Figure <ref type="figure">7</ref>.6. Instead we focus on the most interesting and challenging parts, only. The three ATL code snippets presented in the following paragraphs transform from EPC models to UML ADs. However, the example mappings provided by the user, also allow for UML AD 2 EPC transformation code generation.</p><p>Event2InitialNode and Event2FlowFinal. We already mentioned that we somehow have to distinguish between Events, that can be either normal Events, Start Events or End Events, to properly generate elements in UML Activity models. In our previous work we tried to overcome mapping and thus generation problems by means of reasoning on the metamodel layer. For business process models it seams to be more appropriate to do reasoning on the model layer. When the user maps two elements that are completely identical in the metamodel in one language, but correspond to two different elements in the other language, rea-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Application to Behavioral Modeling Languages</head><p>soning algorithms have to examine the graph structure in the example model. In our Event example the algorithm would have to determine, that Start Events do not have any incoming Control Flows and that End Events do not have any further outgoing Control Flows. Listing 7.3 shows the corresponding ATL rules with proper conditions in the source pattern. This addresses mappings a and g in Figure <ref type="figure">7</ref>.6.</p><p>In ATL it is not possible to match an element more than once, i.e., to have more than one rule applied. Therefore, whenever a metamodel element occurs in at least two source patterns, we have to make sure that only one rule is matched. In the example above this would only be possible, if the user would model an Event without any Control Flow connected to it. Of course this would already violate some validity constraint. However, the OCL constraint to check for multiple matching would look like in ATL as follows: This is why we have to give a guard clause (c.target = f and c.source = ev) to select only those elements we are interested in. This is similar to a join in SQL. To generate Chapter 7 Applications of MTBE this "join" condition automatically we have to assume that elements in a compound mapping are always connected through proper link elements. A reasoning algorithm can check for the existence of links and build conditions that must hold for the pattern to match.</p><p>There are two more conditions given in Listing 7.4 that must evaluate to true if this rule shall be executed. This condition originates from the XOR constraint we face in the metamodel between the mappings Event_InitialNode, Event_ActivityFinalNode and Event_OpaqueAction, which is actually part of a compound mapping indicated by an and. To avoid matching a rule twice we can just take the conditions we have deduced in the previous two ATL rules and insert their negation, i.e. ev.incoming-&gt; size() &lt;&gt; 0 and ev.outgoing-&gt; size() &lt;&gt; 0. The idea of inserting the negation of already existing conditions in other rules can be seen as general heuristic.</p><p>And2Fork and And2Join. In Figure <ref type="figure">7</ref>.5 b we referred to the problem of concept overloading in the CS, which we face in the transformation from an EPC to a UML AD model. We know, that the simple mappings d and f are actually in an XOR relationship, which is determined from the deduced mappings between the metamodel elements. This transformation difficulty was also the reason why we introduced the XOR operator.</p><p>The user mappings together with the derived XOR constraint are not yet sufficient to provide for a heuristic capable of generating valid transformation code. What we need in this special case of concept overloading is an algorithm performing "local reasoning" on a specific node and compare the results with the ones from another one. The differences in the properties found between these nodes are then used to distinguish between them. In our example we determined for the class And mapped to class Fork Node there has to be only one incoming Control Flow and at least two outgoing Control Flows on the CS layer if the rule And2Fork shall be applied. For the class And mapped to class Join Node the opposite has to be true if the rule And2Join is supposed to match. Both rules are given in Listing 7.5</p><p>Listing 7.5: ATL rule for And2Fork and And2Join. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Critical Discussion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ER2UML</head><p>During our case study and experimenting with our prototype we discovered some limitations of our implementation. HOT. Our basic Higher Order Transformation works well and produces model transformations in both directions. There are however some metamodel weavings that we do not fully support in our HOT, i.e., weavings that contain an OCL expression originating either from the notation or from some analyzer pattern. The problem is that OCL conditions are stored in weaving models as strings. But in the HOT we have to compute the equivalent abstract syntax trees for producing the ATL transformation model. As an alternative we consider a template based approach producing ATL code out of weaving models, where we could use plain OCL strings and need not handle abstract syntax trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UML_AD2EPC</head><p>The code for the examples above is generated in a heuristic way and we believe that in many cases and languages there is no great effort for code refinement necessary. However, there are limitations of MTBE we want to briefly discuss. In our language definition of EPC we assumed, that every Basic Function is directly preceded by an Event. But it may be possible in our example to place the Events b and c as one Event in front of the And split. This is another static semantic constraint one can only capture in a natural language description of EPC. As an example we refer to <ref type="bibr">Figure 7.7(a)</ref>.</p><p>Due this alternative way of positioning concrete syntax elements our rule defined in Listing 4.2 would no longer match any of the elements in such small models. To solve this problem MTBE could again be applied on this new EPC example model and map the concepts of interest again. For the example given in Figure <ref type="figure">7</ref>.7(a) we would have to map the Basic Function located between the two And elements to an Opaque Action in our EPC 2 UML AD mapping scenario. Because of the XOR constraints later derived in the metamodels a heuristic could be applied to prevent multiple rule matching and select the rules properly. The mapping of the Event a remains however an open issue.</p><p>In Section 7.2.2 we presented the heterogeneity of alternative representations in CS. In UML AD we could model a join followed by a fork the way shown in Figure <ref type="figure">7</ref>.7(b1). This representation is just an abbreviation, which we want to map in our example to EPC, where this form of abbreviation is not possible. From the users point of view it is sufficient to simply draw the compound mapping a. For both modeling constructs we have again drawn the corresponding metamodel elements and also their mapping to the CS (notation). As one can easily see it is not possible to determine from these notations and the compound mapping a how the elements in the metamodel shall be mapped from one language to the other. Again we can apply local reasoning algorithms operating on the model expressed in AS to find out what elements possibly go together. The UML AD example model given in Figure <ref type="figure">7</ref>.7(b1) is also illustrated in AS (see Figure <ref type="figure">7</ref>.7b2) , modeled in UML object diagram concrete syntax. We can now reason on this representation of the model and try to find out how the single metamodel elements have to be mapped to the elements in EPC. For example we learn from this graph that Fork and Join Nodes have a single outgoing and incoming edge, respectively. The heuristic is similar to the one that copes with mappings d and f in the first example, cf. Figure <ref type="figure">7</ref>.6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 8</head><p>Open Issues and Future Work</p><p>In this thesis we have described our MTBE approach, including basic as well as advanced concepts. Additionally, MTBE has been implemented within the Eclipse platform. However, our evaluation by means of two case studies in two different modeling domains has revealed open issues we need to tackle in future work. In the following we emphasize major directions of future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Extension of the mapping language:</head><p>The mapping language developed so far is able to solve the basic transformation problems in the domains of structural and behavioral modeling. Usually each specific modeling domain raises a set of additional transformation problems. This requires a customization of the mapping language by further mapping operators. For example, in the domains considered we recognized the need for conditional equivalence mapping, and nested mapping. Therefore, we have to look at further domains to derive an extensive requirements catalog for a more powerful MTBE mapping language.</p><p>2) Web modeling languages: So far we have only studied the domains of structural and behavioral modeling languages. However, we believe applying MTBE to the domain of web modeling languages would provide further interesting results for the MTBE approach. Therefore, we apply our current MTBE approach to hypertext models, such as WebML <ref type="bibr" target="#b28">[16]</ref>, which represent the navigation and the data flow between hypertext nodes via links and link parameters. We hope that the area of web modeling languages reveals new mapping problems and allows the evaluation of MTBE in more detail.</p><p>3) Development of reference models in specific modeling domains: Having also participated in the ModelCVS project we recognized the power of building reference models. In Model-CVS, the reference models support the integration task by delivering solutions for transformation problems of a specific domain. These reference models may serve as domain models in our by-example approach. This means the user is able to specify the mappings between two reference models in different modeling languages. Hence, she does not need conceive domain models from scratch. Instead the reference models are used as starting point for the most prominent modeling languages and modeling domains. Reference models are designed to designed all or at least most of the concepts of a certain domain. A at time t0 progresses to A' at time t1. A transformation between two models is always specified in a given point in time. For example, the transformation T specifies the mapping between A and B at time t0. In future work we experiment on the consequences on the existing transformation T when models progress to new versions A' and B'. We classify different characteristics in the delta between A and A' (as well as B and B') to derive further requirements for the automatic model transformation code generation.</p><p>5) Model Heterogeneities: In this thesis we have mainly focused on heterogeneities that have their origin in the metamodels of different modeling languages. We have given a rather comprehensive categorization of metamodel heterogeneities, which has been underpinned with real world examples. However, our case study of business process modeling languages has revealed challenges in the area of model heterogeneities. These model heterogeneities appear in cas of underspecified metamodels or of hidden concepts in the metamodels. For example the implicit merge of OpaqueActions in UML activity diagrams is not specified by means of metamodeling concepts. To handle such model heterogeneities special reasoning algorithms and patterns as well as proper example models have to be provided. The topic of model heterogeneities is therefore closely related to the requirements for example models, see Section 3.7. Also the automatic generation of valid models from metamodels would be helpful for finding heterogeneities on the instance level.</p><p>6) Metrics Implementation: We have demonstrated on a conceptual level how model metrics can support the MTBE approach by helping to measure the explicitness of metamodels. Thereby, the metric assists in finding metamodel heterogeneities. Our metamodel metric however has not been integrated yet within our MTBE framework. It is beneficial, though, to have a measure at hand supporting the software engineer to make complex notation related issues visible. By using GMF, we build on a framework that features the same notation concepts as the ones we incorporate in measuring hidden concepts in metamodels. The graphical model of GMF holds all CS elements, the GMF mapping model denotes the concepts, i.e., the notation, and the Ecore-model captures all AS elements. A special view for visualizing hidden concepts and guiding the user should be developed in order to better cope with metamodel heterogeneities.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1. 1</head><label>1</label><figDesc>Model transformation pattern according to<ref type="bibr" target="#b33">[21]</ref>. . . . . . . . . . . . . . . . . . 1.2 Typical distribution of knowledge considering software architects. . . . . . . 1.3 Big picture of this thesis. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.1 Relationships between QVT metamodels [70]. . . . . . . . . . . . . . . . . . . . 2.2 PacMan type graph. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.3 Instance graph for the PacMan type graph. . . . . . . . . . . . . . . . . . . . . 2.4 Graph transformation rule that moves PacMan. . . . . . . . . . . . . . . . . . . 2.5 Simple retrieval of data within table PERSON. . . . . . . . . . . . . . . . . . . 2.6 Simple transition in Flash using motion tweens. . . . . . . . . . . . . . . . . . 2.7 Simple TBE rule. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3.1 The OMG's metamodeling stack in the light of MTBE [68] . . . . . . . . . . . . 3.2 The Ecore metamodel for creating models [22]. . . . . . . . . . . . . . . . . . . 3.3 Model transformations in the modelware technical space. . . . . . . . . . . . . 3.4 Taxonomy of schema integration conflicts. . . . . . . . . . . . . . . . . . . . . . 3.5 Attribute integration conflicts, (a) and (b) being different modeling languages. 3.6 Property expressed as (a) discriminator, (b) attribute, (c) reference. . . . . . . . 3.7 Reference direction and property set/subset mismatch. . . . . . . . . . . . . . 3.8 Concept definition conflicts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.9 Implicitly missing property. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.10 Part of the UML kernel as pseudo-ontology and as refactored ontology. . . . . 3.11 Modeling languages and their concrete syntax. . . . . . . . . . . . . . . . . . . 3.12 Relationship between abstract and concrete syntax. . . . . . . . . . . . . . . . 3.13 Three characteristics of the EM 2 metric. . . . . . . . . . . . . . . . . . . . . . . 3.14 Side effects of the EM 2 metric. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.15 Results for UML 2.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.16 Demonstrating nesting problems: insufficient example. . . . . . . . . . . . . . 3.17 Demonstrating nesting problems: sufficient example. . . . . . . . . . . . . . . 4.1 Gap between user intention and computer representation. . . . . . . . . . . . 4.2 Concept hiding in metamodels. . . . . . . . . . . . . . . . . . . . . . . . . . . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 . 2 :</head><label>12</label><figDesc>Figure 1.2: Typical distribution of knowledge considering software architects.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1. 4 6 Figure 1 . 3 :</head><label>4613</label><figDesc>Figure 1.3: Big picture of this thesis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 . 1 :</head><label>21</label><figDesc>Figure 2.1: Relationships between QVT metamodels [70].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Listing 2 . 1 :</head><label>21</label><figDesc>QVT Relation for mapping packages to schemas. 1 t r a n s f o r m a t i o n umlToRdbms ( uml : SimpleUML , rdbms : SimpleRDBMS )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Listing 2 . 2 :</head><label>22</label><figDesc>ATL snippet MM1 2 MM2. 1 module MM1_2_MM2 2 c r e a t e OUT : MM2 from IN : MM1;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 2 . 2 :</head><label>22</label><figDesc>Figure 2.2: PacMan type graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 2 . 3 :</head><label>23</label><figDesc>Figure 2.3: Instance graph for the PacMan type graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Example 3 . 5 .Figure 2 . 4 :</head><label>3524</label><figDesc>Figure 2.4: Graph transformation rule that moves PacMan.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2.5 shows a simple QBE query demonstrating how the visual syntax looks like.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Listing 2 . 3 :</head><label>23</label><figDesc>ActionScript 3.0 code for the transition presented in Figure 2.6. 1 import f l . motion . Animator ; 2 var t e s t _ x m l :XML = &lt;Motion d u r a t i o n = " 18 " xmlns= " f l . motion . * " 3 xmlns : geom= " f l a s h . geom . * " xmlns : f i l t e r s = " f l a s h . f i l t e r s .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 2 . 6 :</head><label>26</label><figDesc>Figure 2.6: Simple transition in Flash using motion tweens.</figDesc><graphic coords="36,111.50,103.03,354.33,112.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>13 &lt;</head><label>13</label><figDesc>e c t a n g l e l e f t = "-40" top= "-40" width= " 80 " h e i g h t = " 80 " /&gt; 9 &lt;/dimensions &gt; 10 &lt; t r a n s f o r m a t i o n P o i n t &gt; 11 &lt;geom : P o i n t x= " 0 . 5 " y= " 0 . 5 " /&gt; 12 &lt;/ t r a n s f o r m a t i o n P o i n t &gt;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc><ref type="bibr" target="#b29">17</ref> " tweenSnap= " t r u e " tweenSync= " t r u e " x= " 1 s t _ a n i m a t o r : Animator = new Animator ( t e s t _ x m l , t e s t ) ; 30 t e s t _ a n i m a t o r . play ( ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 2 . 7 :</head><label>27</label><figDesc>Figure 2.7: Simple TBE rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 3 . 1 :</head><label>31</label><figDesc>Figure 3.1: The OMG's metamodeling stack in the light of MTBE<ref type="bibr" target="#b80">[68]</ref> </figDesc><graphic coords="41,193.74,261.46,225.19,62.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 3 . 3 ,Figure 3 . 3 :</head><label>3333</label><figDesc>Figure 3.3, which is based on their work, illustrates the general notion of a transformation model. Refinements of this presentation are found in [9]. In the left part of the figure we have marked the OMG's layers as well as corresponding example modeling artifacts M M 1 and M 1. Further, we have sketched in a second metamodel M M 2 with corresponding model M 2. As we already know from Chapter 2, a model transformation operates on a given source model to produce a specified target model. In addition, this model transformation has to be aware of the metamodels representing the types or</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 3 . 4 :</head><label>34</label><figDesc>Figure 3.4: Taxonomy of schema integration conflicts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>10 ©</head><label>10</label><figDesc>2007 BIG Vienna University of Technology, TK &amp; IFS University Linz</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 3 . 5 :</head><label>35</label><figDesc>Figure 3.5: Attribute integration conflicts, (a) and (b) being different modeling languages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Example 15 .Figure 3 . 6 :</head><label>1536</label><figDesc>Figure 3.6: Property expressed as (a) discriminator, (b) attribute, (c) reference.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>12 ©Figure 3 . 7 :</head><label>1237</label><figDesc>Figure 3.7: Reference direction and property set/subset mismatch.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Example 18 .</head><label>18</label><figDesc>Figure 3.7 shows the aforementioned example of defining the inheritance concept for classes by means of references (cf. Figure3.7 subClasses and superClasses) which are the inverse to each other. If one wants to transform models from the left to right hand side, the reference super-Classes must be computed as by the following OCL constraint.Reference superClasses:= Class.allInstances() -&gt;select(e|e.subClasses = obj1);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>13 ©</head><label>13</label><figDesc>2007 BIG Vienna University of Technology, TK &amp; IFS University Linz</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Figure 3 . 8 :</head><label>38</label><figDesc>Figure 3.8: Concept definition conflicts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Example 22 .</head><label>22</label><figDesc>Figure 3.8 illustrates a reference/class conflict for the concept of generalization of (a) and (b) in mapping 2. In (a) we modeled the the generalization concept as simple reference called superClasses. However, in (b) we introduced an additional class called Generalization to model inheritance graphs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>14 ©</head><label>14</label><figDesc>2007 BIG Vienna University of Technology, TK &amp; IFS University Linz</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>Figure 3 . 9 :</head><label>39</label><figDesc>Figure 3.9: Implicitly missing property.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>Figure 3 . 10 :</head><label>310</label><figDesc>Figure 3.10: Part of the UML kernel as pseudo-ontology and as refactored ontology.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>Figure 3 . 11 :</head><label>311</label><figDesc>Figure 3.11: Modeling languages and their concrete syntax.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>Figure 3 . 13 :</head><label>313</label><figDesc>Figure 3.13: Three characteristics of the EM 2 metric.</figDesc><graphic coords="62,373.97,122.05,78.43,51.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>Figure 3 . 14 :</head><label>314</label><figDesc>Figure 3.14: Side effects of the EM 2 metric.</figDesc><graphic coords="63,145.02,122.83,81.51,53.63" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>Figure 3 . 15 :</head><label>315</label><figDesc>Figure 3.15: Results for UML 2.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_33"><head>Figure 3 . 16 :</head><label>316</label><figDesc>Figure 3.16: Demonstrating nesting problems: insufficient example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_34"><head>Figure 3 . 17 :Listing 3 . 2 :}Listing 3 . 4 : 2 A</head><label>31732342</label><figDesc>Figure 3.17: Demonstrating nesting problems: sufficient example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_35"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4.1 illustrates this problem by an alignment scenario for UML and ER models. The upper half of Figure4.1 depicts that for the user it is appropriate to reason on models representing real world examples expressed in concrete notation of the modeling language to find the semantic equivalent parts. In contrast, the lower half of Figure4.1 shows the same domain model in abstract syntax visualized as an UML object model. As one can see, the abstract syntax is designed for the computer in order to process the models efficiently and not for the visualization of the domain knowledge in an easy understandable way. Hence, when trying to understand a domain model in abstract syntax one has to explore more model elements compared to the concrete notation representation, and furthermore, one has to know all relevant details of the metamodel, i.e., the language definition. Moreover, this problem is further aggravated by the following issue.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_36"><head>Figure 4 . 1 :</head><label>41</label><figDesc>Figure 4.1: Gap between user intention and computer representation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_37"><head>Figure 4 . 2 :</head><label>42</label><figDesc>Figure 4.2: Concept hiding in metamodels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_39"><head>Figure 4 . 3 :</head><label>43</label><figDesc>Figure 4.3: MTBE conceptual framework.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_40"><head>MappingFigure 4 . 4 :</head><label>44</label><figDesc>Figure 4.4: MTBE for UML2ER and vice versa.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_41"><head>Figure 4 . 4 .Figure 4 . 4</head><label>4444</label><figDesc>Figure 4.4 are quite simple, however, they are sufficient to show the most important aspects of our proposed MTBE approach.In the following subsections the steps 2 and 3 of the MTBE framework (cf. Figure6.3) are discussed in more detail. Step 2 has to be carried out by users themselves and concerns the alignment of two domain models shown in concrete syntax (cf. subsection 4.4.2). Step 3 is split into 4 sub-steps, to give an in-depth discussion of the work the MTGen has to do. In particular, we explain how the abstract syntax is analyzed to collect all necessary data for the model transformations. Therefore, we interpret the models shown in abstract syntax as object models consisting of objects, attribute values and links, because these models can be seen as instances of the metamodel, which again can be seen as a simple class diagram. Consequently, we first explain the creation of objects (cf. subsection 4.5.1), then the placement of attribute values (cf. subsection 4.5.1), and finally the linking of objects (cf. subsection 4.5.1). By collecting the data of these three sub-steps, it is possible to derive all necessary information in order to define the query parts (e.g., the from part of ATL rules) and also the generation parts (e.g., the to part of ATL rules) of the model transformation rules (cf. subsection 4.5.3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_42"><head>Figure 4 . 5 :</head><label>45</label><figDesc>Figure 4.5: MTBE workbench vision.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_43"><head>Figure 4 . 8 :</head><label>48</label><figDesc>Figure 4.8: Basic metamodel mapping language.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_44"><head>9 ) 10 t</head><label>910</label><figDesc>UML! P r o pe r t y ( 6 p . owningClass . o c l I s U n d e f i n e d ( ) 7 = f a l s e and 8 p . a s s o c i a t i o n . o c l I s U n d e f i n e d ( ) o a : ER ! A t t r i b u t e (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_45"><head>Contents 5 . 1</head><label>51</label><figDesc>Adding Expressiveness to the Model Mapping Language . . . . . . . . . . 75 5.2 Reasoning based Pattern Matching . . . . . . . . . . . . . . . . . . . . . . . 79 5.3 Adding Expressiveness to the Metamodel Mapping Language . . . . . . . 81 5.4 Advanced Reasoning Algorithms . . . . . . . . . . . . . . . . . . . . . . . . 83 5.5 A Two Step Transformation Process . . . . . . . . . . . . . . . . . . . . . . 84</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_47"><head>Figure 5 . 1 :</head><label>51</label><figDesc>Figure 5.1: Extended model mapping language.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_48"><head>Figure 5 . 4 :</head><label>54</label><figDesc>Figure 5.4: Core analyzer patterns.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_49"><head>Figure 5 . 5 :</head><label>55</label><figDesc>Figure 5.5: Extended metamodel mapping language.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_50"><head>Figure 5 . 6 :</head><label>56</label><figDesc>Figure 5.6: Reasoning about derived associations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_51"><head>Figure 5 . 7 : 2 -</head><label>572</label><figDesc>Figure 5.7: 2-step transformation generation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_52"><head>Figure 6 . 1 :</head><label>61</label><figDesc>Figure 6.1: Overview of the Graphical Modeling Framework.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_53"><head>6. 1 1 Figure 6 . 2 :</head><label>1162</label><figDesc>Figure 6.2: How GMF deals with notation and concrete syntax.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_54"><head>Figure 6 . 3 :</head><label>63</label><figDesc>Figure 6.3: Framework architecture, (1) Underlying frameworks, (2) User front-end, (3) Pattern matching and creation of weavings, (4) Transformation model generation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_55"><head>Figure 6 . 4 :</head><label>64</label><figDesc>Figure 6.4: MTBE Prototype, (a) Mapping editor, (b) Merged Ecore model and merged mapping definition model, (c) Automatically produced weaving model.</figDesc><graphic coords="112,88.82,212.23,399.70,294.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_56"><head>Figure 7 . 1 :</head><label>71</label><figDesc>Figure 7.1: Simplified ER and UML metamodels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_57"><head>Figure 7 . 2 :</head><label>72</label><figDesc>Figure 7.2: Model mappings between ER and UML example models.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_58"><head>Listing 7 . 1 :</head><label>71</label><figDesc>ER2UML transformation including user refined code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_59"><head>1 -- 2 module</head><label>12</label><figDesc>@ a t l c o m p i l e r a t l 2 0 0 6 ER2UML ; --Module Template 3 c r e a t e OUT : UML from IN : ER ; s s e s &lt;-d . e n t i t i e s , 9 a s s o c i a t i o n s &lt;-d . r e l a t i o n s h i p e a t t r i b u t e 2 p r o p e r t y { 22 from a : ER ! A t t r i b u t e Chapter 7 Applications of MTBE name &lt;-a . name ) } r u l e r e l a t i o n s h i p 2 a s s o c i a t i o n { from r e l : ER ! R e l a t i o n s h i p t o a : UML! A s s o c i a t i o n ( name &lt;-r e l . ownedRoles . f i r s t ( ) . name+ ' _2_ ' + r e l . ownedRoles . l a s t ( ) . name , memberEnd &lt;-r e l . ownedRoles -&gt; c o l l e c t ( t | thisModule . resolveTemp ( Tuple { r = t , m = t . m u l t i p l i c i t y } , ' p ' ) e r o l e _ m u l t i p l i c i t y 2 p r o p e r t y { from r : ER ! Role , m : ER ! M u l t i p l i c i t y ( r . m u l t i p l i c i t y = m ) t o p : UML! P r o pe r t y ( name &lt;-r . name , c l a s s &lt;-ER ! R e l a t i o n s h i p . a l l I n s t a n c e s ( ) -&gt; s e l e c t ( x|x . ownedRoles -&gt; c o l l e c t ( y|y . type)-&gt; i n c l u d e s ( r . type ) ) -&gt; c o l l e c t ( y|y . ownedRoles ) . f l a t t e n ( ) -&gt; s e l e c t ( y|y . type &lt;&gt; r . type ) . f i r s t ( ) . type , upper &lt;-m. upper ) } Listing 7.2: UML2ER transformation including user refined code. --@ a t l c o m p i l e r a t l 2 0 0 6 module UML2ER ; --Module Template c r e a t e OUT : ER from IN : UML;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_60"><head>-</head><label></label><figDesc>helper def : g e t R e l a t i o n s h i p ( r o l e : ER ! Role ) : ER ! R e l a t i o n s h i p = ER ! R e l a t i o n s h i p . a l l I n s t a n c e s ()-&gt; s e l e c t ( e|e . ownedRoles -&gt; i n c l u d e s ( r o l e ) ) . f i r s t ( ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_61"><head></head><label></label><figDesc>u l e diagramRoot2diagram { from dr : UML! diagramRoot t o d : ER ! Diagram ( e n t i t i e s &lt;-dr . c l a s s e s , r e l a t i o n s &lt;-dr . a s s o c i a t i o n s , r o l e s &lt;-dr . c l a s s e s -&gt; c o l l e c t ( x|x . ownedAttributes ) . f l a t t e n ( ) -&gt; s e l e c t ( x| not x . a s s o c i a t i o n . o c l I s U n d e f i n e d ( ) ) ) } r u l e c l a s s 2 e n t i t y { from c : UML! C l a s s t o e : ER ! E n t i t y ( name &lt;-c . name , ownedAttribute &lt;-c . ownedAttributes -&gt; s e l e c t ( x|x . a s s o c i a t i o n . o c l I s U n d e f i n e d ( ) ) e p r o p e r t y 2 a t t r i b u t e { 33 from p : UML! P r o pe r t y ( p . a s s o c i a t i o n . o c l I s U n d e f i n e d ( ) ) 34 t o a : ER ! A t t r i b u t e ( e a s s o c i a t i o n 2 r e l a t i o n s h i p { 40 from a : UML! A s s o c i a t i o n</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_62"><head>Figure 7 . 3 :</head><label>73</label><figDesc>Figure 7.3: Parts of the UML 2.1 AD metamodel and its concrete syntax.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_63"><head>Figure 7 . 4 :</head><label>74</label><figDesc>Figure 7.4: Parts of the EPC metamodel and its concrete syntax.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_64"><head>Figure 7 . 5 :</head><label>75</label><figDesc>Figure 7.5: Overview of BP model heterogeneities.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_65"><head>Figure 7 . 6 :</head><label>76</label><figDesc>Figure 7.6: Mapping EPC and UML activity diagram -CS + AS perspectives.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_66"><head>7. 2</head><label>2</label><figDesc>Application to Behavioral Modeling Languages</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_67"><head>Listing 7 . 3 : 2 from 3 s 4 t o 5 i</head><label>732345</label><figDesc>ATL rule for Event2InitialNode and Event2FlowFinal. 1 r u l e S t a r t E v e n t 2 I n i t i a l N o d e { : EPC ! Event ( s . incoming-&gt;s i z e ( ) = 0 ) : A c t i v i t y ! I n i t i a l N o d e ( . . . )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_68"><head>( 7 . 1 ) 1 r</head><label>711</label><figDesc>EP C!Event.allInstances()-&gt; select(e|e.incoming-&gt; size() = 0)-&gt; asSet()-&gt; intersection(EP C!Event.allInstances()-&gt; select(e|e.outgoing-&gt; size() = 0)) -&gt; size() = 0EventControlFlowFunction2OpaqueAction. Now we want to cope with the user mapping e of Figure 7.6. From the model itself and especially the metamodel we know, that in EPC there are three distinct concepts involved whereas in UML Activity diagrams only one concept is affected. For this reason we use a new feature coming along with ATL 2006, i.e., the matching of multiple source pattern elements, see Listing 7.4. Note that the returned set of elements from matched multiple source pattern elements corresponds to the cartesian product. Listing 7.4: ATL rule for EventControlFlowFunction2OpaqueAction. ! B a s i c F u n c t i o n ( 6 c . t a r g e t = f and c . s o u r c e = ev and 7 ev . incoming-&gt;s i z e ( ) &lt;&gt; 0 and 8 ev . outgoing-&gt;s i z e (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_69"><head>1 r</head><label>1</label><figDesc>A c t i v i t y ! JoinNode ( . . . ) 19 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_70"><head>Figure 7 . 7 :</head><label>77</label><figDesc>Figure 7.7: Challenges for MTBE in business process models.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_71"><head>4 )</head><label>4</label><figDesc>Proving MTBE: Usually, models evolve in the course of time. For example, a model Chapter 8 Open Issues and Future Work</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="42,88.82,190.09,399.68,349.77" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>1: Wise-men puzzle: state space. of which color it is made of. Instead he can see what color the hats of the other two wise men have.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>and NAME from the table PERSON, whose DAY OF BIRTH equals 1980-01-27. In SQL this QBE query would be expressed as follows: Joins upon several tables can be achieved by using the same variable names across different tables as depicted in Figure2.5(b). Here the variable name ID is referenced by table PROJECTS to ensure, only tuples, that are related via a distinct SSN to each other, form a solution. Again, in SQL this QBE query looks like:</figDesc><table><row><cell>SELECT SSN, NAME</cell></row><row><cell>FROM PERSON</cell></row><row><cell>WHERE DAYOFBIRTH='1980-01-27';</cell></row><row><cell>Example 6. SELECT SSN, NAME, PROJECTNAME</cell></row><row><cell>FROM PERSON p, PROJECT pr</cell></row><row><cell>WHERE p.SSN = pr.SSN AND DAYOFBIRTH='1980-01-27';</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Contents 3.1 The Metamodeling Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . .</head><label></label><figDesc></figDesc><table><row><cell>3.1.1 The Ecore Model -Core Concepts Reviewed . . . . . . . . . . . . . .</cell></row><row><cell>3.1.2 Differences between Ecore and MOF . . . . . . . . . . . . . . . . . .</cell></row><row><cell>3.1.3 Models and Transformations . . . . . . . . . . . . . . . . . . . . . . .</cell></row><row><cell>3.1.4 Horizontal vs. Vertical Model Transformations . . . . . . . . . . . .</cell></row><row><cell>3</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>.2 Metamodel Heterogeneities . . . . . . . . . . . . . . . . . . . . . . . . . . . 3</head><label></label><figDesc>.2.1 Attribute Conflicts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2.2 Structural Conflicts . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2.3 Semantic Conflicts . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>3.3 Model Heterogeneities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.4 Refactoring Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</head><label></label><figDesc></figDesc><table><row><cell>3.4.1 Patterns for Reification of Concepts . . . . . . . . . . . . . . . . . . .</cell></row><row><cell>3.4.2 Patterns for Elimination of Abstract Concepts . . . . . . . . . . . . .</cell></row><row><cell>3.4.3 Patterns for Explicit Specialization of Concepts . . . . . . . . . . . .</cell></row><row><cell>3.4.4 Patterns for Exploring Combinations of Refactored Concepts . . . .</cell></row><row><cell>3</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>.5 Concrete Syntax vs. Notation . . . . . . . . . . . . . . . . . . . . . . . . . . 3.6 Metamodel Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</head><label></label><figDesc></figDesc><table><row><cell>3.6.1 Calculating the Explicitness of Metamodels . . . . . . . . . . . . . .</cell></row><row><cell>3.6.2 Analysing UML 1.4 and UML 2.1 . . . . . . . . . . . . . . . . . . . .</cell></row><row><cell>3.6.3 Metrics-Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . .</cell></row><row><cell>3</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>.7 Requirements for Example Models . . . . . . . . . . . . . . . . . . . . . . .</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>3.1.4 Horizontal vs. Vertical Model Transformations</head><label></label><figDesc></figDesc><table><row><cell>3.2 Metamodel Heterogeneities</cell></row><row><cell>MTBE primarily targets the use case of horizontal model transformations. But what about</cell></row><row><cell>vertical model transformations from, e.g., platform independent to platform specific models</cell></row><row><cell>(PIM, PSM)? A vertical model transformation results in a decrease in abstraction, whereas a</cell></row><row><cell>horizontal model transformation leaves the level of abstraction unchanged. If UML is used</cell></row><row><cell>to create an abstract model, i.e. a PIM, one can easily define stereotypes to extend the UML</cell></row><row><cell>metamodel. The mapping of stereotypes has not yet been tested in the context of MTBE.</cell></row><row><cell>Though this type of extension mechanism should not pose any problem.</cell></row><row><cell>Another way to model in a more concrete way building a separate metamodel. Then</cell></row><row><cell>all concepts are represented in terms of a metamodel independent of the model. Taking</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Metamodel Conflict Attribute Structural Semantic Conflict Conflict Conflict DataType Conflict Property Definition Conflict Concept Definition Conflict Naming Conflict Scaling Conflict DefaultValue C f l i t Discriminator/ Attribute/ Reference Conflict Domain/Range C f l i t Attribute/Class Conflict Reference/Class C f l i t Synonym Homonym Conflict ValueRepresentation Conflict Intensional Conflict Conflict 1:n Property Conflict Conflict y Reference/ Attribute Conflict Multiplicity Conflict 1:n Reference Conflict 1:n Attribute Conflict Missing Properties Implicitly Missing Properties Conflict Extensional Conflict Properties Subset Overlapping</head><label></label><figDesc></figDesc><table><row><cell>• Aggregation</cell><cell></cell></row><row><cell>© 2007 BIG Vienna University of Technology, TK &amp; IFS University Linz</cell><cell>6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>• Reference: Multiplicity, Ordered, U i T iti Cl</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head>Chapter 6 Implementation Contents 6.1 Overview of the Graphical Modeling Framework . . . . . . . . . . . . . . 87 6.2 An Eclipse Based Implementation for MTBE . . . . . . . . . . . . . . . . . 91</head><label></label><figDesc>6.2.1 MTBE Workbench . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 6.2.2 Integration of GMF . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 6.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head>3 Critical Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96</head><label></label><figDesc>6.3.1 Implementation Status . . . . . . . . . . . . . . . . . . . . . . . . . . 96 6.3.2 Discussing the GMF Approach . . . . . . . . . . . . . . . . . . . . . 96 6.3.3 Alternative Implementation Approaches . . . . . . . . . . . . . . . . 96 6.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head>4 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_19"><head>Contents 7.1 Application to Structural Modeling Languages . . . . . . . . . . . . . . . . 99</head><label></label><figDesc>7.1.1 Integration Problem: ER2UML . . . . . . . . . . . . . . . . . . . . . . 100 7.1.2 User defined Model Mappings . . . . . . . . . . . . . . . . . . . . . . 101 7.1.3 Reasoning and Metamodel Mappings . . . . . . . . . . . . . . . . . . 103 7.1.4 ATL Code Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 7.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20"><head>2 Application to Behavioral Modeling Languages . . . . . . . . . . . . . . . 106</head><label></label><figDesc></figDesc><table /><note><p>7.2.1 Models for Business Processes . . . . . . . . . . . . . . . . . . . . . . 106 7.2.2 Dealing with Heterogeneities in Business Procss Models . . . . . . . 108 7.2.3 Integration Problem: UML AD and EPC . . . . . . . . . . . . . . . . 110 7.2.4 Model Mappings and Metamodel Mappings . . . . . . . . . . . . . . 110 7.3 Critical Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_22"><head></head><label></label><figDesc>Function and Event elements must alternate in the proceed of the BP model and are connected via the Control Flow. This feature</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Chapter 7 Applications of MTBE</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">EPC Business Process</cell></row><row><cell></cell><cell>references</cell><cell></cell><cell></cell><cell cols="2">1</cell><cell>name:string version:string</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1</cell><cell>1</cell></row><row><cell></cell><cell></cell><cell>0..*</cell><cell></cell><cell></cell><cell>source</cell><cell>outgoing</cell><cell>0..*</cell></row><row><cell>AS</cell><cell cols="2">Process Flow Objects</cell><cell></cell><cell>1</cell><cell>target</cell><cell>incoming 0..*</cell><cell>Control Flow</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">1</cell><cell>0..*</cell></row><row><cell></cell><cell></cell><cell>Function</cell><cell></cell><cell></cell><cell></cell><cell>Event</cell><cell>Logical Operator</cell></row><row><cell></cell><cell cols="2">Complex Function</cell><cell cols="4">Basic Function</cell><cell>XOR</cell><cell>OR</cell><cell>AND</cell></row><row><cell></cell><cell>Event</cell><cell cols="2">Basic Function</cell><cell cols="3">Complex Function</cell><cell>AND</cell><cell>OR</cell><cell>XOR</cell></row><row><cell>CS</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>AND</cell><cell>OR</cell><cell>XOR</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_23"><head>Table 7 .</head><label>7</label><figDesc>4: Summary of metamodel mappings for BP models.</figDesc><table><row><cell>MAP UML AD MM Elements</cell><cell>EPC MM Elements</cell><cell>Mapping</cell><cell>Comment</cell><cell>Pattern</cell><cell>Model MAP</cell></row><row><cell>C1 Activity</cell><cell>EPCBusinessProcess</cell><cell cols="2">Full Equiv. Reasoned via GMF properties</cell><cell>X</cell><cell>X</cell></row><row><cell>C2 InitialNode</cell><cell>Event</cell><cell cols="2">Cond. Equiv. Event.incoming -&gt; size() = 0</cell><cell>Pattern 6</cell><cell>(a)</cell></row><row><cell>C3 ActivityFinalNode</cell><cell>Event</cell><cell cols="2">Cond. Equiv. Event.outgoing -&gt; size() = 0</cell><cell>Pattern 6</cell><cell>(g)</cell></row><row><cell>C4 ControlFlow</cell><cell>ControlFlow</cell><cell cols="2">Cond. Equiv. Property.association == null</cell><cell>Pattern 1+6</cell><cell>(b)</cell></row><row><cell>C5 OpaqueAction</cell><cell>BasicFunction</cell><cell cols="2">Cond. Equiv. BasicFunction that succeeds a</cell><cell>Pattern 6</cell><cell>(c)</cell></row><row><cell></cell><cell></cell><cell cols="2">"StartEvent" or OpaqueAction</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">that succeeds InitialNode</cell><cell></cell><cell></cell></row><row><cell>C6 ForkNode</cell><cell>AND</cell><cell cols="2">Cond. Equiv. AND.incoming -&gt; size() = 1 and</cell><cell>Pattern 6</cell><cell>(d)</cell></row><row><cell></cell><cell></cell><cell cols="2">AND.outgoing -&gt; size() &gt; 1</cell><cell></cell><cell></cell></row><row><cell>C7 JoinNode</cell><cell>AND</cell><cell cols="2">Cond. Equiv. AND.incoming -&gt; size() &gt; 1 and</cell><cell>Pattern 6</cell><cell>(f)</cell></row><row><cell></cell><cell></cell><cell cols="2">AND.outgoing -&gt; size() = 1</cell><cell></cell><cell></cell></row><row><cell>C8 OpaqueAction</cell><cell>Event ControlFlow</cell><cell cols="2">Cond. Equiv. Event.incoming -&gt; size() &lt;&gt; 0</cell><cell>Pattern 5</cell><cell>(e)</cell></row><row><cell></cell><cell>BasicFuncition</cell><cell>and</cell><cell>Event.outgoing</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">-&gt; size() &lt;&gt; 0</cell><cell></cell><cell></cell></row><row><cell>A1 Activity.name</cell><cell>EPCBusinessProcess.name</cell><cell>Full Equiv.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>A2 Activity.version</cell><cell>EPCBusinessProcess.version</cell><cell>Full Equiv.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>A3 InitialNode.name</cell><cell>Event.name</cell><cell>Full Equiv.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>A4 ActivityFlowFinal.name</cell><cell>Event.name</cell><cell>Full Equiv.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>A5 OpaqueAction.name</cell><cell>BasicFunction.name</cell><cell>Full Equiv.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>A6 OpaqueAction.name</cell><cell>Event.name</cell><cell cols="2">Full Equiv. Exp Annotation</cell><cell></cell><cell>(h)</cell></row><row><cell></cell><cell>BasicFuncition.name</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>R1 ControlFlow.outgoing</cell><cell>ControlFlow.outgoing</cell><cell>Full Equiv.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>R2 ControlFlow.incoming</cell><cell>ControlFlow.incoming</cell><cell>Full Equiv.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>R2 ActivityNode.source</cell><cell>ProcessFlowObjects.source</cell><cell>Full Equiv.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>R4 ActivityNode.target</cell><cell>ProcessFlowObjects.target</cell><cell>Full Equiv.</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://smartqvt.elibel.tm.fr/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.eclipse.org/m2m/atl/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>www.stagecast.com</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_3"><p>)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_4"><p>http://modelcvs.org/prototypes/mtbe.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_5"><p>t o p : UML! P r o p er t y (</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_6"><p>an . outgoing-&gt;s i z e ( ) = 1</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_7"><p>)</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Requirements for Example Models</head><p>2 &lt; e r : Root xmi : v e r s i o n = " 2 . 0 " xmlns : xmi= " h t t p ://www. omg . org/XMI" xmlns : e r = " h t t p :// e r " &gt; 3 &lt; e n t i t i e s name= " J e d i " /&gt; 4 &lt; e n t i t i e s name= "XWing" /&gt;   thus allowing for semantic variation points as in UML. And second the meaning of a mapping gets determined only when we perform some reasoning on these model mappings in order to deduce a proper mapping model on the M2 layer. Abstract Syntax. Figure <ref type="figure">4</ref>.6 defines a very basic mapping language for MTBE, which solely consists of one mapping operator, i.e., our SimpleMapping.</p><p>context SimpleMapping inv: self.lhs-&gt;size()=1 and self.rhs-&gt;size()=1</p><p>Concrete Syntax. Figure <ref type="figure">4</ref>.7 shows the CS for our basic mapping language according to the AS defined above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">Mapping Definitions By-Example</head><p>The user has to define mappings between model elements of the two concrete domain models as shown in Figure <ref type="figure">4</ref>.4 page 61. These mappings are illustrated by thin dotted lines between elements of the two models in Figure <ref type="figure">4</ref>.4 page 61. For the sake of clarity, we omitted some of the mappings as this helps to focus on those mappings that are of special interest for our algorithms explained in the next subsections. As mentioned before mappings specified by users are solely full equivalence mappings, i.e. one-to-one mappings. Furthermore,  In general, the generation of transformation code dealing with object and value creation is rather simple. What complicates our automatic transformation model generation are links between the objects, especially when the metamodels have different structures due to structural heterogeneities. The first three ATL rules shown in Listing 7.1 can be derived fully automatically. Rule relationship2association comprises a tricky part in lines 32 to 34. Because we deal with multiple source pattern matching in rule role_multiplicity2property, we have to use the resolveTemp construct to query produced properties. Therefore, this reference assignment looks complicated in ATL, but may be generated out of the metamodel mappings. An issue we have to deal with manually is depicted in lines 47 to 50 of the last rule. As for roles in ER, we also have to set the container for the corresponding properties in UML. However, the concept of a role is mirrored among ER and UML and therefore it was not possible to automatically produce a metamodel mapping which is also depicted in Table 2 mapping R1. Therefore, a rather complicated query has to be defined by the user, which assigns properties to classes.</p><p>For the sake of completeness we provide the ATL code for the other transformation direction in Listing 7.2 where similar user adjustments have been made to obtain a complete and correct transformation output.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Application to Behavioral Modeling Languages</head><p>Instead of focusing on the domain of structural modeling languages, what has been done in previous investigations <ref type="bibr" target="#b101">[89]</ref>, <ref type="bibr" target="#b96">[84]</ref>, in this section we concentrate on behavioral modeling languages. More specifically, we apply MTBE on the domain of business process modeling (BPM), which, up to our best knowledge, has not yet been subject to the MTBE approach. The definition of requirements for MTBE in the context of business process modeling and how they can be met in terms of proper generation of transformation rules comprise the main contribution of this section. Therefore, we present main challenges encountered in business process (BP) model transformations, and how these challenges can be tackled by using our extended MTBE mapping operators and reasoning algorithms in order to allow a more sophisticated model transformation code generation. Furthermore, we present a case study in which two prominent BP modeling languages are used, namely the UML Activity Diagram and Event Driven Process Chains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Models for Business Processes</head><p>Business process models are in use for quite a long time and continue to gain importance as support from the software engineering field is improving significantly. Particularly model engineering fosters research in the area of BPM. There exist several metamodels for existing languages in order to raise there acceptance and tool interoperability. Due to this growing interest in BPM and proper tool support, we believe MTBE can be advantageous for specifying model transformations between BP models. Usually BP models cover various perspectives as e.g. described in <ref type="bibr" target="#b31">[19]</ref>. The following two BP modeling languages we choose to use in our case study presented in Section 7.2.3, however, cover only the behavioral perspectives of BPM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UML 2.1 Activity Diagram</head><p>The UML 2.1 Activity Diagram (UML AD) <ref type="bibr" target="#b81">[69]</ref> is a specification of the Object Management Group. The metamodel of Figure <ref type="figure">7</ref>.3 depicts an excerpt of the UML AD language, namely the basic control flow elements which are used for modeling BP models, as well as the concrete syntax.</p><p>The central element is the Opaque Action, which is used to model the activities within a process. The Call Behavior Action represents the concept of a sub process call. Control Nodes are used to structure the process. More specifically, a Fork Node and a Join Node express a concurrent flow as well as a Decision Node and a Merge Node to express an alternative flow. The Initial Node marks the begin of a process model. The UML AD differs between two final nodes, the Flow Final Node (FFN) and the Activity Final Node (AFN). The FFN is used to mark the final of a distinct flow, that means if it is reached the remaining tokens in the process Chapter 7 Applications of MTBE In EPC's there are no distinct metamodel elements nor distinct concrete syntax elements for start and end nodes, although these concepts are used in the modeling language implicitly. In UML AD we do have explicit concepts for start and end nodes both, in the model and the metamodel. If a transformation from EPC2UML_AD has to be performed the transformation model must know how to distinguish between start and end nodes even without having these concepts specified in EPC. We will elaborate on this issue in 7.2.4. Table <ref type="table">7</ref>.2.4 summarizes the above described user mappings in a compact and clear manner.</p><p>To keep our illustration in Figure <ref type="figure">7</ref>.6 transparent and clear we omitted the mappings between CS and AS. Also these mappings are quite straightforward to define, as there are no constraints specified in the notation.</p><p>At last the mappings between the two metamodels can be derived from the user mappings and the notation. To highlight the existence of a compound mapping in the metamodel we marked the three involved mappings with an and operator. On the metamodel mapping level we now make use of our new XOR operator we introduced in Section 7.2.2. To keep the mapping task user-friendly the XOR between mappings can be reasoned automatically based on information in the metamodels. Whenever a meta class contains at least two outgoing mapping edges, an XOR relation can be set in an implicit way. A complete list of metamodel mappings including EAttribute and EReference mappings is shown in Table <ref type="table">7</ref>.2.4. Note, that XOR mappings are expressed in our weaving model by means of conditional equivalence mappings with proper OCL conditions, which will be explained later in this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>How to Make Mappings Executable</head><p>As the automatic generation of transformation rules is a difficult task, we do not claim to support fully automatic rule generation. Instead we believe in a semi-automatic approach. To face the new domain of business process models we implemented a methodology, which </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Curriculum Vitae</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Teaching Experience</head><p>Teaching assistant: • Courses on Programming Basics (Java)</p><p>• Courses on Web Engineering</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Additional Competence</head><p>• Adviser and Referent at the HochschülerInnenschaft an der TU Wien (HTU) <ref type="bibr">(2002 -2006)</ref> </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">QVT Relation for mapping packages to schemas</title>
		<author>
			<orgName type="collaboration">. . . . . . . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">2 ATL snippet MM1 2 MM2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">1 Incomplete ATL transformation for simpleUML to simpleER. . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">2 XMI resulting from Listing 3.1. . . . . . . . . . . . . . . . . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">Correct ATL transformation for simpleUML to simpleER. . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">XMI resulting from Listing 3.3. . . . . . . . . . . . . . . . . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">1 ATL rule for Attribute2Property. . . . . . . . . . . . . . . . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">2 ATL rule for Property2Attribute. . . . . . . . . . . . . . . . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">1 ER2UML transformation including user refined code. . . . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">2 UML2ER transformation including user refined code. . . . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">ATL rule for Event2InitialNode and Event</title>
		<author>
			<orgName type="collaboration">2FlowFinal. . . . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">ATL rule for EventControlFlowFunction2OpaqueAction. . . . . . . . . . . .</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<author>
			<orgName type="collaboration">5 ATL rule for And2Fork and And2Join. . . . . . . . . . . . . . . . . . . . . . . . xv C</orgName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Constraint NM2:NodeMapping NM1:NodeMapping EntityFigure:Node WeakEntityFigure:Node (</title>
		<imprint>
			<publisher>CreationTool</publisher>
			<biblScope unit="volume">2</biblScope>
		</imprint>
		<respStmt>
			<orgName>NodeMapping Label:Diagramlabel Attribute</orgName>
		</respStmt>
	</monogr>
	<note>CR1:ChildReference CR</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Reusable Idioms and Patterns in Graph Transformation Languages</title>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Attila</forename><surname>Vizhanyo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zsolt</forename><surname>Kalmar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anantha</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabor</forename><surname>Karsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Graph-Based Tools</title>
		<meeting>the International Workshop on Graph-Based Tools<address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">GraBaTs 2004. 2004</date>
		</imprint>
	</monogr>
	<note>Satellite workshop of ICGT 2004</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">ADT: Eclipse Development Tools for ATL</title>
		<author>
			<persName><forename type="first">Freddy</forename><surname>Allilaire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tarik</forename><surname>Idrissi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second European Workshop on Model Driven Architecture (MDA) with an emphasis on Methodologies and Transformations</title>
		<meeting>the Second European Workshop on Model Driven Architecture (MDA) with an emphasis on Methodologies and Transformations<address><addrLine>Canterbury, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Programming By Example: Visual Generalization in Programming By Example</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>St</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Amant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Lieberman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luke</forename><surname>Potter</surname></persName>
		</author>
		<author>
			<persName><surname>Zettlemoyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="107" to="114" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<orgName type="collaboration">ATLAS Group</orgName>
		</author>
		<ptr target="http://www.eclipse.org/m2m/atl/" />
		<title level="m">ATL (ATLAS Transformation Language)</title>
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
		</imprint>
	</monogr>
	<note>Last Visit</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><surname>Atlas Group</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lina</forename><forename type="middle">Atl</forename><surname>Inria</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manual</forename><surname>User</surname></persName>
		</author>
		<ptr target="http://www.eclipse.org/m2m/atl/doc/" />
		<title level="m">Last Visit</title>
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Schema and Ontology Matching with COMA++</title>
		<author>
			<persName><forename type="first">David</forename><surname>Aumueller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hong-Hai</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sabine</forename><surname>Massmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erhard</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;05: Proceedings of the 2005 ACM SIG-MOD International Conference on Management of Data</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="906" to="908" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Correctly Defined Concrete Syntax for Visual Modeling Languages</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Baar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 9th International Conference on Model Driven Engineering Languages and Systems</title>
		<meeting>9th International Conference on Model Driven Engineering Languages and Systems<address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">MoDELS 2006. 2006</date>
			<biblScope unit="volume">4199</biblScope>
			<biblScope unit="page" from="111" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">Jean</forename><surname>Bézivin</surname></persName>
		</author>
		<title level="m">On the Unification Power of Models. Software and System Modeling</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="171" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<author>
			<persName><forename type="first">Jean</forename><surname>Bézivin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Büttner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Gogolla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Kurtev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arne</forename><surname>Lindow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model Transformations? Transformation Models! In Proceedings of 9th International Conference on Model Driven Engineering Languages and Systems (MoDELS 2006)</title>
		<meeting><address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-10">October 2006</date>
			<biblScope unit="volume">4199</biblScope>
			<biblScope unit="page" from="440" to="453" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Data Semantics Revisited</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Borgida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Mylopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Workshop on Semantic Web and Databases (SWDB 2004)</title>
		<meeting>the Second International Workshop on Semantic Web and Databases (SWDB 2004)<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="9" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Transforming Object Oriented Models with BOTL</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Marschall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">Frank</forename><surname>Budinsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Steinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ed</forename><forename type="middle">Merks</forename><surname>Raymond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ellersick</forename><surname>Timothy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grose</surname></persName>
		</author>
		<title level="m">Eclipse Modeling Framework</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="2003-08">August 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">In search of a Basic Principle for Model Driven Engineering</title>
		<author>
			<persName><forename type="first">Jean</forename><surname>Bézivin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">UPGRADE</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="21" to="24" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">First Experiments with the ATL Model Transformation Language: Transforming XSLT into XQuery</title>
		<author>
			<persName><forename type="first">Jean</forename><surname>Bézivin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grégoire</forename><surname>Dupé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Pitette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jamal</forename><forename type="middle">Eddine</forename><surname>Rougui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the OOPSLA Workshop on Generative Techniques in the context of MDA</title>
		<meeting>the OOPSLA Workshop on Generative Techniques in the context of MDA<address><addrLine>Anaheim, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Designing Data-Intensive Web Applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ceri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fraternalia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bongio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bramilla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Comai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Matera</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Morgan-Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Conceptual Modeling of Data-Intensive Web Applications</title>
		<author>
			<persName><forename type="first">Stefano</forename><surname>Ceri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Piero</forename><surname>Fraternali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maristella</forename><surname>Matera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Internet Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="20" to="30" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The MMF Approach to Engineering Object-Oriented Design Languages</title>
		<author>
			<persName><forename type="first">Tony</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stuart</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Sammut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Language Descriptions, Tools and Applications</title>
		<meeting>the Workshop on Language Descriptions, Tools and Applications</meeting>
		<imprint>
			<publisher>LDTA</publisher>
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Metrics for Ontologies</title>
		<author>
			<persName><forename type="first">Valerie</forename><surname>Cross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anindita</forename><surname>Pal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Meeting of the North American Fuzzy Information Processing Society</title>
		<meeting>the Annual Meeting of the North American Fuzzy Information Processing Society</meeting>
		<imprint>
			<date type="published" when="2005-06">June 2005</date>
			<biblScope unit="page" from="448" to="453" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<author>
			<persName><forename type="first">Bill</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><forename type="middle">I</forename><surname>Kellner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jim</forename><surname>Over</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Process Modeling</title>
		<meeting>ess Modeling</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="75" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Watch What I Do: Programming by Demonstration</title>
		<author>
			<persName><forename type="first">Allen</forename><surname>Cypher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge, Massachusetts, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Feature-based Survey of Model Transformation Approaches</title>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Helsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Syst. J</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="621" to="645" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m">Eclipse Foundation. Eclipse Modeling Framework (EMF) -Ecore</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<ptr target="http://www.eclipse.org/modeling/emf/javadoc/" />
		<title level="m">Last Visit</title>
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<ptr target="http://www.eclipse.org/modeling/gmf/" />
		<title level="m">Graphical Modeling Framework (GMF)</title>
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
		</imprint>
	</monogr>
	<note>Last Visit</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Edwards</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Example Centric Programming. SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="84" to="91" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Handbook on Graph Grammars and Computing by Graph Transformation</title>
		<author>
			<persName><forename type="first">Hartmut</forename><surname>Ehring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregor</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans-Jörg</forename><surname>Kreowsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Rozenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">World Scientific</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">AMW: A Generic Model Weaver</title>
		<author>
			<persName><forename type="first">Marcos</forename><surname>Didonet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Del</forename><surname>Fabro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean</forename><surname>Bézivin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erwan</forename><surname>Breton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Gueltas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1ère Journée sur l&apos;Ingénierie Dirigée par les Modèles (IDM05)</title>
		<meeting>the 1ère Journée sur l&apos;Ingénierie Dirigée par les Modèles (IDM05)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Semi-automatic Model Integration using Matching Transformations and Weaving Models</title>
		<author>
			<persName><forename type="first">Marcos</forename><surname>Didonet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Del</forename><surname>Fabro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Valduriez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 ACM Symposium on Applied Computing (SAC)</title>
		<meeting>the 2007 ACM Symposium on Applied Computing (SAC)<address><addrLine>Seoul, Korea</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="963" to="970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Learning and Teaching Styles in Engineering Education</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Felder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Linda</forename><surname>Silverman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="674" to="681" />
			<date type="published" when="1988-02">February 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">Franck</forename><surname>Fleurey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benoit</forename><surname>Baudry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre-Alain</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yves</forename><surname>Le Traon</surname></persName>
		</author>
		<title level="m">Qualifying Input Test Data for Model Transformations. Software and Systems Modeling</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Concrete Syntax Definition For Modeling Languages</title>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Fondement</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EPFL</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Lausanne, France</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Making Metamodels Aware of Concrete Syntax</title>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Fondement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Baar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Model Driven Architecture (ECMDA), Springer LNCS 3748</title>
		<meeting><address><addrLine>Nuremberg, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="190" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A Theoretical Framework for Ontology Evaluation and Validation</title>
		<author>
			<persName><forename type="first">Aldo</forename><surname>Gangemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carola</forename><surname>Catenacci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimiliano</forename><surname>Ciaramita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jos</forename><surname>Lehmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd Italian Semantic Web Workshop on Semantic Web Applications and Perspectives (SWAP)</title>
		<meeting>the 2nd Italian Semantic Web Workshop on Semantic Web Applications and Perspectives (SWAP)<address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Visualizing Model Mappings in UML</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Hendrik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hausmann</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Stuart</forename><surname>Kent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM 2003 Symposium on Software Visualization</title>
		<meeting>the ACM 2003 Symposium on Software Visualization<address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Graph Transformation in a Nutshell</title>
		<author>
			<persName><forename type="first">Reiko</forename><surname>Heckel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">148</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="187" to="198" />
			<date type="published" when="2006-02">February 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Integrating Object Teams and OSGi: Joint Efforts for Superior Modularity</title>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Herrmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Mosconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object Technology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="105" to="125" />
			<date type="published" when="2007-10">October 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Logic in Computer Science: Modelling and Reasoning about Systems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">D</forename><surname>Huth</surname></persName>
		</author>
		<author>
			<persName><surname>Ryan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, England</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<ptr target="http://www.alphaworks.ibm.com/tech/mtf" />
		<title level="m">IBM. Model Transformation Framework</title>
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
		</imprint>
	</monogr>
	<note>Last Visit</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">On the Classification of UML&apos;s Meta Model Extension Mechanism</title>
		<author>
			<persName><forename type="first">Yanbing</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weizhong</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiyi</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangwen</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haohai</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Conference on the Unified Modelling Language: Modelling Languages and Applications (UML 2004)</title>
		<meeting>the 7th International Conference on the Unified Modelling Language: Modelling Languages and Applications (UML 2004)<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3273</biblScope>
			<biblScope unit="page" from="54" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">On the Architectural Alignment of ATL and QVT</title>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Kurtev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Symposium on Applied Computing (SAC 06), Model Transformation Track</title>
		<meeting>ACM Symposium on Applied Computing (SAC 06), Model Transformation Track<address><addrLine>Dijon, Bourgogne, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Transforming Models with ATL</title>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Kurtev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Satellite Events at the MoDELS 2005 Conference, MoDELS 2005 International Workshops, Doctoral Symposium, Educators Symposium</title>
		<meeting><address><addrLine>Montego Bay, Jamaica</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="128" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Lifting Metamodels to Ontologies -A Step to the Semantic Integration of Modeling Languages</title>
		<author>
			<persName><forename type="first">Gerti</forename><surname>Kappel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elisabeth</forename><surname>Kapsammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Horst</forename><surname>Kargl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Kramler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Retschitzegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wieland</forename><surname>Schwinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Wimmer</surname></persName>
		</author>
		<idno>LNCS 4199</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 9th International Conference on Model Driven Engineering Languages and Systems</title>
		<meeting>9th International Conference on Model Driven Engineering Languages and Systems<address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">MoDELS 2006. 2006</date>
			<biblScope unit="page" from="528" to="542" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">On Models and Ontologies -A Semantic Infrastructure Supporting Model Integration</title>
		<author>
			<persName><forename type="first">Elisabeth</forename><surname>Kapsammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Horst</forename><surname>Kargl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Kramler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerti</forename><surname>Kappel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Retschitzegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wieland</forename><surname>Schwinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Wimmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Modellierung 2006</title>
		<meeting>Modellierung 2006<address><addrLine>Innsbruck, Tirol, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-03">March 2006</date>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="page" from="11" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Semantische Prozeßmodellierung auf der Grundlage &quot;Ereignisgesteuerter Prozeßketten (EPK)</title>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Nüttgens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">August-Wilhelm</forename><surname>Scheer</surname></persName>
		</author>
		<idno>Heft 89</idno>
		<imprint>
			<date type="published" when="1992-01">January 1992</date>
		</imprint>
		<respStmt>
			<orgName>Institut für Wirtschaftsinformatik Universität Saarbrücken</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Experiential Learning: Experience as the Source of Learning and Development</title>
		<author>
			<persName><forename type="first">David</forename><surname>Kolb</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<author>
			<persName><forename type="first">Jochen</forename><surname>Küster</surname></persName>
		</author>
		<title level="m">Definition and Validation of Model Transformations. Software and Systems Modeling</title>
		<imprint>
			<date type="published" when="2006-09">September 2006</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="233" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Technical Spaces: An Initial Appraisal</title>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Kurtev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehmet</forename><surname>Aksit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean</forename><surname>Bézivin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Conference on Cooperative Information Systems (CoopIS)</title>
		<meeting>the 10th International Conference on Cooperative Information Systems (CoopIS)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Defining Web Schema Transformers by Example</title>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Lechner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schrefl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Database and Expert Systems Applications (DEXA 2003)</title>
		<meeting>the 14th International Conference on Database and Expert Systems Applications (DEXA 2003)<address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="46" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Applying OO Metrics to Assess UML Meta-models</title>
		<author>
			<persName><forename type="first">Haohai</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weizhong</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiyi</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanbing</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Conference on the Unified Modelling Language: Modelling Languages and Applications (UML 2004)</title>
		<meeting>the 7th International Conference on the Unified Modelling Language: Modelling Languages and Applications (UML 2004)<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004-10">October 2004</date>
			<biblScope unit="volume">3273</biblScope>
			<biblScope unit="page" from="12" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">No-redundant Metrics for UML Class Diagram Structural Complexity</title>
		<author>
			<persName><forename type="first">Esperanza</forename><surname>Manso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcela</forename><surname>Genero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Piattini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th International Conference on Advanced Information Systems Engineering (CAiSE 2003), Springer LNCS 2681</title>
		<meeting>the 15th International Conference on Advanced Information Systems Engineering (CAiSE 2003), Springer LNCS 2681<address><addrLine>Klagenfurt, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
			<biblScope unit="page" from="127" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">A Survey of Metrics for UML Class Diagrams</title>
		<author>
			<persName><forename type="first">Coral</forename><surname>Calero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcela</forename><surname>Genero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Piattini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object Technology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="59" to="92" />
			<date type="published" when="2005-12">November-December 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">EPC Modelling based on Implicit Arc Types</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Mendling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Nüttgens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Conference on Information Systems Technology and its Applications (ISTA 2003), GI LNI 30</title>
		<meeting>the 2nd International Conference on Information Systems Technology and its Applications (ISTA 2003), GI LNI 30<address><addrLine>Kharkiv, Ukraine</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="131" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">On the Use of Graph Transformations for Model Refactoring</title>
		<author>
			<persName><forename type="first">Tom</forename><surname>Mens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Generative and Transformational Techniques in Software Engineering (GTTSE 2005)</title>
		<meeting>Generative and Transformational Techniques in Software Engineering (GTTSE 2005)<address><addrLine>Braga, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-07">July 2005</date>
			<biblScope unit="volume">4143</biblScope>
			<biblScope unit="page" from="67" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">A Taxonomy of Model Transformation</title>
		<author>
			<persName><forename type="first">Tom</forename><surname>Mens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pieter</forename><surname>Van Gorp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">152</biblScope>
			<biblScope unit="page" from="125" to="142" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">A Graph-Based Metamodel for Object-Oriented Software Metrics</title>
		<author>
			<persName><forename type="first">Tom</forename><surname>Mens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michele</forename><surname>Lanza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">On the Semantics of Associations and Association Ends in UML</title>
		<author>
			<persName><forename type="first">Dragan</forename><surname>Milicev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="238" to="251" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">Model Transformation By-Example: An Eclipse based Framework. Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">Abraham</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><surname>Müller</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">2008</biblScope>
			<pubPlace>Austria</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Vienna University of Technology</orgName>
		</respStmt>
	</monogr>
	<note>forthcoming</note>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Durchgängige Modularität in der modellgetriebenen Entwicklung domänenspezifischer Modellierungssprachen mit Hilfe aspektorientierter Programmierung</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Mosconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Modellierung 2008</title>
		<meeting>Modellierung 2008<address><addrLine>Berlin, Deutschland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-03">March 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Business Process Model Transformation Issues</title>
		<author>
			<persName><forename type="first">Marion</forename><surname>Murzek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Kramler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Conference on Enterprise Information Systems</title>
		<meeting>the 9th International Conference on Enterprise Information Systems<address><addrLine>Madeira, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<title level="m" type="main">Manual: The Myers-Briggs Type Indicator</title>
		<author>
			<persName><forename type="first">Isabel</forename><surname>Briggs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Myers</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1962">1962</date>
			<publisher>Consulting Psychologists Press</publisher>
			<pubPlace>Palo Alto, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Testing and Simulating Production Control Systems Using the Fujaba Environment</title>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Niere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Zündorf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Applications of Graph Transformations with Industrial Relevance (AGTIVE&apos;99)</title>
		<meeting>Applications of Graph Transformations with Industrial Relevance (AGTIVE&apos;99)<address><addrLine>Kerkrade, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="449" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Using FUJABA for the Development of Production Control Systems</title>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Niere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Zündorf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Applications of Graph Transformations with Industrial Relevance (AGTIVE&apos;99), Springer LNCS 1779</title>
		<meeting>Applications of Graph Transformations with Industrial Relevance (AGTIVE&apos;99), Springer LNCS 1779<address><addrLine>Kerkrade</addrLine></address></meeting>
		<imprint>
			<publisher>The Netherlands</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="181" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Jürg</forename><surname>Nievergelt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">André</forename><surname>Behr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Die Aussagekraft von Beispielen. Informatik Spektrum</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="281" to="286" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">MDA Guide Version 1.0.1</title>
		<ptr target="http://www.omg.org/docs/omg/03-06-01.pd" />
	</analytic>
	<monogr>
		<title level="m">Last Visit</title>
		<imprint>
			<date type="published" when="2003-06">May 2008. June 2003</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<ptr target="http://www.omg.org/docs/ptc/03-09-15.pdf" />
		<title level="m">UML 2.0 Infrastructure Specification</title>
		<imprint>
			<date type="published" when="2003-09">May 2008. September 2003</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group (OMG</orgName>
		</respStmt>
	</monogr>
	<note>Last Visit</note>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Unified Modeling Language Specification Version 1</title>
		<ptr target="http://www.omg.org/cgi-bin/doc?formal/04-07-02" />
	</analytic>
	<monogr>
		<title level="m">Last Visit</title>
		<imprint>
			<date type="published" when="2004-07">May 2008, July 2004</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">UML Superstructure Specification</title>
		<ptr target="http://www.omg.org/cgi-bin/apps/doc?formal/05-07-04.pdf" />
	</analytic>
	<monogr>
		<title level="m">Last Visit</title>
		<imprint>
			<date type="published" when="2005-08">May 2008. August 2005</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group (OMG)</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<monogr>
		<ptr target="http://www.omg.org/docs/formal/06-01-01.pdf" />
		<title level="m">Meta Object Facility (MOF) 2.0 Core Specification</title>
		<imprint>
			<date type="published" when="2006-01">May 2008. January 2006</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
	<note>Last Visit</note>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">UML Superstructure Specification</title>
		<ptr target="http://www.omg.org/docs/ptc/06-04-02.pdf" />
	</analytic>
	<monogr>
		<title level="m">Last Visit</title>
		<imprint>
			<date type="published" when="2006-04">May 2008. April 2006</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group (OMG)</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">final adopted specification 1.1 edition, Last Visit</title>
		<ptr target="http://www.omg.org/docs/ptc/07-07-07.pdf" />
	</analytic>
	<monogr>
		<title level="m">Meta Object Facility (MOF) 2.0 Query/View/Transformation Specification</title>
		<imprint>
			<date type="published" when="2007-07">May 2008. July 2007</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">XSLT Stylesheet Generation by Example with WYSIWYG Editing</title>
		<author>
			<persName><forename type="first">Kouichi</forename><surname>Ono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Teruo</forename><surname>Koyanagi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mari</forename><surname>Abe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masahiro</forename><surname>Hori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 Symposium on Applications and the Internet (SAINT 2002)</title>
		<meeting>the 2002 Symposium on Applications and the Internet (SAINT 2002)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="150" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Programming By Example: Programming by Analogous Examples</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Repenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Corrina</forename><surname>Perrone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="90" to="97" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Towards Automated Testing of Abstract Syntax Specifications of Domain-Specific Modeling Languages</title>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">A</forename><surname>Sadilek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Weißleder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Domain-Specific Modeling Languages (DSML-2008)</title>
		<meeting>the Workshop on Domain-Specific Modeling Languages (DSML-2008)<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-03">March 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Bridging Existing Web Modeling Languages to Model-Driven Engineering: A Metamodel for WebML</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Schauerhuber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elisabeth</forename><surname>Kapsammer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Workshop on Model-Driven Web Engineering (MDWE 2006)</title>
		<meeting>the 2nd International Workshop on Model-Driven Web Engineering (MDWE 2006)<address><addrLine>Palo Alto, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<author>
			<persName><forename type="first">C</forename><surname>Douglas</surname></persName>
		</author>
		<author>
			<persName><surname>Schmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Guest Editor&apos;s Introduction: Model-Driven Engineering</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="25" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Tool Integration with Triple Graph Grammars -A Survey</title>
		<author>
			<persName><forename type="first">Andy</forename><surname>Schürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Königs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">148</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="113" to="150" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Building Personal Tools by Programming</title>
		<author>
			<persName><forename type="first">David</forename><surname>Canfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Smith</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="92" to="95" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Programming Agents without a Programming Language</title>
		<author>
			<persName><forename type="first">David</forename><surname>Canfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Smith</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Allen</forename><surname>Cypher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jim</forename><surname>Spohrer</surname></persName>
		</author>
		<author>
			<persName><surname>Kidsim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="54" to="67" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Programming by Example: Novice Programming comes of Age</title>
		<author>
			<persName><forename type="first">David</forename><surname>Canfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Smith</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Allen</forename><surname>Cypher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><surname>Tesler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="75" to="81" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Stahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Völter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Modellgetriebene Softwareentwicklung. Dpunkt Verlag</title>
		<imprint>
			<date type="published" when="2005-03">March 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Applying Model Transformation By-Example on Business Process Modeling Languages</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marion</forename><surname>Murzek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Wimmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Advances in Conceptual Modeling -Foundations and Applications, ER 2007 Workshops CMLSA, FP-UML</title>
		<meeting>Advances in Conceptual Modeling -Foundations and Applications, ER 2007 Workshops CMLSA, FP-UML<address><addrLine>QoIS, RIGiM,SeCoGIS; Auckland, New Zealand</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-11">November 2007</date>
			<biblScope unit="page" from="116" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">AGG: A Tool Environment for Algebraic Graph Transformation</title>
		<author>
			<persName><forename type="first">Gabriele</forename><surname>Taentzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Applications of Graph Transformations with Industrial Relevance (AG-TIVE&apos;99), Springer LNCS 1779</title>
		<meeting>Applications of Graph Transformations with Industrial Relevance (AG-TIVE&apos;99), Springer LNCS 1779<address><addrLine>Kerkrade, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="481" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">AGG: A Graph Transformation Environment for Modeling and Validation of Software</title>
		<author>
			<persName><forename type="first">Gabriele</forename><surname>Taentzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Applications of Graph Transformations with Industrial Relevance (AGTIVE 2003)</title>
		<meeting>Applications of Graph Transformations with Industrial Relevance (AGTIVE 2003)<address><addrLine>Charlottesville, VA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10">October 2003</date>
			<biblScope unit="page" from="446" to="453" />
		</imprint>
	</monogr>
	<note>Curriculum Vitae</note>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Model Transformation By Example</title>
		<author>
			<persName><forename type="first">Dániel</forename><surname>Varró</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 9th International Conference on Model Driven Engineering Languages and Systems</title>
		<meeting>9th International Conference on Model Driven Engineering Languages and Systems<address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-10">MoDELS 2006. October 2006</date>
			<biblScope unit="volume">4199</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Generic and Meta-transformations for Model Transformation Engineering</title>
		<author>
			<persName><forename type="first">Dániel</forename><surname>Varró</surname></persName>
		</author>
		<author>
			<persName><forename type="first">András</forename><surname>Pataricza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Conference on the Unified Modeling Language: Modeling Languages and Applications</title>
		<meeting>the 7th International Conference on the Unified Modeling Language: Modeling Languages and Applications<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>UML</publisher>
			<date type="published" when="2004-10">2004. October 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Designing the Automatic Transformation of Visual Languages</title>
		<author>
			<persName><forename type="first">Dániel</forename><surname>Varró</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gergely</forename><surname>Varró</surname></persName>
		</author>
		<author>
			<persName><forename type="first">András</forename><surname>Pataricza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="205" to="227" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">Evaluating Ontological Analysis</title>
		<author>
			<persName><forename type="first">Chris</forename><surname>Welty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kalra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Chu-Carroll</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ISWC-03 Workshop on Semantic Integration</title>
		<meeting>the ISWC-03 Workshop on Semantic Integration<address><addrLine>Sanibel Island, Florida, Oc</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">Bridging Grammarware and Modelware</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Kramler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Satellite Events at the MoDELS 2005 Conference</title>
		<meeting>Satellite Events at the MoDELS 2005 Conference<address><addrLine>Montego Bay, Jamaica</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3844</biblScope>
			<biblScope unit="page" from="159" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">Towards Model Transformation Generation By-Example</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Horst</forename><surname>Kargl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Kramler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Hawaii International International Conference on Systems Science (HICSS-40 2007)</title>
		<meeting>the 40th Hawaii International International Conference on Systems Science (HICSS-40 2007)<address><addrLine>Big Island, HI, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<monogr>
		<title level="m" type="main">Learning Structure Descriptions from Examples. The Psychology of Computer Vision</title>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Winston</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1970">1970</date>
			<biblScope unit="page" from="157" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">A Comparison of Metrics for UML Class Diagrams</title>
		<author>
			<persName><forename type="first">Tong</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fangjun</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengzhi</forename><surname>Gan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGSOFT Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Cohesion Metrics for Ontology Design and Application</title>
		<author>
			<persName><forename type="first">Haining</forename><surname>Yoa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><forename type="middle">Mark</forename><surname>Orem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Letha</forename><surname>Etzkorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="107" to="113" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Query By Example</title>
		<author>
			<persName><forename type="first">M</forename><surname>Moshé</surname></persName>
		</author>
		<author>
			<persName><surname>Zloof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of National Compute Conference</title>
		<meeting>National Compute Conference</meeting>
		<imprint>
			<publisher>Publications</publisher>
			<date type="published" when="1975">1975</date>
			<biblScope unit="page" from="431" to="438" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<title level="m">A Framework for Model Transformation By-Example: Concepts and Tool Support. 46th International Conference on Technology of Object-Oriented Languages and Systems (TOOLS&apos;08)</title>
		<meeting><address><addrLine>Zurich, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-07">July 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Kappel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kargl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Retschitzegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schwinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<title level="m">A Framework for Building Mapping Operators Resolving Structural Heterogeneities. 7th International Conference on Information Systems Technology and its Applications (ISTA&apos;08)</title>
		<meeting><address><addrLine>Klagenfurt, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-04">April 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Kappel: HowWeb 2.0 can leverage Model Engineering in Practice</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schauerhuber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Flandorfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Domänenspezifische Modellierungssprachen (DSML&apos;08), in conjunction with Modellierung</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Deutschland</publisher>
			<date type="published" when="2008-03">2008. March 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schauerhuber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schwinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kappel</surname></persName>
		</author>
		<title level="m">A Semiautomatic Approach for bridging DSLs with UML. 7th OOPSLA Workshop on Domain-Specific Modeling, in conjunction with OOPSLA&apos;07</title>
		<meeting><address><addrLine>Montreal, Canada, Oc</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kargl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Seidl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reiter</surname></persName>
		</author>
		<title level="m">Integrating Ontologies with CAR-Mappings, First International Workshop on Semantic Technology Adoption in Business (STAB&apos;07)</title>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<monogr>
		<title level="m" type="main">Curriculum Vitae</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Murzek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<title level="m">Applying Model Transformation By-Example on Business Process Modeling Languages, 3rd International Workshop on Foundations and Practices of UML</title>
		<meeting><address><addrLine>Auckland, New Zealand</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-11">2007. November 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Kappel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kargl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kramler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schauerhuber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Seidl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<title level="m">Matching Metamodels with Semantic Systems -An Experience Report</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<monogr>
		<title level="m" type="main">Fachtagung für Datenbanksysteme in Business, Technologie und Web</title>
		<author>
			<persName><surname>Gi-</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-03">March 2007</date>
			<pubPlace>Aachen</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Measuring the Explicitness of Modeling Concepts in Metamodels</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kargl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE 9th International Conference on Model Driven Engineering Languages and Systems (MoDELS/UML 2006), Workshop on Model Size Metrics</title>
		<meeting><address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10">October 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">Model Transformation Generation By-Example</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kargl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kramler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HICSS-40 Hawaii International Conference on System Sciences</title>
		<meeting><address><addrLine>Hawaii, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-01">January 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Ökonomische Aspekte der Entwicklungsproblematik &quot;Dritter Welt</title>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Länder</title>
		<imprint>
			<date type="published" when="2005-10">October 2005</date>
		</imprint>
		<respStmt>
			<orgName>Vienna University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Diploma Thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
