<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Privilege De-Escalation for Ad Libraries in Mobile Apps</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Bin</forename><surname>Liu</surname></persName>
							<email>bin2.liu@samsung.com</email>
							<affiliation key="aff0">
								<orgName type="department">Samsung Research America</orgName>
								<address>
									<settlement>Mountain View</settlement>
									<region>CA</region>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hongxia</forename><surname>Jin</surname></persName>
							<email>hongxia.jin@samsung.com</email>
							<affiliation key="aff0">
								<orgName type="department">Samsung Research America</orgName>
								<address>
									<settlement>Mountain View</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ramesh</forename><surname>Govindan</surname></persName>
							<email>ramesh@usc.edu</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Southern California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Privilege De-Escalation for Ad Libraries in Mobile Apps</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5E9D1CEC2DD4D24DD0FD8A776604F3BC</idno>
					<idno type="DOI">10.1145/2742647.2742668</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features-Modules, packages</term>
					<term>K.4.1 [Computers and Society]: Public Policy Issues-Privacy Design, Experimentation, Languages, Measurement, Security Previlege De-Escalation</term>
					<term>Ad Libraries</term>
					<term>Mobile Apps</term>
					<term>Static Analysis</term>
					<term>App Instrumentation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The proliferation of mobile apps is due in part to the advertising ecosystem which enables developers to earn revenue while providing free apps. Ad-supported apps can be developed rapidly with the availability of ad libraries. However, today's ad libraries essentially have access to the same resources as the parent app, and this has caused significant privacy concerns. In this paper, we explore efficient methods to de-escalate privileges for ad libraries where the resource access privileges for ad libraries can be different from that of the app logic. Our system, PEDAL, contains a novel machine classifier for detecting ad libraries even in the presence of obfuscated code, and techniques for automatically instrumenting bytecode to effect privilege de-escalation even in the presence of privilege inheritance. We evaluate PEDAL on a large set of apps from the Google Play store and demonstrate that it has a 98% accuracy in detecting ad libraries and imposes less than 1% runtime overhead on apps.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Mobile device usage has reached astronomical levels in recent years. According to a recent report from Gartner Forecasts <ref type="bibr" target="#b10">[12]</ref>, Android device shipments alone are predicted to hit 1.17 billion by the end of 2014. Much of this growth has been fueled by two factors: the ease of app development, and the availability of free apps.</p><p>The ease of app development has been enabled in part by system support for component-oriented development <ref type="bibr" target="#b8">[10]</ref>, in which app developers can easily integrate libraries (sometimes from third-parties) as components of their app. In the Android ecosystem, libraries are used for various purposes. Social SDKs, like Facebook, Twitter4j and WeChat, allow developers to integrate popular social elements to their apps. Development tools, such as ActionbarSherlock, Holo-Everywhere and GeocoderPlus, provide developers with feature-rich and relatively well-maintained plugins for enhancing, say the utility, UI, and image processing capabilities of their apps.</p><p>The availability of free apps has been enabled by an ad ecosystem in which app publishers incorporate ad delivery software in their apps. This software is provided by ad networks who contract with advertisers to deliver ads to end users. App developers are paid by ad networks either by the number of times ads are seen by users, or the number of times they are clicked, or some combination thereof. More than 83% of apps <ref type="bibr" target="#b9">[11]</ref> in Google Play are free and developers of free apps mostly rely on advertising for revenue <ref type="bibr" target="#b56">[58]</ref>.</p><p>To facilitate ad delivery, ad networks provide ad libraries to app developers. Ad libraries, like AdMob, InMobi and Vungle, offer developers solutions for monetizing their apps by showing ads to app users. To show ads in their apps, developers need to bundle ad SDKs in their app code to display ads to users through corresponding ad widgets. These ad widgets can communicate with their ad networks to fetch and show proper ads, according to apps' context or users' information, such as location.</p><p>In this ecosystem, incentives are skewed against the user. Developers have the incentive to deliver the most relevant apps to maximize their revenue, as do ad networks. This results in ad libraries taking unwarranted liberties with personal data on devices in order to more efficiently target ads. As a result, although users seem to understand the privacy risks with using mobile apps in general <ref type="bibr" target="#b17">[19]</ref>, they are especially concerned about privacy risks posed by ad libraries <ref type="bibr" target="#b52">[54]</ref>. An extensive user study <ref type="bibr" target="#b41">[43]</ref> points out that "mobile advertising services were a consistent privacy concern for the most participants" and users "felt the least comfortable when private resources were used for advertising." In another previous study <ref type="bibr" target="#b39">[41]</ref> on location privacy of mobile advertising, users stated that they would "feel more comfortable" with advanced privacy controls than "with a simple opt-in/out-out mechanism".</p><p>One approach to this problem is to selectively de-escalate privileges to each component of an app. In this way, an ad library can have fewer privileges than the app logic itself. The Android access control model, which governs access to sensitive data such as location, identifiers, and contacts, and which has not evolved significantly over many releases, is also too coarse-grained to permit such privilege de-escalation. The current access control model allows users to specify permissions at app install time, and these permis-sions apply to all components of the app. In response to this, there is a large literature that has explored finer-grained access control methods (Section 8). In general, these methods are effective but require significant changes to the underlying OS, or, when they do not require such changes, can sometimes be ineffective in enforcing access to sensitive data. Moreover, simple solutions that deny privileges to ad libraries that are not needed by the app logic are likely to be ineffective: our measurements show that in a majority of apps in a large corpus of over 60,000 apps, the permissions requested by the ad are a subset of the permissions needed by the app logic (Section 5).</p><p>In this paper, we propose a pragmatic approach to selective privilege de-escalation for ad libraries. In our approach, a user can allow the app logic access to location and the contacts database, but, if she chooses, deny these privileges to the ad library. Our system, called PEDAL, has several desirable properties: it does not require OS or VM modifications, is resistant to obfuscated code, prevents privileges inherited by the ad library from app code, and is highly efficient.</p><p>The design of PEDAL poses two challenges: how to identify ad library code in an app, and how to effect selective privilege deescalation.</p><p>The first challenge is non-trivial because, in a compiled binary, there is no annotation that preserves the separation between bytecode from app logic and bytecode from an ad library. More important, library bytecode can often be obfuscated to prevent reverse engineering. In this paper, PEDAL surmounts these challenges by observing that, even in the presence of obfuscation, ad libraries have several features that can be used to identify them. These features arise from the functionality of ad libraries (ad delivery) and from their modularity (they have to expose well-defined interfaces to apps). Based on this observation, PEDAL includes a highly effective, obfuscationresistant, machine classifier that can separate ad library from app logic code (Section 4).</p><p>Effecting privilege de-escalation is non-trivial also, since a pragmatic solution must not require changes to the OS or the VM, or must not require rooting 1 a phone, since these can adversely affect deployability. Moreover, any solution must be highly efficient; significant slowdowns in app execution time can affect usability. Most importantly, in a substantial fraction (25%, Section 6) of apps, ad libraries inherit privileges from the app logic -they access sensitive resources like location etc. by invoking callbacks to app code. Any solution for privilege de-escalation must prevent this kind of privilege inheritance. PEDAL uses efficient binary rewriting and information flow analysis to overcome these challenges (Section 4).</p><p>Figure <ref type="figure" target="#fig_0">1</ref> and Figure <ref type="figure">2</ref> show two examples of PEDAL in action. The first example shows how a user can, in the AccuWeather app, disable Internet access permissions for ad libraries but keep it enabled for this app's main logic. Figure <ref type="figure" target="#fig_0">1</ref> shows that while the app can still function (can download breaking news), the ad space is empty because the ad library cannot download ads. In the second example, in the AroundMe app, the ad library inherits location privileges from the app logic. In this case, the user can choose to use PEDAL's controller app, which allows users to specify de-escalation policies (see Figure <ref type="figure">8</ref> for details), to feed obscured location data. In the example shown, PEDAL feeds the correct location (San Jose) to the app, but feeds Sunnyvale (a city close to San Jose) to the ad library. Figure <ref type="figure">2</ref>(b) shows the result: while the app lists hotels near the real location, the ad library recommends hotels around the obscured location. PEDAL can be used both by end-users and app markets. Individual Android users may use this system to enable self-defined resource access control for ad libraries of apps on their phones. App markets may also apply PEDAL to enforce their policies on ad libraries. For example, an app market may provide plausible-obscured-location options to users to enjoy apps with obscured but plausible location targeted ads. For example, instead of feeding accurate location, say San Jose, to ad libraries, PEDAL may still feed plausible nearby locations, such as Santa Clara or Sunnyvale to them to require useful ads. In this scenario, the ad widgets cannot collect accurate location information but the ads can still be relevant to the user's current location.</p><p>As an aside, there is a fundamental difference between PEDAL and existing ad blockers such as AdBlock Plus <ref type="bibr" target="#b12">[14]</ref>: Ad blockers attempt to completely prevent ad delivery, while PEDAL allows the option of only blocking access of certain resource types to ad modules but still allowing ads to be delivered. In addition, ad blockers usually require rooted phones to enable full functionality while PEDAL does not.</p><p>Overall, this paper makes four contributions:</p><p>• The design and implementation of a system, PEDAL, for selective privilege de-escalation for ad libraries. • An efficient, accurate, automatic and obfuscation-resistant method for identifying ad libraries embedded in app binaries. Our method uses a machine classifier based on features extracted using static analysis of bytecode. • An efficient and flexible privilege de-escalation method that prevents privilege inheritance. This method uses binary rewriting, so does not require changing the Android OS or rooting the phone.</p><p>• Extensive experiments on a large set of real apps to show that PEDAL is both effective and efficient. Our prototype of PEDAL has 98.9% precision and 97.7% recall on identifying ad libraries and requires only 0.57 seconds per app for identification and rewriting. Apps incur less than 1% additional running time and can very effectively de-escalate privileges for ad libraries. The rest of the paper is organized as follows: Section 2 provides background and motivates the design of PEDAL. Sections 3 and 4 discuss the architecture, and the design and implementation of PEDAL. Sections 5 and 6 evaluate the efficacy of ad library identification, and of privilege de-escalation, respectively. Section 7 discusses PEDAL usage scenarios and future refinements. Related work is described in Section 8, and the paper is summarized in Section 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND AND MOTIVATION</head><p>Before describing PEDAL, we provide some background on app execution, code obfuscation, and the app privilege model in Android.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Background</head><p>Libraries in Android. Android apps are written in a dialect of Java, and compiled down into a bytecode that is executed by the Dalvik Virtual Machine (DVM). Apps may include library code either for special purpose uses (such as image or video processing), or for analytics or ad delivery. In this paper, we focus on libraries for ad delivery: some apps can include more than one such library. When developing an Android app, the developer sees clear boundaries between the app's source code and every other library. For example, as shown in Figure <ref type="figure" target="#fig_1">3</ref>, the developers of the AroundMe app maintain their own source code. The app source also includes multiple libraries<ref type="foot" target="#foot_1">2</ref> provided by various third parties. However, when this app source is compiled to bytecode, the boundaries between the developers' code and libraries become unclear: compilation does not preserve all syntactic distinctions. Thus, it is sometime difficult to tell whether two classes belong to the app code or belong the a same library. One syntactic distinction that is preserved after compilation is the folder path for each class file. The folder path uniquely names a class file in a hierarchical namespace, and often, the upper levels of the hierarchy name the library that the class file belongs to. Obfuscation. To prevent reverse engineering of source code from bytecode, app developers and library developers sometimes obfuscate the bytecode in two ways: at the package level and at the code-level. Package level obfuscation is motivated by prior work that has used folder path names to statically analyze app binaries to characterize potential risks <ref type="bibr" target="#b33">[35]</ref>, compute permission usage statistics <ref type="bibr" target="#b54">[56]</ref>, understand longitudinal code changes <ref type="bibr" target="#b24">[26]</ref>, extract usage patterns <ref type="bibr" target="#b55">[57]</ref>, and characterize apps <ref type="bibr" target="#b56">[58]</ref> and so on. All of these pieces of work perform these analyses by matching bytecode paths against a manually-maintained blacklist of ad library names. For example, a path /com/millennialmedia/android indicates the presence of the ad library "Millennial Media". To foil this detection, some ad libraries, like AirPush, LeadBolt and AdsMogo, perform package name obfuscation and generate random package names for different developers.</p><p>Source code level obfuscation renames classes, methods and fields to semantically obscure names to prevent from reverse engineering the source code. Figure <ref type="figure" target="#fig_3">4</ref> shows a simple example of using package name obfuscation and source code obfuscation. Clearly, source code level obfuscation makes it harder to reverse engineer the original source from bytecode.</p><p>A nontrivial fraction of Android apps contain obfuscated code. We manually examined 200 randomly chosen apps from a corpus of about 60,000 (Section 5), and found that 107 of them contained ad libraries with source-code level obfuscation, and 37 of them obfuscated app code. The Android Permissions Model. The Android permissions model governs app access to resources. A resource is an abstraction for data generated either by a hardware device (GPS or camera), data unique to a device (phone number, device ID, MAC address), or data generated by users and generally considered private (contact information). The Android permissions model requires an app developer 1) to notify users of which resources are required for the app, and 2) to explicitly ask the user's permission, at app install time, for access to these resources. Once the app is installed, the app and all its included libraries are granted access to these resources as long as the app is installed on the phone.</p><p>This model is at once too permissive and too coarse-grained, and there have been many examples of instances where permissions have been misused to breach privacy, often by ad libraries <ref type="bibr" target="#b24">[26,</ref><ref type="bibr" target="#b33">35,</ref><ref type="bibr" target="#b53">55]</ref>. In response to this, recent versions of Android include a hidden permission manager called "App Ops" <ref type="bibr" target="#b0">[1]</ref> that allows users to manage app permissions after installation. Moreover, several pieces of research have proposed finer-grained and restrictive access control for resources; we cover these in Section 8.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Privilege De-Escalation</head><p>Motivated by the shortcomings of the current permission model, we focus on a specific problem: how to selectively de-escalate the privileges given to ad libraries? In other words, even though a user may grant an app permissions to several resources, we would like to restrict access by ad libraries to some of these resources. Our position is that ad libraries may, in general need a different set of resources than the apps they are included in, so users should be able to selectively control privileges for these libraries separately from the main app logic.</p><p>Why focus on ad libraries? In Figure <ref type="figure">5</ref>(a), a measurement of more than 60,000 apps shows that nearly 57% of apps use ad libraries. This indicates the magnitude of the problem: more than 1 of every 2 apps may be susceptible to privacy leakage. Furthermore, in roughly half of the ad-included apps, the ad libraries requested permission for a resource that was not required by the app logic itself! There are several ways in which to address this problem, but we consider a part of the design space that has not been explored before. We focus on a solution that has the following properties:</p><p>• It permits users to selectively de-escalate the privileges associated with ad libraries, without affecting privileges granted to other libraries or to the app itself. • It is obfuscation-resistant: it has a high likelihood of success even in the presence of source-code obfuscation. This is motivated by the finding above that non-trivial amounts of obfuscation exist in today's apps. • It must not require changes to the operating system or the API, or require special forms of modification (like rooting the phone). These assumptions enhance the deployability of the solution.</p><p>• It must be efficient and only minimally impact the execution time of the app. • Finally, it must guard against privilege inheritance by ad libraries. In many apps, ad libraries, rather than access resources directly, invoke methods in the app logic that provide access to resources (Figure <ref type="figure" target="#fig_4">6</ref>). Effectively, ad libraries inherit privileges granted to the app itself, and any privilege de-escalation must prevent this. In our corpus of 60,000 apps, we have found substantial numbers of apps that inherit access to location, the phone ID, and, to a lesser extent, the contact information and the account profile, as shown in Figure <ref type="figure">5</ref>(b).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">EFFICIENT PRIVILEGE DE-ESCALATION</head><p>In this paper, we describe the design and evaluation of a system for efficient privilege de-escalation. The system, named PEDAL, contains two parts: a Separator and a Rewriter (Figure <ref type="figure" target="#fig_6">7</ref>). The input to PEDAL is a packaged app, and the output is a repacked app with de-escalated privileges for any (obfuscated) ad libraries in the app. In this section, we describe the overall architecture of PEDAL, leaving the detailed design and implementation to the next section.</p><p>The input app is first unpacked and transformed to Java bytecode, then sent to the Separator for feature extraction and classification. Feature extraction and classification is designed to separate the bytecodes to two different sets. The Separator scans and collects statistics on bytecodes<ref type="foot" target="#foot_2">3</ref> to generate feature vectors. Those feature vectors are input to a classifier which outputs two bytecode sets: the ad library set and the app logic set.</p><p>The Rewriter then performs binary rewriting on the bytecode sets. Specifically, the goal of the Rewriter is to interpose on 1) direct access to resources from both sets, and 2) calls from the app logic code to the ad library set that accesses resources (to prevent privilege inheritance, Section 2). Rewriter maintains a list denoting  what private resources to control, such as Internet, location, contacts, phone ID and so on, takes both bytecode folder sets as inputs, and outputs the controllable versions (with respect to the resource types to control) of the two sets. As we describe later, the Rewriter does not attempt to interpose on all functions that lead to resource access, but 1) identifies a small set of core resource access functions and rewrites these functions which are used for directly accessing the concerned private resources, and 2) uses information flow analysis techniques to identify and rewrite another small set of functions which are used for ad libraries to indirectly access resources. The two rewritten bytecode sets, with other necessary files, are then repackaged back to a new app.</p><p>Finally, PEDAL contains a Controller app (Figure <ref type="figure" target="#fig_6">7</ref>) for users to specify de-escalation policies for ad libraries.</p><p>This design achieves the requirements listed in Section 2 as follows. Classification and binary-rewriting achieve selective deescalation on ad libraries. As we show later (and this is a major contribution of our work), the Separator is obfuscation-resistant. By using binary rewriting, our approach does not require OS level changes, and also achieves significant efficiency. Finally, the Rewriter, by analyzing information flow across bytecode sets, can prevent privilege inheritance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PEDAL DESIGN AND IMPLEMENTATION</head><p>In this section, we present the detailed design and implementation of PEDAL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Separator</head><p>The goal of the Separator is to identify potentially obfuscated ad libraries packaged within an app. Before we explain the Separator, we observe that Java class files are usually named hierarchically. This naming hierarchy enables unique names for classes, permitting flexible inclusion of software from different sources into an application. Each bytecode corresponding to each Java class is then conceptually in a "folder" whose path name specifies the part of the hierarchy that class name is in. For example, the folder whose path is /com/millennialmedia/android would contain the ad library distributed by Millenial Media.</p><p>At a high-level, Separator marks each bytecode within an app as belonging to an ad library or not (i.e., it separates bytecodes, hence the name). Specifically, Separator identifies one or more folders that contain ad libraries. Folders can be nested, so a folder marked as containing an ad library implies that all bytecodes in subfolders are also part of the ad library.</p><p>As an aside, since Separator identifies ad libraries at the granularity of a folder, a potential approach to foil the Separator is to inter-mingle app logic and library code within a single folder. In practice, this is hard to do: the hierarchical class namespace, such as /com/google/android/gms/ads, /com/mopub/mobileads, /com/mobfox, /com/airpush/android, /com/mobclix/android/sdk, /com/applovin, and so on, is designed to enable separable development of code by different vendors, so that the folder hierarchy is used to distinguish code from different vendors. In this way, a developer can easily incorporate class files from different vendors. Even within a given vendor, hierarchical naming is used to ensure modularity: for example, Google uses different hierarchical names for its analytics library and its ad library. Finally, we emphasize that while Separator relies on class hierarchies, it is robust to folder path name obfuscation, as described below.</p><p>The key idea behind Separator is to use a binary machine classifier trained to identify ad libraries, even in the presence of obfuscation. The classifier accepts a feature vector of a bytecode folder (described below) and predicts whether the folder belongs to an ad library. We have manually extracted labeled training data from several hundred ad libraries and apps to train the classifier, and the details are presented in Section 5. The main challenge in our work is selecting features for the classifier that would enable accurate classification in the presence of obfuscation. Bytecode Extraction. Our approach does not require source code; rather it extracts semantic features from bytecode. For this, we convert Dalvik bytecode to Java bytecode using well known techniques <ref type="bibr" target="#b34">[36]</ref>, then perform feature extraction on the Java bytecode. Feature Extraction. The most important aspect of Separator design is to choose the set of features that ensure high classification accuracy. The features need to be: 1) effective and accurate, correctly separating ad libraries from apps; 2) easy and fast, requiring few complex operations to calculate; 3) general enough to support a variety of ad libraries from different vendors; and 4) robust enough to support both obfuscated and non-obfuscated ad libraries. After examining and analyzing the bytecodes of popular ad library SDKs, we chose 128 features that meet the above goals and are informative to ad library classification. These features can be categorized into the following groups. Usage of Android basic components: These are binary features of whether a bytecode folder contains the usage of Android basic components <ref type="foot" target="#foot_3">4</ref> : activity, service, content provider and broadcast receiver. Compared to other software libraries, ad libraries are usually implemented as an independent module. For example, they may contain activities for displaying ads, may hold background services for periodically requesting ads, may use content providers for storing and retrieving informational data, and may register broadcast receivers for better reacting to system events (e.g., disabled screen or low battery). Usage of selective Android permissions: These are binary features of whether a bytecode folder uses the following Android permissions: INT ERNET , ACCES S _NET WORK_S T AT E/_WIFI_S T AT E, ACCES S _FINE/_COARS E_LOCAT ION, and WRIT E_EXT ERNAL_S T ORAGE. These permissions are most likely to be used by ad libraries (they may, of course, be used by the app logic or by other components, so permissions usage is only one of the many features we consider). INT ERNET is necessary for communicating with ad networks. NET WORK_S T AT E and WIFI_S T AT E are for checking the availability and status of network connections. LOCAT ION is for better ad targeting, and WRIT E_EXT ERNAL_S T ORAGE, which implicitly allows READ_EXT ERNAL_S T ORAGE, is for saving and serving cached ads when the device is offline.</p><p>To determine this feature vector, we first extract API calls and content provider URIs from the bytecode, then map that information to permissions using PScout <ref type="bibr" target="#b19">[21]</ref>. Note that we have also tried taking all Android permissions and treated each one as an individual feature. However, in practice, this causes model overfitting and degrades the classifier performance. Usage of visual elements: These are binary features of whether a bytecode folder has implemented instances of visual elements. Ad libraries provide user interfaces (UI) for showing ads. For example, interstitial ads prefer to implement their own activities for displaying full-screen ads, and banner ads usually extend webview or imageview to show ads inside small rectangles. Features in this group check whether there are customized classes that are derived from the commonly used UI widgets, such as activity, webview and videoview. We identified 12 classes from android.app, android.widget or android.webkit that can be used for implementing ad UI components. Usage of information sources and sinks: Information sources refer to system calls that read non-constant information from a shared resource, and information sinks refer to system calls that write a piece of information to a shared resource <ref type="bibr" target="#b49">[51]</ref>. Ad libraries prefer certain types of information. For example, they often use account and phone state information to uniquely identify user devices. We extract features in this group by using SuSi <ref type="bibr" target="#b49">[51]</ref>, a machine-learning approach to classify Android system calls to 12 information source categories and 15 information sink categories. These source and sink categories form 27 features. Each binary feature indicates whether any API call belonging to a category is observed in a bytecode folder. Usage of APIs for runtime permission check: One interesting observation, which was first pointed out in <ref type="bibr" target="#b54">[56]</ref>, is that sometimes ad libraries may try to dynamically check certain permissions and take advantage of these permissions if they are available to apps. This check can be performed through a cluster of API calls like android.content.Context.check*Permission (where "*" denotes a collection of API call names such as "checkCallingOrSelfPermission"). Thus, one feature is added to indicate whether a bytecode folder has called any functions for runtime permissions checks. Keyword matching for class, method and field names: In practice, we have found that the combination of these features accurately recognizes most ad libraries. However, these features can sometimes wrongly classify social-network or e-business plugins into ad libraries, such as Facebook or Amazon. These plugins have very similar behaviors as ad libraries and do, indeed, have many of these features. Therefore, the added binary features in this group show, in a bytecode folder, whether the names of classes, methods or fields contain specific keywords that are often used in ad libraries but rarely used in social-network and e-business plugins, such as "ads," "adsdk," "interstitial," "campaign," "impression," "mraid (Mobile Rich Media Ad Interface Definitions)," and so on. We use a dictionary of 26 such keywords, and 78 (26×3) features for keywords defined for classes, methods and fields, respectively. Obfuscation-Resistance. The features we have chosen for classification are robust to code obfuscation. First, code obfuscation is used to protect developer code from reverse engineering, and it does not obscure API calls, content provider URI or class names of the Android system. For example, ProGuard <ref type="bibr" target="#b13">[15]</ref>, an official Android obfuscation tool, explicitly confirms this in its manual. Obviously, except for the last group of features (keyword matches), all the features are only related to Android system entities and will not be affected by code obfuscation. Second, code obfuscation can foil keyword matching by obscuring most names in an ad library; however, it still needs to preserve some interface names so that can be easily understood by developers and simplify integration with applications. For instance, Chartboost <ref type="bibr" target="#b7">[9]</ref>, a popular ad library that uses obfuscation, still preserves some methods and classes with explicit and in-formative names, such as showInterstitial, requestMorePromotion and ImpressionActivity, for ease of integration. Thus, in most cases, we can still capture features for the last feature group even with an obfuscated ad library. Actually, as shown in the evaluation, even without keyword matching features, the classifier can still make reasonable decisions based on other feature groups.</p><p>Finally, our features will not be affected by package name obfuscation because the Separator does not rely on the path or package name or components thereof, only on the class hierarchy itself. For example, if /com/millenialmedia/android is obfuscated to /a/b/e, Separator's features do not change and it will be able to identify all bytecodes in folder /a/b/e as belonging to an ad library. Path name obfuscation makes it harder to associate the ad library with its developer, but that association is not necessary for PEDAL's functionality. An Optimization. Each Android app has a main bytecode package that usually carries the implementation of the most important part of the app logic. The name of the bytecode folder that contains this is globally unique across an app store, and is defined in the app's manifest. Instead of attempting to classify this main bytecode package, we directly mark this folder as not being an ad library. This optimization has two advantages: 1) it can prevent the potential influence of wrongly classifying this major functional folder as an ad library; and 2) it can speed up the total classification time by skipping feature vector generation for these folders -classification time matters because it can impact how quickly an app store can process a batch of apps. Augmenting Separator with call-graph information. The classifier itself focuses on finding the key functional components of ad libraries such as components for fetching/displaying ads or sending user data to ad networks, so it may miss some auxiliary libraries referenced by the key functional components. These libraries are still logically part of the ad library, but may not contain any of the signatures of these libraries. We applied call-graph information to attempt to ascertain these auxiliary libraries. However, as we show in Section 5, doing this incurred significant cost without additional benefit: intuitively, if these auxiliary libraries do not have signatures similar to ad libraries and perform some auxiliary function (e.g., parsing JSON objects), it is probably not necessary to instrument them to perform privilege de-escalation. So our PEDAL prototype does not use this technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Rewriter</head><p>The output of the Separator is input to the Rewriter, which effects efficient privilege de-escalation by binary re-writing based on user-specified privacy policies. We begin by first describing userspecified policies permitted in PEDAL, then describe the Rewriter design. User-Specified Policies. In PEDAL, users specify policies using a Controller app (Figure <ref type="figure">8</ref>). This controller app is accessed through a unique URI, and a special provider permission is set up to prevent unauthorized apps from accessing it. This provider permission is granted to every rewritten app by adding a permission claim entry to their AndroidManifest.xml files using the AXML library <ref type="bibr" target="#b6">[8]</ref>. At runtime, a rewritten app can access the content provider by using queryController (details are explained below), to read the user's configuration and effect user-specified policies. Conceptually, each policy entry is a quadruple:</p><p>(AppName, ResourceT ype, ComponentT ype, Policy) where AppName is an app's identifier, ResourceT ype is one of the five resources listed in   <ref type="figure" target="#fig_0">10</ref> use Java-style pseudo-code to describe the instrumentation technique for ease of understanding. PEDAL rewrites byte-code, and does not require access to Java or Dalvik source.) the ad library or the app logic, and finally, Policy takes the value from {ALLOW, OBS CURE, BLOCK}. Our current instantiation of PEDAL supports the five resource types listed in Table <ref type="table" target="#tab_2">1</ref>, and users may thus selectively permit or deny an ad library access to each of these resource types. These five resource categories cover the types of resources accessed by ad libraries. It is easy to extend PEDAL to support other resource types.</p><p>In addition, users may choose to obscure the returned results for specific resource types. App developers may derive revenue from some of these resources. For example, when an ad library can obtain a user's location and deliver targeted ads, the developer might get more revenue than when no location is available. So, PEDAL permits users to specify policies that enable some form of obscured result to be returned. We discuss this below in some detail.</p><p>Finally, users can change policy settings at any time, and policy changes take immediate effect (even while an app is running). The Rewriter accesses these policies at run-time through a queryController interface, as discussed below. Rewriting for Privilege De-Escalation. Conceptually, re-writing for privilege de-escalation is straightforward: Rewriter can interpose on resource accesses by the ad library or the app logic, and permit access only if the user-specified policies grant access. In the example in Figure <ref type="figure" target="#fig_7">9</ref>, the call to queryController permits access to the Location resource if the policy permits, otherwise it returns null or an obscured location. However, there are several subtleties in the design, as described below.</p><p>Interposing on content providers. Rewriting content provider <ref type="foot" target="#foot_4">5</ref> based resource access is slightly more involved. Figure <ref type="figure" target="#fig_0">10</ref> shows another Figure <ref type="figure" target="#fig_0">10</ref>: Example of rewriting a system call for operating a content provider example for rewriting the API call query. This function can be used to access all types of resources that are implemented through content providers, and the uri parameter is used to differentiate which resource type is actually queried. For example, if uri is "content://com.android.contacts" or "content://contacts," then the resource type is contacts; if it is "content://call_log," then the resource type is call logs; and if it is "content://com.android.calendar," then the resource type is calendar. When queryController receives a content provider URI as the resourceT ype parameter, it first maps the URI (using PScout <ref type="bibr" target="#b19">[21]</ref>) to the resource type the URI pertains to, and then follows the same procedure as when it directly receives a resource type string, like "Location" above. Obscuring Results. Our current prototype permits users to obscure contacts, location, phone ID, and profile information. Specifically, for location, phone ID, and profile information, PEDAL initiates a new object with pre-defined fake values, and returns this new instance to the app logic or the ad library. However, as discussed above, access to contacts is through a special URI, and the return is a cursor pointer to the actual database. Therefore, it is a little tricky to OBS CURE contacts. We have implemented a fake content provider (essentially, an app) that contains all the fields that have been defined in the real contacts content provider tables. To OBS CURE contacts, PEDAL simply replaces the real provider URI with the URI of the fake content provider, and returns the usable cursor pointing to the fake database. We have left to future work to determine how best to obscure results that preserve user privacy without affecting the app developer's revenue stream. Optimizing the Rewriter. The API for accessing a resource, like the Internet or Location, may have many calls, not all of which need to be interposed. For example, there are a total of 95 calls <ref type="bibr" target="#b2">[4]</ref> for the Internet resource, but only about 15 of them (called core resource access functions, or core functions for short) need to be interposed on to enforce policy. The other calls provide either higherlevel abstractions that ultimately call one of these core functions, or provide utility functionality (for example, for parsing headers, etc.). Avoiding interposing on the non core functions can reduce overhead (Section 5) by avoiding calls to queryController for dynamic policy checking. Table <ref type="table" target="#tab_2">1</ref> lists the number of core functions for each of the 5 resource types we support. Preventing Privilege Inheritance. As we have discussed, ad libraries may also access resources indirectly through the app logic. To prevent this, we use an information flow analysis tool, Flow-Droid <ref type="bibr" target="#b18">[20]</ref> with a reported accuracy of over 90%. Our usage of flow analysis is constrained: we are interested in code paths from calls to resource access core functions in the app logic to Internet access calls in the ad library. Such code paths indicate the potential for privilege inheritance misuse. Note that our approach only focuses on  those kinds of privilege inheritance that can lead to misuse (actual leakage of data).</p><p>Once these potential leakage paths have been identified, Rewriter performs the same kind of interposition as above. Consider the "Location" resource. For this, we first find the core resource access functions that the app logic uses to fetch location information (information flow sources), and then find the places within the ad library part where the Internet core functions are called (information flow sinks). Then, we apply FlowDroid to search for all paths between the defined flow sources and sinks, and further find and interpose on all unique sharing functions that cross the boundary between the app logic and the ad library, as shown in Figure <ref type="figure" target="#fig_8">11</ref>. However, in some cases, we cannot fake a resource type in a sharing function if the resource value has been transformed somewhere along the path. For example, it is possible that, a piece of "Location" information, say latitude 40.714 and longitude -74.006, is accessed in the app logic, and then transformed into a string "New York", and finally what is returned to the ad library part is the string instead of the actual location object. In these cases, because we do not have enough knowledge to analyze the semantics of the transfer between the original object type and the transferred object type, we conservatively block or return a null object for these sharing functions regardless of users' policy setting. Other Details. Java reflection can foil our interposition technique, since reflection can invoke any method of an object at runtime without explicitly exposing the actual function signatures. To deal with this, PEDAL intercepts function calls to re f lect.Method.invoke to decide the actual function signatures during runtime using the function call re f lect.Method.toGenericS tring, and then distributes the invoke call to the actual control logic if core functions are dynamically detected. A similar technique can be used if reflection is used to achieve privilege inheritance. However, PEDAL cannot handle native libraries; in Section 5, we show that ad libraries rarely use native code.</p><p>After replacing all core functions and sharing functions with their rewritten versions, the modified bytecode together with other app files are then repacked to a modified package file. The repacking tool we have implemented strictly preserves and follows the procedure and parameters of the original packing process. Finally, the app is signed; we use the strategy introduced in <ref type="bibr" target="#b60">[62]</ref> to re-sign apps using a parallel set of randomly generated keys.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION: THE SEPARATOR</head><p>In this section, we systematically evaluate the PEDAL classifier. The highlights of our evaluation are:</p><p>• PEDAL is highly accurate (98.9% precision, 97.7% recall) in separating ad libraries from apps. The system is robust to obfuscation: it can identify obfuscated ad libraries with 97.4% accuracy. • PEDAL can discover nearly 5× more ad library sources than the number of ad libraries in blacklists prepared by prior work <ref type="bibr" target="#b24">[26,</ref><ref type="bibr" target="#b25">27,</ref><ref type="bibr" target="#b33">35,</ref><ref type="bibr" target="#b42">44,</ref><ref type="bibr" target="#b47">49,</ref><ref type="bibr" target="#b53">55,</ref><ref type="bibr" target="#b55">57,</ref><ref type="bibr" target="#b56">58]</ref>. The Dataset. We crawled the Google Play Store <ref type="bibr" target="#b11">[13]</ref> and downloaded 63,105 free apps between June 2nd, 2014 and August 1st, 2014. About 5% of these apps failed the Dalvik to Java bytecode conversion step, so our analysis uses the remaining 59,759 apps. Classifier Training. We use LibSVM <ref type="bibr" target="#b27">[29]</ref>, a state-of-the-art SVM library, to build our classifier. We obtained training samples of the classifier, which are ad and non-ad modules, from two sources. First, we collected 100 JAR files of popular ad SDKs listed in <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b33">35]</ref>. From the JAR files we extracted 335 ad modules as positive training data points, among which 117 use code obfuscation and 26 use package name obfuscation. Second, we collected the top 500 free apps in Google Play on August 1st, 2014, and extracted non-ad bytecode modules from these APK files. We randomly sampled 335 non-ad modules among them as negative training data points. The kernel (sigmoid) and parameters (γ=0.125, d=3, cost=8) of the SVM model were chosen according to a grid search of parameters in exponential scale. After a 10-fold cross validation, our classifier performed with accuracy of 98.5% on classifying ad and non-ad modules. To demonstrate that our classifier is not biased by including popular examples in the training set, we intentionally omitted Google AdMob, the most popular ad library, from the training set. Feature Efficacy. We now quantify the accuracy loss when omitting each feature selectively (Table <ref type="table" target="#tab_4">2</ref>).</p><p>First, keyword-matching features which represent the occurrences of key phrases, such as "ads," "promotion," in class, function, or field names, play an important role in boosting the accuracy of our classifier. If we exclude these features, the classifier would perform with an accuracy of 84%, which is lower than using the full feature set. Ad libraries appear to preserve such human readable names even in obfuscated library code, since this simplifies integrating the library into the app.</p><p>We then explored classifier accuracy if the classifier were to use only keyword-matching features. Compared to only using the remaining feature set (i.e., without keyword matching), these two approaches appear to have comparable accuracy. However, the accuracy of detecting ad libraries using only keyword-matching is very low. Taking these two results together, our results show that using keyword matching is necessary, but not sufficient (in the sense that other features are also necessary), to ensure high-accuracy.</p><p>Finally, omitting other groups of features selectively resulted in accuracy losses of between 2%∼9%, suggesting that every feature group is important for the classification. As an aside, we have explored many other feature sets related to function argument types, function return types, class inheritance, full permission list and so on. These additional sets only marginally increase accuracy, and can sometimes reduce accuracy due to classifier overfitting. Thus, the finally chosen features reflect the best tradeoff between the classification accuracy and the complexity of the feature space. Classifier Evaluation on Real-world Apps. To further evaluate our classifier on real-world usage scenarios, the classifier on a subset of real apps. We randomly chose 200 apps from our corpus of free Android apps. For each app, we applied the classifier to automatically identify the ad libraries in it, and examined the results by manually checking the bytecode to see whether the classifier can accurately and completely find the ad libraries within the app. Specifically, we checked ad-related behaviors by scanning through string elements, data format for URL requests and sensitive API calls in the bytecode of these apps, since this information cannot be obfuscated. Of the 200 apps, the classifier accurately and completely identified ad libraries in 186 apps (93.0%). From the 200 apps, we found 357 ad library occurrence from 174 unique ad libraries, of which the classifier identified 347. Note that among these 357 ones, 173 of them (48.5%) did not appear in the classifier training set (AdMob takes the largest number of 78). Among these apps, we found obfuscated bytecode in 120 of them (107 of them have obfuscated codes in ad library modules). Our classifier can still automatically capture 97.4% of the ad library appearances in these obfuscated bytecode blocks. In total, considering the performance on each individual app, the average precision of the classifier is 98.9% (median=100%, sd=6.0%), and the average recall is 97.7% (median=100%, sd=9.7%). New Ad Libraries. We then applied PEDAL to our entire collection of 59,759 apps. Among all these apps, our system found 34,167 apps (57.17%) that contain at least one ad library. Moreover, our classifier discovered many ad libraries previously unknown to us.</p><p>PEDAL discovered 2,598 unique ad library modules, such as the popular "com.millennialmedia.android," and "com.google.ads", as well as the unpopular "com.linxad" and "com.aarki." Note that this count is only based on folder names, and obfuscation might cause this estimate to be off. For example, two essentially different ad libraries can have the same folder name "com.a.b" after obfuscation. Conversely, a single ad library may be obfuscated differently in different apps. Among these 2,598 ad library modules, we identified 546 unique ad library sources<ref type="foot" target="#foot_5">6</ref> by: 1) retaining modules that are used by at least three different app publishers and 2) grouping modules that are known to be with a same ad network or have the same package prefix. The average occurrence of ad library sources (among the collection of 546 identified sources) in each app is 2.12 (max=35, min=1, median=1, sd=2.18). Table <ref type="table" target="#tab_5">3</ref> presents the most frequently occurring ad libraries in our collection of apps with respect to the 546 unique sources.</p><p>Compared to the initial 100 ad library sources we applied in classifier training, our system discovered many more new ad libraries. This number is at least 5× more than the reported numbers in other static code analysis based papers that maintain blacklists of ad library package names <ref type="bibr" target="#b24">[26,</ref><ref type="bibr" target="#b25">27,</ref><ref type="bibr" target="#b33">35,</ref><ref type="bibr" target="#b42">44,</ref><ref type="bibr" target="#b47">49,</ref><ref type="bibr" target="#b53">55,</ref><ref type="bibr" target="#b55">57,</ref><ref type="bibr" target="#b56">58]</ref>. These findings suggest that a blacklist-based approach may be ineffective in identifying ad libraries. To quantify this, Figure <ref type="figure" target="#fig_9">12</ref> measures the (a) the percentage of apps that contain at least one library in the Top-N most popular ad sources (a single ad source may contain multiple ad libraries) and (b) the percentage of apps whose ad libraries are entirely contained in the Top-N most popular ad sources. When N is 100 (respectively, 200), these two values are 88.84% and 85.78% (respectively, 93.37% and 90.50%). Indeed, even if we used all the 546 ad library sources we discovered in a blacklist, these two percentages are 97.23% and 95.69%. This is because there are some highly obfuscated ad library package names that cannot be used in the blacklist: for example, an obfuscated package name "a.b.c" cannot be added to the blacklist because in different apps it may represent different functional modules after obfuscation. The Efficacy of Call Graph Information. As discussed in Section 4, our classifier is designed to capture core functional modules of ad libraries, and may miss some auxiliary modules. Therefore, we explored whether it would be beneficial to detect these auxiliary modules using call-graph analysis. To do this, we used Soot <ref type="bibr" target="#b15">[17]</ref> to generate the class-level call graph of an app, then marked any auxiliary module as an ad library module if it was transitively called from a known ad library and was not a Android system library. We tested the efficacy of this approach on a random subset of 8,693 apps using ad libraries.</p><p>Call graph generation failed on 730 (8.4%) apps due to code obfuscation. For the remaining 7,963 apps, call graph analysis increases the classification cost by over two orders of magnitude, a factor of 143.12 on average (max=7,690.0, min=1.47, median=106, sd=347.5). On the other hand, this approach identified 684 new ad module occurrences (7.07% of all 9,676 occurrences), of which only 55 (0.8%) have requested new permissions, compared to ad libraries identified using the non-call-graph method. Thus, in general, this  approach increases cost significantly while providing diminishing returns.</p><p>Is privilege de-escalation necessary? If the permissions used by ad libraries are disjoint from the ones used by the apps' main logic, we can simply apply tools such as App Ops [2] to disable those permissions requested by the ad library. Table <ref type="table" target="#tab_6">4</ref> shows the statistics of the most frequently used permissions by both the ad libraries <ref type="foot" target="#foot_6">7</ref>and the app logic. There is significant overlap in the permissions requested by apps and by the ad library; of our nearly 60,000 apps, 29,926 apps have at least one permission common to both app logic and ad library. Of these, we found 15,988 apps (53.43%) in which the permissions used by ad libraries are ALL used by its app function. This motivates PEDAL's design, which enables finer-grained permissions than the underlying Android model. PEDAL's design also foils ad libraries that access resources without explicitly requesting permissions. These libraries check available permissions at runtime, and sometimes use permissions granted to the app that includes the library. We analyzed both the bytecode and the documentation of 30 randomly selected ad library SDKs, and found that 5 of them have undocumented usage of important privacy-related permissions. For example, neither "com.appflood" nor "com.applovin" claims any dependency on permissions AC-CESS_FINE_LOCATION or ACCESS_COARSE_LOCATION in their documentation. However, in the bytecode of these two libraries, we found that they both check and have API calls that rely on the location-related permissions. Similarly, "com.greystripe" claims to only use Internet-related permissions, but we found that this library checks and makes API calls to permissions CAMERA and READ_PROFILE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EVALUATION: THE REWRITER</head><p>In this section, we evaluate the overhead introduced by the Rewriter on 34,167 apps with at least one ad library. Our main results are:</p><p>• PEDAL processes an app in about a minute on a single thread. This task is trivially parallelizable.</p><p>• PEDAL introduces negligible runtime overhead (less than 1% on time cost), but can still effectively achieve privilege deescalation. The robustness of the Rewriter. The process of binary rewriting and re-packaging an app can sometimes be fragile: the resulting app may sometimes not install or run on a phone. To quantify this, we took the 34,167 apps that contained an ad library and repackaged them. This step generated no failures. Then, we tested how many of these re-packaged apps would install correctly on an Android device (Galaxy S3). Of these, 32,965 (96.48%) apps installed perfectly; the ones that failed to install were due to dexopt failures. Finally, we used the PUMA <ref type="bibr" target="#b35">[37]</ref> Android UI-automation framework to run each repacked app for 3 minutes or until all UI states were explored (whichever is shorter). In each app, the ad libraries' privilege was restricted: access to a resource either generated an exception or returned obscured or null data. In total, 10 Android emulators were created on a server running Ubuntu 14.04 with 20-core 2.8GHz CPU and 200GB memory and the corpus of 32,965 apps was equally partitioned across these emulators. Of these apps, 3,287 apps could not function properly and crashed mainly because of unhandled exceptions. For example, some apps call HttpClient.execute but fail to deal with the cases in which  IOExceptions are thrown, although these exceptions are supposed to be properly handled according to API specs. In summary, PEDAL is reasonably robust end-to-end: out of the 34,167 apps, 29,678 (86.86%) were crash-free and successfully reported PEDAL debug tags. In the rest of this section, we report results on this set of apps. Rewriting overhead. Table <ref type="table" target="#tab_7">5</ref> shows statistics for all steps discussed in Section 4. Classification and rewriting incur, on average, 0.57s and 3.43s for each app respectively. Flow analysis for detecting privilege inheritance is as expensive as repacking in some cases when multimedia resources need to be re-packed. Overall, the mean per-app processing time is 56.62s, which is acceptable, especially for app stores, since apps can be processed in parallel.</p><p>Execution overhead. The runtime overhead of an app is the cost of invoking queryController. Our micro-benchmarks for this call revealed an average running time of 13.09 ms (sd=22.87 ms) for a normal resource, and 13.45 ms (sd=23.34 ms) for the URI resource.</p><p>Other invocations (e.g., those dealing with invocations) cost less than 1ms.</p><p>To quantify the overhead end-to-end, we selected 100 apps which used the most number of ad libraries and also accessed the location resources. Executing these 100 apps on PUMA <ref type="bibr" target="#b35">[37]</ref> showed a total increase in runtime of 0.89% (min=0.02%, max=1.81%, sd=0.51%) relative to unmodified versions of these apps <ref type="foot" target="#foot_7">8</ref> . This suggests that PEDAL introduces negligible overhead, so is eminently practical. How often do ad libraries inherit privileges? With our experimental infrastructure, we are also able to quantify instances where ad libraries inherit privilege. We find that there are 7,499 apps out of the 29,678 (more than 25%) that access at least one of the five resource types through the app logic; this motivates Rewriter's careful information flow based analysis. Phone ID is the most commonly inherited resource, in 5,348 apps, and Location is next in 3,934 apps. Other resources are rarely inherited (about 0.5% in total). Does PEDAL need to handle native code? We performed static analysis on the apps to search for calls on native code functions and found there are 5,381 apps (18.13%) that use native calls <ref type="foot" target="#foot_8">9</ref> . However, out of the 5,381 apps, only 314 apps (1.06% of the total 29,678 apps) use native calls in ad libraries. Table <ref type="table" target="#tab_8">6</ref> lists the names of the top-10 used native function calls, generated by disassembling app binaries using objdump<ref type="foot" target="#foot_9">10</ref> and IDA Pro<ref type="foot" target="#foot_10">11</ref> . None of these appear to access resources. Finally, we did not find any instance of app logic invoking native code defined in ad libraries, suggesting privilege inheritance is unlikely. For this reason, PEDAL does not perform native code analysis. How effective is PEDAL's privilege de-escalation? To quantify this, we ran 3 versions of the experiments on the 100 apps discussed above. Our UI automation tool replayed the same click stream to each version, and collected screenshots of each app page visited. In the first experiment, we analyzed the original apps without rewriting them. The 100 apps generated 1000 pages, and the unmodified app showed 843 ads. We manually checked and found that 304 of these ads were targeted at San Jose, the phone's location. In the second experiment, we disabled Internet access for the ad libraries. The apps after rewriting generated only 9 ads, indicating that selective network de-escalation was effective. (These 9 ads were generated by an ad library that used an HTTP client which invoked a core function for network access that was not in our set). In the third experiment, we obscured location data by feeding a fake location in New York, NY for a phone located in San Jose, CA. Among the 806 ads shown, 249 were New York based, while only 23 targeted the real location San Jose, CA. It is not trivial to determine how many ads should have been location targeted because the targeting strategies are hard to reverse engineer. However, in the unmodified app set, we observed that 304/843 or about 36% of the ads were targeted. In this set, if the same proportion were to hold, we would expect to see about 290 targeted ads, and our manual analysis uncovered about 272, which is close to the expected number. Thus, we feel confident that PEDAL's miss rate (the rate at which it fails to catch resource accesses) is relatively low (approximate 23/272). The 23 ads that targeted the San Jose location were attributed to two causes: the failure of the classifier to identify ad libraries, and the failure of the information flow analysis to detect privilege inheritance. Overall, these results suggest that obscuring location is generally effective; our corpus of 100 apps includes apps with the most ad library sources, so PEDAL's efficacy is likely to be higher for other apps than reported here.</p><p>PEDAL &amp; ART. Android 4.4 introduced a new runtime, ART <ref type="foot" target="#foot_11">12</ref> , which has officially replaced Dalvik in the newly released Android 5.0. Other proposed fine-grained control systems, such as the popular XPrivacy <ref type="bibr" target="#b16">[18]</ref>, cannot work with ART <ref type="foot" target="#foot_12">13</ref> because they are tightly coupled with the Dalvik environment or the old OS architecture. However, we have verified that PEDAL modified apps work with ART without any noticeable changes, since PEDAL does not require OS or runtime support.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">DISCUSSION</head><p>Failures in Privilege De-Escalation. PEDAL's privilege de-escalation is not perfect: as shown in the evaluation, the Separator can introduce both false positives and false negatives, which can lead to wrongly classifying a social plugin as an ad library, or to an unstable app. However, these infrequent situations, users can choose to revoke and turn off privilege de-escalation for an app by using the Controller (Figure <ref type="figure">8</ref>).</p><p>Another mechanism that may make the de-escalation more robust and efficient is that the app store can include developers in the loop, so that they can test the instrumented apps throughly and understand the de-escalation effects before publishing the rewritten apps. However, developers may not always have the incentive or be willing to cooperate for fear of losing advertising revenue. Resigning Apps. The last step of PEDAL is to resign a repacked app using a randomly generated developer key. This approach has two problems. First, automatic app updates can no longer be delivered because the signature of the app does not match the one from the original developer. However, in this case, the app store can actively monitor the app's update and prepare repacked versions for each update. Second, some features of the original app may break. For example, a repacked app may show a blank map if this app uses Google Maps API because the API certificate is tied to the original developer key used to sign the app which has been replaced during repacking. We have not found more effective solutions for this problem other than involving the developer. Future Improvements. PEDAL can be improved along several dimensions:</p><p>Its classifier accuracy can be improved by designing better features or using more advanced classifiers. Specifically, the current selected features only reflect the most general characteristics of existing ad libraries, and we may need to re-design some of these features as ad libraries evolve. Moreover, although the designed features are resistant to package-level and code-level obfuscation, it is unclear whether they also work for other advanced obfuscation techniques, such as flow obfuscation/logic structural obfuscation, incremental obfuscation and so on. While we have not discovered uses of these advanced obfuscation techniques in today's ad libraries, in future work we plan to explore how effective our features are for such techniques.</p><p>In addition, although our core function list is fairly comprehensive, future work might wish to extend this set as the Android API evolves. Fortunately, PEDAL is designed to be extensible, and adding new core functions is simply a matter of adding some signatures. Improved information flow analysis tools can also improve the accuracy of PEDAL; for example, the tool we use, FlowDroid <ref type="bibr" target="#b18">[20]</ref> has known limitations with respect to reflection.</p><p>Finally, PEDAL cannot detect the use of native code for resource access. Native code cannot bypass resource permissions since these are enforced by the kernel, but can bypass PEDAL's privilege deescalation. As we show above, today's ad libraries do not appear to use native code for resource access. This is primarily because native code cannot access Android abstractions such as services and content providers <ref type="bibr" target="#b4">[6]</ref>; these provide apps with access to location, the contact database, call logs, account/profile, etc. Also, recently, Android terms for ad networks enforce user tracking through a unique Google Advertising ID <ref type="bibr" target="#b1">[3]</ref> assigned to each user, which also cannot be accessed by native code. Native code can use lower-level APIs for Internet access (sockets). In this case, PEDAL can effect privilege de-escalation by collaborating with a transparent Web proxy, such as Sandrop <ref type="bibr" target="#b14">[16]</ref>, an approach we have left to future work. Thus, most of the resources protected by PEDAL cannot be accessed natively, and for the Internet resource, a plausible solution exists. In the future, PEDAL can protect other resources (if any) that might be accessible by native code, by extending binary rewriting to native code, perhaps using Dynamic Binary Translation techniques <ref type="bibr" target="#b40">[42,</ref><ref type="bibr" target="#b48">50,</ref><ref type="bibr" target="#b61">63]</ref>, and we have left this to future work. Extensions and Generalizations. PEDAL's contributions go beyond privilege de-escalation. Our classifier-based approach can be used to identify bytecode sets with different properties, such as social network or e-business plugins, or to train classifiers to recognize multiple categories. Moreover, PEDAL's privilege de-escalation can be combined with methods that implement other forms of fine-grained access control to support advanced privacy policies such as "allow location data access for ad libraries only during daytime," "block Internet access to http://www.hotads.com for ad libraries."</p><p>More generally, the strategy we have investigated in the paper is to first separate and distribute code fragments to different functional sets, and then control each separated component individually. This strategy should be generally applicable to other mobile platforms, though the details of the approach will differ for different platforms. For example, Windows Mobile platform uses C# (and C# bytecode), so it should be quite straightforward to extend our technique to support it by using bytecode analysis and rewriting frameworks for C#, such as CCI (Common Compiler Infrastructure) <ref type="foot" target="#foot_13">14</ref> . iOS uses Objective C, and other work has used binary rewriting for iOS apps as well <ref type="bibr" target="#b58">[60]</ref>, so we believe PEDAL's approach can be extended to iOS apps as well. Reconciling Controllability and Usability. PEDAL can be treated as an extension to the default model of Android resource access control. However, while providing finer-grained options, it also increases the information workload for users to manage the settings, and, thus, may be preferred only by experienced or expert users. One way to address this extra workload is to use the technique of Privacy Revelations <ref type="bibr" target="#b59">[61]</ref> to provide more details about how users' private data are spread among the app logic part and the ad library part so that app users can better understand and manage these settings. Another possible solution is to apply profile-based methods <ref type="bibr" target="#b42">[44,</ref><ref type="bibr" target="#b43">45]</ref> to reconcile privacy and usability to reduce users' burden of managing the settings by learning users' general preferences and providing smart default settings for users. Possible Countermeasures. Ad libraries or app developers could foil PEDAL by: (1) Performing code obfuscation even for public APIs; in this case, developers may need to use some confusing APIs, such as "a.b" or "b.c.d" to integrate and call ad libraries, and this can reduce the accuracy of our Separator to around 84% according to Table <ref type="table" target="#tab_4">2;</ref><ref type="table"></ref> (2) Instead of using third-party ad libraries, developers can implement their own ad libraries (and may have to set up their own ad networks) and mix the implementation together with app logic, in which case, it could be very difficult to make any meaningful separation. While these countermeasures are feasible, they require significantly more development efforts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>Our work is inspired by two strands of work: one on selective privileges and fine-grained access control in mobile systems, and the other on analyzing malicious behaviors within the ad ecosystem. Selective Privileges. Most closely related to PEDAL is prior work that has considered the precise form of selective privilege assignment for ad libraries. AdSplit <ref type="bibr" target="#b53">[55]</ref> achieves this goal by extending the Android OS so that the application logic and the ad library run in different processes with different user IDs. AdDroid <ref type="bibr" target="#b47">[49]</ref> instead suggests introducing a new set of API calls and permissions for ad libraries to Android system. LayerCake <ref type="bibr" target="#b51">[53]</ref> modifies Android to permit ad libraries to embed UI elements in the main logic, without exposing data or privileges of the main app. Finally, Compac <ref type="bibr" target="#b57">[59]</ref> modifies the Android OS to enable component level privileges, and developers need to manually distinguish components. Unlike these systems, PEDAL does not require modifications to the underlying operating system or its APIs, and does not require developer intervention. Fine-grained Access Control. A complementary set of systems has considered fine-grained access control to resources. One line of work in this area has explored access control and information flow control techniques and associated expressive policy specification languages. Starting with TaintDroid <ref type="bibr" target="#b31">[33]</ref>, a long line of work has explored these techniques and languages: AppFence <ref type="bibr" target="#b36">[38]</ref>, Mock-Droid <ref type="bibr" target="#b23">[25]</ref>, Apex <ref type="bibr" target="#b46">[48]</ref>, TISSA <ref type="bibr" target="#b62">[64]</ref>, FlaskDroid <ref type="bibr" target="#b26">[28]</ref>, ASM <ref type="bibr" target="#b45">[47]</ref> and ASF <ref type="bibr" target="#b20">[22]</ref>. Another line of work has explored library re-writing <ref type="bibr" target="#b60">[62]</ref> or loader modifications <ref type="bibr" target="#b16">[18]</ref> to achieve the same goal. A third line of work has used binary rewriting (using techniques discussed in <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b34">36]</ref>) to achieve fine-grained access control <ref type="bibr" target="#b21">[23,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b37">39,</ref><ref type="bibr" target="#b38">40,</ref><ref type="bibr" target="#b50">52]</ref> and derived and enforced sub-permissions in popular permission groups. None of these pieces of work attempt to enforce percomponent access control; PEDAL is complementary and separates privileges per component, and PEDAL can be combined with some of these to provide finer-grained per component access control. Ad Analysis. We have also been inspired by another line of work that explores the static or dynamic behavior of ad libraries. For example, several pieces of work have used static analysis to explore ad library security and privacy <ref type="bibr" target="#b33">[35]</ref>, the evolution of ad libraries <ref type="bibr" target="#b24">[26]</ref>, statistics of ad library usage on Google Play <ref type="bibr" target="#b56">[58]</ref>, characteristics of ad library APIs <ref type="bibr" target="#b25">[27]</ref>, users' common privacy preferences on ad libraries <ref type="bibr" target="#b42">[44]</ref>, and usage of ad-supported apps <ref type="bibr" target="#b55">[57]</ref>. Our component separation technique builds upon the blacklisting techniques employed by these pieces of work: for example, <ref type="bibr" target="#b56">[58]</ref> maintained a list of 21 ad libraries, <ref type="bibr" target="#b24">[26]</ref> used a list of 68 ad libraries, and <ref type="bibr" target="#b33">[35]</ref> generated a list of 100 ad libraries. In contrast, PEDAL is able to identify over 5× more ad library sources than prior work.</p><p>Finally, PEDAL is complementary to prior work that has used dynamic analysis to identify ad fraud <ref type="bibr" target="#b28">[30,</ref><ref type="bibr" target="#b44">46]</ref>, or to estimate the impact of app plagiarism on ad revenue <ref type="bibr" target="#b32">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSION</head><p>In this paper, we have described PEDAL, a system to achieve selective privilege de-escalation for ad libraries. PEDAL performs automated classification to identify ad library code, and rewrites core resource access functions and resource sharing functions of these bytecode sets to achieve de-escalation. PEDAL is robust, by design, to both package name obfuscations and source code obfuscation. Despite this, PEDAL shows remarkable classification accuracy and efficacy, yet requires reasonable computing power to process apps. Finally, PEDAL is effective and imposes negligible runtime overhead for apps.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Disable Internet access for ad libraries.</figDesc><graphic coords="2,439.32,308.65,108.21,192.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Source code to bytecode.</figDesc><graphic coords="3,205.94,530.45,82.69,112.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Perform package name obfuscation and source code obfuscation on the source code</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Two ways of resource access. Taking Location as an example, ad libraries can directly get the location information by calling system calls, or provide interfaces for the app logic to transfer the location information to it.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Figure 5: A measurement of 63,105 apps</figDesc><graphic coords="5,248.78,245.22,288.94,80.42" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: System Architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Example of rewriting a normal system call (This figure and Figure10use Java-style pseudo-code to describe the instrumentation technique for ease of understanding. PEDAL rewrites byte-code, and does not require access to Java or Dalvik source.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Example of rewriting a resource sharing function for location sharing to an ad library.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: CDF comparing with the blacklist approach</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>D:\papers\mobisys 2015_seacat\pics\new 2.java Tuesday, March 24, 2015 9:55 AM</head><label></label><figDesc></figDesc><table><row><cell cols="2">package com.somecompany.ads.sdk public class AdRequest { private final int requestId; private final String requestMessage;</cell></row><row><cell>}</cell><cell>public AdRequest(int id, String message) { requestId = id; requestMessage = message; } public int getId() { return requestId; } public String getMessage() { return message; }</cell></row><row><cell cols="2">package com.ylzr.btpl187440 public class a { private final int a; private final String b;</cell></row><row><cell></cell><cell>public a(int paramInt, String paramString) { this.a = paramInt; this.b = paramString; } public int a() {</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>return this.a; } public String b() { return this.b; } }</head><label></label><figDesc></figDesc><table><row><cell>}</cell><cell>public String getMessage() { return message; }</cell></row><row><cell cols="2">package com.ylzr.btpl187440 public class a { private final int a; private final String b;</cell></row><row><cell>}</cell><cell>public a(int paramInt, String paramString) { this.a = paramInt; this.b = paramString; } public int a() { return this.a; } public String b() { return this.b; }</cell></row><row><cell>(a) Source code</cell><cell></cell></row><row><cell>-3-</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 ,</head><label>1</label><figDesc>ComponentT ype takes the values {AD, APP}, and dictates whether the policy is specified for</figDesc><table><row><cell>D:\papers\mobisys 2015_seacat\pics\new 2.java</cell></row><row><cell>// the original function is: // Location LocationManager.getLastKnownLocation( // String provider) public static Location PEDAL.getLastKnownLocation( LocationManager manager, String provider) { Policy currentPolicy = queryController("AccuWeather", "Location", "AD"); if (currentPolicy == Policy.BLOCK) { return null; } else if (currentPolicy == Policy.OBSCURE) { Location obscuredLocation = new Location(provider); // set obscuredLocation to Sunnyvale obscuredLocation.setLatitude(37.369); obscuredLocation.setLongitude(-122.036); return obscuredLocation } // queryController returns Policy.ALLOW return manager.getLastKnownLocation(provider); }</cell></row><row><cell>private static Policy PEDAL.queryController(appName, resourceType, componentType) { // query user's configuration // resourceType is: // Internet, Location, a content provider URI, etc. // componentType is: "AD" or "APP" }</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Feature Selection and Classifier Performance</figDesc><table><row><cell>Feature Selection</cell><cell>Category</cell><cell>Recall</cell><cell>Precision</cell></row><row><cell></cell><cell>Ad Library</cell><cell>0.991</cell><cell>0.988</cell></row><row><cell>All Features</cell><cell>Non-Ad Module</cell><cell>0.976</cell><cell>0.982</cell></row><row><cell></cell><cell>Weighted Average</cell><cell>0.984</cell><cell>0.985</cell></row><row><cell></cell><cell>Ad Library</cell><cell>0.857</cell><cell>0.866</cell></row><row><cell>No Keyword-Matching Features</cell><cell>Non-Ad Module</cell><cell>0.827</cell><cell>0.815</cell></row><row><cell></cell><cell>Weighted Average</cell><cell>0.842</cell><cell>0.841</cell></row><row><cell></cell><cell>Ad Library</cell><cell>0.746</cell><cell>0.716</cell></row><row><cell>Only Keyword-Matching Features</cell><cell>Non-Ad Module</cell><cell>0.925</cell><cell>0.919</cell></row><row><cell></cell><cell>Weighted Average</cell><cell>0.836</cell><cell>0.818</cell></row><row><cell></cell><cell>Ad Library</cell><cell>0.908</cell><cell>0.905</cell></row><row><cell>No Basic-Component Features</cell><cell>Non-Ad Module</cell><cell>0.913</cell><cell>0.916</cell></row><row><cell></cell><cell>Weighted Average</cell><cell>0.911</cell><cell>0.911</cell></row><row><cell></cell><cell>Ad Library</cell><cell>0.899</cell><cell>0.899</cell></row><row><cell>No Permission Features</cell><cell>Non-Ad Module</cell><cell>0.887</cell><cell>0.902</cell></row><row><cell></cell><cell>Weighted Average</cell><cell>0.893</cell><cell>0.901</cell></row><row><cell></cell><cell>Ad Library</cell><cell>0.937</cell><cell>0.928</cell></row><row><cell>No Visual-Element Features</cell><cell>Non-Ad Module</cell><cell>0.928</cell><cell>0.925</cell></row><row><cell></cell><cell>Weighted Average</cell><cell>0.933</cell><cell>0.927</cell></row><row><cell></cell><cell>Ad Library</cell><cell>0.922</cell><cell>0.91</cell></row><row><cell>No Sources-and-Sinks Features</cell><cell>Non-Ad Module</cell><cell>0.902</cell><cell>0.884</cell></row><row><cell></cell><cell>Weighted Average</cell><cell>0.912</cell><cell>0.897</cell></row><row><cell></cell><cell>Ad Library</cell><cell>0.97</cell><cell>0.973</cell></row><row><cell>No Permission-Check Feature</cell><cell>Non-Ad Module</cell><cell>0.955</cell><cell>0.949</cell></row><row><cell></cell><cell>Weighted Average</cell><cell>0.963</cell><cell>0.961</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Top-10 Frequently Occurring Ad Libraries by Ad Network Names</figDesc><table><row><cell>Name of ad library source</cell><cell>Frequency in the 34,167-app corpus</cell></row><row><cell>Google AdMob</cell><cell>21,772</cell></row><row><cell>Millennial Media</cell><cell>3,871</cell></row><row><cell>Flurry</cell><cell>3,215</cell></row><row><cell>InMobi</cell><cell>1,929</cell></row><row><cell>MoPub</cell><cell>1,777</cell></row><row><cell>Mobclix</cell><cell>1,581</cell></row><row><cell>Airpush</cell><cell>1,316</cell></row><row><cell>MobFox</cell><cell>1,092</cell></row><row><cell>Leadbolt</cell><cell>926</cell></row><row><cell>Tapjoy</cell><cell>899</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>Top-10 Frequently-Used Permissions</figDesc><table><row><cell cols="2">Used by apps' main logic (among 59,759 apps)</cell><cell cols="3">Used by Ad Libraries (among 546 Ad Sources)</cell><cell></cell></row><row><cell></cell><cell></cell><cell>Actually Used by Ads</cell><cell></cell><cell cols="2">Checked for Availability by Ads</cell></row><row><cell>Permission</cell><cell>Frequency</cell><cell>Permission</cell><cell>Frequency</cell><cell>Permission</cell><cell>Frequency</cell></row><row><cell>INTERNET</cell><cell>43,498</cell><cell>INTERNET</cell><cell>546</cell><cell>ACCESS_FINE_LOCATION</cell><cell>104</cell></row><row><cell>ACCESS_NETWORK_STATE</cell><cell>36,485</cell><cell>ACCESS_NETWORK_STATE</cell><cell>413</cell><cell>ACCESS_COARSE_LOCATION</cell><cell>101</cell></row><row><cell>READ_PHONE_STATE</cell><cell>15,265</cell><cell>READ_PHONE_STATE</cell><cell>264</cell><cell>ACCESS_NETWORK_STATE</cell><cell>86</cell></row><row><cell>VIBRATE</cell><cell>14,299</cell><cell>RECEIVE_BOOT_COMPLETED</cell><cell>246</cell><cell>INTERNET</cell><cell>81</cell></row><row><cell>WAKE_LOCK</cell><cell>13,656</cell><cell>WAKE_LOCK</cell><cell>208</cell><cell>READ_PHONE_STATE</cell><cell>81</cell></row><row><cell>ACCESS_FINE_LOCATION</cell><cell>13,205</cell><cell>ACCESS_COARSE_LOCATION</cell><cell>190</cell><cell>WRITE_EXTERNAL_STORAGE</cell><cell>71</cell></row><row><cell>ACCESS_COARSE_LOCATION</cell><cell>11,153</cell><cell>ACCESS_FINE_LOCATION</cell><cell>173</cell><cell>ACCESS_WIFI_STATE</cell><cell>70</cell></row><row><cell>ACCESS_WIFI_STATE</cell><cell>6,987</cell><cell>ACCESS_WIFI_STATE</cell><cell>137</cell><cell>CALL_PHONE</cell><cell>39</cell></row><row><cell>RECEIVE_BOOT_COMPLETED</cell><cell>5,984</cell><cell>GET_ACCOUNTS</cell><cell>111</cell><cell>READ_CONTACTS</cell><cell>35</cell></row><row><cell>READ_CONTACTS</cell><cell>4,943</cell><cell>READ_CONTACTS</cell><cell>49</cell><cell>GET_ACCOUNTS</cell><cell>32</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 5 :</head><label>5</label><figDesc>Micro-Benchmark: Running Time Cost of Each Step</figDesc><table><row><cell>Processing Step</cell><cell cols="5">Time Cost (in seconds, on 29,678 ad-included apks) Average Median Max Min Stdev</cell></row><row><cell>Apk to Java Bytecode</cell><cell>5.81</cell><cell>4.52</cell><cell>52.24</cell><cell>0.48</cell><cell>5.01</cell></row><row><cell>Module Classification</cell><cell>0.57</cell><cell>0.24</cell><cell>11.95</cell><cell>0.00</cell><cell>0.81</cell></row><row><cell>Indirect Flow Analysis</cell><cell>28.93</cell><cell>8.58</cell><cell>455.44</cell><cell>0.34</cell><cell>49.99</cell></row><row><cell>Java Bytecode Rewriting</cell><cell>3.43</cell><cell>1.67</cell><cell>72.70</cell><cell>0.04</cell><cell>4.93</cell></row><row><cell>Repacking to Apk</cell><cell>17.82</cell><cell>10.54</cell><cell>617.86</cell><cell>1.99</cell><cell>27.77</cell></row><row><cell>Total time</cell><cell>56.63</cell><cell>25.98</cell><cell>1075.85</cell><cell>2.73</cell><cell>93.25</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 6 :</head><label>6</label><figDesc>Top-10 Frequency of Native Function Names</figDesc><table><row><cell cols="2">Used by apps' main logic</cell><cell cols="2">Used by Ad Libraries</cell></row><row><cell>Function Name</cell><cell>App Freq</cell><cell>Function Name</cell><cell>App Freq</cell></row><row><cell>nativeInit</cell><cell>1266</cell><cell>UnitySendMessage</cell><cell>195</cell></row><row><cell>nativeRender</cell><cell>1115</cell><cell>getAsString</cell><cell>113</cell></row><row><cell>nativeResize</cell><cell>930</cell><cell>getAsBool</cell><cell>108</cell></row><row><cell>nativePause</cell><cell>905</cell><cell>getAsInt</cell><cell>108</cell></row><row><cell>nativeResume</cell><cell>872</cell><cell>newObject</cell><cell>98</cell></row><row><cell>nativeDone</cell><cell>852</cell><cell>getActivity</cell><cell>74</cell></row><row><cell>init</cell><cell>710</cell><cell>getLength</cell><cell>52</cell></row><row><cell>installNdk</cell><cell>609</cell><cell>getObjectAt</cell><cell>52</cell></row><row><cell>checkLibraryVersion</cell><cell>599</cell><cell>dispatchStatusEventAsync</cell><cell>46</cell></row><row><cell>newPolygonShape</cell><cell>571</cell><cell>getAsDouble</cell><cell>13</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>MobiSys'15, May 18-22, 2015, Florence, Italy.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Not included in this example are native libraries<ref type="bibr" target="#b4">[6]</ref> that are written in native-code languages such as C/C++. The purpose of introducing native libraries is mainly for reusing existing code libraries written in C/C++. We discuss native libraries later.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Note that we do not consider native code when performing classification because the usage of native code in ad libraries is minimal. (Section 6).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>We refer interested readers to<ref type="bibr" target="#b3">[5]</ref> for more Android application fundamentals.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Content providers are basic Android components, and are actually databases addressable by their application-defined URIs. One use of content providers is to share information between apps.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Modules that have obfuscated or randomized package names are excluded from grouping. Thus, the actual number of unique sources may be more than this number.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>Note that each ad library source may have multiple versions, and we dated every versions of a same source using the heuristic introduced in<ref type="bibr" target="#b24">[26]</ref>, Therefore, the permission usage of an individual ad library source is based on its latest version found in our app corpus.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>In running these experiments, we carefully ensured that both versions of the app were fed identical click streams by the "monkey".</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p><ref type="bibr" target="#b7">9</ref> This number is slightly higher than the number of 17.41% reported by a recent large-scale study<ref type="bibr" target="#b56">[58]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>http://en.wikipedia.org/wiki/Objdump</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>https://www.hex-rays.com/products/ida/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_11"><p>http://source.android.com/devices/tech/dalvik/art.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_12"><p>https://github.com/M66B/XPrivacy#FAQ75</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_13"><p>https://ccimetadata.codeplex.com</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank our shepherd, Landon Cox, and the anonymous referees, for their insightful suggestions for improving the technical content and presentation of the paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Includes Hidden App Permissions Manager That Could Bolster Privacy &amp; Security</title>
		<idno>Android 4.3</idno>
		<ptr target="http://techcrunch.com/2013/07/26/android-app-ops/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">D</forename><surname>Advertising</surname></persName>
		</author>
		<ptr target="https://developer.android.com/google/play-services/id.html" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Api</forename><surname>Android</surname></persName>
		</author>
		<author>
			<persName><surname>Guides</surname></persName>
		</author>
		<ptr target="https://developer.android.com/guide/index.html" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://developer.android.com/guide/components/fundamentals.html" />
		<title level="m">Android Application Fundamentals</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Ndk</forename><surname>Android</surname></persName>
		</author>
		<ptr target="http://developer.android.com/tools/sdk/ndk/index.html" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<ptr target="http://www.appbrain.com/stats/libraries/ad" />
	</analytic>
	<monogr>
		<title level="j">AppBrain Statistics on Android Libraries: Ad Networks</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<ptr target="https://code.google.com/p/axml/" />
		<title level="m">AXML: Read Write Android Binary XML and resources.arsc Files</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<ptr target="http://www.chartboost.com/" />
		<title level="m">Chartboost</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="http://en.wikipedia.org/wiki/Component-based_software_engineering" />
		<title level="m">Component-based Software Engineering</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<ptr target="http://www.appbrain.com/stats/free-and-paid-android-applications" />
		<title level="m">Distribution of Free vs. Paid Android Apps</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<ptr target="http://www.gartner.com/newsroom/id/2791017" />
		<title level="m">Gartner Says Worldwide Traditional PC, Tablet, Ultramobile and Mobile Phone Shipments to Grow 4.2 Percent in 2014</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Google</forename><surname>Play</surname></persName>
		</author>
		<ptr target="https://play.google.com/store" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<ptr target="https://adblockplus.org/en/android-install" />
		<title level="m">Install Adblock Plus for Android</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<ptr target="http://developer.android.com/tools/help/proguard.html" />
		<title level="m">ProGuard</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="https://code.google.com/p/sandrop/" />
		<title level="m">Sandrop: Secure Android Proxy</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<ptr target="http://www.sable.mcgill.ca/soot/" />
		<title level="m">Java Optimization Framework</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><surname>Xpricacy</surname></persName>
		</author>
		<ptr target="https://github.com/M66B/XPrivacy#xprivacy" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Brave New World: Privacy Risks for Mobile Users</title>
		<author>
			<persName><forename type="first">P</forename><surname>Aditya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bhattacharjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Erdélyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lentz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SPME</title>
		<meeting>ACM SPME</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware Taint Analysis for Android Apps</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arzt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rasthofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bodden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">L</forename><surname>Traon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Octeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM PLDI</title>
		<meeting>ACM PLDI</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">PScout: Analyzing the Android Permission Specification</title>
		<author>
			<persName><forename type="first">K</forename><surname>Au</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM CCS</title>
		<meeting>ACM CCS</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bugiel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gerling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Styp-Rekowsky</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1404.1395</idno>
		<title level="m">Android Security Framework: Enabling Generic and Extensible Access Control on Android</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">AppGuard: Enforcing User Requirements on Android Apps</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gerling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maffei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Von</forename><forename type="middle">P</forename><surname>Styp-Rekowsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ETAPS TACAS</title>
		<meeting>ETAPS TACAS</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Bartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monperrus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Allix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Traon</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1208.4536</idno>
		<title level="m">Improving privacy on android smartphones through in-vivo bytecode instrumentation</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">MockDroid: Trading Privacy for Application Functionality on Smartphones</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Beresfordand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Skehin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sohan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM HotMobile</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Longitudinal Analysis of Android Ad Library Permissions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Book</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pridgen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wallach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE MoST</title>
		<meeting>IEEE MoST</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A Case of Collusion: A Study of the Interface between Ad Libraries and Their Apps</title>
		<author>
			<persName><forename type="first">T</forename><surname>Book</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wallach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SPSM</title>
		<meeting>ACM SPSM</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Flexible and Fine-grained Mandatory Access Control on Android for Diverse Security and Privacy Policies</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bugiel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Heuser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX security</title>
		<meeting>USENIX security</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">LIBSVM: A Library for Support Vector Machines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
		<ptr target="http://www.csie.ntu.edu.tw/~cjlin/libsvm" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Intelligent Systems and Technology</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">MAdFraud: Investigating Ad Fraud in Android Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Crussell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiSys</title>
		<meeting>ACM MobiSys</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Retroskeleton: Retrofitting Android apps</title>
		<author>
			<persName><forename type="first">B</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiSys</title>
		<meeting>ACM MobiSys</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">I-ARM-Droid: A Rewriting Framework for In-app Reference Monitors for Android Applications</title>
		<author>
			<persName><forename type="first">B</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Khodaverdian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE MoST</title>
		<meeting>IEEE MoST</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">TaintDroid: An Information-flow Tracking System for Realtime Privacy Monitoring on Smartphones</title>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">AdRob: Examining the Landscape and Impact of Android Application Plagiarism</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crussell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Choi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiSys</title>
		<meeting>ACM MobiSys</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Unsafe Exposure Analysis of Mobile In-app Advertisements</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM WiSec</title>
		<meeting>ACM WiSec</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Sif: A selective instrumentation framework for mobile applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Halfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiSys</title>
		<meeting>ACM MobiSys</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">PUMA: Programmable UI-automation for Large Scale Dynamic Analysis of Mobile Apps</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Halfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MobiSys</title>
		<meeting>MobiSys</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">These Aren&apos;t the Droids You&apos;re Looking for: Retrofitting Android to Protect Data from Imperious Applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hornyack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM CCS</title>
		<meeting>ACM CCS</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Application-Centric Security Policies on Unmodified Android</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Micinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vaughan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
		<respStmt>
			<orgName>University of Maryland Computer Science Department Technical</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Hide: Fine-grained Permissions in Android Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Micinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vaughan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fogel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SPSM</title>
		<meeting>SPSM</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">When are users comfortable sharing locations with advertisers?</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Benisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">F</forename><surname>Cranor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCHI Conference on Human Factors in Computing Systems, CHI &apos;11</title>
		<meeting>the SIGCHI Conference on Human Factors in Computing Systems, CHI &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="2449" to="2452" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Secure execution via program shepherding</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kiriansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Expectation and Purpose: Understanding Users&apos; Mental Models of Mobile App Privacy through Crowdsourcing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lindqvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM UbiComp</title>
		<meeting>ACM UbiComp</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Modeling Users&apos; Mobile App Privacy Preferences: Restoring Usability in a Sea of Permission Settings</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOUPS</title>
		<meeting>SOUPS</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Reconciling Mobile App Privacy and Usability on Smartphones: Could User Privacy Profiles Help?</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WWW</title>
		<meeting>WWW</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">DECAF: Detecting and Characterizing Ad Fraud in Mobile Apps</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX NSDI</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">ASM: A Programmable Interface for Extending Android Security</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nadkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX security</title>
		<meeting>USENIX security</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Apex: Extending Android Permission Model and Enforcement with User-defined Runtime Constraints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nauman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ASIACCS</title>
		<meeting>ASIACCS</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">AdDroid: Privilege Separation for Applications and Advertisers in Android</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Felt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nunez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM ASIACCS</title>
		<meeting>ACM ASIACCS</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Dynamic Binary Translation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Probst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. UKUUG Linux Developerâ Ȃ Źs Conference</title>
		<meeting>UKUUG Linux Developerâ Ȃ Źs Conference</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">A Machine-learning Approach for Classifying and Categorizing Android Sources and Sinks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rasthofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Arzt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bodden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Application-Centric Security Policies on Unmodified Android</title>
		<author>
			<persName><forename type="first">N</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vaughan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Foster</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
		<respStmt>
			<orgName>UCLA Computer Science Department Technical</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Securing embedded user interfaces: Android and beyond</title>
		<author>
			<persName><forename type="first">F</forename><surname>Roesner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kohno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">AppProfiler: a Flexible Method of Exposing Privacy-related Behavior in Android Applications to End Users</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM CODASPY</title>
		<meeting>ACM CODASPY</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">AdSplit: Separating Smartphone Advertising from Applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shekhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dietz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wallach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Investigating User Privacy in Android Ad Libraries</title>
		<author>
			<persName><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crussell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE MoST</title>
		<meeting>IEEE MoST</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Understanding Mobile App Usage Patterns Using in-App Advertisements</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tongaonkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Passive and Active Measurement</title>
		<meeting>Passive and Active Measurement</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">A Measurement Study of Google Play</title>
		<author>
			<persName><forename type="first">N</forename><surname>Viennot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nieh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMETRICS</title>
		<meeting>ACM SIGMETRICS</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Compac: Enforce Component-level Access Control in Android</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hariharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Du</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CODASPY</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">PSiOS: Bring Your Own Privacy &amp; Security to iOS Devices</title>
		<author>
			<persName><forename type="first">T</forename><surname>Werthmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ASIACCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Choffnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Greenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hornyack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<imprint>
			<publisher>Privacy Revelations for Web and Mobile Apps</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Aurasium: Practical Policy Enforcement for Android Applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Saidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Native client: A sandbox for portable, untrusted x86 native code</title>
		<author>
			<persName><forename type="first">B</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dardyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ormandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Okasaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Narula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Fullagar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Security and Privacy</title>
		<meeting>IEEE Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Taming Information-stealing Smartphone Applications (on Android)</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Freeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TRUST</title>
		<meeting>TRUST</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
