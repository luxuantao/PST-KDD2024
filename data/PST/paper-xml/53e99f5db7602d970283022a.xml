<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Power: A First-Class Architectural Design Constraint Power is a design constraint not only for portable computers and mobile communication devices but also for high-end systems, and the design process should not subordinate it to performance</title>
				<funder ref="#_S4KfwMA">
					<orgName type="full">DARPA</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Trevor</forename><surname>Mudge</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Michigan</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Power: A First-Class Architectural Design Constraint Power is a design constraint not only for portable computers and mobile communication devices but also for high-end systems, and the design process should not subordinate it to performance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T08:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L</head><p>imiting power consumption presents a critical issue in computing, particularly in portable and mobile platforms such as laptop computers and cell phones. Limiting power in other computer settings-such as server farms-warehouse-sized buildings filled with Internet service providers' servers-is also important. A recent analysis by Deo Singh and Vivek Tawair of Intel showed that a 25,000-square-foot server farm with approximately 8,000 servers consumes 2 megawatts and that power consumption either directly or indirectly accounts for 25 percent of the cost for managing such a facility (see the proceedings of the Cool Chips Tutorial at http://www.eecs.umich.edu/~tnm/ cool.pdf).</p><p>Internet use is growing exponentially, requiring server farms to match the accompanying demand for power. A Financial Times article in Fall 2000 noted that information technology (IT) consumes about 8 percent of power in the US. If this component continues to grow exponentially without check, IT will soon require more power than all other uses combined.</p><p>Table <ref type="table" target="#tab_0">1</ref> presents information to better understand current processor power consumption trends (see the Berkeley CPU information center at http://bwrc.eecs. berkeley.edu/CIC/summary/local/summary.pdf). The rapid growth in power consumption is obvious. Equally alarming is the growth in the chip die's power density, which increases linearly. Alpha model 21364's power density has reached approximately 30 watts per square centimeter, which is three times that of a typical hot plate. This growth occurred despite process and circuit improvements. Trading high power for high performance cannot continue, and containing the growth in power requires adding architectural improvements to process and circuit improvements. The only exceptions will be one-of-a-kind supercomputers built for special tasks like weather modeling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>POWER EQUATIONS FOR CMOS LOGIC</head><p>Three equations provide a model of the power-performance trade-offs for complementary metal-oxide semiconductor logic circuits. The CMOS literature on low power frequently uses these equations. They are simplifications that capture the essentials for logic designers, architects, and systems builders. Here I focus on CMOS because it will likely remain the dominant technology for the next five to seven years. Besides applying directly to processor logic and caches, the equations have relevance for some aspects of DRAM chips. The first equation defines power consumption:</p><formula xml:id="formula_0">P = ACV 2 f + ?AVI short f + VI leak<label>(1)</label></formula><p>This equation has three components. The first component measures the dynamic power consumption caused by the charging and discharging of the capacitive load on each gate's output. It is proportional to the frequency of the system's operation, f, the activity of the gates in the system, A (some gates do not switch every clock), the total capacitance seen by the gate's outputs, C, and the square of the supply voltage, V. The second component captures the power expended as a result of the short-circuit current, I short, which momentarily, ?, flows between the supply voltage and ground when a CMOS logic gate's output switches. The third component measures the power lost from the leakage current regardless of the gate's state.</p><p>In today's circuits, the first term dominates, which immediately suggests that reducing the supply voltage, V, is the most effective way to reduce power consumption. The quadratic dependence on V means that the savings can be significant: Halving the voltage reduces the power consumption to one-fourth its original value. Unfortunately, this savings comes at the expense of performance, or, more accurately, maximum-operating frequency, as the next equation shows:</p><formula xml:id="formula_1">f max ? (V -V threshold ) 2 / V (2)</formula><p>The maximum frequency of operation is roughly linear in V. Reducing it limits the circuit to a lower frequency. Reducing the power to one-fourth its original value only halves the maximum frequency. Equations 1 and 2 have an important corollary: Parallel processing, which involves splitting a computation in two and running it as two parallel independent tasks, has the potential to cut the power in half without slowing the computation.</p><p>Reducing the voltage, V, in Equation 2 requires a reduction in V threshold. This reduction must occur so that low-voltage logic circuits can properly operate. Unfortunately, reducing V threshold increases the leakage current, as Equation <ref type="formula" target="#formula_2">3</ref>shows:</p><formula xml:id="formula_2">I leak ? exp ( -qV threshold / (kT))<label>(3)</label></formula><p>Thus, this is a limited option for countering the effect of reducing V, because it makes the leakage term in the first equation appreciable.</p><p>We can summarize the three essential points from this model as follows:</p><p>? Reducing voltage has a significant effect on power consumption: P ? V 2 .</p><p>? Reducing activity-most simply by turning off the computer's unused parts-also affects power consumption. ? Parallel processing can reduce power consumption if done efficiently-ideally by applying it to independent tasks.</p><p>Although reducing the supply voltage can decrease power consumption and result in considerable savings with only a modest impact on performance, the accompanying increase in leakage current limits how far this technique can be taken.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Other figures of merit related to power</head><p>Equation 1 represents an average value that gives a somewhat one-dimensional view. In many cases, at least two other power quantities are important:</p><p>? Peak power. Typically, systems have an upper limit that, if exceeded, leads to some damage. ? Dynamic power. Sharp changes in power consumption can result in ground bounce or di/dt noise that upsets logic voltage levels, causing erroneous circuit behavior.</p><p>Often, we use the term power to refer to quantities that are not really power. For example, in portable devices, the amount of energy needed to perform a computation may be a more useful measure because a battery stores a fixed amount of energy, not power. To say that one processor is lower power than another may be misleading. If it takes longer to perform a given computation, the total energy expended may be the same-the battery will run down by the same amount in both cases. This comparison leads to the idea of an energy/operation ratio. A processor with a low energy/operation ratio is sometimes incorrectly referred to as a low-power processor. Engineers frequently use the inverse of this measure, MIPS/W or million instructions per second per watt, as a figure of merit for processors intended for mobile applications.</p><p>Reducing the power consumption by half decreases the frequency of operation by much less because of the quadratic term in Equation 1. Ricardo Gonzalez and Mark Horowitz 1 proposed a third figure of merit: energy ? delay. This measure takes into account that, in systems in which power is modeled by Equation <ref type="formula" target="#formula_0">1</ref>, we can trade a decrease in speed for higher MIPS/W. Most of the literature uses MIPS/W or simply watts, so we will continue this convention, recognizing that occasionally it can suggest misleading trade-offs where "quadratic" devices like CMOS are concerned. Finally, if the computation under consideration must finish by a deadline, slowing the operation may not be an option. In these cases, a measure that combines total energy with a deadline is more appropriate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>REDUCING POWER CONSUMPTION</head><p>Systems designers have developed several techniques to save power at the logic, architecture, and operating systems levels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Logic</head><p>A number of techniques can save power at the logic level. The clock tree can consume 30 percent of a processor's power; the early Alpha model 21064 exceeded even this figure. Therefore, it is not surprising that engineers have developed several power-saving techniques at this level.</p><p>Clock gating. This technique is widely used to turn off clock tree branches to latches or flip-flops whenever they are not used. Until recently, developers considered gated clocks to be a poor design practice because the clock tree gates can exacerbate clock skew. However, more accurate timing analyzers and more flexible design tools have made it possible for developers to produce reliable designs with gated clocks.</p><p>Half-frequency and half-swing clocks. A half-frequency clock uses both edges of the clock to synchronize events. The clock then runs at half the frequency of a conventional clock. The drawbacks are that the latches are more complex and occupy more area, and that the clock's requirements are more stringent.</p><p>The half-swing clock swings only half of V. It increases the latch design's requirements and is difficult to use in systems with low V. However, lowering clock swing usually produces greater gains than clocking on both edges.</p><p>Asynchronous logic. Asynchronous logic proponents have pointed out that because their systems do not have a clock, they save the considerable power that a clock tree requires. However, asynchronous logic design suffers from the drawback of needing to generate completion signals. This requirement means that additional logic must be used at each register transfer-in some cases, a double-rail implementation, which can increase the amount of logic and wiring. Other drawbacks include testing difficulty and an absence of design tools.</p><p>Several projects have attempted to demonstrate the power savings possible with asynchronous systems. The Amulet, an asynchronous implementation of the ARM instruction-set architecture, is one of the most successful projects (see the Power-Driven Microarchitecture Workshop at http://www.cs.colorado.edu/~grunwald/ LowPowerWorkshop/agenda.html). Drawing definitive conclusions from such projects is difficult because it requires comparing designs that use the same technologies. Further, the asynchronous designer works at a disadvantage because today's design tools are geared for synchronous design. Ultimately, asynchronous design does not offer sufficient advantages to merit a wholesale switch from synchronous designs.</p><p>However, asynchronous techniques can play an important role in globally asynchronous, locally synchronous systems. <ref type="bibr" target="#b1">2</ref> Such systems reduce clock power and help with the growing problem of clock skew across a large chip, while allowing the use of conventional design techniques for most of the chip.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Architecture</head><p>Computer architecture research, typified by the work presented at the International Symposia on Computer Architecture and the International Symposia on Microarchitecture, focuses on high performance. This research pursues two important themes: exploiting parallelism and using speculation. Parallelism can reduce power, whereas speculation can permit computations to proceed beyond dependent instructions that may not have completed. If the speculation is wrong, executing useless instructions can waste energy. But this is not necessarily so. Branch prediction is perhaps the best-known example of speculation. If the predictors are accurate, it can increase the MIPS/W figure. <ref type="bibr" target="#b2">3</ref> New architectural ideas can contribute most profitably to reducing the dynamic power consumption term, specifically the activity factor, A, in Equation <ref type="formula" target="#formula_0">1</ref>.</p><p>Memory systems. The memory system consumes a significant amount of power. In systems with unsophisticated processors, cache memory can dominate the chip area. Memory systems have two sources of power loss. First, the frequency of memory access causes dynamic power loss, as the first term in Equation 1 models. Second, leakage current contributes to power loss, as the third term in Equation 1 models.</p><p>Organizing memory so that an access activates only parts of it can help to limit dynamic memory power loss. Placing a small cache in front of the L1 cache creates a filter cache that intercepts signals intended for the main cache. <ref type="bibr" target="#b3">4</ref> Even if the filter cache is hit only 50 percent of the time, the power saved is half the difference between activating the main cache and the filter cache, which can be significant.</p><p>Memory banking, currently used in some low-power designs, splits the memory into banks and activates only the bank presently in use. Because it relies on the reference pattern having a lot of spatial locality, memory banking is more suitable for instruction-cache organization.</p><p>The architect or systems designer can do little to limit leakage except shut down the memory. This is only practical if the memory will remain unused for a long time because memory will lose state and, therefore, requires disk backup. The operating system usually Computer architecture research has pursued two themes: exploiting parallelism and using speculation.</p><p>handles this type of shutdown, which we often refer to as "sleep mode."</p><p>Buses. Buses are a significant source of power loss, especially interchip buses, which are often very wide. The standard PC memory bus includes 64 data lines and 32 address lines, and each line requires substantial drivers. A chip can expend 15 percent to 20 percent of its power on these interchip drivers.</p><p>One approach to limiting this swing is to encode the address lines into a Gray code because address changes, particularly from cache refills, are often sequential, and counting in Gray code switches the least number of signals. <ref type="bibr" target="#b4">5</ref> Adapting other ideas to this problem is straightforward. Transmitting the difference between successive address values achieves a result similar to the Gray code. Compressing the information in address lines further reduces them. <ref type="bibr" target="#b5">6</ref> These techniques are best suited to interchip signaling because designers can integrate the encoding into the bus controllers.</p><p>Code compression results in significant instruction-memory savings if the system stores the program in compressed form and decompresses it on the fly, typically on a cache miss. <ref type="bibr" target="#b6">7</ref> Reducing memory size translates to power savings. It also reduces code overlays-a technique still used in many digitalsignal processing (DSP) systems-which are another source of power loss.</p><p>Parallel processing and pipelining. A corollary of our power model is that parallel processing can be an important technique for reducing power consumption in CMOS systems. Pipelining does not share this advantage because it achieves concurrency by increasing the clock frequency, which limits the ability to scale the voltage, as Equation 2 demonstrates. This is an interesting reversal because pipelining is simpler than parallel processing; therefore, pipelining is traditionally the first choice to speed up execution. In practice, the trade-off between pipelining and parallelism is not so distinct: Replicating function units rather than pipelining them has the negative effect of increasing area and wiring, which in turn can increase power consumption.</p><p>The degree to which designers can parallelize computations varies widely. Although some computations are "embarrassingly parallel," they are usually characterized by identical operations on array data structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mike Morrow, Intel</head><p>The Intel XScale Core (http://developer. intel.com/design/intelxscale/) uses advanced circuit, process, and microarchitectural techniques to facilitate low-power operation.</p><p>A processor's active power dissipation is proportional to the frequency and square of the voltage. In the V 2 term of the active power equation, voltage to the core is scalable from 0.75 V to 1.65 V. The core also incorporates back-bias circuitry to minimize leakage current during inactivity, and the core's static design-the clock can be reduced to dc-contributes linearly to active power savings.</p><p>Intel's 80200 (http://developer.intel. com/design/iio/manuals/273411.htm)the first processor to incorporate Intel XScale microarchitecture-offers additional power-saving opportunities by enabling rapid frequency and no-stall voltage changes and by providing a memory bus that runs asynchronously.</p><p>Reaching a lower-power state may not be worthwhile if it requires a long time.</p><p>Because the 80200 uses a PLL with a fast resynch time, it can switch frequencies or power modes in less than 20 ?s. This enables system techniques in which the processor, while providing good interactive response, is usually asleep or operating at low frequency. For example, the processor can be in "drowsy" mode (core dissipation less than 1 mW) until an event awakens it; then it processes the event at several hundred megahertz and drops back into drowsy mode. Even the fastest touch-typist would not detect any performance degradation.</p><p>For voltage scaling to be effective, the processor must not spend excessive time waiting for the voltage to change. A shorter processor idle period translates into accomplishing more work. The 80200's core can run through a voltage change without the processor idling during the transition. Also, the voltage can follow a natural discharge curve rather than being stepped or precipitously dropped for the core, which avoids wastefully forcing the voltage to a lower level and perhaps enables the use of a simpler power supply. The 80200's bus interface runs asynchronously-the core can run at a frequency unrelated to the bus clock. In fact, two clock signals are input to the device, allowing system software to change core frequency as needed without concern for bus operation. If the bus frequency is a fixed fraction of the core frequency, as is often the case, a change in core frequency might necessitate waiting for the bus to clear.</p><p>The asynchronous relationship of the bus and core clocks also enables static or dynamic optimization of the bus frequency. A RAM region with a 25-ns access time requires three 100-MHz clock cycles per access, or one 33-MHz clock cycle. A system with predictable accesses to this memory might choose to drop the bus frequency and realize a linear improvement in power without incurring any loss in throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mike Morrow is a processor architect at</head><p>Intel. Contact him at michael.morrow@ intel.com.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Microarchitecture Uses a Low-Power Core</head><p>However, for general-purpose computations typified by the System Performance Evaluation Cooperative benchmark suite, designers have made little progress in discovering parallelism. Successful general-purpose microprocessors rarely issue more than three or four instructions at once. Increasing instruction-level parallelism is unlikely to offset the loss caused by inefficient parallel execution. Future desktop architectures, however, will likely have shorter pipes.</p><p>In contrast, common signal-processing algorithms often possess a significant degree of parallelism. DSP chip architecture, which is notably different from desktop or workstation architectures, reflects this difference. DSPs typically run at lower frequencies and exploit a higher degree of parallelism. Despite their lower clock rates, DSPs can achieve high MIPS ratings because of their parallelism and direct support for a multiply-accumulate operation, which occurs with considerable frequency in signal-processing algorithms. An example is the Analog Device 21160 SHARC DSP, which uses only 2 watts to achieve 600 Mflops on some DSP kernels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Operating system</head><p>The quadratic voltage term in Equation <ref type="formula" target="#formula_0">1</ref>shows that reducing voltage offers a significant power-savings benefit. It is not necessary for a processor to run constantly at maximum frequency to accomplish its work. If we know a computation's deadline, we can adjust the processor's frequency and reduce the supply voltage. For example, a simple MPEG decode runs at a fixed rate determined by the screen refresh, usually once every 1/30th of a second. Therefore, we can adjust the processor to run so that it does not finish its work ahead of schedule and waste power.</p><p>There are two approaches to scaling voltage using the operating system. The first approach provides an interface that allows the operating system to directly set the voltage-often simply by writing a register. The application uses these operating system functions to schedule its voltage needs. <ref type="bibr" target="#b7">8</ref> The second approach uses a similar interface, but the operating system automatically detects when to scale back the voltage during the application. An advantage of automatic detection is that applications do not require modifications to perform voltage scheduling. A disadvantage is that detecting the best timing for scaling back voltage is difficult, but important steps toward solving this problem are under way (see Kris Flautner's thesis at http://www.eecs.umich.edu/~tnm/theses/krisf.pdf).</p><p>Both approaches offer effective power-saving methods that work directly on the quadratic term in Equation <ref type="formula" target="#formula_0">1</ref>. Voltage scaling has already received support in Intel's next-generation StrongARM microprocessor, the XScale.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>WHAT CAN WE DO WITH A HIGH MIPS/W DEVICE?</head><p>The obvious applications for processors with a high MIPS/W lie in mobile computing. Futuristic third-generation mobile phones will require remarkable processing capabilities. These 3G phones will communicate over a packet-switched wireless link at up to 2 Mbits/sec. The link will support both voice and data and will be connected all the time. Vendors plan to support MPEG4 video transmission and other dataintensive applications.</p><p>In contrast, manufacturers build today's cell phones around two processors: a general-purpose computer and a DSP engine. Both processors require low power, the lower the better. A common solution uses an ARM processor for the general-purpose machine and a Texas Instruments DSP chip. For 3G systems, both processors will need to be more powerful without sacrificing battery life. Given the power constraints, the processing requirements exceed current technology.</p><p>One of the next major challenges for computer architects is designing systems in which power is a firstclass design constraint. Considering the hundreds of millions of cell phones in use today and the projected sales of billions more, mobile phones will surpass the desktop as the defining application environment for computing, further underlining the need to consider power early in the design process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An inelegant solution</head><p>The cell phone's two-processor configuration arose from the need for a low-power system that performs significant amounts of signal processing and possesses general-purpose functionality for low-resolution display support, simple database functions, and protocols for cell-to-phone communications. From an architectural perspective, this solution lacks elegance. A "convergent" architecture that handles both signalprocessing and general-purpose computing requirements offers a better alternative. However, it may be easier to manage the power to separate components so that users can easily turn off the power to either one. More research on such trade-offs is necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Applications where power is key</head><p>While the cell phone and its derivatives will become the leading users of power-efficient systems, this is by no means the only application where power is key. For example, a server farm has a workload of independent programs. Thus, it uses parallelism without the inefficiencies that intraprogram communication and synchronization often introduces-making multiprocessors an attractive solution.</p><p>A typical front-end server that handles mail, Web pages, and news has an Intel-compatible processor, 32 Mbytes of memory, and an 8-Gbyte disk, and requires Despite their lower clock rates, DSPs can achieve high MIPS ratings because of their parallelism and direct support for a multiply-accumulate operation.</p><p>about 30 watts of power. Assume that the processor is an AMD Mobile K6, with a total of 64 Kbytes of cache running at 400 MHz, and is rated at 12 watts. Compare this processor with the XScale, which has the same total cache size but consumes only 450 milliwatts at 600 MHz. The processor can actually run from about 1 GHz to less than 100 MHz; at 150 MHz, it consumes 40 milliwatts. Replacing the K6 with 24 XScales does not increase power consumption. To process as many jobs as the 24-headed multiprocessor, the K6 will require an architectural efficiency about 24 times that of an XScale. Some may disagree with this analysis. For example, it does not account for the more complex processor-memory interconnect that the multiprocessor requires, and it doesn't consider the fact that the individual jobs can have an unacceptable response time. However, the analysis shows that if power is the chief design constraint, a low-power, nontrivial processor like the XScale can introduce a new perspective into computer architecture. If we replaced the K6 with a 100-watt Compaq 21364, it would need to be 200 times as efficient as the XScale.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FUTURE CHALLENGES</head><p>It is remarkable how quickly some microprocessor manufacturers have already deployed some ideas for lowering power consumption: The XScale provides but one example.</p><p>However, if power consumption is to continue to be reduced, an important problem requires attention in the near term, that is, the leakage current. As devices shrink to submicron dimensions, the supply voltage must be reduced to avoid damaging electric fields. This development, in turn, requires a reduced threshold voltage. In Equation <ref type="formula" target="#formula_2">3</ref>, leakage current increased exponentially with a decrease in V threshold. In fact, a 10 percent to 15 percent reduction can cause a two-fold increase in I leak. In increasingly smaller devices, leakage will become the dominant source of power consumption. Further, leakage occurs as long as power flows through the circuit. This constant current can produce an increase in the chip temperature, which in turn causes an increase in the thermal voltage, leading to a further increase in leakage current. In some cases, this vicious circle results in unconstrained thermal runaway.</p><p>Because they are keenly aware of this pitfall, circuit designers have proposed several techniques to handle it. The present popular solution employs two types of field-effect transistors: low V threshold devices for the highspeed paths and high V threshold devices for paths that are not critical, as addressed in Equation <ref type="formula">2</ref>. Such voltage clustering <ref type="bibr" target="#b9">9</ref> makes additional demands on computeraided design tools. Future circuits must operate properly with several supply-voltage levels and thresholds.</p><p>At the architectural level, some techniques for controlling dynamic power will also help to reduce leakage effects. In many cases, components that were shielded from unnecessary activity, such as static random-access memory, are also candidates for implementation with lower-power-threshold devices and can tolerate the performance hit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A</head><p>lthough the contributions of process engineers and circuit designers to power-aware designs are crucial, architects and systems-level designers also need to contribute a twofold improvement in power consumption per design generation.</p><p>Elevating power to a first-class constraint must be a priority early in the design stage when designers make architectural trade-offs as they perform cycleaccurate simulation. This presents a problem because designers can make accurate power determination only after they perform chip layout. However, designers can usually accept approximate values early in the design flow, provided they accurately reflect trends. For example, if the architecture changes, the approximate power figure should reflect a change in power in the correct direction.</p><p>Several research efforts are under way to insert power estimators into cycle-level simulators. Event counters obtain frequency measures for architectural components such as adders, caches, decoders, and buses to estimate power. Researchers at Intel, <ref type="bibr" target="#b10">10</ref> Princeton, <ref type="bibr" target="#b11">11</ref>  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 . Compaq Alpha power trends. Alpha model Peak power (W) Frequency (MHz) Die size (mm 2 ) Supply voltage</head><label>1</label><figDesc></figDesc><table><row><cell>21064</cell><cell>30</cell><cell>200</cell><cell>234</cell><cell>3.3</cell></row><row><cell>21164</cell><cell>50</cell><cell>300</cell><cell>299</cell><cell>3.3</cell></row><row><cell>21264</cell><cell>72</cell><cell>667</cell><cell>302</cell><cell>2.0</cell></row><row><cell>21364</cell><cell>100</cell><cell>1,000</cell><cell>350</cell><cell>1.5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Computer Society members work together to define standards like IEEE 1003, 1394, 802, 1284, and many more.</head><label></label><figDesc>and Penn State University 12 have developed power estimators based on the SimpleScalar simulator widely used in academe (see http://www. simplescalar.org). A fourth effort, PowerAnalyzer, which I am developing with Todd Austin and Dirk Grunwald, is expanding on previous work to provide estimates for multiple thresholds, di/dt noise, and peak power (see http://www.eecs. umich.edu/~tnm/power/ power.html). ? Trevor Mudge is a professor in the Department of Computer Science and Electrical Engineering at the University of Michigan, Ann Arbor. His research interests include computer architecture, very large scale integration design, and compilers. Mudge received a PhD in computer science from the University of Illinois at Urbana-Champaign. Contact him at tnm@eecs. umich.edu.HELP SHAPE FUTURE TECHNOLOGIES ? JOIN A COMPUTER SOCIETY STANDARDS WORKING GROUP AT</figDesc><table><row><cell>SET INDUSTRY</cell><cell cols="2">Posi x gigabit Ethernet enhanced parallel ports</cell></row><row><cell>STANDARDS</cell><cell>wireless networks</cell><cell>FireWire token rings</cell></row><row><cell cols="3">computer.org/standards/</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgment</head><p>This work was supported, in part, by contract <rs type="grantNumber">F33615-00-C-1678</rs> from the <rs type="programName">Power Aware Computing and Communications program</rs> at <rs type="funder">DARPA</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_S4KfwMA">
					<idno type="grant-number">F33615-00-C-1678</idno>
					<orgName type="program" subtype="full">Power Aware Computing and Communications program</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Energy Dissipation in General-Purpose Microprocessors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Solid-State Circuits</title>
		<imprint>
			<biblScope unit="page" from="1277" to="1284" />
			<date type="published" when="1996">1996</date>
			<publisher>IEEE Press</publisher>
			<pubPlace>Piscataway, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Self-Calibrating Clocks for Globally Asynchronous Locally Synchronous Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Computer Design</title>
		<title level="s">Los Alamitos</title>
		<meeting>Int&apos;l Conf. Computer Design</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="73" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Pipeline Gating: Speculation Control for Energy Reduction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Manne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grunwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 25th Int&apos;l Symp. Computer Architecture</title>
		<meeting>25th Int&apos;l Symp. Computer Architecture<address><addrLine>Piscataway, N.J.</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="132" to="141" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Filtering Memory References to Increase Energy Efficiency</title>
		<author>
			<persName><forename type="first">M</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Mangione-Smith</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>IEEE Trans. Computers, IEEE CS Press</publisher>
			<biblScope unit="page" from="1" to="15" />
			<pubPlace>Los Alamitos, Calif</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Address Bus Encoding Techniques for System-Level Power Optimization</title>
		<author>
			<persName><forename type="first">L</forename><surname>Benini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1998 Design Automation and Test in Europe (DATE 98)</title>
		<meeting>1998 Design Automation and Test in Europe (DATE 98)<address><addrLine>Los Alamitos, Calif</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="861" to="866" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Modifying VM Hardware to Reduce Address Pin Requirements</title>
		<author>
			<persName><forename type="first">A</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Farrens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tyson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 25th Int&apos;l Symp. Computer Architecture</title>
		<meeting>25th Int&apos;l Symp. Computer Architecture</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reducing Code Size with Run-Time Decompression</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lefurgy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Piccininni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mudge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Int&apos;l Symp</title>
		<meeting>6th Int&apos;l Symp<address><addrLine>Los Alamitos, Calif</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="218" to="227" />
		</imprint>
	</monogr>
	<note>High-Performance Computer Architecture</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Voltage Scheduling in the lpARM Microprocessor System</title>
		<author>
			<persName><forename type="first">T</forename><surname>Pering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Burd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brodersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Low Power Electronics and Design</title>
		<author>
			<persName><forename type="first">'</forename><surname>Int</surname></persName>
		</author>
		<author>
			<persName><surname>Symp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>IEEE CS Press</publisher>
			<biblScope unit="page" from="96" to="101" />
			<pubPlace>Los Alamitos, Calif</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Clustered Voltage Scaling Technique for Low-Power Design</title>
		<author>
			<persName><forename type="first">K</forename><surname>Usami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int&apos;l Symp. Low-Power Design</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="3" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Architectural Level Power/Performance Optimization and Dynamic Power Estimation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lim</surname></persName>
		</author>
		<ptr target="http://www.eecs.umich.edu/~tnm/cool.html" />
		<editor>T. Mudge, S. Manne, and D. Grunwald</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>IEEE CS Press</publisher>
			<biblScope unit="page" from="90" to="113" />
			<pubPlace>Los Alamitos, Calif</pubPlace>
		</imprint>
	</monogr>
	<note>Cool Chips Tutorial: An Industrial Perspective on Low-Power Processor Design</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Wattch: A Framework for Architectural-Level Power Analysis and Optimizations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th Int&apos;l Symp. Computer Architecture</title>
		<meeting>27th Int&apos;l Symp. Computer Architecture<address><addrLine>Piscataway, N.J.</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="83" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Energy-Driven Integrated Hardware-Software Optimizations Using SimplePower</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vijaykrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th Int&apos;l Symp. Computer Architecture</title>
		<meeting>27th Int&apos;l Symp. Computer Architecture<address><addrLine>Piscataway, N.J.</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="95" to="106" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
