<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Bill Curtis, Mar(: I. Kellner and Jim Over Process Modeling raditionally, the modeling of information systems has focused on analyzing data flows and transformations. This modeling accounted only for the organization&apos;s data and that portion of its processes that interacted with data. Newer uses of information technology extend computer use beyond transaction processing into communication and coordination. Successfully integrating these systems into the enterprise often requires modeling even the manual organizational processes into which these systems intervene. The following are three such applications: • • • • • • • • ® • • • •</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="1992-09">September 1992</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<title level="a" type="main">Bill Curtis, Mar(: I. Kellner and Jim Over Process Modeling raditionally, the modeling of information systems has focused on analyzing data flows and transformations. This modeling accounted only for the organization&apos;s data and that portion of its processes that interacted with data. Newer uses of information technology extend computer use beyond transaction processing into communication and coordination. Successfully integrating these systems into the enterprise often requires modeling even the manual organizational processes into which these systems intervene. The following are three such applications: • • • • • • • • ® • • • •</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="1992-09">September 1992</date>
						</imprint>
					</monogr>
					<idno type="MD5">71D4061FB7D4A9F9BF261990B49E27C2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract xml:lang="pt">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Vo1.35, No.9/COMMUNICATIONS OF THE ACM</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>• Business process reengineering--the redesign of an organization's business processes to make them more efficient.</p><p>• Coordination technology--an aid to managing dependencies among the agents within a business process, and provides automated support for the most routinized component processes. * Process-driven software development environments--an automated system for integrating the work of all software-related management and staff; it provides embedded support for an orderly and defined software development process.</p><p>These three applications share a growing requirement to represent the processes through which work is accomplished. To the extent that automation is involved, process representation becomes a vital issue in redesigning work and allocating responsibilities between humans and computers. This requirement reflects the growing use of distributed, networked systems to link the interacting agents responsible for executing a business process.</p><p>To establish process modeling as a unique area, researchers must identify conceptual boundaries that distinguish their work from modeling in other areas of information science. Process modeling is distinguished from other types of modeling in computer science because many of the phenomena modeled must be enacted by a human rather than a machine. At least some modeling, however, in the area of human-machine system integration or information systems design has this 'human-executable' attribute. Rather than focusing solely on the user's behavior at the interface or the flow and transformation of data within the system, process modeling also focuses on interacting behaviors among agents, regardless of whether a computer is involved in the transactions.</p><p>Much of the research on process modeling has been conducted on software development organizations, since the software engineering community is already accustomed to formal modeling. Software process modeling, in particular, explicitly focuses on phenomena that occur during software creation and evolution, a domain different from that usually modeled in human-machine integration or information systems design. Software development is a challenging focus for process modeling because of the creative problemsolving involved in requirements analysis and design, and the coordination of team interactions during the development of a complex intellectual artifact. In this article, software process modeling will be used as an example application for describing the current status of process modeling, issues for practical use, and the research questions that remain ahead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Uses for Process Models</head><p>Most software organizations possess several yards of software life cycle description, enough to wrap endlessly around the walls of project rooms. Often these descriptions do not correspond to the processes actually performed during software development or maintenance; rather, they typically represent high-level plans and do not contain the type of how-to information that would be found in a project implementation handbook. This lack of fidelity between actual behavior and the organization's stated process is caused by such factors as:</p><p>• high-level prescriptive processes that are unrelated to actual project activities, • imprecise, ambiguous, incomprehensible, or unusable descriptions of processes to be performed on the project, and • failure to update the documentation as processes change.</p><p>These large-grained life-cycle descriptions depict different phases abstractly and some may describe the point at which different functional groups will become involved in the project. Traditionally, these representations have been considered process models. However, the software process modeling community has not been satisfied with using existing life-cycle descriptions as process models, because the granularity of the process steps included is too large. These life-cycle descriptions usually focus abstractly on product engineering and fail to show many elemental process building blocks necessary for man-aging and coordinating the project. For instance, traditional life-cycle descriptions might show phaseending reviews, but not the myriad within-phase reviews that are necessary for developing a quality product. Further, life-cycle descriptions are most often treated as linear sequences, where crucial attributes of the process such as feedback loops and iteration are not represented <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b6">7]</ref>.</p><p>Research on software process modeling supports a wide range of objectives <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b33">33]</ref>. Five basic uses for process models, ranging from understanding aids to automated execution support, are presented in Table <ref type="table" target="#tab_0">1</ref>. These categories are:</p><p>Facilitate human understanding and communication requires that a group be able to share a common representational format Support process improvement requires a basis for defining and analyzing processes Support process management requires a defined process against which actual project behaviors can be compared</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Automate process guidance requires automated tools for manipulating process descriptions</head><p>Automate execution support requires a computational basis for controlling behavior within an automated environment.</p><p>The issues raised by these objectives range from comprehensibility to enactability. Before discussing these issues we need to establish a conceptual framework for process modeling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conceptual FrameworR</head><p>A model is an abstract representation of reality that excludes much of the world's infinite detail. The purpose of a model is to reduce the complexity of understanding or interacting with a phenomenon by eliminating the detail that does not influence its relevant behavior. Therefore, a model reveals what its creator believes is important in understanding or predicting the phenomena modeled. Selecting bounds for the phenomena to be modeled depends on the uses to which the model will be put.</p><p>Humphrey and Feiler <ref type="bibr" target="#b13">[14]</ref> have presented a foundational lexicon on which to build a conceptual framework for software process modeling and definition. They define a process as "a set of partially ordered steps intended to reach a goal." Any component of a process is a process element. A process step is "an atomic action of a process that has no externally visible substructure." Determining that a process element is a process step depends in part on whether any further decomposition of the element's structure is needed to support the objectives of the process model. In ordinary usage a task is often synonymous with a process and an activity is synonymous with a process element or step. We will, however, avoid these terms for the sake of clarity.</p><p>Although there is not widespread consensus on the constructs that collectively form the essential basis of a process model, the following list includes many of those most frequently mentioned (abstracted from <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b35">35]</ref>).</p><p>Agent--an actor (human or machine) who performs a process element.</p><p>Role--a coherent set of process elements to be assigned to an agent as a unit of functional responsibility.</p><p>Artifact--a product created or modified by the enactment of a process element.</p><p>A single agent can perform multiple roles (e.g., designer, reviewer, coder), and a single role (coder) may be performed by multiple agents. A process can now be further elaborated as one or more agents acting in defined roles to enact the process steps that collectively accomplish the goals for which the process was designed. Typically, process steps either manipulate an artifact or coordinate dependencies with other agents involved in the same or a related process. Consequently, process steps should be planned as part of a defined process, assigned to a role, allocated resources, and monitored.</p><p>A process model is an abstract description of an actual or proposed process that represents selected process elements that are considered important to the purpose of the model and can be enacted by a human or machine. The levels of abstraction within the domain of software development range from the detailed process steps executed entirely on a machine, to the larger-grained human processes involved in executing a life-cycle phase, to the abstract stages of the life-cycle chosen for the product. Defined or not, the collection of all the process steps executed to develop a software system constitutes a software development process. These processes, however, do not constitute a software process model until they are represented in some medium. A process model to be performed by a human will be called a process script, while one to be enacted by a machine will be called a process program <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b30">30]</ref>.</p><p>Most life-cycle descriptions represent an extremely abstract model of software development and do not provide clear guidance on how to integrate the many process steps that project staff perform. One of the objectives of software process modeling is to decompose these descriptions into sufficient detail so that they can provide more explicit guidance for executing a software development project. Since many projects are managed as loose collections of process elements that constitute different tasks (an unintegrated set of process fragments), projects might be made more efficient if the process elements and steps underlying different processes could be integrated into an efficient structure for executing the desired software development process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>articles</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Perspectives in Process Representation</head><p>Many forms of information must be integrated to adequately describe software processes. Among the forms of information that people ordinarily want to extract from a process model are what is going to be done, who is going to do it, when and where will it be done, how and why will it be done, and who is dependent on its being done. Processmodeling languages differ in the extent to which their constructs highlight the information that answers these different questions. Process-modeling languages and representations usually present one or more different perspectives related to these questions. Four of the most commonly represented perspectives are:</p><p>Functional represents what process elements are being performed, and what flows of informational entities (e.g., data, artifacts, products), are relevant to these process elements.</p><p>Behavioral represents when process elements are performed (e.g., sequencing), as well as aspects of how they are performed through feedback loops, iteration, complex decision-making conditions, entry and exit criteria, and so forth.</p><p>Organizational represents where and by whom (which agents) in the organization process elements are performed, the physical communication mechanisms used for transfer of entities, and the physical media and locations used for storing entities.</p><p>Informational represents the informational entities produced or manipulated by a process; these entities include data, artifacts, products (intermediate and end), and objects; this perspective includes both the structure of informational entities and the relationships among them.</p><p>These perspectives underlie separate yet interrelated representations for analyzing and presenting process information (Figure <ref type="figure">I</ref>). They are analogous to different vantage points from which one may view an observable process. We can hypothesize that when combined, these perspectives will produce an integrated, consistent, and complete model of the process analyzed. This hypothesis, however, needs verification through experimental process modeling. Integration and consistency may be easier to demonstrate, since completeness is relative to the application. Completeness depends on whether all important components of information remain after less crucial details have been abstracted away by the modeling technique, and on whether the intended uses of the model are enabled by the perspectives offered.</p><p>In practice, most process de-scriptions have employed narrative text and simple diagrams to express process, with the text often structured in a uniform way (e.g., inputs, outputs, activity description). Many conventional uses of process models have posed few requirements on the formal properties of the representation, since their use was more for communication than for analysis. The perspectives that a process model is able to present are bounded by the constructs of the language (textual or graphic) used for modeling. When semantic and syntactic constraints are loosely applied to a representation, however, it is easier for modelers to interleave many perspectives in a process description. Unfortunately, it is difficult to analyze the properties of these perspectives when the representation has not been formally constrained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Process Modeling Paradigms</head><p>Process-modeling languages and representations can be evaluated by the extent to which they provide constructs useful for representing and reasoning about the various aspects of a process. Since software specification and programming languages provide a means for representing, reasoning about, and enacting a computational process,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1. Concept of process perspectives</head><p>most researchers have started from this language base in modeling software processes. They often begin by proposing language structures and formalisms for modeling. Osterweil <ref type="bibr" target="#b30">[30]</ref> has pointed out a chicken-and-egg problem in exploring representations suited to software process modeling. "In order to find out what language features we need, we need to write process programs; in order to write process programs, we need the appropriate language features." Most language classes used by the software community have been tried as a basis for modeling soft-ware processes, and dozens of modeling languages derived from them have been proposed in the past several years. Table <ref type="table">2</ref> identifies the language types and constructs supported by several of the processmodeling languages being explored in the research community. Table <ref type="table">2</ref> is not intended to be complete, merely illustrative of the variety of language types being studied. Table <ref type="table" target="#tab_2">3</ref> summarizes how these language types and constructs support the four perspectives discussed in the preceding section. Comparing the profiles between these two tables provides a summary analysis of There have been several efforts to gain experience in developing and analyzing models of actual software processes <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b34">34]</ref>. Feedback between language development and application experience is necessary to successfully evolve software process-modeling techniques. Such experiments are crucial to support experience-based language design.</p><p>In order to summarize the breadth of process-modeling research, five approaches to representing process information will be reviewed. These techniques do not cover the full range of modeling techniques developed, hut they do provide an overview of some of the most extensively explored approaches. These five approaches to modeling, each described through an example technique, are:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Programming models--process programming</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functional models--HFSP Plan-based models--GRAPPLE Petri-net models--role interaction nets</head><p>Quantitative models--system dynamics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Programming Models</head><p>In stating the case for process programming, Osterweil <ref type="bibr" target="#b30">[30]</ref> argues that "software processes are software, too." That is, since specifying a process is a form of programming, processes can be modeled with all the tools and techniques of the programmer's trade. The resulting programs are bound to humans as well as machines. Osterweil maintains that people develop process descriptions to solve problems. These descriptions can be modeled as algorithms and can be analyzed accordingly. Osterweil and his colleagues developed APPL/A <ref type="bibr" target="#b36">[36]</ref> for constructing process programs that can he enacted by a machine: APPL/A <ref type="bibr" target="#b36">[36]</ref> and p4 <ref type="bibr" target="#b9">[10]</ref>.</p><p>The Ada Process Programruing Language based on Aspen (APPL/A) allows processes to be modeled in an extension of Ada that enables explicit representation of programmable, persistent relations. Aspen is a data model for software engineering that incorporates relations over software objects in an entity-relationship form. APPL/A adds triggers that can propagate updates across relations and provide other functions among them. Predicates have been added that express conditions on the state of relations and therefore can represent constraints. Process programming has often been unfairly characterized as a purely procedural approach. Since it provides both procedural and declarative capabilities, APPL/A supports multiple representational paradigms, an approach to process modeling that will be discussed in a later section.</p><p>Sutton et al.</p><p>[37] have used APPL/A to implement a tool--REBUS--that supports the process  <ref type="bibr" target="#b19">[20]</ref> AP5 [40], GRAPPLE <ref type="bibr" target="#b11">[12]</ref>, MARVEL <ref type="bibr" target="#b16">[17]</ref>, MVP <ref type="bibr" target="#b34">[34]</ref> AP5 [40], APPL/A <ref type="bibr" target="#b36">[36]</ref>, STATEMATE <ref type="bibr" target="#b19">[20]</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>State transition and petri-nets Role Interaction Nets [35], STATEMATE [20]</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Control flow MVP [34]</head><p>Functional languages Formal languages</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HFSP [38]</head><p>Context-Free Grammar</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data modeling 3 APPL/A [36], PMDB [32[, STATEMATE [201</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Object modeling 4 AP5 [40], MARVEL [17], MVP [34]</head><p>Precedence networks 5</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SPMS [this issue]</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Quantitative modeling System Dynamics [1]</head><p>1--including DFD, SADT, structure charts 2--including ru~es pre-/post-conditions 3--including E/R, relations, structured data declarations 4--including class types and instances, hierarchy, inheritance 5--including PERT and critica~ path method (CPM) Ilrticles of developing requirements. REBUS helps analysts manage the process of mutually developing the data structures in which to express the statement of requirements. Experience with REBUS indicated that process programming could successfully automate some of the routine aspects of controlling interaction in the shared requirements workspace that otherwise burdened the analysts with unnecessary process steps. The formality enforced in REBUS emanated from the formal structure of the requirements document, rather than from the structure of the process. Thus, while individual methods for performing activities and tasks were not controlled, the emerging structure of the artifact and the group interaction process for producing it were controlled. Although smallgrained concurrency control was provided, a need surfaced for a larger-grained version that was not supported in APPL/A. The modeling performed with languages such as APPL/A is very procedural, and leads to control models that would underlie a conventional software development environment. Even initial prototypes, such as REBUS, quickly surface the need for capabilities that will be crucial in scaling up automated process models to support process-based environments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functional Models</head><p>The Hierarchical and Functional Software Process (HFSP) description and enaction language was developed at the Tokyo Institute of Technology by Katayama and his colleagues <ref type="bibr">[38]</ref>. The key goals of HFSP are to:</p><p>• aid process understanding • support hierarchical process decomposition • describe concurrent processes and backtracking • provide a flexible and dynamic execution mechanism HFSP is primarily a declarative, textual language; but execution traces can be illustrated diagrammatically. In HFSP, a process is represented as a collection of process elements with input and output attributes. Specifically, a process is defined as a set of mathematical functions depicting relationships among inputs (such as specifications) and outputs (such as source codes). Furthermore, each of these functions is hierarchically decomposable into process subelements, where the input and output attributes of a parent process element must be satisfied by its children's attributes. This decomposition is continued until it produces process steps that can be mapped to external tool invocation or manual operations.</p><p>In general, process elements can execute concurrently, limited only by availability of input attributes. However, additional features have been incorporated into HFSP to represent special ordering information such as sequencing, iteration, and synchronization. In addition, metaoperators have been added to permit inclusion of dynamic control of behavior, such as creating, destroying, suspending, or resuming process elements, and communicating among them. Finally, a process enaction mechanism would be responsible for activity-scheduling (based on such items as resource constraints, activity execution management, tool invocation, object base access, and user interaction).</p><p>HFSP is primarily oriented toward the functional and behavioral perspectives, with some support for the informational perspective. In applying HSFP to an industrial process, Katayama and Motizuki <ref type="bibr" target="#b18">[19]</ref> report that the organizational perspective was difficult to model because of the extent to which it was poorly documented, and often was driven by political rather than technical factors. They decided not to model transient artifacts created within the process but not permanently stored. They found that in practice they halted their process decomposition short of reaching process steps because of substantial variations in the way different agents performed their duties.</p><p>arel¢les They found it difficult to identify a priori the communication points between concurrent processes. They found that allowing a process element to execute when its input was available was an advantage in expediting progress among interacting agents, rather than requiring that all components of a decomposed artifact be available before enabling performance of the next process element. Finally, they observed a requirement for a metalevel process to control (manage) the execution of other processes. Katayama and Motizuki concluded that in trying to model actual processes, they might discover new processing concepts for computer science.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Plan-Based Models</head><p>Huff and Lesser argue that modeling process execution in the real world is difficult because of all the contingencies that must be considered <ref type="bibr" target="#b11">[12]</ref>. This contingency management poses particular problems for procedural languages because the rationale underlying the design of the process has been removed from the procedural representation. The rationale is, therefore, unavailable for reasoning about enaction choices based on existing conditions within the current state of a process's execution. They propose that these problems can be more effectively handled in the planning paradigm that has emerged from artificial intelligence research. This paradigm provides mechanisms whereby operators representing possible actions are selected based on the satisfaction of their preconditions. These operators are applied to the current state of the domain in which the process operates, in order to move that state closer to the desired goal.</p><p>Huff and Lesser created a constraint-based language called GRAPPLE that models software development as a set of goals, subgoals, preconditions, constraints, and effects. GRAPPLE constructs process models from two fundamental components: a set of pro-cess steps and a set of constraints on how those steps can be selected, ordered, and applied. The ability of a constraint-based planning system like GRAPPLE for developing effective process plans depends on the success of its designer in coding knowledge about the environment and the goal hierarchies of the process into the components of GRAPPLE. Huff and Lesser provide a high-level example for representing a system release: Operator: release Goal: current-release (system) Preconditions: built(system) regression-tested (system) performance-tested (system) Constraints:</p><p>current-release(C) not-equal(C,system) Effects:</p><p>DELETE currentrelease(C) ADD currentrelease (system) ADD customerrelease (system) ADD prior-release (system,C) In this example, the computational agent will seek to satisfy the goal of making 'system' the current release when a set of preconditions have been satisfied without violating the stated constraints. In contrast to procedural approaches GRAPPLE produces process plans dynamically by comparing conditions in the current state of the environment with the preconditions of the operators available for acting on it. Plan execution can be simulated to reason about the viability of selecting a particular path for the plan. The status of satisfying different goals in the goal hierarchy is tracked as a means of guiding operator selection.</p><p>Experiences with GRAPPLE revealed that the most interesting process models resulted when the artifact operated on by the process had been represented in a way that revealed internal structure, current attributes, and external dependencies. These descriptive attributes of the artifact provided a rich source of constraints for guiding the selection of operators. Huff and Lesser also identified a need to integrate multiple sources of knowledge representation and an analysis capability for deriving the properties of processes.</p><p>Petri-Net Models One view of a project that is orthogonal to the perspective portrayed by most programming languagebased models is provided by its structure of roles and their interaction. Most of the recent activity with this approach was motivated by Anatole Holt's work in applying Petri nets to modeling coordination in the workplace <ref type="bibr" target="#b10">[11]</ref>. This work has been carried on in projects at MCC <ref type="bibr" target="#b35">[35]</ref>, and at Praxis Systems <ref type="bibr" target="#b31">[31]</ref>. This technique models the role interaction structure of a project using a Petri-net-based representation and language.</p><p>The technique employed at MCC was derived from a Petri-net-based language called RADDLE developed by Ira Forman for use in modeling high-level designs for a distributed system. Extensive modifications, however, had to be made to the formalism to provide the flexibility needed for the system to be used in aiding human coordination. For instance, the tight concurrency control enforced in computing systems often must be relaxed (but in systematic ways) when humans are the agents of execution. Extensive modeling of industrial software processes resulted in additions to the model for scalability. The Petri-net-based role interaction model has now been used in a commercial product.</p><p>Role interaction nets are designed to aid the representation and execution of structured tasks. Structured tasks are those that can be planned from known dependencies. One possible process for conducting a technical review is modeled in role interaction nets in Figure <ref type="figure" target="#fig_2">2</ref> (the figure has been simplified to remove the representation of iteration). Role interaction el F C; :: ,~ : :Z ,,'Z S; nets are strong in representing roles, dependencies, and process elements. Its representation of artifacts, however, is weak.</p><p>When a process has been represented in role interaction nets, a new notion of teams emerges, built on dependencies among roles, rather than on reporting relationships. Where interactions among roles are frequent, a clustering of roles forms a de facto team. A process plan can be designed as a decomposition of tasks, roles, and interactions. A project plan is established when roles are assigned to individuals. One individual may hold many roles and a type of role may be assigned to several individuals.</p><p>Having instantiated a project plan, role interaction nets can be used as a method of coordinating the routing of artifacts among interacting roles and as a method of tracking progress by the completion of interactions among :roles. That is, this formalism can be used as an underpinning for coordinating activities in a process-driven environment. However, technology transfer experience suggests that this model of coordination among role structures is difficult to use if an organization has not been able to establish a basic description of their process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Quantitative Models</head><p>One of the few modeling techniques that involves quantitative representation is system dynamics, which applies feedback and control system techniques to social and industrial phenomena. Models built using system dynamics techniques attempt to define a set of quantitative relationships among variables of interest that simulate the observed behavior of social systems.</p><p>Abdel-Hamid and Madnick have used this technique to provide a quantitative representation of many behavioral observations of software projects <ref type="bibr" target="#b0">[1]</ref>. One of their primary objectives has been to demonstrate why managers chronically underestimate the resources required for a software project. A primary problem in estimating the schedule and resources needed for a project is that feedback loops allow a complex, dynamic system to compensate for changes at any node in the system. For instance, if management relaxes the schedule constraints on a project, then hiring is slowed, productivity drops because of greater perceived schedule slack, and the project falls into the same schedule slippage problem. When these interacting factors are modeled, their effects on successive cycles can be simulated. The simulated behavior presents one possible model of the 90%-complete syndrome that plagues projects.</p><p>An example of a typical equation that might appear in such a model is a simulation of how a manager measures progress based on the stage of the project. During the early stages of a project, managers frequently measure progress by the percent of total project effort that has been expended to date. At the latter stages, managers measure progress by the actual percent of work that has been accomplished, such as the number of modules that have successfully passed the integration test phase, or the number of problem reports closed. Thus, the perceived work accomplished was modeled as: PWA = [VF * (% resources consumed)] + [(1 -VF) * (actual % work finished)] where, PWA = perceived % of work accomplished; VF -= visibility factor, and 0-&lt; VF-&lt; 1; where VF ~-1 at project start VF = 0 at project end When a set of equations such as this interact, they produce dynamic behavior that is difficult to reproduce through modeling techniques that do not provide dynamic feedback loops. The value of these models is very much tied to the closeness with which their constructs and parameters represent actual states observed on real projects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Issues in Process Modeling Formality</head><p>A primary issue in the research agenda involves the level of mathematical formality needed in process-modeling languages. Scaling on this dimension represents a language's level of formal precision in representing the process. A formally precise language is enactable on a machine. The level of formality required may depend on the purpose served by the process model and the agent responsible for enacting the specified processes. That is, process programs enacted by a machine must be quite formal, whereas process scripts performed by humans may require less formality.</p><p>The strong position on formality has been taken by Osterweil in describing process programming <ref type="bibr" target="#b30">[30]</ref>. However, Lehman <ref type="bibr" target="#b24">[25]</ref> and Curtis et al. <ref type="bibr" target="#b6">[7]</ref> maintain that computer programming is too deterministic a paradigm for processes to be enacted by humans. This problem has motivated the distinction between process programs and process scripts. They argue that while computers have precise execution semantics, humans do not. Osterweil indicates that many software development processes are only partially automated, involving interaction between human and computer agents. Although some languages (e.g., systems analysis and design languages) have been used to depict both automated and manual processes, many extensions of existing programming languages have only been applied to those process components being automated.</p><p>Flexibility in representing manual tasks performed by humans is a fundamental requirement for developing process scripts <ref type="bibr" target="#b9">[10]</ref>. Humans exhibit far more variability than computers in executing a defined process. Nevertheless, they are able to enact ambiguous process descriptions because they can fill in gaps in these descriptions before enacting them. Expressiveness and comprehensibility are more crucial for humans, since they exhibit less precision in parsing process instructions. Experience shows that even those using formal specification languages often have run their specifications back through a translator to produce a natural language version that was more understandable <ref type="bibr" target="#b1">[2]</ref>.</p><p>Unfortunately, interest in facilitating human understanding and communication has received less attention from the research community than has machine enaction. Process models and definitions cannot be used if they cannot be understood. The large number of potential process model users, such as software process engineers, project managers, software engineers, system engineers, software executives, and customer management makes it difficult to establish a universally understood representation format. Due to their individual information needs and expertise, these groups place widely diverging demands on a modeling approach. Visual representations, abstraction, and multiple perspectives offer promising techniques for coping with these challenges. Even so, Curtis, Krasner, and Iscoe found that a homogeneous group could spend six months developing a common understanding of the semantics of a representation format <ref type="bibr" target="#b5">[6]</ref>.</p><p>A process-modeling language should permit evaluation of the adequacy of a proposed process. The model should be analyzable for such properties as syntactic correctness, consistency, completeness, correctness, risks, and opportunities for improvement, among others. Most formalisms and tools typically provide the first few types of analysis, since they emerge from the formal properties of the representation. However, a representation's formal properties can support more advanced analyses such as reachability of various process states, detection of deadlocks, and race conditions in the process, detection of behavioral ambiguities <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b22">23]</ref>. These analyses are provided by some state-transition and Petri-net-based approaches. Kellner and Hansen observed that while it is generally not feasible to guarantee such factors as the correctness or completeness of a model, it is possible to search for anomalies within the processes bounded by the model <ref type="bibr" target="#b22">[23]</ref>. However, if no anomalies are found, an important degree of assurance has been provided that the process being modeled is internally sound. executing agent already possesses of the contents and sequencing of process steps, the larger the grain of the process step that can be used in a process model. That is, with greater process knowledge, largergrained modeling units can be used to invoke sequences of process steps when the model is enacted by an agent.</p><p>In many domains, descriptions</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Review Review</head><p>Team Team The external validity of a process model must be determined by the value of its use and the degree of fidelity it offers in depicting relevant phenomena in the real world.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Designer</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Granularity and Precision</head><p>The granularity issue involves the size of the process elements represented in the model. The pressure for greater granularity is driven by the need to ensure process precision-the degree to which a defined process specifies all the process steps needed to produce accurate results <ref type="bibr" target="#b13">[14]</ref>. The granularity of a process step needed to ensure process precision will depend on the purpose of the model and attributes of the agent that must execute the process. The more extensive the understanding or representation the for process scripts are presented to humans at too high a level of abstraction (large-grained) and they do not provide sufficient detail for guiding actual execution. Consequently, human agents are expected to have sufficient knowledge to translate these imprecise scripts into actions by filling in detailed process steps that are appropriate to current conditions. If the human agent already knows many relevant potential scripts, a large-grained process model may be desirable in order to allow the agent to tailor the final detailed process script enacted. This flexibility may be especially desirable when there are complicated decision rules for selecting and integrating the processes to be performed. If human agents do not possess sufficient process knowledge, it may be desirable to model finer-grained process steps with approaches that represent ahernative steps and sequences and can encode guidance in how to choose among them. Current experience suggests that automated processes require a small-grained representation, while process scripts to be executed by humans can be represented in models with larger units than those used in process programs. Still, the granularity of these models is much smaller than those constituting most life-cycle descriptions. Programming-language-based approaches to modeling have largely been used to represent smallgrained models that supported specific forms of process enactment on a machine, Techniques derived from design languages, especially those with strong visual representations, are often used for largergrained process models. Not surprisingly, this observation coincides with the level of abstraction normally associated with the use of these languages in software engineering. Ultimately, process models must support multiple levels of abstraction to serve the various needs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scriptiveness and Fitness</head><p>Process modelers have differed on how prescriptive they intend their models to be of the actual behaviors to be performed. Prescriptive modeling implies the process should be performed a particular way. Much of the process-modeling research presupposes the existence of a prescriptive process in a process modeler's mind, that is then translated into a modeling formalism. Prescriptive models must be analyzed for their processfitness--the degree to which the agents performing the process can faithfully follow the process steps it specifies <ref type="bibr" target="#b13">[14]</ref>. When prescriptive process models violate the reasonable exercise of human or machine capabilities, process fitness is low.</p><p>The prescriptive approach to process modeling can be at odds with the concept of process improvement based on continuous evolution when the prescribed process is difficult to perform (i.e., when process fitness is low <ref type="bibr" target="#b13">[14]</ref>). The evolutionary approach begins with an understanding of the current process used in an organization. Descriptive modeling attempts to determine the actual processes currently used in an organization to get work done, an organization's process baseline. Improvements are made as changes to the established process baseline, since these are likely to be the most successfully absorbed by an organization. Managed improvement is also based on measurements of actual performance that are related to the processes actually performed (a descriptive model), which may differ from those planned (a prescriptive model). More work is needed on methods for capturing descriptive process information, on integrating measurement with process representations, and on analyzing descriptive models for those points at which process changes can be most successfully inserted in an evolutionary way.</p><p>A third perspective is offered by proscriptive models, which delineate behavior that is not allowed. Lawgoverned modeling takes this approach <ref type="bibr" target="#b29">[29]</ref>, and is used for exercising control over the allowable steps that can be taken in a process. For instance, constraint-based modeling techniques such as embodied in AP5, GRAPPLE <ref type="bibr" target="#b11">[12]</ref>, and MAR-VEL <ref type="bibr" target="#b17">[18]</ref> allow the modeler to indicate constraints that cannot be violated by the execution of a process. A proscriptive model might indicate that a modified module cannot resume its former status in the configuration management system until it has been regression-tested. Proscriptive modeling will most often be used as an adjunct to prescriptive or descriptive modeling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Future Directions: Field Growth</head><p>In order to accelerate the growth of process modeling, seven International Software Process Workshops have been held since 1984. These workshops annually bring together 35 researchers selected on the basis of position papers to discuss their most recent results. The proceedings of this workshop (published by IEEE Computer Society Press, Washington, DC) presents the best annual review of progress in the process-modeling field. The field is growing, and in 1991 the First International Conference on the Software Process attracted 200 people from both academia and industry. A review of this brief literature will indicate that currently the field is primarily focused on properties of languages for representing processes and on process-driven environments. An important step in understanding and comparing the various approaches to software process modeling has been undertaken in conjunction with the Sixth and Seventh International Software Process Workshops (ISPW). A working group has developed a benchmark software process modeling example problem <ref type="bibr" target="#b21">[22]</ref>. The original ISPW-6 Software Process Example was carefully designed to incorporate examples of 18 important process aspects and issues focusing on representation issues <ref type="bibr" target="#b23">[24]</ref>. Additional extensions were developed for the Example in conjunction with ISPW-7, highlighting teamwork issues, and process change '.</p><p>At least 24 different modeling approaches have been applied to this common process example. As a result, the Example has provided an important b~isis for understanding, comparing, and assessing various modeling approaches. In addition, it has successfully communicated-with concrete exampies--the diversity of process aspects encountered in real-world software processes. As a result, several researchers have extended and ~Copies of this problem may be obtained at cost by contacting Rocky Mountain Institute of Software Engineering (rMise), P.O. Box 3521, Boulder, CO 80303. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Multi-Paradigm Representations</head><p>The suitability of a modeling approach will depend on the goals and objectives for the resulting model <ref type="bibr" target="#b23">[24]</ref>. A given language construct or type will be better suited to achieving some modeling objectives than others. The goals and objectives outlined in Table <ref type="table" target="#tab_0">1</ref> present diverse requirements for a modeling technique that no current software process modeling approach fully satisfies. The diversity in audiences, in information content, and in the different descriptive capabilities needed for human vs. machine enaction of processes all impose broad, and sometimes conflicting, requirements on a modeling approach. An approach that integrates multiple representational paradigms is currently considered necessary for effective software process modeling. However, the application of multi-paradigm representations raises additional challenges regarding translation, communication, coordination, and interaction among model components.</p><p>A limited number of software process-modeling languages (e.g., APPL/A <ref type="bibr" target="#b36">[36]</ref>, MVP) are already combining at least a few language paradigms <ref type="bibr" target="#b34">[34]</ref>. One prominent approach in this category has been developed, refined, and applied at the Software Engineering Institute (SEI) by Kellner and his colleagues <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23]</ref>, and is supported by a commercial CASE tool called STATEMATE. This modeling approach is focused on supporting three of the objectives outlined in Table <ref type="table" target="#tab_0">1</ref>: facilitate human understanding and communication, support process improvement, and support process management. STATEMATE-based modeling provides a software design and analysis paradigm, formal visual languages, multiple integrated perspectives, and powerful automated analyses and simulations.</p><p>Of the four perspectives described earlier, the STATEMATEbased approach was specifically developed to support the functional, behavioral, and organizational perspectives; it can also provide support for the informational perspective <ref type="bibr" target="#b14">[15]</ref>. This approach supports multiple language paradigms as suggested in Table <ref type="table">2</ref>, including:</p><p>• state transitions with events and triggers (used for the behavioral perspective),</p><p>• systems analysis and design diagrams: enhanced data flow diagrams (used for the functional perspective), and modified structure charts (used for the organizational perspective)</p><p>• data-modeling (used with the functional perspective and additional informational perspective)</p><p>A small example of a STATEMATE model for a process element developing code and tests is presented in Figure <ref type="figure" target="#fig_4">3</ref>.</p><p>Substantial experience with this approach to software process modeling has been gained at the SEI in recent years, and includes major efforts at modeling large-scale software processes. The STATEMATE modeling approach has been applied to model the processes in actual use for supporting the operational software for the F-14A <ref type="bibr" target="#b19">[20]</ref>, and F-16A/B aircraft. These two models depict the full software support process from receipt of a software trouble report, change request, or enhancement request, through to release of the corresponding software change to the field. Other applications modeled processes presented in narrative prescriptions in a military handbook (MIL-HDBK-347). In these efforts, the work has progressed beyond simply representing the process, and has included manual and automated analyses of the process, followed by recommendations for process improvements based on those analyses. The application of appropriate existing technology has allowed the SEI team to focus their efforts on developing the approach and the actual models, rather than on building tools.</p><p>Although a small number of language paradigms can be integrated within a single modeling approach, even more diversity may be required to meet the wide-ranging objectives of modeling. A potential strategy for coping with this challenge is illustrated in Figure <ref type="figure" target="#fig_6">4</ref>. This technique is based on the loose integration (incorporation) of various modeling paradigms, allowing users to capitalize on their best aspects. The central research hypothesis is that a "common denominator schema" can be defined and evolved that will contain the union of all vital process information handled by the various representations. The common denominator schema would be in a basic representational form, such as an object-oriented, entity relationship, or relational schema, and thus would not be suitable for direct user manipulation. However, automatic translators could extract the subset of information represented by a given modeling approach, and store it in an object-base (database) defined by the common denominator schema. Similarly, various additional projections (views) of this process information could be prepared as output for direct use, by automatic or semiautomatic translation. The major challenges are in defining the common denominator schema, developing translators, and ensuring consistency between the input representations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Use in process Improvement</head><p>A software process movement emerged in the mid-1980s when shortcomings in managing the development process were recognized as prime inhibitors of growth in software productivity and quality. Since the payback from inserting technology has been modest [39], greater leverage for improving project results appears to reside in better management of the software process. When the noise created by poorly defined or badly managed processes is removed from a project, the impact of technology is more easily observed in project outcomes <ref type="bibr" target="#b15">[16]</ref>. Software development organizations are finding that they should first focus on defining the processes used in their software business, and only then select tools and methods to support these processes. Thus, when used to integrate people, tasks, tools, and methods, a well-defined and documented software process can provide an underlying foundation for long-term productivity and quality growth <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>Effective use of defined processes requires that a process be documented, that personnel be trained in its application, that it gets performed as it is documented, and that its performance is enforced and measured. Once a process is defined in this manner, it can be deliberately and methodically improved.</p><p>Unfortunately, many software organizations are crisis-driven, and their processes are ad hoc and occasionally even chaotic <ref type="bibr" target="#b12">[13]</ref>. In such environments, it is difficult to make lasting improvements in the software process. Humphrey developed a model of how organizations can mature their software processes and steadily improve their capability for meeting schedules and budgets with high-quality software. This Capability Maturity Model postulates five levels of growth, each of which lays a foundation for establishing improvements at the next level.</p><p>At the initial level of the model, crisis-driven organizations are firefighting, and display little evidence of a defined development process that can be repeated. The primary objective in moving to Level 2, the repeatable level, is to get project management under control. This control is established through sound project planning and tracking, management of subcontractors, controlling product baselines and changes to requirements, and assuring the quality of management processes. Process modeling can be employed in these organizations to define the processes to be performed in these vital areas.</p><p>Having built a sound management infrastructure that is capable of making sensible commitments for work, the focus at Level 3 shifts to defining an organization-wide software process that can be tailored to the conditions of each project. Process modeling techniques that were useful in defining the management processes that must be established at Level 2, are essential for building the process engineering infrastructure at Level 3. The defined software engineering process at Level 3 becomes an organizational asset that represents what the organization knows about performing its technical business <ref type="bibr" target="#b9">[10]</ref>. This asset can be matured and refined with future experience to become a competitive advantage in knowing how to produce highquality software in less time for less cost. In many other industries process efficiency has become a major competitive factor in the marketplace.</p><p>At Level 4, the defined process is instrumented with detailed measures in order to set quality targets for both the product and the process. Statistical quality control principles can be applied to different process elements by being able to ask such questions as, "What is the defect removal efficiency of each of our different kinds of reviews, walkthroughs, or testing methods?" At Level 5 the detailed measures installed at Level 4 are used to guide programs of continuous process improvement, technology innovation, and defect prevention.</p><p>Software process modeling techniques are essential for supporting process improvements at levels 4 and 5. Models provide a solid framework for defining measurement points and metrics at level 4. Analysis of the models can identify improvement opportunities for consideration. Level 5 requires detailed models that can forecast the quantitative impact of potential process changes and guide selection among alternatives. A means of recording and analyzing previous outcomes to form an experience base is another capability needed for software process modeling at level 5.</p><p>The SEI has used the Capability Maturity Model in helping several military and aerospace organizations <ref type="bibr" target="#b15">[16]</ref> improve their software process. Experience in these programs indicates that extensive effort is involved if an organization has few defined processes and exhibits large differences in the way individual projects are conducted. Implementing a successful process improvement program requires that such organizations first identify the processes they want to improve according to their current level of maturity. They must document their current practices as a baseline on which they can build new processes and against which they can compare improvements. They must then formally define the processes they want to install. A crucial attribute of a defined process is that it be measurable. The measures taken on defined processes can be used to determine their effectiveness and to guide subsequent improvements. Building new processes on top of the current process baseline, rather than installing an entirely new process, is important in order to keep the organization from becoming disoriented during the improvement program. Process modeling has been used to identify shortcomings and other improvement opportunities in real world baseline processes <ref type="bibr">[20, 231.</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>use in Software Project</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Management</head><p>A growing body of work is focused on using process modeling to support the management of software development and evolution. Support for both planning and replanning during process performance should enable managers to plan schedules, costs, and resources while varying the resource constraints, and accommodating deter-articles ministic or stochastic modeling. Kellner recently examined modeling support for management planning and control available in STATEMATE-based modeling, and illustrated these capabilities <ref type="bibr" target="#b20">[21]</ref>. Among the other techniques addressing this problem, Krasner and Terrel use a project management tool with CPM; system dynamics has been productively employed to forecast project-level plans and the impact of changes <ref type="bibr" target="#b0">[ 1,</ref><ref type="bibr" target="#b25">26]</ref>; and the Articulator <ref type="bibr" target="#b27">[28]</ref> is based on A1 scheduling techniques from production systems.</p><p>Another important element of planning involves the construction of a suitable process from a repertoire of components. The A1 planning paradigm used by GRAPPLE <ref type="bibr" target="#b11">[12]</ref> provides an automated, goaldriven approach to this problem. Boehm and Belz have proposed a process model generator based on a decision table and various life-cycle processes <ref type="bibr" target="#b4">[5]</ref>. Finally, work by Basili and Rombach <ref type="bibr" target="#b2">[3]</ref>, Krasner and Terrel (this issue), and at the SEI, are exploring reuse-based mechanisms for developing project-specific software processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Process-Based Software Development Environments</head><p>The objectives of automated execution support and automated guidance have received the attention of the largest number of researchers. The research community's interests in process, tools, and environments have found a unifying basis in the concept of "process-driven environments." Existing software engineering environments only support a fraction of the tasks included in a sophisticated software development or maintenance process. In the absence of a defined software process, it is difficult to identify:</p><p>• the complete suite of tools needed to support the entire process, * how these tools should be integrated to support actual work, and * how to design a software development environment that coordi-nates the work of many software engineers.</p><p>These environments provide automated support for software work based on a process model that controls some of the functionality of the environment. This control is achieved by having the components a usable model of the development process.</p><p>MARVEL is a multiuser, process-driven software development environment, offering rule-based process modeling and controlled automation. MARVEL was developed by <ref type="bibr">Kaiser</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CODE_LISTINGS; TEST_PLANS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interconnections Textual Information</head><p>of the environment automatically conform themselves to support the defined process. Some of the earliest research on process-driven environments was conducted by the Arcadia consortium. An early commercial example of a process-driven environment was ISTAR <ref type="bibr" target="#b7">[8]</ref> which enforced a contractual model of software development where contracts for developing components were let hierarchically. Software engineers received access to the tools and data associated with a contract they had accepted through a workdesk that organized their view of the development environment. ISTAR experienced some difficulty with the rigidity of the contractual model as  <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18]</ref> primarily at Columbia University. The key goals of MARVEL are to: • define processes • enact as much of the software process as possible • provide controlled automation of commercial-off-the-shelf (COTS) tools within a software development environment • support multiple users cooperating on a software project MARVEL's focus is on the objective (Table <ref type="table" target="#tab_0">1</ref>) of automated execution support. MARVEL employs a rule-based approach based on ideas from languages used for knowledge-based systems (e.g., OPS5 and Prolog). The underlying paradigm uses typed parameters, preconditions, the process elements (currently restricted to simple tool invocations), and postconditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>tam.</head><p>Each process step corresponds to a user command that is encapsulated with a condition that must be satisfied before its invocation, and an effect that asserts the state to exist at the completion of the process step. A process step in MAR-  Controlled automation in MAR-VEL is provided through opportunistic processing employing backward chaining and forwardchaining. Backward-chaining attempts to satisfy preconditions when a user requests the execution of a process step. Forward-chaining is applied to move to the next process step when a user completes a step. MARVEL also employs an object-oriented data model, and includes an object management sys-VEL typically invokes a tool through a shell script. MARVEL is an instance of a rule-based process server. Kaiser argues that such models can be evaluated by the type of assistance they support. MAR-VEL supports a pure automation model, since it invokes tools automatically, in contrast to a pure consistency-checking model that does not invoke tools. MARVEL emphasizes the functional and behavioral perspectives of software process modeling, along with those aspects of the informational and organizational perspectives relating to automation.</p><formula xml:id="formula_0">Input</formula><p>The MARVEL system has evolved through several successive prototypes, and a recent prototype in C is available for trial use. It has been applied to several small environments involving C programming and document production, and has recently been applied in a commercial application.</p><p>A broad range of research projects are continuing to apply process concepts to environment design. These projects have in common the notion of work distributed across workstations, performed on artifacts with a defined structure, and coordinated through sets of dependencies and constraints. The future for such environments depends on the extent to which more of the artifacts and resources of software development exist and are manipulated within the virtual world of a network rather than in the manual world of desks and bookshelves. Thus, process-driven environments will experience a gradual evolution in use rather than a revolution, because they cannot be effectively used beyond the level of process definition an organization has been able to institutionalize.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusion</head><p>Process modeling work is young, and the span of the research agenda is still being formulated. The software phenomena best modeled using each of the representational techniques discussed in this article vary. Consequently, the structure and attributes of models built with each of these techniques will differ. Since the field is young, results have been scattered in localized areas and few methods have been applied to large phenomena. A review of this literature in a few years may provide a much more definitive assessment of the research issues as the experience as the application base grows. Nevertheless, work to date holds promise for benefits in management, process-driven environments, and process reengineering.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>g., informational)Ir~lcles how different languages used for process modeling support the four perspectives.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Role interaction net for review team</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>arl:lclas enhanced their approaches in response to working through the Example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Example STATEMATE model for code and test development</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Common denominator representation concepts</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 . Software Process MOdeling Objectives and Goals FACILITATE HUMAN UNDERSTANDING AND COMMUNICATION • Represent process in form understandable by humans • Enable communication about and agreement on software processes • Formalize the process so that people can work together more effectively • Provide sufficient information to allow an individual or team to perform the intended process • Form a basis for training the intended process SUPPORT PROCESS IMPROVEMENT • Identify all the necessary components of a high-yield software development or maintenance process • Reuse well-defined and effective software processes on future projects • Compare alternative software processes • Estimate the impacts of potential changes to a software process without first Putting them into actual practice • ASSISt in the selection and incorporation of technology (e.g., tools) into a process • Facilitate organizational learning regarding effective software processes • SupPort managed evolution of a process SUPPORT PROCESS MANAGEMENT • Develop a project-specific software process to accommodate the attributes of a particular project, such as its product, or organizational environment • Reason about attributes of software creation or evolution • Support development Of plans for the project (forecasting) • Monitor, manage, and coordinate the process • Provide a basis for process measurement, such as definition of measurement points within the context Of a specific process AUTOMATED GUIDANCE IN PERFORMING PROCESS • Define an effective software development environment • Provide guidance, suggestions, and reference material to facilitate human performance of the intended process • Retain reusable process representations In a repository AUTOMATED EXECUTION SUPPORT • Automate portions of the process • Support cooperative work among individuals and teams by automating the process • Automatically collect measurement data reflecting actual experience with a process • Enforce rules to ensure process integrity</head><label>1</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>11:ble 2. Language Types and Constructs Used as Bases for Software Process Modeling Base Language Types Sample SOftware PrOCeSS and Constructs Modeling Approaches Procedural programming languages Systems analysis and design 1 AI languages and approaches 2 Events and triggers APPL/A [361 STATEMATE</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 . Perspectives for Process Information and Applicable Language Bases Perspectives</head><label>3</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell>m</cell><cell>o</cell><cell>t-</cell></row><row><cell></cell><cell>o</cell><cell>_o</cell><cell>~</cell></row><row><cell></cell><cell>u 1-</cell><cell>m e-</cell><cell>(~</cell></row><row><cell></cell><cell>u.</cell><cell>m</cell><cell>O</cell><cell>--=</cell></row><row><cell>Procedural Programming languages</cell><cell>~</cell><cell>~"</cell><cell></cell></row><row><cell>Systems analysis and design</cell><cell>/,4</cell><cell></cell><cell></cell></row><row><cell>Allanguages and approaches</cell><cell>~"</cell><cell></cell><cell></cell></row><row><cell>Events and triggers</cell><cell></cell><cell></cell><cell></cell></row><row><cell>state transition and petri-nets</cell><cell>~,2</cell><cell></cell><cell>;,,,2</cell></row><row><cell>Control flow</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Functional languages</cell><cell>~'</cell><cell></cell><cell></cell></row><row><cell>Formal languages Data modeling</cell><cell></cell><cell></cell><cell></cell><cell>/J'</cell></row><row><cell>Object modeling</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Precedence networks</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Notes: le.g, product structure charts</cell><cell></cell><cell></cell><cell></cell></row><row><cell>2specifically role-interaction nets</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>and her colleagues</figDesc><table><row><cell>EARLIER STEPS J</cell><cell></cell><cell cols="2">[ LATER_STEPS }</cell><cell cols="2">I t COMPUTER_FILES t t I</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>CODE</cell><cell>TEST_Fi LES</cell></row><row><cell cols="2">Cr "~ CODE_N COM PILE ~J~ ' ,</cell><cell cols="2">CODE_DEVEL"</cell><cell></cell></row><row><cell>/</cell><cell cols="2">"~ COMPILED [CLEAN]</cell><cell></cell><cell></cell></row><row><cell cols="2">( [REWORK_CODE] "~</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">-{ DEVELOP_TESTSJ</cell><cell cols="2">T_ EVEL</cell><cell></cell></row><row><cell cols="2">~WORK_TESTS]</cell><cell></cell><cell></cell><cell cols="2">[ UN~_DEV_FC~-DE~ ', I ! I</cell></row><row><cell cols="3">Behavioral Perspective-Statechart</cell><cell></cell><cell cols="2">Functional Perspective -Activity Chart</cell></row><row><cell cols="3">I r--'---"~4 I COMPUTER_FILES ~1 FACILffY_MGMT I~l , , rj Ii</cell><cell>o_.</cell><cell cols="2">DEV MODULE_TESTS descrlpUon: Task ot planning and developing unit tests for a module. executed throughout: DEVELOPTESTS carried oul by: QA</cell></row><row><cell>~_E~aINEER, NG +</cell><cell></cell><cell></cell><cell></cell><cell>attributes: NAME:</cell><cell>VALUE:</cell></row><row><cell>[ SW_DEVELOPERS J</cell><cell></cell><cell>QA</cell><cell>I</cell><cell>USES FACILITY</cell><cell>DVLPMT_SUtTE</cell></row><row><cell>HAND_CARRIED_I I</cell><cell cols="3">L HAND CARRIED_2</cell><cell></cell></row><row><cell cols="4">I Organizational Perspective -Module Chart</cell><cell></cell></row></table><note><p>............................. HAND_CARRIED 2 contains:</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>September 1992/Vol.35, No.9/COMMUNICATIONS OFTHE ACM</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>September 1992/Vol.35, No.9/COMMUNICATIONS OF THE ACM</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Segten~be~" 1992/'Mo|.35, No.9/COMMUNICATIONS OF THE ACM</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>September 1992/%1.35, No.9/COMMUNICATIONS OF THE ACM</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors gratefully acknowledge the comments of Bob Balzer, Herb Krasner, and Lee Osterweil on an earlier draft of this article, in addition to others provided by anonymous reviewers. The production of this article was supported in part by the Defense Advanced Research Projects Agency (DARPA)/ Software Technology for Adaptable, Reliable Systems (STARS) program. The authors appreciate the support and encouragement of their process modeling work by John Foreman on this program. The opinions expressed in this material are those of the authors and do not necessarily reflect those of DARPA or the Software Engineering Institute. []</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>JAMES OVER is a senior member of the technical staff, and project leader of the Software Process Definition project at the Software Engineering Institute (SEI). Before joining the SEI, Over was director of information systems for Pulitzer Publications, Chicago, Illinois. He is the coauthor of several publications on process definition and improvement, applications of technology to document maintenance, and documentation tools in software maintenance environments. His interests include the software process, process management and improvement, and process modeling and definition.</p><p>Authors' Present Address: Software Engineering Institute, Carnegie Mellon University, Pittsburgh, PA 15213-3890 Permission to copy without tee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Software Project Dynamics: An Integrated Approach</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">K</forename><surname>Abdel-Hamid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Madnick</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A 15 year perspective on automatic programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Balzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1257" to="1268" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Support for comprehensive reuse</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Basili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Rombach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw. Eng. J</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="303" to="316" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A spiral model of software development and enhancement</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="61" to="72" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Experiences with the spiral model as a process model generator</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boehm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Belz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Software Process Workshop. 1EEE Computer Society</title>
		<meeting>the Fifth International Software Process Workshop. 1EEE Computer Society<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="43" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A field study of the software design process on large systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krasner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Iscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1268" to="1287" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On building software process models under the lamppost</title>
		<author>
			<persName><forename type="first">B</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName><surname>Krasner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Iscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth International Conference on Software Engineering</title>
		<meeting>the Ninth International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="96" to="103" />
		</imprint>
	</monogr>
	<note>DC</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">ISTAR--An integrated project support environment</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dowson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second ACM Software Engineering Symposium on Practical Software Development Environments</title>
		<meeting>the Second ACM Software Engineering Symposium on Practical Software Development Environments</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="27" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Concepts for process definition and support</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dowson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nejmeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Riddle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of. the Sixth International Software Process Workshop</title>
		<meeting>the Sixth International Software Process Workshop<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="87" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A corporate-wide software process</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Frailey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Conference on Software Process</title>
		<meeting>the First International Conference on Software Process<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="113" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">System technology as a basis for a programming environment</title>
		<author>
			<persName><forename type="first">A</forename><surname>Holt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Ramsey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grimes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ITT Electr. Commun</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A planbased intelligent assistant that supports the software development process</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Huff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Lessor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Software Engineering Symposium on Practical Software Development Environments</title>
		<meeting>the Third Software Engineering Symposium on Practical Software Development Environments</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="97" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Managing the Software Process</title>
		<author>
			<persName><forename type="first">W</forename><surname>Humphrey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<pubPlace>Addison-Wesley, Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Software process development and enactment: Concepts and definitions</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Humphrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Feiler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Pittsburgh: Software Engineering Institute, Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. SEI-92-TR-4</note>
	<note>To be published</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Software process modeling: Principles of entity process models</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Humphrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Kellner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh International Conference on Software Engineering</title>
		<meeting>the Eleventh International Conference on Software Engineering<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="331" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Software process improvement at Hughes Aircraft</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Humphrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Snyder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Willis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Softw</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="11" to="23" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Preliminary experience with process modeling in the Marvel software development environment kernel</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Barghouti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Sokolsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23d Annual Hawaii International Conference on System Sciences</title>
		<meeting>the 23d Annual Hawaii International Conference on System Sciences<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="131" to="140" />
		</imprint>
	</monogr>
	<note>H--Software Track</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Intelligent assistance for software development and maintenance</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Feiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Popovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Softw</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="40" to="49" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">What has been learned from applying a formal process model to a real process?</title>
		<author>
			<persName><forename type="first">T</forename><surname>Katayama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Motizuki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Software Process Workshop</title>
		<meeting>the Seventh International Software Process Workshop<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1992">1992. 1992</date>
		</imprint>
	</monogr>
	<note>To be published</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Software process modeling: Value and experience</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Kellner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="22" to="54" />
			<pubPlace>Pittsburgh, Pa</pubPlace>
		</imprint>
		<respStmt>
			<orgName>SEI Tech. Rev. Software Engineering Institute, Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Software process modeling support for management planning and control</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Kellner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Conference on the Software Process</title>
		<meeting>the First International Conference on the Software Process<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="8" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">ISPW-6 software process example</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Kellner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Feiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Finklestein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Katayama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Osterweil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Penedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Rombach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Conference on the Software Process</title>
		<meeting>the First International Conference on the Software Process</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="176" to="186" />
		</imprint>
	</monogr>
	<note>DC</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Software process modeling: A Case study</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Kellner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22d Annual Hawaii International Conference on System Sciences</title>
		<meeting>the 22d Annual Hawaii International Conference on System Sciences<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="175" to="188" />
		</imprint>
	</monogr>
	<note>H--Software Track</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Session summary: Comparisons of software process descriptions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Kellner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Rombach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International Software Process Workshop</title>
		<meeting>the Sixth International Software Process Workshop<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="7" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Process models, process programs, programming support</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Lehman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth International Conference on Software Engineering</title>
		<meeting>the Ninth International Conference on Software Engineering<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="14" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Computer-aided software development process design</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Levary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1025" to="1037" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Session summary: Enaction formalisms</title>
		<author>
			<persName><forename type="first">R</forename><surname>Maclean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Software Process Workshop</title>
		<meeting>the Fourth International Software Process Workshop<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="11" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Modeling articulation work in software engineering processes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Scacchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Conference on the Software Process</title>
		<meeting>the First International Conference on the Software Process</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Society</title>
		<imprint>
			<biblScope unit="page" from="188" to="201" />
			<date type="published" when="1989">1989</date>
			<pubPlace>Washington, DC</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Law-governed systems</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Minsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw. Eng.J</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="285" to="302" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Software processes are software too</title>
		<author>
			<persName><forename type="first">L</forename><surname>Osterweil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth International Conference on Software Engineering</title>
		<meeting>the Ninth International Conference on Software Engineering<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="2" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Modeling iteration in the software process</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Ould</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Roberts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Software Process Workshop</title>
		<meeting>the Fourth International Software Process Workshop<address><addrLine>Wa</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="101" to="104" />
		</imprint>
	</monogr>
	<note>hington</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Acquiring experiences with executable software process models</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Penedo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Software Process Workshop</title>
		<meeting>the Fifth International Software Process Workshop<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="112" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Session summary: Opening session</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Riddle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Software Process Workshop</title>
		<meeting>the Fourth International Software Process Workshop<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="5" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">An experiraental process modeling language: Lessons learned from modeling a maintenance environment</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Rombach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Software Maintenance</title>
		<meeting>the Conference on Software Maintenance<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="95" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Role interaction nets (RINs): A process description formalism</title>
		<author>
			<persName><forename type="first">B</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Rein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Microelectronics and Computer Technology Corp. Austin, Tex.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. CT-083-92</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Language constructs for managing change in process</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Heimbigner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Osterweil</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
