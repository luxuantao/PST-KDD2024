<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Streaming Graph Partitioning for Large Distributed Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Isabelle</forename><surname>Stanton</surname></persName>
							<email>isabelle@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley Berkeley</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gabriel</forename><surname>Kliot</surname></persName>
							<email>gkliot@microsoft.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research Redmond</orgName>
								<address>
									<region>WA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Streaming Graph Partitioning for Large Distributed Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>G.2.2 [Mathematics of Computing]: Discrete Mathematics-Graph Theory</term>
					<term>Graph Algorithms; D.2.8 [Software Engineering]: Metrics-Complexity measures</term>
					<term>Performance measures Algorithms</term>
					<term>Experimentation Graph Partitioning</term>
					<term>Streaming Algorithms</term>
					<term>Distributed Graphs</term>
					<term>Experimental Evaluation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Extracting knowledge by performing computations on graphs is becoming increasingly challenging as graphs grow in size. A standard approach distributes the graph over a cluster of nodes, but performing computations on a distributed graph is expensive if large amount of data have to be moved. Without partitioning the graph, communication quickly becomes a limiting factor in scaling the system up. Existing graph partitioning heuristics incur high computation and communication cost on large graphs, sometimes as high as the future computation itself. Observing that the graph has to be loaded into the cluster, we ask if the partitioning can be done at the same time with a lightweight streaming algorithm.</p><p>We propose natural, simple heuristics and compare their performance to hashing and METIS, a fast, offline heuristic. We show on a large collection of graph datasets that our heuristics are a significant improvement, with the best obtaining an average gain of 76%. The heuristics are scalable in the size of the graphs and the number of partitions. Using our streaming partitioning methods, we are able to speed up PageRank computations on Spark [32], a distributed computation system, by 18% to 39% for large social networks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Modern graph datasets are huge. The clearest example is the World Wide Web where crawls by large search engines currently consist of over one trillion links and are expected to exceed ten trillion within the year. Individual websites also contain enormous graph data. In Jan 2012, Facebook consisted of over 800 million active users, with hundreds of billions friend links <ref type="bibr">[1]</ref>. There are over 900 million additional objects (communities, pages, events, etc.) that interact with the user nodes. In July 2009, Twitter had over 41.7 million users with over 1.47 billion social relations <ref type="bibr" target="#b15">[21]</ref>. Since then, it has been estimated that Twitter has grown to over 200 million users. Examples of large graph datasets are not limited to the Internet and social networks -biological networks, like protein interaction networks, are of a similar size. Despite the size of these graphs, it is still necessary to perform computations over the data, such as calculating PageRank, broadcasting Twitter updates, identify protein associations, as well as many other applications.</p><p>The graphs consist of terabytes of compressed data when stored on disks and are all far too large for a single commodity type machine to efficiently perform computations. A standard solution is to split the data across a large cluster of commodity machines and use parallel, distributed algorithms for the computation. This approach introduces a host of systems engineering problems of which we focus only on the problem of data layout. For graph data, this is called balanced graph partitioning. The goal is to minimize the number of cross partition edges, while keeping the number of nodes (or edges) in every partition approximately even.</p><p>Good graph partitioning algorithms are very useful for many reasons. First, graphs that we encounter and care about in practice are not random. The edges display a great deal of locality, whether due to the vertices being geographically close in social networks, or related by topic or domain on the web. This locality gives us hope that good partitions, or at least partitions that are significantly better than random cuts, exist in real graphs. Next, inter-machine communication, even on the same local network, is substantially more expensive than inter-processor communication. Network latency is measured in microseconds while inter-process communication is measured in nanoseconds. This disparity substantially slows down processing when the network must be used. For large graphs, the data to be moved may border on gigabytes, causing network links to become saturated.</p><p>The primary problem with partitioning complicated graph data is that it is difficult to create a linear ordering of the data that maintains locality of the edges i.e. if it is possible to embed the vertices of a graph into a line such that none of the edges are 'too long', then a good balanced cut exists in the graph. Such an ordering may not even exist at all. There is a strong connection between graph partitioning and the eigenvectors and eigenvalues of the corresponding Laplacian matrix of the graph via the Cheeger bound. This connection has inspired many spectral solutions to the problem, including ARV <ref type="bibr" target="#b5">[11]</ref> and the many works that followed.</p><p>However, spectral methods do not scale to big data. This is in part due to the running time and in part because current formulations require full graph information. When a graph does not physically fit on one machine, maintaining a coherent view of the entire state is impossible. This has led to local spectral partitioning methods, like EvoCut <ref type="bibr" target="#b3">[9]</ref>, but local methods still require access to large portions of the graph, rely on complex distributed coordination and large computation after the data has been loaded. Thus, we look for a new type of solution. A graph loader is a program that reads serial graph data from a disk onto a cluster. It must make a decision about the location of each node as it is loaded. The goal is to find a close to optimal balanced partitioning with as little computation as possible. This problem is also called streaming graph partitioning.</p><p>For some graphs, partitioning can be entirely bypassed by using meta data associated with the vertices, e.g. clustering web pages by URL produces a good partitioning for the web. In social networks, people tend to be friends with people who are geographically nearby. When such data is available, this produces an improved cut over a node ID hashing approach. Unfortunately, this data is not always be available, and even if it is, it is not always clear which features are useful for partitioning. Our goal in this work is to find a general streaming algorithm that relies only on the graph structure and works regardless of the meta data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Applications</head><p>Our motivating example for studying this problem is a large distributed graph computation system. All distributed computation frameworks, like MapReduce, Hadoop, Orleans <ref type="bibr" target="#b9">[15]</ref> and Spark <ref type="bibr" target="#b26">[32]</ref> have methods for handling the distribution of data across the cluster. Unfortunately, for graphs, these methods are not tuned to minimize communication complexity, and saturating the network becomes a significant barrier to scaling the system up.</p><p>The interest in building distributed systems for graph computation has recently exploded, especially within the database community. Examples of these systems include Pregel <ref type="bibr" target="#b19">[25]</ref>, GraphLab <ref type="bibr" target="#b18">[24]</ref>, InfiniteGraph, HyperGraphDB, Ne04j, and Microsoft's Trinity [4] and Horton [3], to name but a few. Even for these graph specific systems, the graphs are laid out using a hash of the node ID to select a partition. If a good pseudorandom hash function is chosen, this is equivalent to using a random cut as graph partitioning and will result in approximately balanced partitions. However, computations on the graph run more slowly when a hash partitioning is used instead of a better partitioning, due to the high communication cost. Fortunately, these systems tend to support custom partitioning, so it is relatively easy to substitute a more sophisticated method, provided it scales to the size of the graph. As our experiments show, even using our simple streaming partitioning techniques can allow systems of this type to complete computations at least 20-40% faster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Theoretical Difficulties -Lower Bound</head><p>Theoretically, a good streaming partitioning algorithm is impossible. It is easy to create graphs and orderings for any algorithm that will cause it to perform poorly. A simple example of this lower bound is a cycle. The optimal balanced 2-partition cuts only 2 edges. However, if the vertices are given in an order of 'all even nodes then all odd nodes', we won't observe any edges until the odd nodes arrive. Without any information, the best an algorithm could is to try and balance the number of vertices it has seen across the 2 partitions. This leads to an expected cut of n 4 edges. The worst algorithm might put all even nodes in one partition leading to all edges being cut!</p><p>We can partially bypass this problem by picking the input ordering. The three popular orderings considered in the literature are adversarial, random, and stochastic. The above cycle example is an adversarial order and demonstrates that the streaming graph partitioning problem may have arbitrarily bad solutions under that input model. Given that adversarial input is unrealistic in our setting -we have control over the data -we focus on input that results from either a random ordering, or the output of a graph search algorithm. The second option is a simplification of the ordering returned by a graph crawler.</p><p>Theorem 1. One-pass streaming balanced graph partitioning with an adversarial stream order can not be approximated within o(n).</p><p>Theorem 2. One-pass streaming balanced graph partitioning with a random stream order can not be approximated within o(n).</p><p>The full proofs are elided due to space. Theorem 1 can be proved with the above cycle discussion. Theorem 2 can be proved by analyzing the expected number of vertices in a random order that arrive with no edges (a third). Each of these vertices contributes an edge to the cut in expectation. This means, in expectation, a random cut will cut O(n) edges, while an optimal partitioning cuts only 2.</p><p>We leave open the theoretical problem of analyzing the performance of our heuristics. While there are current approaches to analyzing streaming algorithms, our use of breadthfirst and depth-first stream orders is novel and previous approaches can not be applied. Theorem 1 shows we should not hope to analyze any algorithm with an adversarial order, while a random ordering will always hide edges in sparse graphs until O( √ n) vertices arrive, making competitive analysis difficult.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">The Streaming Model</head><p>We consider a simple streaming graph model. We have a cluster of k machines, each with memory capacity C, such that the total capacity, kC, is large enough to hold the whole graph. The graph is G = (V, E) where V is the vertices, and E the edges. The graph may be either directed or undirected. The vertices arrive in a stream with the set of edges where it is a member so for undirected graphs, each edge appears twice in the stream. We consider three orders: random, breadth-first search and depth-first search. As vertices arrive, a partitioner decides to place the vertex on one of the k machines. A vertex is never moved after it has been placed. In order to give the heuristics maximal flexibility, we allow the partitioning algorithm access to the entire subgraph defined by all vertices previously seen. This is a strong assumption, but the heuristics studied in this paper use only local (depth 1) information about this subgraph. We extend the model by allowing a buffer of size C so that the partitioning algorithm may decide to place any node in the buffer, rather than the one at the front of the stream.</p><p>Our model assumes serial input and a single loader. This is somewhat unrealistic for a real system where there may be many graph loaders working in parallel on independent portions of the stream. While we will not explore this option, the heuristics we investigate can be easily adapted to a parallel setting where each loads its portion of the graph independently from the others, sharing information only through a distributed lookup table of vertices to partition IDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Contributions</head><p>We provide a rigorous, empirical study of a set of natural heuristics for streaming balanced graph partitioning. To the best of our knowledge, this is a first attempt to study this problem. We evaluate these heuristics on a large collection of graph datasets, from various domains: the World Wide Web, social networks, finite-element meshes and synthetic datasets from some popular generative models -preferentialattachment <ref type="bibr" target="#b7">[13]</ref>, RMAT <ref type="bibr" target="#b17">[23]</ref> and Watts-Strogatz <ref type="bibr" target="#b24">[30]</ref>. We compare the results of our streaming heuristics to both the hash based partitioning, and METIS <ref type="bibr" target="#b13">[19]</ref>, a well-regarded, fast, offline partitioning heuristic.</p><p>Our results show that some of the heuristics are good and some are surprisingly bad. Our best performing heuristic is a weighted variant of the greedy algorithm. It has a significant improvement over the hashing approach without significantly increasing the computational overhead and obtains an average gain of 76% of the possible improvement in the number of edges cut. On some graphs, with some orderings, a variety of heuristics obtain results which are very close to the offline METIS result. By using the synthetic datasets, we are also able to show that our heuristics scale with the size of the graph and the number of partitions. We demonstrate the value of the best heuristic by using it to partition both the LiveJournal and the Twitter graph for PageRank computation using the Spark cluster system <ref type="bibr" target="#b26">[32]</ref>. These are large crawls of real social networks, and we are able to improve the running time of the PageRank algorithm by 18% to 39% by changing the data layout alone. Our experimental results motivate us to recommend that this is an interesting problem worthy of future research and is a viable preprocessing step for graph computation systems.</p><p>Our streaming partitioning is not intended to substitute for a full information graph partitioning. Certain systems or applications that need as good a partitioning as possible will still want to repartition the graph after it has been fully loaded onto the cluster. These systems can still greatly benefit from our optimization as a distributed offline partitioning algorithm started from an already reasonably partitioned graph will require less communication and may need to move fewer vertices, causing it to run faster. Our streaming partitioning algorithms can be viewed as a preprocessing optimization step that cannot hurt in exchange for a very small additional computation cost for every loaded vertex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Graph partitioning has a rich history. It encompasses many problems and has many proposed solutions, from the very simple to the very sophisticated. We cannot hope to cover the whole field and will only focus on the most relevant formulation -balanced k-partitioning. The goal is, given a graph G as input and a number k, to cut G into k balanced pieces while minimizing the number of edges cut. This problem is known to be NP-Hard, even if one relaxes the balanced constraint to 'approximately' balanced <ref type="bibr" target="#b4">[10]</ref>. Andreev and Racke give an LP-based solution that obtains a O(log n) approximation <ref type="bibr" target="#b4">[10]</ref>. Even et al. <ref type="bibr" target="#b10">[16]</ref> provide another LP formulation based on spreading metrics that also obtains an O(log n) approximation. Both require full information about the graph. There are many heuristics that solve this problem with an unknown performance guarantee, like METIS <ref type="bibr" target="#b13">[19]</ref>, PMRSB <ref type="bibr" target="#b8">[14]</ref>, and Chaco <ref type="bibr" target="#b11">[17]</ref>. In practice, these heuristics are quite effective, but many are intended for scientific computing purposes. One can recursively use any balanced 2-partitioning algorithm to approximate a balanced k-partitioning when k is a power of 2 <ref type="bibr" target="#b5">[11]</ref>.</p><p>While we are unaware of any previous work on the exact problem statement that we study -one pass balanced k partitioning -there has been much work on many related streaming problems, primarily graph sparsification in the semi-streaming model, cut projections in the streaming model as well as online algorithms in general, like online bipartite matching. This work includes both algorithms and lower bounds on space requirements.</p><p>The work on streaming graph problems where multiple passes on the stream are allowed includes estimating PageRank <ref type="bibr" target="#b23">[29]</ref> and cut projections <ref type="bibr" target="#b22">[28]</ref>. While PageRank has been used for local partitioning <ref type="bibr" target="#b2">[8]</ref>, the approach in <ref type="bibr" target="#b2">[8]</ref> uses personalized PageRank vectors which does not easily generalize the approach in <ref type="bibr" target="#b23">[29]</ref>. Additionally, cut projections do not maintain our balanced criterion.</p><p>Bahmani et al. <ref type="bibr" target="#b6">[12]</ref> maintain an accurate estimate of the PageRank in one pass in the semi-streaming model, where the nodes are fixed but edges arrive in an adversarial order. In the semi-streaming model, further results are known with regards to finding minimum cuts, i.e. no balance requirement. Jin Ahn and Guha <ref type="bibr" target="#b0">[6]</ref> give a one pass Õ(n/ 2 ) space algorithm that sparsifies a graph such that each cut is approximated to within a (1 + ) factor. Kelner and Levin <ref type="bibr" target="#b14">[20]</ref> produce a spectral sparsifier with O(n log n/ 2 ) edges in Õ(m) time. While sparsifiers are related to partitioning, we do not have a prespecified computation task, so we cannot be sure that a sparsified graph will give accurate answers. Zelke <ref type="bibr" target="#b27">[33]</ref> shows lower bounds of o(n 2 ) space to find max and min cuts in one pass. Zelke <ref type="bibr" target="#b27">[33]</ref> has shown that this cannot be computed in one pass with o(n 2 ) space. By contrast, our methods require only access to a distributed lookup table and a buffer of size C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">HEURISTICS AND STREAM ORDERS</head><p>In this paper, we examine multiple heuristics and stream orders. We now formally define each one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Heuristics</head><p>The notation P t refers to the set of partitions at time t. Each individual partition is referred to by its index P t (i) so ∪ k i=1 P t (i) is equal to all of the vertices placed so far. Let v denote the vertex that arrives at time t in the stream, Γ(v) refers to the set of vertices that v neighbors and |S| refers to the number of elements in a set S. C is the capacity constraint on each partition. Each of the heuristics gives an algorithm for selecting the index ind of the partition where v is assigned. The first seven heuristics do not use a buffer, while the last three do.</p><p>1. Balanced -Assign v to a partition of minimal size, breaking ties randomly:</p><formula xml:id="formula_0">ind = arg min i∈[k] {|P t (i)|} 2.</formula><p>Chunking -Divide the stream into chunks of size C and fill the partitions completely in order:</p><formula xml:id="formula_1">ind = t/C 3. Hashing -Given a hash function H : V → {1 • • • k}, assign v to ind = H(v).</formula><p>We use:</p><formula xml:id="formula_2">H(v) = (v mod k) + 1</formula><p>4. (Weighted) Deterministic Greedy -Assign v to the partition where it has the most edges. Weight this by a penalty function based on the capacity of the partition, penalizing larger partitions. Break ties using Balanced.</p><formula xml:id="formula_3">ind = arg max i∈[k] {|P t (i) ∩ Γ(v)|w(t, i)}</formula><p>where w(t, i) is a weighted penalty function:</p><formula xml:id="formula_4">w(t, i) = 1 for unweighted greedy w(t, i) = 1 − |P t (i)| C</formula><p>for linear weighted w(t, i) = 1−exp{|P t (i)|−C} for exponentially weighted 5. (Weighted) Randomized Greedy -Assign v according to the distribution defined by</p><formula xml:id="formula_5">P r(i) = |P t (i) ∩ Γ(v)|w(t, i)/Z</formula><p>where Z is the normalizing constant and w(t, i) is the above 3 penalty functions.</p><p>6. (Weighted) Triangles -Assign v according to arg max</p><formula xml:id="formula_6">i∈[k] { |E(P t (i) ∩ Γ(v), P t (i) ∩ Γ(v))| |P t (i)∩Γ(v)| 2 w(t, i)}</formula><p>where w(t, i) is the above 3 penalty functions and E(S, T ) is the set of edges between the nodes in S and T .</p><p>7. Balance Big -Given a way of differentiating high and low degree nodes, if v is high-degree, use Balanced. If it is low-degree, use Deterministic Greedy.</p><p>The following heuristics all use a buffer.</p><p>8. Prefer Big -Maintain a buffer of size C. Assign all high degree nodes with Balanced, and then stream in more nodes. If the buffer is entirely low degree nodes, then use Deterministic Greedy to clear the buffer. 9. Avoid Big -Maintain a buffer of size C and a threshold on large nodes. Greedily assign all small nodes in the buffer. When the buffer is entirely large nodes, use Deterministic Greedy to clear the buffer.</p><p>10. Greedy EvoCut -Use EvoCut <ref type="bibr" target="#b3">[9]</ref> on the buffer to find small Nibbles with good conductance. Select a partition for each Nibble using Deterministic Greedy.</p><p>Each of these heuristics has a different motivation with some arguably more natural than others. Balanced and Chunking are simple ways of load balancing while ignoring the graph structure.</p><p>Hashing is currently used by many real systems <ref type="bibr" target="#b19">[25]</ref>. The benefit of Hashing is that every vertex can be quickly found, from any machine in the cluster, without the need to maintain a distributed mapping table. If the IDs of the nodes are consecutive, the hash function H(v) = (v mod k) + 1 makes Balanced and Hashing equivalent. More generally, a pseudorandom hash function should be used, making Hashing equivalent to a random cut.</p><p>The greedy approach is standard, although the weighted penalty is inspired by analysis of other online algorithms. The randomized versions of these algorithms were explored because adding randomness can often be shown to theoretically improve the worst-case performance.</p><p>The (Weighted) Triangles heuristic exploits work showing that social networks have high clustering coefficients by finding triangles completed triangles among the vertices neighbors in a partition and overweighting their importance.</p><p>Heuristics Balance Big, Prefer Big, and Avoid Big assume we have a way to differentiate high and low degree nodes. This assumption is based on the fact that many graphs have power law degree distributions. These three heuristics propose different treatments for the small number of high degree nodes and the large number of low degree nodes.</p><p>Balance Big uses the high degree nodes as seeds for the partitions to 'attract' the low degree nodes. The buffered version, Prefer Big, allows the algorithm more choice in finding these seeds. Avoid Big explores the idea that the high degree nodes form the expander portion of the graph, so perhaps the low degrees nodes can be partitioned after the high degree nodes have been removed.</p><p>The final heuristic, Greedy EvoCut, uses EvoCut <ref type="bibr" target="#b3">[9]</ref>, a local partitioning algorithm, on the buffer. This algorithm has very good theoretical guarantees with regards to the found cuts, and the amount of work spent to find them, but the guarantees do not apply to the way we use it.</p><p>Edge Balancing: While our experiments focus on partitions that are node balanced, in part because this is what our comparator algorithm METIS produces, there is nothing that prevents these heuristics from being used to produce edge-balanced partitions instead, i.e. each partition holds at most C = (1 + )|E|/k edges. An edge-balanced partition may be preferable for power-law distributed graphs when the computation to be performed has complexity in terms of the number of edges and not the number of vertices. In fact, in our second set of experiments with the PageRank algorithm in Section 6 we used the edge-balanced versions of the algorithms instead, for the above reason.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Stream Orders</head><p>In a sense, the stream ordering is the key to having a heuristic perform well. A simple example is Chunking, where, if we had an optimal partitioning, and then created an ordering consisting of all nodes in partition 1, then all nodes in partition 2 and so on, Chunking would also return an optimal partition. For each heuristic, we can define optimal orderings, but, unfortunately, actually generating them reduces to solving balanced graph partitioning so we must settle for orderings that are easy to compute.</p><p>We consider the following three stream orderings:</p><p>• Random -This is a standard ordering in streaming literature and assumes that the vertices arrive in an order given by a random permutation of the vertices.</p><p>• BFS -This ordering is generated by selecting a starting node from each connected component of the graph uniformly at random and is the result of a breadth-first search that starts at the given node. If there are multiple connected components, the component ordering is done at random.</p><p>• DFS -This ordering is identical to the BFS ordering except that depth-first search is used.</p><p>Each of these stream orderings has a different justification. The random ordering is a standard assumption when theoretically analyzing streaming algorithms. While we generate these orderings by selecting a random permutation of the vertices, one could view this as a special case of a generic ordering that does not respect connectivity of the graph. The benefit of a random ordering is that it avoids adversarially bad orderings. The downside is that it does not preserve any locality in the edges so we expect it to do poorly for statistical reasons like the Birthday paradox. Via the Birthday paradox, we can argue that for sparse graphs, we expect to go through O( √ n) of the vertices before we find a first edge. Both BFS and DFS are natural ways of linearizing graphs and are highly simplified models of a web crawler. In practice, web crawlers are a combination of local search approaches -they follow links, but fully explore domains and sub-domains before moving on. This is breadth-first search between domains, and depth-first search within. The main benefit of both orderings is that they guarantee that the partitioner sees edges in the stream immediately. Additionally, they maintain some locality. Each has their drawbacks, but it should be noted that BFS is a subroutine that is often used in partitioning algorithms to find a good cut, particularly for rounding fractional solutions to LPs <ref type="bibr" target="#b10">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EVALUATION SETUP</head><p>We conducted extensive experimental evaluation to discover the performance and trends of stream partitioning heuristics on a variety of graphs. The questions we ask are: Which of these heuristics are reasonable? Can we recommend a best heuristic, restricted to graph type? Do these heuristics scale to larger graphs? Our intent is to use this style of solution for graphs that include trillions of edges, yet in our initial experiments our largest graph has 1.4 million edges. We address this last question by using synthetic datasets to show that the heuristics scale and in Section 6 use our heuristics on two larger social networks successfully.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Datasets</head><p>We used several sources to collect multiple datasets for our experiments. From the SNAP <ref type="bibr" target="#b16">[22]</ref> archive, we used soc-Slashdot0811, wiki-Vote and web-NotreDame. From the Graph Partitioning Archive [5] we used : 3elt, 4elt, and vibrobox. We also used: Astrophysics collaborations (astroph) <ref type="bibr" target="#b21">[27]</ref>, C. Elegans Neural Network (celegans) <ref type="bibr" target="#b24">[30]</ref>, and the Marvel Comics social network <ref type="bibr" target="#b1">[7]</ref>. We used two large social networks (LiveJournal <ref type="bibr" target="#b20">[26]</ref> and Twitter <ref type="bibr" target="#b15">[21]</ref>) to evaluate our heuristics in a real system in Section 6.</p><p>We created synthetic datasets using popular generative models, preferential attachment (BA) <ref type="bibr" target="#b7">[13]</ref> (WS) <ref type="bibr" target="#b24">[30]</ref>, the RMAT generator <ref type="bibr" target="#b17">[23]</ref>, and a power-law graph generator with clustering (PL) <ref type="bibr" target="#b12">[18]</ref>. Three of the synthetic datasets, BA, WS, and PL were created with the NetworkX python package. For each model, we created a degree distribution with average degree O(log n) (average degree of 10 edges for 1,000 nodes, 13 for 10,000, and 25 for 50,000). This fully specifies the BA model. The datasets were chosen to balance both size and variety. All are small enough so that we can find offline solutions with METIS so that our results are reproducable, while still big enough to capture the asymptotic behavior of these graph types. The collection captures a variety of real graphs, focusing on finite-element meshes (FEM) and power-law graphs. FEMs are used for scientific computing purposes to model simulations like the flow over a wing, while power-law (and other heavy-tailed) distributions capture nearly all 'natural' graphs, like the World Wide Web, social networks, and protein networks. In general, it is known that FEMs have good partitions because their edges are highly local, while natural graphs are more difficult to partition because they have high expansion and low diameter. The basic statistics about each graph, as well as its type and source are in Table <ref type="table" target="#tab_0">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Methodology</head><p>We examined all the combinations of datasets, heuristics and steam orders and ran each experiment 5 times on each combination. The Random ordering is a random permutation of the vertices, while BFS and DFS were created by sampling a random vertex to be the root of the BFS or DFS algorithm. Each of the heuristics was run on the same ordering. We ran each experiment on 2, 4, 8, and 16 partitions and fixed the imbalance such that no partition held more than 5% more vertices than its share. The imbalance was chosen as a reasonable setting of this parameter in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION RESULTS</head><p>In all of the following figures, the y-axis has been scaled to zoom in on the data. The ordering of the heuristics in the figures is the one given in Table <ref type="table" target="#tab_1">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Upper and lower bounds</head><p>In order to evaluate the quality of our heuristics, we must establish good upper and lower bounds for the performance. A natural upper bound is the approach currently used in practice -hashing the node ID and mapping it to a partition. This approach completely ignores the edges so its expected performance is cutting a k−1 k fraction of edges for k partitions. This bound is marked by the upper black line in our figures. We expect Balanced and Hashing to always perform at this level, as well as Chunking on a random order.</p><p>The lower bound can be picked in many more ways. Finding an optimal lower bound is NP-hard, so we focus on more realistic approaches. We compare against a practical and fast approach, the partition produced by METIS v4.0.3. While METIS has no theoretical guarantees, it is widely respected and produces good cuts in practice, and is thus a good offline comparison for our empirical work. This METIS value is marked as the lower black line in our figures. Note that METIS is given significantly more information than the streaming heuristics, so we would not expect them to produce partitioning of the same quality. Any heuristic between these two lines is an improvement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance on three graph types</head><p>We have included figures of the results for three of the graphs, a synthetic graph, a social network graph and a FEM with the goal of covering all three major types of graphs.</p><p>Figure <ref type="figure">1</ref> depicts the performance on the PowerLaw Clustered graph <ref type="bibr" target="#b12">[18]</ref> of size 1,000 with 4 partitions. This is one of our synthetic graphs where the model is intended to capture power law graphs observed in nature. The lower bound provided by METIS is 58.9% of the edges cut, while the upper bound for 4 partitions is 75%. The first heuristic, Avoid Big, is worse than a random cut. Linear Deterministic Greedy and Balance Big both perform very well for all 3 stream orderings. These each had a best average performance of 61.7% and 63.2% of the edges cut respectively, corresponding to 82% and 73% of the possible gain in performance. This gain was calculated as the fraction of edges cut by the random minus the fraction cut by the heuristic, divided by the fraction cut by a random cut minus the fraction cut by METIS ( random−heuristic random−METIS ). Figure <ref type="figure">2</ref> is our results for a social network, the Marvel Comics network <ref type="bibr" target="#b1">[7]</ref>, with 8 partitions. The Marvel network is synthetic, as it is the result of character interactions in books, but studies have shown it is similar to real social networks. The lower bound from METIS cuts only 32.2% of edges. The upper bound is 7/8 = 87.5% cut. The two heuristics at the upper bound level are Balanced and Hashing, with Chunking on the random order also performing poorly, as expected. Again, the best heuristic is Linear Deterministic Greedy, with 48%, 48.7% and 50.8% edges cut for the BFS, DFS and Random orderings respectively. This constitutes a gain of 71.3%, 70% and 66%.  Figure <ref type="figure">3</ref> contains the results for a FEM, 4elt [5], with 4 partitions. The change in graph structure gives us quite different results, not the least of which is that METIS now cuts only 0.7% of edges. The upper bound remains at 75%, providing a huge range for improvement. Surprisingly, Chunking performs extremely well here for the BFS and DFS orders, at 4.7% and 5.7% cut respectively. Translating into gain provides 94.7% and 93.3% of the optimal improvement. Chunking performs poorly on the Random order as expected. The other heuristic that performs well is Greedy EvoCut, obtaining 5.1% and 5% cuts for BFS and DFS respectively. Linear Deterministic Greedy obtains 9.4%, 20.3%, and 30.6% cuts for BFS, and Random respectively. In fact, all of the heuristics beyond Balanced Hashing are vast improvements. The BFS ordering is also a strict improvement for all approaches over the DFS and Random orderings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Performance on all graphs: discussion</head><p>We present the gain in the performance of each heuristic in Table <ref type="table" target="#tab_1">2</ref>, averaged over all datasets from Table <ref type="table" target="#tab_0">1</ref> (except for LiveJournal and Twitter) and all runs, for each ordering. The best heuristic is Linear Deterministic Greedy for all orderings, followed by Balance Big. Greedy EvoCut is also successful on the BFS and DFS orderings, but is computationally much more expensive than the other two approaches. Note that Balance Big is a combination of the Greedy and Balanced strategies, assigned based on node degree. There are universally bad heuristics, namely Prefer Big and Avoid Big. Both of these are significantly worse than Hashing.</p><p>We further restrict the results by type of graphs. As stated earlier, FEMs have good balanced edge cuts. For these types of graphs, no heuristic performed worse than the Hashing approach, and most did significantly better. For the BFS ordering, Linear Deterministic Greedy had an average 86.6% gain, with Deterministic Greedy closely behind at 84.2%. For the DFS ordering, the Greedy EvoCut approach performed best at 78.8%, with all 3 deterministic greedy approaches closely behind at 74.9% (exp), 74.8% (unweighted) and 75.8% (linear). Finally, as always, the Random ordering was the hardest, but Linear Deterministic Greedy was also the best with 63% improvement. No other method achieved more than 56%. The surprising result for FEMs is how well the Chunking heuristic performed: an 80% improvement for  BFS and 72% for DFS. This is a huge improvement for such a simple heuristic, although it is due to the topology of the networks and the fact that BFS is used in partitioning algorithms to find good cuts. When given a Random ordering, Chunking had only a 0.2% average improvement. The social networks results were more varied. Here, the Prefer Big and Avoid Big both have large negative improvements, meaning both should never be used for power law degree networks with high expansion. For all three orderings, Linear Deterministic Greedy was clearly the superior approach with 71% improvement for BFS nd 70% for DFS. The second best performance was from both Exponential Deterministic Greedy and Deterministic Greedy at 60.5% for BFS and 52.9% for DFS. Finally, for a Random ordering, Linear Deterministic Greedy achieved a 64% improvement, with the other greedy approaches at only 42%.</p><p>Given that the Linear Deterministic Greedy algorithm performed so well, even compared with the other variants, one may ask why. At a high level, the penalty functions form a continuum. The unweighted version has a very strict cutoff -the penalty only applies when the partition is full and gives no indication that this restriction is approaching. The exponential penalty function has similar performance to the unweighted version because while the exponential function does not indicate that the partition is nearly full until it is very close to the limit. The linear weighting optimally balances the greedy choices with preferring less loaded partitions. Since 1 − x ≈ e −x when 0 &lt; x &lt; 1, the linear weighting can be seen as a normalized exponential weighting. This normalization term allows the penalty to take effect much earlier in the process and smooths the information by preventing the size of the partition from affecting the prediction. As this is a continuum, this parameter could be further fine-tuned for different types of graphs. Additionally, the implementation of the unweighted greedy algorithm in this paper breaks ties lexicographically. Breaking ties by load is equivalent to an indicator penalty function and its performance is very close to the linear penalty function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Scalability in the graph size</head><p>All of our datasets discussed so far are tiny when compared with graphs used in practice. While the above results are promising, it is important to understand whether the heuristics scale with the size of the graph. We used the synthetic datasets in order to control for the variance in different graphs. The key assumption is that using the same generative model with similar parameter settings will guarantee similar graph statistics while allowing the number of edges and nodes to vary. We began by looking at the results for the four generative models, BA, RMAT, WS, and PL. For each of these we had 3 data points: 1,000 vertices, 10,000 vertices, and 50,000 vertices. In order to get a better picture, we created additional graphs with 20,000, 30,000, 100,000 and 200,000 vertices. We will present only the results for the Watts-Strogatz graphs, but all other graphs exhibit quite similar results. Note that these results will scale to any size graph created by the same generative model because of the statistical properties of the generated graphs.</p><p>The labels in Figure <ref type="figure" target="#fig_2">4</ref> have been elided for clarity of the image. The bottom black line is METIS. This shows that our idea that the fraction of edges cut should scale with the size of the graph holds -it is approximately 12% for each graph. Next, there is clearly a best heuristic for this type of graph, the purple line. It corresponds to the Linear Deterministic Greedy heuristic. It has an average edge cut of 21% over all sizes of the graphs. Finally, all of the lines are approximately constant. The noise in the performance of each algorithm is due to the random nature of the orderings, and would decrease with further trials.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Scalability in the number of partitions</head><p>The other question is how the partitioning quality scales with the number of partitions. The fraction of edges cut must necessarily increase as we increase the number of partitions. Also, we are not trying to find an optimal number of partitions for the graph. As before, we only present data on one graph in Figure <ref type="figure" target="#fig_4">5</ref>, the 50,000 node PowerLaw Clustered graph, but all graphs have similar characteristics. The heuristics performance closely tracks that of METIS.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RESULTS ON A REAL SYSTEM</head><p>After evaluating the performance of the partitioning algorithms, we naturally ask whether the improvement in the partitioning makes any measurable difference for real computations. To evaluate our partitioning scheme in a cluster application, we used an implementation of PageRank in Spark <ref type="bibr" target="#b26">[32]</ref>, a cluster computing framework for iterative applications. Spark provides the ability to keep the working set of the application (the graph topology and PageRank values) in memory across iterations, so the algorithm is primarily limited by communication between nodes. Other recent frameworks for large-scale graph processing, like Pregel <ref type="bibr" target="#b19">[25]</ref> and GraphLab <ref type="bibr" target="#b18">[24]</ref>, also keep data in memory and are expected to exhibit similar performance characteristics.</p><p>There are many graph algorithms implemented for the Spark system, but we chose PageRank for two reasons. One is the popularity of this specific algorithm, and the other is its generality. PageRank is a specialized matrix multiplication, and many graph algorithms can be expressed similarly. Additionally, Spark has two implementations of PageRank: a naïve version that sends a message on the network for each edge, and a more sophisticated combiner version that aggregates all messages between each partition <ref type="bibr" target="#b25">[31]</ref>.</p><p>We used Linear Deterministic Greedy, as it performed best in our previous experiments. We tried both a vertex balanced version and an edge-balanced version. However, our datasets are social networks and follow a power-law degree distribution. For PageRank, the quantity that should be balanced is the number of edges in each partition as this controls the amount of computation performed in sparse matrix multiplication and we want this to be equal for all partitions. The existence of very high degree nodes means that some partitions contain many more edges than others, resulting in unbalanced computation times between the different cluster machines. We therefore modified Linear Deterministic Greedy to use the number of edges in a partition for the weight penalty. We used two datasets, LiveJournal <ref type="bibr" target="#b20">[26]</ref> with 4.6 million nodes and 77.4 million edges, and Twitter <ref type="bibr" target="#b15">[21]</ref> with 41.7 million nodes and 1.468 billion edges. While neither are Internet scale, they are both realistic for medium sized web systems and large enough to show the effects of reduced communication on a distributed computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LiveJournal.</head><p>We used 100 partitions, with imbalance of 2% and the stream order provided by the authors of the dataset which is an unknown ordering. Linear Deterministic Greedy reduced the number of edges cut to 47,361,254 edges compared with 76,234,872 for Hashing. We ran 5 iterations of both versions of PageRank, and repeated this experiment 5 times. With the improved partitioning, naïve PageRank was 38.7% faster than the hashed partitioning version.The timing information, along with standard deviations, is summarized in Table <ref type="table" target="#tab_3">3</ref>. We used 10 "large" machines (7.5GB memory and 2 CPUS) on Amazon's EC2. The combiner version with our partitioning was 28.8% faster than the hashed version. This reduction in computation time is obtained entirely by laying out the data in a slightly smarter way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Twitter.</head><p>We repeated the experiment for Twitter <ref type="bibr" target="#b15">[21]</ref>. This graph is one of the largest publicly available datasets. Twitter was partitioned into 400 pieces with a maximum imbalance of 2%. Linear Deterministic Greedy cut 1.341 billion edges, while Hashing cut 1.464 billion. We used 50 "large" machines with 100 cores. The total computation time is much longer These results show that with very little engineering effort, a simple preprocessing step that considers the graph edges can yield a large improvement in the running time. The best heuristic can be computed for each arriving node in time that is linear in the number of edges, given access to the distributed lookup table for the cluster and knowledge of the current loads of the machines. The improvement in running time is entirely due to the reduced network communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS AND FUTURE WORK</head><p>We have demonstrated that simple, one-pass streaming graph partitioning heuristics can dramatically improve the edge-cut in distributed graphs. Our best performing heuristic is the linear weighted variant of the greedy algorithm. This is a simple and effective preprocessing step for large graph computation systems, as the data must be loaded onto the cluster any way. One might need to perform a full graph partitioning once the graph has been fully loaded, however, as it will be re-partitioning an already partitioned graph, there will be less communication cost and it potentially may need to move fewer vertices, and will be faster. Using our approach as preprocessing step can only benefit any future computation while incurring only small cost.</p><p>There are several future directions for our work. First, there is the theoretical work. A framework should be developed for proving the performance of these heuristics. The main complications are the addition of the BFS and DFS stream orderings, and the fact that the offline optimal solution is NP-hard to compute. However, the best heuristic also performed well on the Random ordering, so it may be possible to prove a bound on its performance with additional assumptions like the graph is generated by a specific model.</p><p>The second direction is to address using parallel loaders. In reality, using a single machine to load terabytes of data will be far too slow. We expect the performance of running parallel loaders on independent portions of the graph stream to be similar to our experiments, requiring only access to the distributed lookup table.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>For WS and PL we used .1 as the rewiring probability. The RMAT datasets were created with the Python Web Graph Generator, a variant of the RMAT generator [2]. The RMAT or Kronecker parameters used by this implementation are [0.45,0.15;0.15,0.25].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :Figure 2 :Figure 3 :</head><label>123</label><figDesc>Figure 1: PL1000 results. The top line is the cost of a random cut and the bottom line is METIS. The best heuristic is Linear Deterministic Greedy. The figures are best viewed in color.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: BFS with 4 partitions. Each line is a heuristics performance over 7 sizes of WS graph. The bottom line is METIS. The bottom purple line is Linear Deterministic Greedy. Best viewed in color.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>of Partitions Heuristic performance over the PL Graph with 50,000 nodes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: BFS with 2-64 partitions. Each line connects a heuristics performance over the 6 partition sizes. The bottom line is METIS. The bottom purple line is Linear Deterministic Greedy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Graph datasets summary</head><label>1</label><figDesc></figDesc><table><row><cell>, Watts-Strogatz</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 : The average gain of each heuristic over all of our datasets and partitions sizes.</head><label>2</label><figDesc></figDesc><table><row><cell>Heuristic</cell><cell></cell><cell cols="3">BFS DFS Random</cell></row><row><cell>Avoid Big</cell><cell>AB</cell><cell cols="2">-27.3 -38.6</cell><cell>-46.4</cell></row><row><cell>Balanced</cell><cell>B</cell><cell>-1.5</cell><cell>-1.3</cell><cell>-0.2</cell></row><row><cell>Prefer Big</cell><cell>PB</cell><cell cols="2">-9.5 -18.6</cell><cell>-23.1</cell></row><row><cell>Chunking</cell><cell>C</cell><cell>37.6</cell><cell>35.7</cell><cell>0.7</cell></row><row><cell>Deterministic Greedy</cell><cell>DG</cell><cell>57.7</cell><cell>54.7</cell><cell>45.4</cell></row><row><cell>Exp. Det. Greedy</cell><cell>EDG</cell><cell>59.4</cell><cell>56.2</cell><cell>47.5</cell></row><row><cell>Exp. Rand. Greedy</cell><cell>ERG</cell><cell>45.6</cell><cell>45.6</cell><cell>38.8</cell></row><row><cell>Exp. Triangles</cell><cell>ET</cell><cell>50.7</cell><cell>49.3</cell><cell>41.6</cell></row><row><cell>Greedy EvoCut</cell><cell>GE</cell><cell>60.3</cell><cell>58.6</cell><cell>43.1</cell></row><row><cell>Hashing</cell><cell>H</cell><cell>-1.9</cell><cell>-2.1</cell><cell>-1.7</cell></row><row><cell>Linear Det. Greedy</cell><cell>LDG</cell><cell>76</cell><cell>73</cell><cell>75.3</cell></row><row><cell cols="2">Linear Rand. Greedy LRG</cell><cell>46.4</cell><cell>44.9</cell><cell>39.1</cell></row><row><cell>Linear Triangles</cell><cell>LT</cell><cell>55.4</cell><cell>54.6</cell><cell>49.3</cell></row><row><cell>Randomized Greedy</cell><cell>RG</cell><cell>45.5</cell><cell>44.9</cell><cell>38.7</cell></row><row><cell>Balance Big</cell><cell>BB</cell><cell>67.8</cell><cell>68.5</cell><cell>63.3</cell></row><row><cell>Triangles</cell><cell>T</cell><cell>49.7</cell><cell>48.4</cell><cell>40.2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 : Timing data (mean and standard devia- tion) for 5 iterations of PageRank computation on Spark for LiveJournal and Twitter graphs, Hashing vs. Linear Deterministic Greedy. due</head><label>3</label><figDesc>to the increase in size. The naïve PageRank was 19.1% faster with our partitioning while the combiner version was 18.8% faster. For both graphs, there was additional time associated with loading the graph, about 200 seconds for Twitter and 80 seconds for LiveJournal, but this was not affected by the partitioning method.</figDesc><table><row><cell></cell><cell>LJ Hash</cell><cell>LJ Streamed</cell></row><row><cell>Naïve PR Mean</cell><cell>296.2s</cell><cell>181.5s</cell></row><row><cell>Naïve PR STD</cell><cell>5.5 s</cell><cell>2.2 s</cell></row><row><cell>Combiner PR Mean</cell><cell>155.1 s</cell><cell>110.4 s</cell></row><row><cell>Combiner PR STD</cell><cell>1.5 s</cell><cell>0.8 s</cell></row><row><cell></cell><cell cols="2">Twitter Hash Twitter Streamed</cell></row><row><cell>Naïve PR Mean</cell><cell>1199.4 s</cell><cell>969.3 s</cell></row><row><cell>Naïve PR STD</cell><cell>81.2 s</cell><cell>16.9 s</cell></row><row><cell>Combiner PR Mean</cell><cell>599.4 s</cell><cell>486.8 s</cell></row><row><cell>Combiner PR STD</cell><cell>14.4 s</cell><cell>5.9 s</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Graph sparsification in the semi-streaming model</title>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Jin</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICALP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Alberich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Miro-Julia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rossello</surname></persName>
		</author>
		<title level="m">Marvel universe looks almost like a real social network</title>
				<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Local graph partitioning using pagerank vectors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
				<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Finding sparse cuts locally using evolving sets</title>
		<author>
			<persName><forename type="first">R</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Peres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
				<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Balanced graph partitions. Theory of Computing Systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Andreev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Racke</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="929" to="939" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Expander flows, geo -metric embeddings and graph partitioning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Vazirani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.ACM</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fast incremental and personalized pagerank</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bahmani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="173" to="184" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Emergence of scaling in random networks</title>
		<author>
			<persName><forename type="first">A-L</forename><surname>Barabasi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Albert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">286</biblScope>
			<biblScope unit="issue">5439</biblScope>
			<biblScope unit="page" from="509" to="512" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">PMRSB: Parallel multilevel recursive spectral bisection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Barnard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing</title>
				<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Orleans: Cloud computing for everyone</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bykov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Geller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kliot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Larus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pandya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Thelin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Cloud Computing</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast approximate graph partitioning algorithms</title>
		<author>
			<persName><forename type="first">G</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schieber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="2187" to="2214" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A multilevel algorithm for partitioning graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hendrickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Leland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing</title>
				<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Growing scale-free networks with tunable clustering</title>
		<author>
			<persName><forename type="first">P</forename><surname>Holme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Phys. Rev. E</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multilevel graph partitioning schemes</title>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICPP</title>
				<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="113" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Spectral sparsification in the semi-streaming setting</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kelner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">STACS</title>
		<imprint>
			<biblScope unit="page" from="440" to="451" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">What is Twitter</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
				<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<ptr target="http://snap.stanford.edu/snap" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Kronecker graphs: An approach to modeling networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>JMLR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">GraphLab: A new framework for parallel machine learning</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UAI</title>
				<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Pregel: a system for large-scale graph processing</title>
		<author>
			<persName><forename type="first">G</forename><surname>Malewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Austern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dehnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Czajkowski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>PODC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Measurement and analysis of online social networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mislove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marcon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gummadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bhattacharjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/USENIX IMC</title>
				<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The structure of scientific collaboration networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E J</forename><surname>Newman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Natl Acad Sci</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="404" to="409" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Sparse cut projections in graph streams</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Das</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gollapudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Panigrahy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESA</title>
				<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="480" to="491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Estimating pagerank on graph streams</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Das</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gollapudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Panigrahy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Collective dynamics of &apos;small-world&apos; networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Watts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Strogatz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">393</biblScope>
			<biblScope unit="page" from="440" to="442" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Resilient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mccauley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>NSDI</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Spark: Cluster Computing with Working Sets</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<editor>HotCloud</editor>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Intractability of min-and max-cut in streaming graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zelke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IPL</title>
		<imprint>
			<biblScope unit="volume">111</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="145" to="150" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
