<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Chisel: Reliability-and Accuracy-Aware Optimization of Approximate Computational Kernels</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Carbin</surname></persName>
							<email>mcarbin@csail.mit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Sara</forename><surname>Achour</surname></persName>
							<email>sachour@csail.mit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Zichao</forename><surname>Qi</surname></persName>
							<email>zichaoqi@csail.mit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Martin</forename><surname>Rinard</surname></persName>
							<email>rinard@csail.mit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Mit</forename><surname>Csail</surname></persName>
						</author>
						<title level="a" type="main">Chisel: Reliability-and Accuracy-Aware Optimization of Approximate Computational Kernels</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">387CE7C317A7E27D1F00524BA4A67BDD</idno>
					<idno type="DOI">10.1145/10.1145/2660193.2660231</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D</term>
					<term>3</term>
					<term>2 [Programming Languages]: Processors -Optimization</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The accuracy of an approximate computation is the distance between the result that the computation produces and the corresponding fully accurate result. The reliability of the computation is the probability that it will produce an acceptably accurate result. Emerging approximate hardware platforms provide approximate operations that, in return for reduced energy consumption and/or increased performance, exhibit reduced reliability and/or accuracy.</p><p>We present Chisel, a system for reliability-and accuracyaware optimization of approximate computational kernels that run on approximate hardware platforms. Given a combined reliability and/or accuracy specification, Chisel automatically selects approximate kernel operations to synthesize an approximate computation that minimizes energy consumption while satisfying its reliability and accuracy specification.</p><p>We evaluate Chisel on five applications from the image processing, scientific computing, and financial analysis domains. The experimental results show that our implemented optimization algorithm enables Chisel to optimize our set of benchmark kernels to obtain energy savings from 8.7% to 19.8% compared to the original (exact) kernel implementations while preserving important reliability guarantees.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Emerging approximate hardware platforms provide operations that, in return for reduced energy consumption, may produce less accurate and/or incorrect results <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b35">36]</ref>.</p><p>Target application domains include computations that either 1) contain approximate components that naturally tolerate some percentage of inaccurate and/or incorrect operations, or 2) come with efficient checkers that can detect an unacceptably inaccurate result and enable the application to recompute the result if desired. Examples of such application domains include machine learning, multimedia, information retrieval, scientific, and financial analysis applications. Many of these applications have one or more approximate computational kernels that consume the majority of the execution time <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b25">26]</ref>.</p><p>In previous work, we developed Rely <ref type="bibr" target="#b6">[7]</ref>, a language for expressing and analyzing computations that run on approximate hardware platforms. These hardware platforms provide reliable and unreliable versions of standard arithmetic and logical instructions as well as reliable and unreliable memories. Rely enables a developer to manually identify unreliable instructions and variables that can be stored in unreliable memories. The developer also provides a reliability specification, which identifies the minimum required probability with which the kernel must produce a correct result. The Rely analysis then verifies that, with the identified unreliable instructions and variables, the kernel satisfies its reliability specification for all inputs.</p><p>Rely requires the developer to navigate the tradeoff between reliability and energy savings (because the developer is responsible for identifying the unreliable operations and data). But the developer must redo this identification every time the computation is ported to a new approximate hardware platform with different reliability and energy characteristics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Chisel</head><p>We present Chisel, a new optimization framework that automatically selects approximate instructions and data that may be stored in approximate memory, given the exact kernel computation and the associated reliability and/or accuracy specification. Chisel automatically navigates the tradeoff space and generates an approximate computation that maximizes energy savings (according to an energy model for the hardware platform) while satisfying its combined reliability and accuracy specification. Chisel can therefore reduce the effort required to develop efficient approximate computations and enhance the portability of these computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Reliability and Accuracy Specifications</head><p>A Chisel program consists of code written in an implementation language (such as C) and kernel functions written in the Rely base language <ref type="bibr" target="#b6">[7]</ref>. The kernel function can compute the return value, but may also write computed values into array parameters passed by reference into the kernel. Reliability specifications of the form &lt;r*R(x1, ..., xn)&gt; are integrated into the type signature of the kernel. Here r specifies the probability that the kernel (in spite of unreliable hardware operations) computes the value correctly. The term R(x1, ..., xn) is a joint reliability factor that specifies the probability that x1,...,xn all have correct values at the start of the kernel. In the following specification, for example: int &lt;.99 * R(x)&gt; f(int[] &lt;.98*R(x)&gt; x);</p><p>the return value has reliability at least .99 times the reliability of x; when f returns, the probability that all elements in the array x (passed by reference into f) have the correct value is at least .98 times the reliability of x at the start of f.</p><p>Chisel also supports combined reliability and accuracy specifications of the following form (these specifications are relational in that they specify the combined accuracy and reliability with respect to the fully accurate exact computation): Here d is a maximum acceptable difference between the approximate and exact result values, r is the probability that the kernel computes a value within d of the exact value, and the term R(d1 &gt;= D(x1), ..., dn &gt;= D(xn)) is a joint reliability factor that specifies the probability that each xi is within distance di of the exact value at the start of the computation. If r=1, then the specification is a pure accuracy specification; if d=0 and all the di=0, then the specification is a pure reliability specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Reliability-and Accuracy-Aware Optimization</head><p>Chisel reduces the problem of selecting approximate instructions and variables allocated in approximate memories to an integer linear program whose solution minimizes an objective function that models the energy consumption of the kernel. The integer linear program also contains reliability and/or accuracy constraints that ensure that the solution satisfies the specification. For each instruction in the kernel, Chisel specifies a zero-one valued configuration variable that indicates whether the instruction should be exact (zero) or approximate (one). To generate the optimization objective, Chisel uses the execution traces of the kernel on representative inputs. To generate the constraints, Chisel statically analyzes the kernel.</p><p>A solution to the integer linear program provides a configuration of the kernel computation that minimizes energy consumption while satisfying the specification.</p><p>Chisel works with a hardware specification provided by the designers of the approximate hardware platform <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b35">36]</ref>. This specification gives Chisel the hardware parameter values it needs to optimize the approximate computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Sensitivity Profiling</head><p>To help the developer obtain appropriate reliability and accuracy specifications, Chisel provides an optional sensitivity profiler. The profiler works with an end-to-end sensitivity metric, which compares the end-to-end results of the exact and approximate executions of the Chisel program to define the acceptability requirements for the outputs that the program produces. Specifically, the difference between the exact and approximate executions must be below a specified sensitivity bound. A sensitivity profiler (which performs function-level noise injection to estimate the sensitivity of the program's result to noise in the results that the kernel computes) can help the developer identify specifications that produce acceptable end-to-end results.  The developer provides the Chisel program along with reliability and/or accuracy specifications for the approximate kernels (optionally obtaining these specifications via sensitivity profiling on representative inputs). The hardware designer provides a hardware specification, which specifies the reliability and accuracy information for individual instructions and approximate memory. Chisel analyzes the kernels, generates the integer linear program (we use the Gurobi solver <ref type="bibr" target="#b14">[15]</ref>), then uses the solution to generate approximate code that satisfies its specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6">Contributions</head><p>The paper makes the following contributions:</p><p>• Specification Language: It presents the Chisel reliability and accuracy specification language. Chisel specifications are integrated into the type signatures of Chisel kernel functions and enable the developer to state the probabilistic reliability and/or accuracy constraints that approximate implementations of kernels must satisfy for the Chisel program to produce acceptable end-to-end results. • Optimization Algorithm. It presents the Chisel optimization algorithm, which reduces the problem of selecting approximate instructions and data (which can be stored in approximate memories) to an integer linear program that minimizes energy consumption while satisfying the reliability and/or ac-curacy specification. This algorithm automates the navigation of the reliability and accuracy versus energy consumption tradeoff space. It also eliminates the need to manually develop different approximate implementations for different hardware platforms.  The function scale takes as input the scaling factor f (which increases the image size in both dimensions), along with integer arrays src, which contains the pixels of the image to be scaled, and dest, which contains the pixels of the resulting scaled image. The algorithm calculates the value of each pixel in the final result by mapping the pixel's location back to the original source image and then taking a weighted average of the neighboring pixels. The code for scale implements the outer portion of the algorithm, which enumerates over the pixels in the destination image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Example</head><p>The function scale kernel implements the core kernel of the scaling algorithm. The algorithm computes the location in the array src of the pixel's neighboring four pixels (Lines 4-5), adjusts the locations at the image edges (Lines 7-14), and fetches the pixels (Lines 16-19). To average the pixel values, the algorithm uses bilinear interpolation. Bilinear interpolation takes the weighted average of the four neighboring pixel values. The weights are computed as the distance from the source coordinates i and j to the location of each of the pixels (Lines 21-24). In the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Sensitivity Profiling</head><p>Chisel's sensitivity profiler assists the developer in deriving the reliability specification of the kernel. The sensitivity profiler takes these three inputs from the developer:</p><p>• Sensitivity Metric. A function that compares the outputs of the original and approximate executions. It produces a numerical value that characterizes the difference between the two outputs. For computations that produce images, such as scale, a typically used metric is Peak-Signal-to-Noise Ratio (PSNR).  Chisel's sensitivity profiler automatically explores the relation between the probability of approximate execution and the quality of the resulting image for the set of representative images. Conceptually, the profiler transforms the program to execute the correct implementation of scale kernel with probability r, which represents the target reliability. The framework executes the faulty implementation scale kernel with errors with probability 1r. The framework uses binary search to find the probability r that causes the noisy program execution to produce results with acceptable PSNR. The profiler can also plot the quality of the result as a function of r.</p><p>Figure <ref type="figure" target="#fig_4">3</ref> presents a visual depiction of the results of scaling for different values of r. Note that implementations with low reliability (0.20-0.80) do not produce acceptable results. However, as r reaches values in the range of 0.99 and above, the results become an acceptable approximation of the result of the original (exact) implementation. For the remainder of this section, we use 0.995 as scale kernel's target reliability, which yields images with an average PSNR of 30.9 dB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Reliability Specification</head><p>The derived reliability specification for the kernel is:</p><formula xml:id="formula_0">int&lt;0.995 * R(i, j, src, s_height, s_width)&gt; scale_kernel (float i, float j, int[] src, int s_height, int s_width);</formula><p>The reliability specification of scale kernel appears as part of the type signature of the function. The additional reliability information 0.995 * R(i, j, src, s height, s width) specifies the reliability of the return value:</p><p>• Input Dependencies. The reliability of the return value is a function of the reliability of the function's inputs. The term R(i, j, src, s height, s width) represents the joint reliability of the inputs on entry to the function, which is the probability that they all together contain the correct result. • Reliability Degradation. The coefficient 0.995 expresses the reliability degradation of the function. Specifically, the coefficient is the probability that the return value is correct given that all input variables have the correct values on entry to the function. Since the specification does not explicitly state the acceptable absolute difference, it is by default d=0. Therefore, whenever the computation executes without errors, it should produce an exact result. Arrays. The Rely base language contains annotations on the array parameters that specify that it is allocated in approximate memory. For instance, the following signature of scale kernel would state that the pixel array src is in an approximate memory region named urel: int&lt;...&gt; scale_kernel (..., int[] src in urel, ...);</p><p>To generate such annotations, Chisel explores the possibility that the array passed as a src parameter may be allocated in the approximate memory. Specifically, Chisel's optimization problem encodes both alternatives, i.e., when src is allocated in an exact memory and when it is allocated in an approximate memory. Chisel will report to the developer whether this alternative allocation strategy (which may save additional energy) still satisfies the reliability specification. The developer can then annotate the array's allocation statement to indicate that the compiler or the runtime system should allocate the array in an approximate memory. Lower Bound on Sensitivity Metric. Starting with a reliability specification for our example kernel, it is also possible to obtain an analytic lower bound for the sensitivity metric. Specifically, the PSNR for the exact resulting image d and the approxi-</p><formula xml:id="formula_1">mate image d is PSNR(d,d )=20•log 10 (255)- 10•log 10   1 3hw h i=1 w j=1 c∈{R,G,B} (dijc-d ijc ) 2   .</formula><p>The constants h and w are the height and width of the image and R, G, and B are the color components of a pixel. Each color component is a value between 0 and 255. The kernel computation computes the value of d ijc for all three RGB components correctly with probability r. In this case, For a reliability specification r = 0.995, we can obtain that the expected PSNR is greater than 23.01 dB for any image (and for the typical images used in profiling it is greater than 30.9 dB).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Hardware Specification</head><p>To automatically optimize the implementation of the computation, the optimization algorithm requires a hardware specification of the approximate hardware, consisting of: Operation and Memory Reliability. The hardware specification identifies 1) approximate arithmetic operations and 2) the approximate regions of the main and cache memories. The specification contains the reliability and (optionally) the accuracy loss of each arithmetic operation. It also contains the probability that read and write operations to approximate main memory and cache complete successfully. Energy Model Parameters. To compute the savings associated with selecting approximate arithmetic operation, the energy model specifies the expected energy savings of executing an approximate version (as a percentage of the energy of the exact version). To compute the savings associated with allocating data in approximate memory, the energy model specifies the expected energy savings for memory cells.</p><p>To compute system energy savings, the energy model also provides 1) a specification of the relative portion of the system energy consumed by the CPU versus memory, 2) the relative portion of the CPU energy consumed by the ALU, cache, and other on-chip resources, and 3) the ratio of the average energy consumption of floating-point instructions and other nonarithmetic instructions relative to integer instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Optimization Results</head><p>Chisel generates expressions that characterize the energy savings and reliability of scale kernel. These expressions are parameterized by an unknown configuration of the approximate kernel, which specifies which operations and array parameters may be approximate or must be exact. This configuration is the solution to the optimization problem. For the hardware platforms in Section 9, the optimization algorithm delivers 19.35% energy savings, which is over 95% of the maximum possible energy savings for this computation (which occurs when the reliability bound is zero, and therefore all operations and the src and dest arrays can be approximate).</p><p>When the result of the function is assigned directly to an array variable, like in the case of the dest array, the optimization treats this variable (unless specified otherwise by the developer) as another array parameter of the kernel function that can be specified as approximate. Chisel identifies both src and dest arrays as potentially approximate. Chisel also identifies around 20% of the arithmetic operations as approximate. These operations are in the part of the computation that performs bilinear interpolation. For instance, the assignment to the variable lr w on line 24 uses the inexact multiplication operation "*.".</p><p>Identifying the kernel's array parameters as approximate informs the developer that the kernel can satisfy its reliability specification with the array allocated in approximate memory. Given this information, the developer can use a predefined API call at the array allocation site to allocate the array in approximate memory across the entire application.</p><p>Final Sensitivity Validation. Using the specified sensitivity bound and metric, the framework can evaluate the generated approximate kernel computation on a set of (previously unseen) production inputs. For our example benchmark, the average PSNR on a set of production inputs is 32.31 dB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Hardware Specification and Semantics</head><p>The code of scale in Section 2 illustrates the syntax of the Rely base language, which is a pointer-less C-like language with first-class one-dimensional arrays and reliability specifications.</p><p>In this section, we present a hardware model and a compilation model for Chisel that captures the basic properties of approximate hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Hardware Specification</head><p>We consider a single-CPU architecture that exposes an ISA with approximation extensions and an approximate memory hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Syntax</head><p>Figure <ref type="figure" target="#fig_6">4</ref> presents the abbreviated syntax of the assembly language of the architecture.</p><p>Operands. Each operand is either a register r ∈ R or a fixed N-bit (e.g., 32-bit or 64-bit) integer n ∈ Int N . Floating point numbers are integers coded with the IEEE 754 representation.</p><p>Instructions. Each instruction i ∈ I is either an ALU/FPU arithmetic operation (such as add, multiply and compare), a conditional branch to an address (jmp), or a load/store from memory (load and store).</p><p>Each arithmetic instruction also has a kind κ ∈ K = {0,1} -such as r =add κ r 1 r 2 -that indicates that the instruction is either exact (κ=0) -and always produces the correct result -or approximate (κ = 1) -and may therefore produce an incorrect result with some probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Hardware Specification</head><p>The reliability portion of the hardware specification ψ ∈(Op→ R) × (R × R) × (R × R) is a triple of structures that specify the reliability of instructions, the approximate memory region, and the approximate cache region, respectively. In Sections 6.1 and 7.1, we extend the hardware specification to include the hardware's accuracy and energy parameters, respectively. Instructions. The projection π op selects the first element of the hardware specification, which is a finite map from operations to reliabilities. The reliability of an operation is the probability that the operation executes correctly. Memories. The hardware exposes an exact main memory region and an approximate memory region. The projection π mem selects the second element of the hardware specification, which is a pair of reliabilities (r ld , r st ) that denote the reliability of loading and storing a value in the approximate memory region, respectively. Caches. The hardware exposes an exact cache and an approximate cache. The projection π $ selects the third element of the hardware specification, which is a pair of reliabilities (r ld ,r st ) that denote the reliability of loading and storing a value in the approximate cache, respectively.</p><formula xml:id="formula_2">ALU/FPU-C p=ψ(op) κ r =op κ r 1 r 2 , σ,m C,p -→ γ,ψ,ξ •, σ[r →op(σ(r 1 ),σ(r 2 ))],m ALU/FPU-F p=(1-πop(ψ)(op))•P f (n|op,σ(r 1 ),σ(r 2 )) r =op 1 r 1 r 2 , σ,m F,n ,p -→ γ,ψ,ξ •, σ[r →n],m</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Hardware Semantics</head><p>Register Files, Memories, Memory Configurations, Programs, and Environments. A register file σ ∈Σ=R→Int N is a finite map from registers to machine integers. A memory m ∈ M = A → Int N is a finite map from addresses to machine integers. A memory configuration ξ ∈ Ξ = A → K, maps an address a to a kind κ that designates whether the memory at a is configured as exact (κ=0) or approximate (κ=1). A program γ ∈Γ=A→I is a finite map from addresses to instructions. An environment ε∈E=Σ×M is a register file and memory pair.</p><p>Ready Instructions and Configurations. A ready instruction î ∈ Î := i | • is either an instruction i ∈ I or the distinguished element "•" that indicates that the next instruction needs to be fetched from memory (as determined by the pc register). A configuration î,ε is a ready instruction and environment pair. Errant Result Distributions. The discrete probability distribution P f (n f | op,n 1 ,n 2 ) models the manifestation of an error during an incorrect execution of an operation. Specifically, it gives the probability that an incorrect execution of an operation op on operands n 1 and n 2 produces a value n f different from the correct result of the operation. Arithmetic Instructions. Figure <ref type="figure" target="#fig_7">5</ref> presents the inference rules for arithmetic operations. We present the remaining rules in Section A of the Appendix <ref type="bibr" target="#b21">[22]</ref>. The small-step judgment î,ε</p><formula xml:id="formula_3">λ,p -→ γ,ψ,ξ</formula><p>î ,ε denotes that execution of the program γ from the configuration î,ε under a hardware model ψ and a memory configuration ξ takes a transition with label λ with probability p, yielding a configuration î ,ε .</p><p>A transition label λ ∈ {C, F,n } characterizes whether the transition executed correctly (C) or experienced a fault ( F,n ). The value n in a faulty transition records the value that the fault inserted into the semantics of the program. The semantics of an arithmetic operation r =op κ r 1 r 2 takes one of two possibilities:</p><p>• Correct execution [ALU/FPU-C]. An operation executes correctly with probability π op (ψ)(op) κ . Therefore, if the operation is exact (κ=0) it executes correctly with probability 1. If it is approximate (κ=1), then it executes correctly with probability π op (ψ)(op).</p><p>A correct execution proceeds with the rule [ALU/FPU-C] wherein the instruction reads registers r 1 and r 2 from the register file, performs the operation, and then stores the result back in register r.</p><formula xml:id="formula_4">• Faulty execution [ALU/FPU-F].</formula><p>An operation with a kind κ=1 experiences a fault with probability 1-π op (ψ)(op). A faulty execution stores into the destination register r a value n that is given by the errant result distribution for the operation, P f . Note that while the instruction may experience a fault, its faulty execution does not modify any state besides the destination register.</p><p>Control Flow. Control flow transfer instructions, such as jmp, always correctly transfer control to the destination address.</p><p>Preserving the reliability of control flow transfers guarantees that an approximate program always takes paths that exist in the static control flow graph of the program. We note that while control flow transfers themselves execute correctly, the argument to a control transfer instruction (e.g., the test condition of a jmp) may depend on approximate computation. Therefore, an approximate program may take a path that differs from that of the original (exact) program.</p><p>Loads and Stores. The semantics of loads and stores are similar to arithmetic operation semantics in that each operation can either execute correctly or encounter a fault. The memory configuration ξ determines if an accessed address's memory region is exact (all operations on the region execute correctly) or approximate (operations may encounter a fault). As with the destination register of arithmetic operations, if a store instruction encounters a fault, then only the contents of the destination address are modified. Data stored in the approximate memory region may be placed in the approximate cache. We conservatively model the cache as a buffer that affects the probability of correctly executing load and store operations. We discuss the cache's semantics in Section A.2 of the Appendix <ref type="bibr" target="#b21">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Compilation and Runtime Model</head><p>Data Layout. The compilation and runtime system stores the program's instructions and the stack in the exact memory region. The system represents arrays with a header and a separately allocated chunk of memory that contains the array's data. The header contains the length of the array's data and the address of the array's data in memory. The system allocates the header in exact main memory and allocates the data chunk in either exact or approximate memory based upon Chisel's optimization results. This allocation strategy enables the system to separate the reliability of the array's metadata from the reliability of the data stored in the array.</p><p>To support our formalization of reliability, we define a variable allocation υ ∈ V → P(A) as a finite map from a program variable v ∈ V to the address (or set of addresses in the case of an array) in memory at which the variable has been allocated by the compilation and runtime system. Array Loads/Stores. The compilation system uses the bounds information of each array to provide a failure oblivious <ref type="bibr" target="#b33">[34]</ref> semantics for array loads and stores. Specifically, the compiled program includes a bounds check for each access. If an index for a load is out of bounds, then the check returns an arbitrary value for the load. If the access is a store, then the check elides the write to the array. This semantics enables Chisel-optimized programs to continue executing even if an array access is out-of-bounds due to approximation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Preliminary Definitions</head><p>We next present several definitions that enable us to precisely specify the configuration of approximate programs along with their reliability, accuracy, and energy consumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Configurable Approximate Programs</head><p>We augment our program representation to create an intermediate representation that includes labels, where each label ∈ L is uniquely associated with an instruction or a program variable. Labels enable Chisel to separately mark each instruction and variable as either exact or approximate.</p><p>Instructions. We augment each arithmetic instruction to have a label instead of a kind:</p><formula xml:id="formula_5">i∈I ::= r =op r r</formula><p>Program Variables. We define the finite map χ∈V →L that maps each variable in the program to a unique label.</p><p>Kind Configurations. We also define a kind configuration θ ∈ Θ = L → K as a finite map from labels to kinds that denotes a selection of the kind (i.e., exact or precise) of each of the program's instructions and variables. The set of kind configurations denotes that set of all possible optimized programs that Chisel can generate. We also define the substitution γ[θ] as the program generated by substituting each label in the program γ by the corresponding kind given by θ (namely, θ( )).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Big-step Semantics</head><p>We use the following big-step semantics to later define an approximate program's reliability and accuracy.</p><p>Definition 1 (Big-step Trace Semantics). The big-step trace semantics is a reflexive transitive closure of the small-step execution relation that records a trace of the program's execution. A trace τ ∈ T ::= • | λ :: T is a sequence of small-step transition labels. The probability of a trace, p, is the product of the probabilities of each transition. The predicate final ⊆ ( Î × E) × Γ indicates that the program cannot make a transition from the configuration.</p><formula xml:id="formula_6">•,ε τ,p =⇒ γ,ψ,ξ ε ≡ •,ε λ 1 ,p 1 -→ γ,ψ,ξ ...</formula><p>Definition 2 (Big-step Aggregate Semantics).</p><formula xml:id="formula_7">•,ε p =⇒ γ,ψ,ξ ε where p= τ∈T pτ such that •,ε τ,pτ =⇒ γ,ψ,ξ ε</formula><p>The big-step aggregate semantics enumerates over the set of all finite length traces and sums the aggregate probability that a program γ starts in an environment ε and terminates in an environment ε given a hardware specification ψ and memory configuration ξ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Reliability Constraint Construction</head><p>Chisel generates optimization constraints via a precondition generator. Similar to Rely, Chisel's generator produces a precondition that if valid before the execution of the kernel, guarantees that the kernel produces acceptable outputs with reliability at least that given in its specification. Chisel then transforms the generated precondition into an optimization constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Reliability Predicates</head><p>Chisel's generated preconditions are reliability predicates that characterize the reliability of an approximate program. A reliability predicate P has the following form:</p><formula xml:id="formula_8">P :=R f ≤R f | P ∧P R f :=ρ | ρ | R(O) | R f •R f</formula><p>Specifically, a predicate is either a conjunction of predicates or a comparison between reliability factors, R f . A reliability factor is either a real number ρ, a kinded reliability ρ , a joint reliability factor R(O) of a set of register and variable operands O ⊆R∪V , or a product of reliability factors.</p><p>The denotation of a predicate P ∈ P(E × Φ × Θ × Υ) is the set of environment, approximate environment distribution, kind configuration, and variable allocation quadruples that satisfy the predicate. An environment distribution ϕ∈Φ=E→R is a probability distribution over possible approximate environments.</p><p>The denotation of a reliability factor R f ∈E×Φ×Θ×Υ→ R is the real-valued reliability that results from evaluating the factor for a given quadruple. For example, ρ (ε,ϕ,θ,υ)=ρ and ρ (ε,ϕ,θ,υ)= ρ (ε,ϕ,θ,υ) θ( ) . The denotation of R(O) is the probability that an approximate environment ε a sampled from ϕ has the same value for all operands in O as the environment ε:</p><formula xml:id="formula_9">R(O) (ε,ϕ,θ,υ)= εa∈E(ε,O,υ) ϕ(εa),<label>(1)</label></formula><p>where</p><formula xml:id="formula_10">E((σ,m),O,υ)= {(σa,ma)| ∀o. o∈R⇒σa(o)=σ(o) ∧ o∈V ⇒∀a∈υ(o). ma(a)=m(a)}.</formula><p>The function E(ε,O,υ) is the set of environments in which the values of all operands O are the same as in ε.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Semantics of Reliability</head><p>Given the semantics of reliability predicates, we define the reliability of an approximate program with a Hoare-triple-like semantics defined for the program's paired execution semantics: Definition 3 (Paired Execution Semantics).</p><formula xml:id="formula_11">•, ε,ϕ ⇓ θ,χ,υ γ,ψ ε ,ϕ such that •,ε τ,pr =⇒ γ[0 θ ],ψ,0 ξ ε and ϕ (ε a )= εa∈E ϕ(εa)•pa where •,εa pa =⇒ γ[θ],ψ,ξ ε a and ∀v ∈V. ∀a∈υ(v). ξ(a)=θ(χ(v))</formula><p>The paired execution semantics pairs a program's exact execution with its approximate executions.</p><p>Exact Execution. The semantics specifies the program's exact execution via a big-step execution that uses the exact kind and memory configurations 0 θ and 0 ξ that both return 0 for all inputs.</p><p>Approximate Execution. Because approximate operations can produce different results with some probability, the natural representation for the environments of a program's approximate execution is a probability distribution that specifies the probability that the execution is in a particular environment. The semantics specifies the distributions of the approximate execution's initial and final environments with the distributions ϕ and ϕ , respectively. The relationship between these two distributions is given by a summation over big-step executions, each of which use the potentially approximate kind and memory configurations θ and ξ. For each program variable v, ξ maps the variable's addresses (υ(v)) to either the exact or approximate memory according to the kind specified for the variable (θ(χ(v))).</p><p>Reliability Transformer. Reliability predicates and the semantics of approximate programs are connected through the view of a program as a reliability transformer. Namely, similar to the standard Hoare triple relation, if an environment and distribution pair ε,ϕ satisfy a reliability predicate P , then the program's paired execution transforms the pair to a new pair ε ,ϕ that satisfy a predicate Q. We formalize the reliability transformer relation in Section B of the Appendix <ref type="bibr" target="#b21">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Reliability Precondition Generator</head><p>Given a predicate targeted to be true after the execution of a program (a postcondition), Chisel's reliability precondition generator produces a precondition that when true before the execution of the program, ensures that the postcondition is true after. Namely, the precondition, program, and postcondition satisfy the reliability transformer relation.</p><p>The precondition generator operates backwards on the program's instruction sequence, starting at the program's last instruction and ending at the program's first. The generator starts with an initial postcondition that is a conjunction of terms of the form ρ spec,i • R(V spec,i ) ≤ R({v i }) and the term ρ spec,ret • R(V spec,ret ) ≤ R({r ret }). The left-hand side of the inequalities represent the reliability specification of the array parameters and the return value, respectively. Each v i is an array parameter and r ret is the register that contains the return value. The postcondition asserts that the reliability of each output array and the function's return value must be at least that given in their specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Reliability Precondition Analysis</head><p>The reliability precondition generator is a function C ∈ I × P → P that takes as inputs an instruction and a postcondition and produces a precondition as output. The analysis rules for arithmetic instructions and memory accesses are as follows:</p><formula xml:id="formula_12">C(r =op r1 r2,Q)=Q[ρ op •R({r1,r2}∪X))/R({r}∪X)] C(r1 =load r2,Q)=Q[ρ χ(η(r 2 )) ld •R({η(r2)}∪X)/R({r1}∪X)] C(store r1 r2,Q)=Q[ρ χ(η(r 1 )) st •R({r2}∪X)/R({η(r1)}∪X)]</formula><p>ALU/FPU. The first equation presents the generator rule for ALU/FPU operations. The rule works by substituting the reliability of the destination register r with the reliability of its operands and the reliability of the operation itself. The substitution Q[R({r 1 ,r 2 }∪X)/R({r}∪X)] matches all occurrences of the destination register r in a reliability term that occur in the predicate Q and replaces them with the input registers, r 1 and r 2 . The substitution also multiplies in the factor ρ op , which expresses the reliability of the operation op as a function of its label's kind configuration, and its reliability ρ op =π op (ψ)(op). Load/Store. The second and the third equations present the rules for loads and stores from potentially approximate memory. The rules use the auxiliary register mapping generated by the compiler (η ∈R→V ) that maps the address operand register to the program variable that is read or written.</p><p>The minimum reliability of a load from a potentially approximate variable, ρ ld , is equal to the probability that the read from memory, the write to a cache location, and the read from that cache location all execute correctly, π 1 (π mem (ψ))•π 1 (π $ (ψ))• π 2 (π $ (ψ)). The reliability of a store to a potentially approximate variable, ρ st , assuming a write-through cache, is equal to the reliability of a memory store, π 2 (π mem (ψ)).</p><p>This rule presents the semantics of strong updates for scalar program variables. In Section B of the Appendix <ref type="bibr" target="#b21">[22]</ref> we present the rules for weak updates of array variables. Control Flow. We elide the rules for control flow. Our analysis relies on the fact that the Rely base language has structured control flow and therefore it is straightforward to map assembly instructions to high-level program structures, such as if statements and while loops. Working with these structures, our analysis is similar to Rely's analysis. Specifically, for if statements the resulting precondition ensures that both branches of the if satisfy the postcondition (inclusive of the probability that the condition executes correctly). The analysis of bounded while loops is conceptually similar to loop unrolling whereas the analysis of unbounded loops sets the reliability of variables that are unreliably updated within the body of the loop to zero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Final Precondition</head><p>For a given kernel, our analysis computes a precondition that is a conjunction of the terms of the form</p><formula xml:id="formula_13">ρ spec •R(V spec )≤r•R(V ),</formula><p>where ρ spec • R(V spec ) is a reliability factor for a developerprovided specification of an output and r • R(V ) is a lower bound on the output's reliability computed by the analysis.</p><p>Each ρ spec is a real-valued constant and each r is a product of a real-valued constant and kinded reliabilities of the form</p><formula xml:id="formula_14">ρ•Π k ρ k k .</formula><p>If this precondition is valid for a given kind configuration, then that kind configuration satisfies the developer-provided reliability specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Optimization Constraint Construction</head><p>Validity Checking. To check the validity of this precondition, we use the observation that the reliability of any subset of a set of variables is greater than or equal to the reliability of the set as a whole [7, <ref type="bibr">Proposition 1]</ref>. Specifically,</p><formula xml:id="formula_15">V ⊆Vspec ⇒R(Vspec)≤R(V ).<label>(2)</label></formula><p>Therefore, Chisel can soundly ensure the validity of each inequality in the precondition by verifying that ρ spec ≤r and V ⊆V spec .</p><p>Constraint Construction. Given a precondition, Chisel next generates an optimization constraint. For each inequality in the precondition, Chisel immediately checks if V ⊆ V spec . For the test ρ spec ≤r, recall that the reliability expression r has the form</p><formula xml:id="formula_16">ρ•Π k ρ k k .</formula><p>Given that the denotation of ρ under a configuration θ is ρ θ( ) , Chisel produces a final optimization constraint by taking the logarithm of both sides of the inequality:</p><formula xml:id="formula_17">log(ρ spec )-log(ρ)≤ k θ( k )•log(ρ k ).<label>(3)</label></formula><p>We note that the expression on the right side is linear with respect to all labels k . Each label's kind is an integer variable that can take a value 0 or 1. The reliabilities ρ are constants and their logarithms are immediately computable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Accuracy Constraint Construction</head><p>To exploit the capabilities of architectures that have variable precision floating point units <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b42">44,</ref><ref type="bibr" target="#b43">45]</ref>, we now present Chisel's analysis that unifies reasoning about both reliability and accuracy. Specifically, we extend reliability predicates with the ability to characterize the difference in the value of a variable between the kernel's exact and approximate executions. Then, our constraint generator produces linear expressions of kind configurations that characterize how the numerical error emerges and propagates through the kernel.</p><p>6.1 Accuracy Specification Approximate Hardware Specification. For each approximate floating point operation op, we extend the definition of the hardware specification ψ from Section 3.1 to also include the accuracy specification of the variable-accuracy instructions. The specification of a variable-accuracy instruction consists of the reliability r and the number of mantissa bits that are computed fully accurately c (which determines the maximum error of the operation). Each operation produces an approximate result (with error whose magnitude bound is determined by c) with probability r. With probability 1-r, the operation can produce an arbitrarily inaccurate result.</p><p>Function Specification. We extend the syntax of reliability specifications from the Rely base language to include a specification of acceptable accuracy loss. The extended specification has the following form: The constant d specifies the maximum acceptable difference between the results of the exact and approximate executions. The constant r specifies the probability with which the approximate execution will produce a result within distance d of the exact result. The constraints di &gt;= D(xi) specify that the nonnegative value di is the maximum absolute difference between the values of the function's parameter xi at the beginning of the exact and approximate kernel executions.</p><p>Interval Specification. We extend function specifications to enable developers to specify the intervals of values of a function's parameters. Because the accuracy analysis relies on an internal interval analysis, the precision of the results of this analysis depends on the precision of the intervals specified for the inputs to the function. To specify the parameter interval, a developer precedes a function's declaration with an annotation of the form @interval(p,a,b), denoting that the value of the parameter p is within the interval [a,b].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Accuracy Predicates and Reliability Predicates</head><p>We next present the syntax and semantics of the predicates generated by the accuracy analysis:</p><formula xml:id="formula_18">QA := RD ≥RA | QA∧QA RA := RD | RD • | RD •∆(v) | RA+RA RD := d | ∞ | RD •RD</formula><p>An accuracy predicate Q A is a conjunction of accuracy predicates or a comparison between a product of non-negative real constants extended by infinity R D and an accuracy expression. An accuracy expression R A has one of four forms: a constant term R D ; a product of a constant term and a label ; a product of a constant term and a distance operator ∆(v) that relates the values of the variable v in an exact and an approximate execution; or an addition of two accuracy expressions.</p><p>Figure <ref type="figure" target="#fig_10">6</ref> presents the denotational semantics of accuracy expressions and predicates. Accuracy expressions and predicates have a similar semantics to that of standard logical predicates over numerical expressions. The main point of departure is the semantics of the distance operator, which is the absolute difference between the value of a variable in an exact environment ε and its corresponding value in an approximate environment ε a . For notational purposes, we define implication as:  Extended Reliability Predicates. To specify Chisel's extended reliability precondition generator, we extend the reliability predicate definition from Section 5.1 by adding a generalized joint reliability factor, R * (Q A ). R * (Q A ) denotes the probability that the exact environment ε and an approximate environment ε a sampled from ϕ together satisfy the accuracy predicate Q A :</p><formula xml:id="formula_19">QA1 ⇒QA2 ≡ QA1 ⊆ QA2 . RD ∈R + ∪{∞} d =d ∞ =∞ 0•∞ =0 RD •∞ =∞ RD1•RD2 = RD1 • RD2 RA ∈E×E×Θ×Υ→R + ∪{∞} RD • (ε,εa,θ,υ)= RD •θ( ) ∆(v) (ε,εa,θ,υ)= max a∈υ(v) |π2(εa)(a)-π2(ε)(a)| RD •∆(v) (ε,εa,θ,υ)= RD • ∆(v) (ε,εa,θ,υ) RA1+RA2 (ε,εa,θ,υ)= RA1 (ε,εa,θ,υ)+ RA2 (ε,εa,θ,υ) QA ∈P(E×E×Θ×Υ) RD ≥RA ={(ε,εa,θ,υ) | RD ≥ RA (ε,εa,θ,υ)} QA1∧QA2 = QA1 ∩ QA2</formula><formula xml:id="formula_20">C * ψ,I ∈ S×P →P C * ψ,I (x = e,QR) = let Q A =QA[AE(e)/∆(x)] in QR [RE assign,ψ (x,e)•R * (Q A )/R * (QA)] C * ψ,I (if x b s1 s2,QR) = let Q A =QA∧0≥∆(x b ) in C * ψ,I (s1,QR [R * (Q A )/R * (QA)])∧C * ψ,I (s2,QR [R * (Q A )/R * (QA)]) C * ψ,I (x = φ(x1,x2),QR) = let Q A =QA[∆(x1)/∆(x)] and Q A =QA[∆(x2)/∆(x)] in QR [R * (Q A )/R * (QA)] ∧ QR [R * (Q A )/R * (QA)]</formula><formula xml:id="formula_21">R * (QA) (ε,ϕ,θ,υ)= εa∈E(ε,θ,υ,Q A ) ϕ(εa),</formula><p>where</p><formula xml:id="formula_22">E(ε,θ,υ,Q A ) = {ε a | (ε,ε a ,θ,υ) ∈ Q A }. The syntax of the extended reliability predicates is R f := R f | R * (Q A ) and P :=R f ≤R f |P ∧P .</formula><p>This definition of joint reliability factors subsumes the definition of the standard joint reliability factors R(V ) (Section 5.1, Equation <ref type="formula" target="#formula_9">1</ref>). Specifically, the set of variables that have the same value in the exact and approximate program executions can be represented using accuracy predicates that bound the acceptable absolute difference of each variable by zero:</p><formula xml:id="formula_23">R(V ) (ε,ϕ,θ,υ)= R * ( v∈V 0≥∆(v)) (ε,ϕ,θ,υ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Extended Reliability Precondition Generator</head><p>We now present the precondition generator of extended reliability predicates. For simplicity, we present this analysis at the level of the constructs in the Rely base language. This analysis is applicable to kernel computations without unbounded loops.</p><p>Figure <ref type="figure" target="#fig_11">7</ref> presents the selection of rules of the combined accuracy and reliability analysis. The precondition generator takes as input a statement s and an extended reliability postcondition Q R and generates a precondition Q R , such that if Q R holds before the paired execution of the statement s, then Q R holds after the paired execution of s. The final precondition generated for a full program is a precondition from which the program satisfies both its reliability and accuracy specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Interval Analysis</head><p>To compute the absolute error induced by variable-accuracy arithmetic operations (given the number of accurately computed mantissa bits), an accuracy analysis requires the intervals of the operation's inputs. Therefore, we define an auxiliary interval analysis that computes the intervals of expressions computed within the kernel. These intervals include the maximum absolute errors induced by the variable-accuracy floating point operations.</p><p>The analysis produces a mapping I : L → (Float×Float)+ Unbounded, which yields the interval of values to which each expression (identified by its label ∈ L) evaluates. The set Float contains all floating point numbers that the target platform can represent. A special symbol Unbounded indicates that the interval is unbounded (due to e.g., a possible overflow or divide by zero).</p><p>The analysis operates in a forward fashion, using the standard rules of interval arithmetic. To provide a conservative estimate of the error that the approximate execution may produce, for every arithmetic operation e 1 op e 2 the interval analysis extends the computed interval of the result of the exact operation [a,b] with an error term δ, which represents the maximum absolute error of the approximate operation. The resulting interval is then I( )=[a-δ,b+δ]. The computation of conservative intervals is inspired by the analysis presented in <ref type="bibr" target="#b10">[11]</ref>.</p><p>To compute the error term for an arithmetic operation, the analysis uses the function maxerr op,ψ,I (e 1 ,e 2 ), which returns the maximum error when the operation op operates on only a fraction of the inputs' mantissa bits and the intervals of the operands are I(loc(e 1 )) and I(loc(e 2 )). The function loc returns the label of an expression. If any operand interval is unbounded, then the result interval is also unbounded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">Analysis of Arithmetic Expressions</head><p>The function AE in Figure <ref type="figure" target="#fig_11">7</ref> produces an expression that bounds the absolute error of an arithmetic expression.</p><p>Error Propagation. The function propagation op,I (e 1 ,e 2 ) returns a pair of real-valued error propagation coefficients (k 1 ,k 2 ) that specify how sensitive the result of the operation is to the changes of the first and the second operand, respectively.</p><p>To compute the coefficients for each operation, we use the observation that for a differentiable function f(x,y) defined on a bounded interval and inputs with errors x=x+δ x and ŷ =y+δ y , one can show that |f(x,y)</p><formula xml:id="formula_24">-f(x,ŷ)| ≤ k 1 •|δ x |+k 2 •|δ y |. The constants k 1 = max x,y ∂f(x,y) ∂x</formula><p>and k 2 = max x,y ∂f(x,y) ∂y can be computed from the input intervals when the partial derivatives of f are bounded. Note that the input intervals include the bounds for the errors δ x and δ y .</p><p>We can use this observation to specify the error propagation functions for the four arithmetic operations:</p><formula xml:id="formula_25">propagation +,I (e1,e2) = (1,1) propagation -,I (e1,e2) = (1,1) propagation * ,I (e1,e2) = (max y∈I 2 |y|,max x∈I 1 |x|) propagation ÷,I (e1,e2) = (max y∈I 2 |1/y|, max x∈I 1 ,y∈I 2 |x/y 2 |) when 0 ∈I2.</formula><p>Recall that the conservative interval analysis incorporates the maximum error that can propagate from the operands. Therefore, the intervals of the operands I 1 =I(loc(e 1 )) and I 2 =I(loc(e 2 )) incorporate the upper bounds for the errors in the operands. If either interval is unbounded or the divisor's interval includes 0, then the corresponding coefficient will be infinity (∞), indicating that the operand's value is critical, i.e., the kernel's result is highly sensitive to its change.</p><p>Error Induced by Approximation. The analysis uses the function maxerr op,ψ,I (e 1 ,e 2 ) to compute the maximum error induced by the approximate arithmetic expression when the inputs are in I(loc(e 1 )) and I(loc(e 2 )). If either of the intervals is unbounded, then the function returns ∞.</p><p>The propagation and approximation-induced errors are additive because for two continuous functions f and f, it follows from the triangle inequality that |f(x, y)</p><formula xml:id="formula_26">-f(x, ŷ)| ≤ |f(x, y) -f(x, ŷ)| + |f(x, ŷ) -f(x, ŷ)|.</formula><p>Therefore, the total absolute error is bounded by the sum of the error that propagates through the operands, characterized by the propagation coefficients from propagation op,I (•), and the induced error, maxerr op,ψ,I (•). To control whether to approximate the operation, the generator multiplies the induced error with the operation's label.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.3">Analysis of Statements</head><p>Figure <ref type="figure" target="#fig_11">7</ref> presents the selection of rules for the precondition generator for statements, C * . We present the remaining rules in Section C of the Appendix <ref type="bibr" target="#b21">[22]</ref>. The precondition generator for statements operates backwards, from the end to the beginning of the kernel function. It transforms the extended reliability predicate Q R , starting from the predicate that is the conjunction of the terms ρ spec,i •R * (Q spec,i )≤R * (d spec,i ≥∆(v i )) for each kernel's array parameter v i . The analysis rules for statements are analogous to those from the reliability analysis in Section 5. The main difference between the two analyses is in the propagation of the accuracy predicate Q A within the reliability factors, as opposed to propagating sets of variables. Kernel Preprocessing. Before precondition generation, a preprocessing pass flattens conditionals and transforms the kernel's code to an SSA form (as in <ref type="bibr" target="#b6">[7]</ref>). In addition, the preprocessing pass also unrolls finitely bounded loops. Assignment. The assignment operator modifies the accuracy predicate by substituting the occurrences of ∆(x), the distance operator for the variable x with the assignment's accuracy expressions AE(e). The generator substitutes the joint reliability factor R * (Q A ) with the product of the reliability expression RE assign,ψ (x,e), generated by the analysis from Section 5, and the joint reliability factor of the new accuracy predicate Q A . Control Flow. For the conditional statement, both branches must satisfy the predicate. Note that the preprocessing pass flattens the conditional by extracting the variable x b , which is assigned the expression that computes the boolean condition. The predicate 0 ≥ ∆(x b ) therefore states that the computation affecting the statement's condition cannot be computed with reduced accuracy (which could cause control flow divergence). This predicate simplifies the accuracy analysis so that it need not consider all possible combinations of divergent paths for the kernel's exact and approximate executions.</p><p>The rule for phi-nodes substitutes the distance operator with the variable's name for the distance operators of the alternative variable names in each of the branches to address the dependence of the variable's value on the control flow. Array Operations. We present the analysis of array operations in Section C of the Appendix <ref type="bibr" target="#b21">[22]</ref>. They are analogous to the rule for the assignment statement, but also ensure that the variable-accuracy computation does not affect the array index computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.4">Final Precondition</head><p>The precondition generator generates a precondition that is a conjunction of terms of the form:</p><formula xml:id="formula_27">ρspec•R * (Qspec)≤r•R * (QA).</formula><p>The accuracy predicate Q spec (given by the specification) is a conjunction of terms of the form</p><formula xml:id="formula_28">d≥∆(v),<label>(4)</label></formula><p>where each d is a constant and each v is a function parameter. The accuracy predicate Q A (produced by the precondition generator) is a conjunction of terms of the form</p><formula xml:id="formula_29">dspec ≥ j ∆(vj)• l d j,l + k k • l d k,l .<label>(5)</label></formula><p>The constant d spec comes from the specification and the analysis computes coefficients d j,l and d k,l . The first sum on the right side of the inequality represents how the error in the parameters propagates to the output and the second sum represents the error caused by the approximate execution of the arithmetic operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Optimization Constraint Construction</head><p>If the final precondition generated by the analysis is valid, then the program satisfies its accuracy specification. The validity problem for a precondition leads to a natural method for generating an optimization constraint that limits the set of possible kind configurations of the program to only those that satisfy the program's accuracy specification.</p><p>Predicate Validity. Similar to the procedure in Section 5.4, we demonstrate the validity of each of the final precondition's conjuncts,</p><formula xml:id="formula_30">ρspec•R * (Qspec)≤r•R * (QA),</formula><p>by showing that 1) the reliability coefficient on the right side of the inequality is bounded from below by that on the left side, specifically that ρ spec ≤r, and 2) the generalized joint reliability factor on the left side of the inequality is bounded above by that on the right side, specifically that R * (Q spec )≤R * (Q A ).</p><p>Bounding the reliability coefficients (and generating appropriate optimization constraints) follows from the techniques presented in Section 5.4. To bound the generalized reliability factors, we generalize the ordering property for joint reliability factors (Equation <ref type="formula" target="#formula_15">2</ref>) as follows:</p><p>Proposition 1 (Generalized Reliability Factor Ordering).</p><formula xml:id="formula_31">If QA1 ⇒QA2 then R * (QA1)≤R * (QA2).</formula><p>This property follows from the fact that, if Q A1 implies Q A2 , then the set of approximate program environments that satisfy the predicate Q A1 is a subset of the environments that satisfy the predicate Q A2 . Therefore, R * (Q A1 ), the probability of the environments satisfying Q A1 , must be less than or equal to R * (Q A2 ), the probability of the environments satisfying Q A2 .</p><p>Constraint Construction. Given the generalized reliability factor ordering, Chisel's goal is to generate an optimization constraint that ensures that Q spec ⇒ Q A (which therefore ensures that the corresponding conjunct in the precondition is valid). Chisel constructs this constraint via the observation that Q spec has the form j d j ≥ ∆(v j ) (Section 6.3.4, Equation <ref type="formula" target="#formula_28">4</ref>). Therefore, it is sound to replace each occurrence of ∆(v j ) in Q A with the corresponding d j , yielding a predicate of the form:</p><formula xml:id="formula_32">dspec ≥ j dj • l d j,l + k k • l d k,l .<label>(6)</label></formula><p>The constraint generator takes this accuracy predicate and constructs the optimization constraint. First, it rearranges terms and simplifies numerical constants (d * = j d j • l d j,l and d * k = l d k,l ). Since d * k • k denotes the multiplication of the constant d * k and the kind configuration θ( k ), the generator then produces the following optimization constraint for a conjunct:</p><formula xml:id="formula_33">d spec -d * ≥ k d * k •θ( k ).</formula><p>Identifying Critical Operations. As it generates the optimization constraint, the constraint generator identifies all accuracy expressions in which the coefficient d * k has the value ∞ (Section 6.3.2). Such expressions indicate that small deviations in the result of an intermediate operation or a variable value may cause a large deviation of the kernel's output. The constraint generator sets the corresponding kind configuration θ( k ) to 0 (exact) and removes all terms with such assigned configurations from the final accuracy constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Energy Objective Construction</head><p>We now define a set of functions that operate on traces of the original program to model the energy consumption of the exact and approximate program executions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Absolute Energy Model</head><p>Energy Model Specification. We extend the hardware specification from Section 3.1 with the relative energy savings for each approximate arithmetic operation (for simplicity we use α int for all integer and α fp for all floating point instructions) and approximate memory and cache regions (α mem and α cache ). The specification also contains the relative energy consumption of the system's components (µ CPU , µ ALU , and µ cache ) and relative instruction class energy rates (w fp and w oi ).</p><p>Energy of System. We model the energy consumed by the system (E sys ) when executing a program under configuration θ with the combined energy used by the CPU and memory:</p><formula xml:id="formula_34">Esys(θ)=ECPU(θ)+Emem(θ).</formula><p>Energy of CPU. We model the energy consumption of the CPU as the combined energy consumed by the ALU, cache, and the other on-chip components:</p><formula xml:id="formula_35">ECPU(θ)=EALU(θ)+E cache (θ)+E other .</formula><p>Energy of ALU. Each instruction in the hardware specification may have a different energy consumption associated with it. However, for the purposes of our model, we let E int , E fp , E oi be the average energy consumption (over a set of traces) of an ALU instruction, a FPU instruction, and other non-arithmetic instructions, respectively.</p><p>Using the instructions from the traces that represent kernel execution on representative inputs, we derive the following sets: IntInst is the set of labels of integer arithmetic instructions and FPInst is the set of labels of floating-point arithmetic instructions. For each instruction with a label , we also let n denote the number of times the instruction executes for the set of inputs. Finally, let α int and α fp be the average savings (i.e., percentage reduction in energy consumption) from executing integer and floating-point instructions approximately, respectively. Then, the ALU's energy consumption is:</p><formula xml:id="formula_36">Eint(θ)= Σ ∈IntInst n •(1-θ( )•αint)•Eint E fp (θ)= Σ ∈FPInst n •(1-θ( )•α fp )•E fp EALU(θ)=Eint(θ)+E fp (θ)+noi•Eoi.</formula><p>This model assumes that the instruction count in the approximate execution is approximately equal to the instruction count in the exact execution.</p><p>Memory Energy. We model the energy consumption of the system memory (i.e., DRAM) using an estimate of the average energy per second per byte of memory, E mem . Given the execution time of all kernel invocations, t, the savings associated with allocating data in approximate memory, α mem , the size of allocated arrays, S , and the configurations of array variables in the exact and approximate memories, θ( ), we model the energy consumption of the memory as follows:</p><formula xml:id="formula_37">Emem(θ)=t•Emem• ∈ArrParams S •(1-θ( )•αmem).</formula><p>Cache Memory Energy. We model the energy consumption of cache memory, E cache , similarly. Let S c be the size of the cache, α cache the savings of approximate caches. In addition, we need to specify the strategy for determining the size of approximate caches. We analyze the strategy that scales the size of approximate caches proportional to the percentage of the size of the arrays allocated in the approximate main memory. If c u is the maximum fraction of the approximate cache lines, the energy consumption of the cache is</p><formula xml:id="formula_38">E cache (θ)=t•E cache •Sc•(1-cu• S θ( ) S</formula><p>•α cache ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Relative Energy Model</head><p>While the energy model equations from Section 7.1 capture basic properties of energy consumption, the models rely on several hardware design specific parameters, such as the average energy of instructions. However, we can use these equations to derive a numerical optimization problem that instead uses cross-design parameters (such as the relative energy between instruction classes and the average savings for each instruction) to optimize energy consumption of the program relative to an exact configuration of the program, 0 θ (Section 4.2). For each energy consumption modeling function in the previous section we introduce a corresponding function that implicitly takes 0 θ as its parameter. For example, for the energy consumption of the system, we let E sys ≡E sys (0 θ ). System Relative Energy. The energy model contains a parameter that specifies the relative portion of energy consumed by the CPU versus memory, µ CPU . Using this parameter, we derive the relative system energy consumption as follows:</p><formula xml:id="formula_39">Esys(θ) Esys = ECPU(θ)+Emem(θ) ECPU+Emem = = ECPU ECPU • ECPU(θ) ECPU+Emem + Emem Emem • Emem(θ) ECPU+Emem = =µCPU• ECPU(θ) ECPU +(1-µCPU)• Emem(θ) Emem .</formula><p>CPU Relative Energy. The energy model contains a parameter that specifies the relative portion of energy consumed by the ALU, µ ALU , and cache, µ cache (and µ other = 1-µ ALU -µ cache ). We can then derive the relative CPU energy consumption similarly to that for the whole system:</p><formula xml:id="formula_40">ECPU (θ) ECPU =µALU• EALU(θ) EALU +µ cache • E cache (θ) E cache +µ other .</formula><p>ALU Relative Energy. We apply similar reasoning to derive the relative energy consumption of the ALU:</p><formula xml:id="formula_41">EALU(θ) EALU =µint• Eint(θ) Eint +µ fp • E fp (θ) E fp +µoi.</formula><p>The coefficients µ int , µ fp , and µ oi are computed from the execution counts of each instruction class (n int , n fp , and n oi ) and the relative energy consumption rates of each class with respect to that of integer instructions (w fp and w oi ). For example, if we let w fp be the ratio of energy consumption between floating point instructions and integer instructions (i.e, w fp =</p><formula xml:id="formula_42">E fp Eint ), then µ fp = w fp •n fp nint+w fp •n fp +woi•noi .</formula><p>Memory And Cache Relative Energy. Applying similar reasoning to the memory subsystem yields the following:</p><formula xml:id="formula_43">Emem(θ) Emem = 1 H • t t • ∈ArrParams S •(1-θ( )•αmem) E cache (θ) E cache = 1 H • t t • ∈ArrParams S •(1-cu•θ( )•α cache ),</formula><p>where H = S is the total size of heap data. The execution time ratio t /t denotes possibly different execution time of the approximate program. One can use the results of reliability profiling to estimate this ratio.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Optimization Problem Statement</head><p>We now state the optimization problem for a kernel computation:</p><p>Minimize:</p><formula xml:id="formula_44">E sys (θ) E Constraints: log(ρ spec,i )-log(ρ i )≤ k θ( ki )•log(ρ ki ) d spec,i -d * i ≥ k d ki •θ( ki ) ∀i Variables: θ( 1 ),...,θ( n )∈{0,1}</formula><p>The decision variables θ( 1 ),...,θ( n ) are the configuration kinds of arithmetic instructions and array variables. Since they are integers, the optimization problem belongs to the class of integer linear programs.</p><p>Complexity. The number of constraints for a single program path is linearly proportional to the number of kernel outputs (the return value and the array parameters). The number of paths that Chisel's precondition generator produces is in the worst case exponential in the number of control flow divergence points. However, in practice, one can use the simplification procedure from <ref type="bibr" target="#b6">[7,</ref><ref type="bibr">Section 5.4]</ref>, which can identify most of the path predicates as redundant and remove them during the analysis. Out of the remaining predicates, Chisel can immediately solve those that involve only numerical parameters and pass only the optimization constraints with kind configurations to the optimization solver.</p><p>The number of decision variables is proportional to the number of instructions and array parameters in a kernel. In general, integer linear programming is NP complete with respect to the number of decision variables. However, existing solvers can successfully and efficiently solve many classes of integer linear programs with hundreds of variables.</p><p>We describe two techniques that can reduce the size of the generated optimization problem. First, the precondition can create constraints at coarser granularities. For example, a single decision variable may represent program statements, basic blocks, or loop bodies. (Section 8.1). Second, Chisel can separately optimize the invoked functions that implement hierarchically structured kernels (Section 8.4).</p><p>Extensions. In the rest of this section we describe several extensions to Chisel's optimization algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Operation Selection Granularity</head><p>When the number of decision variables in the optimization problem for a large kernel computation is too large to solve given the computational resources at-hand, a developer may instruct the optimizer to mark all instructions in a block of code with the same kind (i.e., all exact or all approximate). The optimization algorithm assigns a single label to all operations within this block of code. This approach reduces the number of decision variables and -therefore -the resources required to solve the optimization problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Overhead of Operation Mode Switching</head><p>Some approximate architectures impose a performance penalty when switching between exact and approximate operation modes due to e.g. dynamic voltage or frequency scaling. Therefore, for these architectures it is beneficial to incorporate the cost of switching into the optimization problem. For example, the constraint generator can produce additional constraints that bound the total switching overhead <ref type="bibr" target="#b37">[38]</ref>.</p><p>To specify this additional constraint, we let i and i+1 be the labels of two adjacent arithmetic instructions. Next, we define auxiliary counter variables s i ∈{0,1} such that</p><formula xml:id="formula_45">s i ≥θ( i )-θ( i+1 ) ∧ -s i ≤θ( i )-θ( i+1 ).</formula><p>Finally, we specify the constraint i s i ≤ B to limit the total number of mode changes to be below the bound B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Array Index Computations and Control Flow</head><p>Instead of relying on support for failure-oblivious program execution (Section 3.3), Chisel can further constrain the set of optimized instructions to exclude instructions that compute array indices and/or affect the flow of control. To ensure that approximate computation does not affect an expression that computes an array index or a branch condition, a dependence analysis can compute the set of all instructions that contribute to the expression's value. Chisel then sets the labels of these instructions to zero to indicate that the instructions must be exact.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Function Calls</head><p>To analyze function calls, one can use the following strategies:</p><p>Inlining. Chisel's preprocessor inlines the body of the called function before the precondition generation analyses.</p><p>Multiple Existing Implementations. A called function f may have multiple implementations, each with its own reliability specification. The specification of each of the m implementations of f consists of the function's reliability specification ρ f,i •R(•) and estimated energy savings α f,i .</p><p>For n calls to the function f in the kernel, the constraint generator specifies the labels f,1,1 ,..., f,m,n . The reliability expression for a k-th call site becomes i ρ f,i,k f,i . The relative ALU energy consumption expression for the same call site is</p><formula xml:id="formula_46">µ f,k • (1 -i θ( f,i.k ) • α f,i ).</formula><p>A trace profiler can record the count of instructions that the exact computation spends in each called function to calculate the parameters µ f,k .</p><p>We also specify a constraint m i=1 θ( f,i.k )=1 for each call site to ensure that the optimization procedure selects exactly one of the alternative implementations of f. Inferring Reliability Specification. Instead of selecting from one of the predefined reliability specifications, one can use the optimization procedure to find the acceptable reliability degradation of the called function f that will satisfy the reliability specification of the caller function. The constraint generator can then be extended to directly model the logarithm of the reliability as a continuous decision variable ρ ( f )≤0 ( f is the label of f).</p><p>For the energy consumption expression, the optimization requires the developer to provide a function α f (ρ ( f )), which specifies a lower bound on the energy savings. To effectively use an optimization solver like Gurobi, this function is required to be linear (the optimization problem is a mixed integer linear program), or quadratic (the optimization problem is a mixed integer quadratic program).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Hardware with Multiple Operation Specifications</head><p>To support hardware platform with arithmetic operations and memory regions with multiple reliability/savings specifications (ρ op,i , α op,i ), we can use an approach analogous to the one for functions with multiple implementations. Specifically, each arithmetic operation can be analyzed as one such function. Analogously, to specify one of k approximate memory regions for a parameter v, the generator defines the labels v,1 ,..., v,k . It generates the reliability expression i ρ v,i mop,i for each memory operation and the memory savings expression i θ( v,i )•α mem,i for each array parameter. To select a single memory region, the generator produces the constraint i θ( v,i )=1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">Multiple Kernels</head><p>A program may contain multiple approximate kernels. To adapt Chisel's workflow, we consider appropriate modifications to the reliability profiling and the optimization.</p><p>Reliability Profiling. The approximate execution of one kernel may affect the inputs and the execution of the other kernels. Therefore, to find the reliability specifications of multiple kernels, the reliability profiler enumerates parts of the induced multidimensional search space. First, the one-dimensional profiler (Section 2.1) finds the lower reliability bound of each kernel. Then, to find the configuration of kernel reliability specifications that yield an acceptably accurate result, the profiler can systematically explore the search space, e.g. using strategies analogous to those that find configurations of accuracy-aware program transformations <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b39">40]</ref> from a finite set of possible configurations. The profiler then returns configurations that closely meet the accuracy target, ordered by the reliability of the most time-consuming kernels.</p><p>Optimization. The optimization algorithm for multiple kernels needs to consider only the allocation of arrays, since the ALU operations are independent between kernels.</p><p>The multiple kernel optimization operates in two main stages. In the first stage, it computes the energy savings of each individual kernel for all combinations of shared array variables. Conceptually, if the shared variables are labeled as 1 ,..., k , the optimization algorithm calls the basic optimization problems for all combinations of the kind configurations θ( 1 ),...,θ( k ), while pruning the search tree when the algorithm already identifies that a subset of labels cannot satisfy the reliability bound.</p><p>In the second stage, the analysis searches for the maximum joint savings of the combination of m kernels. It searches over the combination of individual kernel results for which all array parameters have the same kind configuration, i.e., θ (1) ( i ) = ... = θ (m) ( i ) for each i ∈ {1,...,k}. The algorithm returns the combination of kernels with maximum joint energy savings, which is a sum of the kernels' savings weighted by the fraction of their execution time. While, in general, the number of individual optimization problems may increase exponentially with the number of shared array variables k, this number is typically small and the search can remain tractable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Evaluation</head><p>We evaluate Chisel for several applications over a parameterized space of approximate hardware designs. Our evaluation consists of the following parts:</p><p>• Sensitivity Profiling. We present how sensitivity profiling can help developers effectively identify an appropriate reliability specification for an application.</p><p>• Optimization Problem Size. We present statistics that characterize the size of Chisel's optimization problem. • Energy Savings. We present the percentage of potential energy savings that Chisel uncovered. • Output Quality. We present the resulting end-to-end sensitivity metric for the execution of the synthesized approximate benchmarks on a set of test inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Chisel Implementation</head><p>We have implemented Chisel using OCaml. The framework consists of several passes. The translation pass produces an equivalent C program for an input file with Rely functions. The trace profiler pass instruments the C program to collect instruction traces used to compute the frequencies of instructions (n int ,n fp , and n oi ) in the energy objective. The analysis pass generates the objective, the reliability constraints, and the accuracy constraints. To solve the optimization problem, we use Gurobi mixed integer programming solver <ref type="bibr" target="#b14">[15]</ref>. Finally, the transformation pass uses the optimization problem solution to generate a kernel code with approximate instructions and memory annotations.</p><p>The framework also contains a fault injection pass, which, given the approximate kernel and the hardware error model, injects errors at approximate operations and collects the execution statistics of the computation. 9.2 Hardware Reliability and Energy Specifications We use the reliability and energy specifications for approximate hardware presented in <ref type="bibr" target="#b35">[36,</ref><ref type="bibr">Table 2]</ref> to instantiate our approximate hardware specification, ψ. We reproduce this table in Section D of Appendix <ref type="bibr" target="#b21">[22]</ref>. It defines three configurations, denoted as mild, medium and aggressive, for arithmetic instructions, caches, and main memories respectively. We consider only the unreliable arithmetic operations (that produce the correct results with specified probability) and unreliable memories. System Parameters. To compute the overall system savings (Section 7.2), we use the server configuration parameters specified in <ref type="bibr" target="#b35">[36,</ref><ref type="bibr">Section 5.4</ref>]: CPU consumes µ CP U =55% of energy and the main memory consumes the remaining 45%; the ALU consumes µ ALU = 65% of CPU's energy and the cache consumes the remaining µ cache =35% energy.</p><p>The sizes of the reliable and approximate regions of the main memory are determined before the execution of the kernel computations and remain fixed until all kernel computations finish. We assume that the capacity of the approximate region of the cache (that can store approximate heap data) is twice that of the reliable cache that contains instructions and reliable data, and therefore c u =67%. Error Model. The error injection pass and its runtime insert faults in the synthesized computation with the frequency specified by the hardware specification. For integer and floating point ALU operations, the error model returns a fully random result (as in <ref type="bibr" target="#b35">[36]</ref>). For read and write memory errors, the error model flips from one (with highest probability) up to three bits (with lowest probability) in the word. The kernel calculates the price of a single option. Our implementation is derived from the benchmark from the PARSEC benchmark suite <ref type="bibr" target="#b41">[42]</ref>.</p><p>Successive Over-relaxation (SOR). The Jacobi SOR computation is a part of various partial differential equation solvers.</p><p>The kernel averages the neighboring matrix cells computed in the previous iteration. It is derived from the benchmark from the SciMark 2 suite [43].</p><p>Table <ref type="table">1</ref> presents an overview of the benchmark computations. For each computation, Column 2 ("Size") presents the number of lines of code of the benchmark computation. Column 3 ("Kernel") presents the number of lines of kernel computation that is a candidate for optimization. Column 4 ("Time in Kernel %") presents the percentage of instructions that the execution spends in the kernel computation. Column 5 ("Array Parameter Count/Heap %") presents the number of array arguments and the percentage of heap allocated space that these variables occupy. Column 6 ("Representative Inputs") presents the number of representative inputs collected for each computation. Column 7 ("Sanity Test") presents whether the computation contains a sanity test that ensures the integrity of its result. Column 8 ("Sensitivity Metric") presents the sensitivity metric of the computation. Representative Inputs. For each benchmark, we have selected several representative inputs. The analysis uses a subset of these inputs (designated as "Profile") to obtain the estimates of the instruction mixes and construct the objective function of the optimization problem. We use the remaining inputs (designated as "Test") to evaluate the synthesized approximate computation. Sensitivity Metrics. For the three image processing benchmarks (Scale, DCT, and IDCT) we use peak signal to noise ratio between images produced by the original and the synthesized versions of the benchmark. Specifically for DCT, the sensitivity metric first converts the image from the frequency domain and computes the PSNR on the resulting image.</p><p>For Blackscholes, we have used the relative difference between the sum of the absolute errors between the option prices and the absolute value of the price of the portfolio (the sum of all option values returned by the fully accurate program). For SOR, the sensitivity metric is the average relative difference between the elements of the output matrix. Sanity Tests. Two of the benchmark computations have builtin sanity test computations that ensure that the intermediate or final results of the computation fall within specific intervals. These computations typically execute for only a small fraction of the total execution time. The Blackscholes sanity test uses a no-arbitrage bound <ref type="bibr" target="#b2">[3]</ref> on the price of each option to filter out executions that produce option prices that violate basic properties of the Black-Scholes model. The SOR benchmark checks whether the computed average is between the minimum and maximum array value.</p><p>If the sanity test computation fails, the approximate computation may skip updating the result (as in SOR), or reexecute the computation (as in Blackscholes). In the case of reexecution, the overall savings are scaled by the additional execution time of the kernel computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4">Sensitivity Profiling</head><p>To find reliability specifications for the benchmark applications, the sensitivity profiler relates the reliability degradation of a kernel computation with its end-to-end sensitivity metric. Methodology. For each profiling input, we perform 100 fault injection experiments. As in Section 2.1, we use the sensitivity profiler to compute the average sensitivity metric value (over the space of possible injected faults) for multiple reliability bounds using a developer-provided sensitivity testing procedure. For each benchmark, we select one reliability bound that yields Table <ref type="table">3</ref>: Optimization Problem Statistics an acceptable sensitivity metric. We also analytically derive conservative estimates of the average sensitivity metric. Table <ref type="table" target="#tab_4">2</ref> presents the final reliability specifications for the benchmarks. Column 2 presents the reliability bound. Column 3 presents the average metric obtained from sensitivity testing. Column 4 presents the analytic conservative lower bound on the average sensitivity metric.</p><p>Image Benchmarks. For Scale and IDCT, the sensitivity testing procedure (like the one from Section 2.1) modifies a single pixel. For DCT, the sensitivity testing procedure changes a single coefficient in the 8x8 DCT matrix. To compute the lower bound on the average PSNR, we use an analytical expression from Section 2.1. Note that DCT has smaller average PSNR than the other two benchmarks, as a single incorrectly computed coefficient can make 64 pixels in the final image incorrect.</p><p>Blackscholes. The sensitivity testing procedure conservatively estimates the error at the end of the computation by returning either the upper or the lower no-arbitrage bound (whichever is more distant from the exact option value). For reliability bound 0.999, the average absolute error is $150.6 (±$1.63), while the average value of the portfolio is $28361.4. Therefore, error of the portfolio price is approximately 0.50%. To derive a conservative analytic expression for the deviation, we use the no-arbitrage bound formula, while assuming that the price of the portfolio is at least $4000 (e.g., each option in a portfolio with 4K options is worth at least a dollar) and the strike price is less than $200. SOR. For SOR, the sensitivity testing strategy returns a random value within the typical range of the input data. Since the computation performs multiple updates to the elements of the input matrix, the worst-case relative error typically exceeds 100%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.5">Optimization Problem Solving</head><p>Chisel's optimization algorithm constructs the optimization problem and calls the Gurobi solver. Table <ref type="table">3</ref> presents for each benchmark the number of variables (Column 2) and the number of constraints (Column 3) constructed by Chisel. For each of these problems, Gurobi took less than a second to find the optimal solution (subject to optimality tolerance bound 10 -9 ) on an 8-core Intel Xeon E5520 with 16 GB of RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.6">Energy Savings</head><p>We next present the potential savings that Chisel's optimization uncovered. We relate the savings obtained for the traces of profiled inputs to 1) the maximum possible savings when the reliability bound is 0.0 and 2) the savings for the previously unseen test inputs. Methodology. To get the statistics on the approximate execution of the benchmarks, we run the version of the benchmark transformed using the fault injection pass. We ran the benchmark 100 times for each test input. To estimate the energy savings, we use the instruction counts from the collected traces and the expressions derived in Section 7.</p><p>Results. Table <ref type="table" target="#tab_7">5</ref> presents the system savings that the Chisel's optimization algorithm finds for the kernel computations. Column 2 ("Reliability Bound") presents the target reliability that we set according to the exploration in Section 9.4. Column 3 ("Potential Savings") presents the maximum possible savings when all instructions and memory regions have medium configuration and the result's reliability bound is 0.0 -so that all operations can be unreliable and all arrays can be stored in unreliable memory.</p><p>The remaining columns present the system savings when running the approximate kernels for different hardware specifications. We represent the system configurations as triples of the form CPU/Cache/Main, denoting the reliability/saving configuration of CPU instructions, cache memories, and main memories, respectively. We use the letters "m" and "M"' to denote the mild and medium reliability/savings configuration of the system component from <ref type="bibr" target="#b35">[36,</ref><ref type="bibr">Table 2]</ref>. We omit the aggressive configurations as they yield no savings or only small savings for the reliability bounds of our benchmarks. For instance, the configuration "M/m/M" denotes a medium configuration for CPU instructions, mild configuration for the cache memory, and medium configuration for the main memory. The column "Profile" contains the savings that Chisel finds for the inputs used in sensitivity profiling. The column "Test" contains savings computed from the traces of inputs not used during sensitivity profiling.</p><p>Overall, for these benchmarks and hardware specification, the majority of savings (over 95%) come from storing data in unreliable memories. For Scale and SOR, Chisel marks all array parameters and a significant portion of instructions as unreliable for the configuration "M/M/M". For Scale, the optimization achieves over 95% (19.35% compared to 20.28%) of the maximum savings. For SOR it obtains more than 98% of the maximum possible savings.</p><p>In general, the hardware parameters affect the result that Chisel produces. For instance, Chisel cannot apply any approximation for the medium main memory configuration for DCT (which is the benchmark with the strictest reliability bound) -it produces a kernel in which all operations are reliable. However, for mild memory and cache configurations, the optimization can obtain up to 43% of the maximum possible savings.</p><p>For IDCT, Chisel obtains greater savings for mild ("m") configurations of the unreliable memories, because it can place both array parameters to the kernel as unreliable, for the savings of 67% of the maximum possible savings. When the memory configurations are at the medium ("M") level, Chisel can place only one array parameter in unreliable memory. For Blackscholes, Chisel also selects different combinations of unreliable input array parameters based on the configurations of the main and cache memories and exposes up to 57% of the maximum possible savings. Blackscholes reexecutes some of its computation (when detected by the sanity test), but this reexecution happens for only a small fraction of the options (less than 0.03% on average) and has a very small impact on program's execution time and energy consumption.</p><p>For all benchmarks, the energy savings obtained on the test inputs typically have a deviation less than 3% from the savings estimated on the profiling inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.7">Output Quality</head><p>We next present the end-to-end sensitivity metrics results for the executions of programs with synthesized kernels.</p><p>Methodology. We instrumented the unreliable operations selected by the optimizer and injected errors in their results according to the hardware specification and error model.</p><p>Results. Table <ref type="table" target="#tab_7">5</ref> presents the end-to-end sensitivity of the optimized benchmarks. Columns 1 and 2 present the benchmark and the reliability bound. The remaining columns present the mean and the standard deviation of the distribution of the error metric. The number of faults per execution ranges from several (Blackscholes) to more than a thousand (DCT and IDCT).</p><p>The sensitivity metric of Scale, DCT, and IDCT is the average PSNR metric (higher value of PSNR means better accuracy). We note that the value of the metric for the synthesized computation is similar to the sensitivity profiling results (Table <ref type="table" target="#tab_4">2</ref>). The accuracy of Scale and IDCT increases for the mild configuration of arithmetical operations, as the frequency of faults and therefore the number of faulty pixels caused by computation decreases. The higher variance in DCT is caused by the inputs of a smaller size, where each fault can significantly impact PSNR.</p><p>The accuracy of blackscholes exceeds the accuracy predicted by the sensitivity testing (up to 0.06% on test inputs vs. 0.5% in sensitivity testing). The error injection results for SOR are less accurate than the sensitivity profiling results for medium main memory configurations (8.0% vs. 5.8%). We attribute this lower accuracy to the fact that the sensitivity profiling does not inject errors in the read-only edge elements of the input matrix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8">Kernel Transformations</head><p>We now focus on the kernels that Chisel's optimization algorithm generated. For each benchmark, we examined the kernel with maximum energy savings.</p><p>Scale. We discussed the transformation in Section 2.4.</p><p>DCT. Chisel places the array that contains the pixels of the output image in the unreliable memory. All arithmetic operations remain reliable, as they all occur in a nested loop.</p><p>IDCT. Chisel places both arrays (these arrays contain the pixels of the source and output image) in unreliable memory. Chisel also selects 14% of the arithmetic instructions as unreliable. The instrumented instructions include those that affect the condition of one of the inner bounded loops. Since this loop executes at most 8 iterations (which is enforced by the language semantics), this transformation does not have a visible impact on the energy consumption of the kernel.</p><p>Blackscholes. Chisel places 5 out of 6 input arrays in unreliable memory. These arrays contain different input parameters for computing the blackscholes equation. In addition, Chisel selects 7% of the arithmetic operations as unreliable that fit within the reliability bound. SOR. Chisel places the input array in unreliable memory and selects 82% of the arithmetic operations as unreliable. These unreliable instructions do not affect the control flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Related Work</head><p>Accuracy and Reliability Specifications. Researchers have previously used dynamic sensitivity testing to obtain combined accuracy and reliability guarantees for approximate computations <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b39">40]</ref>. These guarantees are statistical in that they are based on end-to-end sensitivity testing on representative inputs. Researchers have also developed static analysis techniques that provide similar guarantees <ref type="bibr">[5, 6, 9-11, 25, 47]</ref>.</p><p>Snap combines input fuzzing with dynamic execution and influence tracing to quantitatively characterize the sensitivity of the computation to changes to the input <ref type="bibr" target="#b7">[8]</ref>. ASAC <ref type="bibr" target="#b34">[35]</ref> characterizes the sensitivity of the computation to changes in the intermediate program data. Bao et al. <ref type="bibr" target="#b1">[2]</ref> use whitebox sampling to find discontinuities in numerical computations.</p><p>Chisel's sensitivity profiling quantitatively relates the rate of incorrect kernel results to the quality of the result that the program produces. Chisel's sensitivity profiling differs from previous techniques in the source of the noise (incorrect kernel results as opposed to changes in the computation, inputs, or program data) and the goal of the analysis. The goal of the Chisel sensitivity analysis is to obtain the Chisel reliability specifications. The goal of Snap, in contrast, is to identify input fields, intermediate program data, and program regions that must execute correctly and those that can tolerate errors. The goal of ASAC is to discover approximable program data.</p><p>In contrast to these dynamic techniques, researchers have developed static program analyses for reasoning about programs transformed using accuracy-aware transformations <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b45">47]</ref>, for verifying continuity of computations <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>, and for verifying the precision of numerical computations <ref type="bibr" target="#b10">[11]</ref>. Researchers have also developed techniques for reasoning about reducedbitwidth floating point computations <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b27">28]</ref>. In comparison, Chisel's analysis unifies static reasoning about reliability and accuracy, and dynamic reasoning about performance/energy with the goal to navigate the tradeoff space induced by approximate hardware platforms. Software Approximate Computation. Researchers have developed many systems that apply approximate computing techniques in software to reduce the amount of energy and/or time required to execute computations running on standard exact, reliable hardware platforms <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b45">47]</ref>. In Chisel, the source of the approximation is the hardware -Chisel synthesizes acceptably reliable and accurate software that executes on unreliable approximate hardware platforms. Approximate Hardware Platforms. Researchers have previously proposed multiple hardware architecture designs that improve the performance of processors <ref type="bibr">[12, 13, 17-19, 27, 29, 36, 41, 44, 45]</ref> or memories <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b38">39]</ref> at the expense of decreased reliability or accuracy. Programming Models for Approximate Hardware. Rely provides a specification language that developers can use to specify computational reliability requirements and an analysis that verifies that Rely programs satisfy these requirements when run on unreliable hardware <ref type="bibr" target="#b6">[7]</ref>. Flikker provides a set of C language extensions that enable a developer to specify data that can be stored in approximate memories <ref type="bibr" target="#b20">[21]</ref>. EnerJ provides a type system that a developer can use to specify unreliable data that can be stored in unreliable memory or computed using unreliable operations <ref type="bibr" target="#b35">[36]</ref>. The EnerJ type system ensures the isolation of unreliable computations. More recently, it was extended to support the specification and inference of quantitative reliability types <ref type="bibr" target="#b3">[4]</ref>. Unlike these previous techniques, which rely solely on the developer to identify reliable and unreliable operations and data, Chisel automates the selection of unreliable operations and data while ensuring that the generated program satisfies its reliability specification.</p><p>ExpAX is a framework for expressing accuracy and reliability constraints for a subset of the Java language <ref type="bibr" target="#b30">[31]</ref>. ExpAX uses a genetic programming optimization algorithm to search for approximations that minimize the energy consumption of the computation over a set of program traces. Chisel, in contrast, uses mathematical programming to guarantee that the resulting program satisfies its reliability specification (the genetic algorithm in ExpAX provides no such guarantee).</p><p>Topaz is a task-based language that allows the developer to specify tasks that execute on approximate hardware that may produce arbitrarily inaccurate results. Topaz includes an outlier detector that automatically detects and reexecutes unacceptably inaccurate tasks <ref type="bibr" target="#b0">[1]</ref>. Mathematical Optimization in Program Analysis. There is a long history of using mathematical optimization to solve traditional compiler optimization problems such as instruction scheduling and register allocation <ref type="bibr" target="#b29">[30]</ref>. EPROF uses integer linear programming to schedule parallel streaming applications, taking into account the execution time, energy consumption, and task error rate <ref type="bibr" target="#b44">[46]</ref>. Saputra et al. use integer linear programming to place instructions that dynamically scale the voltage and clock rate of the underlying hardware platform. The goal is to exploit the tradeoff between execution time and energy consumption <ref type="bibr" target="#b37">[38]</ref>.</p><p>We have previously used linear programming as a component of an approximation algorithm that finds an ε-optimal expected error/performance tradeoffs for map-fold computations automatically transformed using randomized program transformations <ref type="bibr" target="#b45">[47]</ref>. Chisel similarly uses mathematical programming to optimize energy while providing reliability and accuracy guarantees. In general, we see mathematical programming, with its ability to optimize an objective while preserving a set of constraints, as a natural fit for many approximate computing problems, which typically aim to optimize a resource consumption objective, such as energy or time, while providing acceptable execution, which may be captured by the constraints in the mathematical program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Conclusion</head><p>As the need for energy-efficient computing becomes more acute, approximate hardware platforms become an increasingly attractive target for computationally intensive applications that must execute efficiently. But successfully navigating the resulting reliability and/or accuracy versus energy tradeoff space requires precise, detailed, and complex reasoning about how the approximate hardware platform interacts with the approximate computation. We present a new system that automatically maps the computation onto the underlying approximate hardware platform and minimizes energy consumption while ensuring that the computation executes with acceptable reliability and/or accuracy. This system is capable of generating significant energy savings while relieving developers of the need to manage the complex, low-level details of assigning different parts of the computation to approximate hardware components. Such systems are clearly required if developers are to produce software that can effectively exploit emerging energy-efficient approximate hardware platforms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>&lt;d, r*R(d1 &gt;= D(x1), ..., dn &gt;= D(xn))&gt;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 Figure 1</head><label>11</label><figDesc>Figure 1: Chisel Overview 1.5 System Overview Figure 1 presents an overview of the resulting Chisel system.The developer provides the Chisel program along with reliability and/or accuracy specifications for the approximate kernels (optionally obtaining these specifications via sensitivity profiling on representative inputs). The hardware designer provides a hardware specification, which specifies the reliability and accuracy information for individual instructions and approximate memory. Chisel analyzes the kernels, generates the integer linear program (we use the Gurobi solver<ref type="bibr" target="#b14">[15]</ref>), then uses the solution to generate approximate code that satisfies its specification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2</head><label>2</label><figDesc>Figure 2 presents an implementation of an algorithm that scales an image to a larger size. It consists of the function scale and the function scale kernel.The function scale takes as input the scaling factor f (which increases the image size in both dimensions), along with integer arrays src, which contains the pixels of the image to be scaled, and dest, which contains the pixels of the resulting scaled image. The algorithm calculates the value of each pixel in the final result by mapping the pixel's location back to the original source image and then taking a weighted average of the neighboring pixels. The code for scale implements the outer portion of the algorithm, which enumerates over the pixels in the destination image.The function scale kernel implements the core kernel of the scaling algorithm. The algorithm computes the location in the array src of the pixel's neighboring four pixels (Lines 4-5), adjusts the locations at the image edges (Lines 7-14), and fetches the pixels (Lines 16-19). To average the pixel values, the algorithm uses bilinear interpolation. Bilinear interpolation takes the weighted average of the four neighboring pixel values. The weights are computed as the distance from the source coordinates i and j to the location of each of the pixels (Lines 21-24). In the</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>i 1 Figure 2 :</head><label>12</label><figDesc>Figure 2: Rely Code for Image Scaling Kernel last step, the algorithm extracts each RGB color component of the pixel, computes the weighted average, and then returns the result (Lines 26-33).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Sensitivity Profiling for Image Scaling for Different Values of r • Sensitivity Testing Procedure. A developer can write fault injection wrappers that inject noise into the computation. In general, the developer may use these wrappers to explore the sensitivity of the program's results to various coarse-grained error models. For scale kernel, a developer can implement the following simple sensitivity testing procedure, which returns a random value for each color component: int scale_kernel_with_errors(float i, float j, int[] src, int s_height, int s_width) { return COMBINE(rand()%256, rand()%256, rand()%256); }</figDesc><graphic coords="4,336.40,67.75,77.54,77.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>c∈{R,G,B} (d ijc -d ijc ) 2 =0. With probability 1-r, the kernel computation can compute the value of d ijc incorrectly. The upper bound on the expected error is then c∈{R,G,B} (d ijc -d ijc ) 2 ≤ 3 • 255 2 . Therefore, the lower bound on the expected PSNR metric is PSNR(d,d )≥-10•log 10 (1-r).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Assembly Language Syntax</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Semantics Of Arithmetic OperationsInstructions. The projection π op selects the first element of the hardware specification, which is a finite map from operations to reliabilities. The reliability of an operation is the probability that the operation executes correctly. Memories. The hardware exposes an exact main memory region and an approximate memory region. The projection π mem selects the second element of the hardware specification, which is a pair of reliabilities (r ld , r st ) that denote the reliability of loading and storing a value in the approximate memory region, respectively. Caches. The hardware exposes an exact cache and an approximate cache. The projection π $ selects the third element of the hardware specification, which is a pair of reliabilities (r ld ,r st ) that denote the reliability of loading and storing a value in the approximate cache, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>λn,pn -→ γ,ψ,ξ •,ε where τ =λ1,...,λn, p= n Π i=1 pi and final( •,ε ,γ)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>&lt;d, r * R( d1 &gt;= D(x1), ..., dn &gt;= D(xn) )&gt;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Accuracy Predicate Semantics</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Accuracy (Q A ) and Extended Reliability (Q R ) Precondition Construction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>It presents a set of extensions to the basic Chisel optimization framework. These extensions enable Chisel to work with larger granularity operations, to model overhead associated with switching between exact and approximate modes of operation on approximate hardware platforms that support these two modes, to reason modularly about function calls within approximate kernels, and to optimize the placement of data accessed by multiple kernels in either exact or approximate memory.</figDesc><table><row><cell>• Hardware Model. It presents an abstract hardware model</cell></row><row><cell>for programs that execute on approximate hardware and</cell></row><row><cell>defines its semantics. The model defines an approximate</cell></row><row><cell>hardware specification, which consists of reliability, accuracy,</cell></row><row><cell>and energy consumption specifications for each hardware</cell></row><row><cell>operation.</cell></row></table><note><p>• Extensions. • Experimental Results. It presents experimental results for five Chisel benchmark applications and a set of hardware platforms with unreliable operations. These results show that Chisel is able to produce approximate kernel implementations that are from 8.7% to 19.83% more energy efficient than the exact implementations. These kernel computations exploit a significant portion of the maximum possible energy savings offered by the unreliable hardware platforms (between 43% and 95% of the maximum savings), while preserving each kernel's reliability guarantee to produce acceptable end-toend results.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Reconstructs an image from the coefficients generated by DCT. The kernel reconstructs a single pixel from the frequency domain grid. Black-Scholes. Computes the price of a portfolio of European Put and Call options using the analytical Black-Scholes formula.</figDesc><table><row><cell>Benchmark</cell><cell>Size</cell><cell>Kernel</cell><cell>Time</cell><cell>Array Parameter</cell><cell>Representative</cell><cell>Sanity</cell><cell>Sensitivity</cell></row><row><cell></cell><cell>(LoC)</cell><cell>(LoC)</cell><cell>in Kernel %</cell><cell>Count / Heap %</cell><cell>Inputs (Profile/Test)</cell><cell>Test</cell><cell>Metric</cell></row><row><cell>scale</cell><cell>218</cell><cell>88</cell><cell>93.43%</cell><cell>2 / 99%</cell><cell>13 (5/8)</cell><cell>×</cell><cell>Peak Signal-to-Noise Ratio</cell></row><row><cell>dct</cell><cell>532</cell><cell>62</cell><cell>99.20%</cell><cell>2 / 98%</cell><cell>13 (5/8)</cell><cell>×</cell><cell>Peak Signal-to-Noise Ratio</cell></row><row><cell>idct</cell><cell>532</cell><cell>93</cell><cell>98.86%</cell><cell>2 / 98%</cell><cell>9 (3/6)</cell><cell>×</cell><cell>Peak Signal-to-Noise Ratio</cell></row><row><cell>blackscholes</cell><cell>494</cell><cell>143</cell><cell>65.11%</cell><cell>6 / 84.4%</cell><cell>24 (8/16)</cell><cell></cell><cell>Relative Portfolio Difference</cell></row><row><cell>sor</cell><cell>173</cell><cell>23</cell><cell>82.30%</cell><cell>1 / 99%</cell><cell>20 (6/14)</cell><cell></cell><cell>Average Relative Difference</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">Table 1: Benchmark Description</cell><cell></cell><cell></cell></row><row><cell>9.3 Benchmarks</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">We implemented a set of benchmarks from several application</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">domains. The benchmarks were selected because they tolerate</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">some amount of error in the output.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">Scale. Scales an image by a factor provided by the user. The</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">kernel computes the output pixel value by interpolating over</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">neighboring source image pixels.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">Discrete Cosine Transform (DCT). A compression algo-</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">rithm used in various lossy image and audio compression meth-</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">ods. The kernel computes a frequency-domain coefficient of an</cell><cell></cell><cell></cell><cell></cell></row><row><cell>8x8 image block.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">Inverse Discrete Cosine Transform (IDCT).</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Software Specification PSNR</figDesc><table><row><cell>Benchmark</cell><cell>Reliability</cell><cell cols="2">Sensitivity metric</cell></row><row><cell></cell><cell>Bound</cell><cell>Average</cell><cell>Conservative</cell></row><row><cell>scale</cell><cell>0.995</cell><cell>30.93 ± 0.95 dB</cell><cell>23.01 dB</cell></row><row><cell>dct</cell><cell>0.99992</cell><cell>27.74 ± 1.32 dB</cell><cell>22.91 dB</cell></row><row><cell>idct</cell><cell>0.992</cell><cell>27.44 ± 0.49 dB</cell><cell>20.96 dB</cell></row><row><cell>blackscholes</cell><cell>0.999</cell><cell>0.005 ± 0.0005</cell><cell>0.05</cell></row><row><cell>sor</cell><cell>0.995</cell><cell>0.058 ± 0.034</cell><cell>≥ 1.0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>Energy Savings (Configurations: 'm' denotes mild and 'M' medium CPU/Cache/Memory approximation)</figDesc><table><row><cell>Benchmark</cell><cell>Reliability</cell><cell>Potential</cell><cell cols="2">m/m/m</cell><cell cols="2">M/m/m</cell><cell cols="2">M/M/m</cell><cell cols="2">M/m/M</cell><cell cols="2">M/M/M</cell></row><row><cell></cell><cell>Bound</cell><cell>Savings</cell><cell>Profile</cell><cell>Test</cell><cell>Profile</cell><cell>Test</cell><cell>Profile</cell><cell>Test</cell><cell>Profile</cell><cell>Test</cell><cell>Profile</cell><cell>Test</cell></row><row><cell>scale</cell><cell>0.995</cell><cell>20.28%</cell><cell cols="2">14.11% 14.16%</cell><cell cols="2">14.22% 14.28%</cell><cell cols="2">15.39% 15.42%</cell><cell cols="2">18.17% 18.20%</cell><cell>19.35%</cell><cell>19.36%</cell></row><row><cell>dct</cell><cell>0.99992</cell><cell>20.09%</cell><cell>6.73%</cell><cell>6.72%</cell><cell>6.73%</cell><cell>6.73%</cell><cell>0.00%</cell><cell>-</cell><cell>8.72 %</cell><cell>8.72%</cell><cell>0.00 %</cell><cell>-</cell></row><row><cell>idct</cell><cell>0.992</cell><cell>19.96%</cell><cell cols="2">13.38 % 13.38%</cell><cell cols="2">13.40% 13.40%</cell><cell>7.34%</cell><cell>7.34%</cell><cell>8.70 %</cell><cell>8.70%</cell><cell>9.32 %</cell><cell>9.32%</cell></row><row><cell>blackscholes</cell><cell>0.999</cell><cell>17.39%</cell><cell>9.87 %</cell><cell>9.79%</cell><cell>9.90%</cell><cell>9.81%</cell><cell>5.38%</cell><cell>5.35%</cell><cell>6.36%</cell><cell>6.32%</cell><cell>4.40 %</cell><cell>4.52%</cell></row><row><cell>sor</cell><cell>0.995</cell><cell>20.07%</cell><cell cols="2">14.52% 14.50%</cell><cell cols="2">14.83% 14.87%</cell><cell cols="2">16.07% 16.07%</cell><cell cols="2">18.81% 18.70%</cell><cell cols="2">19.83% 19.43 %</cell></row><row><cell>Benchmark</cell><cell cols="2">Reliability Bound</cell><cell>m/m/m</cell><cell></cell><cell>M/m/m</cell><cell></cell><cell>M/M/m</cell><cell></cell><cell>M/m/M</cell><cell></cell><cell>M/M/M</cell><cell></cell></row><row><cell>scale</cell><cell>0.995</cell><cell></cell><cell>44.79 ± 2.51</cell><cell></cell><cell cols="2">35.30 ± 1.95</cell><cell cols="2">34.07 ± 1.19</cell><cell cols="2">33.13 ± 1.33</cell><cell cols="2">32.31 ± 1.08</cell></row><row><cell>dct</cell><cell>0.99992</cell><cell></cell><cell>30.34 ± 3.84</cell><cell></cell><cell cols="2">30.37 ± 4.41</cell><cell>-</cell><cell></cell><cell cols="2">29.76 ± 4.81</cell><cell>-</cell><cell></cell></row><row><cell>idct</cell><cell>0.992</cell><cell></cell><cell>31.28 ± 0.80</cell><cell></cell><cell cols="2">30.45 ± 0.75</cell><cell cols="2">30.36 ± 0.19</cell><cell cols="2">30.36 ± 0.18</cell><cell cols="2">30.35 ± 0.20</cell></row><row><cell>blackscholes</cell><cell>0.999</cell><cell></cell><cell cols="2">0.0002 ± 0.00004</cell><cell cols="2">0.0006 ± 0.00008</cell><cell cols="2">0.0005 ± 0.00006</cell><cell cols="2">0.0005 ± 0.0008</cell><cell cols="2">0.0005 ± 0.0008</cell></row><row><cell>sor</cell><cell>0.995</cell><cell></cell><cell cols="2">0.029 ± 0.022</cell><cell cols="2">0.051 ± 0.032</cell><cell cols="2">0.046 ± 0.038</cell><cell cols="2">0.086 ± 0.090</cell><cell cols="2">0.080 ± 0.074</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 5 :</head><label>5</label><figDesc>Sensitivity Metric Results for Test Inputs</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Abbas Banaiyan, Harshad Kasture, Deokhwan Kim, Velibor Misic, Majid Shoushtari, Stelios Sidiroglou, and the anonymous referees for the useful comments on the previous versions of this work. We note our previous technical report <ref type="bibr" target="#b22">[23]</ref>.</p><p>This research was supported in part by NSF (Grants CCF-1036241, CCF-1138967, and IIS-0835652), DOE (Grant DE-SC0008923), and DARPA (Grants FA8650-11-C-7192, FA8750-12-2-0110, and FA-8750-14-2-0004).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Energy-efficient approximate computation in Topaz</title>
		<author>
			<persName><forename type="first">S</forename><surname>Achour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
		<idno>MIT-CSAIL-TR-2014-016</idno>
	</analytic>
	<monogr>
		<title level="j">MIT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">White box sampling in uncertain data processing enabled by program analysis</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OOPSLA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Optimization Methods in Dynamic Portfolio Management (Chapter 20</title>
		<author>
			<persName><forename type="first">J</forename><surname>Birge</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Tuning approximate computations with constraint-based type inference</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">WACAS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Proving acceptability properties of relaxed nondeterministic approximate programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Verified integrity properties for safe approximate program transformations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>PEPM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Verifying quantitative reliability for programs that execute on unreliable hardware</title>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OOPSLA</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Automatically identifying critical input regions and code in applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISSTA</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Continuity analysis of programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lublinerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Proving programs robust</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lublinerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Navidpour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FSE</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Sound compilation of reals</title>
		<author>
			<persName><forename type="first">E</forename><surname>Darulova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kuncak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the use of inexact, pruned hardware in atmospheric modelling</title>
		<author>
			<persName><forename type="first">P</forename><surname>Düben</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Joven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lingamneni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mcnamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Micheli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Palem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Palmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Philosophical Transactions of the Royal Society</title>
		<imprint>
			<biblScope unit="volume">372</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Architecture support for disciplined approximate programming</title>
		<author>
			<persName><forename type="first">H</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>ASPLOS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Floating-point bitwidth analysis via automatic differentiation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gaffar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mencer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shirazi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FPT</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://www.gurobi.com/" />
		<title level="m">Gurobi</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
		<title level="m">Dynamic knobs for responsive power-aware computing. ASPLOS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A 1.45ghz 52-to-162gflops/w variable-precision floating-point fused multiply-add unit with certainty tracking in 32nm cmos</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kaul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Anders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mathew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sheikh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><surname>Borkar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>ISSCC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Mitigating soft error failures for multimedia applications by selective data protection</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shrivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Issenin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Venkatasubramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CASES</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Ersa: error resilient system architecture for probabilistic applications</title>
		<author>
			<persName><forename type="first">L</forename><surname>Leem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mitra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DATE</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Parallelization primitives for dynamic sparse computations</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tarsa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Kung</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>HotPar</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Flikker: saving dram refresh-power through critical data partitioning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pattabiraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moscibroda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zorn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>ASPLOS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Chisel: Reliability-and accuracy-aware optimization of approximate computational kernels (appendix)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Achour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><surname>Rinard</surname></persName>
		</author>
		<ptr target="http://groups.csail.mit.edu/pac/chisel" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Reliability-aware optimization of approximate computational kernels with rely</title>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Achour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
		<idno>MIT-CSAIL-TR-2014-001</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>MIT</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Parallelizing sequential programs with statistical accuracy tests</title>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TECS Special Issue on Probabilistic Embedded Computing</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Probabilistically accurate program transformations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SAS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Quality of service profiling</title>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICSE</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sartori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jones</surname></persName>
		</author>
		<title level="m">Scalable stochastic processors. DATE</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Automatic accuracy-guaranteed bit-width optimization for fixed and floating-point systems</title>
		<author>
			<persName><forename type="first">W</forename><surname>Osborne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Coutinho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mencer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FPL</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Energy aware computing through probabilistic switching: A study of limits</title>
		<author>
			<persName><forename type="first">K</forename><surname>Palem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Ilp-based resource-aware compilation. Multiprocessor Systems-on-Chips</title>
		<author>
			<persName><forename type="first">J</forename><surname>Palsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Expectationoriented framework for automating approximate programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<idno>GT-CS-14-05</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>Georgia Institute of Technology</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Probabilistic accuracy bounds for fault-tolerant computations that discard tasks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Using early phase termination to eliminate load imbalances at barrier synchronization points</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OOPSLA</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Enhancing server availability and security through failure-oblivious computing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dumitran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Beebee</surname><genName>Jr</genName></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>OSDI</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Asac: automatic sensitivity analysis for approximate computing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LCTES</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Enerj: Approximate data types for safe and general lowpower computation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Dietl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fortuna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gnanapragasam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Approximate storage in solid-state memories</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>MICRO</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Energy-conscious compilation based on voltage scaling</title>
		<author>
			<persName><forename type="first">H</forename><surname>Saputra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kandemir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vijaykrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Irwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C-H</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Kremer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>LCTES/SCOPES</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Relaxing manufacturing guardbands in memories for energy savings</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shoushtari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banaiyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dutt</surname></persName>
		</author>
		<idno>CECS TR 10-04</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>UCI</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Managing performance vs. accuracy trade-offs with loop perforation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FSE</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">General-purpose code acceleration with limited-precision analog computation</title>
		<author>
			<persName><forename type="first">R</forename><surname>St Amant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yazdanbakhsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Thwaites</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hassibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISCA</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<ptr target="http://parsec.cs.princeton.edu/" />
		<title level="m">Parsec Benchmark Suite</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Reducing power by optimizing the necessary precision/range of floating-point arithmetic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nagle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rutenbar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Very Large Scale Integrated Systems</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Quality programmable vector processors for approximate computing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Chippa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakradhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>MI-CRO</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Eprof: An energy/performance/reliability optimization framework for streaming applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yetim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<idno>ASP-DAC&apos;12</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Randomized accuracyaware program transformations for efficient approximate computations</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kelner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
