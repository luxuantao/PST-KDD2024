<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Incredible ELK From Polynomial Procedures to Efficient Reasoning with EL Ontologies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yevgeny</forename><surname>Kazakov</surname></persName>
							<email>yevgeny.kazakov@uni-ulm.de</email>
						</author>
						<author>
							<persName><forename type="first">Markus</forename><surname>Krötzsch</surname></persName>
							<email>markus.kroetzsch@cs.ox.ac.uk</email>
						</author>
						<author>
							<persName><forename type="first">František</forename><surname>Simančík</surname></persName>
							<email>frantisek.simancik@gmail.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Institute of Artificial Intelligence</orgName>
								<orgName type="institution">University of Ulm</orgName>
								<address>
									<settlement>Ulm</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Oxford</orgName>
								<address>
									<settlement>Oxford</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Incredible ELK From Polynomial Procedures to Efficient Reasoning with EL Ontologies</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F44D14E0D37DBE1A8586C904E5E98250</idno>
					<idno type="DOI">10.1007/s10817-013-9296-3</idno>
					<note type="submission">Received: 16 December 2012 / Accepted: 21 October 2013</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Description logics</term>
					<term>Implementation and optimization techniques</term>
					<term>Saturation procedures</term>
					<term>Concurrency</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>EL is a simple tractable Description Logic that features conjunctions and existential restrictions. Due to its favorable computational properties and relevance to existing ontologies, EL has become the language of choice for terminological reasoning in biomedical applications, and has formed the basis of the OWL EL profile of the Web ontology language OWL. This paper describes ELK-a high performance reasoner for OWL EL ontologies-and details various aspects from theory to implementation that make ELK one of the most competitive reasoning systems for EL ontologies available today.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>One of the central research goals in Description Logics (DLs) <ref type="bibr" target="#b9">[10]</ref> is finding knowledge representation languages with the right balance between expressivity-what can be said using the language-and complexity-how difficult it is to check if something specific holds. For the lack of a better formal criterion, 'complexity' of DLs was commonly measured in terms of the worst case algorithmic behavior. This research area has resulted in discovery and classification of a broad spectrum of DLs, from simple tractable languages, such as EL <ref type="bibr" target="#b7">[8]</ref> and DL-Lite <ref type="bibr" target="#b24">[25]</ref>, to very expressive languages of high computational complexity, such as SROIQ <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b49">50]</ref>. <ref type="foot" target="#foot_0">1</ref>Amongst many languages, the EL family of DLs has recently received significant interest. EL is a simple DL which features the top concept ( ), conjunctions (C D), and existential restrictions (∃R.C) as the only concept constructors. These, however, are some of the most common constructors used in existing ontologies. Some of today's largest ontologies, such as SNOMED CT <ref type="bibr" target="#b91">[92]</ref>, a medical ontology describing about 300,000 concepts, OpenGALEN <ref type="bibr" target="#b83">[84]</ref>, a medical ontology describing about 23,000 concepts, and many Open Biomedical Ontologies (OBO) <ref type="bibr" target="#b96">[97]</ref> can almost completely be expressed in EL.</p><p>Biology and medicine are particularly prominent application areas of DLs due to a large number of technical terms involved. To deal effectively with large vocabularies, concepts are typically organized in a hierarchical structure called a taxonomy which reflects the subsumption (is-a) relation between them. In a medical ontology, e.g., the concept 'Flu' would be subsumed by the concept 'Disease' and would be placed under this concept in the taxonomy. DL-based ontology languages help to reduce redundancies in modeling of taxonomies: rather than stating all relations between concepts explicitly, ontology engineers provide definitions of concepts and their general properties, from which the subsumption relations can be computed using an appropriate reasoning procedure <ref type="bibr" target="#b86">[87]</ref>. Reasoning also plays an important role during the design of ontologies (e.g., for detecting inconsistencies and other modeling errors <ref type="bibr" target="#b84">[85]</ref>) and in the deployment of ontologies (e.g., for query answering <ref type="bibr" target="#b80">[81]</ref>).</p><p>The main terminological reasoning problem in DLs is ontology classification, whose goal is to compute the taxonomy. Other reasoning problems include checking consistency of the ontology, checking satisfiability of a (complex) concept, and checking whether one (complex) concept is subsumed by another. It turns out that EL is robustly tractable for these reasoning problems: not only are these problems polynomially solvable for EL, <ref type="foot" target="#foot_1">2</ref> but this holds even if the language is augmented with cyclic definitions, general concept inclusion axioms (GCIs), role hierarchies, complex role inclusion axioms, nominals (and thus ABox assertions), bottom concept, and some forms of datatype restrictions and role range restrictions <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b22">23]</ref>. These extensions of EL are often called the EL family of DLs. We will often, however, omit the 'family' suffix when we refer to such extensions. Thus, unless specified otherwise, 'EL ontologies' and 'EL reasoners' will be understood in a broad sense as ontologies expressed in the EL family of DLs and reasoners for such ontologies.</p><p>Polynomial complexity results for EL can be regarded as a strong indication that the problems can be solved efficiently in practice, but it is not a guarantee. For example, if we perform (quadratically many) subsumption tests between every pair of the 300,000 concepts in SNOMED CT to compute the classification, and every test takes just a constant time, say 1 millisecond, then it will take an estimated 25,000 hours (over 2.8 years) to compute all subsumptions. Clearly, this procedure, although polynomial, can hardly be regarded as practical. There is a significant difference between procedures that perform quadratically many operations for all (or typical) inputs, and procedures that perform quadratically many operations only in some pathological cases, which are unlikely to occur in practice. This is one of the main reasons why highly optimized (tableau-based) procedures can perform very well in practice despite often very high complexity of the languages involved <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b75">76]</ref>.</p><p>The EL classification procedures, however, have several other strong indicators pointing to a good practical performance. Unlike conventional tableau-based procedures <ref type="bibr" target="#b45">[46]</ref>, which test unknown subsumptions by trying to construct counter-models, the EL procedures derive new subsumptions explicitly using inference rules. This has two important consequences. First, the reasoner never inspects subsumptions that are not entailed by the ontology. The number of entailed subsumptions is typically much smaller than the number of all pairs of concepts. For example, SNOMED CT entails only about 5 million subsumption relations, which is less than 0.01 % of the total number of possible subsumptions. Second, the EL classification procedure computes all subsumptions at once in 'one pass', which requires fewer operations than testing the same number of subsumptions separately.</p><p>Although modern tableau-based reasoners, such as HermiT, FaCT++, Pellet, and Racer-Pro, incorporate many optimizations that can reduce the number of subsumption tests and reuse the results of computations between the tests <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b73">74,</ref><ref type="bibr" target="#b103">104]</ref>, they still cannot achieve the performance of specialized EL reasoners on EL ontologies. For example, the EL version of OpenGALEN cannot be classified by any tableau reasoners available today, but can be classified by all existing EL reasoners. The main difficulty for tableau reasoners is that OpenGALEN contains many cyclic axioms, which result in very large models.</p><p>Of course, EL reasoners have the advantage of dealing with a much simpler language, so it may seem unfair to compare specialized EL procedures with general-purpose ones. It has been recently shown, however, that EL-style classification procedures are not limited to just EL, or even to tractable DLs, but can be extended to more expressive DLs, such as Horn-SHIQ <ref type="bibr" target="#b50">[51]</ref> and (non-Horn) ALCH, <ref type="bibr" target="#b94">[95]</ref> while preserving the mentioned properties. These so-called consequence-based procedures have other distinguished properties, such as (i) optimal worst-case complexity, (ii) 'pay-as-you-go' behavior: the more EL constructors ontology uses, the more it behaves like the EL procedure, and (iii) determinism: the procedure does not make choices or backtracking even for DLs with disjunctions, such as ALCH.</p><p>This paper describes ELK-an open source, Java-based reasoner for OWL EL ontologies. <ref type="foot" target="#foot_2">3</ref> OWL EL is a profile of the W3C standardized logic-based ontology language OWL <ref type="bibr" target="#b74">[75,</ref><ref type="bibr" target="#b81">82]</ref> based on the EL family of DLs. The main goals of ELK are extensive coverage of OWL EL features, high performance of reasoning, and easy extensibility and use. Since its first release in 2011, ELK has already been used in a variety of biomedical applications, e.g., to model the neuroanatomy of flies <ref type="bibr" target="#b80">[81]</ref>, to integrate databases of diseases, genes, and drugs <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b39">40]</ref>, and to validate and query genetic ontologies <ref type="bibr" target="#b47">[48,</ref><ref type="bibr" target="#b100">101]</ref>. As of this paper, the latest release 0.3.2 of ELK supports a fragment of OWL EL that corresponds to the DL EL + ⊥ , which additionally features the bottom concept (⊥) and (complex) role inclusion axioms.</p><p>Although the procedure in ELK shares many similarities with existing EL procedures <ref type="bibr" target="#b7">[8]</ref>, it offers a range of significant improvements. Firstly, the procedure applies inference rules in a goal-directed way and avoids redundant inferences without compromising completeness. Secondly, the procedure is able to apply inferences in parallel, which can take advantage of existing multiprocessor systems. In combination with some further implementation techniques, such as indexing and efficient join computation, these improvements result in a significant performance increase compared with other EL reasoners. For example, SNOMED CT can be classified in about 10 minutes by the EL reasoners CEL <ref type="bibr" target="#b13">[14]</ref> and jcel [72], and in about 25 seconds by the EL reasoner Snorocket <ref type="bibr" target="#b65">[66]</ref>. The same ontology can now be classified by ELK in as little as 5 seconds on the same (quad-core) computer.</p><p>In detail, the main contributions of this paper can be summarized as follows:</p><p>1. We present a new rule-based procedure for reasoning in EL + ⊥ that incorporates many enhancements and optimizations compared to the previously proposed reasoning procedures. In particular, the procedure does not require the input ontology to be normalized, and has a novel redundancy condition that can be used to avoid unnecessary inferences. 2. We present a new method for concurrent application of inference rules, which can be used with arbitrary rule systems, and in particular, with our EL + ⊥ procedure. The method assigns expressions participating in the rules to one or more 'contexts' such that inferences are possible only between elements of the same context. This way, inferences in different contexts can be performed in parallel. Another advantage of our method is that it does not require the datastructures for storing conclusions of the rules to be thread-safe. 3. We describe some new implementation techniques, which contribute to the improved reasoning performance of ELK. The techniques include indexing of axioms for efficient rule application, optimized join evaluation for premises of the rules, caching of partial joins, practical implementation of redundancy, and optimized transitive reduction. 4. We provide an extensive experimental evaluation measuring the effect of concurrency and other optimizations in ELK on a collection of some of the largest EL + ⊥ ontologies that we were able to obtain from public and commercial sources. We compare the improvements both in system-dependent values, such as running times, as well as system-independent values, such as the number of rule applications. Some results presented in this paper were previously published in conference and workshop proceedings. In particular, the concurrent procedure for EL + ⊥ ontologies <ref type="bibr" target="#b52">[53]</ref> and implementation details of the ELK reasoner <ref type="bibr" target="#b54">[55]</ref>. This paper should be self-contained and does not require any prior knowledge in Description Logics, OWL, or programming languages. We tried to present a coherent view of the main aspects of the EL reasoning, from theory to implementation, and provide many examples to illustrate those aspects. We hope, therefore, that the paper can be valuable to those wishing to understand the underlying ideas of the ELK system, and to those wishing to implement similar systems.</p><p>The paper is organized as follows. After a brief introduction to the description logic EL + ⊥ , in Section 3 we present a consequence-based calculus for terminological reasoning in EL + ⊥ , prove its soundness and completeness, and gradually optimize it with appropriate notions of redundancy for inferences and goal-directed strategies of rule application. In Section 4 we describe a multi-phase procedure for implementing this calculus using indexing and the abstract saturation procedure, in Section 5 we present several optimizations for this procedure, and in Section 6 we extend our approach to concurrency. Section 7 gives an overview of the ELK system, and Section 8 provides empirical evaluations of optimizations and concurrency. We discuss related works in Section 9 and conclude in Section 10. In Appendix A we describe how our procedure can be used for reasoning with ABox assertions and some restricted types of nominals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Description Logic Preliminaries</head><p>Here we introduce the description logic EL + ⊥ , which corresponds to the fragment of OWL EL supported by ELK 0.3.2. Readers who are not familiar with description logics (DLs) may wish to consult a more gentle first introduction <ref type="bibr" target="#b64">[65]</ref>.</p><p>EL + ⊥ is defined w.r.t. vocabulary consisting of countably infinite sets of (atomic) roles, atomic concepts, and (named) individuals. Complex concepts and axioms are defined recursively in Table <ref type="table" target="#tab_1">1</ref>. We use the letters R, S for roles, C, D, E for concepts, A, B for atomic concepts, and a, b, c for individuals. A concept equivalence C ≡ D abbreviates the two concept inclusions C D and D C. Axioms that involve individuals are called assertional axioms, or ABox axioms. Other axioms are called terminological axioms, or TBox axioms. An ontology is a finite set of axioms.</p><p>EL + ⊥ has a Tarski-style semantics. An interpretation I consists of a nonempty set I called the domain of I and an interpretation function • I that assigns to each role R a binary relation R I ⊆ I × I , to each atomic concept A a set A I ⊆ I , and to each individual a an element a I ∈ I . This assignment is extended to complex concepts as shown in Table <ref type="table" target="#tab_1">1</ref>.</p><p>An interpretation I satisfies an axiom α (written I |= α) if the corresponding condition in Table <ref type="table" target="#tab_1">1</ref>   </p><formula xml:id="formula_0">. A concept C is unsatisfiable w.r.t. O if O |= C ⊥, otherwise C is satisfiable w.r.t. O. A concept C is subsumed by D w.r.t. O if O |= C D. Concepts C and D are equivalent w.r.t. O if O |= C ≡ D. An individual a is an instance of a concept C w.r.t. O if O |= C(a).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syntax Semantics</head><p>Roles:</p><formula xml:id="formula_1">Atomic role R R I Concepts: Atomic concept A A I Top I Bottom ⊥ ∅ Conjunction C D C I ∩ D I Existential restriction ∃R.C {x | ∃y : x, y ∈ R I ∧ y ∈ C I } Individuals:</formula><p>Named individual a a I Axioms:</p><formula xml:id="formula_2">Concept inclusion C D C I ⊆ D I Role inclusion R S R I ⊆ S I Role composition R 1 • R 2 S x, y ∈ R I 1 ∧ y, z ∈ R I 2 → x, z ∈ S I Concept assertion C(a) a I ∈ C I Role assertion R(a, b) a I , b I ∈ R I</formula><p>A general reasoning problem in EL + ⊥ is checking entailment of axioms from ontologies: given an ontology O and an axiom α, check if O |= α. If both O and α consist only of terminological axioms, we speak about terminological reasoning. In practice one often does not check entailment of a single axiom, but performs a reasoning task that consists of checking multiple entailments at once. The goal of the ontology classification task is to compute the taxonomy representing all entailed subsumptions and equivalences between , ⊥, and atomic concepts occurring in O. The goal of the ontology realization task is to compute all entailed instances of atomic concepts occurring in O.</p><p>To simplify the presentation, we only consider terminological reasoning in the main part of this paper. Thus, without further qualification, we assume that ontologies contain only terminological (TBox) axioms. However, we will show in Appendix A that our algorithms can very easily be adjusted to also support assertional (ABox) axioms and, more generally, certain 'safe' occurrences of nominals (singleton concepts). As we will show, this is essentially because safe nominals are indistinguishable from atomic concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Inference Rules for Reasoning in EL +</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>⊥</head><p>In this section we develop an optimized calculus for reasoning in EL + ⊥ that is the basis of the procedure implemented in ELK. In Section 3.1 we start with the most simple and least restricted version of the calculus that derives all subsumptions C D between arbitrary (complex) EL + ⊥ concepts C and D entailed from the given EL + ⊥ ontology. In Section 3.2 we formulate a more restricted calculus in which existential conclusions of some inferences are distinguished, and demonstrate how this helps to avoid some rule applications using a new redundancy condition. In Section 3.3 we prove that the restricted calculus does not loose any of the entailed subsumptions-some subsumptions will just have fewer different proofs. In Section 3.4 we show how to further restrict the rules if one is interested not in all derivable subsumptions, but only in some selected subset of (goal) subsumptions. In Section 3.5 we then show how this result can be used to obtain a polynomial-time classification procedure for EL + ⊥ . While the specific calculus we develop here is new, many similar calculi have been studied in the literature. We give an overview of such related works in Section 3.6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Basic Inference Rules</head><p>In this section we present a simple procedure for reasoning in EL + ⊥ , which we are going to refine gradually. The calculus works by applying the rules in Fig. <ref type="figure" target="#fig_2">1</ref>, to derive subsumptions between EL + ⊥ concepts. We distinguish between the premises of a rule (above the horizontal Fig. <ref type="figure" target="#fig_2">1</ref> Basic inference rules for reasoning in EL + ⊥ line), its conclusions (below the horizontal line), and its side conditions (after the colon). Rules R 0 and R have no premises and (so far) can be used with arbitrary concepts C. Note that the axioms in O are only used as side conditions of rules R , R H , and R • .</p><p>Intuitively, rules R 0 and R derive trivial subsumptions. Rule R ⊥ propagates inconsistency of fillers in existential restrictions. Rules R -and R + decompose and compose conjunctions on the right-hand side. Rule R ∃ replaces the filler of the existential restriction on the right-hand side using a derived subsumption. Rule R unfolds (told) subsumptions in the ontology. Rules R H and R • use role inclusion and composition axioms to produce new existential restrictions. Note that no rule creates a complex concept on the left-hand side of subsumptions. This is different from typical sequence-based rules. Also note that rule R ∃ uses a (derived) subsumption C D, and not a told subsumption from the ontology, like D E in R . From the following example one can see that if the second premise of R ∃ is likewise restricted to only told subsumptions, some subsumptions would not be derivable.</p><p>Example 1 Consider the ontology O consisting of the following axioms:</p><formula xml:id="formula_3">(ax1) : A ∃R.(C D) (ax2) : B ≡ A ∃S.D (ax3) : ∃S.D C (ax4) : R S.</formula><p>The rules in Fig. <ref type="figure" target="#fig_2">1</ref> can be used to derive the subsumption A B using axioms (ax1)-(ax4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A</head><p>A by R 0 (1) </p><formula xml:id="formula_4">A ∃R.(C D) by R to (1) using (ax1) (2) C D C D by R 0 (3) C D D by R -to (3)<label>( 4</label></formula><p>A B by R to (7) using (ax2) <ref type="bibr" target="#b7">(8)</ref> Note that (5) was produced by R ∃ using a derived premise (4). We would not be able to apply R ∃ to (2) if instead of this premise we had a side condition similarly to R because there are no (told) subsumptions in O with C D on the left-hand side.</p><p>Clearly, the rules in Fig. <ref type="figure" target="#fig_2">1</ref> can derive only subsumptions that are entailed by O since each rule produces a logical consequence of the premises and the side condition, if there is one. In other words, the inference system is sound. Furthermore, it is possible to show that all entailed subsumptions can be derived by the rules. That is, the rules are complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Redundant Rule Applications</head><p>We are not going to prove completeness of the rules in Fig. <ref type="figure" target="#fig_2">1</ref> just yet, but first present some optimizations. The main idea is that one can avoid applying some inferences to conclusions produced by R ∃ without loosing any derivable subsumptions. Specifically, such conclusions should not be used as the first premise of R ⊥ and R ∃ and premises of R H and R • -these are all places where existential restrictions are mentioned explicitly in the premises.</p><p>Example 2 Note that in Example 1 the conclusion (5) of the rule R ∃ was used as a premise of R H to produce <ref type="bibr" target="#b5">(6)</ref>. Subsumption <ref type="bibr" target="#b5">(6)</ref>, however, can be produced differently by 'swapping' the order of application of R ∃ and R H :</p><formula xml:id="formula_6">A ∃S.(C D) by R H to (2) using (ax4)<label>(9)</label></formula><p>A ∃S.D by R ∃ to ( <ref type="formula" target="#formula_6">9</ref>) and (4) <ref type="bibr" target="#b9">(10)</ref> Hence, A B can be derived without using conclusions of R ∃ as premises of R H .</p><p>To formalize the described optimization, we first need to distinguish existential restrictions produced by R ∃ from those produced by other rules. For this purpose, we introduce another type of conclusions called (existential) links C R -→ D, semantically equivalent to C ∃R.D. The new rules using links are given in Fig. <ref type="figure">2</ref>. Note that instead of a single rule </p><formula xml:id="formula_7">∃R.D from C R -→ D by R + ∃ .</formula><p>It is easy to see that if we now replace every link in the rules of Fig. <ref type="figure">2</ref> by the corresponding existential restrictions, we obtain the rules in Fig. <ref type="figure" target="#fig_2">1</ref>. Indeed, R - ∃ will produce E ∃R.C from E ∃R.C and can be ignored, R + ∃ in Fig. <ref type="figure">2</ref> becomes R ∃ in Fig. <ref type="figure" target="#fig_2">1</ref>, whereas rules R ⊥ , R H and R • in Fig. <ref type="figure">2</ref> will become the corresponding rules in Fig. <ref type="figure" target="#fig_2">1</ref>. Therefore, the rules in Fig. <ref type="figure">2</ref> derive the same concept subsumptions as those in Fig. <ref type="figure" target="#fig_2">1</ref>. From now on, we only focus on the rules in Fig. <ref type="figure">2</ref>.</p><p>Existential links in Fig. <ref type="figure">2</ref> prevent conclusions of R + ∃ to be used as the first premise of We say that Closure is closed under the rules of Fig. <ref type="figure">2</ref> up to redundancy w.r.t. O if it contains all conclusions of non-redundant applications of rules in Fig. <ref type="figure">2</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A</head><p>A by R 0 (11)</p><formula xml:id="formula_8">A ∃R.(C D) by R to (11) using (ax1) (12) A R → C D by R - ∃ to (12)<label>(13)</label></formula><formula xml:id="formula_9">C D C D by R 0 (<label>14</label></formula><formula xml:id="formula_10">)</formula><formula xml:id="formula_11">C D D by R -to (14)<label>(15)</label></formula><p>A S → C D by R H to (13) using (ax4) (16) <ref type="formula">16</ref>) and ( <ref type="formula" target="#formula_11">15</ref>) <ref type="bibr" target="#b16">(17)</ref> There is also another derivation. It starts as above until <ref type="bibr" target="#b14">(15)</ref>, but then instead of deriving the link A S → C D, it proceeds by using the link A R → C D as follows. A ∃R.D by R + ∃ to ( <ref type="formula" target="#formula_8">13</ref>) and (15) (18)</p><formula xml:id="formula_12">A ∃S.D by R + ∃ to (</formula><formula xml:id="formula_13">A R → D by R - ∃ to (18)<label>(19)</label></formula><formula xml:id="formula_14">A S → D by R H to (19) using (ax4) (20) D D by R 0 (21) A ∃S.D by R + ∃ to (20) and (21)<label>(22)</label></formula><p>The redundancy condition allows us to 'block' the second derivation after (18): we have already derived A R → C D in <ref type="bibr" target="#b12">(13)</ref> and C D D in <ref type="bibr" target="#b14">(15)</ref>, so the application of R - ∃ in (19) is redundant. Intuitively, every further conclusion using the link A R → D can as well be derived using the former link A R → C D instead.</p><p>Remark 1 Note that if Closure is closed under the rules in Fig. <ref type="figure">2</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note that the application of R -</head><p>∃ to E ∃R.C can be redundant even if E ∃R.C was not obtained by rule R + ∃ , so the redundancy condition can also be used to avoid other inferences than those mentioned in the beginning of this section. In the next section, we prove that our optimized calculus is complete for deriving all subsumptions entailed in EL + ⊥ .</p><p>Theorem 1 Let O be an EL + ⊥ ontology, and let Closure be a set that is closed under the rules in Fig. <ref type="figure">2</ref>  From Theorem 1, it follows that if O |= C D then either C D or C ⊥ is derivable using the rules in Fig. <ref type="figure">2</ref> even if the applications of R - ∃ are required to be non-redundant w.r.t. the set of already derived (intermediate) conclusions. Specifically, let {S i | i ≥ 0} be a sequence of sets such that S 0 = ∅, and for every i ≥ 0, let S i+1 be the extension of S i with conclusions of all non-redundant (w.r.t. S i ) applications of rules from Fig. <ref type="figure">2</ref> to S i . Let Closure = i≥0 S i be the set of all conclusions derivable in this way. Clearly, Closure is closed under the rules in Fig. <ref type="figure">2</ref> up to redundancy. Hence, by Theorem 1, if O |= C D, then either C D or C ⊥ belongs to Closure, i.e., is derivable using this particular strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Proof of Completeness</head><p>The goal of this section is to prove Theorem 1. A commonly used technique for proving completeness of EL procedures is based on canonical model construction. <ref type="foot" target="#foot_3">4</ref> Similarly to saturation-based theorem proving <ref type="bibr" target="#b17">[18]</ref>, canonical models for EL are constructed (uniquely) from the set of expressions closed under inference rules (up to redundancy).</p><p>Assume that O and Closure satisfy the condition of Theorem </p><formula xml:id="formula_15">I = {x C | C ⊥ / ∈ Closure}, A I = {x C ∈ I | C A ∈ Closure}, R I = { x C , x D ∈ I × I | C R → D ∈ Closure}.</formula><p>Note that I is well-defined only if C ⊥ / ∈ Closure for at least one concept C. Otherwise, the domain I is empty and I is not a valid interpretation. Note also that the definition of the canonical model uses only expressions of the form C A and C R -→ D from Closure. In particular, the existential restrictions C ∃R.D are ignored by this definition, in contrast to the corresponding links C R -→ D, which define the interpretation of roles.</p><p>Of course, even if I is well-defined, it is not necessarily a model of O. In the rest of this section we demonstrate that I |= O if Closure satisfies the closure properties of Theorem 1. Towards this goal, we first prove two auxiliary lemmas. - Proof The proof is by induction over the structure of D. In each case, we assume that x C ∈ D I , and we prove that C D ∈ Closure.</p><formula xml:id="formula_16">Case D = D 1 D 2 : Due to closure under R -, C D 1 D 2 ∈ Closure implies C D i ∈ Closure for i = 1,</formula><p>-  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Goal-Directed Rule Application</head><p>The rules in Fig. <ref type="figure">2</ref> can derive an infinite number of subsumptions since already rule R 0 can be applied for any EL + ⊥ concept C. In practice, however, one is usually interested in finitely many subsumptions of some specific form. For example, for classification, it is sufficient to derive only those C D where C and D are either atomic concepts, , or ⊥. Deriving subsumptions from a given finite set, however, may require other subsumptions not in this set to be derived first, and in general, it is not clear why only finitely many intermediate conclusions can be considered. In this section, we present restrictions of the inference rules in Fig. <ref type="figure">2</ref> that can be used to avoid many inferences that are not relevant for deriving the goal subsumptions. To this end, within this section we assume that we are given a fixed EL + ⊥ ontology O and a fixed goal subsumption F G. Our goal is to determine which applications of the rules in Fig. <ref type="figure">2</ref> are needed for deriving this goal subsumption, if it is derivable.</p><p>First we demonstrate that it is sufficient to consider only intermediate conclusions that are reachable from the goal using derivable links. Definition 3 Given a concept C and a set Closure, we say that C is reachable from F in Closure if there exist sequences of concepts</p><formula xml:id="formula_17">F = C 0 , C 1 , . . . , C n = C and roles R 1 , . . . , R n , n ≥ 0, such that C i-1 R i → C i ∈ Closure for every i with 1 ≤ i ≤ n. We say that expressions C D and C R -→ D are reachable from F in Closure if C is reachable from F in Closure.</formula><p>Note that an expression can be reachable from F in Closure even if it is not contained in Closure. When speaking about reachable concepts and expressions, we often drop F and Closure if they are clear from the context. The following result demonstrates that nonreachable conclusions can be always disregarded when deriving the goal subsumption.</p><p>Lemma 3 Let Closure be a set that contains all reachable (from F in Closure) conclusions of non-redundant applications of rules in Fig. <ref type="figure">2</ref> </p><formula xml:id="formula_18">to Closure. Then O |= F G implies that either F G ∈ Closure or F ⊥ ∈ Closure.</formula><p>Proof Let {S i | i ≥ 0} be a sequence of sets of expressions such that S 0 = Closure, and for every i ≥ 0, S i+1 is the extension of S i with all conclusions of non-redundant applications of rules to S i . Let S = i≥0 S i . Clearly, S is closed under all rules in Fig. <ref type="figure">2</ref> up to redundancy. Thus, by Theorem 1, if O |= F G, then S contains either F ⊥ or F G.</p><p>We will now prove by induction on i ≥ 0 that if α ∈ S i is reachable from F in Closure, then α ∈ Closure. Since both F ⊥ and F G are reachable from F in Closure, this will imply the claim of the lemma.</p><p>The induction hypothesis clearly holds for i = 0 since S 0 = Closure by definition. For the induction step, assume that the hypothesis holds for some i ≥ 0. Now take any α ∈ S i+1 that is reachable from F in Closure. If α ∈ S i then α ∈ Closure by induction hypothesis. Otherwise, α ∈ S i+1 \ S i is a conclusion of a non-redundant application of some rule to S i . We prove that α ∈ Closure by considering all possible cases for deriving α: First, we prove by induction on i ≥ 0 that each S i+1 contains all reachable conclusions of non-redundant rule applications to S i . Indeed, for i = 0 this is the case since, by the condition of the lemma, S 0 = Closure contains all such conclusions for goaldirected rule applications, and S 1 contains all such conclusions for not goal-directed rule applications. Now suppose that this property holds for some i ≥ 0, and let α be a reachable conclusion of some non-redundant rule application to S i+1 . We need to prove that α ∈ S i+2 . If α was derived from premises in S i , then α ∈ S i+1 by induction hypothesis, hence α ∈ S i+2 . Otherwise, α was derived from some ⊥ can be obtained by neither of R , R + or R + ∃ ), S 0 = Closure must contain either F G or F ⊥, as required.</p><formula xml:id="formula_19">-rules R 0 , R , R -, R + , R - ∃ , R ,</formula><formula xml:id="formula_20">β = C D ∈ S i+1 \ S i ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Optimized Inference Rules for Classification</head><p>In this section we formulate an optimized calculus for computing classification of EL + ⊥ ontologies that takes into account the optimizations described in the previous section. Recall that for computing classification it is sufficient to derive all subsumptions of the form A B, A ⊥, B, or ⊥ where A and B are atomic concepts. By Lemma 4, it is thus sufficient to restrict the rules R , R + , R + ∃ in Fig. <ref type="figure">2</ref> to produce only subsumptions C D where D occurs negatively in O: note that for these rules, D cannot be an atomic concept or ⊥. To make sure that only reachable conclusions are derived by the rules, we use a special expression init(C) to indicate that the C is initialized as a reachable concept. This expression is then used as a premise of the rules R 0 and R to make sure that the conclusions produced by such rules are reachable. We do not need to add similar premises to other rules since the conclusions of these rules have the same left-hand side as one of the premises of the rules, and hence are reachable whenever the premises are. Whenever we derive a (reachable) link E R -→ C for some new C, we need to produce init(C) to indicate that C is reachable as well; to this end, we introduce a special rule R that implements this inference.</p><p>The optimized inference system is presented in Fig. <ref type="figure" target="#fig_0">3</ref>. Note that we have also removed the rule R H and, instead, use new side conditions of the form R * O S for the rules R + ∃ and R • . Here * O is the transitive closure of the role hierarchy in O, i.e., it is the smallest reflexive transitive binary relation over roles such that R * O S holds for all R S ∈ O. It is easy to see that once the rules R + ∃ and R • are relaxed in this way, the rule R H is not needed anymore: if the conclusion of this rule can be used in R + ∃ or R • , then its premise can be used instead to produce the same conclusion. The advantage of the new rules is that they produce fewer links: note that if the rules in Fig. <ref type="figure">2</ref> </p><formula xml:id="formula_21">derive E R -→ C then they also derive E S -→ C for all S with R *</formula><p>O S, which is not the case for the rules in Fig. <ref type="figure" target="#fig_0">3</ref>. Thus, by precomputing the (often relatively small) role hierarchy * O , we can reduce the number of derived links E R -→ C by a factor of, roughly, the average number of superroles for each role in the role hierarchy. We also can generalize the notion of redundancy to the new rule R - ∃ as follows:</p><p>Definition 5 (Redundancy of R - ∃ for the system in Fig. <ref type="figure" target="#fig_0">3</ref>) Let O be an EL + ⊥ ontology, and Closure a set of subsumptions, existential links, and initializations. An application of rule</p><formula xml:id="formula_22">R - ∃ that derives E R -→ C from E ∃R.C is redundant w.r.t. Closure and O if {E S -→ D, D C} ⊆ Closure for some concept D and some role S O * R.</formula><p>Any other application of rules in Fig. <ref type="figure" target="#fig_0">3</ref> is non-redundant w.r.t. Closure. We omit Closure if it is clear from the context.</p><p>Closure is closed under the rules in Fig. <ref type="figure" target="#fig_0">3</ref> up to redundancy w.r.t. O if it contains all conclusions of non-redundant applications of rules in Fig. Proof Let Closure be obtained from Closure by removing all expressions of the form init(C) and adding C S → D for every C R → D ∈ Closure with R * O S. We will prove that Closure satisfies the condition of Lemma 4 for every F G such that init(F ) ∈ Closure and G is either an atomic concept or ⊥. This will imply the claim of the theorem.</p><p>Since Closure is closed under the rules in Fig. <ref type="figure" target="#fig_0">3</ref> up to redundancy, Closure is also closed under these rules up to redundancy. But then Closure is closed under all applications of R -, R , R H , and R • in Fig. <ref type="figure">2</ref> and under all goal-directed applications of rules R ⊥ , R + , and R + ∃ in Fig. <ref type="figure">2</ref>. Indeed, it is immediate that the additional side-conditions of R ⊥ , R + , and R + ∃ in Fig. <ref type="figure" target="#fig_0">3</ref> exclude only rule applications that are not goal-directed.</p><p>Furthermore, Closure is closed under all non-redundant applications of rule R - ∃ in Fig. It remains thus to show that Closure is closed under applications of R 0 and R in Fig. <ref type="figure">2</ref> that produce reachable conclusions. Indeed, since init(F ) ∈ Closure and Closure is closed under rule R , we have init(C) ∈ Closure for every C reachable from F in Closure. Hence, every reachable conclusion of rules R 0 and R in Fig. <ref type="figure">2</ref> is in Closure since init(C) ∈ Closure for such conclusions, and Closure is closed under R 0 and R in Fig. <ref type="figure" target="#fig_0">3</ref>.</p><p>Example 4 Consider the ontology O from Example 1. To compute all subsumers of A, we compute the closure of Input = {init(A)} under the inference rules in Fig. <ref type="figure" target="#fig_0">3</ref>.</p><formula xml:id="formula_23">init(A) input expression (23) A A by R 0 to (23)<label>(24)</label></formula><p>A ∃R.(C D) by R to ( <ref type="formula" target="#formula_23">24</ref>) using (ax1) (25)</p><formula xml:id="formula_24">A R → C D by R - ∃ to (25) (26) init(C D) by R to (26)<label>(27)</label></formula><formula xml:id="formula_25">C D C D by R 0 to (27)<label>(28)</label></formula><formula xml:id="formula_26">C D C by R -to (28)<label>(29)</label></formula><formula xml:id="formula_27">C D D by R -to (28)<label>(30)</label></formula><p>A ∃S.D by R + ∃ to ( <ref type="formula">26</ref>) and ( <ref type="formula" target="#formula_27">30</ref>) using (ax4) (31)</p><p>A A ∃S.D by R + to ( <ref type="formula" target="#formula_23">24</ref>) and (31) (32)</p><formula xml:id="formula_28">A S → D by R - ∃ to (31)<label>(33)</label></formula><p>A C by R to (31) using (ax3) (34)</p><formula xml:id="formula_29">A B by R to (32) using (ax2) (35) init(D) by R to (33)<label>(36)</label></formula><formula xml:id="formula_30">D D by R 0 to (36)<label>(37)</label></formula><p>The applications of rules R + ∃ and R + producing ( <ref type="formula">31</ref>) and ( <ref type="formula">32</ref>) use the fact that the concepts ∃S.D and A ∃S.D occur negatively in A ∃S.D B, which is a part of (ax2). Intuitively, these rules are used to gradually construct the subsumption A A ∃S.C, so that rule R with side condition (ax2) can be applied to derive A B.</p><p>Since the subsumption <ref type="bibr" target="#b30">(31)</ref> was produced by rule R + ∃ , the application of R - ∃ producing (33) is redundant. In fact, the expressions {( <ref type="formula">23</ref>)-( <ref type="formula">32</ref>), (34)-( <ref type="formula">35</ref>)} are already closed under the rules in Fig. <ref type="figure" target="#fig_0">3</ref> up to redundancy. Note that rule R ⊥ is not applicable, since ⊥ does not occur in the ontology.</p><p>We can see that the following subsumers of A have been derived In addition, we need to precompute at most r 2 subrole relations R * O S. Consequently, the space complexity of the procedure is O(c 2 r + r 2 ). To bound the time complexity, it is sufficient to estimate the number of instances of the inference rules in Fig. <ref type="figure" target="#fig_0">3</ref>; the closure of a system of instantiated rules can be computed in time linear in the number of rules using the linear time algorithm for checking satisfiability of propositional Horn logic <ref type="bibr" target="#b29">[30]</ref>. There are at most c 3 r 3 instances of rule R • , and this clearly dominates the remaining rules. Consequently, the time complexity of the procedure is O(c 3 r 3 ). Thus, computing the closure of Input under the inference rules in Fig. <ref type="figure" target="#fig_0">3</ref> w.r.t. O can be implemented in polynomial time in the size of Input and O.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Relations with Other Rule Systems</head><p>The inference rules in Figs. <ref type="figure">2</ref> and<ref type="figure"></ref>  The main difference is that the completion-based procedure requires the input ontology O to be normalized (flattened) so that each concept inclusion contains at most one concept constructor. This can always be done by repeatedly replacing complex concepts with fresh atomic concepts and adding the corresponding equivalences, followed by subsequent simplifications. For example, the ontology in Example 1 can be normalized as follows using fresh atomic concepts X 1 and X 2 :</p><formula xml:id="formula_31">-A ∃R.(C D) A ∃R.X 1 , X 1 ≡ (C D) A ∃R.X 1 , X 1 C, X 1 D, C D X 1 ; -B ≡ A ∃S.D B ≡ A X 2 , X 2 ≡ ∃S.D B A, B X 2 , A X 2 B, X 2 ∃S.D, ∃S.D X 2 ; -∃S.D C (already normalized); -R S (already normalized).</formula><p>The subset of EL ++ completion rules <ref type="bibr" target="#b7">[8]</ref> relevant to EL + ⊥ is listed in Fig. <ref type="figure" target="#fig_9">4</ref>. Every rule except for CR5 deals with a specific type of a normalized axiom in O. <ref type="foot" target="#foot_4">5</ref> One can easily see similarities with the rules in Fig. <ref type="figure">2</ref>: the rules correspond respectively to R , R + , R - ∃ , R + ∃ , R ⊥ , R H , and R • . Note that there is no rule that is analogous to R -because axioms of the form C D 1 D 2 are replaced with C D 1 and C D 2 during normalization.</p><p>To compute the entailed subsumptions using completion rules, the algorithm first sets S(C) = {C, } and R(R) = ∅ for each C and R, and then repeatedly applies the rules until no rule is applicable. Initialization of S(C) is similar to applying the initialization rules R 0 and R in our case. For our example, e.g., the rules in Fig. <ref type="figure" target="#fig_9">4</ref> produce</p><formula xml:id="formula_32">S(A) = S(B) = { , A, B, X 2 , C}, S(X 1 ) = { , X 1 , C, D}, S(C) = { , C}, S(D) = { , D}, S(X 2 ) = { , X 2 }, R(R) = A, X 1 , B, X 1 , and R(S) = { A, X 1 , A, D , B, X 1 , B, D }.</formula><p>It is also possible to apply the completion rules in a goal-directed way by initializing S(C) dynamically as they become reachable from the goal query <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b50">51]</ref>.</p><p>It is worth noting that the behavior of the completion-based procedure is sensitive to the chosen normalization method. Typically, equivalences like X 1 ≡ C D are introduced for occurrences of C D irrespective of whether such occurrences are positive or negative. A polarity-preserving structural transformation (see, e.g., <ref type="bibr" target="#b50">[51]</ref>) can be used to introduce weaker axioms depending on polarities of such occurrences. For example, it is sufficient to replace the axiom A ∃R.(C D) in our example, with just A ∃R.X 1 and X 1 C D, thus avoiding C D X 1 and subsequent applications of rule CR2. This has a similar effect as restricting our rule R + only to conjunctions that occur negatively. Even if expressions occur both positively and negatively, it is still possible to avoid introducing full equivalences. For example, our second axiom B ≡ A ∃S.D, can be normalized to Reducing the number of normalized axioms, in general, should reduce the number of inferences. However, aggressive normalization makes it difficult to apply some of the optimizations because the connection between the original and the normalized ontology is destroyed. We will discuss this issue in more detail in Section 5 when we talk about some specific optimizations used in ELK.</p><p>Our calculus is certainly not the only one that avoids normalization for the input ontology. A similar proof-theoretic procedure for EL (without ) was described by Hofmann <ref type="bibr" target="#b40">[41]</ref>. The procedure is based on sequent-style rules in Fig. <ref type="figure">5</ref>. These rules are similar to our basic rules in Fig. <ref type="figure" target="#fig_2">1</ref>. The main difference is that the sequent-style rules introduce new concepts both on the left and on the right of concept subsumptions. This makes it possible to prove the cut elimination result (that Cut rule is not needed), and as a consequence, the subformula property (that all concepts in the rules can be restricted to subconcepts of the goal and O), from which the polynomial complexity of the procedure follows. This is similar to our results in Section 3.4. Note, however, that our rules in Fig. <ref type="figure" target="#fig_2">1</ref> have three cut-like rules, namely R ⊥ , R ∃ , R • -just like Cut, these are the only rules that have some concept that does not occur in the conclusion of the rule or in the ontology, but occurs in the premises. These rules, obviously, cannot be removed from the system. Thus our rules have the subformula property (when restricted to EL), but do not enjoy the similar cut-elimination property.</p><p>Apart from (re-)establishing the polynomial complexity of EL, the sequent-style procedure of Hofmann does not seem to have any purpose. Once the subformula property is established, there does not appear to be much difference between the rules Cut and Concept. In fact, these two rules make the sequent-style procedures rather inefficient for some quite common situations. For example, if the ontology contains a long chain of concept inclusions A i-1 A i (1 ≤ i ≤ n), the procedure (both with and without the Cut rule) derives all A i A j with 0 ≤ i ≤ j ≤ n, and hence there are O(n 3 ) possible applications of both rules Cut and Concept. Thus, every subsumption is produced, on average, O(n) times by these rules from different premises. This does not happen with our procedure in Fig. <ref type="figure" target="#fig_2">1</ref> since there are only O(n 2 ) possible applications of R (in fact every subsumption will be produced Fig. <ref type="figure">5</ref> Sequent-style rules for EL <ref type="bibr" target="#b40">[41]</ref> exactly once for this example). Of course, in theory, a similar situation can occur with our rule R ∃ , which also has a cubic worst-case complexity in the number of different concepts, but due to the presence of existential restrictions, the rule is significantly more restricted (note that not only E, C, and D are required to occur in the input due to the subformula property, but also ∃R.C and ∃R.D) and an example that exhibits the worst case complexity would probably be too artificial to really occur in practice. Our further optimizations, in particular existential links and the notion of redundancy, which effectively prevent the conclusions of R ∃ to be used as the left premise of R ∃ , make this worst-case situation even less likely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Computing the Closure under the Inference Rules</head><p>So far we have discussed theoretical properties of the calculus based on the inference rules in Fig. <ref type="figure" target="#fig_0">3</ref>, such as soundness and completeness of the procedure for various reasoning tasks. In this section, we focus on the algorithmic aspect of the problem, specifically, on how to compute the deductive closure under the inference rules in an efficient way. Although it is relatively easy to implement the procedure so that it runs in polynomial time, we will demonstrate that a number of optimizations and efficient data structures can account for a significant speedup in practice, even though they do not reduce the worst-case complexity.</p><p>We first give a high-level overview of the procedure, which can essentially be applied to any inference system, and then provide a more detailed description that is specific to the inference rules in Fig. <ref type="figure" target="#fig_0">3</ref>. For simplicity, in this section, we do not discuss how to avoid redundant applications of rule R - ∃ ; this will be done later in Section 5.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Abstract Saturation Procedure</head><p>In this section we present a basic algorithm for computing the deductive closure of input expressions under inference rules, which we call the abstract saturation procedure. This is a well-known procedure and it is similar to the 'given clause' algorithm (set of support strategy) used in saturation-based theorem proving (see, e.g., <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b108">109]</ref>) and semi-naive (bottom-up) evaluation of logic programs (see, e.g., <ref type="bibr" target="#b0">[1]</ref>). The abstract saturation procedure can be described using Algorithm 1. In order to compute the deductive closure of a set of expressions Input under a set of inference rules R, the procedure maintains two collections of expressions: the queue Todo contains expressions to which the rules have yet to be applied and the set Closure accumulates the expressions to which the rules are applied. A queue can have duplicate elements whereas a set cannot. Todo is first initialized with the input expressions (lines 2-3). After that, the expressions are repeatedly removed from Todo (in no specific order) and processed by method process(expression) until the queue becomes empty (lines 4-6). Expressions are processed by applying all rules R(expression, Closure) between this expression and the expressions in Closure (lines <ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref>. Note that the new conclusions are inserted into Todo, which are again processed in the main loop (lines 4-6). In order to avoid a potentially infinite loop, the rules are applied only the first time an expression is inserted into Closure (see lines <ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10)</ref>. This guarantees termination of the algorithm in case there are only finitely many expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5</head><p>The derivation in Example 4 already presents the expressions in the order in which they are processed by the abstract saturation algorithm. For example, after processing expression <ref type="bibr" target="#b27">(28)</ref>, Closure contains expressions ( <ref type="formula">23</ref>)-( <ref type="formula" target="#formula_25">28</ref>), and Todo contains expressions <ref type="bibr" target="#b28">(29)</ref> and <ref type="bibr" target="#b29">(30)</ref>. The algorithm then takes and removes expression <ref type="bibr" target="#b28">(29)</ref> from Todo, adds it to Closure, and applies all inferences involving this expression and the previously processed expressions ( <ref type="formula">23</ref>)- <ref type="bibr" target="#b27">(28)</ref>. In this case, no inference rules are applicable. The algorithm then takes the next expression <ref type="bibr" target="#b29">(30)</ref> from Todo, adds it to Closure, and applies all inferences involving this expression and the previously processed expressions ( <ref type="formula">23</ref>)- <ref type="bibr" target="#b28">(29)</ref>. In this case, rule R + ∃ is applicable to the premises ( <ref type="formula">26</ref>) and <ref type="bibr" target="#b29">(30)</ref>, so the conclusion (31) is added to</p><formula xml:id="formula_33">Todo.</formula><p>Correctness of Algorithm 1 is a consequence of the following (semi-)invariants that can be proved by induction over the execution of the algorithm: From (i), it follows that Algorithm 1 can add to Closure only expressions that are derivable by the rules from Input. Therefore, from (ii) and (iii).(a), it follows that if there are only finitely many different expressions that can be derived from Input, then Algorithm 1 terminates. Finally, from (iii).(b) and (iii).(c) it follows that when Algorithm 1 terminates (and thus Todo is empty), Closure contains all expressions derivable from Input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementing the Abstract Saturation Procedure for EL + ⊥</head><p>A key detail of Algorithm 1 not discussed so far is the application of inference rules in line 11, where the abstract saturation procedure needs to compute all inferences between the given expression and the expressions in Closure. How can we implement this computation? One possibility is to enumerate all tuples of expressions in Closure that contain the given expression, <ref type="foot" target="#foot_5">6</ref> and check applicability of all rules to each tuple. While this can be implemented in polynomial time in the size of Closure (all rules have a bounded number of premises, so it suffices to consider polynomially many tuples of bounded size), this would clearly be impractical. For a more efficient implementation, we need a goal-directed way to determine which rules can be applied to the given premise and with which other premises from Closure.</p><p>In this section, we present algorithms and datastructures that enable efficient search and application of the rules from Fig. <ref type="figure" target="#fig_0">3</ref>. The optimized saturation procedure for EL + ⊥ consists of three phases. The first two phases 'compile' axioms to produce an efficient representation of inference rules, and the third phase uses this representation to compute the closure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Phase 1: Indexing</head><p>The goal of the indexing phase is to build a representation of the input ontology O so that the side conditions of the rules in Fig. <ref type="figure" target="#fig_0">3</ref> can be verified efficiently. For this purpose, we store information about occurrences of roles and concepts in O using a system of indexed objects.</p><p>The type hierarchy of indexed objects is shown in Fig. <ref type="figure" target="#fig_11">6</ref>; it closely follows the recursive definition of EL expressions. The top level classes IdxRole and IdxConcept represent roles and concepts, respectively. For each indexed role, the field occurs stores the number of times this role occurs in the ontology O, and the field id contains the string identifier of the role. For indexed concepts we separately keep track of the number of their negative and positive occurrences in O in the fields negOccurs and posOccurs. These counters are used to determine which expressions occur in the ontology under which polarity, and to update this information when adding or removing axioms. The different types of EL concepts are represented by the corresponding subclasses of IdxConcept. For example, a conjunction C D is represented by an object of type IdxConjunction with fields firstConj and secondConj pointing to the indexed objects that represent C and D, respectively. In addition, there are distinguished instances top and bottom of IdxConcept that represent and ⊥, respectively. From now on, when we mention roles or concepts, we refer to their indexed representations.</p><p>Apart from creating the indexed objects, the indexing phase also constructs data structures for efficient look-up of side conditions of the inference rules. Specifically, the following tables (sets of tuples) of indexed objects are constructed. The look-up tables contain the following tuples. To give an idea how these index datastructures can be used during the saturation phase, consider the point in the derivation from Example 4 when the saturation algorithm processes the expression A ∃S.D in line <ref type="bibr" target="#b30">(31)</ref>. To apply rule R + to this expression, the algorithm iterates over those tuples in negConjs whose first or second component is ∃S.D to find all possible ways to satisfy the side condition. Since negConjs contains A, ∃S.D, A ∃S.D , the algorithm checks if Closure already contains A A, which can be used as the first premise of R + . Since this is the case, the conclusion A A ∃S.D is added to the Todo queue. Note that (a pointer to) the indexed conjunction A ∃S.D used in the conclusion can be taken directly from the table negConjs. This illustrates that conclusions of inference rules can be constructed by simply following the pointers in the index, and no new indexed objects need to be created during the saturation phase.</p><formula xml:id="formula_34">negConjs = { C, D, C D | C D occurs negatively in O} negExists = { R, C, ∃R.C | ∃R.C occurs negatively in O} concIncs = { C, D | C D ∈ O} roleIncs = { R, S | R S ∈ O} roleComps = { R 1 , R 2 , S | R 1 • R 2 S ∈ O}</formula><p>Indexing is a lightweight task that can be performed by a single recursive traversal through the structure of each axiom in the ontology. Furthermore, the index datastructures can be constructed incrementally by considering one axiom at a time. Since we keep the exact counts of negative and positive occurrences of concepts and roles, the index can be easily updated not only when axioms are added, but also when axioms are removed. This can be highly useful when working with ontologies that are being modified, e.g., in ontology editors, as it is sufficient to reindex changed axioms only.</p><p>Example 7 Let us see how the index data structures in Example 6 are updated if we remove the axiom B ≡ A ∃S.D from O. First, the tuples B, A ∃S.D and A ∃S.D, B are removed from the table conclncs. Second, the counters for both negative and positive occurrences of B, A ∃S.D, A, ∃S.D, and D are decremented, and the occurrence counter for S is decreased by 2. Since the counter for negative occurrences of the conjunction A ∃S.D becomes zero, the tuple A, ∃S.D, A ∃S.D is removed from the table negConjs. The negative occurrence count of the existential restriction ∃S.D remains positive (the concept still occurs negatively in (ax3)), so the table negExists remains unchanged. Finally, since there are no more occurrences of B and A ∃S.D, the corresponding indexed objects are deleted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Phase 2: Saturation of Roles</head><p>In order to efficiently check the side conditions of rules R + ∃ and R • , we compute the reflexive transitive closure * O of the role inclusion axioms of O, and store it in a table called hier (for role hierarchy):</p><formula xml:id="formula_35">hier = { R, S | R * O S}.</formula><p>The table hier can be easily computed from the table roleIncs obtained in the previous phase.</p><p>Since the number of roles in real-world ontologies is usually much smaller than the number of concepts, any reasonable algorithm for computing the transitive closure can be used with no significant impact on overall performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 8</head><p>The reflexive transitive closure of the table roleIncs in Example 6 is hier = { R, R , R, S , S, S }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Phase 3: Saturation of Concepts</head><p>In this phase, we compute the saturation of Input under the inference rules in Fig. <ref type="figure" target="#fig_0">3</ref> using a specialized version of Algorithm 1. Recall that our inference rules operate with three types </p><formula xml:id="formula_36">C ∈ inits C D Sub(C, D) C, D ∈ subs E R -→C Link(E, R, C) E, R, C ∈ links of expressions: init(C), C D, and E R -→ C.</formula><p>Depending on where these expressions are saved, we use different representations for them. The expressions in Todo are represented by objects with the corresponding number of parameters, whereas the expressions in Closure are represented using three tables inits, subs, and links for the respective types of expressions as given in Table <ref type="table" target="#tab_11">2</ref>.</p><p>Before presenting details of the saturation algorithm, we first reformulate in Fig. <ref type="figure">7</ref> the rules from Fig. <ref type="figure" target="#fig_0">3</ref> as closure properties in the above representation. In these rule formulations, for each table T and tuple x the expression T (x) stands for x ∈ T .</p><p>The main body of the saturation algorithm remains the same as for the abstract saturation procedure (Algorithm 1, lines 2-6). We only replace the implementation of the function process(expression) as shown in Algorithm 2. Each expression is processed according to its type, corresponding to all possible ways the expression can be used as a premise of the rules in Fig. <ref type="figure">7</ref>. Fig. <ref type="figure">7</ref> The closure properties induced by rules in Fig. <ref type="figure" target="#fig_0">3</ref> The Incredible ELK</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Efficient Join Computation</head><p>Iterations over joins of tables are used extensively in Algorithm 2 to retrieve all matching side conditions and premises of inference rules. We can optimize such iterations by iterating over smaller tables and precomputing partial joins. In this section we illustrate these techniques on the application of rules R + and R + ∃ .</p><p>Consider rule R + implemented in Algorithm 2 in lines 16-19. To apply the rule with an axiom C D as the first premise, the loop in line 16 iterates over all indexed concepts D 2 and E such that subs(C, D 2 ) ∧ negConjs(D, D 2 , E) holds, i.e., such that the subsumption C D 2 has already been processed and E = D D 2 occurs negatively in the ontology. One possibility is to iterate over all D 2 such that subs(C, D 2 ) holds, and for each of them check if a (necessarily unique) E with negConjs(D, D 2 , E) exists. Another possibility is to iterate over all D 2 such that negConjs(D, D 2 , E) holds (for E = D D 2 ) and for each of them check if subs(C, D 2 ) holds. Depending on which iteration is shorter, one method is more efficient than the other. For this reason, we do not fix the order of iteration upfront; instead, we dynamically choose the order that results in iterating over the smaller set.</p><p>The above approach can be further improved for rules where the same join is computed multiple times. Consider the application of rule R + ∃ to a link E R -→ C as the first premise implemented in Algorithm 2 in lines 31-32. For simplicity, we ignore the role hierarchy in this discussion. In that case, the loop in line 31 iterates over all D such that subs(C, D) ∧ negExists(R, D, F ) holds (for F = ∃R.D), i.e., such that the subsumption C D has already been processed and F = ∃R.D occurs negatively in the ontology. Since this iteration is independent of E, the algorithm repeats it for very link E R -→ C with the same R and C. To avoid the repetition, we cache the result as 'propagations' props(R, C, F ) := subs(C, D) negExists(R, D, F ), which is updated every time a new subsumption C D is derived.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Relations with Implementations of Completion-Based Procedures</head><p>As we mentioned in the beginning of Section 4.1, algorithms for computing the closure under inference rules are well studied and commonly used in many areas of computer science. So it is not surprising that other rule-based reasoners implement procedures similar to Algorithm 1. In this section we point out the main differences between our implementation and the implementation of completion-based procedures first used in the reasoner CEL <ref type="bibr" target="#b13">[14]</ref>, and later adapted by other reasoners such as jcel <ref type="bibr" target="#b71">[72]</ref>, Snorocket <ref type="bibr" target="#b65">[66]</ref>, and Cheetah <ref type="bibr" target="#b93">[94]</ref>.</p><p>Recall from Section 3.6, that completion-based procedures work with ontologies containing only normalized axioms. The procedure computes sets S(C) and R(R) for every atomic concept C and role R by applying the rules in Fig. <ref type="figure" target="#fig_9">4</ref> starting from the initial values S(C) = { , C} and R(R) = ∅. Like in our case, the CEL procedure uses queues for controlled application of inference rules. Unlike our procedure, however, the queues collect not conclusions of applied rules, but expressions of the form A 1 • • • A n → D that represent 'remainders' of the normalized axioms containing the produced subsumer on the left-hand side <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15]</ref>. For example, when a new subsumer D 1 is added to S(C), and the ontology contains an axiom D 1 D 2 D 3 D, the procedure adds the remainder 'D 2 D 3 → D' for D 1 in this axiom to the queue of C. When this remainder is processed, it is checked whether S(C) contains both D 2 and D 3 , and if so, D is added to S(C), which can result in remainders for D being added to the queue for C in a similar way. This strategy was inspired by the linear-time algorithm for checking satisfiability of propositional Horn formulas <ref type="bibr" target="#b29">[30]</ref>.</p><p>The CEL procedure can be alternatively described using the inference rules in Fig. <ref type="figure">8</ref>. Intuitively, the rules deal with negative occurrences of conjunctions by deriving intermediate subsumers of the form D i → D (we consider only binary conjunctions, so there is at most one concept on the left of →). The procedure thus can be seen as an implementation of Algorithm 1 for these rules, except that the intermediate subsumers produced by the first Fig. <ref type="figure">8</ref> Processing negative conjunctions in CEL using intermediate implications two rules are not saved in Closure, and the conclusion C D produced by the last rule are not inserted into Todo, but processed immediately. In order to optimize applications of first two rules, CEL precomputes remainders for each concept D occurring on the left-hand side of axioms, and saves them in a set Ô(D). This is similar to indexing of axioms in our case.</p><p>The first two rules in Fig. <ref type="figure">8</ref>, however, may result in many unnecessary inferences. Some concepts can occur in ontologies in many conjunctions. For example, in SNOMED CT there are several concepts that occur in over 1,000 negative conjunctions. Typically, these are general concepts, such as 'Drug' or 'Disease', that are used to define more specific concepts, e.g., HeartDisease ≡ Disease ∃affects.Heart, LiverDisease ≡ Disease ∃affects.Liver. Since such concepts are general (high in the class hierarchy), they can be derived as subsumers of many concepts, e.g., HeartDisease Disease, LiverDisease Disease, so the first two rules in Fig. <ref type="figure">8</ref> can be applied very often. Each rule application produces as many intermediate conclusions as there are conjunctions containing the subsumer. Thus, if the subsumer occurs in n conjunctions, and was derived as a subsumer of m concepts, there will be n • m conclusions. This can be a big number for large ontologies, such as SNOMED CT.</p><p>Cheetah <ref type="bibr" target="#b93">[94]</ref> has experimented with a slightly different approach of applying completion rules. Instead of deriving intermediate 'remainders' of axioms, the reasoner counts down how many subsumers on the left-hand side of axioms are remained to be satisfied. That is, for every concept C and every axiom α = A 1 • • • A n D ∈ O the procedure stores a counter #(C, α) representing the number of concepts A i such that the subsumption C A i</p><p>was not yet derived. When a new subsumption C A i is derived, this counter is decremented, and when it reaches 0, the subsumption C D is produced. This approach does not require producing the actual 'remainders' of axioms, but requires storing and updating the counters for every C and α. Cheetah has also experimented with a simplified strategy, in which no counters are used, but instead, every time C A is derived, for every axiom</p><formula xml:id="formula_37">α = A 1 • • • A n D ∈ O having A = A i for some i (1 ≤ i ≤ n), it is checked whether C</formula><p>A i was already derived for every i (1 ≤ i ≤ n), in which case C D is produced. This strategy has, in fact, outperformed the counter-based strategy on existing ontologies, possibly due to a relatively high overhead of storing and updating the counters and relatively short conjunctions.</p><p>The second strategy of Cheetah is similar to our first method of join evaluation for rule R + discussed in Section 4.3, where we first iterate over all negative conjunctions containing the derived subsumer, and then check if subsumption with the other conjunct is already derived. As we mentioned, this iteration is not very efficient if the subsumer occurs in many negative conjunctions. Therefore, similar to CEL, both strategies of Cheetah will have problems in this case. In our implementation, however, it is likely that the second method of join evaluation will be selected in this case. That is, we first iterate over all existing subsumers and then check if the conjunction with the produced subsumer occurs negatively in the ontology. This method should work faster if the number of subsumers is small compared to the number of matching negative conjunctions.</p><p>Another subtle difference between our procedure and the CEL procedure is processing of 'edges' C, D ∈ R(R), which are created whenever an existential ∃R.D is derived for C. Unlike links in our case, CEL does not insert the edges into the queue, but processes them immediately in a recursive call. This, however, may result in an unbounded recursion (and subsequent stack overflow), especially when implementing the rule for role compositions. In Algorithm 1 we do not have recursive methods, so this problem does not occur. Cheetah also avoids this problem by creating intermediate existential restrictions for the produced edges, which are then inserted into the queue as ordinary subsumers. This would be similar had we implemented our procedure using the simplified rules in Fig. <ref type="figure" target="#fig_2">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Redundancy and Other Optimizations</head><p>The basic approach presented in Section 4 may already work well in practice, but the procedure can be optimized even further. In this section we describe several such optimizations implemented in ELK that turned out to work well in practice. In Section 5.1 we discuss how to avoid some redundant applications of the decomposition rules R - ∃ and R -. In Section 5.2 we describe an optimization for the role composition rule R • . In Section 5.3, we present an optimized treatment of disjointness axioms, which does not require (possibly quadratic) binarization. Finally, in Section 5.4 we describe an optimized procedure for taxonomy construction. We empirically evaluate the effect of all these optimizations in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Optimization of Decomposition Rules</head><p>The saturation procedure from the previous section computes the full closure under the inference rules in Fig. <ref type="figure" target="#fig_0">3</ref> without taking advantage of the notion of redundancy from Definition 5. Although it is certainly possible to add the redundancy conditions as additional negative premises for rule R - ∃ , it is not clear how to check them efficiently. Instead, in ELK we use the following weaker optimization O ∃ , which is easy to implement. Example 9 Using optimization O ∃ , the application of rule R - ∃ to axiom <ref type="bibr" target="#b30">(31)</ref> in Example 4 is redundant. This avoids deriving expressions <ref type="bibr" target="#b32">(33)</ref>, <ref type="bibr" target="#b35">(36)</ref>, and (37), and, in particular, even avoids the need to initialize D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interestingly, we can formulate an analogous optimization for rule R -:</head><p>O Do not apply rule R -to a subsumption C D 1 D 2 that has been derived by rule R + .</p><p>If C D 1 D 2 has been derived by rule R + , then both the premises C D 1 and C D 2 of the rule must have been derived earlier, so it is clearly redundant to derive them again in rule R -. Thus, unlike O ∃ , optimization O does not affect the set of expression derived during saturation, it can only reduce the number of rule applications.</p><p>To implement O and O ∃ in the saturation algorithm, we introduce a new expression Sub + (C, D) and change the implementation of rules R + and R + ∃ in Algorithm 2 to produce Sub + instead of Sub. Processing of Sub + (C, D) is analogous to process(Sub(C, D)) in Algorithm 2 except that the applications of rules R -and R - ∃ are omitted.</p><p>The Incredible ELK</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Optimization of the Role Composition Rule</head><p>All the inference rules in Fig. <ref type="figure" target="#fig_0">3</ref> have the property that if a conclusion is derivable from a premise E S -→ D, then the same conclusion is also derivable from each stronger premise</p><formula xml:id="formula_38">E S -→ D with S * O S.</formula><p>Therefore, the former is superfluous in the presence of the latter. In this section, we present an optimization of rule R • that avoids deriving the conclusion</p><formula xml:id="formula_39">E S -→ D from the premises E R 1 -→ C and C R 2 -→ D if a stronger conclusion E S -→ D with S *</formula><p>O S is also derivable by R • from the same premises.</p><p>First, to simplify the application of rule R • , we expand all indexed role composition axioms under the role hierarchy, i.e., we precompute the join</p><formula xml:id="formula_40">hierComps(R 1 , R 2 , S) := roleComps(S 1 , S 2 , S) hier(R 1 , S 1 ) hier(R 2 , S 2 ),</formula><p>which can be done already during the role saturation phase. The application of rule R • in Fig. <ref type="figure">7</ref> then simplifies to the following:</p><formula xml:id="formula_41">R • : If links(E, R 1 , C) &amp; links(C, R 2 , D) &amp; hierComps(R 1 , R 2 ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S), then links(E, S, D).</head><p>Second, we eliminate all entries hierComps(R 1 , R 2 , S) for which there exists another entry hierComps(R 1 , R 2 , S ) with S * O S; to avoid the problem of simultaneously removing all entries with equivalent roles, the entries need to be removed sequentially one at a time. This optimization prevents the algorithm from deriving two different conclusions O S has already been processed by the saturation algorithm. Although less restrictive, the practical advantage of O • is that, at a relatively small cost of preprocessing the table hierComps in the role saturation phase, it avoids even the construction of the weaker link E S -→ D in the concept saturation phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Disjointness Axioms</head><p>In OWL EL one can write axioms DisjointClasses( C 1 . . . C n ) meaning that the concepts C 1 , . . . , C n are pairwise disjoint. Although such statements can be straightforwardly translated to DL axioms C i C j ⊥ for 1 ≤ i &lt; j ≤ n, this translation introduces n(n -1)/2 axioms, which can be inefficient for large n.</p><p>We can treat large disjointness axioms (whose length exceeds a certain threshold) differently. For each such axiom α = DisjointClasses(C 1 , . . . , C n ) we introduce a special 'marker' concept D α and assert C i D α for 1 ≤ i ≤ n. Then, in the saturation phase, whenever we process a subsumption C D α the second time, i.e., whenever we attempt to insert C, D α into table subs in Algorithm 2 but the tuple is already there, we know that C C i must have already been derived for at least two different indexes i, so we derive the conclusion C ⊥.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Taxonomy Construction</head><p>Recall that, for the classification task, we initialize the saturation algorithm with init(A) for each atomic concept A, and then, by our completeness result, the result of the saturation contains all entailed subsumptions A B between atomic concepts. The computed saturation, however, is not very convenient for navigating over subsumptions. Instead, subsumptions are usually represented in the form of a taxonomy, which contains equivalent classes of atomic concepts and direct subsumption relations between them. We say that an atomic concept A is directly subsumed by an atomic concept B w.r. In this section we discuss how to perform transitive reduction of a (transitively closed) set subs of all subsumption relations between atomic concepts. To perform the reduction, for every atomic concept A we compute the set of its equivalent concepts A.equivalent and the set of its direct subsumers A.directSubs.</p><p>A naive algorithm for computing A.directSubs is shown in Algorithm 3. The algorithm iterates over all subsumers C of A, and for each of them checks if another subsumer B of A exists with A B C. If no such B exists, then C is a direct subsumer of A. Note that this approach does not work as expected when A has two equivalent subsumers, in which case none of them would be found as direct. Apart from this shortcoming, the algorithm is also inefficient because it performs two nested iterations over the subsumers of A. In realistic ontologies, the number of all subsumers of A can be sizeable, while the number of direct subsumers is usually much smaller, often just one. A more efficient algorithm would take advantage of this and perform the inner iteration only over the set of direct subsumers of A that have been found so far, as shown in Algorithm 4. Note that it is safe to execute Algorithm 4 in parallel for multiple concepts A.</p><p>The rest of the taxonomy construction is straightforward. We introduce one taxonomy node for each distinct class of equivalent concepts, and connect the nodes according to the direct subsumption relation. Care has to be taken to put the top and the bottom node in their proper positions, even if or ⊥ do not occur in the ontology.</p><p>Example 10 Consider again the ontology from Example 1. The saturation algorithm computes the following subsumptions (projected to atomic concepts): <ref type="figure">A ,</ref><ref type="figure">A,</ref><ref type="figure">B ,</ref><ref type="figure">A,</ref><ref type="figure">C ,</ref><ref type="figure">B,</ref><ref type="figure">A ,</ref><ref type="figure">B,</ref><ref type="figure">B ,</ref><ref type="figure">B,</ref><ref type="figure">C ,</ref><ref type="figure">C,</ref><ref type="figure">C ,</ref><ref type="figure">D,</ref><ref type="figure">D }</ref>, from which Algorithm 4 computes the following taxonomy (shown to the right):</p><formula xml:id="formula_42">subs = { A,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Optimizing Completion-Based Procedures</head><p>Many of the above optimizations are not specific to our procedure but can be adapted to the completion-based setting as well, and thus potentially benefit other reasoners. For example, our handling of large disjointness axioms from Section 5.3 can be readily applied both in completion-and even tableau-based reasoning.</p><p>The optimized implementation O • of the role composition rule R • from Section 5.2 leads straightforwardly to an analogous optimization of the completion rule CR11 in Fig. <ref type="figure" target="#fig_9">4</ref>. Note, however, that this optimization is meaningful only if one takes the view that an edge C, D ∈ R(R) also represents all edges C, D ∈ R(S) with R * O S and adjusts all completion rules accordingly, similarly as we did in Section 3.5.</p><p>The optimizations of redundant decomposition rules R - ∃ and R -from Section 5.1 are more problematic. It is still possible to formulate a redundancy condition for rule CR3 analogous to that of rule R - ∃ in Definition 1 (resp. Definition 5):</p><formula xml:id="formula_43">It is redundant to apply rule CR3 to E ∈ S(C) and E ∃R.D ∈ O if C, F ∈ R(R)</formula><p>and D ∈ S(F ) for some F.</p><p>A practical implementation of (a sufficient condition for) redundancy, like O ∃ is, however, more problematic, due to normalization. A straightforward reformulation of O ∃ for completion rules would give the following sufficient condition:</p><p>It is redundant to apply rule CR3 to E ∈ S(C) and E ∃R.D ∈ O if the premise E ∈ S(C) was produced by rule CR4 applied to C, F ∈ R(R), D ∈ S(F ), and ∃R.D E ∈ O for some F.</p><p>To implement this optimization, however, it is necessary to keep track not only of the rule by which E ∈ S(C) was derived, but also of the premise ∃R.D E ∈ O that has been used, since there can be several such axioms with the same E. Further, the optimization works only if existential restrictions were normalized using equivalences E ≡ ∃R.D. If more aggressive normalizations are used, such as those mentioned in Section 3.6, the optimization may not work. For example, if axiom A ≡ B ∃R.D is normalized like A B, A ∃R.D,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>∃R.D E, B E</head><p>A, and we derive C, F ∈ R(R), D ∈ S(F ), and B ∈ S(C), then we obtain E ∈ S(C) by CR4, and A ∈ S(C) by CR2, to which CR3 using A ∃R.D ∈ O is not blocked by the optimization. If instead of A ∃R.D we had produced two axioms A E and E ∃R.D by normalization, then a similar inference for E ∈ S(C) would have been blocked.</p><p>The problem of efficient taxonomy construction has been well studied in the literature (see, e.g., <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b33">34]</ref>). The CEL reasoner, in particular, employs an optimized procedure similar to Algorithm 4, which also iterates in the inner loop over direct subsumers instead of all subsumers <ref type="bibr" target="#b14">[15]</ref>. However, there is a subtle difference between the two procedures. In Algorithm 4 we iterate in the inner loop over the (current) direct subsumers of A (see line 6) and update these direct subsumers using the new subsumer C. The CEL algorithm, on the other hand, iterates over direct subsumers of C and 'marks' all such subsumers. The direct subsumers of A are then determined as those subsumers of A that have not been marked. Practically, this means that the direct subsumers of all strict subsumers C of A should be computed first. CEL does that in a recursive call of the method (which is again dangerous due to a potential stack overflow). Algorithm 4, on the other hand, can compute the direct subsumers of A without need to compute direct subsumers of other concepts. This makes Algorithm 4 better suitable for goal-directed transitive reduction (when direct subsumers need to be computed only for some given concepts, but not all of them), and also for parallel taxonomy construction (when direct subsumers of different concepts can be computed independently of each other).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Concurrent Saturation</head><p>In Section 5 we have presented several optimization techniques which can make ontology classification faster by reducing the number of operations to perform. However, it is also possible to accelerate the classification procedure by performing several operations in parallel. This way one can effectively make use of multi-core and multi-processor systems that become increasingly widespread. In this section, we discuss the key modifications of our saturation algorithm that are necessary for this. First, in Section 6.1 we discuss some common pitfalls about concurrent algorithms and datastructures, then in Section 6.2 we present a concurrent modification of our general saturation procedure, and finally, in Section 6.3 we describe a particular implementation of this procedure for EL + ⊥ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Thread-safe Algorithms and Datastructures</head><p>Consider the abstract saturation procedure described in Algorithm 1. Suppose there are several independent 'workers' that execute the while loop (lines 4-6) on different processors with the shared Todo and Closure. Will this procedure perform correctly?</p><p>The first problem is that with multiple workers, the instruction on line 5 may be executed even if the queue Todo is empty, despite the explicit check on emptiness before that. This is because other workers could have emptied the queue between the time when the worker has checked the queue on emptiness and the time it takes the next element from the queue. This illustrates one of the typical situations when correct serial algorithms stop working correctly in multi-threaded settings. Fortunately, it possible to fix this problem by testing the queue on emptiness when taking the next element from the queue, as shown in Algorithm 5. Here we assume that if Todo is empty, then Todo.takeNextElement returns a distinguished element null, which can be used in the condition of the while loop for the emptiness test.</p><p>A similar problem occurs in the implementation of the method process(expression) on lines 9, 10 of Algorithm 1: it may happen that two workers process the same expression at the same time, both see that it does not occur in Closure, and consequently apply the inference rules two times. Although the outcome of the procedure will still be correct, there will be inefficiency due to the duplicate work. It is likewise possible to avoid this problem by inserting an element in the set and testing if it occurs there at the same time. To this end, we assume that the method Closure.add(expression), in addition to inserting expression into Closure, returns true if expression did not occur in Closure and false otherwise. It is then easy to see that we can avoid this problem by moving Closure.add(expression) from line 10 to the condition of the if statement on line 9 of Algorithm 1.</p><p>The above modifications, however, are not enough to ensure that our algorithm behaves correctly with multiple workers, i.e., that it is thread-safe. It is also necessary that all operations with Todo and Closure work as expected even if called from multiple workers at the same time. That is, the datastructures implementing those collections must also be threadsafe. For example, when calling Closure.add(expression) from multiple workers for the same expression, this operation should return true for at most one worker. Standard implementation for collections may internally use similar control structures like in Algorithm 1, therefore, they are subject to the issues discussed above. It is possible to make sure that Clo- sure and Todo are never accessed from multiple workers using locks. But this largely defeats the purpose of parallelization since the workers would have to wait for each other in order to progress. Truly thread-safe datastructures that allow multiple workers to perform operations concurrently are difficult to implement, and even if implemented, may exhibit certain overheads when compared to conventional datastructures, which can reduce or even cancel out the potential gains. Existing programming libraries, however, typically include efficient thread-safe implementations of common datastructures used in concurrent programming, such as queues. In the next section, we demonstrate how to modify Algorithm 1 so that only Todo is required to be thread-safe, but not necessarily Closure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">The Abstract Concurrent Saturation Procedure</head><p>In this section we describe a concurrent modification of the saturation algorithm for computing the closure, which uses just concurrent queues and Booleans with atomic 'compare and swap' operations. The main idea is to distribute expressions according to 'contexts' in which the expressions can be used as premises of inference rules, and which can be processed independently by the workers. To this end, we assume that there is a finite set of contexts and a function getContexts(expression) assigning to every expression a subset of contexts such that, whenever an inference between several expressions is possible, at least one common context is assigned to all of these expressions. In Section 6.3 we present a concrete context assignment satisfying this requirement for the EL + ⊥ rules in Fig. <ref type="figure" target="#fig_0">3</ref>. Intuitively, the concurrent saturation procedure works as follows. When an expression is derived, it is 'sent' to all contexts assigned to this expression. Whenever a context receives an expression, it is 'activated' to be processed by some worker. Whenever a worker becomes available, it takes the next activated context and applies all inference rules, but only to the expressions which were sent to this context. The conclusions of such inferences can be sent again to multiple contexts and this process repeats. This idea is realized in Algorithm 6. We assume that every context c has a separate queue c.Todo and a separate set c.Closure, whose purpose is similar to those of Todo and Closure from Algorithm 1, but they only contain expressions to which c is assigned. In addition, the procedure maintains a queue activeContexts to keep all contexts c for which c.Todo is not empty. Queuing of expressions for processing is now done by calling, for every context c assigned to the given expression, the function c.enqueue(expression) (lines <ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref> which inserts expression into c.Todo and activates c. Activation of a context c should result in context c being added to activeContexts (see line 18, ignore line 17 for now). Each activated context is then repeatedly processed by workers in the main loop of Algorithm 6 (lines 4-7) similarly as in the main loop of Algorithm 1, except that the inferences are performed with the elements of context-local Todo and Closure. Since by our assumption, expressions can participate in inferences only if they are assigned to some common context, no inferences will be lost in this way. Note that the set of contexts and context assignment are always fixed and do not change during the saturation (but some contexts might never be activated).</p><p>In Algorithm 6 we assume that the queues Input, c.Todo for every c, and activeContexts are thread-safe, but we do not require thread-safety for any c.Closure. Instead, we ensure that each c.Closure is never accessed by more than one worker at a time. Note that c.Closure can only be accessed from within the method c.process(expression), which is only called after c is taken from the activeContexts queue in the main loop of the algorithm (lines 4-6). Therefore, it is sufficient to ensure that c can never be inserted into activeContexts if it already occurs there or the method c.process(expression) is being called by some worker. For this purpose, we use a Boolean flag c.isActive, which is set to true every time c is inserted into activeContexts and set back to false after c has been processed by some worker.</p><p>Take a look at the instruction on line 17 of method activate(c). There are two things that happen in this instruction. First, it is checked if the value of c.isActive is false, and if this is the case, it is set to true. Second, if the value of c.isActive has changed (from false to true), then the context c is inserted into activeContexts. This mechanism makes sure that (i) if c occurs in activeContexts then c.isActive is true, and (ii) c is inserted into activeContexts only if c.isActive was false. This way, c cannot be inserted into activeContexts if it already occurs there or being processed by a worker (during which c.isActive remains true).</p><p>It is, however, essential that the flag c.isActive is compared and changed in one instruction. Take a look at Algorithm 7, which provides a seemingly equivalent implementation of the method activate(c). This implementation is no-longer thread safe. Indeed, if two workers call activate(c) for some c at the same time, they can both see that c.isActive is false, set it to true, and insert c into activeContexts two times, after which c may be simultaneously processed by two different workers. This cannot happen with the implementation in Algorithm 6: if several workers call isActive.compareAndSet(false, true) at the same time, only for one of them this method can return true.</p><p>Note that the implementation of the queues c.Todo and activeContexts must still be thread-safe since several workers can insert elements into these queues at the same time during the calls of the function c.enqueue(expression). Also note that activation of a context c on line 15 of method c.enqueue(expression) should happen after inserting expression into c.Todo, not before that (that is, one cannot swap lines 14 and 15). Otherwise c may be inserted into activeContexts, processed by another worker, and deactivated before expression is inserted into c.Todo, and we end up with a context whose Todo queue is not empty, but it is not activated. Also note that line 21 is necessary because after deactivate(c) is called and before c.isActive is set to false, some other worker could insert an expression into c.Todo, so c must be reactivated in this case. These issues demonstrate that designing thread-safe algorithms is a difficult task and such algorithms are highly fragile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">The Concurrent Saturation Procedure for EL + ⊥</head><p>In this section we discuss how to turn the saturation procedure for EL + ⊥ presented in Section 4.2.3 into a concurrent one using Algorithm 6. First, we need to find a suitable context assignment that satisfies the requirement for the inference rules in Fig. <ref type="figure" target="#fig_0">3</ref> (that the premises of every rule should be assigned to at least one common context). A simple solution would be to use the inference rules themselves as contexts and assign to every expression the set of inference rules in which the expression can participate. This strategy, however, provides only for as many contexts as there are inference rules, so it may not be very effective with many workers. To find a better solution, note that all premises of the rules in Fig. <ref type="figure" target="#fig_0">3</ref> always have a common concept denoted as C. So, instead of assigning expressions to rules, we can assign expressions to the corresponding concepts. This gives us a much finer granularity for concurrent processing: there can be as many contexts as there are concepts in the input ontology. This should translate into a better scalability even with a large number of workers.</p><p>This context assignment determined by the rules in Fig. <ref type="figure" target="#fig_0">3</ref> is thus as follows: expressions of the form init(C), C D, or E R -→ C are assigned to the context C. Additionally, E R -→ C is also assigned to the context E because the expression may be used as the second premise of rule R • . Note that this assignment of contexts is optimal in the sense that every inference is possible in exactly one context (since the context C is uniquely determined by the inference), so the overall number of inferences performed by the workers does not increase.</p><p>Since the contexts c under our assignment are parts of expressions, it is possible to further 'compress' the representations of elements in c.Todo and c.Closure by removing the arguments that are uniquely determined by the context c as presented in Table <ref type="table" target="#tab_12">3</ref>. The context-local version of function process(expression) from Algorithm 2 that uses this context assignment and representation is given in Algorithm 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 11</head><p>In this example we show how the inferences from Example 4 are transformed when applying the concurrent saturation procedure in Algorithm 6. In Table <ref type="table">4</ref> we have listed all conclusions 23-37 in their Todo representation in the order they are derived in the respective contexts. The rules applied to these conclusions by Algorithm 8 are listed in the last column of the table. The rules indicate in which contexts they are applied to the current expression (assuming all the previous expressions have been processed), and which table entries from Examples 6 and 8 that were precomputed during the phases 1 and 2 of the saturation procedure (see Section 4.2) are used in the inferences. The conclusion of every inference appears in the respective context below the current line, unless it has already been derived (we do not list duplicate conclusions because no inference applies to them). Contexts are activated when the first unprocessed conclusion is derived in the context and deactivated when no unprocessed conclusions are left. For example, context A is activated when Init is produced, deactivated after ForwLink(R, C D) is processed, activated again when Sub(∃S.D) is derived, and, finally, deactivated after Sub(B) is processed. Note that the contexts A and D can be active at the same time, and thus can be processed in parallel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">System Overview</head><p>A practical implementation of the reasoning methods that we explained above is provided in the form of the ontology reasoner ELK, which is described in this section. ELK is a Java-based system to reason with OWL ontologies under Direct Semantics, which can be viewed as a slightly richer syntax for the DL ontologies discussed in this paper. ELK is free and open source, using a commercial-friendly Apache 2 license. <ref type="foot" target="#foot_7">8</ref>As of this paper, the latest stable release ELK 0.3.2 supports all features of EL + ⊥ , that is, conjunction (ObjectIntersectionOf), existential restriction (ObjectSomeValuesFrom), top (owl:Thing), bottom (owl:Nothing), and complex role inclusions (property chains). This also covers transitive and reflexive properties and disjoint classes, for which OWL provides </p><formula xml:id="formula_44">C Init C.Init = true C D C Sub(D) D ∈ C.subs E R -→C C BackLink(R, E) R, E ∈ C.backLinks E ForwLink(R, C) R, C ∈ E.forwLinks</formula><p>syntactic shortcuts. Moreover, ELK implements support for ABoxes and ObjectHasValue restrictions as discussed in Appendix A. Finally, ELK provides some preliminary support for datatypes, using a simplified syntactic matching to compare values. The reasoning tasks supported in ELK are ontology consistency checking, TBox classification, and ABox realization.</p><p>ELK implements the concurrent saturation algorithm described in Section 6 and all optimization techniques detailed in Section 5. The number of concurrent workers used by ELK can be configured, where the same number will be used for all reasoning tasks (saturation of roles (properties), saturation of concepts (classes), transitive reduction). The default is to use the number of cores reported by the operating system; this usually includes virtual cores. In addition, ELK generally uses one parallel worker to generate the ontology index (Section 4.2.1) while loading an ontology.</p><p>ELK is a flexible system that can be used in a variety of configurations. This is supported by a modular program structure that is organized using the Apache Maven<ref type="foot" target="#foot_8">9</ref> build manager for Java. Maven can be used to automatically download, configure, and build ELK and its dependencies, but there are also pre-built packages for the most common configurations. The modular structure also separates the consequence-based reasoning engine from the remaining components, which facilitates extension of the system with new language features.</p><p>The main software modules of ELK are shown in Fig. <ref type="figure" target="#fig_16">9</ref>. The arrows illustrate the information flow during classification. The two independent entry points are the command-line client and the Protégé plug-in to the left. The former extracts OWL ontologies from files in OWL Functional-Style Syntax (FSS), while the latter communicates with Protégé <ref type="bibr" target="#b56">[57]</ref> through the OWL API <ref type="bibr" target="#b43">[44]</ref>. All further processing is based on ELK's own representation of OWL objects (axioms and expressions) that does not depend on the (more heavyweight) OWL API. The core of ELK is its reasoning module, which was described in Sections 4-6.</p><p>ELK is distributed in three pre-built packages, each of which includes the reasoner module. The standalone client includes the command-line client and the FSS parser for reading OWL ontologies. The Protégé plugin allows ELK to be used as a reasoner in Protégé and compatible tools such as Snow Owl. <ref type="foot" target="#foot_9">10</ref> The OWL API bindings package allows ELK to be used as a software library that is controlled via the OWL API interfaces. a proper OWL EL version of GALEN, which is obtained from the CO-ODE version of GALEN <ref type="foot" target="#foot_12">13</ref> by removing inverse role and functional role axioms. This version of the ontology has been used extensively in the past for evaluating reasoners <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b52">53,</ref><ref type="bibr" target="#b72">73,</ref><ref type="bibr" target="#b93">94]</ref>. It is similar to GALEN7 but its only role compositions are transitivity axioms. We also used two versions of the Gene Ontology <ref type="foot" target="#foot_13">14</ref> which we call GO1 and GO2. The older GO1, published in 2006, has been used in many performance experiments <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b72">73,</ref><ref type="bibr" target="#b93">94,</ref><ref type="bibr" target="#b103">104]</ref>. GO2 is the version of March 2012 and uses significantly more features than GO1, including negative occurrences of conjunctions and existential restrictions, and even a few disjointness axioms. To obtain further test data, we selected some of the largest ontologies listed at the OBO Foundry <ref type="bibr" target="#b96">[97]</ref> and the Ontobee <ref type="bibr" target="#b110">[111]</ref> websites that were in OWL EL but were not just plain taxonomies, i.e., included some non-atomic concepts. This gave us the Chemical Entities of Biological Interest (ChEBI), the e-Mouse Atlas Project (EMAP), the Foundational Model of Anatomy (FMA), the Fly Anatomy, and the Molecule Role ontology. All ontologies that we are allowed to publish can be downloaded from the ELK website. <ref type="foot" target="#foot_14">15</ref>Tables <ref type="table" target="#tab_13">5</ref> and<ref type="table" target="#tab_14">6</ref> show various statistics about the ontologies from our benchmark suite. Table <ref type="table" target="#tab_13">5</ref> shows the number of various axiom types; the only logical axiom not mentioned in the table is one reflexive role axiom in ANATOMY. Table <ref type="table" target="#tab_14">6</ref> shows the number of atomic concepts, roles, and the number of positive and negative occurrences of conjunctions and existentials. It turns out that many of the smaller ontologies in our suite contain only concept inclusion axioms of the very simple form A B and A ∃R.B, where A and B are atomic concepts. We will refer to these ontologies as simple and to other as complex as indicated in Tables <ref type="table" target="#tab_13">5</ref> and<ref type="table" target="#tab_14">6</ref>. It is interesting to note that the simple ontologies can be fully classified just by computing the transitive closure of the told subsumptions A B ignoring the remaining axioms. To the best of our knowledge, no reasoner currently takes advantage of this fact. ELK also applies rule R + ∃ to the positive existentials in these ontologies even though, due to lack of negative existentials, the resulting links can never participate in rule R - ∃ . All of our experiments are focused on terminological reasoning, which is currently the most common reasoning problem used in applications involving EL ontologies <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b80">81,</ref><ref type="bibr" target="#b84">85]</ref>. Although the OWL EL standard comprises many features, such as assertions, nominals, and datatypes, these are difficult to find in existing OWL EL ontologies. One of the reason is that many ontologies were not developed in OWL from the beginning, but have been converted to OWL from other formats, such as OBO <ref type="bibr" target="#b27">[28]</ref>, Grail <ref type="bibr" target="#b85">[86]</ref>, or frame-like languages, which did not have those features. In our previous experiments with nominals <ref type="bibr" target="#b55">[56]</ref>, we had to resort to synthetically generated data, but, arguably, such experiments are of a limited value. For the same reason, we also do not evaluate the optimized reasoning with disjointness axioms described in Section 5.3. For a quick (synthetic) evaluation, we Simple:</p><formula xml:id="formula_45">GO1 28,896 - - - - 1 - ChEBI 67,182 - - - - 2 - EMAP 13,730 - - - - - - FMA 126,544 - - 3 - 1 - Fly Anatomy 19,137 - 61 10 - 3 - Molecule Role 9,627 - - - - 2 -</formula><p>modified SNOMED CT by declaring all leaf concepts (i.e., concepts that do not subsume other atomic concepts) disjoint, leading to a disjointness axiom with about 200,000 concepts. This did not lead to any significant difference in ELK's classification time compared to the original ontology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Performance Comparison with Other Reasoners</head><p>We compared ELK 0.3.2 to the specialized OWL EL reasoners CEL 1.1.2 <ref type="bibr" target="#b13">[14]</ref>, jcel 0.18.0 <ref type="bibr" target="#b71">[72]</ref>, the REL reasoner from TrOWL 1.2 [102], and Snorocket 2.0.5 <ref type="bibr" target="#b65">[66]</ref>, to general OWL reasoners FaCT++ 1.6.0 <ref type="bibr" target="#b102">[103]</ref>, HermiT 1.3.6 <ref type="bibr" target="#b75">[76]</ref>, JFact 0.9, <ref type="foot" target="#foot_15">16</ref> Pellet 2.3.0 <ref type="bibr" target="#b95">[96]</ref>, and Rac-erPro 2.0 build 20121209 <ref type="bibr" target="#b35">[36]</ref>, and to experimental consequence-based reasoners CB r.12 <ref type="bibr" target="#b50">[51]</ref> and ConDOR r.12 <ref type="bibr" target="#b94">[95]</ref>. We did not perform experiments with Cheetah <ref type="bibr" target="#b93">[94]</ref> because by the time of writing, this reasoner was not released. We ran all reasoners in their default settings. CEL, jcel, REL, and Snorocket are typical OWL EL systems that implement completionbased procedures <ref type="bibr" target="#b8">[9]</ref>. CB and ConDOR are prototype implementations of consequencebased algorithms for logics that are more expressive than EL. FaCT++, JFact, Pellet, and RacerPro use tableau algorithms, and HermiT is based on a hypertableau calculus. The general OWL reasoners may also use other more efficient reasoning methods when applied to EL ontologies. Section 9 provides further details, and also discusses various other systems that we have not included in this evaluation. Recent versions of Snorocket implement a context-based concurrent procedure which is similar to ours; like ELK, on our architecture Snorocket defaults to using 8 concurrent workers. The remaining reasoners do not take advantage of concurrency.</p><p>Due to the technical differences between the systems, we have used two different experimental setups for our evaluation. Most reasoners could be evaluated using the standard interface of the OWL API <ref type="bibr" target="#b43">[44]</ref>, which allows us to access the reasoners uniformly and facilitates fair comparison. For the case of CB, CEL, ConDOR, and RacerPro, this general setup was not appropriate, for a variety of reasons as explained below. The results obtained in these cases can still be useful indicators of general performance, but some caution is needed when using them to compare systems.</p><p>In the first experimental setup, we parsed and loaded the ontologies using the OWL API 3.4. Table <ref type="table" target="#tab_15">7</ref> shows the wall-clock time each reasoner spent executing the classification method precomputeInferences(CLASS_HIERARCHY). Note, however, that a reasoner may perform certain computations already during ontology loading before calling the classification method; these typically include normalization and indexing of axioms. For this reason, in Table <ref type="table" target="#tab_16">8</ref> we also show the overall wall-clock time for loading and classification. Possible failures for a reasoner are time (no result after 30min), mem (out-of-memory error), stack (stack overflow), N/A (reasoner rejects the ontology due to non-regular role compositions), and exc (program error).</p><p>In our second experimental setup, we measured classification times using a specific method for each reasoner. We ran CB as a plugin in Protégé 4.2, ConDOR and CEL from the command line, and RacerPro using its client RacerPorter. For CB, ConDOR, and Rac-erPro, these are the setups suggested by the developers for most accurate evaluation. CEL requires a Unix-like operating system; we used Linux Mint 13 on the same hardware as in all other experiments. CB, ConDOR, and RacerPro were evaluated on the same Microsoft Windows 7 platform as all other systems. Table <ref type="table" target="#tab_17">9</ref> shows the classification times as reported by the reasoners. The only form of role composition supported by CB and ConDOR is transitivity, hence they are not applicable to any complex ontology apart from GALEN-OWL. However, the single role composition in SNOMED CT is redundant in the sense that rule R • is never applied during classification, so we decided to measure the running times of CB and ConDOR on SNOMED CT even though they discard this role composition.</p><p>Overall, the results of the evaluation show that ELK compares favorably with the other reasoners. While many reasoners in our comparison show similar running times on the simple ontologies, ELK has a significant advantage on the complex ontologies. In particular, ELK is the only reasoner that can classify GALEN8. It can load and classify SNOMED CT in under 10 seconds. Since ELK can update its index structure incrementally without having to reload the whole ontology, subsequent reclassification of SNOMED CT due to small changes in the ontology is likely to take only about 5 seconds as reported in Table <ref type="table" target="#tab_15">7</ref>.</p><p>Regarding memory requirements, we can report that in our experiments ELK could classify SNOMED CT with only 2GB of heap space when used through the OWL API, and with as little as 1GB of heap space when used standalone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Optimizations of Inference Rules</head><p>In our next experiment we evaluated the effect of the optimizations O and O ∃ from Section 5.1, and of the optimization O • from Section 5.2. We excluded the simple ontologies from this experiment: they have no negative occurrences of conjunctions and existential  restrictions, so O and O ∃ do not apply, and, although some of the simple ontologies contain transitive roles, there are no subrole relationships between transitive roles in these ontologies, so O • does not apply either. We evaluated five configurations of the classification algorithm: with none of the three optimizations O , O ∃ , and O • , with one of these optimizations turned on at a time, and with all the three optimizations together (the default setting). We measured the overall classification time with one concurrent worker, the number of derived axioms including multiplicity, and the number of uniquely derived axioms. The results are shown in Table <ref type="table" target="#tab_18">10</ref>.</p><p>First, observe that on SNOMED CT no link C R -→ D is derived more than once. This is because, even though SNOMED CT contains one role composition axiom, rule R • is never applied on this ontology. The links are therefore derived only by rule R - ∃ , which can never produce the same link twice. Next, we discuss each individual optimization in turn.</p><p>The optimization O avoids the decomposition of C D 1 D 2 into C D i for i = 1, 2 in case the former subsumption has been obtained by the composition of the latter two. Thus, the optimization can decrease the multiplicity but not the number of unique subsumptions, and it has no effect on links at all. Furthermore, the optimization makes the multiplicity of subsumptions sensitive to the order of rule applications: the decomposition of C D 1 D 2 is avoided only if the subsumption is derived by rule R + before it is derived by any other rule. The optimization decreases the multiplicity of subsumptions on each ontology in this experiment, albeit for ANATOMY and GO2 the difference is small. In all cases, the differences in classification times were only marginal.</p><p>The optimization O ∃ avoids the decomposition of C ∃R.D into init(D) and C R -→ D in case the first subsumption has been obtained by composition, but in this case it is possible that the avoided conclusions will not be derived by the algorithm at all. Since the optimization can even avoid initialization of concepts, it can decrease all the four numbers shown in Table <ref type="table" target="#tab_18">10</ref>; furthermore, it makes all the four numbers sensitive to the order of rule applications. Even though for the classification task each atomic concept is already initialized on input, the optimization can still avoid initialization of complex concepts in existential restrictions. We have, however, not observed this on any of the ontologies in this experiment, which is why we have obtained the same number of uniquely derived subsumptions both with and without O ∃ . On the other hand, the optimization has substantially reduced The optimization O • avoids the derivation of some links by rule R • without affecting the set of subsumptions that are derivable by the algorithm. Therefore, the optimization can decrease the multiplicity and the number of unique links, and then, due to R + ∃ , also the multiplicity of (but not the number of unique) subsumptions. Indeed, the optimization decreases all these three numbers on all the versions of GALEN, with some improvement in classification times for GALEN7 and GALEN8. Since rule R • is never applicable on SNOMED CT, the optimization has no effect on this ontology. Finally, for ANATOMY and GO2 we only see a decrease in the multiplicity of links: this is negligible for GO2 but considerable for ANATOMY where the speedup reaches 1.31. Unlike the previous two optimizations, R • is not sensitive to the order of rule applications.</p><p>Finally, we discuss the case of using all three optimizations together. Since there is no interaction between O and the remaining two optimizations, adding O to O ∃ and/or O • results in exactly the same reduction in the multiplicity of subsumptions as with O alone. More interestingly, O ∃ and O • optimize the derivation of links in two different ways, and our experiments show their combined effect can be considerably larger than the effect of either of the two optimizations alone.</p><p>Although all the three optimizations had only limited effect on GO2, they proved to be effective on the remaining ontologies, altogether speeding up classification by a factor of 1.41 on SNOMED CT and as much as 2.45 on ANATOMY and GALEN8. Out of the three optimizations considered in this section, O ∃ appears to be the most useful one, while O does not seem to be very significant in practice. On the other hand, it is trivial to include O if one already implements O ∃ . The last optimization O • is effective only on ontologies that have subrole relations between roles occurring in role compositions, such as ANATOMY and the variants of GALEN in our experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Concurrency</head><p>Next, we evaluated the effect of increasing the number of concurrent workers in ELK. Since the machine on which we performed the experiments has 4 physical cores which, due to hyper-threading, appear to the operating system as 8 virtual cores, we experimented with up to 8 concurrent workers. The measured classification times are shown in Table <ref type="table" target="#tab_19">11</ref>. <ref type="foot" target="#foot_16">17</ref>The results show that increasing the number of workers improves the performance of ELK, and that the improvement is more pronounced on the largest ontologies: while ELK achieves a speedup for 8 workers by a factor of 3.83 on SNOMED CT and 3.40 on GALEN8, the speedups are below 2 on many of the smaller ontologies. To further test the hypothesis that the speedup improves with increasing the size of an ontology, we repeated this experiment on the union of all the simple ontologies. As shown in the last row of Table <ref type="table" target="#tab_19">11</ref> under the name UNION, this resulted in a speedup by a factor of 2.45 which is considerably higher than for any of the individual ontologies.</p><p>Our experiments confirm that concurrent processing can offer improvements for ontology classification on common computing hardware. On the other hand, the experiments demonstrate that the improvement factor is far from linear, and that it appears to be higher on larger ontologies. There can be many causes for this effect, such as dynamic CPU clocking, shared Java memory management and garbage collection, hardware bottlenecks in CPU caches and data transfer, or JIT compilation overheads. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Transitive Reduction</head><p>Finally, we evaluated the difference between the 'naive' Algorithm 3 and the 'optimized' Algorithm 4 for transitive reduction from Section 5.4. For this experiment, we implemented the two algorithms exactly as shown in Section 5.4 even though the naive algorithm is incorrect in the presence of equivalent concepts. For each of the two algorithms, Table <ref type="table" target="#tab_20">12</ref> shows the running time and the number of passes through the inner for loop of the algorithm. The experiments show that the optimized algorithm is about 2-3 times faster than the naive algorithm on SNOMED CT, ANATOMY, GALEN7, and GALEN8. The optimized algorithm always requires substantially fewer passes through the inner loop, with the exception of the EMAP ontology, which entails no non-trivial subsumptions between atomic concepts at all so that the transitive reduction task is trivial. Interestingly, this reduced number of passes does not always translate into the corresponding performance improvement, possibly because the optimized algorithm performs more set additions and removals, which are more expensive than membership checks performed by the 'naive' algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Related Work</head><p>We discuss related work for three different aspects of our contribution: OWL EL reasoning (Section 9.1), consequence-and rule-based reasoning (Section 9.2), and concurrent and distributed reasoning (Section 9.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Reasoning in OWL EL and Beyond</head><p>Favorable computational properties have long been an important motivation for the study of the EL family of description logics <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b11">12]</ref>. Most OWL EL implementations use variations of completion-based procedures, which we described in more detail in Section 3.6. First such procedures were proposed for ELH <ref type="bibr" target="#b21">[22]</ref> and EL ++ <ref type="bibr" target="#b7">[8]</ref>; later works extend this approach to also cover reflexive roles and range restrictions <ref type="bibr" target="#b8">[9]</ref>, Boolean role constructors <ref type="bibr" target="#b87">[88]</ref>, and local reflexivity <ref type="bibr" target="#b59">[60]</ref>.</p><p>A number of reasoners have been implemented for the EL family. The first such system was CEL <ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref>, whose implementation we described in Section 4.4. Various later systems have reimplemented the 'CEL algorithm' 18 in order to provide better compatibility with tools, such as the OWL API and Protégé, or to improve performance for some ontologies, such as SNOMED CT. These systems include Snorocket <ref type="bibr" target="#b65">[66]</ref>, TrOWL REL [102], and jcel <ref type="bibr" target="#b70">[71]</ref>. A prototype reasoner Cheetah <ref type="bibr" target="#b93">[94]</ref> was used to investigate the application of linear-time algorithms for propositional Horn logic in EL + reasoning. As discussed in Section 4.4, the results suggest that, at least for current EL ontologies, the performance gains of this optimization do not outweigh the implementation overhead. We have arrived at similar conclusions when experimenting with prototype versions of ELK for reasoning with role chains <ref type="bibr" target="#b53">[54]</ref> and (unrestricted) nominals <ref type="bibr" target="#b55">[56]</ref>. For example, it is hard to come up with examples that would require non-safe use of nominals in OWL EL ontologies. The procedure for safe nominals, as described in Appendix A of this paper, should be, therefore, sufficient in most of the cases.</p><p>Other systems have experimented with alternative approaches to reasoning with EL ontologies. The reasoners DB <ref type="bibr" target="#b28">[29]</ref> and OREL <ref type="bibr" target="#b62">[63]</ref> explored the use of relational database systems in EL reasoning. While feasible in principle, this approach does not match the performance or scalability of the best in-memory EL reasoners. Another recent approach shows the applicability of Answer Set Programming engines to OWL EL reasoning <ref type="bibr" target="#b30">[31]</ref>, using the DReW reasoner <ref type="bibr" target="#b111">[112]</ref> to implement a rule-based calculus for OWL EL <ref type="bibr" target="#b59">[60]</ref>. The approach aims at providing efficient use of OWL EL ontologies in dl-programs, thus enabling a form of rule-ontology integration. Most recently, a prototype implementation for EL reasoning on embedded devices has been studied <ref type="bibr" target="#b34">[35]</ref>. A particular challenge in this context is the very low amount of available memory that allows only very small ontologies to be classified.</p><p>Finally, a number of more general-purpose systems provide some dedicated optimizations for (fragments of) OWL EL. FaCT++ <ref type="bibr" target="#b102">[103]</ref> reduces the number of subsumption tests for completely defined concepts, which frequently occur in GO1 and SNOMED CT <ref type="bibr" target="#b103">[104]</ref>. An extension of this optimization with structural pseudo-model embedding has been successfully used by RacerPro to classify SNOMED CT <ref type="bibr" target="#b73">[74]</ref>. HermiT <ref type="bibr" target="#b75">[76]</ref> uses an optimization that can completely avoid subsumption tests for deterministic ontologies (including EL) <ref type="bibr" target="#b33">[34]</ref>: subsumptions can be just read out of the models produced for concept satisfiability tests. The latest version of Pellet <ref type="bibr" target="#b95">[96]</ref> can apparently switch to a specialized procedure when the ontology is within a fragment of OWL EL. 19 HermiT and Pellet, however, were still unable to classify SNOMED CT in our experiments. CB reasoner uses a consequence-based algorithm for Horn-SHIF <ref type="bibr" target="#b50">[51]</ref>, which works similarly to the procedure presented in this paper when restricted to EL (except for concurrency). A similar support for functional and inverse roles (which are outside of OWL EL) has recently been added to jcel <ref type="bibr" target="#b71">[72]</ref>.</p><p>While most works focus on ontology classification and standard reasoning problems, EL-type logics have also been considered for other reasoning tasks, notably conjunctive query answering <ref type="bibr" target="#b57">[58,</ref><ref type="bibr" target="#b63">64]</ref>, least common subsumer computation <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b16">17]</ref>, unification <ref type="bibr" target="#b6">[7]</ref>, and interpolation <ref type="bibr" target="#b78">[79]</ref>. These reasoning services have yet to make it into common tools, although some prototype implementations exist. 9.2 Rule-, Consequence-, and Saturation-Based Reasoning Rules of inference are a versatile approach to automated deduction, and saturation under a set of inference rules is prominently used in several areas. In databases, this is called materialization and has applications in data integration, constraint repair, and query answering <ref type="bibr" target="#b0">[1]</ref>. In theorem proving, saturation is a key technique for many resolution-based calculi <ref type="bibr" target="#b17">[18]</ref>. In production rule systems, similar ideas are applied to forward-chaining of rules <ref type="bibr" target="#b31">[32]</ref>.</p><p>The abstract saturation procedure described in Section 4.1 is inspired by the given clause approach/set of support strategy in theorem proving <ref type="bibr" target="#b108">[109]</ref>, which is similar to the seminaive evaluation of Datalog queries <ref type="bibr" target="#b0">[1]</ref>. Production rule systems typically employ a variant of the Rete algorithm for applying rules, which largely avoids iterations over processed facts by creating more complex structures in working memory <ref type="bibr" target="#b31">[32]</ref>. Related methods are the linear evaluation strategy for Horn rules studied in Cheetah <ref type="bibr" target="#b93">[94]</ref>, and ELK's partial join computation described in Section 4.3. These results show that this approach can be useful in OWL reasoning but does not pay off in all cases.</p><p>The EL reasoning procedure described herein is most closely related to consequencebased procedures. The first such procedure was described for Horn-SHIQ ontologies and implemented in the CB reasoner <ref type="bibr" target="#b50">[51]</ref>. Later, similar procedures have been formulated for Horn-SROIQ <ref type="bibr" target="#b79">[80]</ref>, and (non-Horn) ALCH <ref type="bibr" target="#b94">[95]</ref>. The differences between completionbased, consequence-based procedures <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b21">22]</ref>, and the proof-theoretic procedure by Hofmann <ref type="bibr" target="#b40">[41]</ref> are discussed in detail in Section 3.6.</p><p>Rule-based approaches have also been applied to reasoning in the OWL 2 Profiles <ref type="bibr" target="#b61">[62]</ref>. OWL EL was discussed in Section 9.1 before. Another common use of rule-based calculi is instance retrieval in OWL RL <ref type="bibr" target="#b74">[75]</ref> and its sublanguages, especially pD * (a.k.a. OWL-Horst) <ref type="bibr" target="#b46">[47]</ref> and RDFS <ref type="bibr" target="#b23">[24]</ref>. These calculi include inference rules that are sound only under the RDF-Based Semantics of OWL; sound calculi for the DL-based Direct Semantics of OWL are easily obtained by omitting these rules. Various (partial) implementations of OWL RL rule calculi have been used in distributed reasoning, discussed in more detail below. It has also been argued that rule-based reasoning is suitable for embedded devices that have very limited resources; this has been explored for both OWL EL <ref type="bibr" target="#b34">[35]</ref> and OWL RL <ref type="bibr" target="#b92">[93,</ref><ref type="bibr" target="#b99">100]</ref>. Most works on OWL RL reasoning focus on instance retrieval. Sound and complete rulebased calculi for classification in OWL RL have been developed only recently <ref type="bibr" target="#b60">[61]</ref>.</p><p>For further optimizing the application of rules, various works on OWL RL distinguish between static/pre-computed and dynamic/inferred premises of inference rules <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b105">106]</ref>. This can be compared to our distinction of side conditions and premises, which serves a similar purpose. The OWL RL reasoner SAOR pre-instantiates static premises (side conditions) of rules to obtain so-called rule templates, and indexes these templates for quick access based on the relevant dynamic premise <ref type="bibr" target="#b42">[43]</ref>. While conceptually different, this method leads to indexing structures for rule applications similar to the ones in ELK.</p><p>In general, the efficient implementation of rule-based computations is also related to the topic of database query optimization, since rule bodies can be considered as conjunctive queries. General methods of optimizing conjunctive queries (i.e., join-project-select queries) are thus applicable; see, e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr">Chapter 6]</ref>. Approaches that use a fixed set of rules like ELK can optimize join computation already when designing the algorithm, as done in Sections 5.2 and 4.3. Our concrete join implementation in ELK corresponds to a nested loop join that uses hash-based indexing structures to largely eliminate the inner loop. Selecting the smaller relation for the outer loop in Section 4.3 is a simple form of join order optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">Concurrent, Distributed, and Parallel Reasoning</head><p>Our work is not the first to address the problem of concurrent OWL reasoning. Notable earlier works include an approach for parallelizing (incomplete) structural reasoning algorithms <ref type="bibr" target="#b18">[19]</ref>, tableau procedures that explore non-deterministic choices concurrently <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b66">67,</ref><ref type="bibr" target="#b69">70,</ref><ref type="bibr" target="#b109">110]</ref>, a resolution calculus for ALCHIQ where inferences are exchanged between distributed workers <ref type="bibr" target="#b88">[89]</ref>, and a distributed classification algorithm that can be used to concurrently invoke (serial) OWL reasoners for checking relevant subsumptions <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>. Experimental evaluations in each case indicate potential advantages on selected examples, but further implementation and evaluation is often needed to demonstrate a clear performance advantage over state-of-the-art systems.</p><p>Several other works have studied concurrency in lightweight ontology languages. Closest to our approach is a distributed MapReduce-based algorithm for EL + <ref type="bibr" target="#b76">[77]</ref>. However, this idea has not been empirically evaluated, and it has been argued that it ignores several practical problems <ref type="bibr" target="#b89">[90]</ref>. Saturation-based reasoning with shared memory has recently been explored for RDFS <ref type="bibr" target="#b37">[38]</ref>. This approach also investigates the use of alternative computation platforms, such as many-core GPUs, which bears some challenges related to memory management.</p><p>Other works focus on distributed reasoning over many machines, instead of sharedmemory parallelism on one machine. A direct approach for achieving this is to pre-partition the input and to distribute the partitions to several processing nodes for reasoning. Some form of message transfer between nodes is usually required to exchange certain inferences. Relevant theoretical results have been developed for the general case of first-order deduction <ref type="bibr" target="#b1">[2]</ref>. Several works on partition-based ontology reasoning focus on (subsets of) OWL RL <ref type="bibr" target="#b77">[78,</ref><ref type="bibr" target="#b97">98]</ref>. Another approach to partitioning in OWL is the computation of modules <ref type="bibr" target="#b26">[27]</ref>, which has also been considered for distribution and related optimizations recently <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b104">105]</ref>.</p><p>Other prominent approaches to distributed reasoning use MapReduce as a computational framework. Many related works focus on the distribution of reasoning with assertional data using weaker schema-level modeling languages pD * and (fragments of) RDFS <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b58">59,</ref><ref type="bibr" target="#b106">107,</ref><ref type="bibr" target="#b107">108]</ref>. These works are distinguished from our approach by their goal to manage large-scale data (in the range of billions of axioms), which is beyond the memory capacity of a single machine. Accordingly, computation is distributed to many servers without memory sharing. Yet, we can find similarities in term-based distribution strategies <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b76">77,</ref><ref type="bibr" target="#b105">[106]</ref><ref type="bibr" target="#b106">[107]</ref><ref type="bibr" target="#b107">[108]</ref> and indexing of rules <ref type="bibr" target="#b42">[43]</ref> with our strategy of assigning contexts to axioms.</p><p>Our abstract saturation procedure from Section 4.1 is closely related to saturation-based theorem proving <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b108">109]</ref>, and it may seem that concurrent extensions of this procedure as described in Section 6.2 should be known in this area. Surprisingly, this appears not to be the case. The closest to our approach is the strategy used in the theorem prover ROO <ref type="bibr" target="#b67">[68]</ref>, in which several workers apply inference and simplification rules in parallel and store the result in a shared fact database. It is assumed, however, that the access to the database is serialized, which can be the main bottleneck of the procedure when many facts are produced at the same time. More recently, from version 2.0.0, Snorocket implements a context-based concurrent procedure inspired by our approach <ref type="bibr" target="#b52">[53]</ref>. <ref type="foot" target="#foot_17">20</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Conclusions</head><p>In this paper we have presented many details of the ELK reasoner ranging from theory to implementation that make ELK one of the most competitive ontology reasoning systems available today. Despite its relatively short history, ELK has already been used in many biomedical applications <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b80">81,</ref><ref type="bibr" target="#b100">101]</ref>, in which often it was the only reasoner that is able to handle the large volumes of data involved with a reasonable performance.</p><p>From our experiments in Section 8, we can summarize that the most significant performance improvement was due to the use of the concurrent saturation procedure (Section 6.3), achieving a speedup factor as high as 3.8. This improvement, however, may depend on the number of processors/cores available. Optimization of inference rules, in particular, avoiding decomposition of negative existential restrictions (Section 5.1) comes second. The speedup factor here was reaching 2.5. The combinations of these techniques can result in more than 8 times speedup, such as in the case of GALEN8. It is difficult to estimate the improvements gained by other optimizations, such as indexing (Section 4.2.1) or efficient joint computation (Section 4.3), and in general, by our inference rules in Fig. <ref type="figure" target="#fig_0">3</ref> and our approach for computing the closure using Algorithm 1, since those features cannot be easily switched off. Thus, one can only speculate about possible reasons why completionbased reasoners, such as CEL and jcel were considerably slower in our experiments even for ELK without optimizations. The most likely reason seems to be the differences in strategies for rule applications, as discussed in Section 4.4. Also the difference in the inference rules may play a significant role, in particular dealing with role hierarchies as discuss in Section 3.5. Finally, the difference may be due to some poor implementation practices, such as unbounded recursive calls mentioned in Sections 4.4 and 5.5. Snorocket, for example, exhibits a much better performance even though it is claimed to implement the same procedure as CEL <ref type="bibr" target="#b65">[66]</ref>.</p><p>Many optimizations and improvements that make ELK so 'incredible' are not limited to just EL. The consequence-based reasoners CB and ConDOR, which use similar techniques as ELK, support more complex (EXPTIME) DLs <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b94">95]</ref> and yet retain a comparable performance (when disregarding concurrency). Thus, polynomial complexity of EL does not really explain the efficiency of our procedures in practice. In fact, the estimates obtained at the end of Section 3.5 for the rules in Fig. <ref type="figure" target="#fig_0">3</ref> are not even remotely similar to the numbers obtained by our experiments in Table <ref type="table" target="#tab_18">10</ref>. For example, for SNOMED CT the analysis would give a bound of about 90 billion unique subsumptions and 5 trillion links, whereas in our experiments even without optimizations we obtain less then 15 million and 4 million, respectively. The number of inferences predicted by this analysis is even more astronomical. If our procedure would behave according to this estimate, it would consume petabytes of memory and take millions of years to finish. Some ideas presented in this paper are not even specific to DLs at all. For example, the abstract concurrent saturation procedure described in Section 6.2 can be used for parallel computation of the deductive closure under essentially any inference system. This paper mainly focuses on techniques that contribute to the performance of ELK. This does not mean that there are no other interesting enhancements. For example, ELK supports interrupting and restarting of reasoning tasks, which was recently argued to be important in certain applications <ref type="bibr" target="#b34">[35]</ref>. There is a mechanism for batch processing of saturation jobs that lets the system recognize when the saturation for an input concept is computed without waiting for all input concepts to be processed. This is used to execute other tasks in parallel, such as the computation of direct subsumers for concepts. While not necessarily improving performance, these features may certainly widen possible uses of ELK.</p><p>ELK is currently under heavy development. Therefore, at this time, we do not present more specific application details, such as description of the API, summary of the classes, or source code, as this information may quickly become outdated. Although this paper cannot serve as a developer manual, it can still be a good starting point for those wishing developing or using the system. ELK is an open source project, and any contribution is welcome.</p><p>There are many interesting directions for future work. Not all OWL EL features are currently covered by ELK. We have recently studied 'pay-as-you-go' extensions of our approach to nominals <ref type="bibr" target="#b55">[56]</ref>, but there are some technical problems yet to be solved before this feature is fully integrated into the mainstream. To support datatypes, we plan to integrate the rules for safe numerical datatypes <ref type="bibr" target="#b68">[69]</ref>. This result can be used even with datatype restrictions outside of the OWL EL profile. The notion of context introduced in Section 6 provides a natural way to localizing inferences. This can be used not only to perform inferences in parallel, but potentially also for incremental reasoning <ref type="bibr" target="#b25">[26]</ref>, axiom pinpointing <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b82">83]</ref>, and debugging <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b90">91]</ref>. Some preliminary work in this direction is already done <ref type="bibr" target="#b51">[52]</ref>.</p><p>As an interesting theoretical problem, one can mention the question of whether the notion of redundancy introduced in Section 3.2 can be generalized to other rules than R - ∃ . Specifically, can applications of rules R H and R • likewise be avoided if they produce links E R -→ C such that {E R -→ D, D C} ⊆ Closure for some D? Tractable algorithms are only a first step towards efficient ontology reasoning systems. Careful design, optimization, implementation, and analysis are at least as significant. Thus, similar to other reasoning approaches, such as tableau or resolution, implementation and optimization techniques for consequence-based procedures are important research topics. This work makes one of the first contributions to this area.</p><p>in particular, we have J |= N(O) and J |= N(α), which contradicts our assumption</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N(O) |= N(α).</head><p>As a particular case of the previous lemma, we can have the following sufficient condition for checking unsatisfiability of ontologies with assertions. Proof Let Closure be the set of subsumptions derivable by the rules in Fig. <ref type="figure">2</ref> w.r.t. N(O) and J the canonical model defined w.r.t. Closure according to Definition 2. Since the rules in Fig. <ref type="figure">2</ref> are sound, we have N a ⊥ / ∈ Closure for every N a , thus, J is well-defined, and its domain contains a distinguished element x N a ∈ N J a for every individual a. Since Closure is closed under the rules in Fig. <ref type="figure">2</ref> (and thus closed under R - ∃ up to redundancy), by Theorem 1, J |= N(O). Define an interpretation I with I = J , A I = A J for atomic concepts, R I = R J for roles, and a I = x N a for the individuals. Then for every ELO + ⊥ concept D we have: ⊥ is derived for at least one individual a, then O is inconsistent. Otherwise, for every atomic concept A, the derived subsumptions of the form N a A correspond exactly to the entailed instances A(a). As in the case of ontology classification, this procedure can be implemented in polynomial time.</p><formula xml:id="formula_46">Claim (i) if D is safe then D I = N(D) J . Claim (ii) if D is n-safe then D I ⊆ N(D) J .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The proof of Claim</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 3</head><label>3</label><figDesc>w.r.t. O. Consider the ontology O from Example 1. We will use the inference rules from Fig. 2 to derive A ∃S.D. The shortest derivation proceeds as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>up to redundancy. Then O |= C D implies C D ∈ Closure or C ⊥ ∈ Closure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Lemma 1</head><label>1</label><figDesc>For each x C ∈ I and each concept D, C D ∈ Closure implies x C ∈ D I . Proof The proof is by induction over the structure of D. In each case, we assume that x C ∈ I and C D ∈ Closure, and we prove that x C ∈ D I . -Case D = A : x C ∈ A I holds by the definition of A I . -Case D = : We have x C ∈ I since I = I . -Case D = ⊥: Not possible since, by Definition 2, C ⊥ / ∈ Closure for x C ∈ I .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Case D = A: C A ∈ Closure holds by the definition of A I . -Case D = : C ∈ Closure holds due to closure under R . -Case D = ⊥: This case cannot occur since x C ∈ ⊥ I = ∅ is not possible. -Case D = D 1 D 2 : By the semantics of , x C ∈ (D 1 D 2 ) I implies x C ∈ D I i for i = 1, 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3</head><label>3</label><figDesc>Fig. 3 Optimized inference rules for classification of EL +⊥ ontologies</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Theorem 3</head><label>3</label><figDesc>3 w.r.t. O. Now the analogue of Theorem 1 for the rules in Fig. 3 can be formulated as follows: Let O be an EL + ⊥ ontology, and let Closure be a set closed under the rules in Fig. 3 up to redundancy w.r.t. O. Then for every concept C such that init(C) ∈ Closure and every D an atomic concept or ⊥, O |= C D implies C ⊥ ∈ Closure or C D ∈ Closure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>2. Indeed, if an application of R - ∃ to E ∃R.C is redundant w.r.t. Closure and O in the sense of Definition 5, then {C S → D, D C} ⊆ Closure for some D and some S * O R. Hence {E R -→ D, D C} ⊆ Closure , and thus the application of R - ∃ to E ∃R.C is redundant w.r.t. Closure in the sense of Definition 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>: A, ∃R.(C D), ∃S.D, A ∃S.D, C, and B. By applying Theorem 3, we can also conclude that O |= A ⊥ and O |= A D, but we cannot tell, e.g., whether O |= A ∃R.B. Finally, we estimate the worst-case complexity of computing the closure of Input under the inference rules in Fig. 3 w.r.t. O. The key insight is to note that the rules in Fig. 3 can only produce expressions init(C), C D, and C R -→ D such that all C, D, and R occur in Input or in O. Let c and r be respectively the number of such concepts and roles. Thus, the inference rules can derive at most c expressions init(C), at most c 2 expressions C D, and at most c 2 r expressions C R -→ D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>3 are closely related to the completion rules proposed for EL ++ [8]. The differences are mostly presentational. Instead of working with expressions of the form C D and C R -→ D, the completion rules work with collection of sets of the form S(C) and R(R) where C is a concept and R is a role. The set S(C) loosely corresponds to all concepts D such that C D is derived by our procedure and the set R(R) to all pairs C, D for which C R -→ D is derived by our procedure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 4 A</head><label>4</label><figDesc>Fig.4A subset of the EL ++ completion rules<ref type="bibr" target="#b7">[8]</ref> specific to EL + ⊥ ontologies</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>(i) Every expression in Todo and Closure is either from Input or obtained by an inference rule from some expressions in Closure; (ii) Closure does not contain duplicate expressions; (iii) After every iteration of the loop at lines 4-6: (a) Either the size of Closure increases or, otherwise, it remains the same and the size of Todo decreases; (b) Every expression in Input occurs in either Todo or Closure; (c) Every conclusion of an inference from Closure occurs in either Todo or Closure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 6</head><label>6</label><figDesc>Fig. 6 Classes for indexing objects</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>negConjs = { A, ∃S.D, A ∃S.D } negExists = { S, D, ∃S.D } conclncs = { A, ∃R.(C D) , B, A ∃S.D , A ∃S.D, B , ∃S.D, C } roleIncs = { R, S } roleComps = ∅</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>O∃</head><label></label><figDesc>Do not apply rule R - ∃ to a subsumption E ∃S.D that has been derived by rule R + ∃ . If a subsumption E ∃S.D has been derived by rule R + ∃ , then some premises E R -→ C and C E with R O * S of the rule must have been derived earlier, so the application of rule R - ∃ to E ∃S.D is redundant according to Definition 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>with S * O S by rule R • from the same premises. We denote this optimization O • . It is also possible to implement a more aggressive optimization that discards each derived link E S -→ D in case a stronger link E S -→ D with S *</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>t. O if O |= A B and for every atomic concept C such that O |= A C B, either O |= C ≡ A or O |= C ≡ B. The procedure of computing the 'direct part' of a transitive relation is usually called transitive reduction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 9</head><label>9</label><figDesc>Fig. 9 Main software modules of ELK and information flow during classification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Corollary 2 Theorem 4</head><label>24</label><figDesc>Let O be an ELO + ⊥ ontology that does not contain atomic concepts of the form N a . If N(O) |= N a ⊥ for some N a , then O is inconsistent. Proof Take α := {a} ⊥. Clearly, α does not contain any atomic concepts of the form N a . Since N(α) = N a ⊥, we have N(O) |= N(α). Therefore, by Lemma 5, O |= α. Since I |= α for no interpretation I, this is only possible if O is inconsistent. The converses of Corollary 2 and Lemma 5 do not hold in general, but they hold if the occurrence of nominals is restricted in the following way. Definition 6 (Nominal Safety) An ELO + ⊥ concept C is safe if C has only occurrences of nominals in subconcepts of the form ∃R.{a}; C is negatively safe (short n-safe) if C is either safe or a nominal. A concept inclusion C D is safe if C is n-safe and D is safe. An ELO + ⊥ ontology is safe if all its concept inclusions are safe. The restricted use of nominals still allows to express assertion axioms C(a) and R(a,b) since the corresponding concept inclusions {a} C and {a} ∃R.{b} are safe. It also captures another common constructor in OWL EL ontologies ObjectHasValue( R a ), which corresponds to the concept ∃R.{a}. Let O be a safe ELO + ⊥ ontology containing no atomic concepts of the form N a . Assume that N(O) |= N a ⊥ for every N a . Then O is consistent. Furthermore, for every safe concept inclusion α containing no atomic concepts of the form N a , if O |= α, then N(O) |= N(α).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Remark 2 Remark 3</head><label>23</label><figDesc>(i)  is by induction on the structure of D. The only non-trivial case in the induction is for D = ∃R.{a}. To prove that (∃R.{a}) I ⊆ (∃R.N a ) J , consider any x C ∈ (∃R.{a}) I . Since a I = x N a , we have x C , x N a ∈ R I = R J . Since x N a ∈ N J a by Corollary 1, the desired x C ∈ (∃R.N a ) J follows. To prove that (∃R.N a ) J ⊆ (∃R.{a}) I , consider any x C ∈ (∃R.N a ) J . Then there exists x E ∈ J such that x C , x E ∈ R J and x E ∈ N J a . Then by the definition of the canonical model, C R → E ∈ Closure and E N a ∈ Closure. Due to closure under R + ∃ and R - ∃ , C R → N a ∈ Closure, and so x C , x N a ∈ R J as well. Since a I = x N a and R I = R J , the desired x C ∈ (∃R.{a}) I follows. This concludes the proof of (i). Claim (ii) follows immediately from (i) if D is safe. Otherwise, D = {a} is a nominal and N(D) = N a ; in this case we haveD I = {a I } = {x N a } ⊆ N J a = N(D) J ,as required. It is now easy to show that I |= O. Indeed, for every role inclusion or role composition axiom α ∈ O, since J |= N(O), N(α) = α and I interprets roles like J , we have I |= α. It remains to show that I |= α for every concept inclusion α = C D ∈ O. By the assumption of the theorem each such α is safe, i.e., C is n-safe and D is safe. Then by Claim (ii), C I ⊆ N(C) J and by Claim (i), D I = N(D) J . Since J |= N(O) and α ∈ O, we have N(C) J ⊆ N(D) J . Therefore, C I ⊆ N(C) J ⊆ N(D) J = D I , hence I |= C D. This proves that I is a model of O and, in particular, O is consistent. To conclude the proof of the theorem, let α = C D be an arbitrary safe concept inclusion such that O |= α. If N(C) ⊥ ∈ Closure then clearly N(O) |= N(α) because the inference rules in Fig. 2 are sound. Otherwise, x N(C) ∈ J = I . We show that x N(C) ∈ C I . Indeed, if C is safe then x N(C) ∈ N(C) J = C I by Corollary 1 and Claim (i); otherwise, if C = {a}, we have x N(C) = x N a = a I ∈ {a I } = C I . Now, since I |= O |= α, we have x N(C) ∈ C I ⊆ D I = N(D) J . Hence, by Lemma 2, we have N(C) N(D) ∈ Closure, and thus N(O) |= N(C) N(D). Theorem 4 fails if the use of nominals is not safe. Take, for example, the ontology O = {A {a}, B {a}, A ∃R.B}. Clearly, O is consistent. Moreover, O |= A B since for every model I of O we have either A I = ∅ or A I = B I = {a I }, and so, I |= A B. However, for N(O) = {A N a , B N a , A ∃R.B}, we have N(O) |= A B = N(A B). Note that if N a does not occur in N(O), then N(O) |= N a ⊥ iff N(O) |= ⊥. Therefore, in Theorem 4 it is sufficient to test whether N(O) |= N a ⊥ only for the individuals a occurring in O or, if O contains no individuals, whether N(O) = O |= ⊥. By combining Theorems 3 and 4, we can describe a 'one pass' ontology realization procedure for computing all entailed instances of atomic concepts occurring in a safe ELO + ⊥ ontology O. This can be accomplished by computing the closure of Input containing init(N a ) for every individual a occurring in O under the rules in Fig. 3 w.r.t. N(O). If N a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>holds. I is a model of an ontology O (written I |= O) if I satisfies all axioms in O. An ontology is consistent if it has at least one model, otherwise it is inconsistent. We say that an axiom α is a consequence of an ontology O, or also that O entails α (written O |= α), if every model of O satisfies α. Note that an inconsistent ontology entails every axiom</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>Syntax and semantics of EL + ⊥</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>R ∃ we now have two rules R - ∃ and R + ∃ , a combined application of which gives R ∃ . Intuitively, rule R - ∃ eliminates existential restrictions by converting them to links, whereas rule</figDesc><table /><note><p><p><p><p><p>R +</p>∃ produces existential restrictions from links and other concept subsumptions.</p>Note that (so far) the inference rules in Fig.</p>2</p>derive C R -→ D if and only if they derive C ∃R.D. Indeed, C R -→ D can be derived from C ∃R.D by R - ∃ . On the other hand, since D D is derivable by R 0 , we can derive C</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Closure for some concept D. Any other application of rules in Fig.2is non-redundant w.r.t. Closure. If Closure is Basic inference rules with links for reasoning in EL + ⊥ clear from the context, we often say that an inference is redundant or non-redundant without mentioning Closure.</figDesc><table><row><cell>Fig. 2</cell></row></table><note><p><p><p><p>R +</p>∃ or as premises of R H and R • immediately, but, of course, one can first convert such conclusions to links using R - ∃ , after which they can be still used as premises of those rules. To avoid this situation, we are going to 'block' the applications of R - ∃ to conclusions of R + ∃ .</p>Definition 1 (Redundancy of</p>R - ∃ ) Let O be an EL + ⊥ ontology, and Closure a set of subsumptions and existential links. An application of rule R - ∃ that derives E R -→ C from E ∃R.C is redundant w.r.t. Closure if {E R -→ D, D C} ⊆</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>1. If C ⊥ ∈ Closure for every concept C then Theorem 1 trivially holds. So, w.l.o.g., we can assume that C ⊥ / ∈ Closure for at least one concept C. In this case, one can define the canonical model (of O w.r.t. Closure) as follows:</figDesc><table><row><cell>Definition 2 (Canonical Model) The canonical model I is defined by</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>2. Then, by the induction hypothesis, we have x C ∈ D I i , from which x C ∈ (D 1 D 2 ) I follows by the semantics of . -Case D = ∃R.D 2 : Due to closure under R - ∃ up to redundancy, by Remark 1, there exists D 1 such that C R → D 1 , D 1 D 2 ⊆ Closure. Now if D 1 ⊥ ∈ Closure then C ⊥ ∈ Closure due to closure under R ⊥ , which contradicts x C ∈ I . Therefore, D 1 ⊥ / ∈ Closure, and so x D 1 ∈ I . Since D 1 D 2 ∈ Closure, by induction hypothesis applied to x D 1 ∈ I , we get x D 1 ∈ D I 2 . Since C R → D 1 ∈ Closure, we have x C , x D 1 ∈ R I by the definition of R I . Then x C ∈ (∃R.D 2 ) I follows by the semantics of ∃. For each C such that C ⊥ / ∈ Closure we have x C ∈ C I . Proof This is a direct application of Lemma 1 with C = D; the required C C ∈ Closure holds due to closure under R 0 . Note that the proof of Lemma 1 uses only that Closure is closed under R -, R ⊥ , R 0 , and under R - ∃ up to redundancy. The converse of Lemma 1 uses closure under R , R + and For each x C ∈ I and each concept D, x C ∈ D I implies C D ∈ Closure.</figDesc><table><row><cell>Corollary 1 R + ∃ :</cell></row><row><cell>Lemma 2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>Closure follows due to closure under R + . -Case D = ∃R.D 2 : By the semantics of ∃, x C ∈ (∃R.D 2 ) I implies that there exists an element x D 1 ∈ I such that x C , x D 1 ∈ R I and x D 1 ∈ D I 2 . Then C R → D 1 ∈ Closure by the definition of R I and, by applying the induction hypothesis to x D 1 ∈ D I We consider an arbitrary x C ∈ D I . We need to show that x C ∈ E I . Indeed, by Lemma 2, x C ∈ D I implies C D ∈ Closure. Then C E ∈ Closure due to closure under R , from which x C ∈ E I follows by Lemma 1. -Case α = R S: We consider arbitrary x C , x D ∈ R I . We need to show that x C , x D ∈ S I . Indeed, by the definition of R I , we have C R → D ∈ Closure. Then C S → D ∈ Closure due to closure under R H , from which x C , x D ∈ S I follows by the definition of S I . -Case α = R 1 • R 2 S: We consider arbitrary x C , x D ∈ R I 1 and x D , x E ∈ R I 2 . We need to show that x C , x E ∈ S I . Indeed, by the definition of R I 1 and R I 2 , we have C R 1 → D ∈ Closure and D R 2 → E ∈ Closure. Then C S → E ∈ Closure due closure under R • , from which x C , x E ∈ S I follows by the definition of S I .</figDesc><table><row><cell cols="2">It is now easy to conclude the proof of Theorem 1. Let C and D be arbitrary concepts</cell></row><row><cell cols="2">such that O |= C D and C ⊥ / ∈ Closure. Then, the canonical model I of O is well-</cell></row><row><cell cols="2">defined, and by Theorem 2, I |= O. Since C ⊥ / ∈ Closure, x C ∈ I , and by Corollary 1, x C ∈ C I . Since I |= O |= C D, we have x C ∈ D I , hence C D ∈ Closure by</cell></row><row><cell>Lemma 2.</cell><cell></cell></row><row><cell>. Then, by the induction hypothesis, we have C</cell><cell>D i ∈ Clo-</cell></row><row><cell cols="2">sure for i = 1, 2, from which C we obtain D 1 D 2 ∈ Closure. Then C D 1 D 2 ∈ 2 , ∃R.D 2 ∈ Closure follows due to closure under R + ∃ .</cell></row><row><cell>We are now ready to prove that I is indeed a model of O.</cell><cell></cell></row><row><cell>Theorem 2 I |= O.</cell><cell></cell></row><row><cell>Proof We check that I |= α for each axiom α ∈ O:</cell><cell></cell></row></table><note><p>-Case α = D E:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Lemma 4 Let Closure be a set that contains all reachable (from F in Closure) conclusions of non-redundant, goal-directed applications of rules in</head><label></label><figDesc>R H : it is easy to see that all premises of such rules are reachable if α is reachable (since they have the same left-hand side). Since all premises belong to S i and are reachable, by induction hypothesis, they belong to Closure. Since Closure contains all reachable conclusions of non-redundant rule applications, we obtain that α ∈ Closure (note that if an application of R - ∃ is not redundant w.r.t. S i then it is not redundant w.r.t. Closure because Closure ⊆ S i ).-rules R ⊥ , R + ∃ , R • : for these rules, the first premise is reachable if the conclusion is reachable. Hence the first premise belongs to Closure by induction hypothesis. But then, the second premise is also reachable by Definition 3, and likewise belongs to Closure. Since both premises belong to Closure, we obtain similarly that α ∈ Closure.It is possible to restrict the application of inference rules even further. Specifically, the inference rules R , R + , R + ∃ that introduce new concepts on the right-hand side of subsumptions can be restricted to produce only concepts occurring in G or occurring in the left-hand sides of axioms in O. Fig.2.Then O |= F G implies that either F G ∈ Closure or F ⊥ ∈ Closure.Proof Let {S i | i ≥ 0} be a sequence of sets of expressions such that S 0 = Closure, and for every i ≥ 0, S i+1 is the extension of S i with all reachable (from F in Closure) conclusions of not goal-directed applications of rules to S i , i.e., those conclusions C D of R , R + ,</figDesc><table><row><cell>Definition 4 We say that a concept C occurs negatively (respectively positively) in a ontol-</cell></row><row><cell>ogy O, if C is a syntactic subexpression of D (respectively E) for some D E ∈ O. An application of rules R , R + , or R + ∃ is goal-directed (w.r.t. O and F G) if for its conclu-sion C D, either D occurs in G or occurs negatively in O. Applications of rules other than R , R + , and R + ∃ (that do not introduce new concepts) are always goal-directed.</cell></row><row><cell>R + ∃ such that D occurs neither in G, nor negatively in O.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>which is obtained by one of the rules R , R + , or R + ∃ such that D occurs neither in G nor negatively in O. But then α can be obtained from β only using R -, R + , R - ∃ , or R + ∃ (the premises of other rules cannot have such β). Then:-if α is obtained by R -, then β = C D 1 D 2 can only be obtained by R + from S i , and so α ∈ S i ⊆ S i+1 ⊆ S i+2 .</figDesc><table><row><cell cols="2">-if α is obtained by R -∃ , then β = E</cell><cell cols="3">∃R.C can only be obtained by R + ∃ from S i , so</cell></row><row><cell cols="3">this rule application is redundant and cannot take place.</cell><cell></cell></row><row><cell>-if α = C</cell><cell cols="2">D 1 D 2 is obtained by R + , then β = C</cell><cell>D 1 or β = C</cell><cell>D 2 , and</cell></row><row><cell cols="5">so, respectively, either D 1 or D 2 occurs neither in G nor negatively in O. But then the</cell></row><row><cell cols="5">same holds for D 1 D 2 , and so α ∈ S i+2 by the definition of S i+2 . -if α = ∃R.D is obtained by R + D and D occurs neither in F nor ∃ , then β = C negatively in O. But then the same holds for ∃R.D, and so α ∈ S i+2 by the definition</cell></row><row><cell>of S i+2 .</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">Now since each S i+1 contains all reachable conclusions of non-redundant applications</cell></row><row><cell cols="5">of rules to S i , the set S = i≥0 S i is closed under such inferences. Thus, by Lemma 3, if O |= F G then S contains either F G or F ⊥. Since neither F G nor F ⊥</cell></row><row><cell cols="2">can be obtained by inferences producing S</cell><cell></cell><cell></cell></row></table><note><p>i+1 from S i for i ≥ 0 (for F G this is not possible since G occurs in G, and F</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 2</head><label>2</label><figDesc>Representation of EL + ⊥ expressions</figDesc><table><row><cell>Expression</cell><cell>Representation in Todo</cell><cell>Representation in Closure</cell></row><row><cell>init(C)</cell><cell>Init(C)</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 3</head><label>3</label><figDesc>Representation of EL + ⊥ expressions within contexts</figDesc><table><row><cell>Expression</cell><cell>Context c</cell><cell>Representation in c.Todo</cell><cell>Representation in c.Closure</cell></row><row><cell>init(C)</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table 5</head><label>5</label><figDesc>Ontology metrics: number of axioms</figDesc><table><row><cell></cell><cell>C D</cell><cell>C≡ D</cell><cell>Disj(C, D)</cell><cell>R S</cell><cell>R ≡ S</cell><cell>Trans(R)</cell><cell>R 1 • R 2 S</cell></row><row><cell>Complex:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>SNOMED CT</cell><cell>227,961</cell><cell>66,507</cell><cell>-</cell><cell>11</cell><cell>-</cell><cell>-</cell><cell>1</cell></row><row><cell>ANATOMY</cell><cell>17,551</cell><cell>21,831</cell><cell>-</cell><cell>4</cell><cell>-</cell><cell>3</cell><cell>2</cell></row><row><cell>GALEN-OWL</cell><cell>25,563</cell><cell>9,968</cell><cell>-</cell><cell>958</cell><cell>-</cell><cell>58</cell><cell>-</cell></row><row><cell>GALEN7</cell><cell>27,820</cell><cell>15,270</cell><cell>-</cell><cell>972</cell><cell>14</cell><cell>-</cell><cell>385</cell></row><row><cell>GALEN8</cell><cell>53,449</cell><cell>113,622</cell><cell>-</cell><cell>996</cell><cell>14</cell><cell>-</cell><cell>385</cell></row><row><cell>GO2</cell><cell>66,216</cell><cell>7,361</cell><cell>6</cell><cell>2</cell><cell>-</cell><cell>2</cell><cell>3</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head>Table 6</head><label>6</label><figDesc>Ontology metrics: number of concepts, roles, and constructors by occurrence polarities</figDesc><table><row><cell></cell><cell>A</cell><cell>pos.</cell><cell>neg.</cell><cell>pos. ∃</cell><cell>neg. ∃</cell><cell>R</cell></row><row><cell>Complex:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>SNOMED CT</cell><cell>294,469</cell><cell>251,428</cell><cell>140,554</cell><cell>105,373</cell><cell>75,666</cell><cell>62</cell></row><row><cell>ANATOMY</cell><cell>37,757</cell><cell>49,092</cell><cell>4,729</cell><cell>25,880</cell><cell>21,387</cell><cell>10</cell></row><row><cell>GALEN-OWL</cell><cell>23,136</cell><cell>13,006</cell><cell>12,542</cell><cell>14,115</cell><cell>7,549</cell><cell>950</cell></row><row><cell>GALEN7</cell><cell>28,482</cell><cell>13,079</cell><cell>12,982</cell><cell>15,105</cell><cell>7,973</cell><cell>964</cell></row><row><cell>GALEN8</cell><cell>128,483</cell><cell>141,592</cell><cell>140,542</cell><cell>106,065</cell><cell>93,241</cell><cell>988</cell></row><row><cell>GO2</cell><cell>36,215</cell><cell>7,363</cell><cell>7,363</cell><cell>10,157</cell><cell>6,581</cell><cell>7</cell></row><row><cell>Simple:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>GO1</cell><cell>20,465</cell><cell>-</cell><cell>-</cell><cell>1,796</cell><cell>-</cell><cell>1</cell></row><row><cell>ChEBI</cell><cell>31,190</cell><cell>-</cell><cell>-</cell><cell>14,053</cell><cell>-</cell><cell>9</cell></row><row><cell>EMAP</cell><cell>13,731</cell><cell>-</cell><cell>-</cell><cell>4,821</cell><cell>-</cell><cell>1</cell></row><row><cell>FMA</cell><cell>80,469</cell><cell>-</cell><cell>-</cell><cell>13,691</cell><cell>-</cell><cell>15</cell></row><row><cell>Fly Anatomy</cell><cell>7,797</cell><cell>-</cell><cell>-</cell><cell>2,558</cell><cell>-</cell><cell>40</cell></row><row><cell>Molecule Role</cell><cell>9,217</cell><cell>-</cell><cell>-</cell><cell>2,238</cell><cell>-</cell><cell>4</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head>Table 7</head><label>7</label><figDesc>Classification time in seconds, measured using the OWL API</figDesc><table><row><cell></cell><cell>ELK</cell><cell>jcel</cell><cell>REL</cell><cell>Snorocket</cell><cell>FaCT++</cell><cell>HermiT</cell><cell>JFact</cell><cell>Pellet</cell></row><row><cell>SNOMED CT</cell><cell>5.1</cell><cell>651.4</cell><cell>116.2</cell><cell>25.8</cell><cell>425.2</cell><cell>time</cell><cell>time</cell><cell>mem</cell></row><row><cell>ANATOMY</cell><cell>4.0</cell><cell>180.0</cell><cell>stack</cell><cell>27.8</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell>GALEN-OWL</cell><cell>1.2</cell><cell>30.0</cell><cell>27.8</cell><cell>2.9</cell><cell>time</cell><cell>time</cell><cell>time</cell><cell>mem</cell></row><row><cell>GALEN7</cell><cell>1.5</cell><cell>57.9</cell><cell>stack</cell><cell>7.9</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell>GALEN8</cell><cell>5.8</cell><cell>time</cell><cell>stack</cell><cell>mem</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell>GO2</cell><cell>1.1</cell><cell>8.2</cell><cell>11.3</cell><cell>2.5</cell><cell>time</cell><cell>41.2</cell><cell>time</cell><cell>65.7</cell></row><row><cell>GO1</cell><cell>0.5</cell><cell>2.2</cell><cell>0.9</cell><cell>1.1</cell><cell>6.8</cell><cell>2.6</cell><cell>10.0</cell><cell>2.5</cell></row><row><cell>ChEBI</cell><cell>0.7</cell><cell>7.6</cell><cell>3.2</cell><cell>1.9</cell><cell>3.5</cell><cell>12.5</cell><cell>7.7</cell><cell>exc</cell></row><row><cell>EMAP</cell><cell>0.3</cell><cell>0.9</cell><cell>0.5</cell><cell>0.6</cell><cell>20.0</cell><cell>2.0</cell><cell>37.7</cell><cell>0.8</cell></row><row><cell>FMA</cell><cell>1.0</cell><cell>16.4</cell><cell>8.8</cell><cell>7.1</cell><cell>5.6</cell><cell>20.7</cell><cell>13.2</cell><cell>736.4</cell></row><row><cell>Fly Anatomy</cell><cell>0.4</cell><cell>2.2</cell><cell>1.0</cell><cell>0.8</cell><cell>0.7</cell><cell>1.8</cell><cell>2.8</cell><cell>23.1</cell></row><row><cell>Molecule Role</cell><cell>0.3</cell><cell>1.0</cell><cell>0.4</cell><cell>0.6</cell><cell>5.4</cell><cell>1.4</cell><cell>9.4</cell><cell>0.9</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head>Table 8</head><label>8</label><figDesc>Loading + classification time in seconds, measured using the OWL API</figDesc><table><row><cell></cell><cell>ELK</cell><cell>jcel</cell><cell>REL</cell><cell>Snorocket</cell><cell>FaCT++</cell><cell>HermiT</cell><cell>JFact</cell><cell>Pellet</cell></row><row><cell>SNOMED CT</cell><cell>9.3</cell><cell>674.3</cell><cell>126.2</cell><cell>38.2</cell><cell>431.3</cell><cell>time</cell><cell>time</cell><cell>mem</cell></row><row><cell>ANATOMY</cell><cell>5.0</cell><cell>182.3</cell><cell>stack</cell><cell>29.2</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell>GALEN-OWL</cell><cell>2.0</cell><cell>32.3</cell><cell>29.2</cell><cell>4.3</cell><cell>time</cell><cell>time</cell><cell>time</cell><cell>mem</cell></row><row><cell>GALEN7</cell><cell>2.3</cell><cell>60.2</cell><cell>stack</cell><cell>9.2</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell>GALEN8</cell><cell>11.1</cell><cell>time</cell><cell>stack</cell><cell>mem</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell>GO2</cell><cell>2.1</cell><cell>9.9</cell><cell>12.1</cell><cell>3.8</cell><cell>time</cell><cell>44.0</cell><cell>time</cell><cell>67.9</cell></row><row><cell>GO1</cell><cell>1.0</cell><cell>3.0</cell><cell>1.2</cell><cell>1.7</cell><cell>7.3</cell><cell>3.7</cell><cell>10.3</cell><cell>3.6</cell></row><row><cell>ChEBI</cell><cell>1.3</cell><cell>8.8</cell><cell>3.6</cell><cell>2.7</cell><cell>4.2</cell><cell>13.9</cell><cell>8.2</cell><cell>exc</cell></row><row><cell>EMAP</cell><cell>1.0</cell><cell>1.6</cell><cell>0.7</cell><cell>1.0</cell><cell>20.4</cell><cell>3.0</cell><cell>38.0</cell><cell>1.8</cell></row><row><cell>FMA</cell><cell>2.2</cell><cell>18.6</cell><cell>9.3</cell><cell>8.4</cell><cell>7.4</cell><cell>23.1</cell><cell>14.0</cell><cell>741.8</cell></row><row><cell>Fly Anatomy</cell><cell>0.8</cell><cell>2.9</cell><cell>1.3</cell><cell>1.3</cell><cell>1.1</cell><cell>2.8</cell><cell>3.2</cell><cell>24.1</cell></row><row><cell>Molecule Role</cell><cell>0.6</cell><cell>1.6</cell><cell>0.5</cell><cell>1.0</cell><cell>5.7</cell><cell>2.1</cell><cell>9.6</cell><cell>1.5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head>Table 9</head><label>9</label><figDesc>Classification time in seconds, reported by the reasoners not supporting OWL API</figDesc><table><row><cell></cell><cell>CB</cell><cell>ConDOR</cell><cell>CEL</cell><cell>RacerPro</cell></row><row><cell>SNOMED CT</cell><cell>36.5</cell><cell>43.8</cell><cell>772.3</cell><cell>778.5</cell></row><row><cell>ANATOMY</cell><cell>N/A</cell><cell>N/A</cell><cell>144.0</cell><cell>N/A</cell></row><row><cell>GALEN-OWL</cell><cell>3.7</cell><cell>4.4</cell><cell>103.9</cell><cell>time</cell></row><row><cell>GALEN7</cell><cell>N/A</cell><cell>N/A</cell><cell>88.0</cell><cell>N/A</cell></row><row><cell>GALEN8</cell><cell>N/A</cell><cell>N/A</cell><cell>time</cell><cell>N/A</cell></row><row><cell>GO2</cell><cell>N/A</cell><cell>N/A</cell><cell>24.0</cell><cell>mem</cell></row><row><cell>GO1</cell><cell>0.5</cell><cell>0.4</cell><cell>0.6</cell><cell>4.2</cell></row><row><cell>ChEBI</cell><cell>2.1</cell><cell>2.2</cell><cell>81.8</cell><cell>stack</cell></row><row><cell>EMAP</cell><cell>0.2</cell><cell>0.1</cell><cell>0.1</cell><cell>13.3</cell></row><row><cell>FMA</cell><cell>3.1</cell><cell>2.0</cell><cell>216.8</cell><cell>22.7</cell></row><row><cell>Fly Anatomy</cell><cell>0.3</cell><cell>0.2</cell><cell>1.5</cell><cell>mem</cell></row><row><cell>Molecule Role</cell><cell>0.2</cell><cell>0.1</cell><cell>0.1</cell><cell>3.5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head>Table 10</head><label>10</label><figDesc>Classification time in seconds (1 working thread) and number of derived axioms Time Speedup Derived C D unique C D Derived C remaining three numbers in Table10on all the test ontologies apart from GO2, with a speedup of 1.33 on SNOMED CT, 1.75 on ANATOMY, 1.25 on GALEN-OWL, 1.46 on GALEN7, and as much as 2.00 on GALEN8.</figDesc><table><row><cell>R -→D Unique C</cell><cell>R -→D</cell></row></table><note><p>the</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_19"><head>Table 11</head><label>11</label><figDesc>Classification time in seconds and relative speedup for increasing number of concurrent workers</figDesc><table><row><cell></cell><cell></cell><cell>workers</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell>7</cell><cell>8</cell></row><row><cell>SNOMED CT</cell><cell>time</cell><cell>18.62</cell><cell>10.07</cell><cell>7.37</cell><cell>6.35</cell><cell>5.76</cell><cell>5.49</cell><cell>5.09</cell><cell>4.85</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.85</cell><cell>2.53</cell><cell>2.93</cell><cell>3.23</cell><cell>3.39</cell><cell>3.66</cell><cell>3.84</cell></row><row><cell>ANATOMY</cell><cell>time</cell><cell>11.58</cell><cell>7.27</cell><cell>5.51</cell><cell>4.63</cell><cell>4.34</cell><cell>4.03</cell><cell>3.80</cell><cell>3.64</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.59</cell><cell>2.10</cell><cell>2.50</cell><cell>2.67</cell><cell>2.88</cell><cell>3.04</cell><cell>3.18</cell></row><row><cell>GALEN-OWL</cell><cell>time</cell><cell>2.49</cell><cell>1.64</cell><cell>1.32</cell><cell>1.27</cell><cell>1.27</cell><cell>1.28</cell><cell>1.25</cell><cell>1.23</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.51</cell><cell>1.88</cell><cell>1.95</cell><cell>1.96</cell><cell>1.94</cell><cell>1.98</cell><cell>2.02</cell></row><row><cell>GALEN7</cell><cell>time</cell><cell>4.12</cell><cell>2.57</cell><cell>2.05</cell><cell>1.85</cell><cell>1.74</cell><cell>1.68</cell><cell>1.60</cell><cell>1.67</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.60</cell><cell>2.01</cell><cell>2.23</cell><cell>2.36</cell><cell>2.45</cell><cell>2.58</cell><cell>2.46</cell></row><row><cell>GALEN8</cell><cell>time</cell><cell>20.56</cell><cell>12.73</cell><cell>9.21</cell><cell>7.67</cell><cell>7.13</cell><cell>6.71</cell><cell>6.32</cell><cell>6.06</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.62</cell><cell>2.23</cell><cell>2.68</cell><cell>2.88</cell><cell>3.07</cell><cell>3.26</cell><cell>3.40</cell></row><row><cell>GO2</cell><cell>time</cell><cell>1.97</cell><cell>1.21</cell><cell>1.05</cell><cell>1.13</cell><cell>1.14</cell><cell>1.11</cell><cell>1.16</cell><cell>1.14</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.63</cell><cell>1.88</cell><cell>1.74</cell><cell>1.73</cell><cell>1.76</cell><cell>1.70</cell><cell>1.72</cell></row><row><cell>GO1</cell><cell>time</cell><cell>0.78</cell><cell>0.53</cell><cell>0.52</cell><cell>0.54</cell><cell>0.54</cell><cell>0.54</cell><cell>0.52</cell><cell>0.56</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.47</cell><cell>1.48</cell><cell>1.44</cell><cell>1.44</cell><cell>1.43</cell><cell>1.50</cell><cell>1.38</cell></row><row><cell>ChEBI</cell><cell>time</cell><cell>1.50</cell><cell>0.96</cell><cell>0.78</cell><cell>0.79</cell><cell>0.78</cell><cell>0.78</cell><cell>0.80</cell><cell>0.80</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.56</cell><cell>1.92</cell><cell>1.91</cell><cell>1.93</cell><cell>1.92</cell><cell>1.88</cell><cell>1.88</cell></row><row><cell>EMAP</cell><cell>time</cell><cell>0.68</cell><cell>0.48</cell><cell>0.44</cell><cell>0.45</cell><cell>0.45</cell><cell>0.41</cell><cell>0.42</cell><cell>0.44</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.42</cell><cell>1.57</cell><cell>1.52</cell><cell>1.51</cell><cell>1.67</cell><cell>1.61</cell><cell>1.57</cell></row><row><cell>FMA</cell><cell>time</cell><cell>1.72</cell><cell>1.09</cell><cell>0.95</cell><cell>0.89</cell><cell>0.93</cell><cell>0.90</cell><cell>0.94</cell><cell>0.85</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.58</cell><cell>1.81</cell><cell>1.94</cell><cell>1.85</cell><cell>1.91</cell><cell>1.84</cell><cell>2.02</cell></row><row><cell>Fly Anatomy</cell><cell>time</cell><cell>0.71</cell><cell>0.52</cell><cell>0.47</cell><cell>0.47</cell><cell>0.50</cell><cell>0.48</cell><cell>0.47</cell><cell>0.49</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.36</cell><cell>1.52</cell><cell>1.49</cell><cell>1.41</cell><cell>1.48</cell><cell>1.49</cell><cell>1.45</cell></row><row><cell>Molecule Role</cell><cell>time</cell><cell>0.62</cell><cell>0.46</cell><cell>0.39</cell><cell>0.41</cell><cell>0.38</cell><cell>0.34</cell><cell>0.37</cell><cell>0.36</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.37</cell><cell>1.59</cell><cell>1.52</cell><cell>1.63</cell><cell>1.81</cell><cell>1.70</cell><cell>1.72</cell></row><row><cell>UNION</cell><cell>times</cell><cell>2.88</cell><cell>1.69</cell><cell>1.41</cell><cell>1.28</cell><cell>1.24</cell><cell>1.21</cell><cell>1.18</cell><cell>1.17</cell></row><row><cell></cell><cell>speedup</cell><cell>1.00</cell><cell>1.71</cell><cell>2.04</cell><cell>2.25</cell><cell>2.32</cell><cell>2.38</cell><cell>2.45</cell><cell>2.45</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20"><head>Table 12</head><label>12</label><figDesc>Running time in seconds and the number of passes through the inner loop of the two transitive reduction algorithms from Section 5.4</figDesc><table><row><cell></cell><cell cols="2">Naive algorithm</cell><cell cols="2">Optimized algorithm</cell><cell></cell></row><row><cell></cell><cell>Time</cell><cell>Passes</cell><cell>Time</cell><cell>Passes</cell><cell>Speedup</cell></row><row><cell>SNOMED CT</cell><cell>4.11</cell><cell>35,745,244</cell><cell>1.61</cell><cell>6,723,839</cell><cell>2.55</cell></row><row><cell>ANATOMY</cell><cell>1.37</cell><cell>14,674,573</cell><cell>0.43</cell><cell>2,244,702</cell><cell>3.19</cell></row><row><cell>GALEN-OWL</cell><cell>0.42</cell><cell>3,012,583</cell><cell>0.26</cell><cell>614,103</cell><cell>1.62</cell></row><row><cell>GALEN7</cell><cell>0.84</cell><cell>89,951,79</cell><cell>0.31</cell><cell>1,535,003</cell><cell>2.71</cell></row><row><cell>GALEN8</cell><cell>2.92</cell><cell>27,208,529</cell><cell>1.24</cell><cell>4,789,837</cell><cell>2.35</cell></row><row><cell>GO2</cell><cell>0.28</cell><cell>2,172,161</cell><cell>0.20</cell><cell>474,042</cell><cell>1.40</cell></row><row><cell>GO1</cell><cell>0.24</cell><cell>782,504</cell><cell>0.23</cell><cell>177,966</cell><cell>1.04</cell></row><row><cell>ChEBI</cell><cell>0.45</cell><cell>4,322,716</cell><cell>0.22</cell><cell>843,412</cell><cell>2.05</cell></row><row><cell>EMAP</cell><cell>0.11</cell><cell>0</cell><cell>0.11</cell><cell>0</cell><cell>1.00</cell></row><row><cell>FMA</cell><cell>0.42</cell><cell>3,754,823</cell><cell>0.26</cell><cell>954,998</cell><cell>1.62</cell></row><row><cell>Fly Anatomy</cell><cell>0.22</cell><cell>335,522</cell><cell>0.21</cell><cell>78,209</cell><cell>1.05</cell></row><row><cell>Molecule Role</cell><cell>0.17</cell><cell>63,083</cell><cell>0.11</cell><cell>13,974</cell><cell>1.55</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>See the Description Logic Complexity Navigator for a comprehensive overview of decidability and complexity results in DLs: http://www.cs.man.ac.uk/~ezolin/dl/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The ontology and concept consistency problems are, in fact, trivial in EL since this language is too weak to express inconsistencies.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://elk.semanticweb.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>In the earlier EL papers<ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9]</ref>, canonical models were called completion graphs.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>In other formulations<ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15]</ref>, CR1 and CR2 are generalized to a rule for n-ary conjunctions on the left.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Note that the given expression will already be present in Closure at this point.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>Recall that we treat the equivalence axiom (ax2) as two individual concept inclusion axioms, so, e.g., the occurrence count of S is 4, not 3.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>Download at http://code.google.com/p/elk-reasoner/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>http://maven.apache.org</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>http://www.b2international.com/portal/snow-owl</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>http://www.ihtsdo.org/licensing/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_11"><p>http://www.opengalen.org/sources/sources.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_12"><p>http://www.co-ode.org/galen/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_13"><p>http://www.geneontology.org</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_14"><p>http://code.google.com/p/elk-reasoner/wiki/TestOntologies</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_15"><p>http://jfact.sourceforge.net/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_16"><p>For a fair comparison with other reasoners, we ran ELK in the experiments in Section 8.1 through OWL API. In the remaining experiments, however, we accessed it directly using its own interfaces. This explains the slight difference between the running times in the last column of Table11and those in Table7.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="20" xml:id="foot_17"><p>http://protegewiki.stanford.edu/wiki/Snorocket_2.0.0</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments This work was supported by the Royal Society, the Seventh Framework Program of the European Commission under Grant Agreement 318338, 'Optique', and the EPSRC projects ConDOR, ExODA, Score!, and MaSI 3 . The first author is supported by the German Research Council (DFG).</p><p>We also thank the International Health Terminology Standards Development Organisation (IHTSDO), and in particular Kent Spackman, for providing us with the experimental version of the ANATOMY ontology.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Experimental Evaluation</head><p>In this section, we evaluate the classification algorithm and the optimizations presented in this paper on existing ontologies. In Section 8.1, we compare the performance of ELK in its default settings (all optimizations turned on) with other commonly used OWL and OWL EL reasoners. To evaluate the effect of individual optimizations, in Section 8.2 we repeat the experiments with certain optimizations turned off. In Section 8.3 we evaluate the effect of varying the number of concurrent workers. Finally, in Section 8.4 we compare the two transitive reduction algorithms from Section 5.4. The experiments were executed on a laptop with Intel Core i7-2630QM 2GHz quadcore CPU and 6GB RAM running Microsoft Windows 7. On this architecture, ELK defaults to using 8 concurrent workers in the saturation phase. We ran Java 1.6 with the -XX:+AggressiveHeap flag and 4GB of heap space. All figures reported in this paper were obtained as the average over 5 runs of the experiment.</p><p>Our test ontology suite contains SNOMED CT obtained from the official January 2012 international release by converting from the native syntax (RF2) to FSS using the supplied converter. Additionally, we used a new experimental version ANATOMY, which remodels the 'body structure' hierarchy of SNOMED CT using role composition axioms. Both of these ontologies are freely available for research and evaluation. 11 We included several versions of OpenGALEN. 12 GALEN7 and GALEN8 were obtained from versions 7 and 8 respectively by removing all inverse role and functional role axioms, and replacing all data property restrictions with new atomic concepts. The role composition axioms of GALEN7 and GALEN8 do not satisfy the regularity condition imposed by OWL2 and therefore are not proper OWL EL ontologies. Although this is not problematic for ELK, these ontologies are rejected by most OWL reasoners. We have additionally included GALEN-OWL,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A: ABoxes and Safe Nominals</head><p>In the main parts of this paper, we have only considered terminological reasoning in EL + ⊥ . Like other completion-based systems <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b98">99]</ref>, our systems in Figs. 1, 2 and 3 can also be extended with rules for dealing with concept and role assertions. To avoid repeating proofs, optimizations and algorithmic details for reasoning with assertions, however, we do not present the additional rules separately. Instead, we demonstrate how ABoxes reasoning can be reduced to terminological reasoning. We also demonstrate that our reduction works for a restricted but quite commonly used pattern of nominals in OWL EL ontologies.</p><p>To this end, within this section we consider ontologies with nominals. A nominal is a concept of the form C = {a} where a is an individual, which is interpreted by the singleton set C I = {a I }. We denote by ELO + ⊥ the extension of EL + ⊥ in which concepts can be constructed using nominals. Note that the assertions C(a) and R(a,b) are semantically equivalent to concept inclusions with nominals {a} C and {a} ∃R.{b}, respectively. Within this section we also assume that the set of atomic concepts contains a distinguished atomic concept N a for every individual a in our vocabulary. For x an ELO + ⊥ concept, axiom, or an ontology, we define N(x) to be the result of replacing each occurrence of each nominal {a} in x by N a . The next lemma shows that this reduction provides us with a sufficient condition for checking entailment in O. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Partition-based logical reasoning for first-order and propositional theories</title>
		<author>
			<persName><forename type="first">E</forename><surname>Amir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mcilraith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">162</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="49" to="88" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">MORe: Modular combination of OWL reasoners for ontology classification</title>
		<author>
			<persName><forename type="first">Armas</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cuenca Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Cudré-Mauroux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heflin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tudorache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hauswirth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Parreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schreiber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Semantic Web Conference (ISWCŠ12)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Blomqvist</surname></persName>
		</editor>
		<meeting>the 11th International Semantic Web Conference (ISWCŠ12)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7649</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Parallel TBox classification in description logics -first experimental results</title>
		<author>
			<persName><forename type="first">M</forename><surname>Aslani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th European Conference on Artificial Intelligence (ECAI&apos;10)</title>
		<title level="s">Frontiers in Artificial Intelligence and Applications</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Coelho</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Studer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Wooldridge</surname></persName>
		</editor>
		<meeting>the 19th European Conference on Artificial Intelligence (ECAI&apos;10)</meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="485" to="490" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Concurrent classification of OWL ontologies -an empirical evaluation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Aslani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Workshop on Description Logics (DL&apos;12)</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</editor>
		<meeting>the 25th International Workshop on Description Logics (DL&apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">846</biblScope>
			<biblScope unit="page" from="400" to="410" />
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Terminological cycles in a description logic with existential restrictions</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI&apos;03)</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 18th International Joint Conference on Artificial Intelligence (IJCAI&apos;03)</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="325" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Extending unification in EL towards general TBoxes</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Borgwardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Morawska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;12)</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Brewka</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mcilraith</surname></persName>
		</editor>
		<meeting>the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;12)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="568" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Pushing the EL envelope</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI&apos;05)</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Kaelbling</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Saffiotti</surname></persName>
		</editor>
		<meeting>the 19th International Joint Conference on Artificial Intelligence (IJCAI&apos;05)</meeting>
		<imprint>
			<publisher>Professional Book Center</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="364" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Pushing the EL envelope further</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings in OWLED 2008 DC Workshop on OWL: Experiences and Directions</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Clark</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<meeting>in OWLED 2008 DC Workshop on OWL: Experiences and Directions</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">496</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<title level="m">The Description Logic Handbook, Theory, Implementation, and Applications, 2nd edn</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An empirical analysis of optimization techniques for terminological representation systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Franconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hollunder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nebel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Profitlich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Appl. Intell</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="109" to="132" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Computing least common subsumers in description logics with existential restrictions</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Küsters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Molitor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Joint Conference on Artificial Intelligence (IJCAI&apos;99)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Dean</surname></persName>
		</editor>
		<meeting>the 16th International Joint Conference on Artificial Intelligence (IJCAI&apos;99)</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="96" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Is tractable reasoning in extensions of the description logic EL useful in practice?</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Suntisrivaraporn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 international workshop on methods for modalities (M4M&apos;05</title>
		<meeting>the 2005 international workshop on methods for modalities (M4M&apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">CEL-a polynomial-time reasoner for life science ontologies</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Suntisrivaraporn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Joint Conference on Automated Reasoning (IJCAR&apos;06)</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Furbach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</editor>
		<meeting>the 3rd International Joint Conference on Automated Reasoning (IJCAR&apos;06)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4130</biblScope>
			<biblScope unit="page" from="287" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient reasoning in EL +</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Suntisrivaraporn</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 International Workshop on Description Logics (DL&apos;06)</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Toman</surname></persName>
		</editor>
		<meeting>the 2006 International Workshop on Description Logics (DL&apos;06)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">189</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Automata-based axiom pinpointing</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Peñaloza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="91" to="129" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Computing the least common subsumer w.r.t. a background terminology</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sertkaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Turhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Appl. Logics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="392" to="420" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Resolution theorem proving</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bachmair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ganzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Automated Reasoning</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Robinson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier and MIT Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="19" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Parallelizing description logics</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Bergmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Quantz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th Annual German Conference on Artificial Intelligence (KI&apos;95)</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Wachsmuth</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Rollinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Brauer</surname></persName>
		</editor>
		<meeting>the 19th Annual German Conference on Artificial Intelligence (KI&apos;95)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">981</biblScope>
			<biblScope unit="page" from="137" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Towards more effective tableaux reasoning for CKR</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bozzato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Homola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Serafini</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Workshop on Description Logics (DL&apos;12)</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</editor>
		<meeting>the 25th International Workshop on Description Logics (DL&apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">846</biblScope>
			<biblScope unit="page" from="114" to="124" />
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On subsumption and instance problem in ELH w.r.t. general TBoxes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Brandt</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 International Workshop on Description Logics (DL&apos;04)</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Möller</surname></persName>
		</editor>
		<meeting>the 2004 International Workshop on Description Logics (DL&apos;04)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">104</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Polynomial time reasoning in a description logic with existential restrictions, GCI axioms, and -What else?</title>
		<author>
			<persName><forename type="first">S</forename><surname>Brandt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th European Conference on Artificial Intelligence (ECAI&apos;04)</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>De Mántaras</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Saitta</surname></persName>
		</editor>
		<meeting>the 16th European Conference on Artificial Intelligence (ECAI&apos;04)</meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="298" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Standard and Non-standard Reasoning in Description Logics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Brandt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<pubPlace>Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Dresden</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<ptr target="http://www.w3.org/TR/rdf-schema/" />
		<title level="m">RDF Vocabulary Description Language 1.0: RDF Schema. W3C Recommendation</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Brickley</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Guha</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2004-02-10">10 February 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Tractable reasoning and efficient query answering in description logics: The DL-Lite family</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Incremental classification of description logics ontologies</title>
		<author>
			<persName><forename type="first">Cuenca</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Halaschek-Wiener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kazakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Suntisrivaraporn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="337" to="369" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Modular reuse of ontologies: Theory and practice</title>
		<author>
			<persName><forename type="first">Cuenca</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kazakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="273" to="318" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">The OBO Flat File Format Specification, version 1.2. The Gene Ontology Consortium</title>
		<author>
			<persName><forename type="first">J</forename><surname>Day-Richter</surname></persName>
		</author>
		<ptr target="http://www.geneontology.org/GO.format.obo-1_2.shtml" />
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Classifying ELH ontologies in SQL databases</title>
		<author>
			<persName><forename type="first">V</forename><surname>Delaitre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings in OWLED 2009 Workshop on OWL: Experiences and Directions</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Hoekstra</surname></persName>
		</editor>
		<meeting>in OWLED 2009 Workshop on OWL: Experiences and Directions</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">529</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Linear-time algorithms for testing the satisfiability of propositional Horn formulae</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">F</forename><surname>Dowling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Gallier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="267" to="284" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Uniform evaluation of nonmonotonic DLprograms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krennwallner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Symposium on Foundations of Information and Knowledge Systems (FoIKS&apos;12)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sali</surname></persName>
		</editor>
		<meeting>the 7th International Symposium on Foundations of Information and Knowledge Systems (FoIKS&apos;12)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7153</biblScope>
			<biblScope unit="page" from="1" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Rete: A fast algorithm for the many pattern/many object pattern match problem</title>
		<author>
			<persName><forename type="first">C</forename><surname>Forgy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="17" to="37" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Computational tools for comparative phenomics: The role and promise of ontologies</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">V</forename><surname>Gkoutos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Schofield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hoehndorf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mamm. Genome</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="669" to="679" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A novel approach to ontology classification</title>
		<author>
			<persName><forename type="first">B</forename><surname>Glimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shearer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Stoilos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Sem</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="84" to="101" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Embedded EL + reasoning on programmable logic controllers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Grimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Watzke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hubauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cescolini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cudré-Mauroux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heflin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tudorache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hauswirth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Parreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Schreiber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Semantic Web Conference (ISWC&apos;12)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Blomqvist</surname></persName>
		</editor>
		<meeting>the 11th International Semantic Web Conference (ISWC&apos;12)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7649</biblScope>
			<biblScope unit="page" from="66" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Racer system description</title>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Möller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Joint Conference on Automated Reasoning (IJCAR&apos;01)</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Goré</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Leitsch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</editor>
		<meeting>the 1st International Joint Conference on Automated Reasoning (IJCAR&apos;01)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2083</biblScope>
			<biblScope unit="page" from="701" to="705" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">FYPO: The fission yeast phenotype ontology</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bühler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Oliver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinforma</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="1671" to="1678" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">RDFS reasoning on massively parallel hardware</title>
		<author>
			<persName><forename type="first">N</forename><surname>Heino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Z</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cudré-Mauroux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heflin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tudorache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hauswirth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Parreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Schreiber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Semantic Web Conference (ISWC&apos;12)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Blomqvist</surname></persName>
		</editor>
		<meeting>the 11th International Semantic Web Conference (ISWC&apos;12)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7649</biblScope>
			<biblScope unit="page" from="133" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Identifying aberrant pathways through integrated analysis of knowledge in pharmacogenomics</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hoehndorf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dumontier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">V</forename><surname>Gkoutos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinforma</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">16</biblScope>
			<biblScope unit="page" from="2169" to="2175" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Semantic integration of physiology phenotypes with an application to the cellular phenotype ontology</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hoehndorf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Herre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rustici</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">V</forename><surname>Gkoutos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinforma</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="1783" to="1789" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Proof-theoretic approach to description-logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hofmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Annual IEEE Symposium on Logic in Computer Science (LICS&apos;05)</title>
		<meeting>the 20th Annual IEEE Symposium on Logic in Computer Science (LICS&apos;05)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="229" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Scalable authoritative OWL reasoning for the Web</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Harth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Semant. Web Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="49" to="90" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">SAOR: template rule optimisations for distributed reasoning over 1 billion linked data triples</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Z</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Decker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Glimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mika</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Semantic Web Conference (ISWC&apos;10)</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</editor>
		<meeting>the 9th International Semantic Web Conference (ISWC&apos;10)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6496</biblScope>
			<biblScope unit="page" from="337" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">The OWL API: A Java API for working with OWL 2 ontologies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Horridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bechhofer</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings in OWLED 2009 Workshop on OWL: Experiences and Directions</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Hoekstra</surname></persName>
		</editor>
		<meeting>in OWLED 2009 Workshop on OWL: Experiences and Directions</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">529</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The even more irresistible SROIQ</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;06)</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Doherty</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Welty</surname></persName>
		</editor>
		<meeting>the 10th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;06)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="57" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Practical reasoning for expressive description logics</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tobies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Logic Programming and Automated Reasoning (LPAR&apos;99)</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Ganzinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Mcallester</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting>the 6th International Conference on Logic Programming and Automated Reasoning (LPAR&apos;99)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1705</biblScope>
			<biblScope unit="page" from="161" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Completeness, decidability and complexity of entailment for RDF Schema and a semantic extension involving the OWL vocabulary</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Ter Horst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="79" to="115" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Logical gene ontology annotations (GOAL): exploring gene ontology annotations with OWL</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jupp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hoehndorf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Biomed. Semant</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">Suppl 1</biblScope>
			<biblScope unit="page" from="1" to="16" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Finding all justifications of OWL DL entailments</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kalyanpur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Aberer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Noy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Allemang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Nixon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Golbeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mika</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maynard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mizoguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Schreiber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Semantic Web Conference (ISWC&apos;07)</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Cudré-Mauroux</surname></persName>
		</editor>
		<meeting>the 6th International Semantic Web Conference (ISWC&apos;07)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4825</biblScope>
			<biblScope unit="page" from="267" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">RIQ and SROIQ are harder than SHOIQ</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;08)</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Brewka</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Lang</surname></persName>
		</editor>
		<meeting>the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;08)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="274" to="284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Consequence-driven reasoning for Horn SHIQ ontologies</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI&apos;09)</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Boutilier</surname></persName>
		</editor>
		<meeting>the 21st International Joint Conference on Artificial Intelligence (IJCAI&apos;09)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="2040" to="2045" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Incremental reasoning in OWL EL without bookkeeping</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Klinov</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-41335-3_15</idno>
	</analytic>
	<monogr>
		<title level="j">Int. Semant. Web Conf</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="232" to="247" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Concurrent classification of EL ontologies</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Simančík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Aroyo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Welty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Alani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kagal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Noy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Semantic Web Conference (ISWC&apos;11)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Blomqvist</surname></persName>
		</editor>
		<meeting>the 10th International Semantic Web Conference (ISWC&apos;11)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">7032</biblScope>
			<biblScope unit="page" from="305" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Unchain my EL reasoner</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Simančík</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Workshop on Description Logics (DL&apos;11)</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</editor>
		<meeting>the 24th International Workshop on Description Logics (DL&apos;11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">745</biblScope>
			<biblScope unit="page" from="202" to="212" />
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">ELK reasoner: architecture and evaluation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Simančík</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the OWL Reasoner Evaluation Workshop 2012 (ORE&apos;12)</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yatskevich</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Jimenez-Ruiz</surname></persName>
		</editor>
		<meeting>the OWL Reasoner Evaluation Workshop 2012 (ORE&apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">858</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Practical reasoning with nominals in the EL family of description logics</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Simančík</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;12)</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Brewka</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mcilraith</surname></persName>
		</editor>
		<meeting>the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;12)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="264" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">The Protégé OWL Plugin: an open development environment for Semantic Web applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Knublauch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Fergerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">F</forename><surname>Noy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Musen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Semantic Web Conference (ISWC&apos;04)</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mcilraith</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Plexousakis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</editor>
		<meeting>the 3rd International Semantic Web Conference (ISWC&apos;04)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3298</biblScope>
			<biblScope unit="page" from="229" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">The combined approach to ontology-based data access</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</meeting>
		<imprint>
			<publisher>AAAI Press/IJCAI</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="2656" to="2661" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Mind the data skew: distributed inferencing by speeddating in elastic regions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kotoulas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Oren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings in 19th international conference on world wide web (WWW&apos;10)</title>
		<meeting>in 19th international conference on world wide web (WWW&apos;10)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="531" to="540" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Efficient rule-based inferencing for OWL EL</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</meeting>
		<imprint>
			<publisher>AAAI Press/IJCAI</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="2668" to="2673" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">The not-so-easy task of computing class subsumptions in OWL RL</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cudré-Mauroux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heflin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tudorache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hauswirth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Parreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Schreiber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Semantic Web Conference (ISWC&apos;12)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Blomqvist</surname></persName>
		</editor>
		<meeting>the 11th International Semantic Web Conference (ISWC&apos;12)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7649</biblScope>
			<biblScope unit="page" from="279" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">OWL 2 Profiles: an introduction to lightweight ontology languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Reasoning Web Summer School</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Krennwallner</surname></persName>
		</editor>
		<meeting>the 8th Reasoning Web Summer School<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012-08">September 3-8 2012. 2012</date>
			<biblScope unit="volume">7487</biblScope>
			<biblScope unit="page" from="112" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Orel: Database-driven reasoning for OWL 2 profiles</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mehdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Workshop on Description Logics (DL&apos;10)</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Toman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Weddell</surname></persName>
		</editor>
		<meeting>the 23rd International Workshop on Description Logics (DL&apos;10)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">573</biblScope>
			<biblScope unit="page" from="114" to="124" />
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Conjunctive queries for a tractable fragment of OWL 1.1</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Aberer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Noy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Allemang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Nixon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Golbeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mika</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maynard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mizoguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Schreiber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Semantic Web Conference (ISWC&apos;07)</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Cudré-Mauroux</surname></persName>
		</editor>
		<meeting>the 6th International Semantic Web Conference (ISWC&apos;07)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4825</biblScope>
			<biblScope unit="page" from="310" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">A description logic primer</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Simančík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<idno>CoRR abs/1201.4089</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Fast classification in Protégé: Snorocket as an OWL 2 EL reasoner</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Lawley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bousquet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Australasian Ontology Workshop (IAOA&apos;10)</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Taylor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Meyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Orgun</surname></persName>
		</editor>
		<meeting>the 6th Australasian Ontology Workshop (IAOA&apos;10)</meeting>
		<imprint>
			<publisher>Australian Computer Society Inc</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">122</biblScope>
			<biblScope unit="page" from="45" to="49" />
		</imprint>
		<respStmt>
			<orgName>Conferences in Research and Practice in Information Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Parallelizing tableaux-based description logic reasoning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Liebig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of OTM workshops 2007, Part II</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Meersman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Z</forename><surname>Tari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Herrero</surname></persName>
		</editor>
		<meeting>OTM workshops 2007, Part II</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4806</biblScope>
			<biblScope unit="page" from="1135" to="1144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Roo: a parallel theorem prover</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Lusk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Mccune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Slaney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Conference on Automated Deduction (CADE&apos;92)</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Kapur</surname></persName>
		</editor>
		<meeting>the 11th Conference on Automated Deduction (CADE&apos;92)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">607</biblScope>
			<biblScope unit="page" from="731" to="734" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Tractable extensions of the description logic EL with numerical datatypes</title>
		<author>
			<persName><forename type="first">D</forename><surname>Magka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="427" to="450" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Experimental analysis of some computation rules in a simple parallel reasoning system for the ALC description logic</title>
		<author>
			<persName><forename type="first">A</forename><surname>Meissner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Appl. Math. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="83" to="95" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">jcel: a modular rule-based reasoner</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mendez</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the OWL Reasoner Evaluation Workshop 2012 (ORE&apos;12)</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yatskevich</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Jimenez-Ruiz</surname></persName>
		</editor>
		<meeting>the OWL Reasoner Evaluation Workshop 2012 (ORE&apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">858</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Implementing completion-based inferences for the EL-family</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mendez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ecke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Turhan</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Workshop on Description Logics (DL&apos;11)</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</editor>
		<meeting>the 24th International Workshop on Description Logics (DL&apos;11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">745</biblScope>
			<biblScope unit="page" from="34" to="344" />
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Reintroducing CEL as an OWL 2 EL reasoner</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mendez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Suntisrivaraporn</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Workshop on Description Logics (DL&apos;09)</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</editor>
		<meeting>the 22nd International Workshop on Description Logics (DL&apos;09)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">477</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">The revival of structural subsumption in tableau-based reasoners</title>
		<author>
			<persName><forename type="first">R</forename><surname>Möller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wandelt</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Workshop on Description logics (DL&apos;08)</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</editor>
		<meeting>the 21st International Workshop on Description logics (DL&apos;08)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">353</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cuenca Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fokoue</surname></persName>
		</author>
		<author>
			<persName><surname>Lutz</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/owl2-profiles/" />
		<title level="m">OWL 2 Web Ontology Language: Profiles. W3C Recommendation</title>
		<editor>
			<persName><forename type="first">C</forename></persName>
		</editor>
		<imprint>
			<date type="published" when="2009-10-27">27 October 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Hypertableau reasoning for description logics</title>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shearer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="165" to="228" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">A MapReduce algorithm for EL +</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mutharaju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Workshop on Description Logics (DL&apos;10)</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Toman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Weddell</surname></persName>
		</editor>
		<meeting>the 23rd International Workshop on Description Logics (DL&apos;10)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">573</biblScope>
			<biblScope unit="page" from="464" to="474" />
		</imprint>
	</monogr>
	<note>CEUR Workshop proceedings</note>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Parallel materialization of large ABoxes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ü</forename><forename type="middle">V</forename><surname>Çatalyürek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Kurç</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Saltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Applied Computing (SAC&apos;09)</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">Y</forename><surname>Shin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Ossowski</surname></persName>
		</editor>
		<meeting>the ACM Symposium on Applied Computing (SAC&apos;09)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1257" to="1261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">ExpExpExplosion: uniform interpolation in general EL terminologies</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nikitina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Raedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bessière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Doherty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Frasconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Heintz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th European Conference on Artificial Intelligence (ECAI&apos;12)</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">F</forename></persName>
		</editor>
		<meeting>the 20th European Conference on Artificial Intelligence (ECAI&apos;12)</meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">242</biblScope>
			<biblScope unit="page" from="618" to="623" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Worst-case optimal reasoning for the Horn-DL fragments of OWL 1 and 2</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Simkus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;10)</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Lin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Truszczynski</surname></persName>
		</editor>
		<meeting>the 12th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;10)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="269" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">A strategy for building neuroanatomy ontologies</title>
		<author>
			<persName><forename type="first">D</forename><surname>Osumi-Sutherland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reeve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Mungall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Neuhaus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ruttenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S X E</forename><surname>Jefferis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Armstrong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinforma</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1262" to="1269" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<title level="m" type="main">OWL 2 web ontology language: document overview. W3C Recommendation</title>
		<author>
			<persName><forename type="first">W</forename><surname>Owl Working Group</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/owl2-overview/" />
		<imprint>
			<date type="published" when="2009-10-27">27 October 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">On the complexity of axiom pinpointing in the EL family of description logics</title>
		<author>
			<persName><forename type="first">R</forename><surname>Peñaloza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sertkaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;10)</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Lin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Truszczynski</surname></persName>
		</editor>
		<meeting>the 12th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;10)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="280" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">The GALEN CORE model schemata for anatomy: towards a re-usable application-independent model of medical concepts</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rector</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gangemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Galeazzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Glowinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rossi-Mori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Congress of the European Federation for Medical Informatics (MIE&apos;94)</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Barahona</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Veloso</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Bryant</surname></persName>
		</editor>
		<meeting>the 12th International Congress of the European Federation for Medical Informatics (MIE&apos;94)</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="229" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Lexically suggest, logically define: quality assurance of the use of qualifiers and expected results of post-coordination in SNOMED CT</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rector</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Iannone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Biomed. Inform</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="199" to="209" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">The grail concept modelling language for medical terminology</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Rector</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bechhofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Goble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Nowlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">D</forename><surname>Solomon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell. Med</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="139" to="171" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Quality assurance of medical ontologies</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Rogers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Methods Inf. Med</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="267" to="274" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Cheap Boolean role constructors for description logics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th European Conference on Logics in Artificial Intelligence (JELIA&apos;08)</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Hölldobler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Wansing</surname></persName>
		</editor>
		<meeting>the 11th European Conference on Logics in Artificial Intelligence (JELIA&apos;08)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5293</biblScope>
			<biblScope unit="page" from="362" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Peer-to-peer reasoning for interlinked ontologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schlicht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Stuckenschmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Semant. Comput</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="27" to="58" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">MapResolve</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schlicht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Stuckenschmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on Web Reasoning and Rule Systems (RR&apos;11)</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Gutierrez</surname></persName>
		</editor>
		<meeting>the 5th International Conference on Web Reasoning and Rule Systems (RR&apos;11)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6902</biblScope>
			<biblScope unit="page" from="294" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Debugging incoherent terminologies</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schlobach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cornet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="317" to="349" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Consolidating SNOMED CT&apos;s ontological commitment</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cornet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Spackman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Appl. Ontol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="11" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Rule-based OWL reasoning for specific embedded devices</title>
		<author>
			<persName><forename type="first">C</forename><surname>Seitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schönfelder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Aroyo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Welty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Alani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kagal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Noy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Semantic Web Conference (ISWC&apos;11)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Blomqvist</surname></persName>
		</editor>
		<meeting>the 10th International Semantic Web Conference (ISWC&apos;11)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">7032</biblScope>
			<biblScope unit="page" from="237" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">In the search of improvements to the EL + classification algorithm</title>
		<author>
			<persName><forename type="first">B</forename><surname>Sertkaya</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Workshop on Description Logics (DL&apos;11)</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</editor>
		<meeting>the 24th International Workshop on Description Logics (DL&apos;11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">745</biblScope>
			<biblScope unit="page" from="389" to="399" />
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Consequence-based reasoning beyond Horn ontologies</title>
		<author>
			<persName><forename type="first">F</forename><surname>Simančík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</meeting>
		<imprint>
			<publisher>AAAI Press/IJCAI</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1093" to="1098" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Pellet: a practical OWL-DL reasoner</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kalyanpur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="51" to="53" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">The OBO Foundry: coordinated evolution of ontologies to support biomedical data integration</title>
		<author>
			<persName><forename type="first">B</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ashburner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rosse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Bug</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ceusters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Eilbeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ireland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Mungall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">O</forename><surname>Consortium</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leontis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rocca-Serra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ruttenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Sansone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Scheuermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">L</forename><surname>Whetzeland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lewis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1251" to="1255" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Parallel inferencing for OWL knowledge bases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Soma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K</forename><surname>Prasanna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Parallel Processing (ICPP&apos;08)</title>
		<meeting>the International Conference on Parallel Processing (ICPP&apos;08)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<monogr>
		<title level="m" type="main">Polynomial-time reasoning support for design and maintenance of large-scale biomedical ontologies</title>
		<author>
			<persName><forename type="first">B</forename><surname>Suntisrivaraporn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<pubPlace>Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Dresden</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">COROR: a composable rule-entailment OWL reasoner for resourceconstrained devices</title>
		<author>
			<persName><forename type="first">W</forename><surname>Tai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Keeney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>O'sullivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on Rule-Based Reasoning, Programming, and Applications (RuleML Europe&apos;11)</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Bassiliades</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Paschke</surname></persName>
		</editor>
		<meeting>the 5th International Conference on Rule-Based Reasoning, Programming, and Applications (RuleML Europe&apos;11)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6826</biblScope>
			<biblScope unit="page" from="212" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">The Gene Ontology Consortium: Gene ontology annotations and resources</title>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="page">102</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">TrOWL: Tractable OWL 2 reasoning infrastructure</title>
		<author>
			<persName><forename type="first">E</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Z</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Aroyo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hyvönen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Extended Semantic Web Conference (ESWC&apos;10)</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Teije</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Stuckenschmidt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Cabral</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Tudorache</surname></persName>
		</editor>
		<meeting>the 7th Extended Semantic Web Conference (ESWC&apos;10)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6089</biblScope>
			<biblScope unit="page" from="431" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">FaCT++ description logic reasoner: system description</title>
		<author>
			<persName><forename type="first">D</forename><surname>Tsarkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Joint Conference on Automated Reasoning (IJCAR&apos;06)</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Furbach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</editor>
		<meeting>the 3rd International Joint Conference on Automated Reasoning (IJCAR&apos;06)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4130</biblScope>
			<biblScope unit="page" from="292" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Optimizing terminological reasoning for expressive description logics</title>
		<author>
			<persName><forename type="first">D</forename><surname>Tsarkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="277" to="316" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Chainsaw: a metareasoner for large ontologies</title>
		<author>
			<persName><forename type="first">D</forename><surname>Tsarkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Palmisano</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the OWL Reasoner Evaluation Workshop 2012 (ORE&apos;12)</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yatskevich</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Jimenez-Ruiz</surname></persName>
		</editor>
		<meeting>the OWL Reasoner Evaluation Workshop 2012 (ORE&apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">858</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">WebPIE: a Web-scale parallel inference engine using MapReduce</title>
		<author>
			<persName><forename type="first">J</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kotoulas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Maassen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="page" from="59" to="75" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Scalable distributed reasoning using MapReduce</title>
		<author>
			<persName><forename type="first">J</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kotoulas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Oren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Heath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maynard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Motta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Semantic Web Conference (ISWC&apos;09)</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Thirunarayan</surname></persName>
		</editor>
		<meeting>the 8th International Semantic Web Conference (ISWC&apos;09)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5823</biblScope>
			<biblScope unit="page" from="634" to="649" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Parallel materialization of the finite RDFS closure for hundreds of millions of triples</title>
		<author>
			<persName><forename type="first">J</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Heath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maynard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Motta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Semantic Web Conference (ISWC&apos;09)</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Thirunarayan</surname></persName>
		</editor>
		<meeting>the 8th International Semantic Web Conference (ISWC&apos;09)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5823</biblScope>
			<biblScope unit="page" from="682" to="697" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<monogr>
		<title level="m" type="main">Automated reasoning: introduction and applications, 2nd edn</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Overbeek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lusk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Boyle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>McGraw-Hill Inc</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">A parallel reasoner for the description logic ALC</title>
		<author>
			<persName><forename type="first">K</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Workshop on Description Logics (DL&apos;12)</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Kazakov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</editor>
		<meeting>the 25th International Workshop on Description Logics (DL&apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">846</biblScope>
			<biblScope unit="page" from="378" to="388" />
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings</note>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Ontobee: a linked data server and browser for ontology terms</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Xiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mungall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ruttenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Biomedical Ontologies (ICBO)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="279" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">DReW: a reasoner for Datalog-rewritable description logics and dlprograms</title>
		<author>
			<persName><forename type="first">G</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Heymans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Workshop on Business models, Business Rules and Ontologies</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Ghali</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Fernández</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Heymans</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Krennwallner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Lévy</surname></persName>
		</editor>
		<meeting>the 1st International Workshop on Business models, Business Rules and Ontologies</meeting>
		<imprint>
			<publisher>ONTORULE Project</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
