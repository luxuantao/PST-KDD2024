<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Effect of Code Reordering on Branch Prediction *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Alex</forename><surname>Ramirez</surname></persName>
							<email>aramirez@ac.upc.es</email>
							<affiliation key="aff0">
								<orgName type="institution">Universitat</orgName>
								<address>
									<addrLine>Politecnica de Catalunya Jordi Girona 1-3</addrLine>
									<postCode>D6 08034</postCode>
									<settlement>Barcelona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Josep</forename><forename type="middle">L</forename><surname>Larriba-Pey</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Universitat</orgName>
								<address>
									<addrLine>Politecnica de Catalunya Jordi Girona 1-3</addrLine>
									<postCode>D6 08034</postCode>
									<settlement>Barcelona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mateo</forename><surname>Valero</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Universitat</orgName>
								<address>
									<addrLine>Politecnica de Catalunya Jordi Girona 1-3</addrLine>
									<postCode>D6 08034</postCode>
									<settlement>Barcelona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Effect of Code Reordering on Branch Prediction *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Branch prediction accuracy is a very important factor</head><p>for superscalar processor performance. The ability to predict the outcome of a branch allows the processor to effectively use a large instruction window, and extract a larger amount of Instruction Level Parallelism (ILP).</p><p>In this paper we will examine the effect of code layout optimizations on branch prediction accuracy and final processor performance. These code reordering techniques align branches so that they tend to be not taken, achieving better instruction cache performance and increasing the fetch bandwidth. Here we focus on how these optimizations affect both static and dynamic branch prediction.</p><p>Code reordering mainly increases the number of not taken branches, which benefits simple static predictors, which reach over 80% prediction accuracy with optimized codes. This branch direction change produces two effects on dynamic branch prediction: on the positive side, trades negative interference for neutral or positive interference in the prediction tables; on the negative side, it causes a worse distribution of the Branch History Register (BHR), causing many possible history values to be unused.</p><p>Our results show that code reordering reduces negative Pattern History Table (PHT) interference, increasing branch prediction accuracy on small branch predictors. For example, a OSKB gshare improves from 91.4% to 93.6%, and a 0.4KB gskew predictor from 93.5% to 94.4%. For larger history lengths, the large amount of not taken branches can degrade predictor performance on dealiased schemes, like the 16KB agree predictor which goes from 96.2% to 95.8%.</p><p>But processor Performance not only depends on branch prediction accuracy. Layout optimized codes have much better instruction cache performance, and wider fetch bandwidth. Our results show that when all three factors are considered together, code reordering techniques always improve processor performance. For example, performance 'This work was supported by the Ministry of Education and Science of Spain under contract TIC-0511/98 and by CEPBA. Alex Ramirez is also supported by Generalitat de Catalunya grant 1998F1-003060-26. 0-7695-0622-4\00 $10.00 0 2000 IEEE still increases by 8% with an agree predictor, which loses prediction accuracy, and it increases by 9% with a gshare predictor, which increases prediction accuracy.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Fetch performance broadly depends on three factors: the number of instruction cache misses, the width of instructions fetched each cycle, and the branch prediction accuracy. The first two factors determine the speed at which instructions are provided to the processor, the third determines the quality of the instruction provided, that is, how many instructions will be provided between instruction window squashes, limiting the amount of ILP that the processor is able to exploit.</p><p>Code reordering techniques are a known approach to the first two factors. The number of instruction cache misses depends on the code layout, by mapping the routines in a program so that they do not conflict with each other, we can reduce the number of cache misses by almost an order of magnitude <ref type="bibr" target="#b14">[17,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr">6]</ref>. By aligning basic blocks so that they execute sequentially, we can further increase spatial locality increasing both cache performance and fetch bandwidth [S, <ref type="bibr">17, 25, 191.</ref> The third factor has motivated the search of more accurate branch predictors.</p><p>The performance loss due to branch instructions was first approached with static branch predictors, which always predict the same outcome for a given branch. This prediction was obtained either using very simple heuristics <ref type="bibr" target="#b20">[23]</ref>, static analysis [l], or profile information <ref type="bibr">[5,</ref><ref type="bibr">4]</ref>.</p><p>The accuracy of static branch predictors can be increased using code transformations, which usually imply code replication [14, 27, 9, 13, 161, and branch alignment <ref type="bibr" target="#b2">[3]</ref>. This branch alignment is nothing but a code reordering optimization which targets an increase in the static branch prediction accuracy: knowing the branch outcome, it is aligned to follow the heuristic implemented by the static predictor.</p><p>As the transistor budget in the processor increased, branch prediction moved to the more accurate dynamic branch predictors. These store the recent branch behavior, and lookup the data each time the branch executes to produce a direction prediction <ref type="bibr" target="#b20">[23,</ref><ref type="bibr" target="#b23">26]</ref>.</p><p>But the size of these dynamic tables is limited, and sometimes two different branches end up sharing the same PHT entry. This is called prediction table interference, and is the main cause for decreased prediction accuracy <ref type="bibr" target="#b25">[28]</ref>.</p><p>Dynamic prediction tables can be organized in a clever way to reduce prediction table interference, leading to the recently proposed dealiased schemes <ref type="bibr">[ 10, 12,241.</ref> In this work we examine the effect on branch prediction accuracy of the code reordering optimizations which target the instruction cache. We examine the interaction of these optimizations with both static and dynamic branch predictors using the Software Trace Cache layout optimization <ref type="bibr">[19]</ref>.</p><p>The main effect of these code reordering techniques is an increase in the fraction of not taken branches. This increase favors static predictors which predict that all branches will be not taken, or that all forward branches will be not taken, going from 60% to over 80% prediction accuracy. Such an increase in the number of not taken branches also favors neutral or positive interference, because branches sharing the same PHT entry are likely to exhibit the same behavior, and will update the counter in the same direction. This interference reduction is specially significant in small predictors, and increases accuracy in a 0.5KB gshare from 91.4% to 93.6%, and a 0.4KB gskew predictor from 93.5% to 94.4%.</p><p>As larger tables are used, prediction table interference naturally decreases, reducing the benefits of an optimized layout. As history length increases, the large number of not taken branches produces a worse distribution of the BHR values, increasing interference in the dealiased predictors.</p><p>The negative BHR effect decreases performance in mid to large sized dealiased predictors, like the 16KB agree predictor which goes from 96.2% to 95.8%.</p><p>Finally, we show results on the overall processor performance because not only branch prediction accuracy affects IPC. Instruction cache performance and fetch bandwidth also play an important role, and more than compensate for the possible degradation in prediction accuracy. Processor performance still increases by 8% with an agree predictor w/out filtering (which loses prediction accuracy), and increases by 9% with a gshare predictor (which increases prediction accuracy).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Simulation setup</head><p>All the results in the paper were obtained using a simulator derived from the SimpleScalar 3.0 tool set <ref type="bibr" target="#b1">[2]</ref>. We run most of the SPECint95 benchmarks plus the PostgreSQL 6.3 database system running a subset of the TPC-D queries. All programs were compiled statically and with -04 optimization level using Compaq's C compiler.  Table <ref type="table" target="#tab_1">1</ref> shows the six benchmarks used and the input sets used to obtain the profile information and for testing, and the reasons for not including the remaining 3 SPECint95 codes. All simulations were run to completion. All figures in the paper present the arithmetic average of all executed benchmarks, where all benchmarks have the same weight.</p><p>In order to simulate the optimized code layout we generate an address translation table using the Software Trace Cache algorithm [ 191 and feed the simulator with translated PC's and recomputed branch outcomes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Paper structure</head><p>The rest of this paper is structured as follows: In Section 2 we present previous related work regarding both code layout optimizations and branch prediction, we also describe the dynamic branch prediction schemes used in the paper. Section 3 examines the effect of code layout optimizations on static branch prediction accuracy. Section 4 does the same for dynamic branch predictors, including dealiased prediction schemes. In Section 5 we measure not only branch prediction accuracy, but overall processor performance in order to account for all the effects of code reordering, both positive and negative. Finally, in Section 6 we summarize the influence of code layout optimizations on branch prediction and present our conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work</head><p>We can classify related work in two main groups: code layout optimization techniques, and branch prediction techniques.</p><p>Code layout optimizations usually target a better utilization of the instruction cache, and use profile data or heuristics to lay out the routines in a program <ref type="bibr" target="#b14">[ 17,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr">61</ref>, and the basic blocks in a routine <ref type="bibr">[8,</ref><ref type="bibr" target="#b14">17,</ref><ref type="bibr">25,</ref><ref type="bibr" target="#b16">191</ref> to minimize the number of conflict misses. Reducing the number of conflict misses in the instruction cache, code reordering increases fetch performance, and overall processor performance. The use of both routine placement and basic block reordering can also increase the effective fetch bandwidth provided by increasing code sequentiality (reducing the number of taken branches). Both factors prove important at increasing the fetch performance, as shown in <ref type="bibr">[19, 181.</ref> Code layout optimizations have also been used to increase the static branch prediction accuracy, using profile data <ref type="bibr">[5,</ref><ref type="bibr">4]</ref> or complex static analysis techniques [I] to predict the branch direction, and then align the branch so that it follows a more simple heuristic <ref type="bibr" target="#b2">[3]</ref>, like making all branches usually taken (or usually not taken), or aligning branches so that only a forward branch is usually not taken <ref type="bibr" target="#b20">[23]</ref>. In this work we examine how code layout optimizations targeting the fetch engine affect both static and dynamic branch prediction.</p><p>There have been other code transformations proposed to improve static branch prediction accuracy, usually implying code replication <ref type="bibr" target="#b26">[14,</ref><ref type="bibr">27,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr">13,</ref><ref type="bibr">161</ref>. These code transformations are beyond the scope of this work.</p><p>Basic branch prediction techniques can also be broadly classified in three groups: static, semi-static, and dynamic predictors. Static prediction techniques are based solely on static analysis and simple prediction strategies, and always predict the same outcome for a given branch. Semi-static branch predictors improve on static techniques by using profile data obtained at run-time to replace the static analysis and heuristics used, but still predict always the same outcome for a given branch. The more accurate dynamic branch predictors store this run-time information in dynamic tables, and lookup this data every time the branch is executed to make a direction prediction. The different dynamic branch predictors differ in the way they store the past behavior of a branch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Software 'kace Cache</head><p>The code layout optimization used in this paper is the Software Trace Cache (STC) [?]. The STC maps basic blocks so that sequentially executed basic blocks tend to be in consecutive memory positions, building basic block chains than may span multiple routines. The generated chains are then mapped in memory trying to minimize conflicts among them, by mapping two popular chains next to each other, and mapping the most heavily used chains to a specially reserved area of the instruction cache that we call the Conflict Free Area (CFA).</p><p>The chain mapping algorithm should have little or no influence on the branch prediction mechanism, only the basic block chaining is relevant for that purpose. The results obtained in this paper should be valid for any other code layout optimization which aligns branches towards their not-taken target.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Two-level adaptive predictors</head><p>The more simple dynamic branch predictor (the bimodal branch predictor <ref type="bibr" target="#b20">[23]</ref>) simply keeps a saturating two-bit counter for each branch, increasing the counter if the branch is taken, and decreasing the counter if it is not taken. The branch is predicted to behave as the high bit of the counter says (taken if it is 1, not taken otherwise). But a branch outcome not only depends on the branch itself, it also depends on the outcomes of the previously executed branches, and on the past outcomes of the same branch.</p><p>As shown in Figure <ref type="figure" target="#fig_8">1</ref>, two-level adaptive branch predictors <ref type="bibr" target="#b23">[26]</ref>  By storing data this way, any given entry in the PHT corresponds to a branch address in a given history situation, which allows the predictor to make a more informed decision, achieving higher accuracy.</p><p>It is possible to improve the Level 2 indexing function by using a hash function of the branch address and the BHR, like an XOR [ 111. This function distributed branches in the PHT in a better way, increasing the accuracy of global his- tory predictors. The resulting scheme (shown in Figure <ref type="figure" target="#fig_8">1</ref>.a) is the gshare branch predictor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dealiased predictors</head><p>Two-level adaptive branch predictors distribute data so that each branch has a separate PHT entry for each different history situation. But the prediction tables are finite, and sometimes two different branches end up sharing the same PHT entry.</p><p>We classify PHT interference in three types: when the conflict does not change the 2-bit counter value, we talk about neutral interference; if the changed counter value produces a correct prediction where there would have been a misprediction, we talk about positive interference; if the conflict causes a misprediction when the old counter was correct, we talk about negative interference. Negative interference happens more often than positive interference, and is the main cause of decreased prediction accuracy <ref type="bibr" target="#b25">[28,</ref><ref type="bibr" target="#b17">20]</ref>.</p><p>Dealiased branch predictors reduce negative PHT interference by changing the way they store data in the predic-Pattern History Table  tion tables. Figure <ref type="figure" target="#fig_0">2</ref>.a shows the agree prediction scheme <ref type="bibr" target="#b21">[24]</ref>. The agree predictor adds an extra bit of information associated to each branch into the BTB/instruction cache: the bias bit. This bit predicts the branch direction. The meaning of the PHT counter changes: the two-bit counter now predicts if the branch behavior will agree with the bias bit, or not. This allows two branches with opposite behavior (a mostly taken and a mostly not taken branch) to use the same PHT entry, without creating a negative conflict because both branches will push the counter towards the agree position, being the bias bit what differentiates them.</p><p>The bi-mode branch predictor [ 101 (shown in Figure <ref type="figure" target="#fig_0">2</ref>.b) is based on the same principle as the agree predictor: separating branches among usually taken and usually not taken sub-streams. The bi-mode predictor uses a separate gshare component to keep track of each sub-stream, avoiding interference among them, and uses a bimodal branch predictor to classify a branch into each sub-stream. Interference among the two sub-streams is avoided because each branch only updates the gshare which keeps track of its sub-stream.</p><p>The gskew branch predictor <ref type="bibr">[12,</ref><ref type="bibr" target="#b19">22]</ref> (Figure <ref type="figure" target="#fig_0">2</ref>.c) is based on the fact that most aliasing in the prediction tables is due to conflict aliasing, not capacity problems. Derived from the skew-associative caches <ref type="bibr" target="#b18">[21]</ref>, the gskew predictor stores r; branches in three separate tables, which are accessed with three different indexes. If a branch data is aliased in one of the tables, it is expected that it will not be so in the other two, obtaining a correct prediction with a majority vote.</p><p>Code reordering techniques are known to improve the instruction cache miss rate and the fetch bandwidth. Next, we examine how they interact with the third factor in fetch performance: the branch prediction mechanism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Effect on static prediction</head><p>In this section we will examine the prediction accuracy that some simple static branch prediction schemes achieve for the examined benchmarks. The static strategies examined are: predict that all branches will be taken, predict that all branches will be not taken, predict that backwards branches will be taken and forward branches will not, and predict that a branch will always take its most usual direction based on profile information.</p><p>Figure <ref type="figure" target="#fig_1">3</ref> shows the branch prediction accuracy of some simple static branch prediction strategies (always taken, always not taken, backwards taken forward not taken) and the profile based predictor for both the original code layout and the compiler optimized layouts. For the optimized layout, we show results for the same input set used for training (self-optimized) and for a different input set (crossoptimized). The prediction accuracy of an 8KB Gshare predictor is shown for comparison purposes. The simple static prediction approaches prove quite useless for the baseline code layout with near 50% prediction accuracy, only the BTFNT predictor reaches 60%, and doesn't go under 50% for any of the studied benchmarks (individual benchmark results not shown). On the other hand, the profile static predictor proves very accurate, predicting correctly over 90% of the branches. This shows that branches can be predicted statically, but not with this simple strategies.</p><p>We optimize the code layout using the Software Trace Cache (STC) algorithm <ref type="bibr">[19]</ref>, which targets an increase in the sequentiality of the code, that is, it reorders basic blocks so that branches tend to be not taken.</p><p>Once we have optimized the code layout, the static branch prediction accuracy changes dramatically. The Not Taken and the BTFNT predictors now predict correctly over 80% of the branches, losing some accuracy in the crosstrained test. This 80% prediction accuracy shows that static branch prediction can be very accurate for these optimized code layouts; but it is still much lower than what can be achieved with modem two level adaptive branch predictors like the Gshare.</p><p>To gain further insight on this high predictability of optimized binaries, we explore in depth the changes in branch behavior introduced by the code layout optimization. Figure <ref type="figure">4</ref>.a shows a classification of all dynamic branches by the percentage of times they are taken or not taken for both the original and the optimized code layouts. Branches to the left of the plot are always not taken, while branches to the right are always taken.</p><p>Examining the branch classification for the original code layout, we observe that 36% of the branches are always not taken, while 32% are always taken. The rest of the branches are evenly spread across all taken percent values, with a slightly higher peak for branches that are 50% taken. This explains the low prediction accuracy obtained, because branches do not seem to follow such simple behavior rules.</p><p>By optimizing the code layout, we can reverse the direction of those branches which are taken more than 50% of the times. This way, a branch which was taken 80% of the times will now only be taken 20% of the times.</p><p>The classification for the optimized code layout shows that we were quite successful at reversing the branch direction for those usually taken branches. The fraction of always taken branches is reduced from 32% to lo%, and most categories over 50% taken also present reductions in the number of branches. This leads to a significant increase in the number of always not taken branches, from 36% to 59%. With most highly biased branches in the not taken side, and most other branches moving from over 50% taken to mostly not taken, the prediction accuracy of an always not taken (or BTFNT) predictor, increases significantly, as we have seen in Figure <ref type="figure" target="#fig_1">3</ref>.</p><p>The increase in the number of usually not taken branches explains the different behavior of the two code layouts regarding static branch prediction. Further increases in static prediction accuracy can be expected of a code layout optimization that explicitly targets a specific branch predictor, like the BTFNT predictor, or uses code replication techniques to use path information in its static predictions.</p><p>Next, we will examine how this change in branch direction affects dynamic branch prediction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Effect on dynamic prediction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Two-level adaptive predictors</head><p>Figure <ref type="figure" target="#fig_3">5</ref> shows the effect of code reordering on dynamic prediction accuracy for the Gshare, PAg, and bimodal predictors. Predictor sizes from 512 bytes to 16KB are explored for both the baseline (dotted line) and the optimized code layout (solid line). Clearly, the STC increases the prediction accuracy of the examined branch predictors, specially for the smaller predictor sizes. Both the Gshare and the bimodal predictors seem to converge at infinite predictor size, which points that the benefits of using the STC are related to prediction table interference. The larger the table, the less interference, the closer the prediction accuracy for both layouts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Prediction table interference</head><p>Figure <ref type="figure" target="#fig_4">6</ref> shows the percent of dynamic branches which introduce conflicts in the prediction tables of the gshare branch predictor with both the baseline and the optimized code layouts. We classify conflicts in three groups: neutral interference when the conflict does not change the prediction, and positive or negative if the conflict changes the prediction for good or bad.</p><p>As expected, there is a significant reduction in the number of negative conflicts when the STC layout is used with the Gshare branch predictor. For example, a 1KB gshare goes down from 1.45% of negative conflicts to 0.79% using the optimized code layout.</p><p>Intuitively, the increase in the number of not taken branches favors positive interference, because it is more likely that when two branches interfere, they both behave the same way (both not taken) resulting in a positive or neutral conflict. The total amount of conflicts shows a different behavior. The optimized code layout has fewer neutral conflicts for small predictor sizes, but it ends up with a larger amount of neutral interference for the largest configurations.</p><p>We will look further into this neutral interference increase in the next section, where we will examine dealiased branch prediction schemes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Dealiased branch predictors</head><p>Given that the use of an optimized code layout is reducing the negative interference found in the dynamic prediction tables, it is interesting to examine what happens with modem branch predictors that are already organized to min- imize such interference like the agree <ref type="bibr" target="#b21">[24]</ref>, bimode <ref type="bibr">[lo]</ref>,</p><p>and gskew [12, 221 predictors. We will refer to these predictors as dealiased branch prediction schemes.</p><p>Figure <ref type="figure" target="#fig_5">7</ref> shows the prediction accuracy of the dealiased predictors with both the baseline and the optimized code layouts. The prediction accuracy of the gshare predictor with the optimized layout is shown for reference purposes.</p><p>These results show that for small predictor sizes, the use of optimized code layouts obtains equivalent or higher accuracy even in the dealiased branch predictors. The advantage of the optimized layouts is specially clear in the 0.4KB gskew predictor, which increases prediction accuracy from 93.5% to 94.4%.</p><p>For medium and large predictor sizes, all dealiased branch predictors obtain higher accuracy with the baseline code layout, being the difference specially significant with the 16KB agree predictor, which obtains a 96.2% accuracy with the baseline layout and a 95.8% with the optimized code.</p><p>A more important result shows that the use of a large agree or bimode predictor with the optimized code layout does not yield sigmficant improvements over a gshare pre- dictor. Only the gskew predictor obtains significantly better results than the gshare predictor when using the optimized code layout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Prediction table interference</head><p>Figure <ref type="figure" target="#fig_4">6</ref> shows the percent of dynamic branches which introduce conflicts in the prediction tables of the gshare branch predictor with the optimized code layout and the agree predictor using both code layouts. These results show that the agree prediction scheme with a non optimized layout obtains a slightly better negative interference reduction than the optimized code layout. It is surprising that using the agree predictor, the optimized code layout has more negative conflicts than the baseline.</p><p>From these results it seems that the dealiased predictors prove more effective at reducing interference than the optimized code layout, but the more important result is that it seems more difficult to reduce conflicts in an optimized binary. The fact that the optimized code layout has more total interference for the larger predictor sizes can explain this higher fraction of negative conflicts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Branch history register distribution</head><p>The fact that dealiased predictors using an optimized binary obtain worse results than a gshare predictor points to some other factor hindering the performance of these predictors.</p><p>The high fraction of not taken branches found in the optimized code layout (80% of all branches are not taken) may be hindering the branch distribution in the BHR. When working with an optimized binary, the BHR will tend to be full of zeros, causing many possible BHR values to be never or rarely used, leading to a worse branch distribution and a loss of useful information to make a correct prediction. The dealiased predictors do not benefit from the interference reduction effect, because they are quite good at reducing it themselves, thus they only suffer the negative BHR effect and loose accuracy with the optimized code layout.</p><p>To analyze this BHR distribution factor, Figure <ref type="figure" target="#fig_7">9</ref> shows the number of times each possible history value was found in an 1 1-bit global history predictor for both code layouts. The BHR values are sorted by the number of zeros their binary value contains (from all 1's to all 0's). In addition to the BHR value usage, the figure shows the average usage, and the average + standard deviation. The average usage is the same in both code layouts. Note the Y axis is in loglo scale.</p><p>The first remarkable aspect of these plots is the position of the highest peak. The most popular history value for the baseline layout is a BHR full of 1's (leftmost value), while the highest peak of the STC layout corresponds to a BHR full of 0's (rightmost value). Aside from that, the BHR value usage in the baseline layout is mostly spread across 1-2 orders of magnitude. Meanwhile, the STC layout has its BHR value usage spread across 4-5 orders of magnitude, with very high peaks on a reduced set of values. It is clear that values having mostly 1's are less used than those having mostly 0's. To summarize these observations, we can just look at the distance between the average usage and the standard deviation lines. The more distance between them, the worse the BHR value distribution. In this case, the distance between both lines in the STC layout is 2 . 5 ~ larger than in the baseline code layout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Processor performance</head><p>The complexity of current processors is already very high, and keeps increasing with each generation. Simulating such complex designs is not always feasible, specially if the design space to explore is large. This leads to many studies in which only isolated components are examined, on the basis that if that component works better, then overall performance will also increase.</p><p>We have shown that the performance impact of the branch predictor is heavily dependent of the instruction cache performance <ref type="bibr">[15]</ref>. New results shown here in this paper point that branch prediction accuracy can decline when optimized code layouts are used, but we know that those same layouts also increase the instruction cache performance.</p><p>The pedormance benefits of an instruction cache miss reduction could compensate for the performance loss due to reduced branch prediction accuracy. In order to explore this possibility, we simulated a whole out of order processor using the sim-outorder simulator of the Simplescalar 3.0 Tool set. The detailed simulation setup for our 4-wide processor is shown in Table <ref type="table" target="#tab_5">2</ref>.</p><p>Figure <ref type="figure" target="#fig_8">10</ref> shows processor performance measured in IPC for both the baseline and the STC code layouts using two different branch predictors: the gshare predictor, which proves more accurate with the optimized layout; and the agree predictor, which proves more accurate with the baseline layout. We simulated both a small 16KB instruction cache and a larger 64KB cache.  These results show that the instruction cache miss reduction more than compensates for the loss of branch prediction accuracy, as the STC layout always performs better than the baseline, even with the agree predictor, with a 17% improvement on the 16KB cache, and a 9% on the 64KB cache.</p><p>Examining the results for each individual code layout on the 16KB instruction cache, we observe that the branch predictor used does not make a significant difference for the baseline layout. Meanwhile, the optimized layout does 0.5% better with the gshare predictor than with the agree predictor.</p><p>When a 64KB instruction cache is used, the baseline layout obtains a 2% improvement using the agree predictor for the smaller predictor size, and a 1% improvement for the larger setup. The optimized code layout still does slightly better with the agree predictor, but the difference is not significant. In any case, the optimized layout still obtains an 8% improvement over the baseline layout with the agree predictor.</p><p>To gain further insight on why the optimized code layout obtains better performance, even when it has lower prediction accuracy, Table <ref type="table" target="#tab_6">3</ref> shows a comparison of all three fetch performance factors for both code layouts and the 16KB a- gree branch predictor. We show the total number of misses (in millions), the average fetch width (in instructions per cycle), the branch prediction accuracy (in percent), and the processor performance (IPC). The lower prediction accuracy of the STC layout translates into smaller sequences of valid instructions, because a branch misprediction is encountered sooner. But the smaller distance between mispredictions is compensated by the smaller perceived latency of the instruction cache, and the higher rate at which these instructions are provided.</p><p>These results show that reducing the number of branch misprediction does not necessarily mean increasing processor performance. Code transformations such as basic block reordering may decrease branch prediction accuracy, but still increase performance due to other effects, like an instruction cache miss reduction and an increase in the fetch bandwidth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>To our knowledge, this is the first paper showing the effects of code reordering on branch prediction accuracy. These are summarized in Figure <ref type="figure" target="#fig_8">1</ref> 1. Summarizing, optimizing the code layout for higher fetch rate will: Change branch direction: Most branches tend to be not taken, and most highly biased branches are now always not taken branches.</p><p>Reduce negative interference: As most branches are now not taken, it is more likely that when two branches map to the same two-bit counter, they push the counter in the same direction (towards not taken).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generate a worse BHR value distribution:</head><p>The high proportion of not taken branches causes many BHR values to be not used, concentrating branch history on a smaller set of values. This reduces the amount of useful information the predictor has to take a decision.</p><p>The overall effect of code reordering on a given branch predictor will depend on which of these effects dominates. Predictors which do not use global history registers (bimodal and PAX), or which hash the global history register with the branch address or other values (gshare) will benefit from the table interference reduction, while they mitigate or ignore the BHR value effect. Predictors which heavily depend of the global history register, or which already have their own interference avoiding mechanism will feel the negative BHR value effect, without obtaining a large benefit form the interference reduction offered by optimized layouts.</p><p>Second, we have shown that increasing branch prediction accuracy does not necessarily mean higher processor performance. For example, optimizing the code layout for better instruction cache performance may decrease prediction accuracy, but the reduced distance between branch mispredictions is compensated by a lower cache miss rate, and a higher fetch width, which increase the speed at which instructions are provided.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Dealiased branch prediction schemes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Static branch prediction accuracy for the original and optimized code layouts (self and cross trained).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>htimes Taken Figure 4 .</head><label>Taken4</label><figDesc>Figure 4. The use of optimized code layouts reverses branch direction, so that they tend to be usually not taken.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Dynamic prediction accuracy for both the base and the STC optimized code layouts using two-level adaptive prediction schemes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Percent of dynamic branches which cause interference in the gshare prediction tables for the baseline and optimized code layouts .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Effect of the optimized code layout on dealiased branch predictors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Percent of dynamic branches which cause interference in the gshare prediction tables optimized code layout and the agree predictor using both code layouts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Branch history register value distribution for the baseline code layout (a), and the STC optimized layout (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 1</head><label>1</label><figDesc>Figure</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Effect of code reordering in (a) static branch prediction (branch direction), (b) dynamic prediction table interference, and (c) branch history register value usage.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 . Simulated benchmarks and their training and test inputs.</head><label>1</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>keep two levels of data about the branch behavior. The Level 1 table keeps information about the past branch outcomes. These table can store the outcomes of all branches in a single register (global history, named PAp,s,g, shown in Figure l.a), or it can have a separate register for each branch (private or self history, named GAp, s, g, shown in Figure 1.b). The Level 1 table is usually referred to as the Branch History Register (BHR). The BHR is used to index into the Level 2 table, composed of two-bit saturating counters managed as in the bimodal predictor. The Level 2 table is usually referred to as the Pattern History Table (PHT).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Two-level adaptive branch predictors store data in two separate tables, using the first table to index into the second level.</head><label></label><figDesc></figDesc><table><row><cell>Branch address</cell><cell></cell><cell></cell><cell></cell></row><row><cell>U</cell><cell></cell><cell></cell><cell></cell></row><row><cell>(a) Gshare predictor (global history)</cell><cell></cell><cell cols="2">(b) PAg predictor (private history)</cell></row><row><cell>Figure 1. I riziGy-</cell><cell>. 1</cell><cell>Panml updatc (only IhS ~slec~ed prdaorl</cell><cell>] Branchaddress I Globrl history</cell></row><row><cell></cell><cell>Grhm B</cell><cell></cell><cell></cell></row><row><cell>Mostly</cell><cell>Mostly</cell><cell></cell><cell></cell></row><row><cell>Not Taken</cell><cell>Take"</cell><cell></cell><cell></cell></row><row><cell>Branches</cell><cell>Branches</cell><cell></cell><cell></cell></row></table><note><p>. . . . 5 Bimodal L N s l 2 mhlc w s if Bhr bil ICIS PrrdiclFd predicum a p s mm h r a o c h d w l m (TakcnlNollakml the bhnbil \ 1 (a) Agree predictor (b) Bi-mode predictor (c) Gskew predictor</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 . Setup description for the 4-way out of order processor examined.</head><label>2</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 3 . Instruction cache (I$) misses, fetch width, prediction accuracy, and IPC for both layouts using a 16KB agree predictor.</head><label>3</label><figDesc></figDesc><table><row><cell>IPC</cell></row></table><note><p><p>I$ size Layout</p>I$ misses Fetch width BP accuracy</p></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Branch prediction for free</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Lams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation</title>
		<meeting>ACM SIGPLAN Conf. on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
			<biblScope unit="page" from="300" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Evaluating future microprocessors: the simplescalar tool set</title>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<idno>TR-1308</idno>
		<imprint>
			<date type="published" when="1996-07">July 1996</date>
		</imprint>
		<respStmt>
			<orgName>University of Winsconsin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Reducing branch costs via branch alignment</title>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grunwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Intl. Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the 6th Intl. Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="1994-10">Oct. 1994</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="242" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Corpus-based static branch prediction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grunwald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lindsay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation</title>
		<meeting>ACM SIGPLAN Conf. on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="79" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Predicting conditional branch directions from previous runs of a program. Proceedings of the 5th Intl. Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Freudenberger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="85" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Procedure placement using temporal ordering information</title>
		<author>
			<persName><forename type="first">N</forename><surname>Cloy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Blackwell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th Annual ACMIIEEE Intl. Symposium on Microarchitecture</title>
		<meeting>the 30th Annual ACMIIEEE Intl. Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1997-12">Dec. 1997</date>
			<biblScope unit="page" from="303" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient procedure mapping using cache line coloring</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Kaeli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIG-PLAN Conf. on Programming Language Design and Implementation</title>
		<meeting>ACM SIG-PLAN Conf. on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
			<biblScope unit="page" from="171" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Achieving high instruction cache performance with an optimizing compiler</title>
		<author>
			<persName><forename type="first">W.-M</forename><surname>Hwu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual Intl. Symposium on Computer Architecture</title>
		<meeting>the 16th Annual Intl. Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1989-06">June 1989</date>
			<biblScope unit="page" from="242" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Improving semi-static branch prediction by code replication</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th Annual ACMIIEEE Intl. Symposium on Microarchitecture</title>
		<meeting>the 30th Annual ACMIIEEE Intl. Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1994-12">1994. Dec. 1997</date>
			<biblScope unit="page" from="4" to="13" />
		</imprint>
	</monogr>
	<note>Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Combining branch predictors</title>
		<author>
			<persName><forename type="first">I</forename></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcfarling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
		</imprint>
		<respStmt>
			<orgName>Compaq Western Research Lab.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report TN-36</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Trading conflict and capacity aliasing in conditional branch predictors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Michaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uhlig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Annual Intl. Symposium on Computer Architecture</title>
		<meeting>the 24th Annual Intl. Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="292" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Avoiding conditional branches by code replication</title>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I.-C</forename><forename type="middle">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Mudge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Whalley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation</title>
		<meeting>ACM SIGPLAN Conf. on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="56" to="66" />
		</imprint>
	</monogr>
	<note>Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the performance of fetch engines running dss workloafds</title>
		<author>
			<persName><forename type="first">C</forename><surname>Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ramirez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Intl. Euro-Par Conference</title>
		<meeting>the Intl. Euro-Par Conference</meeting>
		<imprint>
			<date type="published" when="2000-08">Aug. 2000</date>
		</imprint>
	</monogr>
	<note>page to appear</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Accurate static branch prediction by value range propagation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R C</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation</title>
		<meeting>ACM SIGPLAN Conf. on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="67" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Profile guided code positioning</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pettis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Con$ on Programming Language Design and Implementation</title>
		<meeting>ACM SIGPLAN Con$ on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="16" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Optimization of instruction fetch for decision support workloads</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ramirez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Serrano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Intl. Conference on Parallel Processing</title>
		<meeting>the Intl. Conference on Parallel Processing</meeting>
		<imprint>
			<date type="published" when="1999-09">Sept. 1999</date>
			<biblScope unit="page" from="238" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Software trace cache</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ramirez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Navarm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Intl. Conference on Supercomputing</title>
		<meeting>the 13th Intl. Conference on Supercomputing</meeting>
		<imprint>
			<date type="published" when="1999-06">June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Correlation and aliasing in dynamic branch predictors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sechrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mudge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23th Annual Intl. Symposium on Computer Architecture</title>
		<meeting>the 23th Annual Intl. Symposium on Computer Architecture</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A case for two-way skewed-associative caches</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Annual Intl. Symposium on Computer Architecture</title>
		<meeting>the 20th Annual Intl. Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1993-05">May 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">D-aliased hybrid branch predictors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Michaud</surname></persName>
		</author>
		<idno>PI-1229</idno>
	</analytic>
	<monogr>
		<title level="j">IRISA</title>
		<imprint>
			<date type="published" when="1999-02">Feb. 1999</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A study of branch prediction strategies. Proceedings of the 8th Annual Intl</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Symposium on Computer Architecture</title>
		<imprint>
			<biblScope unit="page" from="135" to="148" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The agree predictor: A mechanism for reducing negative branch history interference</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sprangle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Chappell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Alsup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Annual Intl. Symposium on Computer Architecture</title>
		<meeting>the 24th Annual Intl. Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="284" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Optimizing instruction cache performance for operating system intensive workloads</title>
		<author>
			<persName><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Daigle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st Intl. Conference on High Pelformance Computer Architecture</title>
		<meeting>the 1st Intl. Conference on High Pelformance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1995-01">Jan. 1995</date>
			<biblScope unit="page" from="360" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Two-level adaptive branch prediction</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Annual ACMIIEEE Intl. Symposium on Microarchitecture</title>
		<meeting>the 24th Annual ACMIIEEE Intl. Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="51" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Improving the accuracy of static branch prediction using branch correlation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Intl. Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the 6th Intl. Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="1994-10">Oct. 1994</date>
			<biblScope unit="page" from="232" to="241" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A comparative analysis of schemes for correlated branch prediction</title>
		<author>
			<persName><forename type="first">C</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cloy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22th Annual Intl. Symposium on Computer Architecture</title>
		<meeting>the 22th Annual Intl. Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName><surname>Whalley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992. 1996</date>
			<biblScope unit="volume">322</biblScope>
			<biblScope unit="page" from="22" to="32" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
