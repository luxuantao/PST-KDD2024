<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Treewidth computations I. Upper bounds ୋ</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2009-04-19">19 April 2009</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hans</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
							<email>hansb@cs.uu.nl</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Information and Computing Sciences</orgName>
								<orgName type="institution">Utrecht University</orgName>
								<address>
									<postBox>P.O. Box 80.089</postBox>
									<postCode>3508 TB</postCode>
									<settlement>Utrecht</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Arie</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
							<email>koster@math2.rwth-aachen.de</email>
							<affiliation key="aff1">
								<orgName type="department">Lehrstuhl II für Mathematik</orgName>
								<orgName type="institution">RWTH Aachen University</orgName>
								<address>
									<addrLine>Wüllnerstr. zwischen 5 und 7</addrLine>
									<postCode>D-52062</postCode>
									<settlement>Aachen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Treewidth computations I. Upper bounds ୋ</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2009-04-19">19 April 2009</date>
						</imprint>
					</monogr>
					<idno type="MD5">8267285E680993D2398DCD776477EAC0</idno>
					<idno type="DOI">10.1016/j.ic.2009.03.008</idno>
					<note type="submission">Received 22 September 2008 Revised 29 March 2009</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Treewidth Upper bounds Heuristics Approximation algorithms Graph algorithms</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>For more and more applications, it is important to be able to compute the treewidth of a given graph and to find tree decompositions of small width reasonably fast.</p><p>This paper gives an overview of several upper bound heuristics that have been proposed and tested for the problem of determining the treewidth of a graph and finding tree decompositions. Each of the heuristics produces tree decompositions whose width may be larger than the optimal width. However, experiments show that in many cases, the heuristics give tree decompositions whose width is close to the exact treewidth of the input graphs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The notions of treewidth and tree decomposition have gained their attractiveness partly because many graph and network problems that are intractable (e.g., NP-hard) on arbitrary graphs become efficiently solvable (e.g., with a linear time algorithm) when the treewidth of the input graphs is bounded by a constant. Such algorithms have been found for many combinatorial problems (see e.g. <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref>), and also have been employed for problems from computational biology (see e.g. <ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref>), constraint satisfaction (see e.g. <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b2">3]</ref>), and probabilistic networks (see <ref type="bibr" target="#b10">[11]</ref>).</p><p>Many of the linear or polynomial time algorithms for problems on graphs with small treewidth have the following form. First, a tree decomposition of the graph with small width is found. Then, this tree decomposition is used in a dynamic programming algorithm to solve the original problem. In case of a theoretical investigation where we are not interested in the constant factor hidden in the O-notation, one can use for the first step the algorithm from <ref type="bibr" target="#b11">[12]</ref>: for each fixed k, there is a linear time algorithm that either tells that the treewidth of a given input graph G is larger than k, or finds a tree decomposition of width at most k. In practice however, the algorithm from <ref type="bibr" target="#b11">[12]</ref> is not useful due to the huge constant factor. This was also shown by Röhrig <ref type="bibr" target="#b12">[13]</ref> in an experimental evaluation of the algorithm of <ref type="bibr" target="#b11">[12]</ref>. Thus, there is a need for practical algorithms that find tree decompositions of given graphs of small width.</p><p>We aim to address this issue in a series of three overview papers, reviewing the developments of the last decade and complementing some minor results. In this first paper of the series, we look at upper bound heuristics and approximation ୋ The research was partly carried out during a visit by the second author to Utrecht University with support from the project Treewidth and Combinatorial Optimisation with a grant from the Netherlands Organisation for Scientific Research NWO. The second author's research was also supported by the Centre for Discrete Mathematics and its Applications (DIMAP), University of Warwick, EPSRC award EP/D063191/1. algorithms, i.e., algorithms, that given a graph G, find a tree decomposition of G whose width is possibly not optimal, but hopefully close to optimal. The paper is accompanied by a website for experiments with some of the algorithms presented <ref type="bibr" target="#b13">[14]</ref>.</p><p>In later papers in this series, we plan to address algorithms that give lower bounds to the treewidth of input graphs <ref type="bibr" target="#b14">[15]</ref>, exact algorithms, and preprocessing methods <ref type="bibr" target="#b15">[16]</ref>.</p><p>This paper is organised as follows. In Section 2, we give several of the necessary definitions, and some useful graph theoretic results. In particular, we look at some different characterisations of treewidth, which will be of use for different types of heuristics. One such characterisation is by using elimination orderings, and heuristics based on this notion are discussed in Section 3. Most other heuristics for treewidth appear to be relying in some way on the notion of separator. These are discussed in Section 4. Sometimes, when we have found a tree decomposition, it can be improved by finding a minimal triangulation inside the triangulation corresponding to the tree decomposition; see Section 5. We report on an experimental study to evaluate some of the heuristics in Section 6. Some final conclusions are given in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>In this section, we give some definitions and some useful graph theoretic results. We use standard graph terminology, and will in some cases assume that the reader is familiar with some standard (graph) algorithms.</p><p>We start the preliminaries with some pointers to background information, for readers that are unfamiliar with some of the topics of this paper. For more background in graph theory, see e.g., <ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref>; see also <ref type="bibr" target="#b22">[23]</ref>. Recommended texts for (graph) algorithms are e.g., <ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref><ref type="bibr" target="#b26">[27]</ref>. In several cases, we use results from the algorithmic graph theory for chordal graphs; for this, we recommend <ref type="bibr" target="#b27">[28]</ref>. Books on parameterised complexity, with several results on or using treewidth are <ref type="bibr" target="#b28">[29]</ref><ref type="bibr" target="#b29">[30]</ref><ref type="bibr" target="#b30">[31]</ref>. See <ref type="bibr" target="#b31">[32]</ref> for the theory of NP-completeness. Overview papers on treewidth are <ref type="bibr" target="#b32">[33]</ref><ref type="bibr" target="#b33">[34]</ref><ref type="bibr" target="#b34">[35]</ref><ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref><ref type="bibr" target="#b38">[39]</ref><ref type="bibr" target="#b39">[40]</ref><ref type="bibr" target="#b40">[41]</ref>; see also <ref type="bibr" target="#b41">[42]</ref>. Several concepts, related to treewidth have been studied. A good introduction to many of these can be found in <ref type="bibr" target="#b42">[43]</ref>.</p><p>All graphs we consider in this paper are undirected and simple, i.e., without parallel edges or self-loops. A graph is denoted G = (V, E) with V the set of vertices and E the set of edges. Unless stated otherwise, n = |V| denotes the number of vertices in the considered graph. The degree of a vertex v ∈ V in a graph G is denoted d G <ref type="bibr">(v)</ref> or d(v) if the graph is clear from the context.</p><p>The set of neighbours of</p><formula xml:id="formula_0">v in graph G = (V, E) is denoted by N G (v) = {w ∈ V | {v, w} ∈ E}. The set of neighbours of v and v itself is denoted N G [v] = N G (v) ∪ {v}.</formula><p>We assume the reader to be familiar with notions like cycle, clique, maximal clique, connected component. The subgraph</p><formula xml:id="formula_1">of G = (V, E) induced by vertex set W ⊆ V is denoted by G[W ] = (W, {{v, w} ∈ E | v, w ∈ W }). A set of vertices S ⊆ V is a separator (or separating vertex set) in a graph G = (V, E) if G[V \S</formula><p>] has more than one connected component. A minimum separator is a separator of minimum size. A separator S in G = (V, E) is an s,t-separator for vertices s, t ∈ V , if s and t belong to different connected components of G[V \S]. An s,t-separator S is a minimal s,t-separator, if it does not contain another s,t-separator as a proper subset. A separator S is a minimal separator, if there are s, t ∈ V , such that S is a minimal s,t-separator. A separator S is an inclusion minimal separator, if it does not contain another separator S in G as a proper subset.</p><p>The notions of treewidth and tree decomposition were introduced by Robertson and Seymour <ref type="bibr" target="#b43">[44]</ref> in their work on graph minors.</p><formula xml:id="formula_2">Definition 1. A tree decomposition of a graph G = (V, E) is a pair ({X i | i ∈ I}, T = (I, F)), with {X i | i ∈ I} a family of subsets of V and T a tree, such that • i∈I X i = V ,</formula><p>• for all {v, w} ∈ E, there is an i ∈ I with v, w ∈ X i , and</p><formula xml:id="formula_3">• for all v ∈ V , the set I v = {i ∈ I | v ∈ X i } forms a connected subtree of T . The width of tree decomposition ({X i | i ∈ I}, T = (I, F)) is max i∈I |X i | -1.</formula><p>The treewidth of a graph G, tw(G), is the minimum width among all tree decompositions of G.</p><p>The third condition of tree decomposition can be replaced by the following equivalent condition:</p><formula xml:id="formula_4">• For all i 0 , i 1 , i 2 ∈ I: if i 1 is on the path from i 0 to i 2 in T , then X i 0 ∩ X i 2 ⊆ X i 1 .</formula><p>An example of a graph with a tree decomposition is given in Fig. <ref type="figure" target="#fig_0">1</ref>. We start with a simple lemma, which is a restatement of the Helly property for subtrees of a tree. See also <ref type="bibr" target="#b44">[45]</ref> for a short proof in terms of tree decompositions.</p><p>Lemma 2 <ref type="bibr">(Gavril [46]</ref>). Let W ⊆ V be a clique in G = (V, E), and ({X i | i ∈ I}, T = (I, F)) be a tree decomposition of G. Then there is an i ∈ I with W ⊆ X i . There are several equivalent definitions to the notion of treewidth, some proposed slightly earlier, e.g., the notion of partial k-tree (see <ref type="bibr" target="#b0">[1]</ref>). An overview of several such notions can be found in <ref type="bibr" target="#b34">[35]</ref>. One alternative characterisation is by the use of elimination orderings. On this notion, some heuristics are based. We introduce the characterisation by using equivalent characterisations of chordal graphs, also known as triangulated graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.</head><p>(i) A graph G = (V, E) is chordal, if every cycle in G with length at least four has a chord, i.e., an edge connecting two non-successive vertices in the cycle.</p><formula xml:id="formula_5">(ii) An elimination ordering of a graph G = (V, E) is a bijection f : V → {1, 2, . . . , n}. An elimination ordering f is perfect, if for all v ∈ V , the set of its higher numbered neighbours {w | {v, w} ∈ E ∧ f (w) &gt; f (v)} forms a clique. (iii) A graph G = (V, E)</formula><p>is an intersection graph of subtrees of a tree, if and only if there is a tree T = (I, F), and for each v ∈ V a subtree of T ,</p><formula xml:id="formula_6">T v = (I v , F v ), such that for all v, w ∈ V , v /</formula><p>= w, we have that {v, w} ∈ E, if and only if T v and T w have at least one vertex in common, i.e., I v ∩ I w / = ∅.</p><p>It is known for over 30 years that chordal graphs can be alternatively characterised by perfect elimination orderings or as intersection graphs of subtrees of a tree, see <ref type="bibr" target="#b46">[47]</ref><ref type="bibr" target="#b47">[48]</ref><ref type="bibr" target="#b48">[49]</ref><ref type="bibr" target="#b49">[50]</ref><ref type="bibr" target="#b50">[51]</ref> or <ref type="bibr" target="#b27">[28,</ref><ref type="bibr">Chapter 4]</ref>. Intersection graphs of subtrees of a tree are basically the same structure as tree decompositions, see the proof below. Theorem 4. (See <ref type="bibr" target="#b46">[47]</ref><ref type="bibr" target="#b47">[48]</ref><ref type="bibr" target="#b48">[49]</ref><ref type="bibr" target="#b49">[50]</ref><ref type="bibr" target="#b50">[51]</ref>). Let G = (V, E) be a graph. The following are equivalent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(i) G is chordal. (ii) G has a perfect elimination ordering. (iii) G is the intersection graph of subtrees of a tree.</head><p>(iv) There is a tree decomposition</p><formula xml:id="formula_7">({X i | i ∈ I}, T = (I, F) of G, such that for each i ∈ I, X i is a clique in G.</formula><p>Proof. For equivalence of (i), (ii), and (iii), see <ref type="bibr" target="#b46">[47]</ref><ref type="bibr" target="#b47">[48]</ref><ref type="bibr" target="#b48">[49]</ref><ref type="bibr" target="#b49">[50]</ref><ref type="bibr" target="#b50">[51]</ref> or <ref type="bibr" target="#b27">[28,</ref><ref type="bibr">Chapter 4]</ref>. We give here the easy proof of the folklore result (iii) ⇔ (iv).</p><p>(iii) ⇒ (iv): Suppose we have intersection model tree T = (I, F) with for all v ∈ V , subtree</p><formula xml:id="formula_8">T v with for all v, w ∈ V , v / = w, {v, w} ∈ E ⇔ I v ∩ I w / = ∅. Now one can easily verify that ({X i | i ∈ I}, T = (I, F)) with X i = {v ∈ V | i ∈ I v } is a tree decomposition of G, and for all i ∈ I, X i is a clique. (iv) ⇒ (iii): Let ({X i | i ∈ I}, T = (I, F)) be a tree decomposition of G with for each i ∈ I, X i is a clique in G. Let for all v ∈ V , I v = {i ∈ I | v ∈ X i }.</formula><p>By the definition of tree decomposition I v induces a subtree of T , which we call T v . Now, the collection of T v 's form the intersection model.</p><formula xml:id="formula_9">Definition 5. A graph H = (V H , E H ) is a triangulation of a graph G = (V G , E G ), if H is a chordal graph that is obtained by adding zero or more edges to G (V G = V H , E G ⊆ E H ). A triangulation H = (V, E H ) is a minimal triangulation of G = (V, E G ) if there is no triangulation of G that is a proper subgraph of H, i.e., if there is no set of edges F such that (V, F) is a triangulation of G with F ⊆ E H , F / = E H .</formula><p>The notions for chordal graphs can now be translated to equivalent notions for treewidth. We first give a mechanism that adds edges to a graph to make it chordal, using an elimination ordering. Consider Algorithm The algorithm is known as the Elimination Game, designed in 1961 by Parter <ref type="bibr" target="#b51">[52]</ref>, see also <ref type="bibr" target="#b52">[53]</ref>. See e.g., <ref type="bibr" target="#b53">[54]</ref> for a recent study of the algorithm. We now come to the following well known alternative characterisations of the notion of treewidth. We include the equivalence proofs to show that they quite directly follow from the equivalent characterisations for chordal graphs from Theorem 4. For more background and other notions that are equivalent to treewidth, see the overview in <ref type="bibr" target="#b34">[35]</ref>. Theorem 6. Let G = (V, E) be a graph, and let k ≤ n be a non-negative integer. The following are equivalent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Fill(Graph G, Elimination Ordering π)</head><formula xml:id="formula_10">H = G; for i = 1 to n do Let v = π -1 (i)</formula><p>(i) G has treewidth at most k.</p><p>(ii) G has a triangulation H such that the maximum size of a clique in H is at most k + 1. (iii) There is an elimination ordering π, such that the maximum size of a clique of G + π is at most k + 1. (iv) There is an elimination ordering π, such that no vertex v ∈ V has more than k neighbours with a higher number in π in G + π .</p><p>Proof. (iii) → (iv): Observe that the set consisting of a vertex v and the higher numbered neighbours of v in the filled graph form a clique in the filled graph.</p><formula xml:id="formula_11">(i) ⇒ (ii): Suppose ({X i | i ∈ I}, T = (I, F)) is a tree decomposition of G of width at most k. Let H = (V, E H ) be the graph with E H = {{v, w} | v, w ∈ V , v / = w, ∃i ∈ I : v, w ∈ X i }.</formula><p>(iv) → (iii): Suppose no vertex v ∈ V has more than k neighbours with a higher number in π in the filled graph G + π . Let W be a clique in G + π , and let x be the vertex in W with the smallest number in π. As all vertices in W \{x} are higher numbered neighbours of x in G + π , |W \{x}| ≤ k. Besides algorithms that construct tree decompositions directly, several construct orderings π as in Theorem 6(iv). Such algorithms will be discussed in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Using elimination orderings</head><p>In this section, we look to heuristics for treewidth that are based upon building an elimination ordering. These are based on the equivalence given in Theorem 6, in particular, the characterisation of treewidth by the maximum number of higher numbered neighbours in a filled graph of an elimination ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Tree decomposition construction</head><p>We see that Theorem 6 implies that each permutation of the vertices of a graph gives us a heuristic to upper bound the treewidth of the graph: given such elimination ordering π, we can build the filled graph G + π , and from that the corresponding tree decomposition. Thus, each algorithm that builds permutations of the vertices of a graph can be seen as an upper bound heuristic for treewidth. In this section we discuss a number of such algorithms. Before doing this, we briefly show how one can construct the corresponding tree decomposition directly, given an elimination ordering. Definition 7. Let G = (V, E) be a graph, and v ∈ V be a vertex. Eliminating v is the operation, that adds an edge between each pair of non-adjacent neighbours of v, and then removes v.</p><p>Algorithm 1 (the "Elimination Game"), can also be expressed as follows: for i = 1 to n, we eliminate π -1 (v). As output graph H, we take the graph containing all edges in G and all edges, added during the elimination steps.</p><p>In Algorithm 2, we give a recursive procedure that builds a tree decomposition from a permutation. It is not hard to turn this into an efficient iterative procedure. The following result shows correctness of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 8. Let G = (V, E) be a graph, and π be an elimination ordering of G. Let</head><formula xml:id="formula_12">H = (V, E H ) = G π i be the filled graph of G with respect to G. Suppose V = {v 1 , . . . , v n }, and for all v i ∈ V , π(v i ) = i. Algorithm 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>outputs, when given G and vertex ordering</head><formula xml:id="formula_13">(v 1 , v 2 , . . . , v n ), a tree decomposition ({X v | v ∈ V }, T = (V, F)), such that (i) For all v i ∈ V , X v i is the set of v i and all higher numbered neighbours of v i in H, i.e., X v i = {v i } ∪ {v j | j &gt; i ∧ {v i , v j } ∈ E H }.</formula><p>(ii) The width of the tree decomposition is one smaller than the maximum clique size of H.</p><p>Proof. First we note that G + π can be constructed as follows: take the graph G , obtained by eliminating v 1 ; let π be the elimination ordering of G , obtained from π by removing v 1 ; recursively, build G + π , and then add v 1 and its incident edges to H .</p><p>The result can be obtained by induction on n.</p><formula xml:id="formula_14">The case n = 1 is trivial. Otherwise, as N G (v) is a clique in G , Lemma 2 guarantees that there is an w ∈ V with N G (v 1 ) ⊆ X w . We can take w = v j , j the lowest numbered neighbour of v 1 . As N G (v 1 ) is a clique in G , all vertices in N G (v 1 ) \ {v j } are neighbours of v j in G ,</formula><p>and hence, by induction, we have that</p><formula xml:id="formula_15">N G (v 1 ) ⊆ X v j .</formula><p>We indeed have a tree decomposition of H and of G. Induction shows that for all {v α ,</p><formula xml:id="formula_16">v β } ∈ E H with α &gt; 1, β &gt; 1, there is a bag containing both v α and v β . By construction, v 1 and each vertex v α with {v 1 , v α } ∈ E H belongs to bag X v 1 . Induction shows that for all w ∈ V \ N G [v], I w = {i ∈ V | w ∈ X i } forms a connected subtree of the tree T. For w ∈ N G (v), I w consists of</formula><p>a subtree of T that contains v j and of the new bag v 1 , which is adjacent in T to v j ; thus this again forms a connected subtree of T . Finally, v 1 belongs only to bag X v 1 , and hence I v 1 forms a connected subtree of T of only one vertex.</p><p>It is not hard to see that the two stated conditions hold. For instance, each clique W is a subset of the bag of the lowest numbered vertex in W . So, we have shown the result with induction.</p><formula xml:id="formula_17">Algorithm 2 PermutationToTreeDecomposition(Graph G = (V, E), VertexList (v 1 , v 2 , . . . , v n )) if n = 1 then Return a tree decomposition with one bag X v 1 = {v 1 }. end if Compute the graph G = (V , E ) obtained from G by eliminating v 1 . Call PermutationToTreeDecomposition(G , (v 2 , v 3 , . . . , v n )) recursively, and let ({X w | w ∈ V }, T = (V , F</formula><p>)) be the returned tree decomposition.</p><p>Let v j be the lowest numbered neighbour of v 1 , i.e., j</p><formula xml:id="formula_18">= min{i | {v 1 , v i } ∈ E}. Construct a bag X v 1 = N G [v 1 ]. return ({X v | v ∈ V }, T = (V, F)) with F = F ∪ {v 1 , v j }.</formula><p>The discussion above gives us a simple general format of several treewidth heuristics. First, use some algorithm to build an ordering of the vertices of the graph, and then convert it to a tree decomposition of it by Algorithm 2. The width is the maximum number of higher numbered neighbours of a vertex in the corresponding filled graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Chordal graph recognition heuristics</head><p>There are several vertex ordering algorithms that have been used for this purpose. Some of these are based upon algorithms that give a perfect elimination ordering when the input graph is a chordal graph, and were originally proposed as algorithms to recognise chordal graphs. One of these is the Maximum Cardinality Search algorithm by Tarjan and Yannakakis <ref type="bibr" target="#b54">[55]</ref>. In the Maximum Cardinality Search algorithm, a vertex ordering is built from right to left, i.e., first the highest numbered vertex is chosen, then the one-but-highest numbered vertex, etc. An arbitrary vertex is chosen as v n , and then, at each step, the next vertex chosen must be one which is adjacent to an as large as possible number of already chosen vertices. In our experiments, we call this algorithm MCS-P. A variant of this algorithm, MCS-M, has been proposed by Berry et al. <ref type="bibr" target="#b55">[56,</ref><ref type="bibr" target="#b56">57]</ref>. MCS-M has a slightly more complicated criterion to select the next vertex. Another algorithm to recognise chordal graphs is the Lexicographic Breadth First Search algorithm by Rose et al. <ref type="bibr" target="#b49">[50]</ref>. This algorithm also comes in two flavours: LEX-P and LEX-M. LEX-P and LEX-M also generate orderings of the vertices from right to left. MCS-P and LEX-P are faster than their "M-counterparts" and guarantee to yield a perfect elimination scheme when the input graph is chordal. MCS-M and LEX-M also guarantee this, but do more: also when the input graph is not chordal, they produce a minimal elimination ordering, i.e., when we apply Algorithm 1 to the ordering, it yields a minimal triangulation of the input graph. Alternatively, fill edges an be added on the fly when generating the ordering. Villanger <ref type="bibr" target="#b57">[58]</ref> has shown that MCS-M and LEX-M generate the same set of (minimal) triangulations. Further generalisations of these algorithms have been considered by Berry et al. <ref type="bibr" target="#b58">[59]</ref>.</p><p>For the recognition of chordal graphs, the result is independent of the first chosen vertex v n . For computing good tree decompositions the result heavily depends on this vertex and so it is straightforward to run these algorithms with all potential start vertices once at the cost of increasing the complexity by a factor O(n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1</head><p>Greedy algorithms for constructing an elimination ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm</head><p>Selection of next vertex</p><formula xml:id="formula_19">GreedyDegree (MinimumDegree) v = arg min u δ H (u) GreedyFillIn v = arg min u φ H (u) GreedyDegree+FillIn v = arg min u δ H (u) + φ H (u) GreedySparsestSubgraph v = arg min u φ H (u) -δ H (u) GreedyFillInDegree v = arg min u δ H (u) + 1 n 2 φ H (u) GreedyDegreeFillIn v = arg min u φ H (u) + 1 n δ H (u)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Greedy triangulation algorithms</head><p>Other heuristics for treewidth build the ordering together with adding fill edges. Algorithm 3 shows the general scheme to build elimination orderings greedily. For each different criterion X, we have a different treewidth heuristic. We only give the code to build the ordering; the corresponding filled graphs and tree decompositions can be made as in Algorithms 1 and 2.</p><formula xml:id="formula_20">Algorithm 3 GreedyX(Graph G = (V, E)) H = G; for i = 1 to n do</formula><p>Choose a vertex v from H according to criterion X.</p><p>Let v be the ith vertex in ordering π.</p><p>Let H be the graph, obtained by eliminating v from H (make the neighbourhood of v a clique and then remove v.) end for return ordering π.</p><p>Using different criteria X gives us different algorithms to build elimination orderings, and hence different heuristics for treewidth. A very simple criterion, and one that performs often quite well in practice is to select a vertex of smallest degree in H. This heuristic is well known as the Minimum Degree heuristic; for consistency with our other terms, we call it here the GreedyDegree heuristic. This heuristic was designed by Markowitz in 1957 in the context of sparse matrix computations <ref type="bibr" target="#b59">[60]</ref>, and is in use by many linear algebra software packages. Many studies to speed up this heuristic have been made; as a starting point for reading, consult e.g., <ref type="bibr" target="#b60">[61]</ref>. Slightly slower than GreedyDegree, but with on average slightly better bounds for the treewidth in practice is the GreedyFillIn heuristic (see <ref type="bibr">Section 6 and [39]</ref>). In this case, we choose a vertex that causes the smallest number of fill edges, i.e., a vertex that has the smallest number of pairs of non-adjacent neighbours. GreedyDegree is motivated by the fact that we create a bag of size the degree of the chosen vertex plus one, GreedyFillIn by a wish not to create many new edges, as these may cause other vertices to have high degree when eliminated.</p><p>GreedyDegree and GreedyFillIn are very simple heuristics, that appear to perform very well for many instances obtained from existing applications. For our computational evaluation in Section 6, we propose in Table <ref type="table">1</ref> a few alternative greedy approaches that we have considered (here φ H (v) denotes the number of fill edges by elimination v in H whereas δ H (v)</p><formula xml:id="formula_21">denotes the degree of v in H).</formula><p>Recently, new criteria have been proposed and investigated for the selection of vertices. The new treewidth heuristics thus obtained give in some cases improvements upon the existing heuristics.</p><p>One such criterion was proposed by Clautiaux et al. <ref type="bibr" target="#b61">[62,</ref><ref type="bibr" target="#b62">63]</ref>. Here, we compute for each vertex v first a lower bound on the treewidth of the graph obtained from H by eliminating v. The vertex is chosen which has the smallest value for the sum of twice this lower bound plus the degree in H.</p><p>Inspired by results on preprocessing graphs for treewidth computations, Bachoore and Bodlaender <ref type="bibr" target="#b63">[64]</ref> investigated several other selection criteria. To describe these, we need a few new notions.</p><formula xml:id="formula_22">Definition 9. A vertex v ∈ V is simplicial in graph G = (V, E), if its set of neighbours N G (v) is a clique in G. A vertex v ∈ V is almost simplicial, if it has a neighbour w, such that the set of neighbours except w, N G (v)\{w} is a clique in G.</formula><p>If v is simplicial in G = (V, E), then there exists an elimination ordering of G that starts with v and gives the optimal treewidth, i.e., for which the maximum clique size of its filled graph equals the treewidth of G. Thus, if v is simplicial, it seems a good choice to select v as the first vertex of the elimination ordering. Such an elimination ordering also exists, when v is almost simplicial and the degree of v is at most the treewidth of G <ref type="bibr" target="#b64">[65]</ref>. Now, if we have a lower bound low on the treewidth of G, then we can start the ordering with an almost simplicial vertex v whose degree is at most low.</p><p>The Enhanced MinimumFillIn algorithm of <ref type="bibr" target="#b63">[64]</ref> uses a lower bound low on the treewidth of the input graph G, and works with the following selection criterion: if there is a simplicial vertex, or an almost simplicial vertex of degree at most low, then that vertex is chosen, otherwise a vertex with smallest number of fill edges (as in the GreedyFillIn heuristic) is chosen. The other heuristics from <ref type="bibr" target="#b63">[64]</ref> also start with selecting simplicial or low-degree almost simplicial vertices, but then use more complicated selection criteria, based upon the degree, fill, the minimum number of edges that must be added to make the vertex almost simplicial, and/or the ratio of some of these parameters.</p><p>Cano and Moral designed and evaluated several algorithms of a similar type for a related problem <ref type="bibr" target="#b65">[66]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Local search and genetic algorithms</head><p>Local search methods, like simulated annealing or tabu search, appear to give for many optimisation problems heuristics that give solutions close to optimal, but that use much time. A few studies have been carried out to use local search methods for computing the treewidth or computing a related graph parameter.</p><p>In particular, we discuss here the tabu search algorithm for treewidth by Clautiaux et al. <ref type="bibr" target="#b62">[63]</ref>. We do not give full details here. The main idea of tabu search is the following: we start with an initial solution to the problem, and then step from this solution to a 'neighbouring' solution, i.e., one that is obtained from the first solution by performing a small change. Usually, one steps to the neighbouring solution with smallest cost. This process is repeated for some time, and the best solution found is reported. In order to avoid cycling among a small set of solutions, tabu search keeps a list of the last α encountered solutions during the search, and we forbid the algorithm to step to a solution that is already on the list.</p><p>In <ref type="bibr" target="#b62">[63]</ref>, Clautiaux et al. show how the tabu search paradigm can be successfully applied for approximating treewidth. The set of solutions is the set of elimination orderings of G, similar as for the heuristics discussed earlier in this section. While we want to optimise the corresponding width (the maximum number of higher numbered neighbours of a vertex in the filled graph of the elimination ordering), it is not wise to use this number as cost for the tabu search, as many neighbouring solutions will have the same width, and hence, the search is not well directed towards improvements. So, a more complicated cost function is used. For an elimination ordering π, its cost is</p><formula xml:id="formula_23">w π • n 2 + v∈V |N + π (v)| 2</formula><p>where w π is the treewidth corresponding to π, and N + π (v) is the set of higher numbered neighbours of v in the filled graph corresponding to π. In this way, orderings that give tree decompositions with few large bags are preferred above orderings with the same width but with more large bags.</p><p>A simplified variant of the neighbourhood structure from <ref type="bibr" target="#b62">[63]</ref> is the following: let two elimination orderings be neighbours if one can be obtained from the other by moving one vertex to a different position in the ordering. In this way, each solution has Θ(n 2 ) neighbours.</p><p>Clautiaux et al. use less neighbours per vertex in their neighbourhood structure. First, let us observe that certain changes of the elimination ordering do not change the corresponding triangulations (hence width).</p><p>Lemma 10 (Clautiaux et al. <ref type="bibr" target="#b62">[63]</ref>). Let π, π be two elimination orderings of G = (V, E), where π is obtained from π by reversing the order of two successive vertices v, w. Let H = G + π , and H = G + π . If v and w are not adjacent in H, then H = H .</p><p>Heggernes and Villanger <ref type="bibr" target="#b66">[67]</ref> generalised this result as follows. Two vertices v and w are said to be indistinguishable in an ordering π, if, after eliminating the vertices with order 1, . . . , min{π(v), π(w)}, v and w are incident and have the same neighbourhood. It is not hard to see that a version of Lemma 10 where v and w are indistinguishable instead of non-adjacent also holds. Heggernes and Villanger <ref type="bibr" target="#b66">[67]</ref> show that these are basically the only swaps we can make.</p><p>Theorem 11 <ref type="bibr">(Heggernes and Villanger [67]</ref>). Let π and π be orderings of the vertices of G.</p><formula xml:id="formula_24">G + π = G + π , if</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and only if α can be obtained from β by repeatedly swapping pairs of consecutive non-adjacent or indistinguishable vertices.</head><p>Using Lemma 10 and induction or Theorem 11, we see that when we take a permutation ordering π, and move a vertex v to a different position in π, such that there are no neighbours to v in π between the original and new position of v, then the filled graph does not change. As equal filled graphs correspond to basically the same tree decompositions, moves in the search where the filled graph does not change are highly undesirable. In <ref type="bibr" target="#b62">[63]</ref>, a vertex is moved to the position just after its first higher numbered neighbour in the filled graph, or to the position just before the last lower numbered neighbour in the filled graph. In this way, each solution / elimination ordering has at most 2n neighbouring solutions (each vertex can moved to at most two positions). See <ref type="bibr" target="#b62">[63]</ref> for further details.</p><p>Kjaerulff <ref type="bibr" target="#b67">[68]</ref> has applied simulated annealing to solve a problem related to treewidth: a different cost measure obtained from the use of tree decomposition for the inference problem for probabilistic networks is used here. Larrañaha et al. <ref type="bibr" target="#b68">[69]</ref> have used genetic algorithms for treewidth. Both Kjaerulff <ref type="bibr" target="#b67">[68]</ref> and Larrañaha et al. <ref type="bibr" target="#b68">[69]</ref> use the elimination ordering representation, and two orderings neighbouring each other if they can be obtained with small changes like the moving of a vertex or exchange of two vertices; in <ref type="bibr" target="#b68">[69]</ref>, also a mechanism is used to make a cross-over between two elimination orderings.</p><p>Heggernes and Villanger <ref type="bibr" target="#b66">[67]</ref> designed k-Opt type local search algorithms, based upon Theorem 11 for the Minimum Fill problem. A study whether the approach of [67] also helps to obtain better treewidth bounds has not yet been carried out.</p><p>Recently, further local search algorithms have been developed, either operating on the elimination ordering <ref type="bibr" target="#b69">[70]</ref> or directly on the tree decomposition <ref type="bibr" target="#b70">[71]</ref>. Key idea in both approaches is to exchange the chord in cycles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Turning exact methods into heuristics</head><p>Several exact algorithms for computing the treewidth can be turned into a heuristic algorithm -one that does not necessarily give the exact answers, but uses less time. One such example is a branch and bound algorithm. Gogate and Dechter <ref type="bibr" target="#b71">[72]</ref> give a branch and bound algorithm to compute the treewidth. An early halt of the algorithm (e.g., after some fixed amount of time has passed) gives an approximate solution. Dynamic programming algorithms also can be turned into a heuristic by dropping some elements from tables. This procedure has been suggested and evaluated in <ref type="bibr" target="#b72">[73]</ref>. We plan to report on these and other exact approaches in <ref type="bibr" target="#b15">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Using separators</head><p>In this section, we look at a number of heuristics that build a tree decomposition by finding a number of separators in the graph. There is a group of heuristics that follow the same strategy, which we term 'splitting into components'; these are discussed in Section 4.1. Two other heuristics that use separators are discussed in Sections 4.2 and 4.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">The splitting into components strategy</head><p>Several heuristics for treewidth use the same global strategy. We give a general description of the main scheme, but will not go into details for most of the separate heuristics.</p><p>The main idea is as follows: the graph is split with the help of a separator; recursively, we find a tree decomposition for each part of the graph, and then these tree decompositions are 'glued' together. The heuristics of this type have a general advantage above e.g., those based on elimination orderings: they come with guarantees on the treewidth obtained by the heuristic. They also have disadvantages: they are significantly more complex, significantly slower, and often give bounds that are higher than those of simpler algorithms.</p><p>Each of <ref type="bibr" target="#b73">[74]</ref><ref type="bibr" target="#b74">[75]</ref><ref type="bibr" target="#b75">[76]</ref><ref type="bibr" target="#b76">[77]</ref><ref type="bibr" target="#b77">[78]</ref><ref type="bibr" target="#b78">[79]</ref><ref type="bibr" target="#b79">[80]</ref><ref type="bibr" target="#b80">[81]</ref>contains a heuristic of this type. See also <ref type="bibr" target="#b26">[27,</ref><ref type="bibr">Chapter 10.5]</ref>. The method can be traced back to an algorithm by Robertson and Seymour in <ref type="bibr" target="#b81">[82]</ref>. This algorithm either decides that the branchwidth is larger than k, or finds a branch decomposition of width at most 3k; the algorithm uses time quadratic in n but exponential in k. Branchwidth and treewidth are closely related, and a branch decomposition can be easily converted to a tree decomposition. The algorithm given below is basically the algorithm from <ref type="bibr" target="#b81">[82]</ref>, but stated in terms of treewidth and tree decompositions instead of branchwidth and branch decompositions.</p><p>Let S ⊂ V be a separator of G = (V, E). Without loss of generality, we partition V \S in vertex sets A and B such that S is a a,b-separator for all a ∈ A, b ∈ B. We say that S separates A from B in G. For proofs of results similar to Lemma 12, see e.g., <ref type="bibr" target="#b77">[78,</ref><ref type="bibr" target="#b82">83,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b83">84,</ref><ref type="bibr" target="#b43">44]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 12. Let G = (V, E) be a graph of treewidth at most k, and let W ⊆ V be a set of vertices. There is a partition of V into three sets S, A, B, such that |S| ≤</head><formula xml:id="formula_25">k + 1, |A ∩ W | ≤ 2 3 |W|, |B ∩ W | ≤ 2 3 |W|</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, and S separates A from B.</head><p>Suppose FindBalancedPartition is a procedure, that given a graph G = (V, E) and a set W ⊆ V , either gives a partition of V into three sets S, A, B, fulfilling the conditions of Lemma 12, represented by the 4-tuple (true, S, A, B), or determines that such a partition does not exist, represented by (false, -,-,-). There is an implementation of FindBalancedPartition that takes  <ref type="bibr" target="#b24">[25]</ref>).</p><formula xml:id="formula_26">O(3 |W| • k • (n + m)</formula><p>Using this procedure FindBalancedPartition, Algorithm 4 describes the general scheme of this type of treewidth heuristic. It returns a tree decomposition of G with a specific bag identified as root node. Fig. <ref type="figure" target="#fig_1">2</ref> illustrates the construction of the algorithm. The step where we added a vertex from V \W to S in case (A = ∅ or B = ∅) and S ⊆ W is needed to prevent the possibility of a not terminating recursive program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 13.</head><p>(i) Let G = (V, E) be a graph with treewidth at most k, and suppose |W| ≤ 3k + 3. The procedure BuildTreeDecomposition (G, W ) outputs a tree decomposition of G of width at most 4k + 3, such that a root bag of the tree decomposition contains all vertices in W . (ii) If procedure BuildTreeDecomposition(G, W ) outputs that the treewidth is larger than k, then the treewidth of G is at least k + 1. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4 BuildTreeDecomposition(Graph</head><formula xml:id="formula_27">G = (V, E), VertexSet W ) if W = V then</formula><p>return A tree decomposition with one bag containing all vertices end if</p><formula xml:id="formula_28">(t, S, A, B) = FindBalancedPartition(G = (V, E), W ) if t ≡ false then return Reject: treewidth is larger than k end if if (A = ∅ or B = ∅) and S ⊆ W then Add a vertex from V \W to S end if Run BuildTreeDecomposition(G[S ∪ A], S ∪ (W ∩ A)) Run BuildTreeDecomposition(G[S ∪ B], S ∪ (W ∩ B))</formula><p>if at least one of these runs rejects then return Reject: treewidth is larger than k end if Take the disjoint union of the two recursively obtained tree decompositions Add a new bag x containing the vertices in S ∪ W Make x adjacent to the root nodes of the two recursively obtained tree decompositions return The just computed tree decomposition of G with x as root.</p><p>Proof. (i) First note that the algorithm terminates: either the graph in the first argument of a recursive call has fewer vertices, or it has the same number of vertices but the number of vertices not belonging to the set of the second argument has decreased. Now, to proof the result, we use induction on the depth of the recursion. If we return a tree decomposition with one bag, the result clearly holds.</p><formula xml:id="formula_29">Suppose W / = V . We have that |W ∩ A| ≤ 2 3 |W| ≤ 2k + 2. So, |S ∪ (W ∩ A)| ≤ 3k + 3, and similarly, |S ∪ (W ∩ B)| ≤ 3k + 3.</formula><p>With induction, we have that the recursive calls yield tree decompositions of G[S ∪ A] and G[S ∪ B] of width at most 4k + 3, whose root bags contain respectively the vertices in S ∪ (W ∩ A) and S ∪ (W ∩ B). We can now verify that the algorithm indeed outputs a tree decomposition of G of width at most 4k + 3 whose root bag contains W . It is easy to observe that each vertex in V belongs to at least one bag.</p><p>Consider an edge {v, w} ∈ E. By the assumption on partitions, we have that v, w ∈ S ∪ A or v, w ∈ S ∪ B. In the former case, {v, w} is an edge in G[S ∪ A], and hence there is a bag in the tree decomposition of G[S ∪ A] containing both v and w; the latter case is similar.</p><p>Consider a vertex v ∈ V . Consider the set of bags containing v, I v . If v ∈ V \(S ∪ A ∪ W ) then v only appears in bags in the tree decomposition of G[V \B], and thus I v forms a subtree. Similarly when v ∈ V \(S ∪ B ∪ W ). The remaining case is that v ∈ (S ∪ A ∪ W ) ∩ (S ∪ B ∪ W ) = S ∪ W . v either belongs to no bags in the tree decomposition of G[S ∪ A] or a connected set of bags that includes the root bag; similar, it belongs to either no bags in the tree decomposition of G[S ∪ B] or a connected set of bags that includes the root bag; and it belongs to bag x. Thus, these bags form a connected subtree.</p><p>We have now verified that the algorithm outputs a tree decomposition of G. Clearly, the root bag contains W . The maximum size of a bag is at most 4k + 4, by the assumptions on the widths of the recursively obtained tree decompositions and the fact that |S ∪ W | ≤ 4k + 4.</p><p>(ii) If the algorithm outputs that the treewidth is more than k, then the graph at hand has treewidth more than k by Lemma 12. As each recursive call works with an induced subgraph, and the treewidth cannot increase by taking induced subgraphs, the treewidth of the original input graph G is also larger than k.</p><p>Several variations and improvements on the method are possible. For exmple, instead of working with separators that partition into two parts, one can also work with separators which partition into more parts, often guaranteeing that each part contains at most half of the vertices of W (and thus getting better treewidth bounds). Thus, different algorithms can vary in quality of obtained approximations and running times. For some algorithms in this vein, see e.g., <ref type="bibr" target="#b73">[74]</ref><ref type="bibr" target="#b74">[75]</ref><ref type="bibr" target="#b75">[76]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">The Minimum Separating Vertex Sets heuristic</head><p>The Minimum Separating Vertex Sets (MSVS) heuristic of Koster <ref type="bibr" target="#b84">[85]</ref> (see also <ref type="bibr" target="#b2">[3]</ref>) refines a tree decomposition by replacing one bag with multiple smaller bags with the help of minimum separators, also called Minimum Separating Vertex Sets, hence the name of this heuristic. In its original version, it starts with a trivial tree decomposition (i.e., a tree decomposition with one bag X i = V ) but the general scheme can be applied to any tree decomposition, is described in Algorithm 5, and illustrated in Fig. <ref type="figure" target="#fig_2">3</ref>. Unless all X i induce complete graphs, the tree decomposition can be refined to one with smaller width; this process is repeated until the nodes of maximum cardinality in the tree decomposition cannot be refined anymore. The refinement step consists of splitting a bag X i into a number of bags, each of smaller cardinality.</p><formula xml:id="formula_30">Algorithm 5 RefineTreeDecomposition(Graph G = (V, E), TreeDecomposition ({X i , i ∈ I}, T = (I, F))) while ∃i ∈ I such that |X i | maximal and G[X i ] does not induce a clique do Construct graph H i with vertex set X i and edge set {{v, w} ∈ X i × X i |{v, w} ∈ E ∨ ∃j = i : v, w ∈ X j } Compute minimum separator S ⊂ X i in H i ; let W 1 , . . . , W r define the r connected components of H i [X i \ S] Set I = I \ {i} ∪ {i 0 , . . . , i r } Set X j = X j for all j = i, X i 0 = S, X i q = W q ∪ S for q = 1, . . . , r Set F = F \ {{i, j}|j ∈ N T (i)} ∪ {{i 0 , i q }|q = 1, . . . , r} ∪ {{j, i q j }|j ∈ N T (i)} where q j ∈ {1, . . . , r} such that X i ∩ X j ⊆ W q j ∪ S end while return Tree decomposition ({X j , j ∈ I }, T = (I , F )).</formula><p>Suppose we have a tree decomposition ({X i | i ∈ I}, T = (I, F)) of G = (V, E) and we want to refine bag X i , i ∈ I. This is done by first building an auxiliary graph H i , next finding a minimum separator S in H i , and finally adapting the tree decomposition as dictated by S, as described below.</p><p>H i is a graph with vertex set X i . For each pair of vertices v, w ∈ X i , v / = w, we take an edge {v, w} in H i , if and only if v and w are adjacent in G or there is a node j / = i with v, w ∈ X j .</p><p>The second step is finding a minimum separator in H i . Finding a minimum separator in a graph with n vertices, m edges, can be done in O(max{k 3 • m, k • n • m}) time, with k the size of the minimum separator by using network flow techniques, see e.g., <ref type="bibr" target="#b24">[25,</ref><ref type="bibr">Section 6.2]</ref>. If H i would be a clique, then we cannot refine i and therefore this case is not considered.</p><p>Now, if we have separator S in H i , we can refine X i as follows. The graph H i [X i \S] has at least two connected components, say these connected components have vertex sets W 1 , . . . , W r . The refinement of X i takes place as follows. Each node j / = i is kept, setting X j = X j . i is replaced by r + 1 nodes i 0 , . . . , i r , with X i 0 = S, and for 1 ≤ q ≤ r, X i q = S ∪ W q . In the new tree T , we keep all edges between nodes / = i. Then we make i 0 adjacent to each i q , 1 ≤ q ≤ r. Each neighbour j of i is made adjacent to one of the nodes i q , in the following way. Consider Y j = X i ∩ X j . Note that Y j is a clique in H i . Thus, there cannot be two different connected components of H i [X i \ S] that both contain vertices of Y j , and hence there must be a q j , 1 ≤ q j ≤ r, such that Y j ⊆ W q j ∪ S. Make node j adjacent to node i q j in T. Let (T = (I , F ), {X j : j ∈ I }) be the resulting structure, which is a tree decomposition by the following lemma.</p><p>Lemma 14. Let (T = (I , F ), {X j : j ∈ I }) be obtained from applying a refinement step to node i ∈ I in a tree decomposition (T = (I, F), {X j : j ∈ I}) of graph G = (V, E). Then (T = (I , F ), {X j : j ∈ I }) is a tree decomposition of G.</p><p>Proof. It is trivial that the first of the three conditions of tree decomposition is fulfilled. Consider an edge {v, w} ∈ E. There is a node j ∈ I with v, w ∈ X j . If j / = i, then v, w ∈ X j also after the refinement step. Otherwise, {v, w} is an edge in</p><formula xml:id="formula_31">H i . If v, w ∈ S, then v, w ∈ X i 0 . If v ∈ W q , 1 ≤ q ≤ r</formula><p>, then w ∈ S ∪ W q , so v, w ∈ X i q ; similarly when w ∈ W q . We have now verified the second requirement of tree decompositions.</p><p>Consider a vertex v ∈ V , and the sets of nodes</p><formula xml:id="formula_32">I v = {j ∈ I : v ∈ X j }, I v = {j ∈ I : v ∈ X j }. If v ∈ X i , then I v = I v , hence I v is connected in T . If v ∈ S, then I v = I v \ {i} ∪</formula><p>{i 0 , . . . , i r }, and one easily sees that the connectedness of I v follows from the connectedness of I v . If v ∈ W q , 1 ≤ q ≤ r, then for every neighbour j of i with v ∈ X j , we have that j is adjacent to i q in T . As</p><formula xml:id="formula_33">I v = I v \ {i} ∪ {i q }, connectedness of I v again follows. We can now conclude that ({X j : j ∈ I }, T = (I , F )) is indeed a tree decomposition of G.</formula><p>Note that each of X i 0 , …, X i r is of smaller cardinality than X i . A refinement step is illustrated in Fig. <ref type="figure" target="#fig_2">3</ref>. If H i is a complete graph, then it has no separating vertex set. If H i is not complete, then it has: when v and w are not adjacent in H i , then X i \ {v, w} is a separating vertex set of H i . Thus, as long as there is a node i ∈ I in the tree decomposition of maximum cardinality with H i not a complete graph, the refinement step can be applied. When no refinements are possible, the MSVS heuristic stops.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Completing minimal separators</head><p>We can look at the MSVS heuristic in a different way, and arrive at a heuristic that builds a minimal triangulation of a graph by adding edges to vertices in minimal separators.</p><p>Consider again the MSVS heuristic, and the triangulation H of G obtained by making each set X i in the final tree decomposition a clique. Consider a tree decomposition ({X i | i ∈ I}, T = (I, F)) that is used in an intermediate step during the algorithm.</p><p>For some pairs of vertices v, w ∈ V , we can deduce that they must form an edge in H, namely when {v, w} is already an edge in G, or if there are at least two bags X i , X j , with v, w ∈ X i and v, w ∈ X j . Say G is the graph, formed by these edges, i.e., {v, w} is an edge in G , if it is an edge in G, or there are at least two bags that contain both v and w. In one refinement step, we precisely add those edges to G that turn S into a clique. Following terminology of <ref type="bibr" target="#b76">[77]</ref>, let completing a vertex set S in a graph G be the operation that turns S into a clique, i.e., for each pair of vertices v, w, v / = w in S, we add an edge from v to w to G, unless v and w were already adjacent. Thus, in the MSVS heuristic, we repeatedly build a graph H i , and then complement a minimum size separator in H i . In <ref type="bibr" target="#b76">[77]</ref>, a heuristic is described that works slightly differently: we now complement a minimal or minimum size separator in G .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 6 MinimalTriangulation(Graph</head><formula xml:id="formula_34">G = (V, E)) G = G;</formula><p>while G is not a chordal graph do Choose a minimal separator S in G that is not a clique.</p><p>Let G be the graph, obtained by completing S in G . end while return G .</p><p>In Algorithm 6 we see the main scheme of Bouchitté et al. <ref type="bibr" target="#b76">[77]</ref>. In a refinement, we always choose a set S of minimum size that is not a clique. In <ref type="bibr" target="#b76">[77]</ref>, it is discussed how the algorithm can be carried out, and implemented to run in O(n 5.5 ) time. In <ref type="bibr" target="#b76">[77]</ref>, it is shown that this algorithm approximates the treewidth within a multiplicative factor of 8a, where a is the asteroidal number of G. No experimental evaluation of this algorithm is known to us.</p><p>The similarity between the MinimalTriangulation heuristic and the MSVS heuristic can be stressed further by observing that each separator in the graph H i as built by the MSVS heuristic is also a separator in G .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Postprocessing</head><p>For several treewidth heuristics, it is the case that the triangulation that corresponds to the tree decomposition (compare Theorem 6) is not always a minimal triangulation. In that case, it may be useful to apply a postprocessing step, using a subroutine that solves the triangulation minimisation problem.</p><p>In the triangulation minimisation problem, we are given a graph G = (V, E) and a triangulation H = (V, F) of G, and we look for a minimal triangulation G = (V, E ) of G, with the property that G is a subgraph of H, i.e., G is a chordal graph and E ⊆ E ⊆ F. There are several algorithms known that solve the triangulation minimisation problem in O(nm) time. In our experiments, we used the algorithm of Blair et al. <ref type="bibr" target="#b85">[86]</ref>. Other algorithms that solve this problem can be found in <ref type="bibr" target="#b86">[87]</ref><ref type="bibr" target="#b87">[88]</ref><ref type="bibr" target="#b88">[89]</ref><ref type="bibr" target="#b89">[90]</ref>. See also <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b90">91,</ref><ref type="bibr" target="#b91">92]</ref>, and the overview paper by Heggernes <ref type="bibr" target="#b92">[93]</ref>. Recently, Heggernes et al. <ref type="bibr" target="#b93">[94]</ref> found a faster algorithm for the triangulation minimisation problem.</p><p>Using triangulation minimisation, we can do the following: we run some heuristic that produces tree decompositions. The tree decomposition is converted to a triangulation H of the input graph G. Given G and H, we find a minimal triangulation G of G that is a subgraph of H using an algorithm for the triangulation minimisation problem. This minimal triangulation is converted back to a tree decomposition of G.</p><p>This postprocessing step can never increase the treewidth, but will for some instances decrease it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Computational evaluation</head><p>In this section, we present a computational evaluation of a selection of the algorithms presented. We in particular focus on the variants of GreedyX as those turn out to provide the best value for money (i.e., time). First, we discuss the experimental setup, and the next the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Experimental setup</head><p>All algorithms that have been evaluated have been implemented in C++ with use of the Boost Graph Library <ref type="bibr" target="#b94">[95]</ref>. For most of the presented algorithms, computational studies have been presented in the corresponding publications. Typically the algorithms have been tested on a number of graphs originating from a variety of applications. In addition, sometimes graphs with a well-known combinatorial structure like the Petersen graph have been considered. Although we strongly agree that the performance of the upper bound algorithms on graphs originating from applications is of utmost importance, we follow another approach in the paper. For most graphs from applications it is difficult to determine the optimal width, and so the quality of the algorithms is masked by this fact.</p><p>To evaluate a selection of the upper bound algorithms on their scientific merits, we adapted the procedure proposed by Shoikhet and Geiger <ref type="bibr" target="#b95">[96]</ref> and test the algorithms on randomly generated partial-k-trees. A k-tree is a chordal graph with the property that there exists a perfect elimination ordering π with |N + π (v)| = min{k, n -π(v)} for all v ∈ V (note that n -π(v) is the degree of the last k vertices in the ordering). Thus, a k-tree has exactly k(k -1)/2 + k(nk) = knk(k + 1)/2 edges. A partial-k-tree G is a graph for which there exist a k-tree supergraph. Hence, the treewidth of a partial-k-tree is at most k. If we in addition can guarantee that the treewidth of a randomly generated partial-k-tree is at least k, the treewidth equals k and we have a good basis to compare upper bound algorithms.</p><p>Randomly generated partial-k-trees are characterised by three parameters: the number of vertices n, the value k, and the number of edges missing to be a k-tree as percentage p of the number of k-tree edges. All combinations of n ∈ {100, 200, 500, 1000}, k ∈ {10, 20} and p ∈ {30, 40, 50} have been considered. For every choice (n, k, p) of the parameters, we generate 50 instances by first constructing a k-tree and then removing randomly p% of the edges (hence, the total number of graphs is 1200).</p><p>To assure that the treewidth of a randomly generated partial-k-tree is at least k, we apply the maximum minimum degree heuristic for the contraction degeneracy lower bound <ref type="bibr" target="#b96">[97]</ref>. For the above parameter choices, this lower bound matches k without exception.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Comparison of greedy algorithms</head><p>In Table <ref type="table">1</ref>, a number of algorithms to construct an elimination ordering greedily have been presented. Experiments revealed that the GreedySparsestSubgraph is not competitive. The idea to find the sparsest subgraph might be attractive on first sight but implies that we have a preference to select vertices of high degree as long as the fill is relatively low for those. The degree however will determine the width of the tree decomposition in the end and thus high degree vertices are not a good choice in this respect. Therefore, we leave this algorithm out of our further discussion.</p><p>For the variants GreedyFillInDegree and GreedyDegreeFillIn (of respectively GreedyDegree and GreedyFillIn) where a second criterion is used as tie breaker, the differences with the algorithms without tie breaker turn out to marginal (slightly better in most, but not all cases). Therefore we focus on the algorithms without tie breaker in the sequel. Fig. <ref type="figure" target="#fig_3">4</ref> shows the average width obtained with the algorithms GreedyFillIn, GreedyDegree, and GreedyDegree+FillIn for the different parameter settings. In addition, the results of the postprocessing step for two of the algorithms are shown. The postprocessing step did not have any effect on the results of the GreedyDegree algorithm. In fact, the width could not be improved for a single instance (the number of fill edges could be reduced in a few cases and hence the orderings are not providing minimal triangulations in general). The distribution of the width is shown in Fig. <ref type="figure" target="#fig_4">5a</ref>.</p><p>The figures show that GreedyFillIn is outperformed by GreedyDegree, but that after triangulation minimisation, the better results are achieved by GreedyFillIn. The combination of GreedyFillIn and GreedyDegree in GreedyDegree+FillInturns  out to be competitive and for k = 20 slightly better than GreedyDegree. Adding triangulation minimisation to this algorithm results in results that are similar to GreedyFillIn with triangulation minimisation.</p><p>Besides the quality of the results, the computation times play an important role by selecting the best algorithm. Fig. <ref type="figure" target="#fig_4">5b</ref> shows a scatter plot of the normalised average width values and the normalised average computation times. The normalisation is done individually for every triple (n, k, p) with respect to the smallest computation time and the best average width. The plot shows that GreedyDegree is the clear winner in computation time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Chordal graph recognition heuristics</head><p>One might think that the triangulation recognition heuristics like Maximum Cardinality Search (MCS/MCS-M) and Lexicographic Breadth First Search (LEX-P/LEX-M) should perform better than the greedy algorithms as they incorporate more graph theoretical knowledge. The truth is quite contrary. Both for graphs of practical applications and the randomly generated partial-k-trees, the results for the adapted recognition heuristics are not even close to those of the greedy algorithms, regardless the starting vertex selected. To illustrate this, we performed two experiments.</p><p>First, we took one of the randomly generated partial-k-trees with n = 100 vertices, k = 10 and p = 30. For this graph, we ran the algorithms MCS, MCS-M, LEX-P, and LEX-M for all possible start vertices. Fig. <ref type="figure" target="#fig_5">6</ref> shows the resulting widths for the four algorithms, displayed against the degree of the start vertex.</p><p>It is clear from Fig. <ref type="figure" target="#fig_5">6</ref> that the best choice is the MCS algorithm. But even with this algorithm the best width obtained is 15, whereas the GFI found the optimal width of 10 for this instance. Although MCS-M and LEX-M found an elimination ordering with width 16, the overall performance of the algorithms was significantly worse than MCS (the best width by LEX-P was 29). Remarkable, the highest reported width is achieved by minimal triangulation variants. For both MCS-M and LEX-M there exists a start vertex resulting in a minimal triangulation of width 78. Given that MCS-M and LEX-M produce  the same minimal triangulations <ref type="bibr" target="#b57">[58]</ref>, it is to be expected that they give similar widths; small differences can be the result of tiebreakings. The above results are not due to an unfortunate choice of the partial-k-tree as a second experiment showed. For all randomly generated partial-k-trees with n = 100 and k = 10 used in the previous subsection, we ran MCS. The results are reported in Table <ref type="table" target="#tab_4">2</ref> and clearly show that MCS is outperformed by GFI in all cases. Since MCS does not provide a minimal triangulation, the procedure of Section 5 can be applied on the best elimination ordering generated. The average width after triangulation minimisation is also reported in Table <ref type="table" target="#tab_4">2</ref> together with the result for MCS-M which include the triangulation minimisation. The results show that (i) triangulation minimisation significantly reduces the width of the MCS-generated elimination orderings, (ii) MCS-M is outperformed by this procedure, (iii) the width is still not competitive with the width obtained via GFI, with or without triangulation minimisation.</p><p>To understand better why the triangulation recognition heuristics perform so badly for relatively small graphs, we have set up a final experiment. We first randomly generate a k-tree with n = 100 and k = 10. Next, we randomly remove edges in steps of 1% until 10% of the edges have been removed. For each of the 11 graphs generated this way, we count how many start vertices result in a certain width. The results are shown in Table <ref type="table" target="#tab_5">3</ref>.</p><p>Since the MCS algorithm can start with any vertex for chordal graphs, it is not a surprise that the optimal width is found in all cases if no edges are removed. However, as soon as 2% of the edges are removed, none of the start vertices results in the optimal width. GFI, in contrast, still finds the optimal width after removal of 10% of the edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions</head><p>In this paper, we discussed several upper bound heuristics for treewidth. Each of the heuristics finds for a given graph G = (V, E) a tree decomposition of G.</p><p>Experiments show that in many cases, the heuristics perform reasonably well, i.e., give tree decompositions whose width comes close to (and sometimes equals) the exact treewidth. Some of the well performing heuristics are very fast. Thus, one can conclude that for many practical purposes, there are good methods to find tree decompositions with small treewidth.</p><p>Which of the heuristics is actually the best depends on the application. Our experiments show that different heuristics have different sets of instances on which they perform particularly well, see <ref type="bibr" target="#b97">[98]</ref>.</p><p>In many cases, the algorithms that run on the tree decompositions have a running time that is exponential in the width. Depending on the precise running times of this algorithm, and the number of times the same tree decomposition is used for different computations, it can make sense to spend more time on finding a good tree decomposition, e.g., to use a slower algorithm that computes the treewidth exactly. An overview of such algorithms is planned <ref type="bibr" target="#b15">[16]</ref>.</p><p>Many theoretical studies on treewidth give algorithms that start with the linear time algorithm for finding tree decompositions of width at most k for fixed k from <ref type="bibr" target="#b11">[12]</ref>. While this often gives the theoretically best asymptotic bound, this is not what one would do in practice: in a real life setting, one would instead use one of the heuristics discussed in this paper, or run a few of the heuristics and take the best solution found. For this purpose, we are developing an interactive website <ref type="bibr" target="#b13">[14]</ref>, that allows to experiment with a number of the discussed algorithms on graphs of your choice. The algorithms take as input a graph in the standardised DIMACS format <ref type="bibr" target="#b98">[99]</ref> and outputs the width found as well as the corresponding elimination ordering.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A graph with a tree decomposition.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The construction of Algorithm 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. A refinement step in the MSVS heuristic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Performance of greedy algorithms: average width obtained for samples of 50 randomly generated partial k graphs (treewidth equals k in all cases).The size of the graphs in number of vertices and edges is given on the x-axis; the average width on the y-axis. GFI = GreedyFillIn, GD = GreedyDegree, GD+FI = GreedyDegree+FillIn, +TM = Triangulation minimisation algorithm applied on result of greedy algorithm.</figDesc><graphic coords="13,42.39,272.17,456.52,131.41" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Performance of greedy algorithms. Panel (a) shows the distribution of the width relative to the optimal value (OPT). Panel (b) shows the performance of the algorithms in relation to the computation time. Both times and widths are normalised according to minimum achieved value (not the optimal width). See Fig. 4 for explanation of algorithm acronyms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Resulting width of the triangulation recognition heuristics compared to degree of the start vertex.</figDesc><graphic coords="14,163.81,69.01,216.78,144.78" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>One can easily observe that π is a perfect elimination ordering of H; in fact, we added the minimum set of edges to G such that π is a perfect elimination ordering of G. Call H the filled graph of G with respect to elimination ordering π, and denote this graph as G + π . As the filled graph H = G +</figDesc><table><row><cell>triangulation of G.</cell><cell>π has a perfect elimination ordering, it is a</cell></row></table><note><p>1. Fill(G,π ) yields a graph H.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>be the ith vertex in ordering π.</figDesc><table><row><cell>for each pair of neighbours w, x of v in H with w / = x, π(w) &gt; π(v), π(x) &gt; π(v) do</cell></row><row><cell>if w and x not adjacent in H then</cell></row><row><cell>add {w, x} to H.</cell></row><row><cell>end if</cell></row><row><cell>end for</cell></row><row><cell>end for</cell></row><row><cell>return H.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>By the second property of tree decompositions, G is a subgraph of H. By construction, each set X i is a clique in H. So, by Theorem 4, H is chordal. From Lemma 2, we see that the maximum size of a clique in H is at most k + 1.(ii) → (iii): This follows when we set π to be the perfect elimination ordering of H.</figDesc><table><row><cell>(iii) → (i): Let H = G + π . By Theorem 4, there is a tree decomposition ({X i | i ∈ I}, T = (I, F)) of H such that each set X i is a clique in H. So, by assumption, the width of this tree decomposition is at most k; as G is a subgraph of H, this is also a tree</cell></row><row><cell>decomposition of G.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>) time: we try each of the 3 |W| possibilities to distribute the vertices of W over S, A, and B; for each such possibilities we test if there is a separator of size k -|S ∩ W | that separates the set of vertices A ∩ W from the set of vertices</figDesc><table /><note><p>B ∩ W in the graph G[V \(S ∩ W )]; this test can be done in O(k(n + m)) time with flow techniques (see e.g.,</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2</head><label>2</label><figDesc>Average width by GFI, MCS, and MCS-M, with and without triangulation minimisation.</figDesc><table><row><cell></cell><cell>GFI</cell><cell>GFI+TM</cell><cell>MCS</cell><cell>MCS+TM</cell><cell>MCS-M</cell></row><row><cell>p = 50</cell><cell>10.62</cell><cell>10.10</cell><cell>16.64</cell><cell>11.84</cell><cell>27.52</cell></row><row><cell>p = 40</cell><cell>10.56</cell><cell>10.10</cell><cell>16.08</cell><cell>11.78</cell><cell>26.38</cell></row><row><cell>p = 30</cell><cell>10.76</cell><cell>10.16</cell><cell>14.72</cell><cell>11.32</cell><cell>22.30</cell></row></table><note><p>n = 100, k = 10</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3</head><label>3</label><figDesc>Histograms of returned widths by MCS after removal of a percentage of the edges of a 10-tree using all possible 100 start vertices.</figDesc><table><row><cell>E d g e s r e m o v e d ( % )</cell><cell>0</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell></cell><cell>8</cell><cell>9</cell><cell>1 0</cell></row><row><cell>Width</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>10</cell><cell>100</cell><cell>100</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>11</cell><cell></cell><cell></cell><cell>70</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>12</cell><cell></cell><cell></cell><cell>30</cell><cell>97</cell><cell>28</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>1 3</cell><cell></cell><cell></cell><cell></cell><cell>3</cell><cell>4 4</cell><cell>5 3</cell><cell>9 1</cell><cell>7 4</cell><cell>7 9</cell><cell>6 9</cell><cell>4 2</cell></row><row><cell>14</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>28</cell><cell>47</cell><cell>9</cell><cell>26</cell><cell>21</cell><cell>24</cell><cell>8</cell></row><row><cell>15</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>7</cell><cell>4 6</cell></row><row><cell>16</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>4</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Linear time algorithms for NP-hard problems restricted to partial k-trees</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arnborg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Proskurowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Disc. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="11" to="24" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Linear time computation of optimal subgraphs of decomposable graphs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Bern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Lawler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithm</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="216" to="235" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Solving partial constraint satisfaction problems with tree decomposition</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P M</forename><surname>Van Hoesel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W J</forename><surname>Kolen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="170" to="180" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Algorithms for vertex partitioning problems on partial k-trees</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Telle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Proskurowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Disc. Math</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="529" to="550" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A methodology for constructing linear graph algorithms</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">V</forename><surname>Wimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Hedetniemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Laskar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Congressus Numerantium</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="43" to="60" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Tree decomposition based fast search of RNA structures including pseudoknots in genomes</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Malmberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cai</surname></persName>
		</author>
		<idno type="DOI">10.1109/CSB.2005.52</idno>
	</analytic>
	<monogr>
		<title level="m">CSB&apos;05: Proceedings of the 2005 IEEE Computational Systems Bioinformatics Conference</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="223" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Comparative pathway annotation with protein-DNA interaction and operon information via graph tree decomposition</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Che</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Pacific Symposium on Biocomputing (PSB 2007)</title>
		<meeting>Pacific Symposium on Biocomputing (PSB 2007)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="496" to="507" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Rapid ab initio prediction of RNA pseudoknots via graph tree decomposition</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Malmberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Math. Biol</title>
		<imprint>
			<biblScope unit="page" from="243" to="282" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Quantified constraint satisfaction and bounded treewidth</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th European Conference on Artificial Intelligence, ECAI&apos;2004</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>De Mántaras</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Saitta</surname></persName>
		</editor>
		<meeting>the 16th European Conference on Artificial Intelligence, ECAI&apos;2004</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="161" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A comparison of structural CSP decomposition methods</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Scarcello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inform</title>
		<imprint>
			<biblScope unit="volume">124</biblScope>
			<biblScope unit="page" from="243" to="282" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Local computations with probabilities on graphical structures and their application to expert systems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Lauritzen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Spiegelhalter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Roy. Stat. Soc. Ser. B</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="157" to="224" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A linear time algorithm for finding tree-decompositions of small treewidth</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1305" to="1317" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Tree decomposition: a feasibility study, Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">H</forename><surname>Röhrig</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<pubPlace>Saarbrücken, Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Max-Planck-Institut für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">ComputeTW -An interactive platform for computing Treewidth of graphs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<ptr target="http://www.math2.rwth-aachen.de/∼koster/ComputeTW/" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<title level="m">Treewidth computations II. Lower bounds</title>
		<imprint/>
	</monogr>
	<note>in preparation</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<title level="m">Treewidth computations III. Exact algorithms and preprocessing</title>
		<imprint/>
	</monogr>
	<note>in preparation</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">C</forename><surname>Berge</surname></persName>
		</author>
		<author>
			<persName><surname>Graphs</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Modern Graph Theory</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bollobás</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Graduate Texts in Mathematics</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yellen</surname></persName>
		</author>
		<title level="m">Graph Theory and Its Applications</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>CRC Press</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Harary</surname></persName>
		</author>
		<title level="m">Graph Theory</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">T</forename><surname>Tutte</surname></persName>
		</author>
		<title level="m">Graph theory, Encyclopedia of Mathematics and Its Applications</title>
		<meeting><address><addrLine>Menlo Park, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Introduction to Graph Theory</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>West</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Brandstädt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Spinrad</surname></persName>
		</author>
		<title level="m">Graph Classes. A Survey, SIAM Monographs on Discrete Mathematics and Applications</title>
		<meeting><address><addrLine>SIAM, Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<title level="m">Introduction to Algorithms</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Graph Algorithms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<pubPlace>Pitman, London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Algorithmic Graph Theory</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Gibbons</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<title level="m">Éva Tardos, Algorithm Design</title>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Algorithmic Graph Theory and Perfect Graphs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Golumbic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>Academic Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Downey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Parameterized Complexity</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Flum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
		<title level="m">Parameterized Complexity Theory</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Invitation to fixed-parameter algorithms</title>
		<author>
			<persName><forename type="first">R</forename><surname>Niedermeier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Oxford Lecture Series in Mathematics and Its Applications</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Oxford University Press</publisher>
			<pubPlace>Oxford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>W.H. Freeman</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Efficient algorithms for combinatorial problems on graphs with bounded decomposability -a survey</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arnborg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BIT</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2" to="23" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A tourist guide through treewidth</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Cybernetica</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1" to="23" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A partial k-arboretum of graphs with bounded treewidth</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">209</biblScope>
			<biblScope unit="page" from="1" to="45" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Discovering treewidth</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 31st Conference on Current Trends in Theory and Practice of Computer Science, SOFSEM 2005</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Vojtás</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Bieliková</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Charron-Bost</surname></persName>
		</editor>
		<meeting>31st Conference on Current Trends in Theory and Practice of Computer Science, SOFSEM 2005<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3381</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Combinatorial optimization on graphs of bounded treewidth</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="255" to="269" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Branch and tree decomposition techniques for discrete optimization</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">V</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kolotoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TutORials 2005, INFORMS Tutorials in Operations Research Series, INFORMS Annual Meeting</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Smith</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1" to="29" />
		</imprint>
	</monogr>
	<note>Chapter 1</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P M</forename><surname>Van Hoesel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Discrete Mathematics</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Broersma</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Faigle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Hurink</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Pickl</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="54" to="57" />
			<date type="published" when="2001">2001</date>
			<publisher>Elsevier Science Publishers</publisher>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
	<note>Treewidth: computational experiments</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Tree width and tangles: a new measure of connectivity and some applications, Surveys in Combinatorics</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">LMS Lecture Note Series</title>
		<imprint>
			<biblScope unit="volume">241</biblScope>
			<biblScope unit="page" from="87" to="162" />
			<date type="published" when="1997">1997</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Algorithmic aspects of tree width, Recent Advances in Algorithms and Combinatorics</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">CMS Books Mathematics/Ouvrages Mathematics SMC</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="85" to="107" />
			<date type="published" when="2003">2003</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">T</forename><surname>Kloks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Width parameters beyond tree-width and their applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hliněný</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Oum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Seese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="326" to="362" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Graph minors. II. Algorithmic aspects of tree-width</title>
		<author>
			<persName><forename type="first">N</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Seymour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithm</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="309" to="322" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The pathwidth and treewidth of cographs</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Möhring</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Disc. Math</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="181" to="188" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">The intersection graphs of subtrees in trees are exactly the chordal graphs</title>
		<author>
			<persName><forename type="first">F</forename><surname>Gavril</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comb. Theory B</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="47" to="56" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">A characterization of rigid circuit graphs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Disc. Math</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="205" to="212" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">On rigid circuit graphs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dirac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Abh. Math. Sem. Univ. Hamburg</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="71" to="76" />
			<date type="published" when="1961">1961</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Incidence matrices and interval graphs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Fulkerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">A</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pacific J. Math</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="835" to="855" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Algorithmic aspects of vertex elimination on graphs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Lueker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="266" to="283" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Representations of chordal graphs as subgraphs of a tree</title>
		<author>
			<persName><forename type="first">J</forename><surname>Walter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Theory</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="265" to="267" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">The use of linear graphs in Gauss elimination</title>
		<author>
			<persName><forename type="first">S</forename><surname>Parter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Rev</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="119" to="130" />
			<date type="published" when="1961">1961</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Triangulated graphs and the elimination process</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Rose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Math. Anal. Appl</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="597" to="609" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Sequential and parallel triangulating algorithms for Elimination Game and new insights on Minimum Degree</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Dahlhaus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Simonet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">409</biblScope>
			<biblScope unit="page" from="601" to="616" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Simple linear time algorithms to test chordiality of graphs, test acyclicity of graphs, and selectively reduce acyclic hypergraphs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="566" to="579" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Maximum cardinality search for computing minimal triangulations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R S</forename><surname>Blair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 28th International Workshop on Graph Theoretic Concepts in Computer Science, WG&apos;02</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Kucera</surname></persName>
		</editor>
		<meeting>28th International Workshop on Graph Theoretic Concepts in Computer Science, WG&apos;02<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2573</biblScope>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Maximum cardinality search for computing minimal triangulations of graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Blair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Peyton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="287" to="298" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Y</forename><surname>Villanger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lex M Versus</forename><surname>Mcs-M</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Disc. Math</title>
		<imprint>
			<biblScope unit="volume">306</biblScope>
			<biblScope unit="page" from="393" to="400" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Ultimate generalizations of LexBFS and LEX M</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Krueger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Simonet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 31st International Workshop on Graph-Theoretic Concepts in Computer Science WG&apos;05</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>31st International Workshop on Graph-Theoretic Concepts in Computer Science WG&apos;05<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3787</biblScope>
			<biblScope unit="page" from="199" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">The elimination form of the inverse and its application to linear programming</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Markowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Manage. Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="255" to="269" />
			<date type="published" when="1957">1957</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">The minimum degree heuristic and the minimal triangulation process</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Simonet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 29th International Workshop on Graph Theoretic Concepts in Computer Science, WG&apos;03</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>29th International Workshop on Graph Theoretic Concepts in Computer Science, WG&apos;03<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2880</biblScope>
			<biblScope unit="page" from="58" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">New lower and upper bounds for graph treewidth</title>
		<author>
			<persName><forename type="first">F</forename><surname>Clautiaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Carlier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moukrim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Négre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings International Workshop on Experimental and Efficient Algorithms</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">D P</forename><surname>Rolim</surname></persName>
		</editor>
		<meeting>International Workshop on Experimental and Efficient Algorithms<address><addrLine>WEA; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="volume">2647</biblScope>
			<biblScope unit="page" from="70" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Heuristic and meta-heuristic methods for computing graph treewidth</title>
		<author>
			<persName><forename type="first">F</forename><surname>Clautiaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moukrim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Négre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Carlier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RAIRO Operat. Res</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="13" to="26" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Bachoore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Workshop on Experimental and Efficient Algorithms WEA 2005</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Nikoletseas</surname></persName>
		</editor>
		<meeting>the Fourth International Workshop on Experimental and Efficient Algorithms WEA 2005<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3503</biblScope>
			<biblScope unit="page" from="217" to="227" />
		</imprint>
	</monogr>
	<note>New upper bound heuristics for treewidth</note>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Pre-processing rules for triangulation of probabilistic networks</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">V D</forename><surname>Eijkhof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Intell</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="286" to="305" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Heuristic algorithms for the triangulation of graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Intelligent Computing, Selected Papers from the Fifth International Conference on Precessing and Management of Uncertainty in Knowledge-Based Systems IPMU94</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Bouchon-Meunier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Yager</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><forename type="middle">A</forename><surname>Zadeh</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">945</biblScope>
			<biblScope unit="page" from="98" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Simple and efficient modifications of elimination orderings</title>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Villanger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Seventh International Conference on Applied Parallel Computing</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Seventh International Conference on Applied Parallel Computing<address><addrLine>PARA; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004. 2006</date>
			<biblScope unit="volume">3732</biblScope>
			<biblScope unit="page" from="788" to="797" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Optimal decomposition of probabilistic networks by simulated annealing</title>
		<author>
			<persName><forename type="first">U</forename><surname>Kjaerulff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Stat. Comput</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="2" to="17" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Decomposing Bayesian networks: triangulation of the moral graph with genetic algorithms</title>
		<author>
			<persName><forename type="first">P</forename><surname>Larrañaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M H</forename><surname>Kuijpers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Poza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Murga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Stat. Comput. (UK)</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="19" to="34" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">A local search algorithm for determining tree decompositions of graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Marchal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Hoesel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Presented on the International Symposium on Combinatorial Optimization</title>
		<imprint>
			<date type="published" when="2008-03">March 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Finding good tree decompositions by local search</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P M V</forename><surname>Hoesel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electron. Notes Dis. Math.</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="43" to="50" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">A complete anytime algorithm for treewidth</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gogate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Annual Conference on Uncertainty in Artificial Intelligence UAI-04</title>
		<meeting>the 20th Annual Conference on Uncertainty in Artificial Intelligence UAI-04<address><addrLine>Arlington, VA</addrLine></address></meeting>
		<imprint>
			<publisher>AUAI Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="201" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">On exact algorithms for treewidth</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">V</forename><surname>Fomin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kratsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Thilikos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 14th Annual European Symposium on Algorithms, ESA 2006</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Azar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Erlebach</surname></persName>
		</editor>
		<meeting>14th Annual European Symposium on Algorithms, ESA 2006<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4168</biblScope>
			<biblScope unit="page" from="672" to="683" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Efficient approximation for triangulation of minimum treewidth</title>
		<author>
			<persName><forename type="first">E</forename><surname>Amir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence</title>
		<meeting>the 17th Conference on Uncertainty in Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="7" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<title level="m" type="main">Approximation algorithms for treewidth, algorithmica</title>
		<author>
			<persName><forename type="first">E</forename><surname>Amir</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>published online</note>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">A sufficiently fast algorithm for finding close to optimal clique trees</title>
		<author>
			<persName><forename type="first">A</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Geiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">125</biblScope>
			<biblScope unit="page" from="3" to="17" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">On treewidth approximations</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bouchitté</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kratsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Todinca</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Disc. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">136</biblScope>
			<biblScope unit="page" from="183" to="196" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Approximating treewidth, pathwidth, frontsize, and minimum elimination tree height</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hafsteinsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kloks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithm</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="238" to="255" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Highly connected sets and the excluded grid theorem</title>
		<author>
			<persName><forename type="first">R</forename><surname>Diestel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Y</forename><surname>Gorbunov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Thomassen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comb. Theory B</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="61" to="73" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Efficient parallel algorithms for graphs of bounded tree-width</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lagergren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithm</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="20" to="44" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Finding approximate separators and computing tree-width quickly</title>
		<author>
			<persName><forename type="first">B</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Annual Symposium on Theory of Computing</title>
		<meeting>the 24th Annual Symposium on Theory of Computing<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="221" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Graph minors. XIII. The disjoint paths problem</title>
		<author>
			<persName><forename type="first">N</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Seymour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comb. Theory B</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="65" to="110" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">A separator theorem for chordal graphs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Edenbrandt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Alg. Disc. Meth</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="306" to="313" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">The role of elimination trees in sparse factorization</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W H</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Matrix Anal. Appl</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="134" to="172" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<title level="m">Frequency assignment -models and algorithms</title>
		<meeting><address><addrLine>Maastricht, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>University of Maastricht</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">A practical algorithm for making filled graphs minimal</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R S</forename><surname>Blair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Telle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">250</biblScope>
			<biblScope unit="page" from="125" to="141" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">A wide-range efficient algorithm for minimal triangulation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA&apos;99: ACM-SIAM Symposium on Discrete Algorithms</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="860" to="861" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">A wide-range algorithm for minimal triangulation from an arbitrary ordering</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Bordat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Simonet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Villanger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithm</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="33" to="66" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Minimal elimination ordering inside a given chordal graph</title>
		<author>
			<persName><forename type="first">E</forename><surname>Dahlhaus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 23rd International Workshop on Graph-Theoretic Concepts in Computer Science WG&apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>23rd International Workshop on Graph-Theoretic Concepts in Computer Science WG&apos;97<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1335</biblScope>
			<biblScope unit="page" from="132" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Efficient implementation of a minimal triangulation algorithm</title>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Villanger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Annual European Symposium on Algorithms, ESA&apos;2002</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Möhring</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Raman</surname></persName>
		</editor>
		<meeting>the 10th Annual European Symposium on Algorithms, ESA&apos;2002<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2461</biblScope>
			<biblScope unit="page" from="550" to="561" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">A vertex incremental approach for maintaining chordality</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Villanger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Disc. Math</title>
		<imprint>
			<biblScope unit="volume">306</biblScope>
			<biblScope unit="page" from="318" to="336" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Minimal orderings revisited</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Peyton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Matrix Anal. Appl</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="271" to="294" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Minimal triangulations of graphs: a survey</title>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Disc. Math</title>
		<imprint>
			<biblScope unit="volume">306</biblScope>
			<biblScope unit="page" from="297" to="317" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Computing minimal triangulations in time</title>
		<author>
			<persName><forename type="first">P</forename><surname>Heggernes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Telle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Villanger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">SIAM J. Disc. Math.</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="900" to="913" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<monogr>
		<title level="m" type="main">The Boost Graph Library: User Guide and Reference Manual</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Siek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-Q</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lumsdaine</surname></persName>
		</author>
		<ptr target="&lt;http://www.boost.org&gt;" />
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Addison-Wesley Professional</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
	<note>Software available on</note>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">A practical algorithm for finding optimal triangulations</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shoikhet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Geiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the National Conference on Artificial Intelligence (AAAI&apos;97)</title>
		<meeting>the National Conference on Artificial Intelligence (AAAI&apos;97)<address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufman</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="185" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Contraction and treewidth lower bounds</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M C A</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wolle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithm Appl</title>
		<imprint>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="5" to="49" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<monogr>
		<title/>
		<author>
			<persName><surname>Treewidthlib</surname></persName>
		</author>
		<ptr target="&lt;http://www.cs.uu.nl/people/hansb/treewidthlib&gt;" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<monogr>
		<title level="m" type="main">The second DIMACS implementation challenge: NP-Hard Problems: Maximum Clique, Graph Coloring, and Satisfiability, 1992-1993</title>
		<ptr target="&lt;http://dimacs.rutgers.edu/Challenges/&gt;" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
