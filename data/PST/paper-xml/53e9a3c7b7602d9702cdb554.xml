<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CCured: Type-Safe Retrofitting of Legacy Code</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">George</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
							<email>necula@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Scott</forename><surname>Mcpeak</surname></persName>
							<email>smcpeak@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Westley</forename><surname>Weimer</surname></persName>
							<email>weimer@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">CCured: Type-Safe Retrofitting of Legacy Code</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5CF619A18A7BA54CCA30344933C73C21</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we propose a scheme that combines type inference and run-time checking to make existing C programs type safe. We describe the CCured type system, which extends that of C by separating pointer types according to their usage. This type system allows both pointers whose usage can be verified statically to be type safe, and pointers whose safety must be checked at run time. We prove a type soundness result and then we present a surprisingly simple type inference algorithm that is able to infer the appropriate pointer kinds for existing C programs.</p><p>Our experience with the CCured system shows that the inference is very effective for many C programs, as it is able to infer that most or all of the pointers are statically verifiable to be type safe. The remaining pointers are instrumented with efficient run-time checks to ensure that they are used safely. The resulting performance loss due to run-time checks is 0-150%, which is several times better than comparable approaches that use only dynamic checking. Using CCured we have discovered programming bugs in established C programs such as several SPECINT95 benchmarks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The C programming language provides programmers with a great deal of flexibility in the representation of data and the use of pointers. These features make C the language of choice for systems programming. Unfortunately, the cost is a weak type system and consequently a great deal of "flexibility" in introducing subtle bugs in programs.</p><p>While in the 1970s sacrificing type safety for flexibility and performance might have been a sensible language design choice, today there are more and more situations in which type safety is just as important as, if not more important than, performance. Errors like array out-of-bounds accesses lead both to painful debugging sessions chasing inadvertent memory updates and to malicious attacks exploiting buffer overrun errors in security-critical code. (Almost 50% of recent CERT advisories result from security violations of this kind <ref type="bibr" target="#b28">[29]</ref>.) Type safety is desirable for isolating program components in a large or extensible system, without the loss of performance of separate address spaces. It is also valuable for inter-operation with systems written in type-safe languages (such as type-safe Java native methods, for example). Since a great deal of useful code is already written or being written in C, it would be useful to have a practical scheme to bring type safety to these programs.</p><p>The work described in this paper is based on two main premises. First, we believe that even in programs written in unsafe languages like C, a large part of the program can be verified statically to be type safe. Then the remaining part of the program can be instrumented with run-time checks to ensure that the execution is memory safe. The second premise of our work is that in many applications, some loss of performance due to run-time checks is an acceptable price for type safety, especially when compared to the alternative cost of reprogramming the system in a type-safe language.</p><p>The main contribution of this paper is the CCured type system, an extension of the C type system with explicit types for pointers into arrays, and with dynamic types. It extends previous work on adding dynamic types to statically typed languages: types and capabilities for the statically-typed elements are known at compile time, while the dynamicallytyped elements are guarded by run-time checks. Our type system is inspired by common C usage, and includes support for physical type equivalence <ref type="bibr" target="#b7">[8]</ref> and special "sequence" pointers for accessing arrays. The second contribution of the paper is a simple yet effective type-inference algorithm that can translate ordinary C programs into CCured mostly automatically and in a matter of seconds even for 30,000line programs. We have used this inference algorithm to produce type-safe versions of several C programs for which we observed a slowdown of 0-150%. In the process, we have also found programming bugs in the analyzed code, the most surprising being several array out-of-bounds errors in the SPECINT95 compress, go and ijpeg benchmarks.</p><p>We continue in Section 2 with an informal overview of the system in the context of a small example program. Then in Section 3 we present a simple language of pointers, with its type system (in Section 4) and operational semantics (in Section 5), followed by a discussion of the type safety guarantees of CCured programs. In Section 6 we present a simple constraint-based type inference algorithm for CCured. We discuss informally the extension of the language presented in this paper to the whole C programming language in Section 7, necessary source code changes in Section 8, and in Section 9 we relate our experience with a prototype implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Overview of the Approach</head><p>To ensure memory safety, for each pointer we must keep track of certain properties of the memory area to which it is supposed to point. Such properties include the area's size and the types of the values it contains. For some pointers this information can be computed precisely at compile time and for others we must compute it at run time, in which case we have to insert run-time safety checks.</p><p>These two kinds of pointers appear in the example C program shown in Figure <ref type="figure" target="#fig_6">1</ref>. The program operates on a hypothetical disjoint union datatype we call "boxed integer" that has been efficiently implemented in C as follows: if a boxed integer value is odd then it represents a 31-bit integer in the most significant bits along with a least significant tag bit equal to one, otherwise it represents a pointer to another "boxed integer". We use the C datatype int * to represent boxed integers. The variable a is a pointer to an array of boxed integers. The purpose of the function is to accumulate in the variable acc the sum of the first 100 boxed integers in the array. In line 8 we compute the address of a boxed integer and in line 9 we fetch the boxed integer. The loop in lines 10-12 unboxes the integer. The subscripts on the pointer type constructors "*" have been added to simplify cross-referencing from the text.</p><p>By inspection of the program we observe that the values of the variables a and p are supposed to point into the same array. Neither of these variables is subject to casts (and they have no other aliases) and thus we know that the type of the values they point to is indeed "int * ". Furthermore, we observe that while the pointer a is subject to pointer arithmetic, the pointer p is not. This means that we must check uses of "a" for array out-of-bounds errors but we do not need to do so for the uses of "p" (assuming that a check is performed in line 8 where "p" is initialized). In this paper we refer to "p" as a safe pointer and to "a" as a sequence pointer. To be more precise we associate this information with the pointer type constructors * 4 and * 2 respectively. Safe and sequence pointers have only aliases that agree on the type of the value pointed to and thus point to memory areas whose contents is statically typed. Now we turn our attention to the pointer values of "e". These values are used with two incompatible types "int * " and "int * * ". This means that we cannot count on the static type of "e" as being an accurate description of its values. In our type system we say that "e" has a dynamic pointer type and we associate this information with the pointer type constructors * 5 and * 7. Dynamic pointers always point into memory areas whose contents do not have a reliable static type and must therefore store extra information to classify their contents as pointers or integers. Correspondingly, the aliases of dynamic pointers can only be other dynamic pointers; otherwise a safe pointer's static type assumptions could be violated after a memory write through a dynamic pointer alias. This means that the type constructors * 1, * 3 and * 6 must also be classified as dynamic pointers. In this example program, we have a mixture of pointers whose static type can be relied upon and thus require little or no access checks (the safe and sequence pointers), and also pointers whose static type is unreliable and thus require more extensive checking.</p><p>Motivated by this and similar examples, the CCured language is essentially the union of two languages: a strongly typed language (containing safe and sequence pointers), and an untyped language for which the type information is maintained and checked at run time.</p><p>All values and memory areas in the system are either part of the safe/sequence world, or part of the dynamic world. The only place these worlds touch is when a typed memory area contains a pointer to untyped memory. Untyped memory cannot contain safe or sequence pointers because we cannot assign a reliable static type to the contents of dynamic areas. We shall formalize these invariants starting in Section 4. Before then, in order to provide some intuition for the formal development, we summarize in Figure <ref type="figure" target="#fig_0">2</ref> the capabilities and invariants of various pointer kinds. Since in C the null pointer is used frequently, we allow the safe pointers to be null. Similarly, we allow arbitrary integers to be "disguised" as sequence and dynamic pointers, but not as safe pointers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kind</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invariants maintained</head><p>Capabilities Access checks required Safe pointer to τ</p><p>• Either 0 or a valid address containing a value of type τ .</p><p>• Aliases are either safe or sequence pointers of base type τ .</p><p>• Cast from sequence pointer of base type τ .</p><p>• Set to 0.</p><p>• Cast to integer.</p><p>• Null-pointer check when dereferenced.</p><p>Sequence pointer to τ</p><p>• Knows at run-time if it is an integer, and if not, knows the memory area (containing a number of values of type τ ) to which it points.</p><p>• Aliases are safe and sequence pointers of base type τ .</p><p>• Cast to safe pointer of base type τ .</p><p>• Cast from integer.</p><p>• Cast to integer.</p><p>• Perform pointer arithmetic.</p><p>• Non-pointer check (subsumes null-pointer check).</p><p>• Bounds check when dereferenced or cast to SAFE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic pointer</head><p>• Knows at run-time if it is an integer, and if not, knows the memory area (containing a number of integer or dynamic pointer values) to which it points.</p><p>• The memory area pointed to maintains tags distinguishing integers from pointers.</p><p>• Aliases are dynamic pointers.</p><p>• Cast to and from any dynamic pointer type.</p><p>• Cast from integer.</p><p>• Cast to integer.</p><p>• Perform pointer arithmetic.</p><p>• Non-pointer check.</p><p>• Bounds check when dereferenced.</p><p>• Maintain the tags in the pointed area when reading and writing.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A Language of Pointers</head><p>There are many constructs in the C programming language that can be misused to violate memory safety and type safety. Among them are type casts, pointer arithmetic, arrays, union types, the address-of operator, and explicit deallocation. To simplify the presentation of the key ideas behind our approach we describe it formally for a small language containing only pointers with casts and pointer arithmetic, and then we discuss informally in Section 7 how we extend the approach to handle the remaining C constructs.</p><p>Figure <ref type="figure" target="#fig_1">3</ref> presents the syntax of types, expressions and commands for a simple programming language that serves as the vehicle for formalizing CCured. At the level of types we have retained only the integers and the pointer types. In C the symbol "*" is used in various syntactic roles in conjunction with pointer types; to avoid confusion we have instead adopted the syntax of ML references for our modeling language. We have three flavors of pointer types corresponding to safe, sequence and dynamic pointers respectively. The type DYNAMIC is a pointer type that does not carry with it the type of the values pointed to. This is indicative of the fact that we cannot count on the referenced type of a dynamic pointer.</p><p>Among expressions we have integer literals and an assortment of binary integer operations, such as the arithmetic and relational operations, written generically as op. Relational operations on pointers are done after casting the pointers to integers. The binary operation ⊕ denotes pointer arithmetic and the notation ! e denotes the result of reading from the memory location denoted by e (like *e in C).</p><p>The language of commands is greatly simplified. The only notable form of commands is memory update through a pointer (p := e is like *p = e in C). Control flow operations are not interesting because our approach is flow insensitive. Function calls are omitted for simplification; instead we discuss briefly in Section 7 how we handle function calls and function pointers. Among other notable omissions are variable updates and the address-of operator on variables. Instead, to simplify the formal presentation, we consider that a variable that is updated or has its address taken in C would be allocated on the heap and operated upon through its address (which is an immutable pointer variable) in our language. Finally, we ignore here the allocation and deallocation of memory (including that of stack frames). Even though the resulting language appears to be much simpler than C, it allows us to expose formally and in a succinct way the major ideas behind our type system, the type inference algorithm and the implementation. The implementation itself handles the entire C language.</p><p>Our example program from Figure <ref type="figure" target="#fig_6">1</ref> can be transcribed in this language (with the use of variable declarations and a few additional control-flow constructs) as shown in Figure <ref type="figure">4</ref>. The major change in this version is that we have replaced the variables i, acc, p and e by pointers, and the accesses to those variables by memory operations. (The lines 1-5 are technically not representable in our language. We show them only to provide a context for the rest of the example. We also ignore the initialization of these variables.) All the newly introduced pointer type constructors are SAFE since the corresponding pointers are used only for reading and writing. Another change is that one or more nested dynamic pointer type constructors are collapsed into the DYNAMIC type.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The Type System</head><p>In this section we describe the CCured type system for the language introduced in the previous section. The purpose of this type system is to maintain the separation between the statically typed and the untyped worlds, and to ensure that all well-typed programs can be made to run safely with the addition of appropriate run-time checks. The run-time checks are described as part of the operational semantics in Section 5. For now we concentrate on type checking, and we shall assume that the program contains complete pointer kind information.</p><p>The type system is expressed by means of the following three judgments: Expression typing: Γ e : τ Command typing: Γ c Convertibility:</p><p>τ ≤ τ</p><p>In these judgments Γ denotes a typing environment mapping variable names to types. Since we do not have declarations in our language, the typing environment is assumed to be provided externally. The derivation rules for the typing judgments are shown in Figure <ref type="figure" target="#fig_4">5</ref>.</p><p>Observe in the typing rules that we check casts with respect to a convertibility relation on types, whose rules are defined at the bottom of the figure. We also have a special typing rule for creating a safe null pointer. Pointer arithmetic can be done on sequence and dynamic pointers. Memory operations are legal for safe and dynamic pointers. A dereference operation on a sequence pointer can be performed after the pointer is cast to a safe one. Notice also how the type DYNAMIC is used both for pointers into untyped areas and for the values stored into those areas.</p><p>The type convertibility relation captures the situations in which a cast or coercion is legal in CCured. Notice in the rules that any type can be converted to an integer but integers can be converted only to sequence or to dynamic pointers. However, whenever we convert an integer into a sequence or a dynamic pointer we obtain pointers for which dereferences are prevented by run-time checks. The last conversion rule is used for converting sequence pointers into safe pointers, in which case the referenced type cannot change.</p><p>If this last conversion rule is used then our operational semantics inserts a run-time check to verify that the pointer being cast is within the bounds of its home area.</p><p>It is important to point out that in most cases casts act as conversions between different representations of values and in some cases they are also accompanied by run-time checks. The run-time manipulations that accompany casts make convertibility different from subtyping in several respects. First, convertibility extended with transitivity and viewed as a coercion-based subtyping relation <ref type="bibr" target="#b3">[4]</ref>, would be incoherent. For example, the series of coercions corresponding to DYNAMIC ≤ int ≤ DYNAMIC have a different effect from the identity since even if we start with a perfectly usable pointer we end up with a pointer that has lost its capability to perform memory operations. Because of lack of coherence we cannot allow a general subsumption rule and instead we let the program control the use of conversions, through casts. Consequently, we do not have a transitivity rule and we rely instead on the programmer to obtain the same effect by using a sequence of casts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Operational Semantics</head><p>In this section we describe the run-time checks that are necessary for CCured programs to run safely. We do this in the form of an operational semantics for CCured.</p><p>The execution environment consists of a mapping Σ from variable names to values, a set of allocated memory areas H (which we call homes), and a mapping M (the memory) from addresses within the homes to values. The mapping Σ is assumed to be provided externally just like the similar mapping Γ from the typing rules. In our language only the memory changes during the execution. In order to better expose the precise costs of using each kind of pointer we use a low-level representation of addresses as natural numbers. A home is represented by its starting address (H ⊆ N ) and for all homes we define a function size : H → N whose value is the size of the home. We require the following properties of the set H and the function size:</p><p>• NULL: 0 ∈ H and size(0) = 1.</p><formula xml:id="formula_0">• DISJOINT: ∀h, h , i, i . (h = h ∧ 0 ≤ i &lt; size(h) ∧ 0 ≤ i &lt; size(h )) ⇒ h + i = h + i .</formula><p>We choose the size of the null home to be 1 in order to ensure that only the null pointer belongs to the null home. We write H * for the set H \{0}. A memory corresponding to a set of allocated homes is a mapping of addresses to values MH : N → Values such that its domain consists exactly of the addresses contained in the non-null homes:</p><formula xml:id="formula_1">Dom(MH ) = { h + i | h ∈ H * ∧ 0 ≤ i &lt; size(h) }</formula><p>Since the set of homes H does not change during the evaluation we often omit the subscript H from the memory. We define two operations on memory. We write M (n) to denote the contents of the memory address n, and we write M [ v n] to denote a new memory state obtained from M by storing the value v at address n. Both of these operations are defined only when n is a valid address (n ∈ Dom(M )).  Expressions: The values of integer and safe pointer expressions are plain integers (without any representation overhead over C), while the values of sequence and dynamic pointer expressions is of the form h, n :</p><formula xml:id="formula_2">τ ≤ τ τ ≤ int int ≤ τ ref SEQ int ≤ DYNAMIC τ ref SEQ ≤ τ ref SAFE</formula><formula xml:id="formula_3">Σ, M n ⇓ n INT Σ(x) = v Σ, M x ⇓ v VAR Σ, M e1 ⇓ n1 Σ, M e2 ⇓ n2 Σ, M e1 op e2 ⇓ n1 op n2 OP Casts: Σ, M e ⇓ n Σ, M (int)e ⇓ n C1 Σ, M e ⇓ h, n Σ, M (int)e ⇓ h + n C2 Σ, M e ⇓ n Σ, M (τ ref SEQ)e ⇓ 0, n C3 Σ, M e ⇓ h, n Σ, M (τ ref SEQ)e ⇓ h, n C4 Σ, M e ⇓ n Σ, M (DYNAMIC)e ⇓ 0, n C5 Σ, M e ⇓ h, n Σ, M (DYNAMIC)e ⇓ h, n C6 Σ, M e ⇓ n Σ, M (τ ref SAFE)e ⇓ n C7 Σ, M e ⇓ h, n 0 ≤ n &lt; size(h) Σ, M (τ ref SAFE)e ⇓ h + n C8 Pointer arithmetic: Σ, M e1 ⇓ h, n1 Σ, M e2 ⇓ n2 Σ, M e1 ⊕ e2 ⇓ h, n1 + n2 ARITH Memory reads: Σ, M e ⇓ n n = 0 Σ, M ! e ⇓ M (n) SAFERD Σ, M e ⇓ h, n h = 0 0 ≤ n &lt; size(h) Σ, M ! e ⇓ M (h + n) DYNRD Commands: Σ, M skip =⇒ M SKIP Σ, M c1 =⇒ M Σ, M c2 =⇒ M Σ, M c1; c2 =⇒ M CHAIN Σ, M e1 ⇓ n n = 0 Σ, M e2 ⇓ v2 Σ, M e1 := e2 =⇒ M [ v2 n] SAFEWR Σ, M e1 ⇓ h, n h = 0 0 ≤ n &lt; size(h) Σ, M e2 ⇓ v2 Σ, M e1 := e2 =⇒ M [ v2 h + n ] DYNWR</formula><formula xml:id="formula_4">Values v ::= n | h, n</formula><p>The latter kind of pointer value carries with it its "identity" (represented by its home). The home is used both to check if the pointer is actually an integer converted to a pointer (when the home is 0), or otherwise to retrieve the size of the home while performing a bounds check.</p><p>The operational semantics is defined by means of two judgments. We write Σ, M e ⇓ v to say that in the environment Σ and in the memory state denoted by M the expression e evaluates to value v. For commands we use a similar judgment Σ, M c =⇒ M but in this case the result is a new memory state. The derivation rules for these two judgments are given in Figure <ref type="figure" target="#fig_5">6</ref>.</p><p>Notice that we have eight rules for casts, one rule for each combination of destination type and form of the value being cast. The rules C3 and C5 show that an integer is converted to a sequence or to a dynamic pointer by using a null home. The rule C7 applies when we cast the integer 0 or a safe pointer to another safe pointer, while the rule C8 applies for casts from sequence pointers to safe pointers. In this latter case we must perform a bounds check. Here and in the rules to follow we mark such run-time checks with a box around them. Other instances of run-time checks are for memory operations. If the memory operation uses a safe pointer then only a null-pointer check must be done, otherwise a nonpointer check and a bounds check must be done.</p><p>The typing rules from Figure <ref type="figure" target="#fig_4">5</ref> suggest that we can perform a sequence of conversions τ ref SEQ ≤ int ≤ τ ref SEQ or even a similar one where the destination type is τ ref SEQ. This is indeed legal in CCured but the operational rules show that when starting with a pointer value h, n we end up after these two conversions with the value 0, h+n , which is a pointer value that cannot be used for reading and writing. This property is quite important in practice: programs that cast pointers into integers and then back to pointers will not be able to use the resulting pointers as memory addresses. We discuss this issue further in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Type Safety</head><p>The type system described in Section 4 enforces the separation between the typed and the untyped worlds. The operational semantics of Section 5 describes the run-time checks we perform for each operation on various pointer kinds. In this section we formalize and outline a proof of the resulting safety guarantees we obtain for CCured programs.</p><p>For each non-null home we define its kind as either Typed (τ ), meaning that it contains a number of values of type τ and has only safe and sequence pointers of base type τ pointing to it, or as Untyped , meaning that it contains a number of values of type DYNAMIC and has only pointers of type DYNAMIC pointing to it.</p><p>Then we define for each type τ the set τ H of valid values of that type. As the notation suggests, this set depends on the current set of homes:</p><formula xml:id="formula_5">int H = N DYNAMIC H = { h, n | h ∈ H ∧ (h = 0 ∨ kind(h) = Untyped )} τ ref SEQ H = { h, n | h ∈ H ∧ (h = 0 ∨ kind(h) = Typed (τ ))} τ ref SAFE H = {h + i | h ∈ H ∧ 0 ≤ i &lt; size(h) ∧ (h = 0 ∨ kind(h) = Typed (τ ))}</formula><p>We extend the notation v ∈ τ H element-wise to the corresponding notation for environments Σ ∈ Γ H (meaning ∀x ∈ Dom(Σ). Σ(x) ∈ Γ(x) H ).</p><p>At all times during the execution, the contents of each memory address must correspond to the typing constraints of the home to which it belongs. We say that such a memory is well-formed (written WF (MH )), a property defined as follows:</p><formula xml:id="formula_6">WF (MH ) def = ∀h ∈ H * . ∀i ∈ N. 0 ≤ i &lt; size(h) ⇒ (kind(h) = Untyped ⇒ M (h + i) ∈ DYNAMIC H ∧ kind(h) = Typed (τ ) ⇒ M (h + i) ∈ τ H )</formula><p>There are several reasons why the evaluation of an expression or a command can fail. The most obvious is that a boxed run-time check can fail. We actually consider this to be safe behavior. Another reason for failure is that operands can evaluate to unexpected values, such as if the second operand of ⊕ evaluates to a value of the form h, n . The third reason is that the operations on memory are undefined if they involve invalid addresses. We state below two theorems saying essentially that the last two reasons for failure cannot happen in well-typed CCured programs.</p><p>In order to state a progress theorem we want to distinguish between executions that stop because memory safety is violated (i.e. trying to access an invalid memory location) and executions that stop because of a failed run-time check (the boxed hypotheses in the rules of Figure <ref type="figure" target="#fig_5">6</ref>). We accomplish this by introducing a new possible outcome of evaluation. We say that Σ, M e ⇓ CheckFailed when one of the run-time checks fails during the evaluation of the expression e. Similarly, we say that Σ, M c =⇒ CheckFailed when the execution of the command c results in a failed run-time check. Technically, this means that we add derivation rules that initiate the CheckFailed result when one of the run-time check fails and also rules that propagate the CheckFailed outcome from the subexpressions to the enclosing expression. Expressions and commands: safety. They also imply that well-typed computations of nondynamic type are type preserving, similar to corresponding results for a type-safe language. This means that CCured is memory safe and is also type safe for the non-dynamic fragment.</p><formula xml:id="formula_7">Γ e1 : τ ref q → C1 Γ e2 : int → C2 Γ e1 ⊕ e2 : τ ref q → C1 ∪ C2 ∪ {q = SAFE} Γ e : τ → C τ ≤ τ → C Γ (τ )e : τ → C ∪ C Γ (τ ref q)0 : τ ref q → ∅ Γ e : τ ref q → C Γ ! e : τ → C Γ e1 : τ ref q → C1 Γ e2 : τ2 → C2 τ2 ≤ τ → C3 Γ e1 := e2 → C1 ∪ C2 ∪ C3 Convertibility: τ ≤ int → ∅ int ≤ τ ref q → {q = SAFE} τ1 ref q1 ≤ τ2 ref q2 → {q1 q2} ∪ {q1 = q2 = DYNQ ∨ τ1 ≈ τ2}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Type Inference</head><p>So far we have considered the case of a program that is written using the CCured type system. Our implementation does allow the programmer to write such programs directly in C with the pointer kinds specified using the attribute keyword of GCC. But our main goal is to be able to use CCured with existing, un-annotated C programs. For this purpose we have designed and implemented a type inference algorithm that, given a C program, constructs a set of pointer-kind qualifiers that make the program well-typed in the CCured type system. Our inference algorithm can operate either on the whole program, or on modules whose interfaces have been annotated with pointer-kind qualifiers. We rely on the fact that the C program already uses types of the form "τ ref". All we need is to discover for each occurrence of the pointer type constructor whether it should be safe, sequence or dynamic. To describe the inference algorithm we extend the CCured type language with the pointer type "τ ref q", where q is a qualifier variable ranging over the set of qualifier values {SAFE, SEQ, DYNQ} (where DYNQ is the qualifier associated with the DYNAMIC type).</p><p>The inference algorithm starts by introducing a qualifier variable for each syntactic occurrence of the pointer type constructor in the C program. We then scan the program and collect a set of constraints on these qualifier variables. Next we solve the system of constraints to produce a substitution S of qualifier variables with qualifier values and finally we apply the substitution to the types in the C program to produce a CCured program.</p><p>The substitution S is applied to types using the following rules:</p><formula xml:id="formula_8">S(int) = int S(τ ref q) = DYNAMIC if S(q) = DYNQ S(τ ) ref S(q) otherwise</formula><p>Note that when the qualifier q is substituted with DYNQ we ignore the referenced type (τ ) of the pointer, which is consistent with the idea that for the dynamic pointers we should not count on the declared referenced type. DYNAMIC pointers never point to typed areas and thus the inference algorithm is designed to infer only DYNQ qualifiers in the referenced types of DYNQ pointers.</p><p>The overall strategy of inference is to find as many SAFE and SEQ pointers as possible. Simply making all qualifiers DYNQ yields always a well-typed solution, but SAFE and SEQ pointers are preferred.</p><p>1. Constraint Collection. We collect constraints using a modified typing judgment written Γ e : τ → C and meaning that by scanning the expression e in context Γ we inferred type τ along with a set of constraints C. We also use the auxiliary judgments τ ≤ τ → C to collect constraints corresponding to the convertibility relation, and Γ c → C to express constraint collection from commands. The intent is that a solution to the set of constraints C, when applied as a substitution to the elements appearing before the symbol →, yields a valid typing judgment of the corresponding syntactic form in CCured. The rules for the constraint collection judgments are shown in Figure <ref type="figure" target="#fig_7">7</ref>.</p><p>The constraints for pointer arithmetic are fairly straightforward and those for casts are expressed as a separate convertibility judgment. For memory reads and writes, we must bridge the gap between the rules of C and the rules of CCured. Specifically, we allow memory access through SEQ (not just SAFE ) pointers, and we allow ints to be read or written through DYNAMIC pointers. In both cases, an implicit cast is inserted to yield a valid CCured program. In a memory write we allow for a conversion of the value being written to the type of the referenced type.</p><p>To express the convertibility constraints in a concise way we introduce a convertibility relation on qualifier values, which essentially says SEQ can be cast to SAFE:</p><formula xml:id="formula_9">q q def = q = q ∨ (q = SEQ ∧ q = SAFE)</formula><p>Finally, to capture the requirement that all DYNAMIC pointers point only to dynamically typed areas, for each type of the form τ ref q ref q we collect a POINTSTO constraint q = DYNQ ⇒ q = DYNQ.</p><p>After constraint generation we end up with a set containing the following four kinds of constraints: ARITH: q = SAFE CONV: q q POINTSTO: q = DYNQ ⇒ q = DYNQ TYPEEQ: q = q = DYNQ ∨ τ1 ≈ τ2</p><p>The constraint τ1 ≈ τ2 requires that a valid solution is a substitution S that makes the types S(τ1) and S(τ2) identical. This notion is made more precise below.</p><p>2. Constraint Normalization. The next step is to normalize the generated constraints into a simpler form. Notice that the system of constraints we have generated so far has conditional constraints. The POINTSTO constraints are easy to handle because we can ignore them as long as the qualifier q on the left is unknown, and if it becomes DYNQ, we add the constraints "q = DYNQ" to the system of constraints. If q remains unknown at the end of the normalization process we will make it SAFE or SEQ.</p><p>However, the same is not true of the TYPEEQ constraints. If we postpone such constraints and the qualifiers involved remain unconstrained we would like to make them both SAFE or SEQ (to mimimize the number of DYNAMIC pointers). But to do that we must introduce in the system the type equality constraint, which might lead to contradictions that require backtracking. Fortunately there is a simple solution to this problem. We start by simplifying the TYPEEEQ constraint based on the possible forms of the types τ1 and τ2:</p><formula xml:id="formula_10">q = q = DYNQ ∨ int ≈ int → ∅ q = q = DYNQ ∨ int ≈ τ2 ref q2 → {q = DYNQ, q = DYNQ} q = q = DYNQ ∨ τ1 ref q1 ≈ int → {q = DYNQ, q = DYNQ} q = q = DYNQ ∨ τ1 ref q1 ≈ τ2 ref q2 → {q = q } ∪ C where q1 = q2 = DYNQ ∨ τ1 ≈ τ2 → C</formula><p>The only subtlety is in the last rule. We observe that a constraint of the form "q = q = DYNQ ∨ τ1 ref q1 ≈ τ2 ref q2" arises only when the types "τ1 ref q1 ref q" and "τ2 ref q2 ref q " appear in the program. This means that the following POINTSTO constraints also exist:</p><formula xml:id="formula_11">q = DYNQ ⇒ q1 = DYNQ q = DYNQ ⇒ q2 = DYNQ</formula><p>This in turn means that the disjunct q = q = DYNQ in the last reduction rule is redundant and can be eliminated.</p><p>After simplifying all TYPEQ constraints, the normalized system has only the following kinds of constraints:</p><formula xml:id="formula_12">ARITH: q = SAFE CONV:</formula><p>q q POINTSTO: q = DYNQ ⇒ q = DYNQ ISDYN: q = DYNQ EQ: q = q 3. Constraint Solving. The final step in our algorithm is to solve the remaining set of constraints. The algorithm is quite simple: 3.1 Propagate the ISDYN constraints using the constraints EQ, CONV, and POINTSTO. After this is done all the other qualifier variables can be made SEQ or SAFE, as follows:</p><p>3.2 All qualifier variables involved in ARITH constraints are set to SEQ and this information is propagated using the constraints EQ and CONV (in this latter case the SEQ information is propagated only from q to q, or against the direction of the cast).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.3</head><p>We make all the other variables SAFE.</p><p>Essentially, we find first the minimum number of DYNQ qualifiers. Among the remaining qualifiers we find those on which pointer arithmetic is performed and we make them SEQ, and the remaining qualifiers are SAFE. This solution is the best one possible in terms of maximizing the number of SAFE and SEQ pointers.</p><p>The whole type inference process is linear in the size of the program. A linear number of qualifier variables is introduced (one for each syntactic occurrence of a pointer type constructor), then a linear number of constraints is created (one for each cast or memory read or write in the program). During the simplification of the TYPEQ constraints the number of constraints can get multiplied by the maximum nesting depth of a qualifier in a type. Finally, constraint solving is linear in the number of constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Handling the Rest of C</head><p>In the interest of clarity we have formalized in this paper only a small subset of the CCured dialect of C. Our implementation handles the entire C programming language along with most of the extensions in the GNU C dialect. In this section we discuss informally how we handle the rest of the C programming language. The full details are presented in a forthcoming paper.</p><p>In the DYNAMIC world, structures and arrays are simply alternative notations for saying how many bytes of storage to allocate. In the SAFE world, structures accesses are required to respect the types of all fields. For example, it is possible to have a SAFE pointer to a structure field, but you cannot perform arithmetic on such a pointer. We treat unions as syntactic sugar for casts.</p><p>Explicit deallocation is currently ignored, and the Boehm-Weiser conservative garbage collector <ref type="bibr" target="#b2">[3]</ref> is used to reclaim storage. However, the CCured system maintains enough type information to allow the use of a precise collector; this may be future work.</p><p>The address-of operator in C can yield a pointer to a stackallocated variable. The variable to which the pointer points may be inferred to live in the DYNAMIC or SAFE worlds, depending on how the pointer is used. The only difficulty is that the storage will be deallocated when the function returns, so the CCured run-time checks ensure no stack pointer ever gets written into the heap or globals. This restriction allows the common use of address-of to implement call-byreference; for other uses, the storage in question may have to be allocated on the heap instead.</p><p>DYNAMIC function pointers and variable-argument functions are also handled in CCured, by passing a hidden argument which specifies the types of all arguments passed. The hidden argument is then checked in the callee, and parameters interpreted accordingly. Among other things, this level of checking is sufficient to detect format string errors.</p><p>Certain C library functions must be handled specially. Several functions (of which malloc is the most important) are treated polymorphically, lest all dynamically-allocated data be marked DYNAMIC. A few others impose constraints on argument qualifiers: e.g., memcpy internally does pointer arithmetic, and hence cannot accept SAFE pointers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Source Changes</head><p>The CCured type system and inference algorithm are designed to minimize the amount of source changes required to conform to its restrictions. However, there are still a few cases in which legal C programs will stop with a failed runtime check. In those cases manual intervention is necessary.</p><p>One common situation is when the program stores a pointer in a variable declared to hold an integer, then casts it back to a pointer and dereferences the pointer. In some cases, it suffices to change the variable's declaration from from (say) unsigned long to void*. This type will certainly be marked DYNAMIC, but it will work. For other programs, we may be able to replace casts with pointer arithmetic. For example, if e is a sequence or dynamic pointer expression then the legal CCured expression "e ⊕ (n -(int)e)" is effectively a cast of the integer n to a pointer (with the same home as e). As a last resort, it is possible to query the garbage collector at run time to find the home and type of any pointer, but so far this has not been necessary.</p><p>Another problem in otherwise legal C code is the interaction between sizeof and our fat pointers: one must change occurrences of sizeof(type) to sizeof(expression), whenever type contains pointers. A typical example, allocating an array of 5 integer pointers, is int **p = (int**)malloc(5 * sizeof(int*)); This code will always allocate space for 5 SAFE pointers, even if p is inferred to point to SEQ or DYNAMIC pointers. This code must be changed to int **p = (int**)malloc(5 * sizeof(*p)); so the size passed to malloc is related to the size of *p.</p><p>While most uses of address-of are to implement call-byreference, some programs attempt to store stack pointers into memory. Among the programs we have compiled with CCured, only two (the SPECINT95 benchmarks li and ijpeg) do this. The solution is to annotate certain local variables with a qualifier that causes them to be allocated on the heap. For li, which makes fairly extensive use of this feature, this results in a performance penalty of about 25%.</p><p>When CCured changes the representation of pointers, this can lead to problems when calling functions in libraries that were not compiled with CCured. The typical solution is to write wrapper functions which translate between two-word and one-word arguments and return values. The wrapper must do the run-time checks assocated with the pointers, before passing them to the underlying library.</p><p>The wrapper solution works well for the standard C library. However, we expect to encounter difficulties when interoperating with third-party libraries whose interface involves passing pointers to large structures which themselves contain pointers. We are experimenting with an alternative implementation scheme in which the bookkeeping information for sequence and dynamic pointers that escape the CCured world are kept in a global table so that we do not have to change the representation of exported data structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Experiments</head><p>We ran though our translator several C programs ranging in size from 400 (treeadd) to 30,000 (ijpeg) lines of code (including whitespace and comments), with several goals. First, we wanted to measure the performance impact of the run-time checks introduced by our translator. Second, we wanted to see how effective our inference system is at eliminating these checks. Finally, we investigated what changes to the program source are required to make the program run under the CCured restrictions.</p><p>We used several test cases, some from SPECINT95 <ref type="bibr" target="#b25">[26]</ref>: compress is LZW data compression; go plays the board game Go; ijpeg compresses image files; li is a Lisp interpreter; and some from the Olden benchmark suite <ref type="bibr" target="#b5">[6]</ref>, a collection of small, compute-intensive kernels: bh is an n-body simulator; bisort is a sorting algorithm; em3d solves an elecromagnetism problem; health simulates Colombia's health care system; mst computes minimum spanning trees; perimeter computes perimeters of regions in images; power simulates power market prices; treeadd simply builds a binary tree; tsp uses a greedy algorithm to approximately solve random Traveling Salesman Problem instances; and voronoi constructs Voronoi diagrams.</p><p>Most of the source changes needed to run these benchmarks were simple syntactic adjustments, such as adding (or correcting) prototypes and marking printf-like functions. A few benchmarks required changing sizeof (prevalent in ijpeg) or moving locals into the heap (for li). No program required changes to the data structures or other basic design elements. A number of remaining bugs in our implementation prevents us from applying CCured to the other benchmarks in the SPECINT95 suite.</p><p>The running time (median of five) of each of the benchmarks is shown in Figure <ref type="figure">8</ref>. The measurements were made on an otherwise quiescent 1GHz AMD Athlon, 768MB Linux machine, using the gcc-2.95.3 compiler with -O2 or -O3 optimization level (depending on benchmark size).</p><p>In all cases the pointer kind inference was performed over the whole program. However, because inference time is linear in the size of the program (as argued in Section 6), we have not observed scalability problems with our wholeprogram approach. In fact, our biggest scalability problem is with the optimizer in the C compiler that consumes our output (presented as a single, large C source file).</p><p>Most of the benchmarks have between 30% and 150% slowdown. To measure the effectiveness of our inference al- gorithm we used CCured with a naive inference algorithm that makes all pointers DYNAMIC. The slowdown in this case is more significant (6 to 20 times slower) and it approaches that reported by other researchers <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19]</ref> who tried an allrun-time-checks approach to memory safety for C. For example, the most pointer-intensive benchmark is li, which runs 16 times slower if all pointers are blindly marked DYNAMIC; however, once the inference discovers that all the pointers are SAFE or SEQ, it is only twice as slow.</p><p>Program size has a big influence on how many of the pointers can be statically verified. Small programs like the Olden benchmark suite tend to have few data types, and they are used in straightforward ways. Large programs, especially those designed to be extended in the future, use pointers in many ways. In the case of ijpeg, it uses object-oriented downcasts throughout, and thus a large number of the pointers become DYNAMIC.</p><p>We discovered and fixed several bugs in the SPECINT95 benchmarks: compress and ijpeg each contain one array bounds violation, and go has (at least) eight array bounds violations and one use of an uninitialized integer variable as an array index. In each case we verified that fixing the bug did not change the program's eventual output (for the test vectors considered), which partially explains how these bugs survived for so long in otherwise well-tested programs.</p><p>Most of the bugs in go involved erroneous index arithmetic within large, multi-dimensional arrays. Finding these bugs demonstrates an advantage of our type-sensitive approach. If we simply marked all home areas as untyped, and only checked for errors when a pointer strayed out of its home area, we would miss errors that happen to stay within the intended home area. While we were originally motivated by performance to discover safe pointers, we found that doing so enhanced our bug-finding ability too.</p><p>The last column in Figure <ref type="figure">8</ref> shows the slowdown of these programs when instrumented with Purify (version 2001A) <ref type="bibr" target="#b9">[10]</ref>, a tool that instruments existing C binaries to detect memory errors and leaks by keeping two bits of storage for each byte in the heap (unallocated, uninitialized and initialized). However, Purify does not catch pointer arithmetic that yields a pointer to a separate valid region <ref type="bibr" target="#b12">[13]</ref>, a property that Fischer and Patil <ref type="bibr" target="#b19">[20]</ref> show to be important. Purify tends to slow programs down by a factor of 10 or more, much more than CCured. Of course, Purify does not require source code, so may be applicable in more situations. Purify did find the uninitialized variable in go, but none of the other bugs, because the accesses in question did not stray far enough to be noticed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Related Work</head><p>Abadi et al. <ref type="bibr" target="#b0">[1]</ref> study the theoretical aspects of adding a Dynamic type to the simply-typed λ-calculus and discuss extensions to polymorphism and abstract data types. Thatte <ref type="bibr" target="#b27">[28]</ref> extends their system to replace the typecase expressions with implicit casts. Their system does not handle reference types or memory updates and Dynamic types are introduced to add flexibility to the language. In contrast our system was designed to handle memory reads and writes, allows DYNAMIC values to be manipulated (e.g., via pointer arithmetic) without checking their tags, and uses DYNAMIC types to guarantee the safety of code that cannot be statically verified.</p><p>Chandra and Reps <ref type="bibr" target="#b7">[8]</ref> present a method for physical type checking of C programs based on structure layout in the presence of casts. Their inference method can reason about casts between various structure types by considering the physical layout of memory. Our example in Section 2 would fail to type check in their system for the same reason that we must mark some of the pointers DYNAMIC: its safety cannot be guaranteed at compile time. Siff et al. <ref type="bibr" target="#b23">[24]</ref> identify that many casts in C programs are safe upcasts and present a tool to check such casts.</p><p>The programming languages CLU <ref type="bibr" target="#b16">[17]</ref>, Cedar/Mesa <ref type="bibr" target="#b15">[16]</ref> and Modula-{2+,3} <ref type="bibr" target="#b4">[5]</ref> include similar notions of a dynamic type and a typecase statement. This idea can also be seen in CAML's exception type <ref type="bibr" target="#b21">[22]</ref>.</p><p>Other related work in this area falls into three broad categories: (1) extensions to C's type system, (2) adding runtime checks to C, and (3) removing run-time checks from LISP.</p><p>Previous efforts to extend C's type system usually deal with polymorphism. Smith et al. <ref type="bibr" target="#b24">[25]</ref> present a polymorphic and provably type-safe dialect of C that includes most of C's features (and higher-order functions, which our current system handles weakly) but lacks casts and structures. Evans <ref type="bibr" target="#b8">[9]</ref> describes a system in which programmer-inserted annotations and static checking techniques can find errors and anomalies in large programs. Ramalingam et al. <ref type="bibr" target="#b20">[21]</ref> have presented an algorithm for finding the coarsest acceptable type for structures in C programs. Most such type systems and inference methods are presented as sources of information. In this paper we present a type and inference system with the goal of making programs safe.</p><p>There have been many attempts to bring some measure of safety to C in the past by trading space and speed for security. Previous techniques have been concerned with spatial access errors (array bounds checks and pointer arithmetic) and temporal access errors (touching memory that has been freed) but none of them use a static analysis of the form presented here. Kaufer et al. <ref type="bibr" target="#b13">[14]</ref> present an interpretive scheme called Saber-C that can detect a rich class of errors (including uninitialized reads and dynamic type mismatches but not all temporal access errors) but runs about 200 times slower than normal. Austin et al. <ref type="bibr" target="#b1">[2]</ref> store extra information with each pointer and achieve safety at the cost of a large (up to 540% speed and 100% space) overhead and a lack of backwards compatibility. Jones and Kelly <ref type="bibr" target="#b12">[13]</ref> store extra information for run-time checks in a splay tree, allowing safe code to work with unsafe libraries. This results in a slowdown factor of 5 to 6. Fischer and Patil have presented a system that uses a second processor to perform the bounds checks <ref type="bibr" target="#b18">[19]</ref>. The total execution overhead of a program is typically only 5% using their technique but it requires a dedicated second processor. Loginov et al. <ref type="bibr" target="#b17">[18]</ref> store type information with each memory location, incurring a slowdown factor of 5 to 158. This extra information allows them to perform more detailed checks and they can detect when stored types mismatch declared types or union members are accessed out of order. While their tool and ours are similar in many respects their goal is to provide rich debugging information and ours is to make C programs safe while retaining efficiency. Steffen's rtcc compiler <ref type="bibr" target="#b26">[27]</ref> is portable and adds object attributes to pointers but fails to detect temporal access errors and does not perform any check optimizations. In fact, beyond array bounds check elimination, none of these techniques use type-based static analysis to aggressively reduce the overhead of the instrumented code.</p><p>Finally, much work has been done to remove dynamic checks and tagging operations from LISP-like languages. Henglein <ref type="bibr" target="#b10">[11]</ref> details a type inference scheme to remove tagging and untagging operations in LISP-like languages. The overall structure of his algorithm is very similar to ours (simple syntax-direct constraint generation, constraint normalization, constraint solving) but the domain of discourse is quite different because his base language is dynamically typed. In Henglein's system each primitive type constructor is associated with exactly one tag, so there is no need to deal with the pointer/array ambiguity that motivates our SEQ pointers. In C it is sometimes necessary to allocate an object as having a certain type and later view it as having another type: Henglein's system disallows this because tags are set at object creation time (that is, true C-style casts or unions are not fully supported <ref type="bibr" target="#b11">[12]</ref>). Henglein is also able to sidestep update and aliasing issues because tagging and untagging create a new copy of the object (to which set! can be applied, for example) so one never has tagged and untagged aliases for the same item. His algorithm does not consider polymorphism or module compilation <ref type="bibr" target="#b14">[15]</ref>. The CCured system uses a form of physical subtyping for pointers to structures and it is not clear how to extend Henglein's constraint normalization procedure in such a case. Jagannathan et al. <ref type="bibr" target="#b11">[12]</ref> use a more expensive and more precise flow-sensitive analysis called polymorphic splitting to eliminate run-time checks from higher-order call-by-value programs. Shields et al. <ref type="bibr" target="#b22">[23]</ref> present a system in which dynamic typing and staged computation (run-time code generation) coexist: all deferred computations have the same dynamic type at compile-time and can be checked precisely at run-time. Such a technique can handle persisting dynamic data, a weakness of our current system. Soft type systems <ref type="bibr" target="#b6">[7]</ref> also infer types for procedures and data structures in dynamically-typed programs. Advanced soft type systems <ref type="bibr" target="#b29">[30]</ref> can be based on inclusion subtyping and can handle unions, recursive types and other complex language features. Finally, <ref type="bibr" target="#b14">[15]</ref> presents a practical ML-style type inference system for LISP. As with Henglein <ref type="bibr" target="#b10">[11]</ref>, such systems start with a dynamically typed language and thus tackle a different core problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">Conclusion and Future Work</head><p>The C programming language is the language of choice for systems programming because of its flexibility and control over the layout of data structures and the use of pointers. Unfortunately, this comes at the expense of type safety. In this paper we propose a scheme that combines program analysis and run-time checking to bring type safety to existing C programs by trading off some performance.</p><p>The key insight of this work is that even in C programs most pointers are used in such a way that they can be verified to be type safe using typing rules similar to those of strongly typed languages. Furthermore the rest of the pointers can be checked at run-time to ensure that they are indeed used safely. The entire approach hinges on the ability to infer accurately which pointers need to be checked at run time and which do not. We present a surprisingly simple type inference algorithm that is able to do just that.</p><p>Perhaps the most surprising result of our experiments is that in many C programs most pointers are perfectly safe (and our inference is able to discover that), which means that those programs are just as safe as if they had been written in a type-safe language. Consequently the cost of enforcing safety for many C programs is relatively low and even with a prototype implementation we were able to achieve overheads several times smaller than those of comparable tools that rely exclusively on run-time checking.</p><p>The two flavors of typed pointers that we present in this paper cover many of the programming paradigms encountered in C programs. But there are still other operations on pointers that could be statically proven safe, which our type system fails to recognize. The most important example is tagged union types with incompatible members, which the current CCured system flags as untyped; a special case is object-oriented "downcasts," used heavily by ijpeg. To handle these situations without resorting to the DYNAMIC sledgehammer, it would be useful to have a more expressive language of pointer types than our current system provides.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Summary of the properties and capabilities of various kinds of pointers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The syntax of a simple language with pointers, pointer arithmetic and casts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>12 } 13 pFigure 4 :</head><label>12134</label><figDesc>Figure 4: The program from Figure 1, translated to CCured.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Γ</head><label></label><figDesc>e : τ ref SAFE Γ e : τ Γ e := e Γ e : DYNAMIC Γ e : DYNAMIC Γ e := e Convertibility:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The typing judgments.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The operational semantics. The boxed premises are the run-time checks that CCured uses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Theorem 1 (</head><label>1</label><figDesc>Progress and type preservation) If Γ e : τ and Σ ∈ Γ H and WF (MH ) then either Σ, MH e ⇓ CheckFailed or else Σ, MH e ⇓ v and v ∈ τ H . Theorem 2 (Progress for commands) If Γ c and Σ ∈ Γ H and WF (MH ) then either Σ, MH c =⇒ CheckFailed or else Σ, MH c =⇒ M H and WF (M H ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Constraint generation rules.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Expressions:Γ(x) = τ Γ x : τ Γ n : int Γ e1 : int Γ e2 : int Γ e1 op e2 : int Γ e : τ τ ≤ τ Γ (τ )e : τ Γ (τ ref SAFE)0 : τ ref SAFE Γ e1 : τ ref SEQ Γ e2 : int Γ e1 ⊕ e2 : τ ref SEQΓ e1 : DYNAMIC Γ e2 : int Γ e1 ⊕ e2 : DYNAMIC Γ e : τ ref SAFE Γ ! e : τ Γ e : DYNAMIC Γ ! e : DYNAMIC Commands: Γ skip Γ c1 Γ c2 Γ c1; c2</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>The proofs of these theorems are fairly straightforward inductions on the structure of the typing derivations. Note that the progress theorems state more than just memory</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">Acknowledgments</head><p>We would like to thank Alex Aiken and Jeff Foster for useful comments on earlier drafts of this paper and also Raymond 138 To, Aman Bhargava, S. P. Rahul, and Danny Antonetti for helping with the implementation of the CCured system.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research was supported in part by the National Science Foundation Career Grant No. CCR-9875171, and ITR Grants No. CCR-0085949 and No. CCR-0081588, Air Force contract no. F33615-00-C-1693, and gifts from AT&amp;T Research and Microsoft Research. The information presented here does not necessarily reflect the position or the policy of the Government and no official endorsement should be inferred.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Dynamic typing in a statically typed language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="237" to="268" />
			<date type="published" when="1991-04">April 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient detection of all pointer and array access errors</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Breach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN &apos;94 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN &apos;94 Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1994-06">June 1994</date>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="290" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Garbage collection in an uncooperative environment. Software-Practice and Experience</title>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Boehm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weiser</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-09">Sept. 1997</date>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="807" to="820" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Computing with coercions</title>
		<author>
			<persName><forename type="first">V</forename><surname>Breazu-Tannen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LISP and Functional Programming</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="44" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Glassman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kalsow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<title level="m">Modula3 report</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Olden: Parallelizing Programs with Dynamic Data Structures on Distributed-Memory Machines. PhD thesis</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Carlisle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-06">June 1996</date>
		</imprint>
		<respStmt>
			<orgName>Princeton University Department of Computer Science</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Soft typing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cartwright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the &apos;91 Conference on Programming Language Design and Implementation</title>
		<meeting>the &apos;91 Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="278" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Physical type checking for C</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
		<idno>24.5</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering</title>
		<meeting>the ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999-06">Sept. 6 1999</date>
			<biblScope unit="page" from="66" to="75" />
		</imprint>
	</monogr>
	<note>of Software Engeneering Notes (SEN)</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Static detection of dynamic memory errors</title>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="44" to="53" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Purify: Fast detection of memory leaks and access errors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hastings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Joyce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Usenix Winter 1992 Technical Conference</title>
		<meeting>the Usenix Winter 1992 Technical Conference<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-01">Jan. 1991</date>
			<biblScope unit="page" from="125" to="138" />
		</imprint>
	</monogr>
	<note>Usenix Association</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Global tagging optimization by type inference</title>
		<author>
			<persName><forename type="first">F</forename><surname>Henglein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1992 ACM Conference on LISP and Functional Programming</title>
		<meeting>the 1992 ACM Conference on LISP and Functional Programming</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="205" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Effective flow analysis for avoiding run-time checks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jagannathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Static Analysis Symposium</title>
		<meeting>the Second International Static Analysis Symposium</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">983</biblScope>
			<biblScope unit="page" from="207" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Backwards-compatible bounds checking for arrays and pointers in C programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H J</forename><surname>Kelly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AADEBUG</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Saber-C: an interpreterbased programming environment for the C language</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kaufer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lopez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pratap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Summer Usenix Conference</title>
		<meeting>the Summer Usenix Conference</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="161" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A practical approach to type inference for EuLisp</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Friedrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Lisp and Symbolic Computation</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="159" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A description of the Cedar language</title>
		<author>
			<persName><forename type="first">B</forename><surname>Lampson</surname></persName>
		</author>
		<idno>CSL-83-15</idno>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
		<respStmt>
			<orgName>Xerox Palo Alto Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Atkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bloom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schaffert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Snyder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
		<respStmt>
			<orgName>CLU Reference Manual</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Debugging via run-time type checking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Loginov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Horwitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FASE 2001: Fundamental Approaches to Software Engineering</title>
		<meeting>FASE 2001: Fundamental Approaches to Software Engineering</meeting>
		<imprint>
			<date type="published" when="2001-04">Apr. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient run-time monitoring using shadow processing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated and Algorithmic Debugging</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="119" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Low-cost, concurrent checking of pointer and array accesses in C programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software-Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="87" to="110" />
			<date type="published" when="1997-01">Jan. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Aggregate structure identification and its application to program analysis</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ramalingam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Field</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tip</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1999-01">Jan. 1999</date>
			<biblScope unit="page" from="119" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Objective ML: A simple objectoriented extension of ML</title>
		<author>
			<persName><forename type="first">D</forename><surname>Remy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vouillon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="40" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Dynamic typing as staged type inference</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shields</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sheard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L P</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="289" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Coping with type casts in C</title>
		<author>
			<persName><forename type="first">M</forename><surname>Siff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kunchithapadam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Engineering Conference (LNCS 1687)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag / ACM Press</publisher>
			<date type="published" when="1999-09">1999. September 1999</date>
			<biblScope unit="volume">1687</biblScope>
			<biblScope unit="page" from="180" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A sound polymorphic type system for a dialect of C</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="49" to="72" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Standard Performance Evaluation Corportation Benchmarks</title>
		<ptr target="http://www.spec.org/osg/cpu95/CINT95" />
	</analytic>
	<monogr>
		<title level="m">SPEC 95</title>
		<imprint>
			<date type="published" when="1995-07">July 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Adding run-time checking to the Portable C Compiler</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Steffen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software-Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="305" to="316" />
			<date type="published" when="1992-04">Apr. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Quasi-static typing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thatte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference record of the 17th ACM Symposium on Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="367" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A first step toward automated detection of buffer overrun vulnerabilities</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network Distributed Systems Security Symposium</title>
		<imprint>
			<date type="published" when="2000-02">Feb. 2000</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A practical soft type system for Scheme</title>
		<author>
			<persName><forename type="first">A</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cartwright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
