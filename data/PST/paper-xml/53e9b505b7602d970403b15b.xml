<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Algorithmic Meta-theorems for Restrictions of Treewidth</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-07-30">30 July 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Michael</forename><surname>Lampis</surname></persName>
							<email>mlampis@gc.cuny.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Computer Science Department</orgName>
								<orgName type="department" key="dep2">Graduate Center</orgName>
								<orgName type="institution">City University of New York</orgName>
								<address>
									<settlement>New York</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Algorithmic Meta-theorems for Restrictions of Treewidth</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-07-30">30 July 2011</date>
						</imprint>
					</monogr>
					<idno type="MD5">97231C3C32F9DF5938E920E54B79D01F</idno>
					<idno type="DOI">10.1007/s00453-011-9554-x</idno>
					<note type="submission">Received: 31 October 2010 / Accepted: 14 July 2011 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Possibly the most famous algorithmic meta-theorem is Courcelle's theorem, which states that all MSO-expressible graph properties are decidable in linear time for graphs of bounded treewidth. Unfortunately, the running time's dependence on the formula describing the problem is in general a tower of exponentials of unbounded height, and there exist lower bounds proving that this cannot be improved even if we restrict ourselves to deciding FO logic on trees.</p><p>We investigate whether this parameter dependence can be improved by focusing on two proper subclasses of the class of bounded treewidth graphs: graphs of bounded vertex cover and graphs of bounded max-leaf number. We prove stronger algorithmic meta-theorems for these more restricted classes of graphs. More specifically, we show it is possible to decide any FO property in both of these classes with a singly exponential parameter dependence and that it is possible to decide MSO logic on graphs of bounded vertex cover with a doubly exponential parameter dependence. We also prove lower bound results which show that our upper bounds cannot be improved significantly, under widely believed complexity assumptions. Our work addresses an open problem posed by Michael Fellows. Keywords Vertex cover • Max-leaf number • MSO logic • Courcelle's theorem 1 Introduction Algorithmic metatheorems are general statements of the form "All problems sharing property P, restricted to a class of inputs I can be solved efficiently". The archetypal, and possibly most celebrated, such metatheorem is Courcelle's theorem which states A preliminary version of this paper appeared in ESA 2010. M. Lampis ( )</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>that every graph property expressible in monadic second-order (MSO 2 ) logic is decidable in linear time if restricted to graphs of bounded treewidth <ref type="bibr" target="#b5">[6]</ref>. Metatheorems have been a subject of intensive research in the last years producing a wealth of interesting results. Some representative examples of metatheorems with a flavor similar to Courcelle's can be found in the work of Frick and Grohe <ref type="bibr" target="#b16">[17]</ref>, where it is shown that all properties expressible in first order (FO) logic are solvable in linear time on planar graphs, and the work of Dawar et al. <ref type="bibr" target="#b7">[8]</ref>, where it is shown that all FO-definable optimisation problems admit a PTAS on graphs excluding a fixed minor (see <ref type="bibr" target="#b18">[19]</ref> and <ref type="bibr" target="#b19">[20]</ref> for more results on the topic). In all these works the defining property P for the problems studied is given in terms of expressibility in a logic language; in many cases metatheorems are stated with P being some other problem property, for example whether the problem is closed under the taking of minors. This approach, which is connected with the famous graph minor project of Robertson and Seymour <ref type="bibr" target="#b24">[25]</ref> has also led to a wealth of significant and practical results, including the so called bi-dimensionality theory (see <ref type="bibr" target="#b8">[9]</ref> for an overview and also the recent results of <ref type="bibr" target="#b1">[2]</ref>).</p><p>In this paper we focus on the study of algorithmic metatheorems in the spirit of Courcelle's theorem, where the class of problems we attack is defined in terms of expressibility in a logic language. In this research area, many interesting extensions have followed Courcelle's seminal result: for instance, Courcelle's theorem has been extended to logics more suitable for the expression of optimisation problems <ref type="bibr" target="#b0">[1]</ref>. It has also been investigated whether it's possible to obtain similar results for larger graph classes (see <ref type="bibr" target="#b6">[7]</ref> for a metatheorem for bounded cliquewidth graphs, <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> for corresponding hardness results and <ref type="bibr" target="#b22">[23]</ref> for hardness results for graphs of small but unbounded treewidth). Finally, lower bound results have been shown proving that the running times predicted by Courcelle's theorem can not be improved significantly in general <ref type="bibr" target="#b17">[18]</ref>.</p><p>This lower bound result is one of the main motivations of this work, because in some ways it is quite devastating. Though Courcelle's theorem shows that a vast class of problems is solvable in linear time on graphs of bounded treewidth, the "hidden constant" in this running time, that is, the running time's dependence on the input's other parameters, which are the graph's treewidth and the formula describing the problem, is in fact (in the worst case) a tower of exponentials. Unfortunately, in <ref type="bibr" target="#b17">[18]</ref> it is shown that this tower of exponentials is unavoidable even if we restrict ourselves to deciding FO logic on trees.</p><p>In this paper our aim is to investigate if it is possible to go around this harsh lower bound by restricting the considered class of input graphs further. In other words, we are looking for meta-theorems which would imply that all of FO or MSO logic can be solved in time not only linear in the size of the graph, but also depending more reasonably on the secondary parameters, if we are willing to give up some of the generality of the class of bounded-treewidth graphs. We concentrate on two graph classes: graphs of bounded vertex cover and graphs of bounded max-leaf number. We note that the investigation of the existence of stronger meta-theorems for these classes has been posed explicitly as an open problem by Fellows in <ref type="bibr" target="#b10">[11]</ref>.</p><p>Though graphs of bounded vertex cover or max-leaf number are considerably more restricted than bounded treewidth graphs, these classes are still interesting from the algorithmic point of view and the complexity of hard problems parameterized by vertex cover or max-leaf number has been investigated in the past <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>. Furthermore, as mentioned, strong lower bounds are known to apply to slightly more general classes: for bounded feedback vertex set and bounded pathwidth graphs even FO logic is non-elementary, while even for binary trees (thus for graphs of bounded treewidth and max degree) FO logic is at least triply exponential (again by <ref type="bibr" target="#b17">[18]</ref>). Bounded vertex cover and bounded max-leaf number evade all these lower bound arguments so it's natural to ask what is exactly the complexity of FO and MSO logic for these classes of graphs?</p><p>The main results of this paper show that meta-theorems stronger than Courcelle's can indeed be shown for these classes of graphs. In addition, we show that our metatheorems for vertex cover cannot be significantly improved under standard complexity assumptions.</p><p>Specifically, for the class of graphs of vertex cover bounded by k we show that  n) , there is no algorithm which can decide if an FO formula φ with q quantifiers holds in a graph G of vertex cover k in time f (k, q)n c , for any f (k, q) = 2 o(kq) .</p><formula xml:id="formula_0">(k) = 2 2 o(k) . -Unless n-variable 3SAT can be solved in time 2 o(</formula><p>Furthermore, for the class of graphs of max-leaf number bounded by k we show that -All graph problems expressible with an FO formula φ can be solved in time linear in the graph size, polynomial in k and singly exponential in |φ|.</p><p>Our upper bounds rely on techniques different from the standard dynamic programming on decompositions usually associated with treewidth. For max-leaf number we rely on the characterization of bounded max-leaf number graphs from <ref type="bibr" target="#b21">[22]</ref> also used heavily in <ref type="bibr" target="#b13">[14]</ref> and the fact that FO logic has limited counting power in paths. For vertex cover we exploit an observation that for FO logic two vertices that have the same neighbors are "equivalent" in a sense we will make precise. We state our results in this case in terms of a new graph "width" parameter that captures this graph property more precisely than bounded vertex cover. We call the new parameter neighborhood diversity, and the upper bounds for vertex cover follow by showing that bounded vertex cover is a special case of bounded neighborhood diversity. Our essentially matching lower bounds on the other hand are shown for vertex cover. In the last section of this paper we prove some additional results for neighborhood diversity, beyond the algorithmic meta-theorems of the rest of the paper, which we believe indicate that neighborhood diversity might be a graph structure parameter of independent interest and that its algorithmic and graph-theoretic properties may merit further investigation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Definitions and Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Model Checking, FO and MSO Logic</head><p>In this paper we will describe algorithmic meta-theorems, that is, general methods for solving all problems belonging in a class of problems. However, the presentation is simplified if one poses this approach as an attack on a single problem, the model checking problem. In the model checking problem we are given a logic formula φ, expressing a graph property, and a graph G, and we must decide if the property described by φ holds in G. In that case, we write G | φ. Clearly, if we can describe an efficient algorithm for model checking for a specific logic, this will imply the existence of efficient algorithms for all problems expressible in this logic. Let us now give more details about the logics we will deal with and the graphs which will be our input instances.</p><p>Our universe of discourse will be labeled, colored graphs. Specifically, we assume that the first part of the input is an undirected graph G(V , E), a set of labels L, each associated with a vertex of V and a set of subsets of V , C = {C 1 , C 2 , . . . , C c }, which we refer to as color classes. Note that it could be the case that several labels are assigned to the same vertex and that some vertex belongs in several color classes. The interesting case here is unlabeled, uncolored graphs (that is, L = C = ∅), but the additional generality in the definition of the problem makes it easier to describe a recursive algorithm. We include labels in our definition to allow our formulas to refer to some constant vertices of the input graph.</p><p>The formulas of FO logic are those which can be constructed using vertex variables, denoted usually by x i , y i , . . . , vertex labels denoted by l i , color classes denoted by C i , the predicates E(x i , x j ), x i ∈ C j , x i = x j operating on vertex variables or labels, standard propositional connectives and the quantifiers ∃, ∀ operating on vertex variables. The semantics are defined in the usual way, with the E() predicate being true if (x i , x j ) ∈ E and labels being interpreted as vertex constants corresponding to the vertices of the graph they are attached to. We also sometimes extend notation slightly by using conditional quantified variables: ∃x : ψ(x) (φ(x)) can be read as shorthand for ∃x(ψ(x) ∧ φ(x)), while ∀x : ψ(x) (φ(x)) is short for ∀x(ψ(x) → φ(x)).</p><p>For MSO logic the additional property is that we now introduce set variables denoted by X i and allow the quantifiers and the ∈ predicate to operate on them. The semantics are defined in the obvious way. If the set variables are allowed to range over sets of vertices only, then the logic is referred to as MSO 1 .</p><p>A variation is MSO 2 logic. Here, first-order variables are allowed to range over vertices or edges, and second-order variables range over sets of vertices or edges. To keep the presentation simple we will use the letters e i , F i for variables which range over edges and sets of edges respectively and we assume that it is clear from the context what domain each variable is quantified over. We also add the incidence predicate I (v, e) which is true if edge e is incident on vertex v. Observe that in the first-order case it does not make a difference if one also allows quantification over edges or not, because any FO formula that uses edge variables can be transformed to an equivalent formula that only uses vertex variables: one simply replaces ∃e with ∃x∃y : E(x, y) while also replacing I (v, e) with (v = x) ∨ (v = y). It is known that this is not possible with MSO in general: there exist MSO 2 expressible properties which are not expressible in MSO 1 . However, we will use such a transformation that works for graphs of small vertex cover.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Bounded Vertex Cover and Neighborhood Diversity</head><p>We will work extensively with graphs of bounded vertex cover, that is, graphs for which there exists a small set of vertices whose removal also removes all edges. We will usually denote the size of a graph's vertex cover by k. Note that there exist lineartime FPT algorithms for finding an optimal vertex cover in graphs where k is small (see e.g. <ref type="bibr" target="#b2">[3]</ref>). Recall that an algorithm is called fixed-parameter tractable (FPT) if it runs in time f (k)n O (1) for some function f of the parameter k.</p><p>Our technique relies on the fact that in a graph of vertex cover k, the vertices outside the vertex cover can be partitioned into at most 2 k sets, such that all the vertices in each set have exactly the same neighbors outside the set and each set contains no edges inside it. Since we do not make use of any other special property of graphs of small vertex cover, we are motivated to define a new graph parameter, called neighborhood diversity, which intuitively seems to give the largest graph family to which we can apply our method in a straightforward way.</p><p>Definition 1 We will say that two vertices v, v of a graph G(V , E) have the same type iff they have the same colors and N(v) \ {v } = N(v ) \ {v}, where N(v) denotes the set of neighbors of v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1 Having the same type is an equivalence relation on the set of vertices of a graph G.</head><p>Proof Obviously the relation is reflexive and symmetric, so we only need to prove that it is transitive. Suppose u and v have the same type and also that v and w have the same type. First, N(u) \ {v} = N(v) \ {u} and N(v) \ {w} = N(w) \ {v} from the definition. From this we have N(u) \ {v, w} = N(v) \ {u, w} = N(w) \ {u, v}. So, it suffices to show that if v is connected to one of u, w it is connected to the other. But if u, v are connected then u, w are also since v and w have the same type. Now, because u and v have the same type and u, w are connected then v, w are also connected. Definition 2 A colored graph G(V , E) has neighborhood diversity at most w, if there exists a partition of V into at most w sets, such that all the vertices in each set have the same type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2 If an uncolored graph has vertex cover at most k, then it has neighborhood diversity at most</head><formula xml:id="formula_1">2 k + k.</formula><p>Proof Construct k singleton sets, one for each vertex in the vertex cover and at most 2 k additional sets, one for each subset of vertices of the vertex cover. Place each of the vertices of the independent set in one of these sets, specifically the one which corresponds to its neighborhood in the vertex cover.</p><p>In Sect. 7 we will show some more results about neighborhood diversity which indicate it may be an interesting parameter in its own right. However, until then our main focus will be graphs of bounded vertex cover. We will prove most of our algorithmic results in terms of neighborhood diversity and then invoke Lemma 2 to obtain our main objective. We will call a partition of the vertex set of a graph G into w sets such that all vertices in every set share the same type a neighborhood partition of width w. We will usually assume that a neighborhood partition of the graph is given to us, because otherwise one can easily be found in linear time by using the mentioned linear-time FPT algorithm for vertex cover and Lemma 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Bounded Max-Leaf Number</head><p>We say that a connected graph G has max-leaf number at most l if no spanning tree of G has more than l leaves. The algorithmic properties of this class of graphs have been investigated in the past <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b13">14]</ref>. In this paper we rely heavily on a characterization of bounded max-leaf graphs by Kleitman and West <ref type="bibr" target="#b21">[22]</ref> which is also heavily used in <ref type="bibr" target="#b13">[14]</ref>.</p><p>Theorem 1 <ref type="bibr" target="#b21">[22]</ref> If a graph G has max-leaf number at most l, then G is a subdivision of a graph on O(l) vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>What this theorem tells us intuitively is that in a graph</head><formula xml:id="formula_2">G(V , E) with max-leaf number l there exists a set S of O(l) vertices such that G[V \ S] is a collection of O(l 2 ) paths. Furthermore,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>only the endpoints of the paths can be connected to vertices of S in G.</head><p>It is well-known that a graph of max-leaf number at most l has a path decomposition of width at most 2l. Furthermore, it must have maximum degree at most l. Bounded max-leaf number graphs are therefore a subclass of the intersection of bounded pathwidth and bounded degree graphs (in fact, they are a proper subclass, as witnessed by the existence of say 2 × n grids). Let us mention again that model checking FO formulas on binary trees has at least a triply exponential parameter dependence, so the results we present for graphs of bounded max-leaf number can also be seen as an improvement on the currently known results for FO logic on bounded degree graphs, for this more restricted case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">FO Logic for Bounded Vertex Cover</head><p>In this Section we show how any FO formula can be decided on graphs of bounded vertex cover number, with a singly exponential parameter dependence. Our main argument is that for FO logic, two vertices which have the same neighbors are essentially equivalent. We will state our results in the more general case of bounded neighborhood diversity and then show the corresponding result for bounded vertex cover as a corollary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3 Let G(V , E) be a graph and φ(x) a FO formula with one free variable. Let v, v ∈ V be two distinct unlabeled vertices of G that have the same type. Then</head><formula xml:id="formula_3">G | φ(v) iff G | φ(v ).</formula><p>Proof Let l be a new label which is not currently used in G. Let G 1 be the labeled graph we obtain from G if we associate l with v and G 2 be the labeled graph we obtain if we associate l with v . Then the labeled graphs G 1 and G 2 are isomorphic (meaning that there is a one-to-one correspondence between them that also respects the labels). Therefore,</p><formula xml:id="formula_4">G 1 | φ(l) iff G 2 | φ(l).</formula><p>Theorem 2 Let φ be a FO sentence of quantifier depth q. Let G(V , E) be a labeled colored graph with neighborhood diversity at most w and l labeled vertices. Then, there is an algorithm that decides if G | φ in time O((w + l + q) q • |φ|), assuming that an optimal neighborhood partition is given with the input.</p><p>Proof We will rely heavily on Lemma 3 and describe a recursive algorithm. If q = 0 the problem is trivial, so assume q &gt; 0. Assume wlog that φ is in prenex normal form, φ = Qxψ(x) where Q is ∃ or ∀.</p><p>Suppose that V can be partitioned into V 1 , V 2 , . . . , V w as required by the definition of neighborhood diversity. Now, by Lemma 3 if v, v ∈ V i for some i, and neither of the two is labeled then</p><formula xml:id="formula_5">G | ψ(v) iff G | ψ(v )</formula><p>. Thus, it suffices to recursively model check at most (w + l) sentences of q -1 quantifiers to decide φ: we try replacing x with each of the l labeled vertices or with one arbitrarily chosen nonlabeled representative from each V i . If x is existentially quantified we decide that G | φ if at least one of the resulting sentences is true, while if x is universally quantified we decide that G | φ if all of the resulting sentences are true. In the process we introduce a new label. Repeating this process constructs a computation tree with at most q-1 i=0 (w + l + i) = O((w + l + q) q ) leaves. The result of the computation tree can be evaluated in time linear in its size.</p><p>Corollary 1 There exists an algorithm which, given a FO sentence φ with q variables and an uncolored, unlabeled graph G on n vertices with vertex cover at most k,</p><formula xml:id="formula_6">decides if G | φ in time 2 O(kq+q log q) |φ| + O(2 k n).</formula><p>Proof The second term in the running time comes from the basic FPT algorithm for finding a vertex cover of size k. From this we can construct a neighborhood partition and invoke Theorem 2 and Lemma 2.</p><p>Thus, the running time is (only) singly exponential in the parameters, while a straightforward observation that bounded vertex cover graphs have bounded treewidth and an application of Courcelle's theorem would in general have a nonelementary running time. Of course, a natural question to ask now is whether it is possible to do even better, perhaps making the exponent linear in the parameter. As we will see later on, this is not possible if we accept some standard complexity assumptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">FO Logic for Bounded Max-Leaf Number</head><p>In this section we describe a model checking algorithm for FO logic on graphs of small max-leaf number. Because we are not going to solve MSO logic on this class of graphs, we can simplify things by assuming that our graphs only have labels and not colors (i.e. all vertices are initially uncolored). Our main tool is the mentioned observation that all but a small fraction of the vertices have degree 2, and therefore (since we assume without loss of generality that the graph is connected) induce paths. We call a maximal set of connected vertices of degree 2 a topo-edge.</p><p>Our main argument is that when a topo-edge is very long (exponentially long in the number of quantifiers of the first-order sentence we are model checking) its precise length does not matter. Readers familiar with classical results regarding Ehrenfeucht-Fraisse games and their use in proving negative results for the expressive power of FO logic on paths will recognize that the technique we use is an extension of this work to graphs of small max-leaf number (for more information on E-F games see for example <ref type="bibr" target="#b20">[21]</ref>).</p><p>First we define a similarity relation on graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3</head><p>Let G 1 , G 2 , be two labeled graphs. For a given q we will say that G 1 and G 2 are q-similar and write G 1 ∼ q G 2 iff G 1 contains a topo-edge of order at least 2 q+1 consisting of unlabeled vertices, call it P , and G 2 can be obtained from G 1 by contracting one of the edges of P . We denote the transitive closure of the relation ∼ q as ∼ * q .</p><p>Our main technical tool is now the following lemma.</p><p>Lemma 4 Let φ be a FO formula with q quantifiers. Then, for any two graphs</p><formula xml:id="formula_7">G 1 , G 2 if G 1 ∼ q G 2 then G 1 | φ iff G 2 | φ. Therefore, if G 1 ∼ * q G 2 then G 1 | φ iff G 2 | φ.</formula><p>Proof We will prove the first statement by induction on q and the second statement follows directly from it. For q = 0 the statement is trivial because φ can only refer to labeled vertices and G 1 , G 2 are identical with respect to these vertices.</p><p>Suppose that the statement is true for at most q -1 quantifiers. It suffices to show the statement for q quantifiers for a formula φ of the form ∃xψ(x), and the statement then easily follows for formulas which are boolean combinations of formulas of at most q quantifiers. So, suppose that G 1 | ∃xψ(x). This means that there exists a vertex in G 1 such that if we label it with a new label l to obtain a graph G 1 (which is G 1 with the label l added) we have G 1 | ψ(l). Now we must take cases for the vertex where l is placed.</p><p>If l is placed on a vertex outside of P then it is not hard to see that G 2 | φ: we place l on the same vertex on G 2 (and obtain G 2 ) and now we have</p><formula xml:id="formula_8">G 1 ∼ (q-1) G 2 so from the inductive hypothesis G 2 | ψ(l).</formula><p>Now the interesting case is when l is placed on a vertex of P . Number the vertices of P from 1 to |P |, starting from one of the endpoints of the path induced by P . Partition P into two parts: P 2 contains the last 2 q vertices and P 1 the rest. In G 2 we use the same numbering for the vertices of the path (of course now the numbering is from 1 to |P | -1, since one edge has been contracted).</p><p>Suppose that l is placed on a vertex of P 1 . We place l on the same vertex in G 2 . Now, we have G 1 ∼ (q-1) G 2 , because in both graphs P has been broken into two paths P and P . P has the same size on both (depending on the position where l was placed) and P has size at least 2 q on G 1 and one less than that on G 2 . So, by the inductive hypothesis</p><formula xml:id="formula_9">G 1 | ψ(l) iff G 2 | ψ(l).</formula><p>Finally, if l is placed on a vertex of P 2 we place l on a vertex of G 2 that has the same distance from the end of the path and two q-similar graphs G 1 , G 2 are obtained, because the smaller part of the two into which P is broken has the same size on both graphs and the larger has size at least 2 q . So by the inductive hypothesis</p><formula xml:id="formula_10">G 1 | ψ(l) iff G 2 | ψ(l).</formula><p>The converse directions where we know that G 2 | φ and need to show that this implies G 1 | φ can be established with a similar argument. Now we are ready to state our main result of this section.</p><p>Theorem 3 Let G be a graph on n vertices with max-leaf number k and φ a FO formula with q quantifiers. Then, there exists an algorithm for deciding if G | φ running in time poly(n) + 2 O(q 2 +q log k) .</p><p>Proof By applying Theorem 1 we know that G can be partitioned into a set of at most O(k) vertices of degree at least 3 and a collection of paths. By applying Lemma 4 we know that there exists a G such that G ∼ * q G and G consists of the same O(k) vertices of degree at least 3 and at most O(k 2 ) paths whose length is at most 2 q+1 . Of course, G can be found in time polynomial in n. Now, we can apply the straightforward algorithm to model check φ on G . The trivial algorithm takes time O(|V | q ) = O((k 2 2 q+1 ) q ) giving the promised running time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">MSO Logic for Bounded Vertex Cover</head><p>Here we will follow a similar strategy as in Sect. 3 proving that if there is a very large number of vertices of a certain type in our graph then it is safe to delete some of them without affecting the truth of the MSO sentence we are trying to model check. To do this we first define another kind of similarity relation on graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4</head><p>Let G 1 , G 2 , be two labeled colored graphs. For given integers q S , q V we will say that G 1 and G 2 are (q S , q V )-similar and write G 1 ∼ (q S ,q V ) G 2 iff G 2 can be obtained by G 1 by deleting an unlabeled vertex u and G 1 contains at least 2 q S q V additional unlabeled vertices of the same type as u. We denote the transitive closure of the relation ∼ (q S ,q V ) as ∼ * (q S ,q V ) .</p><p>Lemma 5 Let φ be a MSO 1 formula with q S set quantifiers and q V vertex quantifiers. Then, for any two graphs</p><formula xml:id="formula_11">G 1 , G 2 if G 1 ∼ (q S ,q V ) G 2 then G 1 | φ iff G 2 | φ. Therefore, if G 1 ∼ * (q S ,q V ) G 2 then G 1 | φ iff G 2 | φ.</formula><p>Proof We will prove the first statement by induction on q S + q V and the second statement will immediately follow. For q V = 0 the statement is trivial since without vertex variables the formula may only refer to the labeled vertices where G 1 and G 2 are identical so the statement is proved for q S + q V = 0. Suppose that we have proved the statement for formulas with at most q quantified (vertex and set) variables and we are given a formula φ with q S set variables and q V vertex variables, where q S + q V = q + 1. We are also given two graphs G 1 , G 2 such that G 1 ∼ (q S ,q V ) G 2 . The two interesting cases are φ = ∃xψ(x) and φ = ∃Xψ(X) (i.e. φ begins with an existentially quantified vertex or set variable) because the universal quantification case and boolean combinations of simpler formulas follow directly if we deal with these.</p><p>First, assume that φ = ∃Xψ(X) and that G 1 | φ. So, there exists a set S 1 of vertices of G 1 such that assigning a new color C to these, thus obtaining a new colored graph G 1 , gives us G 1 | ψ(C). Let T be the type of vertices of G 1 where if we delete a vertex we obtain G 2 (recall that |T | ≥ 2 q S q V + 1). We select a set S 2 of vertices of G 2 as follows: for every type other than T we select the same number of vertices as S 1 has selected from this type in G 1 . From T , if S 1 contains at most half the vertices of type T in G 1 we place the same number of vertices from that type of G 2 in S 2 . Otherwise, we select from type T one vertex less than S 1 contains from that type in G 1 . We thus obtain a graph G 2 by coloring all the vertices of S 2 with a new color C. Informally, we can say that G 1 and G 2 are the same except that one of the types of G 1 has one more vertex than the corresponding type of G 2 . Note that we have made sure that this type has at least half the vertices of T . The claim now is that G 1 ∼ (q S -1,q V ) G 2 . To see this, observe that we can obtain G 2 from G 1 by deleting a vertex which had type T in</p><formula xml:id="formula_12">G 1 . If |S 1 ∩ T | = |S 2 ∩ T | that</formula><p>vertex is one which did not receive the new color C, but this happens if at most half the vertices did, meaning its type contains at least (2 q S q V + 1)/2 = 2 q S -1 q V + 1 vertices in G 1 . Otherwise, the vertex we can delete is one that received the new color, which means in this case its type again contains at least 2 q S -1 q V + 1 vertices. From the inductive hypothesis we now get</p><formula xml:id="formula_13">G 1 | ψ(C) iff G 2 | ψ(C), which gives G 1 | φ iff G 2 | φ.</formula><p>Similar arguments can be applied if we start with the assumption G 2 | φ.</p><p>Second, if φ = ∃xψ(x) and G 1 | φ, there exists a vertex of G 1 such that assigning to it a new label l, thus obtaining a new graph G 1 , we have G 1 | ψ(l). We assign the label l to a vertex of the same type in G 2 , obtaining G 2 . Now, we have G 1 ∼ (q S ,q V -1) G 2 , because the number of unlabeled vertices in the type where G 1 and G 2 differ has been decreased by at most one. Therefore, it is now at least 2 q S q V ≥ 2 q S (q V -1) + 1. By inductive hypothesis we get G 2 | ψ(l) so G 2 | φ. Similar arguments can again be applied if we initially assume that G 2 | φ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4</head><p>Let G be a graph on n vertices with neighborhood diversity at most w and φ be a MSO 1 formula with q S set quantifiers and q V vertex quantifiers. Then, given a neighborhood partition of G, there exists an algorithm which can decide if G | φ in time 2 O(2 q S wq V +q V log q V ) .</p><p>Proof Using Lemma 5 we can assume that no type has more than 2 q S q V vertices, otherwise we can delete one vertex and get an equivalent graph. Thus, the total number of vertices is at most w2 q S q V . The trivial MSO 1 model checking algorithm on a graph on n vertices would take time O((2 n ) q S • n q V • |φ|) (try all possible cases for each set variable and each vertex variable). Using the above bound on n gives the promised running time.</p><p>Corollary 2 There exists an algorithm which, given a MSO 1 sentence φ with q variables and an uncolored, unlabeled graph G with vertex cover at most k,</p><formula xml:id="formula_14">decides if G | φ in time 2 2 O(k+q) + O(2 k n).</formula><p>Again, this gives a dramatic improvement compared to Courcelle's theorem, though exponentially worse than the case of FO logic. This is an interesting point to consider because for treewidth there does not seem to be any major difference between the complexities of model checking FO and MSO 1 logic.</p><p>The natural question to ask here is once again, can we do significantly better? For example, perhaps the most natural question to ask is, is it possible to solve this problem in 2 2 o(k+q) ? As we will see later on, the answer is no, if we accept some standard complexity assumptions.</p><p>Finally, let us briefly discuss the case of MSO 2 logic. In general this logic is more powerful than MSO 1 , so it is not straightforward to extend Theorem 4 in this case. However, if we are not interested in neighborhood diversity but just in vertex cover we can observe that all edges in a graph with vertex cover of size k have one of their endpoints in one of the k vertices of the vertex cover. Thus, any edge set X can be written as the union of k edge sets. In turn, each of these k edge sets can easily be replaced by vertex sets, without loss of information, since we already know one of the endpoints of each of these edges. Using this trick we can replace every edge set variable in an MSO 2 sentence with k vertex set variables. This leads to a 2 2 O(kq) algorithm for MSO 2 logic on graphs of bounded vertex cover.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 6</head><p>Let φ be an MSO 2 sentence with q quantifiers and G be a graph of vertex cover k. Then, there exists an MSO 1 sentence φ with O(kq) quantifiers and a graph G with vertex cover k and k labeled vertices such that</p><formula xml:id="formula_15">G | φ iff G | φ .</formula><p>Proof We'll first argue that edge and edge-set variables can be removed from φ. G will simply be G with k labels l 1 , . . . , l k , each attached to a different vertex of the vertex cover. Suppose wlog that φ is in prenex normal form, and the edge-set variables which appear in φ are F 1 , . . . , F m , while the edge variables which appear are e 1 , . . . , e p . For the former, we replace their quantifications QF i , where Q is ∃ or ∀, with k new quantified set variables for each: QX i,1 QX i,2 . . . QX i,k : ( 1≤j ≤k ∀x : x ∈ X i,j (E(x, l j ))). For edge variables, we replace Qe i with Qx e i Qy e i : E(x e i , y e i ) where x e i , y e i are new vertex variables.</p><p>We continue by replacing every occurrence of e i ∈ F j with the formula 1≤i ≤k (x i = l i ∧ y i ∈ X j,i ), while we replace each occurrence of I (x, e i ) with (x = x e i ∨ x = y e i ). Thus, we are left with an MSO 1 formula. It is not hard to see that the new formula has at most k quantifiers for every quantifier of the old formula. Its total size is also at most O(k|φ|). Now φ is equivalent to φ because every valuation of the edge and edge-set variables of φ corresponds to a valuation of the new variables of φ and vice-versa.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 3 There exists an algorithm which, given a MSO 2 sentence φ with q variables and an uncolored, unlabeled graph G with vertex cover at most k, decides if</head><formula xml:id="formula_16">G | φ in time 2 2 O(kq) + O(2 k n).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Lower Bounds for Parameterizations by Vertex Cover</head><p>In this section we will prove some lower bound results for the model checking problems we are dealing with for vertex cover. Our proofs rely on a construction which reduces SAT to a model checking problem on a graph with small vertex cover.</p><p>Given a propositional 3-CNF formula φ p with n variables and m clauses, we want to construct a graph G that encodes its structure, while having a small vertex cover. The main problem is encoding numbers up to n with graphs of small vertex cover but this can be achieved by using the binary representation of numbers. We will begin by constructing a colored graph and then briefly describe how the reduction can be strengthened to apply to uncolored graphs as well. Without loss of generality we will assume that n is a power of 2 (dummy variables can be added to φ p if necessary).</p><p>We begin constructing a graph by adding 7 log n vertices, call them u (i,j ) , 1 ≤ i ≤ 7, 1 ≤ j ≤ log n. Add all edges of the form (u (i,j ) , u (k,j ) ) (so we now have log n disjoint copies of K 7 ). Let</p><formula xml:id="formula_17">N i = {u (i,j ) | 1 ≤ j ≤ log n}.</formula><p>For every variable x i in φ p add a new vertex to the graph, call it v i . Define for every number i the set X(i) = {j | the j -th bit of the binary representation of i is 1}. Add the edges (v i , u (1,j ) ), j ∈ X(i), that is, connect every variable vertex with the vertices of N 1 that correspond to the binary representation of its index. Let U = {v i | 1 ≤ i ≤ n} be the vertices corresponding to variables.</p><p>For every clause c i in φ p add a new vertex to the graph, call it w i . If the first literal in c i is a positive variable x k then add the edges (w i , u (2,j ) ), j ∈ X(k). If the first literal is a negated variable ¬x k , add the edges (w i , u <ref type="bibr">(3,j )</ref> ), j ∈ X(k). Proceed in a similar way for the second and third literal, that is, if the second literal is positive connect w i with the vertices that correspond to the binary representation of the variable in N 4 , otherwise in N 5 . For the third literal do the same with N 6 or N 7 . Let W = {w i | 1 ≤ i ≤ m} be the vertices corresponding to clauses.</p><p>Finally, set the color classes to be {N 1 , N 2 , . . . , N 7 , U, W }. Now, looking at the graph it is easy to see if a vertex v i corresponds to a variable that appears positive in the clause represented by a vertex w i . They must satisfy the formula</p><formula xml:id="formula_18">pos(v i , w j ) = k=2,4,6 ∀x : x ∈ N 1 (∃y : y ∈ N k ((E(v i , x) ↔ E(w j , y)) ∧ E(x, y))))</formula><p>It is not hard to define neg(v i , w j ) in a similar way. Now it is straight-forward to check if φ p was satisfiable:</p><formula xml:id="formula_19">φ = ∃S(∀x : x ∈ S(x ∈ U)) ∧ (∀w : w ∈ W (∃x : x ∈ U (((pos(x, w) ∧ x ∈ S) ∨ (neg(x, w) ∧ x / ∈ S)))))</formula><p>Clearly, φ holds in the constructed graph iff φ p is satisfiable. S corresponds to the set of variables set to true in a satisfying assignment. It is relatively easy to eliminate the colors and labels from the construction above. Colors can be reduced to labels by adding a labeled vertex for each color and connecting all the vertices that had that color to the labeled vertex. Finally, labels can also be eliminated by attaching a different FO-definable gadget to each labeled vertex. In particular, observe that all the vertices in our construction now have degree at least two. Thus, attaching a leaf to a vertex can be seen as labeling it (this can be expressed in FO logic). Similarly, we attach two leaves to the next vertex we want to label and so on. We only need a constant number of labels to simulate the constant number of color classes our construction uses. Therefore the lower bounds given below apply to the natural form of the problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7 G | φ iff φ p is satisfiable. Furthermore, φ has size O(1) and G has a vertex cover of size O(log n).</head><p>Proof Follows from the description of the construction.</p><p>Theorem 5 Let G a graph with vertex cover k. Then, there exists a fixed MSO formula φ such that, unless 3-SAT can be solved in time</p><formula xml:id="formula_20">2 o(n) , there is no algorithm which decides if G | φ in time O(2 2 o(k) • poly(n)).</formula><p>Proof We have already observed that the construction we described has k = O(log n). Since the construction can clearly be performed in polynomial time, an algorithm running in time O(2 2 o(k) • poly(n)) would imply an algorithm for SAT running in 2 o(n) • poly(n).</p><p>Note that, since the formula used in Theorem 5 is fixed, it is also implied that a O(2 2 o(k+q) • poly(n)) algorithm would also give a sub-exponential algorithm for SAT. Thus, Theorem 5 essentially matches the results of Corollary 2.</p><p>Theorem 6 Let φ be a FO formula with q v vertex quantifiers and G a graph with vertex cover k. Then, unless 3-SAT can be solved in time</p><formula xml:id="formula_21">2 o(n) , there is no algorithm which decides if G | φ in time O(2 o(kq v ) • poly(n)).</formula><p>Proof We use the same construction, but begin our reduction from Weighted 3-SAT, a well-known W <ref type="bibr" target="#b0">[1]</ref>-hard parameterized problem. Suppose we are given a 3-CNF formula and a number w and we are asked if the formula can be satisfied by setting exactly w of its variables to true. The formula φ we construct is exactly the same, except that we replace the ∃S with ∃x 1 ∃x 2 . . . ∃x w ( 1≤i&lt;j ≤w x i = x j ) and all occurrences of x ∈ S with 1≤i≤w x = x i . It is not hard to see that the informal meaning of φ now is to ask whether there exists a set of exactly w distinct variables such that setting them to true makes the formula true.</p><p>We now have q v = w + O(1) so an algorithm running in time 2 o(kq v ) • poly(n) would imply an algorithm for Weighted 3-SAT running in 2 o(w log n) • poly(n) = n o(w) , and thus, by the results of <ref type="bibr" target="#b3">[4]</ref> that there exists a sub-exponential algorithm for 3-SAT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Neighborhood Diversity</head><p>In this section we give some general results on the new graph parameter we have defined, neighborhood diversity. We will use nd(G), tw(G), cw(G) and vc(G) to denote the neighborhood diversity, treewidth, cliquewidth and minimum vertex cover of a graph G. We will call a partition of the vertex set of a graph G into w sets such that all vertices in every set share the same type a neighborhood partition of width w.</p><p>First, some general results</p><p>Theorem 7</p><formula xml:id="formula_22">1. Let V 1 , V 2 , .</formula><p>. . , V w be a neighborhood partition of the vertices of a graph G(V , E). Then each V i induces either a clique or an independent set. Furthermore, for all i, j the graph either includes all possible edges from V i to V j or none. 2. For every graph G we have nd(G) ≤ 2 vc(G) +vc(G) and cw(G) ≤ nd(G)+1. Furthermore, there exist graphs of constant treewidth and unbounded neighborhood diversity and vice-versa.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">There exists an algorithm which runs in polynomial time and given a graph G(V , E) finds a neighborhood partition of the graph with minimum width.</head><p>Proof For the first statement, to show that every V i induces either a clique or an independent set, we may assume that |V i | ≥ 3, otherwise the statement is trivial. Suppose that some V i includes at least one edge (u, v). Consider another vertex w ∈ V i . The vertex w has the same type as u, therefore (w, v) must be an edge. Similarly, (w, u) must also be an edge, and generally all other vertices in V i are connected to both u and v. Finally, if w, w are two vertices of V i other than u, v it must be the case that (w, w ) is an edge, because (u, w ) is an edge and u and w have the same type.</p><p>Another way to see this observation is to say that the property of two vertices having the same type is an equivalence relation as observed in Lemma 1. For the edges between V i and V j , suppose that there exists at least an edge (u, v) between them and let w ∈ V i , w ∈ V j . v has the same type as w , therefore (u, w ) must be an edge. Now, w has the same type as u so (w, w ) must also be an edge, and once again this is true for any w, w .</p><p>We have already shown the first part of the second statement. For the part with cliquewidth, we remind the reader that the graphs of cliquewidth k are those which can be constructed by repeated application of the following operations: introducing a new vertex with a label in {1, . . . , k}, joining all vertices of label i with all vertices of label j , renaming all vertices of label i to label j and taking disjoint union of two graphs of cliquewidth at most k. We must show how to construct a graph in such a way starting from a neighborhood partition of width w, using at most w + 1 labels. The labels in {1, . . . , w} will only be used for the vertices of the corresponding set in the partition, while the extra label will be used to construct the cliques. For each V i , if V i is an independent set introduce |V i | new vertices with label i. If V i is a clique repeat |V i | times: introduce a new vertex of label w + 1, join all vertices of label i to w + 1 and rename w + 1 to i. After all the vertices have been introduced, for all i, j for which the graph had all edges between V i and V j join the vertices labeled i with those labeled j .</p><p>To see why treewidth is incomparable to neighborhood diversity consider the examples of a complete bipartite graph K n,n and a path on n vertices.</p><p>Finally, let us argue why neighborhood diversity is computable in polynomial time. As mentioned already, the property of two vertices having the same type is an equivalence relation. The number of sets in an optimal partition is equal to the number of equivalence classes, so we simply need to determine these. It is easy to see that one can check if two vertices have the same type in polynomial time, so dividing the vertices into equivalence classes can also be done in polynomial time by checking all pairs of vertices.</p><p>Taking into account the observations of Theorem 7 we summarize what we know about the graph-theoretic and algorithmic properties of neighborhood diversity and related measures in Fig. <ref type="figure">1</ref>.</p><p>There are several interesting points to make here. First, though this work is motivated by a specific goal, beating the lower bounds that apply to graphs of bounded treewidth by concentrating on a special case, it seems that the results which can achieved are at least somewhat better; it is possible to prove stronger meta-theorems by focusing on a class which is not necessarily smaller than bounded treewidth, only different. However, this class is a special case of another known width which generalizes treewidth as well, namely cliquewidth. Since the lower bound results which apply to treewidth apply to cliquewidth as well, this work can perhaps be viewed more appropriately as an improvement on the results of <ref type="bibr" target="#b6">[7]</ref> for bounded cliquewidth graphs when restricting our attention to the more special case of bounded neighborhood diversity.</p><p>Second, there is the case of MSO 2 logic. The very interesting hardness results shown in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> demonstrate that the tractability of MSO 2 logic is in a sense the price one has to pay for the additional generality that cliquewidth provides over treewidth. It is natural to ask if these results can be strengthened to apply to neigh- Though we cannot yet fully answer the above question related to MSO 2 , we can offer some first indications that this direction might merit further investigation. In <ref type="bibr" target="#b14">[15]</ref> it is shown that MSO 2 model checking is not fixed-parameter tractable when the input graph's cliquewidth is the parameter by considering three specific MSO 2 -expressible problems and showing that they are W-hard. The problems considered are Hamiltonian cycle, Graph Chromatic Number and Edge Dominating Set. We can show that these three problems admit FPT algorithms on graphs of small neighborhood diversity (for Hamiltonian cycle this is in fact an easy consequence of an old result from <ref type="bibr" target="#b4">[5]</ref>). Since small neighborhood diversity is a special case of small cliquewidth, where these problems are hard, this result could be of independent interest. Proof We will make use of an auxiliary graph G on w vertices. Each vertex of G corresponds to a set in an optimal neighborhood partition of G and two vertices of G have an edge iff the corresponding sets of the partition of G have all possible edges between them.</p><p>For Hamiltonian cycle we rely on the results of <ref type="bibr" target="#b4">[5]</ref>. There it is shown that the TSP problem is FPT parameterized by the number of cities even when one has to visit each city a number of times given in the input. We take G and add a self-loop to every vertex that corresponds to a clique in G. The number of times we want to visit each vertex of G is equal to the size of the corresponding set of the neighborhood partition. We set the cost of each edge to 1 and each non-edge to 2 and solve the resulting TSP instance on G . G is Hamiltonian iff there is a TSP tour on G with cost n.</p><p>Let us now show how to solve graph coloring. Observe that if a set V i of a neighborhood partition of G induces an independent set, we can delete all of its vertices but one, without affecting the graph's chromatic number, because there always exists an optimal coloring where all the vertices of V i take the same color. So, we can assume without loss of generality that all the sets V i of a neighborhood partition of G induce cliques (some of them of order one).</p><p>We are now going to reformulate the problem, using the fact that in any coloring of G every color class intersects each set of the neighborhood partition in at most one vertex (since all the sets of the partition induce cliques). In other words, every color class essentially coincides with an independent set of G . Let I be the set of all independent sets of G and let V p be the set of vertices of G , each of which represents a set in the neighborhood partition of G. Consider the following ILP with variables x I , I ∈ I (i.e. at most 2 w variables): We argue that the optimal solution to this problem is exactly the chromatic number of G. First, suppose that there exists a coloring of G with c colors. Every color class induces an independent set, so by looking at the collection of sets of the neighborhood partition that the class intersects we have that every color class corresponds to some I ∈ I. Several color classes may correspond to the same set I , so we set x I to be equal to the number of color classes that correspond to the set I . It should be easy to see then that x I = c. The requirement that |V i | = I :i∈I x I is satisfied because every vertex belongs in exactly one color class.</p><p>For the other direction, suppose that there exist integers x I which satisfy the ILP and x I = s. We can produce a coloring of G with s colors: as long as there exists an I with x I &gt; 0 select a new color and arbitrarily pick exactly one uncolored vertex from each V i with i ∈ I . Color these vertices with the new color, and set x I := x I -1. It is not hard to see that this algorithm will use exactly s colors. It produces a valid coloring because in the beginning we have |V i | = I :i∈I x I and the equality continues to hold at each step if we only count the uncolored vertices on the left-hand side of the equation.</p><p>Thus, intuitively we have reformulated the problem as one of selecting the independent sets that will form the color classes. The main observation now is that the possible choices for the independent sets are only 2 w . Thus, we can recast the problem as an Integer Linear Program with at most 2 w variables and w constraints for the equations |V i | = I :i∈I x I . It follows from a seminal result of <ref type="bibr">Lenstra [24]</ref> that solving this can be performed in FPT time.</p><p>In the edge dominating set problem, we are asked to find a set of edges of minimum size such that all other edges share an endpoint with one of the edges we selected. This problem is equivalent to the minimum maximal matching problem, where we are trying to find a minimum size independent set of edges that cannot be extended by picking another edge of the graph. To see why the optimal solution to the edge dominating set problem can always be transformed to a matching, suppose that we have a solution S which includes two edges (u, v), <ref type="bibr">(u, v )</ref>. Now, if all the neighbors of v are incident on an edge of S we can simply remove (u, v ) from S and improve the size of the solution. If there is a neighbor w of v that is not incident on an edge of S we can replace (u, v ) with (w, v ) in S. To see why a solution to the edge dominating set problem can always be transformed to a matching that is maximal, suppose that the matching we got was not maximal. Then there would be two unmatched vertices connected by an edge, which would imply that this edge is not dominated.</p><p>Our algorithm will proceed as follows: for every vertex cover V of G repeat the following (there are at most 2 w vertex covers to be considered): from V infer a vertex cover of G by placing into the vertex cover all the vertices that belong in a type whose corresponding vertex is in V . Also place in the vertex cover all but one (arbitrarily chosen) vertex of every vertex type that induces a clique but whose corresponding vertex is not in V . Denote the resulting vertex cover of G by V . Find a maximum matching on the graph induced by V , call it M 1 . Take the bipartite graph induced by the unmatched vertices of V and V \ V and find a maximum matching there, call it M 2 . The solution produced is M 1 ∪ M 2 . After repeating this for all vertex covers of G , pick the smallest solution.</p><p>Now we need to argue why this solution is optimal. Let S be an optimal solution for G. We say that a set of the neighborhood partition V i is full if all of its vertices are incident on edges of S. If we take in G the corresponding vertices of the full sets of G, they must form a vertex cover of G , otherwise there would be two neighboring vertices with neither having any edge of S incident to it, which would mean that S is not maximal. This is a vertex cover of G considered by our algorithm, since our algorithm considers all vertex covers of G , call it V . Let V be again the vertex cover of G our algorithm derived from V by also including a minimal number of vertices from each remaining clique. Let V * be the set of vertices of G incident on some edge of S, which must also be a vertex cover of G. Without loss of generality we will assume that V ⊆ V * , because the two vertex covers of G agree on taking all vertices of the full sets and V takes a minimal number of vertices from every other clique. Even if V * leaves out a different vertex from some clique because all the vertices of the clique have the same neighbors we can apply an exchanging argument and transform S appropriately without increasing its size so that both sets leave out the same vertex. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions and Open Problems</head><p>In this paper we presented algorithmic meta-theorems for more restricted inputs, which improve the running times implied by previously known meta-theorems. In this way we have partially explored the trade-off which can be achieved between running time and generality. This is an interesting area for further investigations and much more can be done.</p><p>For bounded max-leaf number the complexity of MSO logic is unknown. Quite likely, it is possible to improve upon Courcelle's theorem for this case as well, but the problem remains open. Also, it would be nice to obtain a lower bound for FO logic in the case of max-leaf showing that it is impossible to achieve 2 o(q 2 ) , i.e. that the exponent must be quadratic in the number of quantifiers of the FO formula. For neighborhood diversity the most interesting open problem is the complexity of MSO 2 .</p><p>Going further, it would also make sense to investigate whether restricting the model checking problem to graphs of bounded vertex cover or max-leaf number can also allow us to solve logics wider than MSO 2 . Some indications that this may be possible are given in <ref type="bibr" target="#b12">[13]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 8</head><label>8</label><figDesc>Given an n-vertex graph G whose neighborhood diversity is w, there exist algorithms running in time O(f (w) • poly(n)) that decide Hamiltonian cycle, Graph Chromatic Number and Edge Dominating Set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>min I ∈I x I s.t. ∀v ∈ V p : I :v∈I x I = |V p | Intuitively, in the above ILP the variables x I encode how many different color classes coincide with the independent set I of G in a coloring of G.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Now note that |M 2 | ≤ |V | -2|M 1 |. So our algorithm's solution has size at most |V | -|M 1 |. On the other hand the optimal solution S includes some edges with both endpoints in V , call this set S 1 . Because M 1 is a maximum matching, |S 1 | ≤ |M 1 |.From what we have so far, the fact that all vertices of V * are matched by S and the fact that V is a vertex cover, so V * \ V induces no edges we have|V * | = |V * ∩ V | + |V * \ V | = |V | + |V | -2|S 1 | ≥ 2|V | -2|M 1 |.This implies that |S| ≥ |V | -|M 1 | which concludes the proof.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>-</head><label></label><figDesc>All graph problems expressible with an FO formula φ can be solved in time linear in the graph size and singly exponential in k and |φ|.-All graph problems expressible with an MSO 2 formula φ can be solved in time linear in the graph size and doubly exponential in k and |φ|.</figDesc><table /><note><p>-Unless n-variable 3SAT can be solved in time 2 o(n) (that is, unless the Exponential Time Hypothesis fails), then no f (k) • poly(|G|) algorithm exists to decide MSO logic on graphs of vertex cover k for any f</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>A summary of the relations between neighborhood diversity and other graph widths. Included are cliquewidth, treewidth, pathwidth, feedback vertex set and vertex cover. Arrows indicate generalization, for example bounded vertex cover is a special case of bounded feedback vertex set. Dashed arrows indicate that the generalization may increase the parameter exponentially, for example a graph of treewidth w has cliquewidth at most O(2 w ) and this is known to be tight. The table summarizes the best known model checking algorithm's dependence on each width for the corresponding logic borhood diversity or MSO 2 logic can be shown to be tractable when parameterized by neighborhood diversity.</figDesc><table><row><cell></cell><cell>FO</cell><cell>MSO</cell><cell>MSO 2</cell></row><row><cell>Cliquewidth</cell><cell cols="3">tow(w) tow(w) tow(w)</cell></row><row><cell>Treewidth</cell><cell cols="3">tow(w) tow(w) tow(w)</cell></row><row><cell>Vertex Cover</cell><cell>2 O(w)</cell><cell>2 2 O(w)</cell><cell>2 2 O(w)</cell></row><row><cell cols="3">Neighborhood Diversity poly(w) 2 O(w)</cell><cell>Open</cell></row><row><cell>Fig. 1</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgement I would like to thank the anonymous reviewers for offering various suggestions to improve this paper and catching errors in the proofs of Theorems 7 and 8.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Easy problems for tree-decomposable graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arnborg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lagergren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Seese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="308" to="340" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">(Meta) kernelization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fomin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lokshtanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S E</forename><surname>Penninkx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thilikos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FOCS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Improved parameterized upper bounds for vertex cover</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">A</forename><surname>Kanj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">MFCS. Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Kralovic</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Urzyczyn</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4162</biblScope>
			<biblScope unit="page" from="238" to="249" />
			<date type="published" when="2006">2006</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Linear FPT reductions and computational lower bounds</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">A</forename><surname>Kanj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Babai</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="212" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The traveling salesman problem with many visits to few cities</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Cosmadakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">99</biblScope>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The monadic second-order logic of graphs. I. Recognizable sets of finite graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="12" to="75" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Linear time solvable optimization problems on graphs of bounded clique-width</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Makowsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Rotics</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="125" to="150" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Approximation schemes for first-order definable optimisation problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dawar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kreutzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Schweikardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<meeting><address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Comput. Soc</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="411" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Demaine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Hajiaghayi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The bidimensionality theory and its algorithmic applications</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="292" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">FPT is P-time extremal structure I</title>
		<author>
			<persName><forename type="first">V</forename><surname>Estivill-Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Langston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A</forename><surname>Rosamond</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACiD. Texts in Algorithmics</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Broersma</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Johnson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Szeider</surname></persName>
		</editor>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>King&apos;s College</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="1" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Open problems in parameterized complexity</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AGAPE Spring School on Fixed Parameter and Exact Algorithms</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The complexity ecology of parameters: an illustration using bounded max leaf number</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A</forename><surname>Rosamond</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">CiE. Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Cooper</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Löwe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sorbi</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4497</biblScope>
			<biblScope unit="page" from="268" to="277" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Graph layout problems parameterized by vertex cover</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lokshtanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A</forename><surname>Rosamond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saurabh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ISAAC. Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S.-H</forename><surname>Hong</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Nagamochi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Fukunaga</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5369</biblScope>
			<biblScope unit="page" from="294" to="305" />
			<date type="published" when="2008">2008</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The complexity ecology of parameters: an illustration using bounded max leaf number</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lokshtanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mnich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A</forename><surname>Rosamond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saurabh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="822" to="848" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Clique-width: on the price of generality</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">V</forename><surname>Fomin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Golovach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lokshtanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saurabh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Mathieu</surname></persName>
		</editor>
		<meeting><address><addrLine>Philadelphia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="825" to="834" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Intractability of clique-width parameterizations</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">V</forename><surname>Fomin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Golovach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lokshtanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saurabh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1941" to="1956" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Deciding first-order properties of locally tree-decomposable structures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Frick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1184" to="1206" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The complexity of first-order and monadic second-order logic revisited</title>
		<author>
			<persName><forename type="first">M</forename><surname>Frick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Pure Appl. Log</title>
		<imprint>
			<biblScope unit="volume">130</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="3" to="31" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Logic, graphs, and algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electron. Colloq. Comput. Complex. (ECCC)</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">091</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Width parameters beyond tree-width and their applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hlinený</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-I</forename><surname>Oum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Seese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="326" to="362" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Descriptive Complexity</title>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Spanning trees with many leaves</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Kleitman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>West</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Discrete Math</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">99</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On brambles, grid-like minors, and parameterized intractability of monadic second order logic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kreutzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tazari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SODA</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Integer programming with a fixed number of variables</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Lenstra</surname></persName>
		</author>
		<author>
			<persName><surname>Jr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Oper. Res</title>
		<imprint>
			<biblScope unit="page" from="538" to="548" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Graph minors. I-XXIII</title>
		<author>
			<persName><forename type="first">N</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Seymour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comb. Theory, Ser. B</title>
		<imprint>
			<date type="published" when="1983">1983-2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
