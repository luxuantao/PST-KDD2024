<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Intruder Deductions, Constraint Solving and Insecurity Decision in Presence of Exclusive or</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">H</forename><surname>Comon-Lundh</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LSV, INRIA and ENS</orgName>
								<address>
									<addrLine>Cachan 61 Avenue du Président Wilson</addrLine>
									<postCode>94235</postCode>
									<settlement>Cachan cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">V. Shmatikov SRI International</orgName>
								<address>
									<addrLine>333 Ravenswood Avenue Menlo Park</addrLine>
									<postCode>94025</postCode>
									<region>CA</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Intruder Deductions, Constraint Solving and Insecurity Decision in Presence of Exclusive or</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">737E6A4E2DA2DCAEE4752DC24CB34E03</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present decidability results for the verification of cryptographic protocols in the presence of equational theories corresponding to xor and Abelian groups. Since the perfect cryptography assumption is unrealistic for cryptographic primitives with visible algebraic properties such as xor, we extend the conventional Dolev-Yao model by permitting the intruder to exploit these properties. We show that the ground reachability problem in NP for the extended intruder theories in the cases of xor and Abelian groups. This result follows from a normal proof theorem. Then, we show how to lift this result in the xor case: we consider a symbolic constraint system expressing the reachability (e.g., secrecy) problem for a finite number of sessions. We prove that such constraint system is decidable, relying in particular on an extension of combination algorithms for unification procedures. As a corollary, this enables automatic symbolic verification of cryptographic protocols employing xor for a fixed number of sessions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In this paper, we demonstrate that the reachability problem is decidable for cryptographic protocols that employ primitives with equational properties corresponding to xor and arbitrary Abelian groups. While the reachability problem for cryptographic protocols has received a lot of attention, in most approaches <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b12">13]</ref> the underlying cryptographic primitives are modeled, following the so called "Dolev-Yao" model <ref type="bibr" target="#b6">[7]</ref>, as abstract data types without any algebraic properties. This simplification may be realistic for information-theoretically secure crypto schemes, but it is not valid for primitives such as xor, products, etc.</p><p>Algebraic properties of modular exponentation are exploited by popular cryptographic protocols such as those based on group Diffie-Hellman <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b10">11]</ref>. Vernam cipher and cipher-block chaining mode for block ciphers rely on xor <ref type="bibr" target="#b11">[12]</ref>. Their properties-associativity, commutativity, cancellation with inverses-are not, in general, hidden from the intruder, and abstracting away the intruder's ability to exploit them results in missed attacks. For example, the original version of Bull's recursive authentication protocol was formally proved correct in the Dolev-Yao model, but the protocol used xor for encryption and was thus vulnerable to an attack that exploited the self-cancellation property <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b16">17]</ref>. Automatic verification of such protocols must take into account the fact that the cryptographic primitives obey certain equational theories. Though some procedures have been designed for verifying protocols in the presence of algebraic properties (e.g., <ref type="bibr" target="#b10">[11]</ref>), there was no relevant decision result in this case until now. The main contribution of this paper is to develop decision results for protocol insecurity in the presence of relevant equational theories.</p><p>Similar results have been obtained independently in <ref type="bibr" target="#b4">[5]</ref> and are published in these proceedings. In that paper, the authors show that, for a finite number of sessions, the protocol insecurity problem is NP-complete in presence of XOR. In section 1.3, we compare their results and their techniques with ours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Intruder deduction problem</head><p>The first question in automating cryptographic protocol verification is the following intruder deduction problem:</p><p>Given a finite set of messages Ì and (presumably) secret ×, can the intruder deduce × from Ì ? Formally, messages are terms over a finite alphabet, which includes, for instance, encryption. We write Ì × as a shorthand for the intruder deduction problem. This decision problem depends on the deduction capabilities of the intruder. The most widely used deduction relation in this context is shown in figure <ref type="figure">1</ref> (for the case of a symmetric-key cipher) and known, following <ref type="bibr" target="#b6">[7]</ref>, as the Dolev-Yao model: the intruder can form pairs and ciphertexts from known terms, decompose pairs, and decrypt ciphertexts only when he knows the decryption key. This assumes perfect cryptography: the set of messages is supposed to be a free algebra, which, of course, is an unrealistic hypothesis as many cryptographic primitives do have some algebraic properties. Ì × can be decided in polynomial time for the Dolev-Yao intruder (i.e., the deduction rules of figure <ref type="figure">1</ref>). We observe that this result can be easily derived from a theorem by D. McAllester <ref type="bibr" target="#b9">[10]</ref>: the intruder theory given by the rules of figure <ref type="figure">1</ref> is local. This means that Ì × iff there is a proof which only involves subterms of terms in Ì ×. This is true if we add any set of function symbols with rules allowing the intruder to apply these function symbols to any term and, for some of them, to decompose the terms. We may also add other encryption functions, in particular those modeling a public-key cipher. It is also not hard to show that Ì × is complete for PTIME.</p><p>In the first part of this paper, we consider the same question, relaxing, however, the perfect cryptography assumption. Our main motivation is to develop a decision technique for protocol security that will not miss attacks such as the Ryan-Schneider attack on the recursive authentication protocol <ref type="bibr" target="#b16">[17]</ref> in which the attacker exploits algebraic properties of the encryption scheme (see section 4).</p><p>We introduce the ¨symbol, which is interpreted either as xor, or as an arbitrary Abelian group operator. We prove a locality theorem for the new set of deduction rules. However, due to the associativity and commutativity of ¨, locality only implies that Ì × is in NP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Protocol verification via constraint solving</head><p>Cryptographic protocols can be seen as finite sequences of rules stating "If a principal receives a message Ù, then she emits a message Ú". However, may not have access to the entire message Ù. Assume for instance that Ù Ñ℄ Ã½ ℄ Ã¾ (a message Ñ cyphered using Ã ½ and then Ã ¾ ) and that knows the inverse of Ã ¾ , but not the inverse of Ã ½ . Then cannot distinguish this message from any Ñ ¼ ℄ Ã¾ since Ñ℄ Ã½ looks like any randomly generated message. This is modeled using terms with variables: Ù is written Ü℄ Ã¾ , parts which cannot be further decomposed being abstracted with variables. Now, the protocol rules can be seen as pairs of terms with variables Ù Ú, which must be read: "If receives a message matching Ù, then she emits the corresponding message Ú". That is where an intruder can mislead a principal, replacing an instance of Ù with another instance that he was able to build.</p><p>Then, a sequence of messages Ñ ½ Ñ forms a valid Pairing (P)</p><formula xml:id="formula_0">Ì Ù Ì Ú Ì Ù Ú Encryption (E) Ì Ù Ì Ú Ì Ù℄ Ú Unpairing (UL,UR) Ì Ù Ú Ì Ù Ì Ù Ú Ì Ú Decryption (D) Ì Ù℄ Ú Ì Ú Ì Ù Axioms (A) Ì Ù if Ù ¾ Ì</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1. The Dolev-Yao intruder capabilities</head><p>protocol trace if each Ñ is an instance Ú such that the intruder can deduce Ù for some protocol rule ´Ù Úµ (and the principal emitting Ñ was in a state expecting a message Ù ).</p><p>Protocol insecurity problem can thus be stated as finding a sequence of protocol rules ´Ù½ Ú ½ µ ´ÙÒ Ú Ò µ (rules can be repeated, using distinct variables, for multi-sessions) and a substitution such that, for every</p><formula xml:id="formula_1">Ò Ì ¼ Ú ½ Ú ½ Ù<label>(1)</label></formula><p>and</p><formula xml:id="formula_2">Ì ¼ Ú ½ Ú Ò ×<label>(2)</label></formula><p>for a given × which was expected to be kept secret. Such a formalization can be found in, e.g., <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b12">13]</ref> and can be extended to trace-based properties other than secrecy.</p><p>In general finding such an Ò and a is undecidable. Undecidability results from several factors: the intruder's ability to generate fresh random data (nonce generation), the unboundedness of the number of sessions, the ability to form pairs, and the unboundedness of term sizes. Only the unbounded number of sessions is essential for undecidability. Removing one of the other three is not sufficient for decidability <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b7">8]</ref>. This is why the problem of reachability with a bounded number of sessions has drawn some attention. In this setting, Ò is bounded, we can guess the rules which are played at every step and reduce the insecurity problem to finding a substitution satisfying (1) and <ref type="bibr" target="#b1">(2)</ref>.</p><p>Several authors showed that reachability is decidable for a bounded number of sessions, assuming perfect cryptography. This line of research culminates with M. Rusinowitch and M. Turuani's result that this problem is co-NPcomplete <ref type="bibr" target="#b15">[16]</ref>. The decision technique used in <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b12">13]</ref> consists, roughly, in first guessing an interleaving of the sessions, thus reducing the question to a single session, then expressing the problem as a constraint solving problem: Ì ½ Ù ½ Ì Ò Ù Ò where each individual constraint Ì Ù is a lifting of the ground intruder deduction problem to terms with variables. This constraint solving problem is proved to be in NP if the intruder's capabilities are modeled by the deduction rules of figure <ref type="figure">1</ref>.</p><p>In the second part of this paper, we introduce a new symbolic constraint system in which we can express the constraints Ì Ù and prove that these constraints are decidable in the presence of xor. As a consequence, protocol insecurity is decidable for a bounded number of sessions.</p><p>Constraint solving proceeds in several steps. The first one requires an extended narrowing procedure: roughly, we want to anticipate all possible simplifications occurring after any instantiation or combination of subterms of the original constraint. Our algorithm is inspired by combination techniques for unification algorithms <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b17">18]</ref> and unification modulo ACUN <ref type="bibr" target="#b13">[14]</ref>. In the future, it should be possible to extend it to other equational theories, typically the theory of Abelian groups, for which in this paper we already prove NP-membership in the ground case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Comparison with [5] (these proceedings)</head><p>In <ref type="bibr" target="#b4">[5]</ref>, the authors also consider the intruder deductions (ground reachability). They show a stronger result for the xor case: they prove that this problem is in PTIME, whereas we only prove an NP membership. On the other hand, we also consider the case of Abelian groups. Now, for the protocol insecurity, in <ref type="bibr" target="#b4">[5]</ref>, the authors consider a restricted class of protocol rules: for instance a protocol containing the two following rules:</p><formula xml:id="formula_3">AE ¨AE ¼</formula><p>generates two random numbers (nonces) AE and AE ¼ and sends to their xor AE ¨AE¼ AE ¨AE generates a nonce AE and replies sending AE ¨AE is dismissed in <ref type="bibr" target="#b4">[5]</ref>. Such assumptions look reasonable since the principal cannot retrieve AE from AE ¨AE ¼ without knowing AE ¼ .</p><p>All rules of figure <ref type="figure">1</ref> and, in addition:</p><formula xml:id="formula_4">Xor (X) Ì Ù Ì Ú Ì Ù ¨Ú Inversion (I) Ì Ù Ì Á ´Ùµ Equality Ì Ø Ø Ù Ì Ù</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. Intruder capabilities with equational theory</head><p>Our result does not assume any such restriction. In this respect, we prove a more general decidability result. However, in <ref type="bibr" target="#b4">[5]</ref>, they get an NP upper bound, which we don't have. They also abstract out intruder rules using oracles, and provide an example of application of such oracles.</p><p>In order to prove the NP decision result, <ref type="bibr" target="#b4">[5]</ref> shows that, if there is an attack, then there is a polynomial size attack. We proceed in a completely different way. The protocol insecurity problem is expressed as a constraint satisfaction problem as explained above. We provide constraint solving rules, yielding a complete set of solved forms. Then all attacks are solutions of these solved forms and the protocol is insecure iff there is at least one solved form, which implies the decidability of protocols insecurity with xor. We hope that this technique can be generalized to other equational theories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Intruder deductions in the presence of</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.1</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The setting</head><p>We assume that messages are terms built over an alphabet of function symbols containing constants, pairing , encryption ℄ , a unary symbol Á ´µ and a binary function symbol ¨used in infix notation. In this paper we will only consider symmetric-key encryption, but everything can be extended to several encryption symbols, including public/private-key cryptosystems and to other free symbols as well, such as one-way functions.</p><p>We extend the intruder deduction rules of figure <ref type="figure">1</ref> as displayed in figure <ref type="figure">2</ref>.</p><p>For , we consider the congruence generated by the equations of figure <ref type="figure">3</ref>, which we will call AG (for Abelian groups) or the congruence generated by these equations and</p><formula xml:id="formula_5">´Ü ¨Ýµ ¨Þ Ü ¨´Ý ¨Þµ Ü ¨Ý Ý ¨Ü ¼ ¨Ü Ü Ü ¨Á ´Üµ ¼ Á ´Á ´Üµµ Ü Á ´Ü ¨Ýµ Á ´Ýµ ¨Á ´Üµ Á ´¼µ ¼ Figure 3. ¨axioms</formula><p>the equation Á ´Üµ Ü, which will be called the xor theory.</p><p>If we orient from left to right the equations of figure 3 other than associativity and commutativity, adding the extension Ý ¨Ü ¨Á ´Üµ Ý, we get a convergent rewrite system modulo associativity and commutativity of ¨. This is also the case if we add the rule Á ´Üµ Ü and simplify all the rules accordingly. Hence every term Ø has a unique normal form Ø up to associativity and commutativity.</p><p>If Ì is a finite set of terms, let St´Ì µ be the least set of terms such that:</p><formula xml:id="formula_6">¯If Ø ¾ Ì then Ø ¾ St´Ì µ ¯If Ø ¾ St´Ì µ then Á ´Øµ ¾ St´Ì µ ¯If Ù Ú ¾ St´Ì µ then Ù Ú ¾ St´Ì µ ¯If Ù℄ Ú ¾ St´Ì µ then Ù Ú ¾ St´Ì µ ¯If Ù ½ ¨ ¨ÙÒ ¾ St´Ì µ and Ù ½ Ù Ò are not headed with ¨, then Ù ½ Ù Ò ¾ St´Ì µ</formula><p>When Á ´Üµ Ü, St´Ì µ is exactly the subterms of the flatten forms of terms in Ì , i.e., the subterms when ¨is viewed as a variadic function symbol. In all cases, the number of elements in St´Ì µ is linear in the size of Ì (the size of a set of terms is defined, as usual, as the sum of the number of nodes in each member of Ì ).</p><p>Our goal in this section is to show that, if Ì ×, then there is a normal form proof in which only terms in St´Ì × µ appear. For example, one way to derive from ¨ is to construct , then ¨ ¨ , then ¨ , and finally . But this proof is not minimal since it uses the "unnecessary" term . The minimal proof consists in simply adding Á ´ µ and ¨ to obtain .</p><p>Since we will need to gather the ¨rule applications together, we replace the former ´ µ rule with the following general ¨rule, whose number of premises is unbounded:</p><formula xml:id="formula_7">(GX) Ì Ù ½ Ì Ù Ò Ì Ù ½ ¨ ¨ÙÒ</formula><p>Define SS´Ì µ to be the closure of St´Ì µ under ¨:</p><formula xml:id="formula_8">SS´Ì µ Ø ½ ¨ ¨ØÒ Ø ½ Ø Ò St´Ì µ</formula><p>Assuming that Ì × are in normal form, if there is a proof of Ì ×, we get another proof by normalizing the terms at each inference step: normalizing cannot prevent A, UL, UR or D and for the other rules equality steps can be pushed after their application. Therefore, we can assume that all terms are kept in normal form, a normalization step taking place after each inference rule. That is why, from now on, the equality rule will be implicit:</p><formula xml:id="formula_9">Definition 1 A proof of Ì</formula><p>Ù is a tree labeled with sequents Ì Ú such that the root is labeled with Ì Ú and every node labeled with</p><formula xml:id="formula_10">Ì Ú has Ò sons Ì × ½ Ì × Ò such that Ì × ½ ¡ ¡ ¡ Ì × Ò Ì Û</formula><p>is an instance of one of the rules UL,UR,A,GX,E,P,D,I and Û Ú.</p><p>The size of a proof is the number of its nodes. We say that a proof is simple if every Ì Ú occurs at most once on every branch. We start with a simple result on simple proofs:</p><p>Lemma 1 If there is a simple proof È of one of the following forms:</p><p>. . .</p><formula xml:id="formula_11">Ì Ù Ú Ì Ù . . . Ì Ú Ù Ì Ù . . . Ì Ù℄ Ú . . . Ì Ú Ì Ù Then Ù Ú ¾ St´Ì µ (resp. Ú Ù ¾ St´Ì µ, resp. Ù℄ Ú ¾ St´Ì µ).</formula><p>Proof:(sketch) Assume that the last rule is (UL). The other cases are similar. We construct inductively a branch of the proof whose every label Ì Û is such that Ù Ú ¾ St´Ûµ.</p><p>Assume that the branch is constructed up to Ì Û and consider the subproof yielding Ì Û. By the minimality hypothesis, either Û Ù Ú or the last inference rule is not a pairing. Then, investigating all possible last rules, at least one of the premisses must contain Ù Ú as a subterm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¾</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Normal proofs</head><formula xml:id="formula_12">Definition 2 A simple proof È of Ì Ù is normal if ¯either Ù ¾ St´Ì µ and every non-leaf node of È is la- beled Ì Ú with Ú ¾ St´Ì µ ¯or È È ½ È Ò ℄</formula><p>where every proof È is a normal proof of some Ì Ú with Ú ¾ St´Ì µ and is built using the inference rules P,E,GX,I only.</p><p>Lemma 2 If there is a proof of Ì Ù, then there is a normal proof of Ì Ù.</p><p>Proof: Consider first the case where Ù ¾ St´Ì µ. We prove the result by induction on the size of the proof of Ì Ù. If the proof consists in an application of (A) only, the result is straightforward.</p><p>Let È be a proof of Ì Ù. We may assume w.l.o.g. that the proof is simple (otherwise simplify it and apply the induction hypothesis). Then consider all possible cases for the last inference:</p><p>If the last rule is (P) (or (E), which is handled in a similar way), then If the last rule is (GX) and we assume Ù is in normal form, consider the maximal context such that</p><formula xml:id="formula_13">È ½ È Ò ℄</formula><p>È and every node of is obtained by a (GX) rule or an (I) rule (such a context does exist since at least the root node is obtained in this way). We transform the proof, gathering together (GX) inferences and commuting (I) and (GX) in such a way that (I)'s occur before (GX).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The roots of</head><formula xml:id="formula_14">È ¼ ½ È ¼ Ò are respectively labeled with Ì Ù ½ ¨Ú½ Ì Ù Ò ¨ÚÒ and Ù Ù ½ ¨ ¨ÙÒ , ´Ú½ ¨ ¨ÚÒ µ ¼.</formula><p>We only consider here normal forms (each Ù ¨Ú is assumed to be in normal form), with the exception that some of the Ù Ú can be ¼.</p><p>For each Ù ¨Ú , there are four possible cases: È contains at least one (GX) node in addition). Now we will argue that a normal proof for Ì Ù Ù ½ ¨¡ ¡ ¡ ¨ÙÒ can be constructed using only terms Ù ¨Ú that fall into cases A, B, or C, and that all subproofs of Ì Ú for Ú ¾ St´Ì µ (case D) can be simply removed from the proof of Ì Ù.</p><formula xml:id="formula_15">Case A Ú ¼ and</formula><p>Suppose there is a total of Ñ terms Ù ¨Ú that fall into cases A, B, or C (Ñ Ò). Rearrange the proofs so that</p><formula xml:id="formula_16">Ú ½ Ú ¾ St´Ì µ (case A) and Ú •½ Ú Ñ ¼ (case B or C).</formula><p>For every term Ú in normal form, we define atomic´Úµ as follows:</p><p>¯If Ú is not headed with   </p><formula xml:id="formula_17">¼. È ½ È È •½ È Ñ Ì Ù ½ ¨Ú½ ¡ ¡ ¡ Ì Ù ¨Ú Ì Ù •½ ¡ ¡ ¡ Ì Ù Ñ<label>(</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Ground reachability is in NP</head><p>Theorem 3 Given a finite set of (ground) terms Ì and a ground term Ù, the derivability of Ì Ù is in NP, both in the xor case and in the case of Abelian groups.</p><p>Proof: (sketch) Define immediate derivability as follows:</p><formula xml:id="formula_18">Ì Ù is immediately derivable if Ù ½ Ù Ò ¾ Ì such that Ì Ù is obtained from Ì Ù ½ Ì Ù Ò</formula><p>by a single application of an inference rule from (E,P,I,GX). To prove membership in NP, we proceed as follows:</p><p>1. Guess a subset Ë of St´Ì Ù µ containing Ù. Guess an ordering × ½ × Ò on Ë St´Ì µ and an ordering Ù ½ Ù Ñ on the remaining part of Ë. Informally, we guess the order in which the subterms are derived.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">For every</head><formula xml:id="formula_19">½ Ò, check that Ì × ½ × ½</formula><p>× is immediately derivable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">For every</head><formula xml:id="formula_20">½ Ñ, check that Ì × ½ × Ò Ù ½ Ù ½</formula><p>Ù is immediately derivable using rules from (E,P,I,GX) only. This algorithm is in NP since there are at most Ç´ St´Ì Ù µ µ steps (i.e., polynomially many) and each step can be completed in non-deterministic polynomial time.</p><p>It is straightforward to see that if the algorithm succeeds, then Ì Ù is derivable. For the converse, we rely on lemma 2: if Ì Ù is derivable, then there is a normal proof of Ì Ù, from which we can derive an ordering on St´Ì Ùµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¾</head><p>Let us point out that, as shown in <ref type="bibr" target="#b4">[5]</ref>, the applicability of GX can actually be checked in polynomial time in the xor case. Then it follows from their result that the derivability of Ì Ù is actually in PTIME, at least in the xor case, using a marking algorithms of terms in St´Ì Ùµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Constraint solving in the presence of xor</head><p>For a fixed number of sessions, the reachability problem reduces (in NP) to the reachability problem for a single session by guessing an interleaving of the processes representing each protocol role and then guessing at which step of the combined process the property is violated <ref type="bibr" target="#b12">[13]</ref>. Then, as explained in section 1.2, the protocol insecurity problem reduces to constraint solving.</p><p>Our (reachability) constraints are finite conjunctions of expressions Ì Ø where Ì is a finite set of terms (with variables) and Ø is a term (with variable) and such that, for</p><formula xml:id="formula_21">any two atomic constraints Ì Ø Ì ¼ Ø ¼ in , either Ì Ì ¼ or Ì ¼ Ì .</formula><p>A solution of a constraint is a substitution such that, for every Ì Ù in , Ì Ù are ground and Ì Ù is derivable (using the rules of figure <ref type="figure">2</ref>), i.e., the attacker can construct term Ù from the terms Ì available to it after all variables have been instantiated as specified by .</p><p>From now on, we only consider the xor theory, i.e., the equations of figure <ref type="figure">3</ref> and the identity Á ´Üµ Ü. We will discuss the additional difficulties in the Abelian group case.</p><p>To motivate our constructions, let us show some of the difficulties on examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 1</head><p>Consider the constraint Ü where Ü is a variable. Then the set of solutions contains ℄ . It is infinite and cannot be represented as a set of instances of finitely many terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2</head><p>Ü ¨Ý ¨ Ù´Ü Ýµ Ú. The constraint can be simplified to the equivalent one:</p><formula xml:id="formula_22">Ü ¼ Ý ¼ Ù´Ü ¼ ¨Þ Ý ¼ ¨Þµ Ú, where Ü ¼ Ý ¼ Þ are new vari- ables.</formula><p>In this example, though all variables initially occur on both sides, variable Þ occurs only on the left. This situation cannot occur in the restricted class of protocols considered in <ref type="bibr" target="#b4">[5]</ref>. It cannot occur either in problems derived from protocol analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3 Let</head><formula xml:id="formula_23">Ì ¾ ¨ ¿ ½ ¨ ¿ Ü ¨ ¾ ¨ ¿ and Ù ½ ¨ ¿ . A solution of Ì Ù is, for instance, Ü ½ ¨ ¾ ½ ¨ ¿ ¨ ½ ¨ ¾ .</formula><p>Our first goal is to get rid of possible instantiations that collapse some of the subexpressions by application of the rules of figure <ref type="figure">3</ref>.</p><p>Definition 3 A substitution is normalized, if, for every variable Ü, Ü is irreducible by the rules of figure <ref type="figure">3</ref>.</p><p>A normalized solution of is collapse free if:</p><formula xml:id="formula_24">¯For any two distinct terms Ù Ú in St´ µ, Ù Ú ¯For any distinct terms Ù ½ Ù Ò ¾ St´ µ, ´Ù½ ¨ ÙÒ µ Ù ½ ¨ ¨ÙÒ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 4</head><p>Consider the constraint</p><formula xml:id="formula_25">Ü ¨ Ý ¨ . Ü ¨ Ý ¨ is a non-normalized solution, Ü ¨ Ý ¼ , Ü ¨ Ý ¨ , Ü Ý</formula><p>are non-collapsefree solutions. Actually, there is no collapse-free solution to this constraint since Ü must contain a , which implies that</p><formula xml:id="formula_26">´Ü ¨ µ Ü ¨</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">First reduction step</head><p>The goal of this section is to transform any term Ø into a finite set of terms Ë´Øµ such that the set of instances of Ø (by a normalized substitution) is the set Ù Ù ¾ Ë´Øµ is a collapse-free substitution .</p><p>The first idea is to guess all possible equalities between subterms and solve them relying on unification procedures. However, this is not sufficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5</head><p>Consider the term Ø ´Ü ¨Ý Üµ (and the theory of xor).</p><p>Subterms are Ø Ü ¨Ý Ü Ý. Guessing equalities between these terms, we get several unsolvable systems; only three identifications yield solvable equations: the empty identification, Ü Ý and finally Ü ¨Ý Ü, which yields</p><formula xml:id="formula_27">Ý ¼.</formula><p>With such identifications, we get the three terms ´Ü ¨Ý Üµ ´¼ Üµ ´Ü Üµ. Consider now</p><formula xml:id="formula_28">Ü ¨ Ý</formula><p>. Ø contains a redex and Ø ´ ¨ µ is not an instance of any of the above three terms.</p><p>We use a procedure which is similar to the combination of unification procedures of <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b2">3]</ref>, but we insert step 3:</p><p>1. Introduce a new variable Ü Ø for each non variable Ø ¾ St´ µ. We record this variable introduction in a set of equalities containing Ü ´Ø½ ØÒµ ´ÜØ½ Ü ØÒ µ, where, by convention, when Ø is a variable, Ü Ø is the variable Ø itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Guess an equivalence relation</head><formula xml:id="formula_29">Ë on variables Ü Ø , Ø ¾ St´ µ Ò Î Ö´ µ.</formula><p>For each equivalence class, let Ü be a representative of Ü, ¼ be the set of representatives of Ü Ø where Ø not headed with ¨, and ¨be the set of representatives for Ü Ø where Ø is headed with ¨. By convention, we let Ü Ü for Ü ¾ Î Ö´ µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Guess for each variable</head><formula xml:id="formula_30">Ü ¾ Î Ö´ µ a decomposition Ü Ý¾ ¼ ¯Ü Ý Ý ¨ Ü¾Ë Î Ö´ µ ¯Ü Ë Ý Ë</formula><p>where ¯ ¾ ¼ ½ and Ý Ë are new variables. The equalities are recorded in a substitution ¼ .</p><p>4. Compute, for every variable Ü ¾ Ü Ø Ø ¾ St´ µ Î Ö´ µ, the normal form Ü defined as follows:</p><formula xml:id="formula_31">¯Ü ´Ø½ ØÒµ def ´ Ü Ø½ Ü ØÒ µ ¯ÜØ½¨ ¨ØÒ def ´ Ü Ø½ ¨ ¨ Ü ØÒ µ ¼ . ¯Ü def Ü ¼ if Ü ¾ Î Ö´ µ.</formula><p>And for other variables, Ü Ø def Ü Ø 6. Check satisfiability using the rules of figure <ref type="figure">5</ref>, which express on one hand the independence of the representative choice for equivalence classes and, on the other hand, the absence of cycles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 6</head><p>Assume that</p><formula xml:id="formula_32">St´ µ Þ Ý Þ ¨Ý ´Þ ¨Ýµ Ü ´Ü½ Ü Ò µ ¾ µ Ü ´ Ü ½ Ü Ò µ Ü Ü ½ ¨ ¨ÜÒ ¾ µ Ü ´ Ü ½ ¨ ¨ Ü Ò µ ¼ Ü Ü µ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 5. Checking the consistency of guesses</head><p>Step 1 introduces two variables Ü Þ¨Ý and Ü ´Þ¨Ýµ and we have the equalities It follows that the above procedure can be seen as a nondeterministic computation of a substitution .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5</head><p>If is a normalised solution of , then there is a substitution , which is an output of the above procedure, there is a collapse-free solution ¼ of such that, for every</p><formula xml:id="formula_33">Ü ¾ Î Ö´ µ, Ü Ü ¼ .</formula><p>This lemma allows us to focus our attention on collapsefree solutions.</p><p>Extending the lemma to the case of Abelian groups is non-trivial. Nevertheless, we believe that there is a similar lemma for the Abelian groups, proceeding along the lines of the above example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Second reduction step</head><p>Let Ì ½ Ì Ò be the left members of sequents in . Guess for each the set Ë of terms in St´Ì µ that can be deduced from Ì . Guess a linear ordering on Ë . This guess has to be consistent: Ë Ë •½ and •½ extends . Then replace each occurrence of Ì with Ì Ë and add, for every and every</p><formula xml:id="formula_34">Ù ¾ Ë the constraint Ì Ú ¾ Ë Ú Ù Ù.</formula><p>Then, close every left member by ¨(if Ù ¨Ú Ú ¨Û ¾ Ì , then Ù ¨Û ¾ Ì ) and remove sequents Ì Ù such that Ì Ù is derivable (with the rules of figure <ref type="figure">2</ref>). We write ¾ ¼ if ¼ can be obtained from by the above-described transformation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 6</head><p>¯Every which is a collapse-free solution of , is also a collapse free solution of some ¼ such that ¾ ¼ .</p><p>¯for every collapse free solution of , there is some</p><formula xml:id="formula_35">¼ such that ¾ ¼ and, for every Ì Ù ¾ ¼ , for every Ú ¾ St´Ì µ such that Ì Ú is derivable, then either Ú ¾ Ì or Ì Ú is not derivable. ¯If ¾ ¼ and Ì Ù ¾ ¼ , then Ì is closed by ¨. ¯If ¾ ¼ , then St´ ¼ µ St´ µ and every solution of ¼ is a solution of</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 7</head><p>The following example will be reused later on. Assume we have the following constraint after step 1:</p><formula xml:id="formula_36">Ü ½ Ü ¾ ¨Ü¿ ¨ Ü ℄ Ü ½ Ü ¾ ¨Ü¿ Ü Ü ¾</formula><p>and let ¼ be the following collapse-free solution of the constraint:</p><formula xml:id="formula_37">Ü ½ Ü ¾ ¨ Ü ¿ ¨ ℄ Ü</formula><p>after step 2 the second constraint is replaced with (among others)  </p><formula xml:id="formula_38">Ü ½ Ü ¾ ¨Ü¿ Ü Ü ¾ Ü ½ Ü ¾ ¨Ü¿ Ü Ü ¿ Ü ½ Ü ¾ Ü ¿ Ü Ü ¾ whose ¼ is a solution. (P) Ì Ù Ú Ì Ù Ì Ú (E) Ì Ù℄ Ú Ì Ù Ì Ú (A) Ì Ù If Ù ¾ Ì (S) Ì Ù ¨Ú Ì Ù Ì Ú (X) Ì Ú ¨Û Ù ¨Ú Ì Ú ¨Û Ù ¨Û</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Solved forms and completeness</head><formula xml:id="formula_39">(b) either Ü Ù ¾ Ì or there is a term Ü Ù ¨ÚÙ ¾ Ì such that Ü Ù Ó Ý for Ý ¾ Î Ö´Ú Ù µ 2. if Ì Ü ¨Ú ¾ (or Ì Ü ¾ ) and Ì Ì ¼ Ù ½ ¨ ¨ÙÒ ¾ , then for every , Ü Ù Ü 3. If Ü ¾ Î Ö´Ùµ, then Ù Ó Ü.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7</head><p>If is a collapse free solution of (obtained by the previous transformation steps), then there is a ¼ such that ¼ by the rules of figure <ref type="figure" target="#fig_1">6</ref> and ¼ is a solved form.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 8</head><p>Consider again example 7. The constraint now becomes</p><formula xml:id="formula_40">Ü ½ Ü ¾ ¨Ü¿ ¨ Ü ℄ Ü ½ Ü ¾ ¨Ü¿ Ü Ü ¾ Ü ½ Ü ¾ ¨Ü¿ Ü Ü ¿ Ü ½ Ü ¾ Ü Ü which is in solved form, with Ü Ü ¾ Ü Ü ℄ Ü ¿ and the ordering Ü ¿ Ó Ü ¿ ℄ Ó Ü .</formula><p>It can be easily checked that ¼ is again a solution of the constraint.</p><p>For every solved form, it is easy to construct a (non necessarily collapse-free,but it doesn't matter) solution of the constraint, by induction on the variables ordered by Ó : Lemma 8 Every solved form has a solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The main result</head><p>Theorem <ref type="bibr" target="#b8">9</ref> The solvability of reachability constraints is decidable (in the case of xor).</p><p>Proof: We may only consider normalized solutions. Given a constraint , perform the first two reduction steps. They terminate and, according to lemmas 6, 5, has a solution only if at least one of the resulting constraints ¼ has a collapse-free solution. And if some of the resulting constraints has a solution, then has a solution. Now, consider the rules of figure <ref type="figure" target="#fig_1">6</ref>. They preserve the set St´ µ. Hence only finitely many distinct constraints can be derived using such rules. If the application of the rules does not terminate, that can only be due to a loop (with X). We simply avoid loops, keeping tracks of previous constraints. Then, by lemma 7, if has a solution, then there is a constraint ¼ obtained by this (now terminating) set of rules such that ¼ is a solved form and ¼ has a solution. And conversely: the solutions of such ¼ are also solutions of .</p><p>Then either all ¼ obtained in this way are not in solved form, in which case has no solution or else there is a constraint ¼ in solved form, in which case has a solution, thanks to lemma 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¾</head><p>Corollary 10 In the presence of xor, the failure of secrecy or authentication is decidable for a fixed number of sessions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Example: Bull's authentication protocol</head><p>We illustrate the constraint solving technique of section 3 by applying it to Bull's recursive authentication protocol. The protocol was first proved correct <ref type="bibr" target="#b14">[15]</ref>, and then shown to be vulnerable <ref type="bibr" target="#b16">[17]</ref> once properties of xor are taken into account. We consider the 3-party version of the protocol (see figure <ref type="figure" target="#fig_2">7</ref>). It is assumed that Ã are shared between Ë and respectively, and is a function symbol modeling a hash function. Among other goals, the protocol should prevent from learning session key Ã .</p><p>Secrecy of Ã from fails if the following constraint is satisfiable: Ì Å Ü Ý Ã ¨ ´Ã AE µ Ã ¨ ´Ã AE µ Ã ¨ ´Ã AE µ Ã ¨ ´Ü Ýµ Ã (Ü Ý represent terms under control of ). We guess that Ü Ý are not instantiated, and the following order of subterm derivation:  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Concluding remarks</head><p>We gave the first decision result for cryptographic protocols which does not assume the perfect cryptography. First, our work is incomplete in two respects:</p><p>(i) What is the exact complexity of solving the reachability constraint in the xor case?</p><p>(ii) What about an analog of theorem 9 in the case of Abelian groups?</p><p>It should be possible to answer the second question with a significant extra effort and time since we believe that there is an analog of lemma 5 for Abelian groups. The techniques introduced in section 2 and the work of McAllester <ref type="bibr" target="#b9">[10]</ref> raise a more general question:</p><p>For which (relevant) equational theories is the reachability problem in PTIME ? NP? decidable?</p><p>The techniques introduced in section 3.1 also raise a general question in unification theory:</p><p>For which equational theories can we restrict our attention to collapse-free solutions?</p><p>In other words: can we extend lemma 5 to arbitrary theories for which unification is finitary? Finally, it would be nice to abstract out the lifting argument of section 3: Is there a general relationship between the complexity of reachability in the ground case and the solvability of reachability constraints?</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>¾</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Constraint transformation rules</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Recursive authentication protocol</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Ù Ù ½ Ù ¾ . Observe that Ù ½ Ù ¾ ¾ St´Ùµ St´Ì µ. By induction hypothesis, there is a normal proof of Ì Ù ½ that involves only terms in St´Ì µ, and a normal proof of Ì Ù ¾ that involves only terms in St´Ì µ, hence the result. If the last rule is (I), then Ù Á ´Úµ and there is a proof of Ì Ú, which is strictly smaller than È . Moreover, St´Ì µ is closed under inverses, hence Ú ¾ St´Ì µ. It follows, by induction hypothesis, that there is a normal proof È ½ of Ì Ú. Completing È ½ by (I) rule, we get a normal proof of Ì Ù.</figDesc><table><row><cell>Ì</cell><cell>Ù Ú</cell></row><row><cell>Ì</cell><cell>Ù</cell></row><row><cell>and Ù Ú</cell><cell></cell></row></table><note><p><p>If the last rule is (UL) (or (UR) or (D), which are handled in a similar way), assume that È is minimal (otherwise, the induction hypothesis applies for the shorter proof of Ì Ù). By lemma 1, È . . . ¾ St´Ì µ (resp. Ú Ù ¾ St´Ì µ, resp. Ù℄ Ú ¾ St´Ì µ). Now, we apply the induction hypothesis and obtain that there is a proof of Ì Ù Ú (resp.</p>Ì Ú Ù , resp. Ì Ù℄ Ú ) that involves only terms in St´Ì µ.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>´Ù ¨Ú µ is headed with Case B Ú ¼ and Ù is headed with Case C Ú ¼ and Ù is not headed with Case D Ù ¼ and Ú is not headed with Öbserve that ´Ù ¨Ú µ ¾ St´Ì µ for all terms Ù ¨Ú that fall into cases A,B or C: in case C, this follows from ´Ù ¨Ú µ Ù ¾ St´Ùµ and, in case A,B, ´Ù ¨Ú µ ¾ St´Ì µ. Indeed, by maximality of , the last inference rule of È cannot be (GX) or (I). Since Ù ¨Ú is headed with ¨, it cannot be (P) or (E). If it is (A), then the result is straightforward. In all other cases, we can apply lemma 1. Then either È È ¼ and ´Ù ¨Ú µ ¾ St´Ì µ or else È ¼ is obtained from È by applying an (I) rule and ´Á ´Ù µ ¨Á ´Ú µµ ¾ St´Ì µ, which implies, by definition of St´Ì µ, that Á ´´Á ´Ù µ ¨Á ´Ú µµ µ ´Ù ¨Ú µ ¾ St´Ì µ. By induction hypothesis, this means that there exist normal proofs È ¼¼ for Ì ´Ù ¨Ú µ that belong to cases A, B, and C. (Note that, although È ¼ may be larger than È , each È ¼ is strictly smaller than È since</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>¨, then atomic´Úµ Ú such that Á ´Ú µ ¾ atomic´Ú µ. However, ´Ù ¨Ú µ cannot be headed with ¨. For, if it were headed with ¨, ´Ù ¨Ú µ ¾ St´Ì µ, as seen above, which implies Ú ¾ SS´Ì µ, hence Á ´Ú µ ¾ St´Ì µ, which contradicts Ú ¾ St´Ì µ. It follows that</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Ú</cell></row><row><cell cols="2">¯If Ú</cell><cell>Ú ½ ¨</cell><cell cols="2">¨Ú</cell><cell>and Ú ½</cell><cell>Ú are not</cell></row><row><cell cols="6">headed with ¨, then atomic´Úµ is the multiset</cell></row><row><cell>Ú ½</cell><cell></cell><cell>Ú .</cell><cell></cell><cell></cell></row><row><cell cols="3">Consider an index</cell><cell cols="3">Ñ. Now, since Ú ½ ¨</cell><cell>¨ÚÒ</cell></row><row><cell cols="3">¼, there is a Ú Á ´Ú µ and Ù</cell><cell cols="3">¼. Thus for every term Ú such</cell></row><row><cell>that</cell><cell cols="3">Ñ, for every</cell><cell cols="2">Ñ, Á ´Ú µ ¾ atomic´Ú µ. It</cell></row><row><cell cols="3">follows that Ú ½ ¨</cell><cell>¨Ú</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>St´Ì µ, and Ù Ù ½ ¨¡ ¡ ¡ ¨ÙÒ , this proof satisfies the definition of the normal proof.Finally, construct the normal proof for Ù by adding normal proofs for Ù •½ Ù Ñ as shown in figure4.Now let us go back to the general case: consider a minimal size proof È of Ì Ù, not assuming that Ù ¾ St´Ì µ. The proof can be written È ½ È Ò ℄ where È ½ St´Ì µ for every . Let us prove the result by induction on the size of :</figDesc><table><row><cell></cell><cell cols="2">GX)</cell><cell cols="2">Ì</cell><cell>Ù ½ ¨</cell><cell>ßÞ Ù</cell><cell>¨ÙÑ</cell></row><row><cell></cell><cell></cell><cell cols="4">Figure 4. Rearranging the sums</cell></row><row><cell cols="3">Therefore, the normal proof for Ù ½ ¨¡ ¡ ¡ ¨Ù</cell><cell>Ù ½</cell><cell cols="2">Ú½</cell></row><row><cell cols="5">¨Ù¾ ¨Ú¾ ¨¡ ¡ ¡ ¨ÙÒ ¨ÚÒ can be constructed simply</cell></row><row><cell cols="2">by adding Ù ½ ¨Ú½</cell><cell cols="3">Ù ¨Ú in any order. Since</cell></row><row><cell>Ù ½ ¨Ú½</cell><cell>Ù ¨Ú ¾</cell><cell></cell><cell></cell><cell></cell></row></table><note><p><p>È Ò are maximal subtrees of È whose roots are labeled with Ì Ú respectively and Ú ¾ ¯If is empty, then Ù ¾ St´Ì µ. ¯If the last inference rule of is (UL), (UR) or (D), then, by lemma 1, Ù ¾ St´Ì µ.</p>¯In all other cases, we consider the sons of È and apply the induction hypothesis.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>5. Compute the occurrence relation on variables as the smallest transitive relation s.t. Ü Ý if Ý occurs in Ü.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Ü Þ¨Ý Þ ¨Ý and Ü ´Þ¨Ýµ ´ÜÞ¨Ý µ. The set of equalities Ü Ø defines a substitution on variables such that Ü Ø Ë Ü Ù implies Ø</figDesc><table><row><cell cols="4">At step 2, assume we don't guess any equality.</cell></row><row><cell cols="4">At step 3 we guess the decompositions:</cell></row><row><cell>Þ</cell><cell></cell><cell cols="2">¯Þ ´Þ¨Ýµ Ü ´Þ¨Ýµ ¨¯½¼ Ü ½¼ ¨¯½½ Ü ½½</cell></row><row><cell>Ý</cell><cell></cell><cell cols="2">¯Ý ´Þ¨Ýµ Ü ´Þ¨Ýµ ¨¯¼½ Ü ¼½ ¨¯½½ Ü ½½</cell></row><row><cell cols="4">At step 4, we compute:</cell></row><row><cell cols="2">Ü Þ¨Ý</cell><cell cols="2">´¯Þ ´Þ¨Ýµ Ü ´Þ¨Ýµ ¨¯Ý ´Þ¨Ýµ Ü ´Þ¨Ýµ</cell></row><row><cell></cell><cell></cell><cell></cell><cell>¨¯½¼ Ü ½¼ ¨¯¼½ Ü ¼½ µ</cell></row><row><cell cols="2">Ü ´Þ¨Ýµ</cell><cell></cell><cell>´ÜÞ¨Ý µ</cell></row><row><cell cols="2">Þ</cell><cell cols="2">¯Þ ´Þ¨Ýµ Ü ´Þ¨Ýµ ¨¯½¼ Ü ½¼ ¨¯½½ Ü ½½</cell></row><row><cell cols="2">Ý</cell><cell cols="2">¯Ý ´Þ¨Ýµ Ü ´Þ¨Ýµ ¨¯¼½ Ü ¼½ ¨¯½½ Ü ½½</cell></row><row><cell cols="4">At step 5, we compute the occurrence relation. For instance,</cell></row><row><cell cols="4">if we chose ¯Þ ´Þ¨Ýµ</cell><cell>½ and ¯Ý ´Þ¨Ýµ</cell><cell>¼, then we get</cell></row><row><cell>Ü Þ¨Ý</cell><cell cols="2">Ü ´Þ¨Ýµ</cell><cell>Ü Þ¨Ý , which will yield unsatisfiability</cell></row><row><cell cols="4">at the next step. Similarly, choosing ¯Þ ´Þ¨Ýµ</cell><cell>¼ and</cell></row><row><cell cols="2">¯Ý ´Þ¨Ýµ</cell><cell cols="2">½ yields unsatisfiability.</cell></row><row><cell cols="4">Assume now that we chose ¯Þ ´Þ¨Ýµ</cell><cell>½ and</cell></row><row><cell cols="2">¯Ý ´Þ¨Ýµ</cell><cell cols="2">½, then Ü Þ¨Ý ¯½¼ Ü ½¼ ¨¯¼½ Ü ¼½ and the system</cell></row><row><cell cols="4">passes the satisfiability test.</cell></row><row><cell cols="4">For instance, if ¯½½ ¼, ¯¼½ ¯½¼ ½, we get</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Þ</cell><cell>Ü ´Ý¨Þµ ¨Ü½¼</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Ý</cell><cell>Ü ´Ý¨Þµ ¨Ü¼½</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Ü Þ¨Ý</cell><cell>Ü ½¼ ¨Ü¼½</cell></row><row><cell></cell><cell></cell><cell cols="2">Ü ´Þ¨Ýµ</cell><cell>´ÜÞ¨Ý µ</cell></row><row><cell cols="2">Lemma 4</cell><cell></cell></row></table><note><p><p>Ù</p>.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>. Therefore, after the second reduction step we obtain an empty constraint, proving that secrecy of Ã is violated.´Ã AE µ Ã ¨ ´Ã AE µ Ã ¨ ´Ã AE µ Ã ¨ ´Ã AE µ Ã ¨ ´Ã AE µ Ã ¨ ´Ã AE µ Ã ¨ ´Ã AE µ Ã ¨ ´Ã AE µ</figDesc><table><row><cell>½</cell><cell>Å</cell><cell>AE</cell><cell>´</cell><cell>AE µ</cell><cell></cell></row><row><cell>¾</cell><cell>Å</cell><cell cols="2">AE Å</cell><cell>´</cell><cell>AE Å µ</cell></row><row><cell>¿</cell><cell>Ë Å</cell><cell>Ë AE Å</cell><cell>´</cell><cell cols="2">Ë AE Å µ</cell></row><row><cell>Ë</cell><cell>Ã ¨</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>´Ü Ýµ</cell><cell>Ã</cell><cell>Ã . Observe that Ì</cell><cell>´Ü Ýµ</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">in one step by applying function symbol to Ü and Ý,</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Ì</cell><cell>´Ü Ýµ</cell><cell>Ã by (X), Ì</cell><cell>´Ü Ýµ</cell><cell>Ã</cell><cell>Ã by</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">two applications of ´ µ: ´´Ã ¨ ´Ã AE µµ ¨´Ã ¨</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">´Ã AE µµµ ¨Ã</cell></row></table><note><p>Ã</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank the authors of <ref type="bibr" target="#b4">[5]</ref> who pointed out a mistake in the complexity analysis provided in the submitted version of this paper, as well as several valuable comments from the referees. This work has been partially supported by the RNTL project EVA and by ACI Vernam.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On name generation and setbased analysis in the Dolev-Yao model</title>
		<author>
			<persName><forename type="first">R</forename><surname>Amadio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Charatonik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CONCUR &apos;02</title>
		<meeting>CONCUR &apos;02</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2421</biblScope>
			<biblScope unit="page" from="499" to="514" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the reachability problem in cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Amadio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lugiez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CONCUR &apos;00</title>
		<meeting>CONCUR &apos;00</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1877</biblScope>
			<biblScope unit="page" from="380" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Combining constraint solving</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Schulz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Constraints in Computational Logics (CCL &apos;99), volume 2002 of LNCS</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="104" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Symbolic trace analysis of cryptographic protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Boreale</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP &apos;01</title>
		<meeting>ICALP &apos;01</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="667" to="681" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An np decision procedure for protocol insecurity with xor</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chevalier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kuester</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">These proceedings</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Tree automata with one memory, set constraints, and ping-pong protocols</title>
		<author>
			<persName><forename type="first">H</forename><surname>Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cortier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP &apos;01</title>
		<meeting>ICALP &apos;01</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="682" to="693" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On the security of public key protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="198" to="208" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Undecidability of bounded security protocols</title>
		<author>
			<persName><forename type="first">N</forename><surname>Durgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on formal methods in security protocols</title>
		<meeting>Workshop on formal methods in security protocols<address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Computing symbolic models for verifying cryptographic protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th IEEE Computer Security Foundations Workshop</title>
		<meeting>14th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="160" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Automatic recognition of tractability in inference relations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mcallester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="284" to="303" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A unification algorithm for the group Diffie-Hellman protocol</title>
		<author>
			<persName><forename type="first">C</forename><surname>Meadows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Narendran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Issues in Theory of Security</title>
		<meeting>Workshop on Issues in Theory of Security</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Handbook of Applied Cryptography</title>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vanstone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>CRC Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Constraint solving for bounded process cryptographic protocol analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Millen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th ACM Conference on Computer and Communications Security (CCS &apos;01)</title>
		<meeting>8th ACM Conference on Computer and Communications Security (CCS &apos;01)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="166" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Unification and matching modulo nilpotence</title>
		<author>
			<persName><forename type="first">P</forename><surname>Narendran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wolfram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CADE-13</title>
		<meeting>CADE-13</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1104</biblScope>
			<biblScope unit="page" from="261" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Mechanized proofs for a recursive authentication protocol</title>
		<author>
			<persName><forename type="first">L</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th IEEE Computer Security Foundations Workshop</title>
		<meeting>10th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="84" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Protocol insecurity with finite number of sessions is NP-complete</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th IEEE Computer Security Foundations Workshop</title>
		<meeting>14th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="174" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An attack on a recursive authentication protocol: A cautionary tale</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="10" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Unification in a combination of arbitrary disjoint equational theories</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt-Schauß</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="51" to="99" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Diffie-Hellman key distribution extended to group communication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Steiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd ACM Conference on Computer and Communications Security (CCS &apos;96)</title>
		<meeting>3rd ACM Conference on Computer and Communications Security (CCS &apos;96)</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="31" to="37" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
