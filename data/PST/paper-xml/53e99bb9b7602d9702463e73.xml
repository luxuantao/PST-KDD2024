<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">PMaude: Rewrite-based Specification Language for Probabilistic Object Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Gul</forename><surname>Agha</surname></persName>
							<email>agha@cs.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana Champaign</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jos√©</forename><surname>Meseguer</surname></persName>
							<email>meseguer@cs.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana Champaign</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
							<email>ksen@cs.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana Champaign</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">PMaude: Rewrite-based Specification Language for Probabilistic Object Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">538B23A8C0A14CEDB3332361BB9F76F3</idno>
					<idno type="DOI">10.1016/j.entcs.2005.10.040</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Specification language</term>
					<term>PMaude</term>
					<term>actors</term>
					<term>probabilistic specification</term>
					<term>non-deterministic specification</term>
					<term>query language</term>
					<term>QuaTEx</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce a rewrite-based specification language for modelling probabilistic concurrent and distributed systems. The language, based on PMaude, has both a rigorous formal basis and the characteristics of a high-level rule-based programming language. Furthermore, we provide tool support for performing discrete-event simulations of models written in PMaude, and for statistically analyzing various quantitative aspects of such models based on the samples that are generated through discrete-event simulation. Because distributed and concurrent communication protocols can be modelled using actors (concurrent objects with asynchronous message passing), we provide an actor PMaude module. The module aids writing specifications in a probabilistic actor formalism. This allows us to easily write specifications that are purely probabilistic -and not just non-deterministic. The absence of such (un-quantified) non-determinism in a probabilistic system is necessary for a form of statistical analysis that we also discuss. Specifically, we introduce a query language called Quantitative Temporal Expressions (or QuaTEx in short), to query various quantitative aspects of a probabilistic model. We also describe a statistical technique to evaluate QuaTEx expressions for a probabilistic model.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In modelling large-scale concurrent systems, it is infeasible to account for the complex interplay of the different factors that affect events in the system. For example, in a large scale computer network like the Internet, network delays, congestion, and failures affect each other in ways that make it infeasible to model the system deterministically. However, non-deterministic models do not allow us to reason about the likely behaviors of a system; probabilistic modelling and analysis is necessary to understand such behavior.</p><p>A probabilistic model allows us to quantify a number of sources of indeterminacy in concurrent systems. The exact time duration of a behavior often depends on the schedulers, loads, etc. and may be represented by a stochastic process. Process or network failures may occur with a certain rate. Randomness can also come in explicitly: some parts of the system may implement randomized algorithms.</p><p>There has been considerable research on models of probabilistic systems. Both light-weight formalisms such as extensions of UML and SDL and rigorous formalisms based on process algebra <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b15">16]</ref>, Petri-nets <ref type="bibr" target="#b22">[23]</ref>, and stochastic automata <ref type="bibr" target="#b12">[13]</ref> has been proposed and successfully used to model and analyze probabilistic systems. The light-weight formalisms are closer to programming languages and easy for engineers to learn; however, some may lack a rigorous semantics. On the other hand, rigorous formalisms can be too cumbersome for engineers to adopt.</p><p>To bridge the gap between light-weight and rigorous formalisms, we propose a rewrite-based specification language, called PMaude, for specifying probabilistic concurrent systems. PMaude, which is based on probabilistic rewrite theories, has both a rigorous formal basis and the characteristics of a high-level programming language. <ref type="foot" target="#foot_0">4</ref> Furthermore, we provide tool support for performing discrete-event simulations of models written in PMaude and to statistically analyze various quantitative aspects of such models. In addition, because various distributed and concurrent communication protocols can be modelled using asynchronous message passing concurrent objects or actors <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4]</ref>, we provide an actor PMaude module to aid writing specifications in a probabilistic-actor formalism.</p><p>Our PMaude language extends standard rewrite theories with support for probabilities. Rewrite theories <ref type="bibr" target="#b23">[24]</ref> have already been shown to be a natural and useful semantic framework which unifies different kinds of concurrent systems <ref type="bibr" target="#b23">[24]</ref>, as well as models of real-time <ref type="bibr" target="#b26">[27]</ref>. The Maude system <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> provides an execution environment for rewrite theories. The discrete-event simulator for PMaude has been implemented as an extension of Maude.</p><p>Actor PMaude extends the actor model <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4]</ref> of concurrent computation by allowing us to explicitly associate probability distribution with time for message delay and computation. Actors are inherently autonomous computational objects which interact with each other by sending asynchronous messages. The actor model has been formalized and applied to dependable computing <ref type="bibr" target="#b32">[33]</ref> and software architecture <ref type="bibr" target="#b4">[5]</ref>.</p><p>A motivation for writing a specification in actor PMaude is that it allows us to easily write specifications that have no un-quantified non-determinism. In Section 3.1, we outline simple requirements which ensure that a specification written in actor PMaude is free of un-quantified non-determinism, i.e. all non-determinism has been replaced by quantified non-determinism such as probabilistic choices and stochastic real-time. Absence of (un-quantified) nondeterminism is necessary for the kind of statistical analysis that we propose. This analysis technique extends the existing numerical and statistical modelchecking techniques <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b30">31]</ref>. In particular, in our statistical analysis we allow evaluation of quantitative temporal expressions, called QuaTEx, which allows us get more quantitative insight about a probabilistic model than what is possible using traditional model-checking of temporal properties.</p><p>This paper makes the following contributions:</p><p>1. We introduce PMaude, a language for writing specifications in probabilistic rewrite theories. We also explain how models specified in PMaude are simulated in the underlying Maude language.</p><p>2. We provide an actor extension of probabilistic rewrite theories which we claim is a natural model to write various probabilistic network protocols.</p><p>The extension also helps us to write specifications which are free from nondeterminism. This is essential for the form of statistical analysis that we introduce.</p><p>3. We introduce a new query language QuaTEx to write quantitative temporal expressions which can be used to query various quantitative aspects of a probabilistic model with no non-determinism. We describe a statistical technique to evaluate such expressions using discrete-event simulation. We have implemented the technique as a part of the tool VeStA. Furthermore, we describe the integration of PMaude with VeStA.</p><p>The rest of the paper is organized as follows. Section 2 introduces PMaude along with its underlying formalism and a translator from PMaude modules to standard Maude modules. In Section 3 we describe actor PMaude module with examples. We introduce QuaTEx and a statistical evaluation technique for QuaTEx in Section 4 followed by a conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PMaude and its Underlying Formalism</head><p>In this section, we introduce PMaude and its underlying formalism starting with a brief primer on PMaude and an example. This is followed by a formal introduction to probabilistic rewrite theories along with background concepts and notations. We then explain how probabilistic models specified in PMaude are simulated in the underlying Maude language. The formalism of probabilistic rewrite theories is given to keep the paper self-contained. Further details about the formalism can be found in <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>. Readers can go to Section 2.5 skipping the formalisms given in Section 2.2, 2.3, and 2.4 without loss of continuity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A Primer on PMaude</head><p>In a standard rewrite theory <ref type="bibr" target="#b10">[11]</ref>, transitions in a system are described by labelled conditional rewrite rules (keyword crl) of the form</p><formula xml:id="formula_0">crl [L]: t( -‚Üí x ) ‚áí t ( -‚Üí x ) if C( -‚Üí x )<label>( 1 )</label></formula><p>where we assume that the condition C is purely equational. Intuitively, a conditional rule (with label L) of this form specifies a pattern t( -‚Üí x ) such that if some fragment of the system's state matches that pattern and satisfies the condition C, then a local transition of that state fragment, changing into the pattern t ( -‚Üí x ) can take place. In a probabilistic rewrite rule we add probability information to such rules. Specifically, our proposed probabilistic rules are of the form,</p><formula xml:id="formula_1">crl [L]: t( -‚Üí x ) ‚áí t ( -‚Üí x , -‚Üí y ) if C( -‚Üí x ) with probability -‚Üí y := œÄ( -‚Üí x ) (2)</formula><p>where the set of variables in the left hand side term t( -‚Üí x ) is -‚Üí x , while some new variables -‚Üí y are present in the term t ( -‚Üí x , -‚Üí y ) on the right hand side. Of course it is not necessary that all of the variables in -‚Üí x occur in t ( -‚Üí x , -‚Üí y ). The rule will match a state fragment if there is a substitution Œ∏ for the variables -‚Üí x that makes Œ∏(t) equal to that state fragment and the condition Œ∏(C) is true.</p><p>Because the right hand side t ( -‚Üí x , -‚Üí y ) may have new variables -‚Üí y , the next state is not uniquely determined: it depends on the choice of an additional substitution œÅ for the variables -‚Üí y . The choice of œÅ is made according to the probability function œÄ(Œ∏), where œÄ is not a fixed probability function, but a family of functions: one for each matching substitution Œ∏ of the variables -‚Üí x .</p><p>It is important to note that our notion of probabilistic rewrite theory can express both probabilistic and non-deterministic behavior in the following  sense: in a concurrent system, at any given point many different rules can fire. In a probabilistic rewrite theory, the choice of which rules will fire is non-deterministic. Once a match Œ∏ of a given probabilistic rule of the general form (2) at a given position has been chosen, then the subsequent choice of the substitution œÅ for the variables -‚Üí y is made probabilistically according to the probability distribution function œÄ(Œ∏). In Fig. <ref type="figure" target="#fig_0">1</ref>, we illustrate the interplay between non-determinism and probabilities by means of a simple example in PMaude, modelling a battery-operated clock with a reset-button. Comments in PMaude are prefixed with ***. The module in Fig. <ref type="figure" target="#fig_0">1</ref> imports modules POSREAL and PMAUDE defining the positive real numbers and probability distributions, respectively. A clock in normal stable state is represented as a term clock(T,C), where T is the time, and C is a real number representing the amount of charge left in the clock battery. The key rule is advance, which has a new boolean variable B and a positive real number variable t in its righthand side. If all goes well (B = true), the clock increments its time by t and the charge is slightly decreased, but if B = false, the clock will go into state broken(T,C-C 1000 ). Here the binary variable B (boolean in this case) is distributed according to the Bernoulli distribution with mean C 1000 . Thus the value of B probabilistically depends on the amount of charge left in the battery: the lesser the charge left in the battery, the greater is the chance that the clock will break. In this way, PMaude supports discrete probabilistic choice as in discrete-time Markov chains. The other extra variable t on the righthand side of the rule advance is distributed according to the exponential distribution with rate 1.0. Thus, PMaude also allows us to model stochastic continuous-time as found in continuous-time Markov chains. The reset rule, which resets the clock to time 0.0, does not have any extra variables in its righthand side and is therefore standard rewrite rule. Given a clock expression clock(T,C) one of the two rules advance, or reset is chosen non-deterministically to apply to the term clock(T,C). If the rule advance is chosen, then the clock is advanced probabilistically.</p><p>Execution of a PMaude module requires transforming it into a corresponding Maude module that simulates its behavior, as explained in Section 2.5. One can then obtain a sample execution by giving a rewrite command with an initial ground term, say clock(0.0, 1000). The result will be an execution in which the non-determinism about which rule to apply is resolved by a fair scheduler, but each application of the advance rule chooses the value of B and t probabilistically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Background and Notation</head><p>A membership equational theory <ref type="bibr" target="#b25">[26]</ref> is a pair (Œ£, E), with Œ£ a signature consisting of a set K of kinds, for each kind k ‚àà K a set S k of sorts, a set of operator declarations of the form f : k 1 . . . k n ‚Üí k, with k, k 1 , . . . , k n ‚àà K and with E a set of conditional Œ£-equations and Œ£-memberships of the form</p><formula xml:id="formula_2">(‚àÄ -‚Üí x ) t = t ‚áê u 1 = v 1 ‚àß . . . ‚àß u n = v n ‚àß w 1 : s 1 ‚àß . . . ‚àß w m : s m (‚àÄ -‚Üí x ) t : s ‚áê u 1 = v 1 ‚àß . . . ‚àß u n = v n ‚àß w 1 : s 1 ‚àß . . . ‚àß w m : s m</formula><p>The -‚Üí x denote variables in the terms t, t , u i , v i and w j above. A membership w : s with w a Œ£-term of kind k and s ‚àà S k asserts that w has sort s. Terms that do not have a sort are considered error terms. This allows membership equational theories to specify partial functions within a total framework. A Œ£-algebra B consists of a K-indexed family of sets X = {B k } k‚ààK , together with</p><formula xml:id="formula_3">(i) for each f : k 1 . . . k n ‚Üí k in Œ£ a function f B : B k 1 √ó . . . √ó B kn ‚Üí B k (ii) for each k ‚àà K and each s ‚àà S k a subset B s ‚äÜ B k .</formula><p>We denote the algebra of terms of a membership equational signature by T Œ£ . The models of a membership equational theory (Œ£, E) are those Œ£-algebras that satisfy the equations E. The inference rules of membership equational logic are sound and complete <ref type="bibr" target="#b25">[26]</ref>. Any membership equational theory (Œ£, E) has an initial algebra of terms denoted T Œ£/E which, using the inference rules of membership equational logic and assuming Œ£ unambiguous <ref type="bibr" target="#b25">[26]</ref>, is defined as a quotient of the term algebra T Œ£ by</p><formula xml:id="formula_4">‚Ä¢ t ‚â° E t ‚áî E t = t ‚Ä¢ [t] ‚â° E ‚àà T Œ£/E,s ‚áî E t : s</formula><p>In <ref type="bibr" target="#b9">[10]</ref> the usual results about equational simplification, confluence, termination, and sort-decreasingness are extended in a natural way to membership equational theories . Under those assumptions a membership equational theory can be executed by equational simplification using the equations from left to right, perhaps modulo some structural axioms A (e.g. associativity, commutativity, and identity). The initial algebra with equations E and structural axioms A is denoted T Œ£,E‚à™A . If E is confluent, terminating, and sort-decreasing modulo A <ref type="bibr" target="#b9">[10]</ref>, the isomorphic algebra of fully simplified terms (canonical forms) modulo A is denoted by Can Œ£,E/A . The notation [t] A represents the A-equivalence class of a term t fully simplified by the equations E.</p><p>In a standard rewrite theory <ref type="bibr" target="#b23">[24]</ref>, transitions in a system are described by labelled conditional rewrite rules of the form</p><formula xml:id="formula_5">crl [L] : t( -‚Üí x ) ‚áí t ( -‚Üí x ) if C( -‚Üí x )</formula><p>Intuitively, a rule (with label L) of this form specifies a pattern t( -‚Üí x ) such that if some fragment of the system's state matches that pattern and satisfies the condition C, then a local transition of that state fragment, changing into the pattern t ( -‚Üí x ) can take place. The Maude system <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> provides an execution environment for membership equational theories and for rewrite theories of the form (Œ£, E, R), with (Œ£, E) a membership equational theory, and R a collection of conditional rewrite rules. Several examples of Maude specification can be found in <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b11">12]</ref>.</p><p>To succinctly define probabilistic rewrite theories, we use a few basic notions from measure theory. A œÉ-algebra on a set X is a collection F of subsets of X, containing X itself and closed under complementation and finite or countably infinite unions. For example the power set P(X) of a set X is a œÉ-algebra on X. The elements of a œÉ-algebra are called events. We denote by B R the smallest œÉ-algebra on R containing the sets (-‚àû, x] for all x ‚àà R. We also remind the reader that a probability space is a triple (X, F , œÄ) with F a œÉ-algebra on X and œÄ a probability measure function, defined on the œÉ-algebra F which evaluates to 1 on X and distributes by addition over finite or countably infinite unions of disjoint events. For a given œÉ-algebra F on X, we denote by PFun(X, F ) the set {œÄ | (X, F , œÄ) is a probability space}</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Probabilistic Rewrite Theories</head><p>We next define probabilistic rewrite theories after the following definition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (E/A-canonical ground substitution) An</head><formula xml:id="formula_6">E/A-canonical ground substitution for variables -‚Üí x is a function [Œ∏] A : -‚Üí x ‚Üí Can Œ£,E/A .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We use the notation [Œ∏]</head><p>A for such functions to emphasize that an E/A-canonical substitution is induced by an ordinary substitution Œ∏ : -‚Üí x ‚Üí T Œ£ where, for each</p><formula xml:id="formula_7">x ‚àà -‚Üí x , Œ∏(x) is fully simplified by E modulo A. Of course, [Œ∏] A = [œÅ] A iff for each rule x ‚àà -‚Üí x , [Œ∏(x)] A = [œÅ(x)] A . We use CanGSubst E/A ( -‚Üí x )</formula><p>to denote the set of all E/A-canonical ground substitutions for the set of variables -‚Üí x .</p><p>Intuitively an E/A-canonical ground substitution represents a substitution of ground terms from the term algebra T Œ£ for variables of the corresponding sorts, so that all of the terms have already been reduced as much as possible by the equations E modulo the structural axioms A. For example the substitution 10.0 √ó 2.0 for a variable of sort PosReal is not a canonical ground substitution but a substitution of 20.0 for the same variable is a canonical ground substitution. We now proceed to define probabilistic rewrite theories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Probabilistic rewrite theory)</head><formula xml:id="formula_8">A probabilistic rewrite the- ory is a 4-tuple R = (Œ£, E ‚à™ A, R, œÄ), with (Œ£, E ‚à™ A, R) a rewrite theory with the rules r ‚àà R of the form L : t( -‚Üí x ) -‚Üí t ( -‚Üí x , - ‚Üí y ) if C( -‚Üí x )</formula><p>where</p><formula xml:id="formula_9">‚Ä¢ -‚Üí x is the set of variables in t,</formula><p>‚Ä¢ -‚Üí y is the set of variables in t that are not in t; thus, t might have variables coming from the set -‚Üí x ‚à™ -‚Üí y ; however, it is not necessary that all variables in -‚Üí x occur in t ,</p><p>‚Ä¢ C is a condition of the form</p><formula xml:id="formula_10">( j u j = v j ) ‚àß ( k w k : s k ), i.e.</formula><p>, C is a conjunction of equations and memberships, and all the variables in u j , v j and w k are in -‚Üí x , and œÄ is a function assigning to each rewrite rule r ‚àà R a function</p><formula xml:id="formula_11">œÄ r : [[C]] ‚Üí PFun(CanGSubst E/A ( -‚Üí y ), F r )</formula><p>where</p><formula xml:id="formula_12">[[C]] = {[Œº] A ‚àà CanGSubst E/A ( -‚Üí x ) | E ‚à™ A Œº(C)</formula><p>} is the set of E/A-canonical substitutions for -‚Üí x satisfying the condition C, and F r is a œÉalgebra on CanGSubst E/A ( -‚Üí y ). We denote a rule r together with its associated function œÄ r , by the notation</p><formula xml:id="formula_13">crl [L]:t( -‚Üí x ) ‚áí t ( -‚Üí x , -‚Üí y ) if C( -‚Üí x ) with probability -‚Üí y := œÄ r ( -‚Üí x )</formula><p>If the set CanGSubst E/A ( -‚Üí y ) is empty because -‚Üí y is empty then œÄ r ( -‚Üí x ) is said to define a trivial distribution; this corresponds to an ordinary rewrite rule with no probability. If -‚Üí y is nonempty but CanGSubst E/A ( -‚Üí y ) is empty because there is no canonical substitution for some y ‚àà -‚Üí y because the corresponding sort or kind is empty, then the rule is considered erroneous and will be disregarded in the semantics.</p><p>We denote the class of probabilistic rewrite theories as PRwTh. For the specification in Example 2.1, the rule advance has two variables B and t on the righthand side. The possible substitutions for B are true and false with true chosen with probability C 1000 . Similarly, the possible substitutions for t are positive real numbers sampled from an exponential distribution with rate 1.0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Semantics of Probabilistic Rewrite Theories</head><p>Let R = (Œ£, E ‚à™ A, R, œÄ) be a probabilistic rewrite theory such that:</p><p>(i) E is confluent, terminating and sort-decreasing modulo A <ref type="bibr" target="#b9">[10]</ref>.</p><p>(ii) the rules R are coherent with E modulo A <ref type="bibr" target="#b10">[11]</ref>. </p><formula xml:id="formula_14">Definition 3 (Context) A context C is a Œ£-term</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (R/A-matches) Given</head><formula xml:id="formula_15">[u] A ‚àà Can Œ£,E/A , its R/A-matches are triples ([C] A , r, [Œ∏] A ), where if r ‚àà R is a rule rl [L]:t( -‚Üí x ) -‚Üí t ( -‚Üí x , -‚Üí y ) if C( -‚Üí x ) with probability -‚Üí y := œÄ r ( -‚Üí x ) then [Œ∏] A ‚àà [[C]], that is [Œ∏] A satisfies condition C, and [u] A = [C( ‚Üê Œ∏(t))] A , so [u]</formula><p>A is the result of applying Œ∏ to the term t( -‚Üí x ) and placing it in the context.</p><p>For example, the R/A-matches for the term clock(75.0, 800.0) in Example 2.1 are as follows:</p><formula xml:id="formula_16">‚Ä¢ ([ ] A , advance, [T ‚Üê 75.0, C ‚Üê 800.0]) ‚Ä¢ ([ ] A , reset, [T ‚Üê 75.0, C ‚Üê 800.0]) Definition 5 (E/A-canonical one-step R-rewrite) An E/A-canonical one- step R-rewrite is a labelled transition of the form, [u] A ([C] A ,r,[Œ∏] A ,[œÅ] A ) ---------‚Üí [v] A where (i) [u] A , [v] A ‚àà Can Œ£,E/A (ii) ([C] A , r, [Œ∏] A ) is an R/A-match of [u] A (iii) [œÅ] A ‚àà CanGSubst E/A ( -‚Üí y ) (iv) [v] A = [C( ‚Üê t (Œ∏( -‚Üí x ), œÅ( -‚Üí y )))] A</formula><p>The above definition describes the steps involved in a one-step computation of a PRwTh. First, a R/A-match ([C] A , r, [Œ∏] A ) is chosen non-deterministically for the lefthand side of r, and then a substitution [œÅ] A is chosen for the new variables -‚Üí y in the r's righthand side according to the probability function œÄ r ([Œ∏] A ). These two substitutions are then applied to the term t ( -‚Üí x , -‚Üí y ) to produce the final term v whose equivalence class [v] A is the result of the step of computation. The non-determinism associated with the choice of the R/Amatch must be removed in order to associate a probability space over the space of computations (which are infinite sequences of canonical one-step Rrewrites). The non-determinism is removed by what is called an adversary of the system, which defines a probability distribution over the set of R/Amatches. In <ref type="bibr" target="#b19">[20]</ref>, we describe the association of a probability space over the set of computation paths. We have also shown in <ref type="bibr" target="#b19">[20]</ref> that probabilistic rewrite theories have great expressive power. They can express various known models of probabilistic systems like continuous-time Markov chains <ref type="bibr" target="#b31">[32]</ref>, probabilistic non-deterministic systems <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b28">29]</ref>, and generalized semi-Markov processes <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Simulating PMaude Specifications in Maude</head><p>Due to their non-determinism, probabilistic rewrite rules are not directly executable. Consider for example the advance rule in Example 2.1 that advances the clock. There are two new variables in its righthand side, namely, a Boolean variable B, which will determine whether the clock will continue to function normally or will break, and a positive real variable t, which will determine the actual time advance of the clock.</p><p>However, probabilistic systems specified in PMaude can be simulated in Maude. This is accomplished by transforming a PMaude specification into a corresponding Maude specification in which actual values of the new variables appearing in the righthand side of a probabilistic rewrite rule are obtained by sampling the corresponding distribution functions. For example, in the advance rule in our clock example, the Boolean variable B must be sampled according to the Bernoulli distribution BERNOULLI( C 1000 ), whereas the positive real variable must be sampled according to the exponential distribution EXPONENTIAL(1.0).</p><p>This theory transformation uses three key Maude modules as basic infrastructure, namely, COUNTER, RANDOM, and SAMPLER. The module COUNTER provides a built-in strategy for the application of the non-deterministic rewrite rule:</p><formula xml:id="formula_17">rl counter ‚áí N:Nat .</formula><p>that rewrites the constant counter to a natural number. The built-in strategy applies this rule so that the natural number obtained after applying the rule is exactly the successor of the value obtained in the preceding rule application. The RANDOM module is a built-in Maude module providing a random number generator function called random. The SAMPLER module provides sampling functions for different probability distributions. In the above advance rule, the needed sampling functions are which rewrites the constant rand to a floating point number between 0 and 1 pseudo-randomly chosen according to the uniform distribution. This floating point number is obtained by converting the rational number random(counter + 1) / 4294967296 into a positive real number, where 4294967296 is the maximum value that the random function can attain. The rewrite rules defining the semantics of the EXPONENTIAL and BERNOULLI sampling functions are then rl EXPONENTIAL(R) ‚áí (-log(rand)) / R . rl BERNOULLI(R) ‚áí if rand &lt; R then true else false fi . We can then use this transformed module to simulate the original EXPONEN-TIAL-CLOCK PMaude module. In particular, as explained in Section 4, we can use the results of performing Monte-Carlo simulations in this way to formally analyze probabilistic properties of a system, provided all non-determinism has been eliminated from the original PMaude module. In example 2.1 this elimination of non-determinism has not happened because the reset rule and the advance rule could both be applied to a clock. However, it would be easy to transform this example into one where such non-determinism has been replaced by probabilities. In section 3 we give a general method to specify probabilistic object-oriented distributed systems in a way that eliminates all non-determinism and makes them amenable to the form of statistical analysis discussed in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The result of transforming the</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Actor PMaude</head><p>An actor <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4]</ref> is a concurrent object encapsulating a state and having a unique name. Actors communicate asynchronously by sending messages to each other. On receiving a message, an actor changes its state and sends messages to other actors. Actors provide a natural formalism to model and reason about distributed and concurrent systems. We provide the module, actor PMaude, to aid high level modelling of various concurrent and distributed object systems.</p><p>Another motivation for writing a specification in actor PMaude is that it allows us to easily write specifications that have no non-determinism. To ensure absence of non-determinism in an actor PMaude specification, we outline simple requirements in Section 3.1. Absence of non-determinism is necessary for statistical analysis as described briefly in Section. 4.</p><p>In actor PMaude, we introduce stochastic real-time to capture the dynamics of various elements of a system. Specifically, we assume that both message passing and computation by an actor on receiving a message may take some positive real-valued time. This time can be distributed according to some continuous probability distribution function. In an actor PMaude specification, in addition to the functional description of the actors and their computations, we explicitly describe the probability distributions associated with message passing time and computation time. We also allow time associated with message passing or computation to be zero, to indicate synchronous communication and instant computation, respectively. We next describe the actor PMaude module along with the semantics for one-step computation which is required for discrete event simulation.</p><p>The definition of the various sorts and operators for the actor PMaude module is given in Fig. <ref type="figure" target="#fig_4">2</ref>. A term of sort Actor represents an actor. An actor has a unique name (a term of sort ActorName) and a list of named attributes (a term of the sort AttributeList). The attribute list of an actor, which is a list of terms of the sort Attribute, represents the state of an actor. An actor is constructed by the mixfix operator<ref type="foot" target="#foot_1">5</ref> name: | that maps an actor name and a list of attributes to an actor.</p><p>A message is represented by a term of sort Msg. A message contains an address or the name of the actor to which it is targeted and a content (a term of sort Content). A message is constructed by the operator ‚Üê that maps an actor name and a content to a message. An actor on receiving a message can change it state, i.e. its attributes, and can send out messages to other actors.</p><p>An actor or a message can be generically represented by a term of sort Object, whose subsorts are Actor and Msg. To model stochastic real-time associated with message passing delay or actor computation, we make a message or an actor, respectively, inactive up to a given global time by enclosing them between square brackets [ ]. A term of sort ScheduledObject represents an object which is not yet active or available to the system. We call such objects scheduled objects. A scheduled object is constructed by the operator [ , ] that maps a time (a term of the sort PosReal) and an object (i.e. an actor or a message) to a scheduled object. The time indicates the global time at which the object will become available to the system.</p><p>A term of sort Config represents a multiset of objects, scheduled objects, and a global time combined with an empty syntax (juxtaposition) multiset union operator that is declared associative and commutative. The global state of a system is represented by a term of the sort Config containing (i) a multiset of objects, (ii) a multiset of scheduled objects, and (iii) a global time (a term of the sort PosReal) <ref type="foot" target="#foot_2">6</ref> .</p><p>The ground terms empty, nil, and null represents constants of the sorts Content, AttributeList, and Config, respectively.</p><p>The module also defines a special tick rule which is omitted from Fig. <ref type="figure" target="#fig_4">2</ref> for brevity. The description of the tick rule is given below, where we define an one-step computation of a model written in actor PMaude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>One-Step Computation:</head><p>An one-step computation of a model written in actor PMaude is a transition of the form  of the form (C‚Üê empty). The delay associated with the message from the client to the server is distributed exponentially with rate 10.0 (see rule labelled send). The message contains a natural number which is incremented by 1 by the client, each time it sends a message. The server, when not busy, can receive a message and increment its attribute total by the number received in the message (see rule labelled compute). If the server is busy processing a message (computation time is exponentially distributed with rate 1.0), it drops any message it receives (see rule labelled busy-drop). Note that we can modify the rule busy-drop to allow the server actor to enqueue any message it receives when it is busy.</p><formula xml:id="formula_18">[u] A ¬¨tick ---‚Üí * [v] A tick --‚Üí [w] A where (i) [u] A is a canonical term of sort Config,</formula><p>The rule for sending a message by a client C to a server S is labelled by send. The lefthand side of the rule matches a fragment of the global state consisting of a client actor of the form name: C | counter: N, server: S , a message of the form (C‚Üê empty), and a global time of the form T. The rule states that the client C, on receiving an empty message, produces two messages: an empty message to itself and a message to a server, whose name is contained in its attribute server. Both the messages were produced as scheduled objects to represent that they are inactive till the delay time associated with the messages has elapsed. The delay times t 1 and t 2 are substituted probabilistically.</p><p>Note that the model has no non-determinism. All non-determinism has been replaced by probabilistic choices. A model with no non-determinism is a key requirement for our statistical analysis technique briefly described in Section. 4. We next give sufficient conditions to ensure that a specification written in actor PMaude has no non-determinism.</p><p>3.1 Sufficient conditions for absence of un-quantified non-determinism in an actor PMaude specification:</p><p>(i) The initial global state of the system or the initial configuration can have at most one non-scheduled message.</p><p>(ii) The computation performed by any actor after receiving a message must have no un-quantified non-determinism; however, there may be probabilistic choices.</p><p>(iii) The messages produced by an actor in a particular computation (i.e. on receiving a message) can have at most one non scheduled message.</p><p>(iv) No two scheduled objects become active at the same global time. This is ensured by associating continuous probability distributions with message delays and computation time.</p><p>We next provide the specification of a practical system to show the expressiveness of actor PMaude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3.2</head><p>The model of a symmetric polling server <ref type="bibr" target="#b18">[19]</ref> with 5-stations is given in Fig. <ref type="figure" target="#fig_5">4</ref>. Each station has a single-message buffer and they are cyclically attended to by a single server. The server polls a station i. If there is a message in the buffer of station i, then the server serves the station. Once the station is served, or once the station is polled in case the station has an empty buffer, the server moves on to poll the station (i + 1) modulo N, where N is the number of stations. The polling time, the service time, and the time for arrival of a message at each station is exponentially distributed. Note that this model can be represented by a continuous-time Markov chain. In Fig. <ref type="figure" target="#fig_5">4</ref>, we modelled each station and the server as actors. Messages that arrive at each station-actor are modelled as self-sending scheduled messages having exponentially distributed delays (see rule labelled produce). The start of polling of a station by the server is modelled as an instantaneous poll message (i.e. with no delay) sent by the server to the station (see rule labelled next). On receiving a poll message, a station sends itself a scheduled serve message (see rule labelled poll), i.e. a message having delay equal to the polling time. On receiving a serve message, if the station finds that its buffer is empty, it sends an instantaneous next message (i.e. with no message delay) to the server indicating that the server needs to poll the next station (see rule labelled serve). Otherwise, if the buffer has a message (indicated by non-zero value of the attribute buf), it sends itself a scheduled done message (i.e. a message having delay equal to the serving time). On receiving a done message, the station sends an instantaneous next message (i.e. with no message delay) to the server indicating that the server needs to poll the next station (see rule labelled served).</p><p>Note that the model has no un-quantified non-determinism, since it meets the conditions given in Section 3.1.</p><p>A more complex example of modelling and analysis of a denial of service resistant TCP/IP protocol can be found in <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">QuaTEx</head><p>Once a probabilistic system has been specified in PMaude using criteria such as those in Section 3.1 that ensure that there is no non-determinism, we want to formally analyze the system by evaluating various quantitative properties of the system. In this section we introduce a language to express various quantitative properties of a probabilistic system. We also give a statistical technique to evaluate such properties.</p><p>To query various quantitative aspects of a probabilistic model, we introduce a query language called Quantitative Temporal Expressions (or QuaTEx in short). The language is mainly motivated by probabilistic computation tree logic (PCTL) <ref type="bibr" target="#b14">[15]</ref> and Eagle <ref type="bibr" target="#b6">[7]</ref>. In QuaTEx, some example queries that can be encoded are as follows:</p><p>(i) Out of 100 clients, what is the expected number of clients that successfully connect to a server under a denial of service attack?</p><p>(ii) What is the probability that a client connected to a server within 10 seconds after it initiated the connection request?</p><p>QuaTEx is more expressive than PCTL. In QuaTEx, one can query the expected value of any expression rather than simple probabilities as in PCTL. Moreover, the path expressions in QuaTEx can have any level of nesting of other path expressions. In PCTL, one can only use state formulas in path formulas. This strictly disallows nesting of path formulas directly into other path formulas.</p><p>We next introduce the notation that we will use to describe the syntax and the semantics of QuaTEx, followed by a few motivating examples.</p><p>We assume that an execution path is an infinite sequence œÄ = s 0 ‚Üí s 1 ‚Üí s 2 ‚Üí ‚Ä¢ ‚Ä¢ ‚Ä¢ where s 0 is the unique initial state of the system, typically a term of sort Config representing the initial global state, and s i is the state of the system after the i th computation step. If the k th state of this sequence cannot be rewritten any further (i.e. is absorbing), then s i = s k for all i ‚â• k.</p><p>We denote the i th state in an execution path œÄ by œÄ[i] = s i . Also, we denote the suffix of a path œÄ starting at the i th state by œÄ</p><formula xml:id="formula_19">(i) = s i ‚Üí s i+1 ‚Üí s i+2 ‚Üí ‚Ä¢ ‚Ä¢ ‚Ä¢ .</formula><p>We let Path(s) be the set of execution paths starting at state s. Note that, because the samples are generated through discrete-events simulation of a PMaude model with no non-determinism, Path(s) is a measurable set and has an associated probability measure. This is essential to compute the expected value of a path expression from a given state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">QuaTEx through Examples</head><p>The language QuaTEx, which is designed to query various quantitative aspects of a probabilistic model, allows us to write temporal query expressions like temporal formulas in a temporal logic. It supports a framework for parameterized recursive temporal operator definitions using a few primitive nontemporal operators and a temporal operator ( ). The temporal operator , called the next operator, takes an expression at the next state and makes it an expression for the current state. For example, suppose we want to know "the probability that along a random path from a given state, the client C gets connected with S within 100 time units." This can be written as the following query: The first two lines of the query define the recursive temporal operator IfCon-nectedInTime(t), which returns 1, if along an execution path C gets connected to S within time t and returns 0 otherwise. The state function time() returns the global time associated with the state; the state function connected() returns true, if in the state, C gets connected with S and returns false otherwise. Then the state query at the third line returns the expected number of times C gets connected to S within 100 time units along a random path from a given state. This number lies in [0, 1] since along a random path either C gets connected to S within 100 time units or C does not get connected to S within 100 time units. In fact, this expected value is equal to the probability that along a random path from the given state, the client C gets connected with S within 100 time units.</p><formula xml:id="formula_20">IfConnectedInTime(t) = if t &gt;</formula><p>A further rich query is as follows: In this query, the state function anyConnected() returns true if any client C i gets connected to S in the state. We assume that in a given execution path, at any state, at most one client gets connected to S.</p><formula xml:id="formula_21">NumConnectedInTime(t, count ) = if t &gt;</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Syntax of QuaTEx</head><p>The syntax of QuaTEx is given in Fig. <ref type="figure" target="#fig_6">5</ref>. A query in QuaTEx consists of a set of definitions D followed by a query of the expected value of a path expression PExp. In QuaTEx, we distinguish between two kinds of expressions, namely, state expressions (denoted by SExp) and path expressions (denoted by PExp); a path expression is interpreted over an execution path and a state expression is interpreted over a state. A definition Defn ‚àà D consists of a definition of a temporal operator. A temporal operator definition consists of a name N and a set of formal parameters on the left-hand side, and a path expression on the right-hand side. The formal parameters denote the freeze formal parameters. When using a temporal operator in a path expression, the formal parameters are replaced by state expressions. A state expression can be a constant c, a function f that maps a state to a concrete value, a k-ary  We also assume that expressions of type integer can be coerced to the real type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Semantics of QuaTEx</head><p>Next, we give the semantics of a subset of query expressions that can be written in QuaTEx. In this subclass, we impose the restriction that the value of a path expression PExp that appears in any expression E[PExp] can be determined from a finite prefix of an execution path. We call such temporal expressions bounded path expressions. The semantics is given in Fig. <ref type="figure">6</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(œÄ)[ [PExp]</head><p>] D is the value of the path expression PExp over the path œÄ. Similarly, (s)[ [SExp]] D is the value of the state expression SExp in the state s. Note that if the value of a bounded path expression can be computed from a finite prefix œÄ fin of an execution path œÄ, then the evaluations of the path expression over all execution paths having the common prefix œÄ fin are the same. Since a finite prefix of a path defines a basic cylinder set (i.e. a set containing all paths having the common prefix) having an associated probability measure, we can compute the expected value of a bounded path expression over a random path from a given state. In our analysis tool, we statistically estimate the expected value through Monte-Carlo simulation instead of calculating it exactly based on the underlying probability distributions of the model. The exact procedure is described in Section 4.5.</p><p>where the state function time() returns the global time associated with the state. However, QuaTEx is more expressive than the temporal logic operators of PCTL and CSL. It can be used for counting as described through an example in Section 4.1. It can be used to relate data temporally. For example, suppose we want to know "the probability that along a random path from a given state, if a message is sent then the same message is received within 100 time units." This can be written as the following query:</p><formula xml:id="formula_22">Received(m, t) = if t &gt; time() then 0 else if receive(m) then 1 else (Received(m, t)) fi fi; eval E[if send () then Received(messageId (), 100 + time()) else 1 fi]</formula><p>where, the state function time() returns the global time associated with the state; the state function send() returns true, iff in the state a message is sent; receive(m) returns true, iff in the state a message with id m is received; messageId(m) returns the id of the message that is sent in the current state. Note that along a path, the path expression if send () then Received(message-Id(), 100 + time()) else 1 fi returns 1 if a message is sent in the current state and the same message (i.e. the message having the same id) is received within 100 time units at some later state. Here the data, message id, is related temporally which is otherwise not possible using the traditional probabilistic temporal logics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Statistical Evaluation of a QuaTEx Expression</head><p>Given a probabilistic model and a QuaTEx expression, we evaluate the expression at the initial state of the model. The evaluation of all path and state expressions, except the expectation expression, is straightforward and follows directly from the semantics. However, the evaluation of an expression of the form E[PExp] can be difficult to compute numerically for a complex probabilistic model. For example, at a given state the probability of a PCTL path formula, which can be expressed as an expression in QuaTEx, cannot be computed numerically for a complex probabilistic model such as Generalized Semi-Markov Processes (GSMP) <ref type="bibr" target="#b13">[14]</ref>. The expected value of a QuaTEx expression is statistically evaluated with respect to two parameters Œ± and Œ¥ provided as input. Specifically, we approximate the expected value by the mean of n samples such that the size of (1Œ±)100% confidence interval <ref type="bibr" target="#b17">[18]</ref> for the expected value computed from the samples is bounded by Œ¥. We next describe the details of this computation.</p><p>Let X be random variable giving the value of the expression PExp along a random path œÄ from a state s. Then (s)[ [E <ref type="bibr">[PExp]</ref>]] D = E[X]. Let X 1 , . . . , X n be n random variables having the same distribution as X. By Central Limit Theorem <ref type="bibr" target="#b17">[18]</ref>, we know that if</p><formula xml:id="formula_23">Z = X -Œº S/ ‚àö n</formula><p>where X =</p><formula xml:id="formula_24">P i‚àà[1,n] X i n , S 2 = P i‚àà[1,n] X 2 i -X2 n-1</formula><p>, and Œº = E[X], then Z has student's t-distribution with n-1 degrees of freedom for large enough n. If T is random variable having t-distribution with k degrees of freedom, then we define t Œ±,k as follows:</p><formula xml:id="formula_25">P r[T &lt; t Œ±,k ] = 1 -Œ±</formula><p>The values of t Œ±,k for various values of Œ± and k can be obtained from a distribution table or by numerical computation.</p><p>Let x 1 , . . . , x n be n samples from X. Then for large enough n (i.e. n &gt; 30) a (1Œ±)100% confidence interval is given by (xt Œ±/ . We want the size of this (1Œ±)100% confidence interval to be less than or equal to Œ¥. That is we want 2t Œ±/2,n-1 s ‚àö n ‚â§ Œ¥</p><p>We compute E[X] iteratively using the function computeExpectedValue-OfX() described below. The function iteratively tries to find a sample size n, such that a (1Œ±)100% confidence interval computed from n samples has a size less than or equal to Œ¥. The mean of these n sample, i.e. x, is then returned as the estimated value for E[X]. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Implementation</head><p>We have implemented the evaluator for QuaTEx in Java. The tool, called VeStA, takes as input an actor PMaude model, an initial actor PMaude term representing the initial configuration of the system, and a QuaTEx expression along with the two parameters Œ± and Œ¥.</p><p>VeStA performs discrete-event simulation by invoking the Maude interpreter <ref type="bibr" target="#b11">[12]</ref>. VeStA maintains the current configuration of the system as an actor PMaude term represented as a Java string. This term is initialized to the initial actor PMaude term provided as input. At every simulation step, VeStA passes the current configuration term to the Maude interpreter for a one-step computation and obtains the result of rewriting as a term representing the next configuration. The value of the application of a function on the current state, as required by certain QuaTEx expressions, is computed by VeStA by parsing the current configuration term.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have introduced PMaude, a rewrite-based formal modelling language for probabilistic concurrent systems with support for discrete-event simulation and statistical analysis. One important advantage of PMaude is that the well-known expressiveness of rewrite rules to specify concurrent systems <ref type="bibr" target="#b24">[25]</ref> is in this way naturally extended to specify concurrent probabilistic systems. In fact, a PMaude specification may have both probabilistic rewrite rules and ordinary rewrite rules, which can be viewed as a no-probability special case of probabilistic rules. The language allows high-level specification of a wide-range of probabilistic systems. In particular, it supports concurrent object-oriented programming through actors. PMaude specifications can be simulated in the underlying Maude language. We have also introduced QuaTEx, a language to specify quantitative temporal expressions that can be used to query various quantitative aspects of a probabilistic model. We have already used PMaude and VeStA to model and analyze a DoS resistant TCP/IP protocol <ref type="bibr" target="#b2">[3]</ref>. We plan to use the tool to model and analyze various other network protocols.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Clock illustrating probabilistic non-deterministic systems</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>with a single occurrence of a single variable, , called the hole. Two contexts C and C are A-equivalent if and only if A (‚àÄ ) C = C . Notice that the relation of A-equivalence for contexts defined above is an equivalence relation on the set of contexts. We use [C] A for the equivalence class containing context C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>op EXPONENTIAL : PosReal ‚Üí PosReal . op BERNOULLI : PosReal ‚Üí Bool .The key rule in the SAMPLER module is the rule rl [rnd] : rand ‚áí float(random(counter + 1) / 4294967296) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Actor PMaude module</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Symmetric Polling System with 5-stations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>QFig. 5 .</head><label>5</label><figDesc>Fig. 5. Syntax of QuaTEx</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>computeExpectedValueOfX () Input: Œ±, Œ¥, X the random variable Output: Approximate E[X] begin n = 0; while(d &gt; Œ¥) begin n = n + 100; Let x 1 , . . . , x n be n samples of X d = 2t Œ±/2,n-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>PMaude module in Example 2.1, is then the module</figDesc><table><row><cell>mod EXPONENTIAL-CLOCK-TRANSFORMED is</cell></row><row><cell>protecting POSREAL .</cell></row><row><cell>protecting PMAUDE .</cell></row><row><cell>sort Clock .</cell></row><row><cell>op clock : PosReal PosReal ‚Üí Clock .</cell></row><row><cell>op broken : PosReal PosReal ‚Üí Clock .</cell></row><row><cell>vars T C t : PosReal .</cell></row><row><cell>var B : Bool .</cell></row><row><cell>rl [advance]: clock(T,C) ‚áí if BERNOULLI( C 1000 ) then clock(T+EXPONENTIAL(1.0),C-C 1000 ) else broken(T,C-C 1000 ) fi</cell></row><row><cell>rl [reset]: clock(T,C) ‚áí clock(0.0,C) .</cell></row><row><cell>endm</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>adds the term Obj to [v ] A through multiset union to get the term [v ] A , and ‚Ä¢ replaces the global time of the term [v ] A with T' to get the final term [w] A .</figDesc><table><row><cell>mod ACTORS is</cell></row><row><cell>protecting PosReal .</cell></row><row><cell>sorts ActorName Attribute AttributeList Content .</cell></row><row><cell>sorts Actor Msg Object Config ScheduledObject .</cell></row><row><cell>subsort Attribute &lt; AttributeList .</cell></row><row><cell>subsort Actor &lt; Object .</cell></row><row><cell>subsort Msg &lt; Object .</cell></row><row><cell>subsort Object &lt; Config .</cell></row><row><cell>subsort PosReal &lt; Config .</cell></row><row><cell>subsort ScheduledObject &lt; Config .</cell></row><row><cell>op empty : ‚Üí Content .</cell></row><row><cell>op _‚Üê _ : ActorName Content ‚Üí Msg .</cell></row><row><cell>op name:_|_ : ActorName AttributeList ‚Üí Actor .</cell></row><row><cell>op nil : ‚Üí AttributeList .</cell></row><row><cell>op null : ‚Üí Config .</cell></row><row><cell>Such a one-step computation represents a single step in a discrete-event sim-</cell></row><row><cell>ulation of a model written in actor PMaude.</cell></row></table><note><p><p><p><p>representing the global state of a system, (ii)</p>[v]  </p>A is term obtained after a sequence (zero or more) of one-step rewrites such that</p>‚Ä¢ in none of those rewrites is the tick rule applied, and ‚Ä¢ [v] A cannot be further rewritten by applying any rule except the tick rule. (iii) [w] A is obtained after a one-step rewrite of [v] A by applying the tick rule, which does the following ‚Ä¢ finds and removes the scheduled object, if one exists, with the smallest global time, say [T',Obj], from the term [v] A to a term, say [v ] A , ‚Ä¢ Example 3.1 As an example, let us consider the model in Fig. 3. In the example, a client c continuously sends messages to a server s. The time interval between the messages is distributed exponentially with rate 2.0. The message sending of the client is triggered when it receives a self-sent message op __ : Config Config ‚Üí Config [assoc comm id: null] . op _,_ : AttributeList AttributeList ‚Üí AttributeList [assoc id: nil] . op [_,_] : PosReal Object ‚Üí ScheduledObject . *** tick rule is omitted for brevity endm</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>time() then 0 else if connected () then 1</figDesc><table><row><cell>else</cell><cell>(IfConnectedInTime(t)) fi fi;</cell></row><row><cell cols="2">eval E[IfConnectedInTime(time() + 100)];</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>function mapping k state expressions to a state expression, or a formal parameter. A path expression can be a state expression, a next operator followed by an application of a temporal operator defined in D, or a conditional expression if SExp then PExp 1 else PExp 2 fi. We assume that expressions are properly typed. Typically, these types would be integer, real, boolean etc. The condition SExp in the expression if SExp then PExp 1 else PExp 2 fi must have the type boolean. The temporal expression PExp in the expres-</figDesc><table /><note><p>sion E[PExp] must be of type real.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0"><p>Note that there are other formalisms which provide both rigorous formal basis and the features of high-level programming languages<ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b8">9]</ref>. PMaude differs from them as it extends rewrite theories rather than extending process-algebra or automata based formalisms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_1"><p>The underscores ( ) in a mixfix operator represent the placeholders for its arguments.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_2"><p>Note that PosReal is a subset of Configuration.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>The authors would specially like to acknowledge Nirman Kumar for his contribution to the development of an earlier finitary version of PMaude. The work is supported in part by the DARPA IXO NEST Program F33615-01-C-1907, the ONR Grant N00014-02-1-0715, and the Motorola Grant MOTOROLA RPF #23.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , (s)[[SExp k ]]D ) (s)[[E[PExp]]]D = E[(œÄ)[[PExp]]D ] for</head><p>where N (x1, . . . , xm) = B; ‚àà D Fig. <ref type="figure">6</ref>. Semantics of QuaTEx</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Example Encoding of Standard Temporal Operators</head><p>In probabilistic computation tree logic (PCTL) <ref type="bibr" target="#b14">[15]</ref> and continuous stochastic logic (CSL) <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6]</ref> a compound temporal logic operator is the until operator U. A path satisfies œÜ 1 UœÜ 2 , iff some state s along the path satisfies œÜ 2 and all states before s along the path satisfies œÜ 1 . We can easily encode the until operator as follows:</p><p>The operator takes as arguments two state expressions œÜ 1 and œÜ 2 of type Boolean. It returns 1 if œÜ 1 UŒ¶ 2 holds along the path and 0 otherwise. We return 1 and 0 instead of true or false because we may want to calculate the probability that a path from a given state satisfies œÜ 1 UœÜ 2 , i.e., Pr [œÜ 1 UœÜ 2 ]. For example the following QuaTEx expression</p><p>queries the probability that a message is received without re-sending. The state predicates (or state expressions of type Boolean) resend() and receive() returns true iff a message is re-sent and received in the current state, respectively. Note that ¬¨ is a unary function with the usual meaning mapping a state expression to another state expression.</p><p>Similarly, we can encode the bounded until operator œÜ 1 U ‚â§t œÜ 2 of CSL as follows:</p><p>UntilBounded(œÜ1, œÜ2, t) = if t &gt; time() then 0 else if œÜ2 then 1 else if œÜ1 then (UntilBounded(œÜ1, œÜ2, t)) else 0 fi fi fi;</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Verifying continuous-time Markov chains</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aziz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sanwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Singhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Computer Aided Verification (CAV&apos;96)</title>
		<meeting>the 8th International Conference on Computer Aided Verification (CAV&apos;96)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1102</biblScope>
			<biblScope unit="page" from="269" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Actors: A Model of Concurrent Computation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Formal modeling and analysis of dos using probabilistic rewrite theories</title>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Greenwald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Thati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Foundations of Computer Security (FCS&apos;05</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Affiliated with LICS&apos;05</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A foundation for actor computation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">A</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Talcott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1" to="72" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Customization and composition of distributed objects: middleware abstractions for policy management</title>
		<author>
			<persName><forename type="first">M</forename><surname>Astley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGSOFT &apos;98/FSE-6: Proceedings of the 6th ACM SIGSOFT international symposium on Foundations of software engineering</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Model-checking continuous-time Markov chains</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aziz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sanwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Singhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="162" to="170" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Rule-based runtime verification</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 5th International Conference on Verification, Model Checking and Abstract Interpretation (VMCAI&apos;04)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th International Conference on Verification, Model Checking and Abstract Interpretation (VMCAI&apos;04)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004-01">January 2004</date>
			<biblScope unit="volume">2937</biblScope>
			<biblScope unit="page" from="44" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Model checking of probabilistic and nondeterministic systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bianco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>De Alfaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 15th Conference on the Foundations of Software Technology and Theoretical Computer Science (FSTTCS&apos;95)</title>
		<meeting>15th Conference on the Foundations of Software Technology and Theoretical Computer Science (FSTTCS&apos;95)</meeting>
		<imprint>
			<publisher>LNCS</publisher>
			<biblScope unit="volume">1026</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The modest modeling tool and its implementation</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Bohnenkamp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Katoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Klaren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th International Conference on Computer Performance Evaluations, Modelling Techniques and Tools</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2794</biblScope>
			<biblScope unit="page" from="116" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Specification and proof in membership equational logic</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bouhoula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">236</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="35" to="132" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Maude: specification and programming in rewriting logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dur√°n</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mart√≠-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Quesada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="page" from="187" to="243" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dur√°n</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mart√≠-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</author>
		<ptr target="http://maude.cs.uiuc.edu/maude2-manual/" />
		<imprint>
			<date type="published" when="2003-06-00">Maude 2.0 Manual, Version 1.0, june 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Algebras and automata for timed and stochastic systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Argenio</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<pubPlace>Enschede, The Netherlands</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Twente</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the role of generalized semi-markov processes in simulation output analysis</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Glynn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSC &apos;83: Proceedings of the 15th IEEE conference on Winter simulation</title>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="39" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A logic for reasoning about time and reliability</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jonsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="512" to="535" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Process algebra for performance evaluation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Herzog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Katoen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Compututer Science</title>
		<imprint>
			<biblScope unit="volume">274</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="43" to="87" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A Compositional Approach to Performance Modelling</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hillston</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
	<note>Distinguished Dissertations Series</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Hogg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">T</forename><surname>Craig</surname></persName>
		</author>
		<title level="m">Introduction to Mathematical Statistics</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Macmillan</publisher>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
	<note>fourth edition</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Stochastic petri net models of polling systems</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">C</forename><surname>Ibe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Trivedi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1649" to="1657" />
			<date type="published" when="1990-12">Dec. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Probabilistic rewrite theories: Unifying models, logics and tools</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
		<idno>UIUCDCS-R-2003-2347</idno>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
		<respStmt>
			<orgName>University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A rewriting based model for probabilistic distributed object systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 6th IFIP International Conference on Formal Methods for Open Object-based Distributed Systems (FMOODS&apos;03)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>6th IFIP International Conference on Formal Methods for Open Object-based Distributed Systems (FMOODS&apos;03)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2884</biblScope>
			<biblScope unit="page" from="32" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Z</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
		<title level="m">Prism: Probabilistic symbolic model checker</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Modelling with Generalized Stochastic Petri Nets</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Marsan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Balbo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Conte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Donatelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Franceschinis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>John Wiley and Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Conditional rewriting logic as a unified model of concurrency</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="155" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A logical theory of concurrent objects and its realization in the Maude language</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research Directions in Concurrent Object-Oriented Programming</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="314" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Membership algebra as a logical framework for equational specification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WADT&apos;97</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Parisi-Presicce</surname></persName>
		</editor>
		<meeting>WADT&apos;97</meeting>
		<imprint>
			<publisher>Springer LNCS 1376</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="18" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Specification of real-time and hybrid systems in rewriting logic</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>√ñlveczky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="page" from="359" to="405" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Markov Decision Processes: Discrete Stochastic Dynamic Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Puterman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>John Wiley and Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Modelling and Verification of Randomized Distributed Real Time Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Segala</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Statistical model checking of black-box probabilistic systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th conference on Computer Aided Verification (CAV&apos;04)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004-07">July 2004</date>
			<biblScope unit="volume">3114</biblScope>
			<biblScope unit="page" from="202" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On statistical model checking of stochastic systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th conference on Computer Aided Verification (CAV&apos;05)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Edinburgh, Scotland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-07">July 2005</date>
			<biblScope unit="volume">3576</biblScope>
		</imprint>
	</monogr>
	<note>To Appear</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Introduction to the Numerical Solution of Markov Chains</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Stewart</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<pubPlace>Princeton</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A protocol description language for customizing semantics</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Sturman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Reliable Distributed Systems</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="148" to="157" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
