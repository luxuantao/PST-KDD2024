<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Tool for Profiling the Energy Usage of Mobile Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Jason</forename><surname>Flinn</surname></persName>
							<email>fjflinn@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Tool for Profiling the Energy Usage of Mobile Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8DBD26A3BA37A499C844082FF2E64C7C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we describe the design and implementation of PowerScope, a tool for profiling energy usage by applications. PowerScope maps energy consumption to program structure, in much the same way that CPU profilers map processor cycles to specific processes and procedures. Our approach combines hardware instrumentation to measure current level with kernel software support to perform statistical sampling of system activity. Postprocessing software maps the sample data to program structure and produces a profile of energy usage by process and procedure. Using PowerScope, we have been able to reduce the energy consumption of an adaptive video playing application by 46%.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Energy is a critical resource for mobile computers <ref type="bibr" target="#b3">[5,</ref><ref type="bibr" target="#b6">8]</ref>. In spite of many improvements in low-power hardware design and battery life, there is now growing awareness that a strategically viable approach to energy management must include higher levels of the system <ref type="bibr">[2]</ref>. For example, a network application that offers acceptable service while temporarily disconnected can save a considerable amount of energy by suppressing non-essential wireless communication. The resulting savings add to those offered by energyefficient hardware. In contrast, efforts aimed solely at the hardware cannot benefit from application-specific knowledge.</p><p>Progress in energy-efficient software design requires the ability to attribute energy consumption to specific software components, in much the same way that CPU profilers such This research was sponsored by the Defense Advanced Research Projects Agency (DARPA), Air Force Materiel Command, USAF under agreement number F19628-96-C-0061, the Intel Corporation, and AT&amp;T Corporation. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of Intel, AT&amp;T, DARPA, or the U.S. Government.</p><p>as prof and gprof help expose code components that are wasteful of processor cycles. In this paper, we describe a tool called PowerScope that we have built to profile energy usage.</p><p>PowerScope maps energy consumption to program structure. Using PowerScope, one can determine what fraction of the total energy consumed during a certain time period is due to specific processes in the system. Further, one can drill down and determine the energy consumption of different procedures within a process. By providing such fine-grained feedback, PowerScope allows attention to be focused on those system components responsible for the bulk of energy consumption. As improvements are made to these components, PowerScope quantifies their benefits and helps expose the next target for optimization. Through successive refinement, a system can be improved to the point where its energy consumption meets design goals.</p><p>Our initial experience with this tool has been rewarding. By using PowerScope, we have obtained a 46% reduction in total energy consumption when an adaptive video application is run on the Odyssey platform for mobile computing <ref type="bibr" target="#b4">[6]</ref>. Some of the steps in the path to achieving this reduction were counterintuitive -certain obvious changes did not produce anticipated savings. Thus, although this research is still in its early stages, we are convinced that an energy profiling tool such as PowerScope is indispensable in building mobile computing systems. In the rest of this paper, we present the design and implementation of Power-Scope and describe its use in the adaptive video case study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Design considerations</head><p>The most important design consideration was for Power-Scope to gather sufficient information to produce a detailed picture of system activity. The usefulness of a profiling tool is directly related to how definitively it assigns costs to specific application events. Attributing costs in detail enables attention to be focused quickly on problem areas in the code. With this in mind, we felt it insufficient to map energy costs only to specific processes -we also desired to map costs to the procedure level.</p><p>A second consideration was that our tool monitor the activity of all processes executing on a computer system. We have found that profiling the activity of only a single process omits critical information about total energy usage. For instance, a task which blocks frequently may expend large amounts of energy on the screen, disk, and network when the processor is idle. Furthermore, asynchronous activity, such as network interrupts, can account for a significant portion of energy consumption. An energy profiler which monitors energy usage only when a specific process is executing will not account for the energy expended by these activities.</p><p>Finally, we have taken care to minimize the overhead generated by our tool. A profiler necessarily induces some overhead on the system that it monitors. For an energy profiler, this is reflected both in additional CPU usage and in additional energy expended during execution. We have striven to reduce this overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Implementation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Overview</head><p>The prototype version of PowerScope, shown in Figure <ref type="figure" target="#fig_0">1</ref>, uses statistical sampling to profile the energy usage of a computer system. To reduce overhead, profiles are generated by a two-stage process. During the data collection stage, the tool samples both the power consumption and the system activity of the profiling computer. PowerScope then generates an energy profile from this data during a later analysis stage. Because the analysis is performed off-line, it creates no profiling overhead.</p><p>During data collection, we use a digital multimeter to sample the current drawn by the profiling computer through its external power input. We require that this multimeter have an external trigger input and output, as well as the ability to sample DC current at high frequency. Our present implementation uses a Hewlett Packard 3458a digital multimeter, which satisfies both these requirements. A separate data collection computer controls the multimeter and stores current samples.</p><p>We considered an alternate implementation in which measurement and data collection were performed on the profiling computer using an on-board digital multimeter with a PCI or PCMCIA interface. However, this implementation makes it very difficult to differentiate the energy consumed by the profiled applications from the energy used by data collection and by the operation of the on-board multimeter. Further, our current implementation allows easy  Because our tool requires a small set of kernel modifications, we require that a source-available operating system run on the profiling computer. At present, we are using the NetBSD operating system. There is no specific operating system requirement for the data collection computer; we currently use Windows 95 to take advantage of manufacturer-provided device drivers for our multimeter.</p><p>The functionality of PowerScope is divided among three software components. Two components, the System Monitor and Energy Monitor, share responsibility for data collection. The System Monitor samples system activity on the profiling computer by periodically recording information which includes the program counter (PC) and process identifier (PID) of the currently executing process. The Energy Monitor runs on the data-collection computer, and is responsible for collecting and storing current samples. Because data collection is distributed across two monitor processes, it is essential that some synchronization method en-pscope_init (u_int size); pscope_read (void* sample, u_int size, u_int* ret_size); pscope_start (void); pscope_stop (void); The final software component, the Energy Analyzer, uses the raw sample data collected by the monitors to generate the energy profile. The analyzer runs on the profiling computer since it uses the symbol tables of the executables on disk to map samples to specific procedures. There is an implicit assumption in this method that the executables being profiled are not modified between the start of profile collection and the running of the off-line analysis tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">The System Monitor</head><p>The System Monitor consists of a user-level daemon process and a small set of modifications to the NetBSD kernel. Its design is similar to the sampling components of continuous profilers such as Morph <ref type="bibr" target="#b7">[9]</ref> and DCPI <ref type="bibr" target="#b0">[1]</ref>. Our current implementation samples system activity when triggered by the digital multimeter. Each twelve byte sample records the value of the program counter (PC) and the process identifier (PID) of the currently executing process, as well as additional information such as whether the system is currently handling an interrupt. This assumes that the profiling computer is a uniprocessor -a reasonable assumption for a mobile computer.</p><p>Samples are written to a circular buffer residing in kernel memory. This buffer is emptied by the user-level daemon, which writes the samples to disk. The daemon is triggered when the buffer grows more than 7/8 full, or at the end of data collection.</p><p>The System Monitor records a small amount of additional information to assist in the generation of energy profiles. The kernel fork(), exec(), and exit() routines are instrumented to record the pathname associated with each currently executing process. The NetBSD run-time system loader is also instrumented to record the loading of shared libraries. This information is written to the sample buffer during data collection, and is used during off-line analysis to associate each sample with a specific executable image on disk.</p><p>We created a small number of system calls, shown in Figure <ref type="figure" target="#fig_1">2</ref>, to allow applications to control profiling. The user-level daemon calls pscope init() to set the size of the kernel sample buffer. Since there is a tension between excessive memory usage and frequent reading of the buffer by the user-level daemon, the buffer size has been left flexible to allow efficient profiling of different workloads. The pscope read() system call is used by the user-level daemon to read samples out of the buffer. The pscope start() and pscope stop() system calls allow application programs to precisely indicate the period of sample collection. Multiple sets of samples may be collected one after the other; each sample set is delineated by start and end markers written into the sample buffer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">The Energy Monitor</head><p>The Energy Monitor runs on the data collection computer and communicates with the digital multimeter. It configures the multimeter to sample the current being drawn by the laptop from its external power source. In our experience, the voltage variation is extremely small (measured at less than 0.25%). Therefore, current samples alone are sufficient to determine the energy usage of the system. The battery is removed from the laptop while measurements are taken to avoid extraneous power drain caused by charging. Current samples are transmitted asynchronously to the Energy Monitor which stores them on disk for later analysis.</p><p>Sample collection is driven by the multimeter clock. Synchronization with the System Monitor is provided by connecting the multimeter's external trigger input and output to pins on the parallel port of the profiling computer. Immediately after the multimeter takes a current sample, it toggles the value of a parallel port pin. This causes a system interrupt on the profiling computer, during which the System Monitor samples system activity. Upon completion, the System Monitor triggers the next sample by toggling another parallel port pin (unless profiling has been halted by the pscope stop system call). The multimeter buffers this trigger until the time to take the next sample arrives.</p><p>Our original design used the clock of the profiling computer to drive sample collection. Although simpler to implement, that design had the disadvantage of biasing the profile values of activities correlated with the system clock. Using the multimeter clock also allows us to generate interrupts at a finer granularity then that allowed by the kernel stat clock routine. The user may specify the sample period as a parameter when the Energy Monitor is started. For all measurements reported in this paper, we used a sample period of approximately 1.6 ms.  <ref type="figure">----------------------------------------------------------</ref>  <ref type="figure">-----------------------------------------------------------</ref>   <ref type="figure">-----------------------------------------------------------</ref>   </p><formula xml:id="formula_0">(W) ------------------------------ ---------- ---------- ----------</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">The Energy Analyzer</head><p>The Energy Analyzer generates an energy profile of system activity. Total energy usage can be calculated by integrating the product of the instantaneous current and voltage over time. We can approximate this value by simultaneously sampling both current, I t , and voltage, V t , at regular intervals of time t. Further, in our current implementation, V t is constant within the limits of accuracy for which we are striving. We therefore calculate total energy over n samples using a single measured voltage value, V meas , as follows:</p><formula xml:id="formula_1">E V meas n X t=0 I t t (1)</formula><p>The Energy Analyzer reads the raw data generated by the monitors and associates each current sample collected by the Energy Monitor with the corresponding sample collected by the System Monitor. The analyzer assigns each sample to a process bucket using the recorded PID value. Samples that occurred during the handling of an asynchronous interrupt, such as the receipt of a network packet, are not attributed to the currently executing process but are instead attributed to a bucket specific to the interrupt handler. If no process was executing when the sample was taken, the sample is attributed to a kernel bucket. The energy usage of each process is calculated as in Equation <ref type="formula">1</ref>by summing the current samples in each bucket and multiplying by the measured voltage (V meas ) and the sample interval ( t).</p><p>The analyzer then generates a summary of energy usage by process, such as the one shown in Figure <ref type="figure" target="#fig_4">3(a)</ref>. Each entry displays the total time spent executing the process, the total energy usage of the process, and the average power usage (simply calculated by dividing the energy value by the time value). We envision extending this summary to include histograms of energy usage over time.</p><p>The analyzer repeats the above steps for each process to determine the energy usage by procedure. The process and shared library information stored by the System Monitor is used to reconstruct the memory address of each procedure from the symbol tables stored on disk. Then, the PC value of each sample is used to place the sample in a procedure bucket. When the profile is generated, procedures that reside in shared libraries and kernel procedures can be displayed separately. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Case study: adaptive video</head><p>We decided to test the effectiveness of our tool by using it to reduce the energy consumption of an adaptive video-  The application currently adapts to changing network conditions by varying the video quality. When bandwidth drops, the client plays tracks encoded with a greater amount of lossy compression. We were curious to see if the adaptivity could be extended to conserve client energy usage. In this design, when battery life is low, the player would use less energy by displaying a degraded version of the current video. Therefore, one of the goals of our case study was to identify a method for creating significant energy savings by slightly degrading the quality of the video. Of course, we also sought to reduce the total energy consumption of the video player across all track qualities.</p><p>For the following study, the client machine is a 75 MHz 486 IBM 701C laptop with 24 MB of memory and the server is a 200 MHz Pentium Pro with 64 MB of memory. The client and server communicate using a wireless 900 MHz Lucent WaveLAN network. Figure <ref type="figure" target="#fig_7">5</ref> shows the measured power consumption for key components of the client machine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Effect of lossy compression</head><p>We first used PowerScope to measure the energy used to play three video tracks which varied only in the amount of lossy compression used for encoding. Each track was generated from the same 184 second 320x240 pixel video clip using Adobe Premiere. For reference, we have labeled these compression levels Premiere-A, Premiere-B, and Premiere-C. Premiere-A is the highest quality track, and Premiere-C This figure shows the measured power consumption of components of the IBM 701C laptop in their various power states. Power consumption is slightly but consistently superlinear; for example, the machine consumes 8.69 W when the screen is at its brightest and the disk and network are idle, which is 0.08 W more than the sum of the individual power consumption of each component when measured separately. The last row displays the power consumed by the laptop when the disk, screen, and network are all powered off. Each reported value is the mean of five trials -in all cases, the sample standard deviation is less than 0.01 W. This figure shows the characteristics of the five video tracks used in this case study. All tracks were generated from the same video clip and are 184 seconds in length. From left to right, the columns describe the amount of lossy compression used to encode the video, the size of the video display (in pixels), the size of the video (in megabytes) and the data rate (in kilobits per second). All tracks were encoded in QuickTime CinePak format using Adobe Premiere. Premiere-A is the highest quality track. Premiere-C is the lowest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 6. Video Track Characteristics</head><p>is the lowest. The basic characteristics of the video tracks are shown in the first three rows of Figure <ref type="figure">6</ref>.</p><p>The results of this experiment are shown in Figure <ref type="figure">7</ref>(a). To our surprise, playing tracks with greater compression results in only a small (13.5%) reduction in energy usage. Analysis of the energy usage by process revealed that compression significantly reduces the energy used by networkrelated activities (the Odyssey process and asynchronous WaveLAN interrupts) and the xanim video player. However, the energy consumed by the X server remains relatively unaffected by the amount of compression, most probably because it operates only on data that has already been decoded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Effect of display size</head><p>We next decided to try to reduce the X server's energy usage by reducing the size of the video display from 320x240 pixels to 160x120. We therefore generated two 160x120 tracks, one encoded at Premiere-A and one encoded at Premiere-C, from the same video clip used in the previous experiment. Figure <ref type="bibr">7(b)</ref> shows the effects of reducing the display size for both encodings.</p><p>Despite having a greater data rate, the Premiere-A 160x120 video consumes less energy than the Premiere-C 320x240 video. The greater energy usage for networkrelated activities is more than compensated for by an approximately 75% reduction in energy usage by the X server. When the Premiere-C 160x120 video track is played, the largest energy reduction (24.3%) is achieved. The majority of the energy consumption for this track occurs when the CPU is idle.</p><p>We conjectured that this behavior indicated that most of the energy was now being consumed by keeping hardware devices such as the network and disk in their idle states. To test this, we measured the power expended by the profiling computer with the screen on, and the CPU, network, and disk idle. This configuration uses 7.80 Watts, which projected over the length of the video accounts for 1434 Joules, or 94% of the total energy consumed by the Premiere-C 160x120 track. Clearly, this value represents the upper bound on the energy savings that can be achieved by degrading the video without changing the power state of client hardware components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Effect of network power management</head><p>These results led us to explore the feasibility of powering down hardware components when they are not in use. Although the display accounts for the majority of the energy consumed by the client, it is difficult to imagine how it could be disabled while the video is playing. Our efforts therefore concentrated on the network interface and the hard drive.</p><p>As shown in Figure <ref type="figure" target="#fig_7">5</ref>, completely powering down the WaveLAN interface achieves a power savings of 1.57 Watts. However, restarting the interface from this state requires 137 milliseconds, which is less than ideal for a networkintensive application like our video player. Fortunately, our WaveLAN hardware supports the ability to disable only those components that can be quickly restarted, including the RF-modem. We modified our NetBSD WaveLAN driver by adding ioctl operations which support transitions to and from this standby mode. Our measurements indicate that the interface consumes only 0.15 Watts while in standby mode and requires only 0.81 milliseconds to resume transmission.</p><p>We next modified Odyssey to manage the power state of the WaveLAN interface. Odyssey fetches frames from the server using a RPC protocol. After each RPC completes, Odyssey puts the interface into standby mode until it is ready to initiate the next RPC. Here, we assume that the video player is the only application using the network.</p><p>As shown in Figure <ref type="figure">7</ref>(c), network power management reduces the energy consumption of all tracks, achieving greater reductions for tracks which require less network activity. The video player consumes 33.1% less energy playing the Premiere-C 160x120 track (the rightmost bar in Figure <ref type="figure">7</ref>(c)) compared to playing the Premiere-A 320x240 track (the leftmost bar in Figure <ref type="figure">7(c)</ref>). When compared to playing the Premiere-A 320x240 track with no network power management (the leftmost bar in Figure <ref type="figure">7</ref>(a)), the energy reduction is 36.9%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Effect of disk power management</head><p>Since the video player buffers frames entirely in memory, the disk is not required when playing a video. We therefore modified Odyssey to power down the disk when the video first starts to play. As shown in Figure <ref type="figure">7</ref>(d), this reduces the amount of energy needed to play each track by approximately 195 Joules. With both network and disk power management, degrading the quality of the video provides an energy savings of 36.3%. This value is calculated by comparing the Premiere-C 160x120 track (the rightmost bar in Figure <ref type="figure">7(d)</ref>) with the 320x240 Premiere-A track (the leftmost bar in Figure <ref type="figure">7(d)</ref>). Cumulatively applying all optimizations in this case study achieves a 46.2% energy savings compared to playing the Premiere-A 320x240 track without power management (the leftmost bar in Figure <ref type="figure">7</ref>(a)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Related work</head><p>To the best of our knowledge, PowerScope is the first tool that maps energy consumption to program structure. At the same time, our development of the tool was motivated by previous work in CPU profiling. In particular, the implementation of the System Monitor is closely related to similar components of continuous profilers such as Morph <ref type="bibr" target="#b7">[9]</ref> and DCPI <ref type="bibr" target="#b0">[1]</ref>.</p><p>Several researchers have previously investigated power management in the context of wireless networks and disks. Stemm and Katz <ref type="bibr" target="#b5">[7]</ref> measured the power consumption of several network interfaces. They also presented simulation results showing how powering down the network interface could reduce energy consumption for e-mail and webbrowsing applications. Kravets and Krishnan <ref type="bibr" target="#b2">[4]</ref> proposed a transport-level protocol which powers down the network interface for short periods and measured the reduction in energy consumption for communication patterns typical of common applications. Douglis et al. <ref type="bibr" target="#b1">[3]</ref> investigated the energy implications of various strategies for powering down the disk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion</head><p>We believe PowerScope is a valuable tool that can facilitate further research in developing energy-efficient mobile applications. We are greatly encouraged by our initial study which reduced the energy consumption of an adaptive movie player by 46%. Our current plans for the tool include several enhancements.</p><p>In the short-term, we plan to repeat the movie player case study for at least one additional laptop computer. This will have the dual purpose of verifying the robustness of our tool across multiple hardware platforms and allowing us to obtain measurements for a more modern computer. We also plan additional experiments to carefully calibrate the performance of the tool.</p><p>In the longer-term, we plan to incorporate a more detailed model of the relationship between energy usage and battery life. In addition to total energy usage, other factors such as peak power levels can significantly effect battery life. Our enhancement would be mostly to the analyzer component since we currently collect sufficiently detailed sample data to support more complex analysis.</p><p>Finally, we plan to use our tool to investigate the behavior of multiple adaptive applications which concurrently access hardware components such as the network and disk. In this and other areas of investigation, PowerScope promises to be of considerable assistance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. PowerScope Architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. PowerScope API</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(c) Partial Detail of WaveLAN Interrupt Energy UsageThis figure shows a sample energy profile for an adaptive video playing application. Part (a) summarizes the energy usage by process. Part (b) shows a portion of the detailed profile for a single process, while part (c) shows a portion of the detailed profile for WaveLAN interrupts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Sample Energy Profile</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 (</head><label>3</label><figDesc>b) shows a partial profile of one typical process, and Figure3(c) shows a partial profile of WaveLAN interrupts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>the architecture of an adaptive video-playing application. Odyssey prefetches frames from the remote server. They are subsequently decoded by the xanim process and displayed by the X server.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Video Application</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Power Measurements for IBM 701C</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Tom Martin helped us considerably with his many useful suggestions and his assistance with our experimental setup. Bob Baron provided us with his NetBSD kernel expertise. Dushyanth Narayanan, David Petrou, Eric Tilton, and Kip Walker provided much useful feedback during the course of this project.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Energy (Joules)</head><p>Premiere-A 320x240</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Premiere-C 320x240</head><p>Premiere-A 160x120</p><p>Premiere-C 160x120 shows the effect of powering down the disk. Note that the effects are applied cumulatively, so that part (d) shows the aggregate effect of all four power-saving strategies. Each reported result is the mean of five trials. The number of dropped or late frames was less than 4% in every trial. Refer to Figure <ref type="figure">6</ref> for the size and data rate of each video track.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 7. Reducing the Energy Consumption of a Video Player</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Continuous Profiling: Where Have All the Cycles Gone?</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Berc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-T</forename><forename type="middle">A</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Sites</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Vandevoorde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Waldspurger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Weihl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM Symposium on Operating Systems and Principles</title>
		<meeting>the 16th ACM Symposium on Operating Systems and Principles<address><addrLine>Saint-Malo, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Thwarting the Power-Hungry Disk</title>
		<author>
			<persName><forename type="first">F</forename><surname>Douglis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Marsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 1994 Winter USENIX Conference</title>
		<meeting>1994 Winter USENIX Conference</meeting>
		<imprint>
			<date type="published" when="1994-01">January 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Power Management Techniques for Mobile Communication</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kravets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Krishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The Fourth Annual ACM/IEEE International Conference on Mobile Computing and Networking (MOBICOM&apos;98)</title>
		<meeting>The Fourth Annual ACM/IEEE International Conference on Mobile Computing and Networking (MOBICOM&apos;98)</meeting>
		<imprint>
			<date type="published" when="1998-10">October 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Software Strategies for Portable Computer Energy Management</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Personal Communications</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Agile Application-Aware Adaptation for Mobility</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Tilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM Symposium on Operating Systems and Principles</title>
		<meeting>the 16th ACM Symposium on Operating Systems and Principles<address><addrLine>Saint-Malo, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Measuring and Reducing Energy Consumption of Network Interfaces in Hand-Held Devices</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stemm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Transactions on Communications</title>
		<imprint>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="1997-08">August 1997</date>
		</imprint>
	</monogr>
	<note>Special Issue on Mobile Computing</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Scheduling for Reduced CPU Energy</title>
		<author>
			<persName><forename type="first">M</forename><surname>Weiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Welch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Demers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First USENIX Symposium on Operating System Design and Implementation (OSDI)</title>
		<meeting>the First USENIX Symposium on Operating System Design and Implementation (OSDI)<address><addrLine>Monterey, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-11">November 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">System Support for Automated Profiling and Optimization</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gloy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM Symposium on Operating Systems and Principles</title>
		<meeting>the 16th ACM Symposium on Operating Systems and Principles<address><addrLine>Saint-Malo, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
