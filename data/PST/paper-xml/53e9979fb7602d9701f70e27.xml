<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Beautiful Interpolants</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Aws</forename><surname>Albarghouthi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kenneth</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Beautiful Interpolants</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">42B7F1668AD44DC18AB55D509289E58B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe a compositional approach to Craig interpolation based on the heuristic that simpler proofs of special cases are more likely to generalize. The method produces simple interpolants because it is able to summarize a large set of cases using one relatively simple fact. In particular, we present a method for finding such simple facts in the theory of linear rational arithmetic. This makes it possible to use interpolation to discover inductive invariants for numerical programs that are challenging for existing techniques. We show that in some cases, the compositional approach can also be more efficient than traditional lazy SMT as a decision procedure.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>beau•ti•ful adjective \'byü-ti-f@l\ 1: ...exciting aesthetic pleasure 2: generally pleasing <ref type="bibr" target="#b1">[2]</ref> In mathematics and physics, the beauty of a theory is an important quality. A simple or elegant argument is considered more likely to generalize than a complex one. Imagine, for example, proving a conjecture about an object in N dimensions. We might first try to prove the special case of two or three dimensions, and then generalize the argument to the N -dimensional case. We would prefer a proof of the two-dimensional case that is simple, on the grounds that it will be less prone to depend on particular aspects of this case, thus more likely to generalize. We can apply this heuristic to the proof of programs or hardware systems. We produce a proof of correctness for some bounded collection of program executions. From this proof we can derive a conjectured invariant of the program using Craig interpolation methods, e.g., <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b10">11]</ref>. The simpler our conjecture, the less it is able to encode particular aspects of our bounded behaviors, so the more likely it is to be inductive. Typically, our bounded proofs will be produced by an SMT (satisfiability modulo theories) solver. Simplicity of our interpolant-derived conjecture depends on simplicity of the SMT solver's proof. Unfortunately, for reasons we will discuss shortly, SMT solvers may produce proofs that are far more complex than necessary.</p><p>In this paper, we consider an approach we call compositional SMT that is geared to produce simple interpolants. It is compositional in the sense that the interpolant acts as an intermediate assertion between components of the formula, localizing the reasoning. This approach allows us to solve inductive invariant generation problems that are difficult for other techniques, and in some cases can solve bounded verification problems much more efficiently than standard lazy SMT <ref type="bibr" target="#b7">[8]</ref> methods. The approach is simple to implement and uses an unmodified SMT solver as a "black box".</p><p>A lazy SMT solver separates the problems of Boolean and theory reasoning. To test satisfiability of a formula A relative to a theory T , it uses a SAT solver to find propositionally satisfying assignments. These can be thought of as disjuncts in the disjunctive normal form (DNF) of A. A theory solver then determines feasibility of these disjuncts in T . In the negative case, it produces a theory lemma. This is a validity of the theory that contradicts the disjunct propositionally. In the worst case, each theory lemma rules out only one amongst an exponential collection of disjuncts.</p><p>In compositional SMT, we refute satisfiability of a conjunction A ∧ B by finding an interpolant formula I, such that A ⇒ I, B ⇒ ¬I and I uses only the symbols common to A and B. We do this by building two collections of feasible disjuncts of A and B that we call samples. We then try to construct a simple interpolant I for the two sample sets. If I is an interpolant for A and B, we are done. Otherwise, we use our SMT solver to find a new sample that contradicts either A ⇒ I or B ⇒ ¬I, and restart the process with the new sample.</p><p>Unlike the theory solver in lazy SMT, our interpolant generator can "see" many different cases and try to find a simple fact that generalizes them. This more global view allows compositional SMT to find very simple interpolants in cases when lazy SMT produces an exponential number of theory lemmas.</p><p>We develop the technique here in the quantifier-free theory of linear rational arithmetic (QFLRA). This allows us to apply some established techniques based on Farkas' lemma to search for simple interpolants. The contributions of this paper are (1) A compositional approach to SMT based on sampling and interpolation (2) An interpolation algorithm for QFLRA based on finding linear separators for sets of convex polytopes. (3) A prototype implementation that demonstrates the utility of the technique for invariant generation, and shows the potential to speed up SMT solving.</p><p>Organization. Sec. 2 illustrates our approach on a simple example. Sec. 3 gives a general algorithm for interpolation via sampling. Sec. 4 describes an interpolation technique for sets of convex polytopes. Sec. 5 presents our implementation and experimental results. Related work is discussed in Sec. 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivating Example</head><p>Figure <ref type="figure" target="#fig_0">1</ref> shows two QFLRA formulas A and B over the variables x and y. For clarity of presentation, the two formulas are in DNF, where A 1 , A 2 , and A 3 are the disjuncts of A, and B 1 and B 2 are the disjuncts of B. Intuitively, since a disjunct is a conjunction of linear inequalities (half-spaces), it represents a convex polyhedron in R 2 . Fig. <ref type="figure" target="#fig_2">2</ref>(a) represents A and B geometrically, where each disjunct is highlighted using a different shade of gray. We start by sampling disjuncts from A and B. In practice, we sample a disjunct from a formula ϕ by finding a model m |= ϕ, using an SMT solver, and evaluating all linear inequalities occurring in ϕ with respect to m. Suppose we sample the disjuncts A 2 and B 1 . We now find an interpolant of (A 2 , B 1 ). To do so, we utilize Farkas' lemma and encode a system of constraints that is satisfiable iff there exists a half-space interpolant of (A 2 , B 1 ). That is, we are looking for an interpolant comprised of a single linear inequality, not an arbitrary Boolean combination of linear inequalities. In this case, we might find the half-space interpolant y ≤ 2.5, shown in Fig. <ref type="figure" target="#fig_2">2(c</ref>).</p><formula xml:id="formula_0">A =(x ≤ 1 ∧ y ≤ 3) (A1) ∨ (1 ≤ x ≤ 2 ∧ y ≤ 2) (A2) ∨ (2 ≤ x ≤ 3 ∧ y ≤ 1) (A3) B =(x ≥ 2 ∧ y ≥ 3) (B1) ∨ (x ≥ 3 ∧ 2 ≤ y ≤ 3) (B2)</formula><p>We call y ≤ 2.5 a partial interpolant, since it is an interpolant of A 2 and B 1 , which are parts of (i.e., subsumed by) A and B, respectively. We now check if this partial interpolant is an interpolant of (A, B) using an SMT solver. First, we check if A ∧ y &gt; 2.5 is satisfiable. Since it is satisfiable, A ⇒ y ≤ 2.5, indicating that y ≤ 2.5 is not an interpolant of (A, B). A satisfying assignment of A∧y &gt; 2.5 is a model of A that lies outside the region y ≤ 2.5, for example, the point <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b2">3)</ref> shown in Fig. <ref type="figure" target="#fig_2">2(c</ref>). Since (1, 3) is a model of the disjunct A 1 , we add A 1 to the set of samples in order to take it into account.</p><p>At this point, we have two A samples, A 1 and A 2 , and one B sample B 1 . We now seek an interpolant for (A 1 ∨ A 2 , B 1 ). Of course, we can construct such an interpolant by taking the disjunction of two half-space interpolants: one for (A 1 , B 1 ) and one for (A 2 , B 1 ). Instead, we attempt to find a single half-space that is an interpolant of (A 1 ∨A 2 , B 1 ) -we say that the samples A 1 and A 2 are merged into a sampleset {A 1 , A 2 }. As before, we construct a system of constraints and solve it for such an interpolant. In this case, we get the half-space x+y ≤ 4, shown in Fig. <ref type="figure" target="#fig_2">2(d)</ref>. Since x + y ≤ 4 is an interpolant of (A, B), the algorithm terminates successfully. If there is no half-space interpolant for (A 1 ∨ A 2 , B 1 ), we split the sampleset {A 1 , A 2 } into two samples, and find two half-space interpolants for (A 1 , B 1 ) and (A 2 , B 1 ).</p><p>The key intuition underlying our approach is two-fold: (1) Lazily sampling a small number of disjuncts from A and B often suffices for finding an interpolant for all of A and B. (2) By merging samples, e.g., as A 1 and A 2 above, and encoding a system of constraints to find half-space interpolants, we are forcing  the procedure to take a holistic view of the problem and produce simpler and possibly more general interpolants.</p><formula xml:id="formula_1">y x A2 (1, 3) 3 2 1 y ≤ 2.5 B1 y x A1 A2 x + y ≤ 4 3 2 1 3 2 1 B1 (c) (d) y x A1 A2 A3 3 2 1 3 2 1 B1 B2 (e)</formula><p>Given the formulas A and B, an SMT solver is generally unable to find the simple fact x + y ≤ 4, due to the specificity of the theory lemmas it produces.</p><p>For example, we used the MathSAT SMT solver to find an interpolant for A and B, and it produced the following formula<ref type="foot" target="#foot_0">1</ref> :</p><formula xml:id="formula_2">(x ≤ 2 ∧ y ≤ 2) ∨ ((x ≤ 1 ∨ y ≤ 1) ∧ ((x ≤ 2 ∧ y ≤ 2) ∨ (x ≤ 1 ∨ y ≤ 1))),</formula><p>illustrated in Fig. <ref type="figure" target="#fig_2">2(e</ref>). This interpolant is more complex and does not capture the emerging pattern of the samples. As we add more disjuncts to A and B following the pattern, the interpolants produced by MathSAT grow in size, whereas our approach produces the same result. This ability to generalize a series is key to invariant generation. In the SMT approach, the theory solver sees only one pair of disjuncts from A and B at a time, and thus cannot generalize.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Constructing Interpolants from Samples</head><p>We now present Csmt (Compositional SMT), a generic algorithm for computing an interpolant for a pair of quantifier-free first-order formulas (A, B). Csmt attempts to partition samples from A and B as coarsely as possible into samplesets, such that each A sampleset can be separated from each B sampleset by an atomic interpolant formula (for linear arithmetic, this means a single linear constraint). Although Csmt applies to any theory that allows quantifier-free interpolation, for concreteness, we consider here only linear arithmetic.</p><p>Preliminaries. A formula of quantifier-free linear rational arithmetic, LRA, is a Boolean combination of atoms. Each atom is a linear inequality of the form</p><formula xml:id="formula_3">c 1 x 1 + • • • + c n x n k,</formula><p>where c 1 , . . . , c n and k are rational constants, x 1 , . . . , x n are distinct variables, and is either &lt; or ≤. The atom is an open or closed half-space if is &lt; or ≤, respectively. We use LinIq(ϕ) to denote the set of atoms appearing in formula ϕ, and Vars(ϕ) to denote the set of variables. We will often write cx k for a half-space c 1 x 1 + • • • + c n x n k, where c is the row vector of the coefficients {c i }, and x is the column vector of the variables {x i }.</p><p>A model of ϕ is an assignment of rational values to Vars(ϕ) that makes ϕ true. Given a model m of ϕ, we define the sample of ϕ w.r.t. m, written sample ϕ (m), as the formula</p><formula xml:id="formula_4">{P | P ∈ LinIq(ϕ), m |= P } ∧ {¬P | P ∈ LinIq(ϕ), m |= P }.</formula><p>Note, there are finitely many samples of ϕ and ϕ is equivalent to the disjunction of its samples. Geometrically, each sample can be thought of as a convex polytope.</p><p>Given two formulas A, B ∈ LRA such that A∧B is unsatisfiable, an interpolant of (A, B) is a formula I ∈ LRA such that Vars(I) ⊆ Vars(A) ∩ Vars(B), A ⇒ I, and B ⇒ ¬I. An interpolant exists for every inconsistent (A, B). General Algorithm. We formalize Csmt in Fig. <ref type="figure" target="#fig_3">3</ref> as a set of guarded commands. In each, if the condition above the line is satisfied, the assignment below may be executed. The state of Csmt is defined by the following variables:</p><formula xml:id="formula_5">Init SA := ∅ SB := ∅ PItp := ∅ • Rules for distributing samples into samplesets: X ∈ {A, B} s1 ∈ SX s2 ∈ SX s1 = s2 Merge SX := (SX \ {s1, s2}) ∪ {s1 ∪ s2} X ∈ {A, B} s1 ∪ s2 ∈ SX s1 = ∅ s2 = ∅ Split SX := (SX \ {s1 ∪ s2}) ∪ {s1} ∪ {s2}</formula><p>• Rules for constructing and checking interpolants: Initially, as dictated by the command Init,</p><formula xml:id="formula_6">sA ∈ SA sB ∈ SB HalfItp(sA, sB) = PItp(sA, sB) is undefined PartialItp PItp(sA, sB) := HalfItp(sA, sB) C = Cand(SA, SB, PItp) = m |= A ∧ ¬C CheckItpA SA := SA ∪ {{sample A (m)}} C = Cand(SA, SB, PItp) = m |= C ∧ B CheckItpB SB := SB ∪ {{sample B (m)}} • Termination conditions: sA ∈ SA sB ∈ SB |sA| = |sB| = 1 HalfItp(sA, sB) = Sat A ∧ B is satisfiable C = Cand(SA, SB, PItp) A ⇒ C C ⇒ ¬B Unsat C is an interpolant of (A, B)</formula><formula xml:id="formula_7">S A = S B = ∅. -Partial interpolant map PItp is a map from pairs of samplesets to half-spaces. Invariantly, if (s A , s B ) is in the domain of PItp then PItp(s A , s B ) is an inter- polant for ( s A , s B ).</formula><p>We do not attempt to find a smallest set of half-spaces that separate the samples, as this problem is NP-complete. This can be shown by reduction from k-polyhedral separability: given two sets of points on a plane, is there a set of less than k half-spaces separating the two sets of points <ref type="bibr" target="#b25">[26]</ref>. Instead, we heuristically cluster the samples into large samplesets such that each pair of samplesets (s A ,s B ) is linearly separable. Even with a minimal clustering, this solution may be sub-optimal, in the sense of using more half-spaces than necessary. Since our objective is a heuristic one, we will seek reasonably simple interpolants with moderate effort, rather than trying to optimize.</p><p>In practice, we heuristically search the space of clusterings using Merge and Split. Merge is used to combine two samplesets in S {A,B} and make them a single sampleset. Split performs the opposite of Merge: it picks a sampleset in S {A,B} and splits it into two samplesets. The command PartialItp populates the map PItp with interpolants for pairs of samplesets (s A , s B ). This is done by calling HalfItp (s A , s B ), which returns a half-space interpolant of ( s A , s B ) if one exists, and the symbol otherwise (Sec. 4 presents an implementation of HalfItp).</p><p>The commands CheckItpA and CheckItpB check if the current candidate interpolant is not an interpolant of (A, B), in which case, samples produced from counterexamples are added to S A and S B . The function Cand constructs a candidate interpolant from PItp. If the domain of PItp contains S A × S B , then</p><formula xml:id="formula_8">Cand(S A , S B , PItp) ≡ sA∈SA sB ∈SB PItp(s A , s B )</formula><p>Otherwise the result is . The result of Cand is an interpolant of (A , B ), where A and B are the disjunction of all samples in S A and S B , respectively. This DNF formula may not be optimal in size. Synthesizing optimal candidate interpolants from partial interpolants is a problem that we hope to explore in the future.</p><p>If Sat or Unsat apply, then the algorithm terminates. Sat checks if two singleton samplesets do not have a half-space separating them. Since both samples define convex polytopes, if no half-space separates them, then they intersect, and therefore A ∧ B is satisfiable. Unsat checks if a candidate interpolant C is indeed an interpolant, in which case Csmt terminates successfully.</p><p>Example 1. Consider the formulas A and B from Sec. 2. Suppose that Csmt is in the state S A = {{A 2 }}, S B = {{B 1 }}, PItp = ∅, where A 2 and B 1 are the samples of A and B defined in Sec. 2. By applying PartialItp, we find a half-space separating the only two samplesets. As a result, PItp({A 2 }, {B 1 }) = y ≤ 2.5. Suppose we now apply CheckItpA. The candidate interpolant Cand(S A , S B , PItp) at this point is y ≤ 2.5. Since A ∧ y &gt; 2.5 is satisfiable, CheckItpA adds the sampleset {A 1 }, which is not subsumed by the candidate interpolant, to S A . Now, S A = {{A 1 }, {A 2 }}. Since we have two samplesets in S A , we apply Merge and get S A = {{A 1 , A 2 }}. PartialItp is now used to find a half-space interpolant for the samplesets {A 1 , A 2 } and {B 1 }. Suppose it finds the plane x + y ≤ 4. Then Unsat is applicable and the algorithm terminates with x + y ≤ 4 as an interpolant of (A, B).</p><p>The key rule for producing simpler interpolants is Merge, since it decreases the number of samplesets, and forces the algorithm to find a smaller number of half-spaces that separate a larger number of samples. In Example 1 above, if we do not apply Merge, we might end up adding all the samples of A and B to S A and S B . Thus, producing an interpolant with a large number of half-spaces like the one illustrated in Fig. <ref type="figure" target="#fig_2">2(e)</ref>.</p><p>Theorem 1 (Soundness of Csmt). Given two formulas A and B, if Csmt terminates using 1. Sat, then A ∧ B is satisfiable. 2. Unsat, then Cand(S A , S B , PItp) is an interpolant of (A, B).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (Sketch).</head><p>In case 1, by definition of the rule Sat, we know that there is a sample a of A and a sample b of B such that there does not exist a half-space I that is an interpolant of (a, b). Since both a and b define convex polytopes, if a and b do not have a half-space separating them, then a ∧ b is satisfiable, and therefore A ∧ B is satisfiable.</p><p>In case 2, the candidate interpolant C, checked in rule Unsat, is over the shared variables of A and B (by definition of HalfItp), A ⇒ C, and C ⇒ ¬B. Therefore, it is an interpolant of (A, B).</p><p>We now consider the termination (completeness) of Csmt. It is easy to see that one can keep applying the commands Merge and Split without ever terminating. To make sure that does not happen, we impose the restriction that for any sampleset in P {A,B} , if it is ever split, it never reappears in the sampleset collection. For example, if a sampleset s A ∈ S A is split into two samplesets s 1 A and s 2 A using Split, then s A cannot reappear in S A . Given this restriction, Csmt always terminates.</p><p>Theorem 2 (Completeness of Csmt). For any two formulas A and B, Csmt terminates.</p><p>Proof (Sketch). Since there are finitely many samples, CheckItpA, Check-ItpA and PartialItp must be executed finitely. Due to our restriction, Merge is also bounded. Thus, if we do not terminate, eventually Split reduces all samplesets to singletons, at which point Sat or Unsat must terminate the procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Half-Space Interpolants</head><p>In this section, we present a constraint-based implementation of the parameter HalfItp of Csmt. Given two samplesets s A and s B , our goal is to find a halfspace interpolant ix k of ( s A , s B ). Since both s A and s B represent a union (set) of convex polytopes, we could compute the convex hulls of s A and s B and use techniques such as <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b6">7]</ref> to find a half-space separating the two convex hulls. To avoid the potentially expensive convex hull construction, we set up a system of linear constraints whose solution encodes both the separating half-space and the proof that it is separating. We then solve the constraints using an LP solver. This is an extension of the method in <ref type="bibr" target="#b28">[29]</ref> from pairs of convex polytopes to pairs of sets of convex polytopes.</p><p>The intuition behind this construction is simple. We can represent the desired separator as a linear constraint I of the form ix ≤ k, where x is a vector of variables, i is a vector of unknown coefficients, and k is an unknown constant. We wish to solve for the unknowns i and k. To express the fact that I is a separator, we apply Farkas' lemma. This tells us that a set of linear constraints {C j } implies I exactly when I can be expressed as a linear combination of {C j } with non-negative coefficients. That is, when Σ j c j C j + d ≡ I for some non-negative {c j } and d. The key insight is that this equivalence is itself a set of linear equality constraints with unknowns {c j }, d, i and k. The values of {c j } and d constitute a certificate that in fact {C j } implies I. We can therefore construct constraints requiring that each sample in s A implies (is contained in) I, and similarly that each sample in s B implies ¬I (equivalent to -ix &lt; -k). Solving these constraints we obtain a separator I and simultaneously a certificate that I is a separator. What is new here is only that we solve for multiple Farkas proofs: one for each sample in s A or s B .</p><p>We now make this construction precise. Let</p><formula xml:id="formula_9">N A = |s A | and N B = |s B |. Each sample in s A is represented as a vector inequality A j x ≤ a j , for j ∈ [1, N A ]. Similarly, samples in s B are of the form B j x ≤ b j , for j ∈ [1, N B ].</formula><p>Here, x is a column vector of the variables Vars(A) ∪ Vars(B). For example, the sample y ≤ 1 ∧ z ≤ 3 is represented as follows:</p><formula xml:id="formula_10">1 0 0 1 y z ≤ 1 3</formula><p>In the remainder of this section, we assume that all samples are conjunctions of closed half-spaces, i.e., non-strict inequalities. (In <ref type="bibr" target="#b5">[6]</ref>, we present a simple extension to our construction for handling open half-spaces.) It follows that if there exists a half-space interpolant for ( s A , s B ), then there exists a closed half-space that is also an interpolant. Thus, our goal is to find a closed half-space ix ≤ k that satisfies the following two conditions:</p><formula xml:id="formula_11">∀j ∈ [1, N A ] • A j x ≤ a j ⇒ ix ≤ k (1) ∀j ∈ [1, N B ] • B j x ≤ b j ⇒ ¬ix ≤ k (2)</formula><p>Condition (1) specifies that ix ≤ k subsumes all s A samples. Condition <ref type="bibr" target="#b1">(2)</ref> specifies that ix ≤ k does not intersect with any of the s B samples. By forcing coefficients of unshared variables to be 0 in ix ≤ k, we ensure that ix ≤ k is an interpolant of ( s A , s B ). To construct such half-space interpolant, we utilize Farkas' lemma <ref type="bibr" target="#b29">[30]</ref>:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3 (Farkas' lemma). Given a satisfiable system of linear inequalities</head><p>Ax ≤ b and a linear inequality ix ≤ k, then: Ax ≤ b ⇒ ix ≤ k iff there exists a row vector λ ≥ 0 s.t. λA = i and λb ≤ k.</p><p>Using this fact, we construct a constraint Φ A that, when satisfiable, implies that a half-space ix ≤ k satisfies condition <ref type="bibr" target="#b0">(1)</ref>. Consider a sample A j x ≤ a j , where A j is an m j × n j matrix. We associate with this sample a row vector λ Aj of size m j , consisting of fresh variables, called Farkas coefficients of the m j linear inequalities represented by A j x ≤ a j . We now define Φ A as follows:</p><formula xml:id="formula_12">Φ A ≡ ∀j ∈ [1, N A ] • λ Aj ≥ 0 ∧ λ Aj A j = i ∧ λ Aj a j ≤ k</formula><p>The row vector i is of the form (i x1 • • • i xn ), where each i xj is a variable denoting the coefficient of variable x j in the interpolant. Similarly, k is a variable denoting the constant in the interpolant. Suppose we have an assignment to i, k, and λ Aj that satisfies Φ A . Then, by Farkas' lemma, the half-space ix ≤ k satisfies condition <ref type="bibr" target="#b0">(1)</ref>, where i and k are replaced by their assignment values. This because a satisfying assignment of Φ A implies that for every j ∈</p><formula xml:id="formula_13">[1, N A ], A j x ≤ a j ⇒ ix ≤ k.</formula><p>We now encode a constraint Φ B that enforces condition <ref type="bibr" target="#b1">(2)</ref>. As before, we associate a row vector λ Bj with each sample B j x ≤ b j . We define Φ B as follows:</p><formula xml:id="formula_14">Φ B ≡ ∀j ∈ [1, N B ] • λ Bj ≥ 0 ∧ λ Bj B j = -i ∧ λ Bj b j &lt; -k Following Farkas' lemma, a satisfying assignment of Φ B results in a half-space -ix &lt; -k that subsumes all samples in s B . That is, B j x ≤ b j ⇒ ¬ix ≤ k, for all j ∈ [1, N B ]</formula><p>, thus satisfying condition <ref type="bibr" target="#b1">(2)</ref>. Therefore, a satisfying assignment of Φ A ∧ Φ B produces a half-space interpolant ix ≤ k for ( s A , s ). Note that our encoding implicitly ensures that coefficients of unshared variables are 0 in ix ≤ k. See <ref type="bibr" target="#b5">[6]</ref> for an example of solving these constraints to obtain an interpolant. Thm. 4 below states soundness and completeness of our encoding for samples that are conjunctions of closed half-spaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4 (Soundness and Completeness of HalfItp). Given two samplesets (where all samples are systems of closed half-spaces), s A and s B , and their corresponding encoding</head><formula xml:id="formula_15">Φ ≡ Φ A ∧ Φ B , then: 1. If Φ is satisfiable using a variable assignment m, then i m x ≤ k m is an interpolant for ( s A , s B )</formula><p>, where i m and k m are the values of i and k in m, respectively. 2. Otherwise, no half-space interpolant exists for ( s A , s B ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation and Evaluation</head><p>We implemented the compositional SMT technique, Csmt, in the C language, using the Z3 SMT solver <ref type="bibr" target="#b26">[27]</ref> for constraint solving and sampling. The primary heuristic choice in the implementation is how to split and merge samplesets. The heuristics we use for this are described in <ref type="bibr" target="#b5">[6]</ref>, along with some optimizations that improve performance.</p><p>To experiment with Csmt, we integrated it with Duality <ref type="bibr" target="#b24">[25]</ref>, a tool that uses interpolants to construct inductive invariants. We will call this CsmtDua.</p><p>In the configuration we used, Duality can be thought of as implementing Lazy Abstraction With Interpolants (LAWI), as in Impact <ref type="bibr" target="#b21">[22]</ref>. The primary difference is that we use a large-block encoding <ref type="bibr" target="#b8">[9]</ref>, so that edges in the abstract reachability tree correspond to complete loop bodies rather than basic blocks.</p><p>Sequence Interpolants with Csmt. Duality produces sequences of formulas corresponding to (large block) program execution paths in static single assignment (SSA) form, and requires interpolants to be computed for these sequences. An interpolant sequence for formulas A 1 , . . . , A n is a sequence of formulas I 1 , . . . , I n-1 where I i is an interpolant for ( k≤i A k , k&gt;i A k ). The interpolant sequence must also be be inductive, in the sense that this application, an inductive interpolant sequence can be thought of as a Hoare logic proof of the given execution path.</p><formula xml:id="formula_16">I i-1 ∧A i ⇒ I i . In Program CsmtDua CPA Ufo InvGenAI InvGenCS f2 ✔ ✗ ✗ ✗f ✗f gulv ✔ ✗ ✗ ✗f ✗f gulv simp ✔ ✔ ✔ ✔ ✔ substring1 ✔ ✗ ✔ ✔ ✔ pldi08 ✔ ✔ ✔ ✗f ✗f pldi082unb ✔ ✗ ✗ ✔ ✔ xy0 ✔ ✗ ✗ ✔ ✔ xy10 ✔ ✔ ✔ ✔ ✔ xy4 ✔ ✗ ✗ ✔ ✔ xyz ✔ ✗ ✗ ✔ ✔ xyz2 ✔ ✗ ✗ ✔ ✔ dillig/01 ✔ ✔ ✔ ✔ ✔ dillig/03 ✔ ✗ ✗ ✔ ✔ dillig/05 ✔ ✗ ✔ ✔ ✔ dillig/07 ✔ ✔ ✔ ✔ ✔ dillig/09 ✔ ✗ ✗ ✔ ✗ dillig/12 ✔ ✗ ✔ ✗ ✗ dillig/15 ✔ ✔ ✔ ✔ ✔ dillig/17 ✔ ✔ ✗ ✔ ✔ dillig/19 ✔ ✔ ✔ ✗f ✗f dillig/20 ✔ ✔ ✔ ✗f ✗f dillig/24 ✔ ✔ ✔ ✔ ✔ dillig/25 ✔ ✔ ✔ ✔ ✗f dillig/28 ✔ ✗ ✗ ✔ ✔ dillig/31 ✔ ✔ ✗ ✔ ✗ dillig/32 ✔ ✔ ✔ ✔ ✔ dillig/33 ✔ ✔ ✗f ✗ ✗ dillig/35 ✔ ✔ ✔ ✗f ✗f dillig/37 ✔ ✔ ✔ ✗f ✗f dillig/39 ✔ ✔ ✔ ✔ ✔ #Solved 30<label>17</label></formula><p>A key heuristic for invariant generation is to try to find a common interpolant for positions that correspond to the same program location. The requirement to find a simple common interpolant forces us to "fit" the emerging pattern of consecutive loop iterations, much as occurs in Figure <ref type="figure" target="#fig_2">2(b)</ref>. We can easily reduce the problem of finding a common interpolant to finding a single interpolant for a pair (A, B), provided we know the correspondence between variables in successive positions in the sequence. Say we have substitutions σ i mapping each program variables to its instance at position i in the SSA sequence. We construct formula A as i&lt;n</p><formula xml:id="formula_17">( k≤i A k )(σ -1 i ) and B as i&lt;n ( k&gt;i A k )(σ -1 i ).</formula><p>That is, A represents all the prefixes of the execution path and B all the suffixes. If I is an interpolant for (A, B), then the sequence {I i } where I i = Iσ i is an interpolant sequence for A 1 , . . . , A n . If it is inductive, we are done, otherwise we abandon the goal of a common interpolant.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Evaluation</head><p>We now present an evaluation of Csmt. First, we compare CsmtDua against a variety of verification tools on a set of benchmarks requiring non-trivial numerical invariants. Second, we demonstrate how our prototype implementation of Csmt can outperform Z3 at SMT solving. Finally, we compare the size of the interpolants computed by Csmt to those computed by iZ3 <ref type="bibr" target="#b22">[23]</ref>, an interpolating version of Z3.</p><p>Csmt for Verification. We compared CsmtDua against the state-of-theart verifiers CPAChecker (CPA) <ref type="bibr" target="#b9">[10]</ref> and Ufo <ref type="bibr" target="#b4">[5]</ref> -the top abstractionbased verifiers from the 2013 software verification competition (SV-COMP) <ref type="bibr" target="#b0">[1]</ref>.</p><p>CPA is a lazy abstraction tool that admits multiple configurations -we used its predicate abstraction and interpolation-based refinement configuration predicateAnalysis. Ufo is an interpolation-based verification tool that guides interpolants with abstract domains [4,3] -we did not use any abstract domains for guidance (using an abstract domain does not change the number of solved benchmarks). We also compared against InvGen <ref type="bibr" target="#b16">[17]</ref>, an invariant generation tool that combines non-linear constraint solving, numerical abstract domains, and dynamic analysis to compute safe invariants. We use InvGenAI to denote the default configuration of InvGen, and InvGenCS to denote a configuration where abstract interpretation invariants are not used to strengthen invariants computed by constraint solving (-nostrength option).</p><p>To study the effectiveness of CsmtDua, we chose small C programs from the verification literature that require non-trivial numeric invariants. The benchmarks f2, gulv*, and substring1 are from <ref type="bibr" target="#b14">[15]</ref>. The benchmarks pldi08* are from <ref type="bibr" target="#b15">[16]</ref>. The benchmarks xy* are variations on a classic two-loop example requiring linear congruences. The benchmarks dillig/* were provided Dillig, et al. <ref type="bibr" target="#b12">[13]</ref>. Some are from the literature and some are original and are intended to test arithmetic invariant generation. We omitted benchmarks using the mod operator, as we do not support this, and also elided some duplicates and near-duplicates. The benchmarks and tool output are available at http://www.cs.utoronto.ca/ ~aws/cav13.zip.</p><p>Fig. <ref type="figure">4</ref> shows the result of applying Csmt and the aforementioned tools on 30 such benchmarks. In the table, ✔ means the tool verified the program, ✗ means that the tool timed out (after 60s), and ✗ f means the tool terminated unsuccessfully. The run times in successful cases tend to be trivial (less than 2s), so we do not report them. We observe that CsmtDua produced proofs for all benchmarks, whereas CPA and Ufo failed to prove 13, and InvGenAI failed to prove 9.</p><p>This shows the effectiveness of the heuristic that simple proofs tend to generalize. For example, in the case of pldi082unb, CsmtDua produces the intricate invariant x+y-2N ≤ 2∧y ≤ x. On the other hand, interpolant-based refinement in CPA and Ufo diverges, producing an unbounded sequence of predicates only containing x and N .</p><p>Compositional SMT Solving. One way prove unsatisfiability of a formula Φ ≡ A ∧ B is to exhibit an interpolant I of (A, B). Using Csmt, this might be more efficient than direct SMT solving because (1) Csmt only makes SMT queries on the components A and B, and (2) by merging samples, Csmt can find proofs not available to the SMT solver's theory solver. This is especially true if Φ has many disjuncts.</p><p>Suppose, for example, we have</p><formula xml:id="formula_18">A ≡ x 0 = y 0 = 0 ∧ n i=1 (inc i ∨ eq i ) B ≡ 2n i=n+1 (dec i ∨ eq i ) ∧ x 2n = 0 ∧ y 2n = 0, where inc i is x i = x i-1 + 1 ∧ y i = y i-1 + 1, dec i is x i = x i-1 -1 ∧ y i = y i-1 -1 and eq i is x i = x i-1 ∧ y i = y i-1 .</formula><p>The formula Φ n = A ∧ B is essentially the BMC formula for our benchmark xy0, where the two loops are unrolled n times. The pair (A, B) has a very simple interpolant, that is, x n = y n , in spite of the fact that each of A and B have 2 n disjuncts. Moreover, the conjunction A ∧ B has 2 2n disjuncts. In a lazy SMT approach, each of these yields a separate theory lemma. Fig. <ref type="figure">6</ref> shows the time (in seconds) taken by Z3 and Csmt to prove unsatisfiability of Φ n for n ∈ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14]</ref>. For n = 10, Z3 takes 160 seconds to prove unsatisfiability of Φ n , whereas Csmt requires 1.4 seconds. For n &gt; 10, Z3 terminates without producing an answer. This shows that a compositional approach can be substantially more efficient in cases where a large number of cases can be summarized by a simple interpolant.</p><p>Interpolant Size. We now examine the relative complexity of the interpolants produced by Csmt and SMT-based interpolation methods, represented by iZ3 <ref type="bibr" target="#b22">[23]</ref>.</p><p>For our formulas, we used BMC unrollings of s3 clnt 1, an SSH benchmark from the software verification competition (SV-COMP) <ref type="bibr" target="#b0">[1]</ref>. Fig. <ref type="figure">5</ref> shows the sizes of the interpolants computed by iZ3 and Csmt (and the time taken to compute them) for unrollings (#Iter) of N iterations of the loop, with the interpolant taken after N/2 iterations. The size of the interpolant is measured as the number of operators and variables appearing in it. Since the loop has a reachability depth of 14, all the interpolants from N = 30 are false. For N = 12, the interpolant size for iZ3 is 447, whereas for Csmt it is 2, a 200X reduction. A large reduction in interpolant size is observed for most unrolling lengths. Notice that, since this example has few execution paths, SMT is quite fast. This illustrates the opposite case from the previous example, in which the compositional approach is at a significant performance disadvantage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>We compare Csmt against interpolation and invariant generation techniques.</p><p>Constraint-Based Techniques. In <ref type="bibr" target="#b28">[29]</ref>, Rybalchenko and Stokkermans describe a method of for computing half-spaces separating two convex polytopes using Farkas' lemma. Here, we generalize this method to separators for sets of polytopes. This helps us search for a simple interpolant separating all the samples, rather than constructing one separating plane for each sample pair. This in turn gives us an interpolation procedure for arbitrary formulas in QFLRA, rather than just conjunctions of literals.</p><p>Interpolants from Classifiers. Our work is similar in flavor to, and inspired by, an interpolant generation approach of Sharma et al. <ref type="bibr" target="#b30">[31]</ref>. This approach uses point samples of A and B (numerical satisfying assignments) rather than propositional disjuncts. A machine learning technique -Support Vector Machines (SVM's)is used to create linear separators between these sets. The motivation for using disjuncts (polytopes) rather than points is that they give a broader view of the space and allow us to exploit the logical structure of the problem. In particular, it avoids the difficult problem of clustering random point samples in a meaningful way. In practice, we found that bad clusterings led to complex interpolants that did not generalize. Moreover, we found the SVM's to be highly sensitive to the sample set, in practice often causing the interpolation procedure to diverge, e.g., by finding samples that approach the boundary of a polytope asymptotically.</p><p>Interpolants from Refutation Proofs. A number of papers have studied extracting "better" interpolants from refutation proofs. For example, <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b27">28]</ref> focused on the process of extracting interpolants of varying strengths from refutation proofs. Hoder et al. <ref type="bibr" target="#b18">[19]</ref> proposed an algorithm that produces syntactically smaller interpolants by applying transformations to refutation proofs. Jhala and McMillan <ref type="bibr" target="#b19">[20]</ref> described a modified theory solver that yields interpolants in a bounded language. In contrast, we have taken the approach of structuring the proof search process expressly to yield simple interpolants. Our method can compute simpler and more general interpolants, by discovering facts that are not found in refutation proofs produced by lazy SMT solvers. On the other hand, constructing interpolants from refutation proofs can be much faster in cases where the number of theory lemmas required is small. Also, while the compositional approach may be applicable to the various theories handled by proof-based interpolation, we have as yet only developed a method for LRA.</p><p>Template Methods. A more direct approach to synthesize linear inductive invariants is based on Farkas' Lemma and non-linear constraint solving <ref type="bibr" target="#b11">[12]</ref>. The invariant is expressed as a fixed conjunction of linear constraints with unknown coefficients, and one solves simultaneously for the invariant and the Farkas proof of its correctness. This has the advantage, relative to the interpolant approach, that it does not require unfolding the program and the disadvantage that it requires a non-linear arithmetic solver. Currently, such solvers do not scale to more than a few variables. Thus, the difficulty of finding a solution grows rapidly with the number of constraints in the invariant <ref type="bibr" target="#b11">[12]</ref>. An example of a tool using this approach is InvGen, run without abstract interpretation (called InvGenCS in Table <ref type="table">4</ref>). An examination of the 12 cases in which InvGenCS fails shows that in most the invariant we found has at least three conjuncts, and in some it is disjunctive, a case that the authors of InvGen have found impractical using the method <ref type="bibr" target="#b16">[17]</ref>. Thus, it appears that by searching for simple interpolants, we can synthesize invariants with greater propositional complexity than can be obtained using the constraint-based approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have developed a compositional approach to interpolation based on the heuristic that simpler proofs of special cases are more likely to generalize. The method produces simple (perhaps even beautiful) interpolants because it is able to summarize a large set of cases using one relatively simple fact. In particular, we presented a method for finding such simple facts in the theory of linear rational arithmetic. This made it possible to use interpolation to discover inductive invariants for numerical programs that are challenging for existing techniques. We also observed that for formulas with many disjuncts, the compositional approach can be more efficient than non-compositional SMT.</p><p>Our work leaves many avenues open for future research. For example, can the method be effectively applied to integer arithmetic, or the theory of arrays? From a scalability standpoint, we would like to improve the performance of Csmt on formulas requiring more complex interpolants. One possible direction is parallelism, e.g., instead of decomposing a formula into A∧B, we could decompose it into multiple sets of conjuncts and use techniques such as <ref type="bibr" target="#b17">[18]</ref> to parallelize SMT solving.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Inconsistent formulas A and B</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. (a) Illustration of the formulas A and B. (b) An interpolant x + y ≤ 4 for (A, B). (c) An interpolant y ≤ 2.5 for (A2, B1). (d) An interpolant x + y ≤ 4 for samples (A1 ∨ A2 B1). (e) An interpolant computed by MathSAT5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Csmt as guarded commands</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>17 21 18 Fig. 4 .</head><label>184</label><figDesc>Fig. 4. Verification results of Csmt, CPAChecker, Ufo, and two configurations of InvGen on a collection of C benchmarks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Fig. 5. Size of interpolants from Csmt and iZ3 for BMC unrollings of increasing length</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Produced using MathSAT 5.2.2, and slightly modified for clarity of presentation.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://sv-comp.sosy-lab.org/" />
		<title level="m">Competition On Software Verification</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Merriam-Webster</forename><surname>Dictionary</surname></persName>
		</author>
		<ptr target="www.merriam-webster.com" />
		<imprint>
			<date type="published" when="2012-12">December 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Craig interpretation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Albarghouthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gurfinkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chechik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS 2012</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Miné</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Schmidt</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7460</biblScope>
			<biblScope unit="page" from="300" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">From under-approximations to overapproximations and back</title>
		<author>
			<persName><forename type="first">A</forename><surname>Albarghouthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gurfinkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chechik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2012</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>König</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7214</biblScope>
			<biblScope unit="page" from="157" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ufo: A framework for abstraction-and interpolation-based software verification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Albarghouthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gurfinkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chechik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2012</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7358</biblScope>
			<biblScope unit="page" from="672" to="678" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Beautiful interpolants</title>
		<author>
			<persName><forename type="first">A</forename><surname>Albarghouthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<idno>MSR-TR- 2013-42</idno>
		<imprint>
			<date type="published" when="2013-04">April 2013</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Counter-example guided predicate abstraction of hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ivančić</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2003</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Hatcliff</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2619</biblScope>
			<biblScope unit="page" from="208" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Satisfiability modulo theories</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tinelli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Handbook of Satisfiability</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Software Model Checking via Large-Block Encoding</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Griggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Keremoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
		<editor>FMCAD</editor>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">cPAchecker: A tool for configurable software verification</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Keremoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2011</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6806</biblScope>
			<biblScope unit="page" from="184" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient Generation of Craig Interpolants in Satisfiability Modulo Theories</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Griggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Linear invariant generation using non-linear constraint solving</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Colón</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sankaranarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Sipma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2003</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Hunt</surname><genName>Jr</genName></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2725</biblScope>
			<biblScope unit="page" from="420" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Personal Communication</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Interpolant strength</title>
		<author>
			<persName><forename type="first">D'</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Purandare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weissenbacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI 2010</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Hermenegildo</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">5944</biblScope>
			<biblScope unit="page" from="129" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Automatically Refining Abstract Interpretations</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Gulavani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2008</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Ramakrishnan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Rehof</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4963</biblScope>
			<biblScope unit="page" from="443" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Program analysis as constraint solving</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="281" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">InvGen: An efficient invariant generator</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2009</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Bouajjani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="634" to="640" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Lazy decomposition for distributed decision procedures</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hamadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marques-Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Wintersteiger</surname></persName>
		</author>
		<editor>PDMC</editor>
		<imprint>
			<date type="published" when="2011">2011. 2011</date>
			<biblScope unit="page" from="43" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Playing in the grey area of proofs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Hoder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kovács</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 2012</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="259" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A practical and complete approach to predicate refinement</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2006</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Palsberg</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3920</biblScope>
			<biblScope unit="page" from="459" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Lifting propositional interpolants to the wordlevel</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weissenbacher</surname></persName>
		</author>
		<editor>FMCAD</editor>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="85" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Interpolation and SAT-Based Model Checking</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2003</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Hunt</surname><genName>Jr</genName></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2725</biblScope>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Interpolants from Z3 proofs</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMCAD 2011</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="19" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An interpolating theorem prover</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2004</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Jensen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2988</biblScope>
			<biblScope unit="page" from="16" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Computing relational fixed points using interpolation</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
		<idno>MSR-TR-2013-6</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the complexity of polyhedral separability</title>
		<author>
			<persName><forename type="first">N</forename><surname>Megiddo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete &amp; Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="325" to="337" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Z3: An Efficient SMT Solver</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2008</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Ramakrishnan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Rehof</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4963</biblScope>
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Leveraging interpolant strength in model checking</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Rollini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2012</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7358</biblScope>
			<biblScope unit="page" from="193" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Constraint solving for interpolation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sofronie-Stokkermans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symb. Comput</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1212" to="1233" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Theory of linear and integer programming</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schrijver</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>John Wiley &amp; Sons, Inc</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Interpolants as classifiers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2012</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7358</biblScope>
			<biblScope unit="page" from="71" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Interpolant strength revisited</title>
		<author>
			<persName><forename type="first">G</forename><surname>Weissenbacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT 2012</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7317</biblScope>
			<biblScope unit="page" from="312" to="326" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
