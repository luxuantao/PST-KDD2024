<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">sFuzz: An Efficient Adaptive Fuzzer for Solidity Smart Contracts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Tai</forename><forename type="middle">D</forename><surname>Nguyen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Long</forename><forename type="middle">H</forename><surname>Pham</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jun</forename><surname>Sun</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Yun</forename><surname>Lin</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Quang</forename><surname>Tran</surname></persName>
							<email>quangtran@hcmut.edu.vn</email>
						</author>
						<author>
							<persName><forename type="first">Quang</forename><forename type="middle">Tran</forename><surname>Minh</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Singapore Management University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Singapore Management University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Singapore Management University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Ho Chi Minh City University of Technology</orgName>
								<address>
									<country key="VN">Vietnam</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">sFuzz: An Efficient Adaptive Fuzzer for Solidity Smart Contracts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6A17A7173C9A7C9CB7753CCBD57570FB</idno>
					<idno type="DOI">10.1145/3377811.3380334</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Smart contracts are Turing-complete programs that execute on the infrastructure of the blockchain, which often manage valuable digital assets. Solidity is one of the most popular programming languages for writing smart contracts on the Ethereum platform. Like traditional programs, smart contracts may contain vulnerabilities. Unlike traditional programs, smart contracts cannot be easily patched once they are deployed. It is thus important that smart contracts are tested thoroughly before deployment. In this work, we present an adaptive fuzzer for smart contracts on the Ethereum platform called sFuzz. Compared to existing Solidity fuzzers, sFuzz combines the strategy in the AFL fuzzer and an efficient lightweight multi-objective adaptive strategy targeting those hard-to-cover branches. sFuzz has been applied to more than 4 thousand smart contracts and the experimental results show that (1) sFuzz is efficient, e.g., two orders of magnitude faster than state-of-the-art tools; (2) sFuzz is effective in achieving high code coverage and discovering vulnerabilities; and (3) the different fuzzing strategies in sFuzz complement each other.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Ethereum <ref type="bibr">[1,</ref><ref type="bibr" target="#b30">31]</ref> is the first to introduce the functionality of smart contracts. Based on the Ethereum platform, Solidity is the most popular programming language for smart contracts <ref type="bibr">[6]</ref>.</p><p>Like traditional C or Java programs, smart contracts may contain vulnerabilities. Unlike traditional programs, smart contracts cannot be modified easily once they are deployed on the blockchain <ref type="bibr" target="#b22">[23]</ref>. As a result, a vulnerability renders the smart contract forever vulnerable, which significantly magnifies the problem. In recent years, there has been an increasing number of news reports on attacks which exploit security vulnerabilities in Ethereum smart contracts. One particularly noticeable example is the DAO attack <ref type="bibr" target="#b11">[12]</ref>, i.e., an attacker stole more than 3.5 million Ether (which is equivalent to about $45 million USD at the time) exploiting a vulnerability in the DAO contract. To fix the vulnerability, a hard fork was launched which was not only expensive but also caused much controversy <ref type="bibr" target="#b11">[12]</ref>.</p><p>It is thus desirable to develop tools for validating smart contracts to identify vulnerabilities, ideally before they are deployed. Among the range of complementary techniques for validating smart contracts, we focus on automatic testing of smart contracts in this work as testing is often the least expensive and thus the most applicable. To automatically test smart contracts, we must solve the following three problems:</p><p>• the test automation problem (i.e., how to run test cases),</p><p>• the test generation problem (i.e., what to test),</p><p>• and the oracle problem (i.e., what are vulnerabilities).</p><p>In the literature, several approaches have been developed for automatic testing smart contracts, each of which answers these three problems in slightly different ways. For instance, ContractFuzzer <ref type="bibr" target="#b17">[18]</ref> builds a network with pre-deployed contracts and generates transactions to run smart contracts, generates test cases based on a set of predefined parameter values and targets a set of oracles specific for smart contracts. Oyente <ref type="bibr" target="#b21">[22]</ref> runs smart contracts symbolically through symbolic execution, generates test cases for covering different program paths in single functions through constraint solving, and supports multiple oracles to identify 4 kinds of vulnerabilities. teEther <ref type="bibr" target="#b20">[21]</ref> similarly applies symbolic execution to generate test cases covering program paths, and focuses on oracles which are related to financial transactions.</p><p>In this work, we propose a fully automatic testing engine for smart contracts running on Ethereum called sFuzz. sFuzz is inspired by AFL <ref type="bibr" target="#b6">[7]</ref>, a well-known fuzzer for C programs, i.e., sFuzz is a feedback-guided fuzzing engine and is inexpensive to apply. sFuzz complements existing testing engines based on symbolic execution like Oyente and teEther, as it is known that fuzzing and symbolic execution are complementary <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b31">32]</ref>. While AFL-based fuzzing is often effective, it has its limitation as well, i.e., it is often expensive in covering branches guarded with strict conditions. To tackle the problem, sFuzz integrates AFL-based fuzzing with an efficient lightweight adaptive strategy for selecting seeds. Although inspired by search-based software testing <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b23">24]</ref>, the latter distinguishes itself by having a lightweight objective function (designed considering characteristics of Solidity programs) as well as a novel multi-objective optimization strategy.</p><p>sFuzz is built based on Aleth [2] (i.e., an Ethereum VM written in C++), has a system architecture similar to AFL, and is extensible to different Ethereum VMs and oracles as well as fuzzing strategies. sFuzz has been systematically applied to a set of more than 4 thousand smart contracts. The experimental results show that sFuzz is on average more than two orders of magnitudes faster than ContractFuzzer, covers more branches and reveals many more vulnerabilities. A comparison between sFuzz and Oyente shows that they are complementary. Furthermore, experiments with prolonged fuzzing time show that the adaptive strategy improves code coverage. sFuzz is available online and has been adopted by multiple companies.</p><p>The remainder of the paper is organized as follows. Section 2 illustrates how sFuzz works through examples. Section 3 presents the details of the approach. Section 4 shows implementation details of sFuzz. Section 5 reports evaluation results. Section 6 reviews related work and concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">ILLUSTRATIVE EXAMPLES</head><p>In this section, we show how sFuzz works step-by-step through two illustrative examples. Note that Solidity source codes for both examples are shown for simplicity. sFuzz requires only the EVM (i.e., Ethereum Virtual Machine) bytecode <ref type="bibr">[1,</ref><ref type="bibr" target="#b30">31]</ref> to fuzz smart contracts.</p><p>Given a smart contract, sFuzz automatically configures a blockchain network, deploys the smart contract, and generates multiple transactions each of which calls a function in the contract. The transactions are then executed with an EVM enriched with a set of oracles for identifying vulnerabilities. sFuzz monitors the execution of the transactions to collect certain feedback, e.g., whether a certain branch has been covered and how far the branch is covered. Whenever a vulnerability is revealed, the transactions and the network configuration (i.e., a test case) are saved and reported to the user later on. Otherwise, some of the test cases are selected as seeds based on feedback collected during the transaction execution according to certain seed selection criteria. Afterwards, the seeds are mutated to generate the next generation of test cases. This process repeats until a time out occurs.</p><p>In the following, we describe how sFuzz works using the contract shown in Figure <ref type="figure" target="#fig_0">1</ref>. The contract implements a simple quiz game. The contract is based on contract opposite_дame 1 with minor modification for simplicity. A quiz can be created by calling function start_quiz_дame. The response is hashed and then saved in the responseHash variable. The user then calls the try function with their answer as the argument and pays a fee of 100 f inney (which This contract suffers from a vulnerability known as Gasless Send when line 11 is executed and a costly fallback function is called. That is, when function send() at line 11 is executed, if the receiver is a contract, its fallback function is executed automatically. Because function send() only forwards 2300 units of gas (i.e., price to pay for executing the function), an out-of-gas exception is thrown if the fallback function is costly (e.g., costs more than 2300 units of gas). In this case, the send() function simply returns f alse and because the returned value is not checked and handled accordingly, the owners of the contract can keep the reward for themselves.</p><p>To expose this vulnerability, first a network is configured with several addresses and associated balances. This contract is then deployed at one of the addresses. In addition, an attacker contract with a costly fallback function is deployed automatically. To expose the vulnerability, a test case (i.e., a sequence of transactions) with such a network configuration must first call function start_quiz_дame and then function Try with parameters such that all 2 conditions in function Try at line 9 and 10 are satisfied. The condition at line 9 is satisfied with a test case that sets all the parameters and contract variables to the default value of 0. Note that responseHash is set to keccak256(_answer ) at line 16 and is compared to keccak256(_response) at line 9. However, generating a test case which satisfies the second condition by randomly generated test values is highly unlikely. The variable msд.value has a size of 32 bytes and thus we have only 1 2 256 probability to generate the value 100 (if we generate random values with a uniform distribution among all possible values). Existing fuzzing strategy in AFL is ineffective in this case as well, i.e., AFL selects test cases that cover new branches as seeds. Since all test cases generated through mutation are unlikely to cover the then-branch at line 10, they are equally 'bad' according to the AFL seed selection strategy.</p><p>sFuzz complements AFL's seed selection strategy with an adaptive strategy that prioritizes the seeds according to a quantitative measure (i.e., a distance) on how far a seed is from covering The above example shows a simplistic situation where there is only one just-missed branch. In general, there may be multiple just-missed branches and thus sFuzz measures a distance for each pair of test case and just-missed branch, i.e., how far is the branch from being covered by the test case. Then for each just-missed branch, sFuzz selects the test case with the minimum distance as the seed. For instance, the contract in Figure <ref type="figure">2</ref> shows a function which performs some basic arithmetic operations. There are two different branches, i.e., the condition at line 5 for comparing y with 110 and the one at line 6 for comparing y with 10010. Assume that both then-branches are yet to be covered. Given any test case, sFuzz computes two distances, one for covering the first then-branch; and the other for covering the second then-branch. Given a set of test cases, sFuzz selects, for each of these two branches, a test case which has minimum distance as seed, to generate further test cases. After repeating the process multiple times, sFuzz generates two test cases that cover the two then-branches. We remark that for this example, due to the non-linear computation at line 4, approaches based on symbolic execution like Oyente <ref type="bibr" target="#b21">[22]</ref> and teEther <ref type="bibr" target="#b20">[21]</ref> are ineffective due to the limitation of underlying constraint solvers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">FUZZING SMART CONTRACTS</head><p>In this section, we define our problem and then present our approach in detail step-by-step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Problem Definition</head><p>A smart contract S typically has a number of instance variables, a constructor and multiple functions, some of which are public. It can be equivalently viewed in the form of a control flow graph (CFG) S = (N , i, E) where N is a finite set of control locations in the program; i ∈ N is the initial control location, i.e., the start of the contract; and E ⊆ N × C × N is a set of labeled edges, each of which is of the form (n, c, n ′ ) where c is either a condition (for conditional branches like if-then-else or while-loops) or a command (i.e., an assignment). Note that for simplicity, we define the smart contract as one single graph rather than defining one graph for each function and then connecting them through a call graph. A node in the graph is branching if and only if it has multiple child nodes and its outgoing edges are labeled with conditions. We refer to an outgoing edge of a branching node as a branch.</p><p>Test cases. A test case for S is a pair (σ 0 , Σ) where σ 0 is a configuration of the blockchain network and Σ is a sequence of transactions (i.e., function calls). The configuration σ 0 contains all information on the setup of the network which is relevant to the execution of the smart contract. Formally, σ 0 is a tuple (b, ts, SA, SB, v) where b is the current block number, ts is the current block timestamp, SA is a set of the addresses of the smart contracts (including the smart contract under test as well as other invoked contracts), SB is a function which assigns an initial balance to each address and v is the initial valuation of the persistent state. Σ = ⟨m 0 ( -</p><formula xml:id="formula_0">→ p 0 ), m 1 ( - → p 1 ), • • • ⟩</formula><p>is a sequence of public function calls of the smart contract under test, each of which has an optional sequence of concrete input parameters -→ p i . Note that m 0 must be a call of the constructor.</p><p>The task of fuzzing a smart contract is thus to generate a set of test cases (a.k.a. test suite) according to certain testing criteria. The execution of a test case t traverses through a path in the CFG S, which visits a set of nodes and edges. For simplicity, we assume that one test execution covers one unique path (i.e., there is no nondeterminism). Furthermore, a trace generated by t is a sequence of pairs of the form ⟨(σ 0 , n 0 ), (σ 1 , n 1 ), • • • ⟩ where (n 0 , n 1 , • • • ) is the sequence of nodes visited by t and σ i is the configuration at the time of visiting node n i for all i.</p><p>Code Coverage. Ideally, we aim to generate a test suite which reveals all vulnerabilities in the contract. However, as we do not know where the vulnerabilities are, we must instead aim to achieve something more measurable. In this work, our answer is to focus on code coverage, in particular, branch coverage. We remark that our approach can be extended to support different coverage at the cost of additional code instrumentation. A branch in S is covered by a test suite if and only if there is a test case t in the suite that visits the edge at least once. The branch coverage of a test suite is calculated as the percentage of the covered branches over the total number of branches. Note that identifying the total number of (feasible) branches statically in a smart contract is often infeasible for two reasons. First, some branches might be infeasible (i.e., there does not exist any test case that visits the branch) and knowing whether a branch is feasible or not is a hard problem. Second, EVM has a stack-based implementation which makes identifying all potentially feasible branches hard (as we will explain in more detail in Section 4). Our problem is thus reduced to generate a test suite which maximizes the number of covered branches.</p><p>To achieve maximum code coverage, one way is to generate a large test suite (e.g., through random test generation). However, in practice, we often have limited resources (in terms of time or the number of computer processes) and thus our problem is refined as 'to generate a test suite which maximizes the number of covered branches as efficiently as possible'. Our solution to the problem is feedback-guided adaptive fuzzing.</p><p>Fuzzing is one of the most popular methods to create test cases <ref type="bibr" target="#b19">[20]</ref>. A feedback-guided fuzzing system (a.k.a. fuzzer) takes a program under test and an initial test suite as input, monitors the execution of the test cases to obtain certain feedback, generates new test cases based on the existing ones in certain ways and then repeats the process until a stopping criteria is satisfied. We present details of our feedback-guided adaptive fuzzing process in Section 3.2.</p><p>Oracles The remaining problem is then how to tell whether a test case reveals a vulnerability. In this work, we adopt a set of oracles from previous approaches <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b21">22]</ref> including Gasless Send, Exception Disorder, Timestamp Dependency, Block Number Dependency, Dangerous DelegateCall, Reentrancy, Integer Overflow/Underflow, and Freezing Ether. We refer the readers to Section 4 for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Feedback-Guided Adaptive Fuzzing</head><p>The general idea of feedback-guided fuzzing is to transform the test generation problem into an optimization problem and use some form of feedback as an objective function in solving the optimization problem. Our fuzzing strategy is adaptive as we change the objective function adaptively based on the feedback. At the top level, sFuzz employs a genetic algorithm <ref type="bibr" target="#b4">[5]</ref> which is inspired by the wellknown AFL fuzzer to evolve the test suite in order to iteratively improve its branch coverage.</p><p>The overall workflow is shown in Algorithm 1. Variable suite is the test suite to be generated. It is initially empty. Whenever a test case covers a new branch, it is added into suite. Variable seeds is a set of seed test cases, based on which new test cases are generated. First, we generate an initial test suite using function initPopulation(). The loop from line 3 to 6 then iteratively evolves the test suite. In particular, we add those test cases in seeds which cover new branches (i.e., any branch which is not covered by test cases in suite) into suite at line 4. At line 5, we filter the test cases in seeds through function f itToSurvive() so as to focus on those seeds which are more likely to lead to test cases covering new branches later. At line 6, function crossover Muatation() generates more test cases based on the test cases in seeds. The loop continues until a pre-set time out is triggered. While Algorithm 1 resembles the one in AFL, the differences are in the details of each function.</p><p>In the following, we present each function in detail.</p><p>Generating Initial Population Function initPopulation() generates an initial population containing multiple test cases. As mentioned above, to generate a test case, we need to generate an initial configuration σ 0 as well as a sequence of (public) function calls with concrete parameters. The initial configuration by default is as follows (in hexadecimal): b = 0, ts = 0, SA = {0xf0}, SB = {0xff00...} and v is set using the declared initial value for each variable representing the persistent state. sFuzz additionally allows a user to customize the initial configuration, i.e., the user is allowed to provide an initial set of test cases.</p><p>Next, we generate multiple sequences of transactions, each of which is a function call with concrete parameters. For a contract with n functions, we generate n sequences. In each sequence, a different function is called once after the constructor is called. This makes sure that each function is tested at least once (i.e., function coverage is 100%).</p><p>For each function call, we generate a random value for each parameter based on its type. Note that if the parameter type has a fixed-length, e.g., of type uint256, this is straightforward. If the type does not have a fixed length (e.g., an array or a string), we first randomly generate a number (with a range from 0 to bound where bound is a bound on maximum length with a default value of 255) representing the number of elements in the parameter (e.g., number of characters) and then generate a corresponding number of element values.</p><p>Each test case is encoded in form of a bit vector. In the terminology of genetic algorithms, such bit vectors can be naturally regarded as chromosomes. The size of the bit vector equals to the number of bits for encoding the configuration plus the number of bits encoding the function calls. Note that for each test case, we keep a list of function calls (which always includes the constructor in the contract) and then encode each parameter value. If the parameter value is of variable-length, we use ⌈log bound⌉ (where bound is a bound on the maximum length with a default value of 255) to encode the length of the parameter value. For example, given the contract shown in Figure <ref type="figure" target="#fig_0">1</ref>, (part of) the encoding of a test case is shown in Figure <ref type="figure" target="#fig_1">3</ref> where each part of encoding is labeled in the figure. It contains 192 bytes, of which the first 96 bytes are initial configuration and the last 96 bytes are a sequence of two function calls and the corresponding input parameters. As there are three string parameters, the first 3 bytes including 0x05, 0x05 and 0x05 encode the length of _response, _question and _answer respectively. The remaining 0x05 values are used when there are more than 3 dynamic variables.</p><p>Before executing the test case, the bit vector is decoded to a test case according to our internally defined protocol. Note that the bits in the bit vector may be correlated with each other in multiple ways. For instance, the bits presenting the length of a variablelength value must be equal to the 'length' of the value.</p><p>Fitness After executing the seeds at line 4 in Algorithm 1, function f itToSurvive() is called to evaluate the fitness of the seeds according to a fitness function. Note that the fitness function plays an extremely important role.</p><p>In sFuzz, we combine two complementary strategies. One is adopted from AFL, which works as follows. While seeds are executed, sFuzz monitors the execution and records the branches that each test case cover. A test case is deemed 'fit to survive' if it covers a new branch in the contract, e.g., a branch which is not covered by any test case in suite. This strategy has been shown to be effective in many settings <ref type="bibr" target="#b6">[7]</ref> and indeed our experimental results show that it is effective in covering most of the branches (see Section 5). Although the AFL strategy allows us to quickly cover most of the branches, it often makes very slow progress in covering the remaining ones afterwards, i.e., often those branches which are with strict conditions. The reason is that most likely the randomly generated test cases would fail to satisfy the strict condition. In such a case, the above fitness function offers little feedback and guideline on how to generate new test cases. For instance, the probability of satisfying the second condition at line 10 of Figure <ref type="figure" target="#fig_0">1</ref> is as low as 1 2 256 (if we assume that every value is equally likely to be generated). Intuitively, however, it is clear that a test input with msд.value = 200 is 'closer' to satisfy the condition than a test input with msд.value = 10000000. sFuzz thus integrates an adaptive strategy which selects seeds based on a quantitative measure on how far a test case is from covering any just-missed branch.</p><p>Let br n be a just-missed branch in S, i.e., an uncovered outgoing edge from a branching node n in S and n has been covered. The idea is to define a function distance(t, br n ) where t is a test case to return a quantitative measure on how far the branch br n is from being covered by t.</p><p>Assume that br n is labeled with a condition c. Note that c can be either true, f alse, a == b, a != b, a &gt;= b, a &gt; b, a &lt;= b, or a &lt; b at the byte-code level where a and b are variables or constants. In our setting, since br n is assumed to be a just-missed branch, c must not be true (otherwise br n must be covered already). Function distance(t, br n ) is then defined as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>distance(t, br</head><formula xml:id="formula_1">n ) =                K if c is f alse | a -b | + K if c is a == b K if c is a != b b -a + K if c is a &gt;= b or a &gt; b a -b + K if c is a &lt;= b or a &lt; b</formula><p>where K is a constant which represents the minimum distance. It is set to be 1 in sFuzz. Intuitively, distance(t, br n ) is defined such that the closer the branch is from being covered, the smaller the resultant value is. With the above, function f itToSurvive(seeds) then selects the seeds as shown in Algorithm 2. The loop from line 2 to 4 goes through every test case to select those which cover a new branch. Afterwards, for each just-missed branch br n in the smart contract, the loop from line 5 to line 11 selects a test case from seeds which is the closest to cover the branch according to distance(t, br n ). Note that one seed is selected for each just-missed branch, which makes this algorithm a lightweight multi-objective optimization approach. All selected seeds are then used for crossover and mutation to Algorithm 2: Algorithm f itToSurvive(seeds) generate more test cases in the next step. We refer the readers to Section 2 for an example.</p><p>Remark The above-described strategy is inspired by search-based software testing (SBST) <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b23">24]</ref> and yet it differs from SBST in several ways. The high-level reason for the difference is that having an AFL-based approach for fuzzing requires us to run test cases efficiently whereas existing SBST's seed selection strategy is timeconsuming. Furthermore, due to the stack-based implementation of EVM, implementing existing the SBST strategy is infeasible. In the following, we present the differences in detail.</p><p>First, existing state-of-the-art SBST techniques (i.e., the one in EvoSuite <ref type="bibr" target="#b15">[16]</ref>) measures how far a test case t is from covering any uncovered branch (not only those just-missed ones) in a more complicated way. That is, given CFG S = (N , i, E), let the distance from a node n 1 to node n 2 to be the minimum number of edges along any path from n 1 to n 2 . Let br n be any uncovered branch and m be a node covered by t which is the nearest node to n, i.e., m has a minimum distance to n compared to any other node covered by t. SBST uses the following function to measure how far t is from covering br n .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>dist(t, br</head><formula xml:id="formula_2">n ) = appr _dist(t, br n ) + norm(distance(t, br m ))</formula><p>where br m is an outgoing edge of m which is along the shortest path from m to n. Note that if m is n (i.e., in case br n is just-missed), br m is simply br n . Function appr _dist(t, br n ) is a measurement of how far branch br n is from being covered by test case t, i.e., the distance from m to n plus 1. For instance, given a control flow graph as in Figure <ref type="figure" target="#fig_2">4</ref>, if t covers only the edge A → B → E, appr _dist(t, C) = 1 since there is one branch from B to reach C and there are two branches from A to reach C via D. Similarly, appr _dist(t, F ) = 2. Lastly, function norm(x) is a normalization function which normalizes the results of distance(t, br m ) to a value between 0 and 1. One such function is norm(x) = 1 -1.001 -|x | <ref type="bibr" target="#b15">[16]</ref>.</p><p>Applying the above strategy in fuzzing Solidity smart contracts is inefficient, if not infeasible, for multiple reasons. First, calculating appr _dist(t, br n ) would require us to construct the complete CFG. However, constructing the CFG based on bytecode only is highly nontrivial. In EVM, branches are realized with the opcode jumpi, with a value representing the target program counter dynamically at runtime. The only way to know the target is to fully simulate the stack, which is expensive. Second, even if we have the CFG, computing appr _dist(t, br n ) is still expensive. Given a CFG with K uncovered nodes. To maintain a list of 'best' test cases for each uncovered node, we have to calculate appr _dist(t, br n ) for all K uncovered nodes, i.e., by building a table of the shortest paths from all nodes to these K nodes. Furthermore, whenever a new node is covered, appr _dist(t, br n ) must be updated. The overhead is unreasonable given that efficiency is key for AFL-based fuzzing. By focusing on just-missed branches, sFuzz avoids both problems. That is, appr _dist(t, br n ) is always 1 for any just-missed branch br n since node n must have been covered. Furthermore, because it is constant for any uncovered branch, we can simply skip it in dist(t, br n ) and so that dist(t, br n ) is reduced to distance(t, br n ), without even the need to normalize. This further reduces the overhead.</p><p>Another key difference between sFuzz's strategy and existing SBST's is the multi-objective searching strategy. The multi-objective search strategies in existing SBST consider each uncovered branch as an objective and select Pareto-optimal seeds to evolve in next generation. Given a set of uncovered branch {b 1 , b 2 , ..., b m }, a set of seeds {t 1 , t 2 , ..., t n }, we say t i is more Pareto-optimal than t j if ∀k ∈ 0..m, distance(t i , b k ) &lt; distance(t j , b k ). Otherwise, we say that t i and t j are Pareto-equivalent. All Pareto-equivalent seeds form a Pareto frontier and the seeds can fall into several Pareto frontiers. Existing SBST selects the most Pareto-optimal seeds to evolve. A known problem for such a strategy <ref type="bibr" target="#b26">[27]</ref> is that the number of seeds in the same Pareto frontier soars with the increase of the number of objectives (i.e., uncovered branches). For example, there could be hundreds of seeds in the most Pareto-optimal frontier with only 3-5 objectives, which makes it hard to select the most promising seeds and increases the runtime overhead. In contrast, sFuzz keeps one best seed for each just-missed branch (line 6-11 in Algorithm 2) and as a result, the number of seeds remains small (i.e., equivalent to the number of just-missed branches). Our experimental results show that such a strategy balances effectiveness in identifying good seeds and efficiency well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Crossover and Mutation</head><p>Function crossover Mutation() generates new test cases based on those in seeds through crossover and mutation. sFuzz adopts all of the crossover strategies from AFL and introduces news ones specific for smart contracts. Furthermore, due to correlation between parameters of a test case, sFuzz additionally makes sure the generated test cases are valid. For instance, sFuzz (1) randomly chooses  (2) breaks the two test cases into two pieces at a selected position; and (3) swaps the second pieces to form two new test cases. Note that due to correlations between the bits representing a test case, there is no guarantee that the resultant test cases are valid and thus sFuzz always checks for validity and discard those invalid ones.</p><p>Mutation is another way of generating new test cases. Given a seed encoded in the form of a bit vector, sFuzz supports a set of mutation operators to generate new test cases. All mutation operators are shown in Table <ref type="table" target="#tab_3">1</ref>.</p><p>Recall that a test case is in the form of an initial configuration and a sequence of function calls with concrete parameters. The first three mutation operators aim to alter the sequence of function calls, by pruning a function call, adding a function call or swapping two function calls. When a function call is pruned (or added or swapped), the corresponding concrete parameters are pruned (or added or swapped) accordingly.</p><p>For those values in a test case other than those representing the called functions, sFuzz categorizes them into two groups. The first group contains those values which have fixed-length (e.g., a parameter of type uint256). sFuzz systematically applies the remaining mutation operators shown in Table <ref type="table" target="#tab_3">1</ref> to generate new values, which are inspired by the mutation operators in AFL. Note that account addresses (and balances) are handled slightly differently (refer to the last row in the table) as there are special format requirements. Each address has 32 bytes, in which the last 20 bytes contain the address value and the first 12 bytes contain the balance of the address. For instance, the value 0xff00...00...00f0 represent an address 0xf0 with balance 0xff0000000000000000000000.</p><p>The second group contains those values which have variablelength (e.g., a parameter of type array). For such values, their lengths are encoded as part of the test case as well. We thus first mutate the value representing the length in such a way that the result is a random value between 0 and 255 where 255 is an upper bound. If the new length is less than the current one, the corresponding value is shortened accordingly by pruning the additional bits. If the length is more than the current one, random type-compatible values are padded accordingly.</p><p>Note that we discard identical test cases generated through either crossover or mutation. Furthermore, although we do not set a limit on the number of mutations generated from a test case, we apply multiple heuristics adopted from AFL to reduce the number of mutations. For instance, if applying the WalkingByte mutation to a block of 32 bytes does not result in any test case which covers a new branch, in the next stages sFuzz will not mutate that block. We refer the readers to AFL for details on these heuristics <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">IMPLEMENTATION</head><p>sFuzz is implemented in C++ with an estimated 4347 lines of code. It is publically available (https://sfuzz.github.io). It has 3 main components: runner, libfuzzer and liboracles.</p><p>Component runner manages the execution of the test cases. sFuzz takes as input the bytecode of a smart contract along with the ABI (i.e., application binary interface, which can be generated automatically using existing tools) of the contract. The runner then generates a bash script file which contains a list of commands to analyze the ABI, and set options for the other two components.</p><p>The runner sets up a test network based on which smart contracts are deployed and transactions are executed. To generate test cases for functions with address-type parameters, sFuzz deploys a pool of externally owned accounts in the test network with random balances. The pool size is less than or equal to the number of address-type parameters because it is possible to set the same address to multiple address-type parameters. The values for address-type parameters are then chosen randomly from this pool. In addition, sFuzz deploys two special smart contracts as attackers, i.e., a normal attacker and a reentrancy attacker. Each attacker is set as the owner of the contract under test in turn. The normal attacker throws an exception whenever other contracts call its payable fallback function. The reentrancy attacker calls back the function which makes a call to its payable fallback function. If the attacker fails to call back, it acts as a normal attacker. Note that the reentrancy attacker is only loaded to detect Reentrancy vulnerability. Otherwise, the normal attacker is loaded to avoid call loops of Reentrancy Attacker which significantly reduces the speed of sFuzz.</p><p>Component libfuzzer solves the test generation problem, i.e., how to selectively generate test cases, by implementing the fuzzing strategy presented in the previous sections. It is responsible for multiple tasks.</p><p>First, it constructs the CFG of the given smart contract on-the-fly. Ideally, we would like to construct the CFG statically before fuzzing. However, constructing the CFG based on bytecode only is highly nontrivial. In EVM, branches are realized with the opcode jumpi, with a value representing the target program counter dynamically at runtime. The only way to know the target is to fully simulate the stack, which is expensive. Therefore, sFuzz constructs the CFG on-the-fly while fuzzing. That is, whenever the opcode jumpi is executed, the two destinations are recorded. If these two destinations are not part of the CFG yet, two new nodes are created accordingly representing the two destinations in the CFG.</p><p>Second, component libfuzzer implements the fuzzing algorithm discussed in Section 3. One optimization is that we identify view functions (i.e., those which do not change any variables) and exclude them from test case generation. The justification is that these view functions do not change the states and having them does not additionaly expose those vulnerabilities sFuzz targets at (see below). Note that view functions are marked by view, pure or constant keywords, sFuzz reads ABI file to recognize them.</p><p>Component liboracles solves the oracle problem, i.e., it monitors the execution of a test case and checks whether there is a vulnerability according to an extensible library of oracles used in sFuzz. sFuzz monitors the execution of test cases through the hooking mechanism supported by EVM. Whenever EVM executes an opcode, it creates an event containing read-only execution information, such as the values of the stack, memory, program counter, and the current executed opcode. sFuzz monitors these events for constructing the CFG and computing distance(t, br n ), as well as logs the events for vulnerability detection. To reduce the execution overhead, vulnerability detection is conducted offline in batches (i.e., once for every 500 test cases). This design allows sFuzz to easily support different versions of Solidity, i.e., by simply replacing the EVM packed in sFuzz.</p><p>sFuzz has an extensible architecture which allows it to easily support different oracles as well. Currently, sFuzz supports 8 oracles inspired by the previous work <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b21">22]</ref>. Since these oracles are not our main contribution, we refer the readers to <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b21">22]</ref> for details.</p><p>These oracles are checked based on the logs of test cases. For instance, to check if a test case expose the Gasless Send vulnerability, we check that whether test case executes a CALL instruction with some data greater than 0 when the gas is equal to 2300. The test cases that expose vulnerabilities in the contract are kept in a separate test suite and reported to the user together with the vulnerabilities that they expose. Note that by design, sFuzz always reports true positives according to our definition of vulnerability except in the case of Freezing Ether. However, in practice, a reported vulnerability might be a false positive as it may be what the user intended (i.e., our definition of vulnerability is too strict). In the case of Freezing Ether, the identified 'warning' might be a false positive if there exist some test cases which call send() or trans f er () but such test cases are never generated. Technically, the problem of checking whether there is Freezing Ether vulnerability can only be solved if we cover all feasible opcode (which is often infeasible).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTS AND EVALUATION</head><p>In this section, we evaluate sFuzz through multiple experiments. The experiments are designed to answer the following research questions (RQ).</p><p>• RQ1: How efficient is sFuzz? • RQ2: Is sFuzz effective in finding smart contract vulnerabilities and obtaining high code coverage? • RQ3: Is the adaptive strategy useful?</p><p>Our test subjects include 4112 smart contracts which we collect from EtherScan <ref type="bibr">[4]</ref>. These contracts are implemented using Solidity 4.2.24, which is the most popular version of Solidity. Moreover, the source code for these contracts are available, which makes the evaluation more accurate. We note that sFuzz can run with bytecode only. For a baseline comparison, we compare sFuzz with a fuzzer named ContractFuzzer reported in <ref type="bibr" target="#b14">[15]</ref> and a symbolic execution tool named Oyente reported in <ref type="bibr" target="#b21">[22]</ref>. Other fuzzers for smart contracts have been mentioned in <ref type="bibr" target="#b20">[21]</ref>. However, we fail to find the reported tools online or through the authors. We run the experiments 3 times and report the average as the result. All experimental results reported below are obtained on an Ubuntu 18.04.1 LTS machine with Intel Core i7 and 16GB of memory. We use the default initial configuration as presented in Section 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Efficiency</head><p>To answer RQ1, we systematically apply sFuzz, ContractFuzzer and Oyente on all 4112 smart contracts. To save time, each contract is run for 2 minute in this experiment. Note that in general the adaptive fuzzing strategy takes time to show its effectiveness (as we will show later) and thus this setting gives an edge to other tools.</p><p>We measure the efficiency of sFuzz by counting how many test cases are generated and executed per second. Naturally, a test case for a more complicated contract (e.g., with many loop iterations) takes more time to execute. Thus, we show how efficiency varies for different contracts. Figure <ref type="figure" target="#fig_3">5</ref> summarizes the result, where each bar represents 10% (about 400) of the fuzzed contracts and the y-axis shows the number of test cases generated and executed per second. The contracts are sorted according to how efficiently it can be fuzzed. From the figure, we observe that the efficiency varies significantly over different contracts, i.e., sFuzz generates and executes more than 989 test cases per second on average for the top 10% of the contracts, and less than 14 test cases for the bottom 20%. On average, sFuzz generates and executes more than 208 test cases per second.</p><p>Figure <ref type="figure" target="#fig_3">5</ref> also compares the efficiency of sFuzz with Oyente and ContractFuzzer. From the results, we observe that sFuzz is significantly more efficient than other tools. On average, ContractFuzzer and Oyente generate and execute 0.1 and 16 test cases per second respectively. There are multiple reasons why sFuzz is much faster. First, ContractFuzzer simulates the whole network and manages the blockchain (e.g., commit state changes to storage and append new mined blocks to blockchain after function calls), whereas sFuzz simulates only details of network or blockchain which are relevant to vulnerabilities in smart contracts. Second, sFuzz has a highly optimized implementation in C++, whereas ContractFuzzer is based on Node.js and Go language. In the case of Oyente, because it is a symbolic execution tool, Oyente is expected to run slower than a fuzzer like sFuzz.</p><p>We further conduct an experiment to measure the overhead of monitoring the execution of a test case (using the hooking mechanism) and the overall overhead of the fuzzing process (including the overall of monitoring the execution, constructing the CFG, mutating the test cases and comparing them, etc.). We apply sFuzz to a set of 60 randomly selected contracts and measure the time spent on executing the test cases, monitoring the execution and other steps of the fuzzing process. The results show that on average the monitoring consumes about 10% of the total execution time and the overhead of the fuzzing process (including monitoring) is about  14%. This is very efficient compared to the reported overhead in other fuzzers <ref type="bibr" target="#b31">[32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Effectiveness</head><p>To answer RQ2, we aim to measure the branch coverage achieved by the test suite generated for each smart contract, as well as count the number of vulnerabilities identified. However, measuring branch coverage precisely is highly non-trivial due to, for instance, the problem of infeasible branches. Thus, we instead measure the number of distinct branches covered by the generated test suite. Figure <ref type="figure">6</ref> summarizes a comparison between sFuzz and ContractFuzzer in terms of the number of distinct branches covered. The y-axis is the number of branches covered by sFuzz minus that of ContractFuzzer and each point on the x-axis represents a smart contract. The contracts are sorted by their y-axis value. Similarly, Figure <ref type="figure" target="#fig_4">7</ref> shows the comparison between sFuzz and Oyente.</p><p>For most of the smart contracts (i.e., 4077 of 4112 contracts) sFuzz covers more branches than ContractFuzzer. To our surprise, ContractFuzzer managed to cover more branches for 35 contracts. In the case of Oyente, in 3402 contracts, Oyente covers more branches than sFuzz. An investigation shows that Oyente analyzes every function separately and thus has to assume that state variables can take arbitrary values (without considering their initial values or constraints on how the values are updated). As a result, Oyente can easily satisfy almost all conditions in smart contracts. Given the sample contract A in Figure <ref type="figure">8</ref>, Oyente covers 99.1% EVM code and discovers an integer overflow vulnerability. It means that these conditions: id == 9 and balances[msд.sender ] &gt; 10 are satisfied. However, it is impossible as there is no way to change values of id and balances[msд.sender ]. Often, a condition in smart contract is the comparison between local/parameter variables and state variables, e.g., balances[msд.sender ] &gt; value (whether sender has enough Ethereum to deduce). In such cases, sFuzz must call the function which sets certain values to the state variables before satisfying them whereas Oyente assigns arbitrary values directly to state variables. It is apparent to us that Oyente's approach is flawed and would 'cover' many infeasible paths.</p><p>In the following, we summarize the number of vulnerable contracts discovered by sFuzz in each category. The results are shown in Table <ref type="table" target="#tab_5">2</ref>. The first column shows the type of vulnerability. The next three columns show the number of vulnerable contracts found by sFuzz, ContractFuzzer and Oyente respectively. The sub-column # show the number of contracts that have the vulnerability according to each vulnerability type and the second sub-column is the percentage of true positives of the identified vulnerabilities. For all categories, sFuzz finds more vulnerable contracts than Contract-Fuzzer. Note that ContractFuzzer removes Freezing Ether from their source code and does not check Integer Overflow/Underflow. In total, sFuzz finds vulnerabilities in 1113 contracts, i.e., 24 times more than that of ContractFuzzer. To evaluate the soundness of sFuzz, we manually examine the identified vulnerable contracts to check whether they are true positives or not. However, we are unable to manually check all the identified vulnerability for two reasons. First, there is an overwhelming number of vulnerabilities. Instead, we randomly sample 50 vulnerable contracts with source code in each category and manually check whether the identified vulnerability is a true positive or not. If there are fewer than 50 vulnerable contracts with source code in the category, we check all of them.</p><p>For Gasless Send, Exception Disorder and Reentrancy vulnerability, all 50 sampled vulnerable contracts are true positives. For Timestamp Dependency, out of the 50 sampled vulnerable contracts, 43 of them are true positives. In the remaining 7 contracts, although block.timestamp and/or now is used in a condition, they are irrelevant to the Ether sending part (i.e., no control/data dependency). Rather their values are saved in global variables to record the creation time of specific events. sFuzz mistakenly claims that such cases are vulnerable. For Block Number Dependency, 40 out of the 50 sampled vulnerable contracts are true positives. Similarly, the reason for the 10 false positives is the value of block.number is assigned to global variables but they are irrelevant to Ether sending process. For Dangerous DelegateCall, all 17 sampled contracts are indeed vulnerable. Similarly so for Integer Overflow. For Integer Underflow, 40 of the 50 identified contracts are indeed vulnerable. The reason for the 10 false positives is because it is non-trivial to identify the correct type of a variable based on bytecode only (e.g., whether it is uint256 or uint128), sFuzz conservatively assumes that all arithmetic operations returning a negative value may be vulnerable. This can be improved by adopting the approach in <ref type="bibr" target="#b28">[29]</ref> to infer types based on EVM bytecode. Lastly, for Freezing Ether, 9 of the 15 identified contracts are true positives. The reason for the 6 false positives is that although there is a program path which allows the contract to send Ether, the program path is not covered and sFuzz falsely assumes that there is no such program path. This percentage of such false positives is expected to be reduced if sFuzz is applied for a longer time (with more branches covered).</p><p>The last column in Table <ref type="table" target="#tab_5">2</ref> shows the results of Oyente. The results should be taken with a grain of salt since Oyente requires the source code. For instance, it is trivial to know the type of variables with the source code, and thus Oyente identifies many more problems with Integer Overflow/Underflow. For the remaining vulnerabilities, Oyente does not support 5 of them; identifies a higher number of vulnerable contracts for Reentrancy but with a higher false positive rate; and identifies much fewer vulnerable contracts for Timestamp Dependency. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Adaptiveness</head><p>To answer RQ3, we systematically analyze the test suite generated by sFuzz for each smart contract. Note that each test case covers at least one branch which is not covered by any other test cases. To measure how the two fuzzing strategies implemented in sFuzz complement each other, we count how many test cases in the resultant test suites are generated due to the AFL strategy and how many are due to the adaptive strategy. Note that a test case is judged to be due to the adaptive strategy if and only if it is generated based on a seed selected by line 11 at Algorithm 2.</p><p>The results are shown in Figure <ref type="figure" target="#fig_5">9</ref>, where the y-axis is the percentage of test cases generated by the strategy. Each bar represents 10% of the contracts. We remark that the two strategies have different targets and thus whether they are effective largely depends on what branching conditions are in the smart contracts. We thus sort the contracts according to the speed of sFuzz. The bar on the rightmost thus represents the top 10% contracts. We observe that, as expected, the AFL strategy easily covers most of the branches (since the conditions for executing most branches are not strict). For about 80% of the smart contracts, the adaptive strategy makes a noticeable contribution, i.e., contributing an average of 31% of the generated test cases. Given that sFuzz is applied for each contract only for 2 minutes, the result is encouraging as we hypothesize that the effect of the adaptive strategy would be more apparent if sFuzz is applied for a longer period of time.</p><p>To test our hypothesis, we record the percentage of test cases generated by the adaptive strategy every 12 seconds. The results are shown in Figure <ref type="figure" target="#fig_0">10</ref>, where the x-axis is the fuzzing time and each bar shows the percentage after certain number of seconds. We can observe that the percentage of generated test cases by adaptive strategy increases with more time. On average, the percentage rises from 18% 12 seconds fuzzing to 33% after 2 minutes fuzzing. From the results, we conclude the adaptive strategy is useful in increasing the coverage of the generated test suites.</p><p>Threat to validity There are both internal threats and external threats to our work. For external threats, it is probable that sFuzz's performance will vary with the choice of the initial population, as other researchers have noted <ref type="bibr" target="#b19">[20]</ref>. For internal threats, the percentage of true positives in Table <ref type="table" target="#tab_5">2</ref> may not be accurate as they are approximated by a sample of 50 contracts for each type of vulnerability. In addition, the exact intention of the author of the contract is not always clear, even if we try our best to read the source code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK AND CONCLUSION</head><p>sFuzz is closely related to existing fuzzers for smart contracts. Con-tractFuzzer <ref type="bibr" target="#b17">[18]</ref> is a fuzzer which can check 7 different types of vulnerabilities. Its approach, however, does not use any feedback to improve the test suite. <ref type="bibr">Echidna [3]</ref> is another fuzzer that is reportedly capable of checking if the contract violates some user-defined properties. However, we fail to find any publication about it.</p><p>sFuzz is complementary to existing symbolic execution engines for smart contracts. In <ref type="bibr" target="#b21">[22]</ref>, Luu et al. presented an engine to find potential security bugs in smart contracts. The tool, however, is neither sound nor complete. In <ref type="bibr" target="#b20">[21]</ref>, Krupp and Rossow presented teEther, which is focused on financial transactions and related vulnerabilities. In <ref type="bibr" target="#b24">[25]</ref>, Nikolic et al. presented a tool named MAIAN, which can find 3 types of trace vulnerabilities. In <ref type="bibr" target="#b28">[29]</ref>, Torres et al. presented Osiris, a tool which combines symbolic execution and taint analysis to discover 3 types of integer bugs in smart contracts. Different from the above works, sFuzz is a fuzzer and it can be combined with the above engines to form a hybrid fuzzing engine.</p><p>sFuzz is related to work on formal verification of smart contracts. Zeus <ref type="bibr" target="#b18">[19]</ref> is a framework which verifies the correctness and fairness of smart contracts based on LLVM. Bhargavan et al. proposed a framework to verify smart contracts formally by transforming the source code and the bytecode to F*, a language designed for verification <ref type="bibr" target="#b8">[9]</ref>. In <ref type="bibr" target="#b16">[17]</ref>, the author presented an attempt to verify the Deed contract using Isabelle/HOL <ref type="bibr" target="#b25">[26]</ref>.</p><p>sFuzz is broadly related to work on analyzing smart contracts. In <ref type="bibr" target="#b12">[13]</ref>, Delmolino et al. showed that writing a safe smart contract is not a trivial task. In <ref type="bibr" target="#b7">[8]</ref>, Atzei et al. provided a taxonomy for common vulnerabilities in smart contracts with real-world attacks. In <ref type="bibr" target="#b13">[14]</ref>, the authors performed a call graph analysis and showed that only 40% of smart contracts are truthless as their control flows are immutable. In <ref type="bibr" target="#b9">[10]</ref>, Chen et al. presented 7 gas-cost programming patterns and showed that most of the contracts suffer from these gas-cost patterns.</p><p>To conclude, in this work, we present sFuzz, an adaptive fuzzing engine for EVM smart contracts. Experimental results show that sFuzz is significantly more reliable, faster, and more effective than existing fuzzers. sFuzz is currently under rapid development and has already gained interest from multiple companies and research organizations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Algorithm 1 :</head><label>1</label><figDesc>The test generation algorithm 1 let suit e be an empty test suite; 2 let seeds := init Popul at ion(); 3 while not time out do 4 add tests in seeds which covers new branches into suit e; 5 let seeds := f itT oSurvive(seeds); 6 let seeds = cr ossover Mut at ion(seeds); 7 return suit es;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: A generated test case</figDesc><graphic coords="5,79.02,83.69,453.96,103.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A control flow graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Efficiency comparison between sFuzz, Oyente, and ContractFuzzer</figDesc><graphic coords="8,317.96,220.32,240.25,96.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Coverage comparison between sFuzz and Oyente</figDesc><graphic coords="8,317.96,362.97,240.25,96.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Percentage of test cases due to adaptive strategy</figDesc><graphic coords="10,53.80,83.69,240.24,90.09" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>1 let new Seeds be an empty set of test cases; 2 foreach seed in seeds do</figDesc><table /><note><p>3 if seed covers a new branch then 4 add seed into new Seeds; 5 foreach uncovered branches br n do 6 let min be +∞; let t be a dummy test case; 7 foreach seed in seeds do 8 if dist ance(t, br n ) &lt; min then 9 let min be dist (t, br n ); 10 let t be seed; 11 add t into new Seeds; 12 return new Seeds;</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Mutations for fix-length values</figDesc><table><row><cell>Name</cell></row><row><cell>pruneMethodCall (new)</cell></row><row><cell>addMethodCall (new)</cell></row><row><cell>swapMethodCall (new)</cell></row><row><cell>singleWalkingBit, twoWalkingBit, fourWalkingBit</cell></row><row><cell>1/2/4 consecutive bits</cell></row><row><cell>singleWalkingByte, twoWalkingByte, fourWalkingByte</cell></row><row><cell>singleArith, twoArith, fourArith</cell></row><row><cell>singleInterest, twoInterest, fourInterest</cell></row><row><cell>overwriteWithDictionary</cell></row><row><cell>overwriteWithAddressDictionary</cell></row><row><cell>two test cases from seeds;</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Figure 8: Oyente visits infeasible branchesA closer investigation shows that the number of branches covered by ContractFuzzer is inflated for the following reasons. First, as sFuzz does not execute view functions (for efficiency reasons), all branches in these functions are not counted. Because view functions do not modify the state of a smart contract, they are considered irrelevant to vulnerabilities. Second, ContractFuzzer sometimes generates invalid test cases which fail mandatory constraints and cover additional branches. Mandatory constraints are generated by the compiler (i.e., the Solidity compiler) and are embedded in the bytecode to assert the correctness logic of function calls or data types. For example, ContractFuzzer invokes a fallback function of a non-fallback contract or sends Ethereum to functions which are not marked with the payable keyword. As a result, the mandatory constraints are failed which lead to branches which signal an error in the test case being covered.</figDesc><table><row><cell cols="2">1 contract A {</cell></row><row><cell>2</cell><cell>mapping ( address =&gt; uint ) balances ;</cell></row><row><cell>3</cell><cell>uint id = 10;</cell></row><row><cell>4</cell><cell>function main ( uint x , uint y) {</cell></row><row><cell>5</cell><cell>if ( id == 9) {</cell></row><row><cell>6</cell><cell>if ( balances [ msg . sender ] &gt; 10) {</cell></row><row><cell>7</cell><cell>uint sum = x + y; } } } }</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>Vulnerabilities</figDesc><table><row><cell>Vulnerability Type</cell><cell cols="4">sFuzz # true posi. # true posi. ContractFuzzer</cell><cell cols="2">Oyente # true posi.</cell></row><row><cell>Gasless Send</cell><cell>764</cell><cell>100%</cell><cell>14</cell><cell>100%</cell><cell>0</cell><cell>N.A.</cell></row><row><cell>Exception Disorder</cell><cell>36</cell><cell>100%</cell><cell>6</cell><cell>100%</cell><cell>0</cell><cell>N.A.</cell></row><row><cell>Reentrancy</cell><cell>29</cell><cell>100%</cell><cell>3</cell><cell>100%</cell><cell>52</cell><cell>60%</cell></row><row><cell>Timestamp Dependency</cell><cell>243</cell><cell>86%</cell><cell>28</cell><cell>86%</cell><cell>102</cell><cell>100%</cell></row><row><cell cols="2">Block Number Dependency 59</cell><cell>80%</cell><cell>16</cell><cell>95%</cell><cell>0</cell><cell>N.A.</cell></row><row><cell>Dangerous DelegateCall</cell><cell>17</cell><cell>100%</cell><cell>0</cell><cell>100%</cell><cell>0</cell><cell>N.A.</cell></row><row><cell>Integer Overflow</cell><cell>98</cell><cell>100%</cell><cell>0</cell><cell>N.A.</cell><cell>3350</cell><cell>60%</cell></row><row><cell>Integer Underflow</cell><cell>224</cell><cell>80%</cell><cell>0</cell><cell>N.A.</cell><cell>2246</cell><cell>60%</cell></row><row><cell>Freezing Ether</cell><cell>15</cell><cell>60%</cell><cell>0</cell><cell>N.A.</cell><cell>0</cell><cell>N.A.</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This research was supported by the Singapore Ministry of Education (MOE) Acemedic Research Fund (AcRF) Tier 1 grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">A Next-Generation Smart Contract and Decentralized Application Platform.</orgName>
		</author>
		<ptr target="https://github.com/ethereum/wiki/wiki/White-Paper" />
		<imprint>
			<date type="published" when="2020-02">Feb 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="https://github.com/ethereum/aleth/" />
		<title level="m">Aleth -Ethereum C++ client, tools and libraries</title>
		<imprint>
			<date type="published" when="2020-02">Feb 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><surname>Echidna</surname></persName>
		</author>
		<ptr target="https://github.com/crytic/echidna/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>Etherscan</surname></persName>
		</author>
		<ptr target="https://etherscan.io/" />
		<imprint>
			<date type="published" when="2020-02">Feb 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="https://en.wikipedia.org/wiki/Genetic_algorithm" />
		<title level="m">Genetic algorithm</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><surname>Solidity</surname></persName>
		</author>
		<ptr target="https://solidity.readthedocs.io/" />
		<imprint>
			<date type="published" when="2020-02">Feb 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<ptr target="http://lcamtuf.coredump.cx/afl/technical_details.txt" />
		<title level="m">Technical &quot;whitepaper&quot; for afl-fuzz</title>
		<imprint>
			<date type="published" when="2020-02">Feb 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A survey of attacks on Ethereum smart contracts</title>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Atzei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimo</forename><surname>Bartoletti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tiziana</forename><surname>Cimoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="volume">2016</biblScope>
			<biblScope unit="page">1007</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Formal verification of smart contracts: Short paper</title>
		<author>
			<persName><forename type="first">Karthikeyan</forename><surname>Bhargavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antoine</forename><surname>Delignat-Lavaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cédric</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anitha</forename><surname>Gollamudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georges</forename><surname>Gonthier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nadim</forename><surname>Kobeissi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Natalia</forename><surname>Kulatova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aseem</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Sibut-Pinote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikhil</forename><surname>Swamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for Security</title>
		<meeting>the 2016 ACM Workshop on Programming Languages and Analysis for Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="91" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Under-optimized smart contracts devour your money</title>
		<author>
			<persName><forename type="first">Ting</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaoqi</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiapu</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaosong</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="442" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><surname>Christopher D Clack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vikram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lee</forename><surname>Bakshi</surname></persName>
		</author>
		<author>
			<persName><surname>Braine</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1608.00771</idno>
		<title level="m">Smart contract templates: foundations, design landscape and research directions</title>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Analysis of the DAO exploit</title>
		<author>
			<persName><forename type="first">Phil</forename><surname>Daian</surname></persName>
		</author>
		<ptr target="https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/" />
		<imprint>
			<date type="published" when="2020-02">Feb 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Step by step towards creating a safe smart contract: Lessons and insights from a cryptocurrency lab</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Delmolino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mitchell</forename><surname>Arnett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmed</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Financial Cryptography and Data Security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="79" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">Michael</forename><surname>Fröwis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rainer</forename><surname>Böhme</surname></persName>
		</author>
		<title level="m">Code We Trust? In Data Privacy Management, Cryptocurrencies and Blockchain Technology</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="357" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">DART: directed automated random testing</title>
		<author>
			<persName><forename type="first">Patrice</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nils</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<idno type="DOI">10.1145/1065010.1065036</idno>
		<ptr target="https://doi.org/10.1145/1065010.1065036" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-06-12">2005. June 12-15, 2005</date>
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A theoretical and empirical study of search-based testing: Local, global, and hybrid search</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phil</forename><surname>Mcminn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="226" to="247" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Formal verification of Deed contract in Ethereum name service</title>
		<author>
			<persName><forename type="first">Yoichi</forename><surname>Hirai</surname></persName>
		</author>
		<ptr target="https://yoichihirai.com/deed.pdf" />
		<imprint>
			<date type="published" when="2016-11">2016. November-2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection</title>
		<author>
			<persName><forename type="first">Bo</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ye</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Chan</surname></persName>
		</author>
		<idno type="DOI">10.1145/3238147.3238177</idno>
		<ptr target="https://doi.org/10.1145/3238147.3238177" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering (ASE 2018)</title>
		<meeting>the 33rd ACM/IEEE International Conference on Automated Software Engineering (ASE 2018)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="259" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Zeus: Analyzing safety of smart contracts</title>
		<author>
			<persName><forename type="first">Sukrit</forename><surname>Kalra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seep</forename><surname>Goel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohan</forename><surname>Dhawan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Subodh</forename><surname>Sharma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th Annual Network and Distributed System Security Symposium (NDSS&apos;18)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Evaluating fuzz testing</title>
		<author>
			<persName><forename type="first">George</forename><surname>Klees</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Ruef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benji</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shiyi</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2018 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="2123" to="2138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">teEther: Gnawing at Ethereum to Automatically Exploit Smart Contracts</title>
		<author>
			<persName><forename type="first">Johannes</forename><surname>Krupp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Rossow</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/usenixsecurity18/presentation/krupp" />
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium, USENIX Security</title>
		<meeting><address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08-15">2018. 2018. August 15-17, 2018</date>
			<biblScope unit="page" from="1317" to="1333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Making smart contracts smarter</title>
		<author>
			<persName><forename type="first">Loi</forename><surname>Luu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Duc-Hiep</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hrishi</forename><surname>Olickel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aquinas</forename><surname>Hobor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="254" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Setting standards for altering and undoing smart contracts</title>
		<author>
			<persName><forename type="first">Bill</forename><surname>Marino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Rules and Rule Markup Languages for the Semantic Web</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="151" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">Phil</forename><surname>Mcminn</surname></persName>
		</author>
		<title level="m">Search-based software test data generation: a survey. Software testing, Verification and reliability</title>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="105" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Finding the greedy, prodigal, and suicidal contracts at scale</title>
		<author>
			<persName><forename type="first">Ivica</forename><surname>Nikolić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aashish</forename><surname>Kolluri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Sergey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aquinas</forename><surname>Hobor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual Computer Security Applications Conference</title>
		<meeting>the 34th Annual Computer Security Applications Conference</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="653" to="663" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Wenzel</surname></persName>
		</author>
		<title level="m">Isabelle/HOL: a proof assistant for higher-order logic</title>
		<imprint>
			<publisher>Springer Science &amp; Business Media</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2283</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Automated Test Case Generation as a Many-Objective Optimisation Problem with Dynamic Selection of the Targets</title>
		<author>
			<persName><forename type="first">A</forename><surname>Panichella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Kifetew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tonella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="122" to="158" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Formalizing and securing relationships on public networks</title>
		<author>
			<persName><forename type="first">Nick</forename><surname>Szabo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">First Monday</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">9</biblScope>
			<date type="published" when="1997">1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Osiris: Hunting for Integer Bugs in Ethereum Smart Contracts</title>
		<author>
			<persName><forename type="first">Christof</forename><forename type="middle">Ferreira</forename><surname>Torres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julian</forename><surname>Schütte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual Computer Security Applications Conference</title>
		<meeting>the 34th Annual Computer Security Applications Conference</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="664" to="676" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Towards optimal concolic testing</title>
		<author>
			<persName><forename type="first">Xinyu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhenbang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peixin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jingyi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yun</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th International Conference on Software Engineering</title>
		<meeting>the 40th International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="291" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Ethereum: A Secure Decentralised Generalised Transaction Ledger</title>
		<author>
			<persName><forename type="first">Gavin</forename><surname>Wood</surname></persName>
		</author>
		<ptr target="https://ethereum.github.io/yellowpaper/paper.pdf" />
		<imprint>
			<date type="published" when="2020-02">Feb 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">QSYM: A practical concolic execution engine tailored for hybrid fuzzing</title>
		<author>
			<persName><forename type="first">Insu</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meng</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yeongjin</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium</title>
		<title level="s">USENIX Security</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="745" to="761" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Blockchain challenges and opportunities: A survey</title>
		<author>
			<persName><forename type="first">Zibin</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shaoan</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hong-Ning</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huaimin</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Work Pap</title>
		<imprint>
			<biblScope unit="page">2016</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
