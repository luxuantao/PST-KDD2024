<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scratch &amp; Vote Self-Contained Paper-Based Cryptographic Voting</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ben</forename><surname>Adida</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">CSAIL</orgName>
								<address>
									<addrLine>MIT 32 Vassar Street</addrLine>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Ronald</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
							<email>rivest@mit.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">CSAIL</orgName>
								<address>
									<addrLine>MIT 32 Vassar Street</addrLine>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scratch &amp; Vote Self-Contained Paper-Based Cryptographic Voting</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E4D7D8319D2BDB1C75F53732705A1CE4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.4.m [Information Systems Applications]: Miscellaneous</term>
					<term>J.1 [Administrative Data Processing]: Government</term>
					<term>K.4.1 [Computers and Society]: Public Policy Issues Security, Human Factors, Verification Cryptographic Voting, Scratch Surface, Barcode, Paper Ballot, Homomorphic Tallying, Paillier Cryptosystem</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present Scratch &amp; Vote (S&amp;V), a cryptographic voting system designed to minimize cost and complexity: (1) ballots are paper-based and can be printed using today's technology, (2) ballots are universally verifiable without electionofficial intervention, and (3) tallying requires only one trustee decryption per race, thanks to homomorphic aggregation.</p><p>Scratch &amp; Vote combines the multi-candidate election techniques of Baudron et al. with the ballot-casting simplicity of Chaum and Ryan's paper-based techniques. In addition, S&amp;V allows each voter to participate directly in the audit process on election day, prior to casting their own ballot.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Cryptography can reconcile public auditability and ballot secrecy in voting. Votes are encrypted and posted on a public bulletin board, along with the voter's name (or voter identification number) in plaintext. Everyone can see that Alice has voted, though, of course, not what she voted for. The encrypted votes are then anonymized and tallied using publicly verifiable techniques.</p><p>Most cryptographic voting schemes require complex equipment and auditing. A certain degree of complexity is un-avoidable, as the functional goal of cryptographic voting is to run an election correctly while trusting third parties as little as possible. Unfortunately, this complexity often stands in the way of adoption. If it takes significant expertise to understand how a voting system functions, and if the operation of the system is particularly complex, election officials and the public may be reluctant to adopt it. The question, then, is how much can we simplify the voting process while retaining cryptographic verifiability?</p><p>Voting systems &amp; scratch surfaces. In recent months, Arizona has proposed running a cash-prize lottery for all citizens who vote <ref type="bibr" target="#b27">[27]</ref>. In response, a well-known online satirical publication jokingly proposed a "Scratch &amp; Win" voting system <ref type="bibr" target="#b30">[30]</ref>. Though our proposal, Scratch &amp; Vote, uses scratch surfaces, it should not be confused with a game of chance. That said, we hope that, given the public's familiarity with scratch surfaces, our own use of them will help spark more widespread interest in the topic of cryptographic voting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Proposal</head><p>We propose Scratch &amp; Vote (S&amp;V), a cryptographic voting method that provides public election auditability using simple, immediately deployable technology. S&amp;V offers:</p><p>1. Paper ballots: ballot casting is entirely paper-and pen-based.</p><p>2. Self-contained ballot auditing: ballots contain all the necessary information for auditing; there is no need to interact with the election officials.</p><p>3. Simple tallying: ballots are tallied using homomorphic encrypted counters rather than mixnets. Anyone can easily verify the final tally, and election officials need only cooperate to decrypt a single tally ciphertext per race (or even a single tally ciphertext for the entire election, if it isn't too large.)</p><p>The voter experience is simple and mostly familiar:</p><p>• Sign in: Alice signs in and obtains a ballot with randomized candidate ordering. Election officials should not see this candidate ordering. The ballot is perforated along its vertical midline, with candidate names on the left half and corresponding scannable bubbles on the right. A 2D-barcode is positioned just below the checkboxes on the right. A scratch surface, labeled "void if scratched," is positioned just below the barcode, and an additional perforation separates the scratch surface from the rest of the right half. (See Figure <ref type="figure">1</ref>.)</p><p>• Audit [optional]: Alice may select a second ballot for auditing. She scratches off the scratch surface, hands the now void ballot to a helper organization on the premises -i.e. a political party or activist organization she trusts -and receives confirmation that the ballot was well-formed. This gives Alice confidence that her first ballot is also well-formed: if enough voters perform the audit, even a handful of bad ballots will be quickly detected. (See Figure <ref type="figure">2</ref>.)</p><p>• Make selection: Alice steps into the isolation booth to make and review her selection.</p><p>• Detach ballot halves: Alice separates the two halves of the ballot. A receptacle is available for her to discard her left ballot half. Note that this discarded half carries no identifying information, only a randomized candidate ordering. (See Figure <ref type="figure">3</ref>.)</p><p>• Casting: Alice presents the right half of her ballot to an election official, who inspects the scratch surface to ensure it is intact. The official then detaches the scratch surface and discards it in sight of all observers, including Alice herself. Alice then feeds what remains of her ballot -the checkmark and barcode -into a scanner. This is effectively her encrypted ballot. Alice takes it home with her as a receipt. (See </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Overview of the Ideas</head><p>Scratch &amp; Vote combines a number of existing cryptographic voting ideas in a novel way, with some interesting new variations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Homomorphic tallying. Cryptographic paper ballots do</head><p>not naturally support write-in votes. Generally, when Alice wants to write in a name, she selects the "write-in" predetermined pseudo-candidate option, and follows a separate process to specify her candidate. Thus, our first proposal for S&amp;V is to use homomorphic aggregation to simplify the tally for pre-determined candidates, as originally proposed by Benaloh <ref type="bibr">[9,</ref><ref type="bibr" target="#b3">3]</ref> and, more specifically, as extended by Baudron et al. <ref type="bibr" target="#b2">[2]</ref> for multi-candidate election systems. This design choice opens the door to further simplifications. Cut-and-choose at the precinct. Once a ballot is audited, it cannot be used for voting: with its randomization values revealed, the ballot is no longer privacy-protecting. Thus, auditing is used in a cut-and-choose process: each voter may select two ballots, auditing one and voting with the other. The specific advantage of S&amp;V is that this cut-and-choose auditing requires no election official intervention: the ballot and the public election parameters are sufficient. Thus, auditing in S&amp;V is practical enough to be performed live, in front of the voter, just before she casts her ballot. In addition, local election officials may audit a number of ballots on their own before voting begins: once again, these local election officials only need the public election parameters to successfully audit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2D-barcode and scratch surface.</head><p>Proofs of correctness and certified ballot list. In a homomorphic tallying system, auditors want assurance that the encrypted ballots contribute no more than one vote per race; otherwise, a malicious official and voter could collude to artificially inflate a candidate's tally. For this purpose, election officials prepare zero-knowledge proofs of correctness for each official ballot. These proofs are published on the bulletin board for all to see prior to election day, and only ballots whose proofs verify are included in the tally. As a result of this tallying condition, voters now need assurance that their ballot won't be disqualified at some point after ballot casting. Unfortunately, the sheer size of the proof precludes printing it on the ballot alongside the ciphertexts.</p><p>To address this concern, election officials produce a certified ballot list containing ballots that officials are prepared to guarantee as correct. This certified list can be easily downloaded to each physical precinct before the polls open. The voter can then check that his ballot is present on the certified list before voting. In addition, this certification prevents spurious complaints from malicious voters who might inject fraudulent ballots in to the system solely for the purpose of complaining and holding up the proper execution of the election.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Related Work</head><p>Chaum <ref type="bibr" target="#b7">[7]</ref> introduced the first paper-based cryptographic scheme in 2004 . Ryan et al. <ref type="bibr" target="#b8">[8]</ref> proposed a variant, the Prêta-Voter scheme, recently extended to support reencryption mixes and just-in-time ballot printing <ref type="bibr" target="#b29">[29]</ref>. Another variant by Randell and Ryan <ref type="bibr" target="#b28">[28]</ref> suggests the use of scratch surfaces (though for different goals than ours). Chaum's latest variant, called Punchscan <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b6">6]</ref>, proposes a number of interesting variations to further simplify the paper-based voting approach.</p><p>All of these methods make use of mixnets to anonymize the ballots, though it should be noted that the mixnet proposed by Punchscan is simplified and uses only hash-based commitments for the shuffle permutation. In this latter case as well as in most decryption mixnets, proofs are performed by randomized partial checking <ref type="bibr" target="#b17">[17]</ref>. In the case of reencryption mixnets, Neff's proof <ref type="bibr" target="#b23">[23]</ref> can be used . In all cases, however, the officials are involved in the anonymization of the ballots.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">This Paper</head><p>In section 2, we cover some preliminaries. We cover the basic S&amp;V method in section 3, some potential extensions in section 4, and the adaptation of S&amp;V to the Chaum ballot in section 5. We consider the system's threat model in section 6, before concluding in section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES 2.1 Paillier Cryptosystem</head><p>The Paillier public-key cryptosystem <ref type="bibr" target="#b24">[24]</ref> provides semantically secure encryption, efficient decryption, and an additive homomorphism by ciphertext multiplication. The details of the Paillier cryptosystem can be found in the original paper. We provide a brief summary:</p><p>• Gen(1 k ): generate two safe primes p1 and p2. The secret key sk is λ = lcm(p1 -1, p2 -1). The public key pk includes n = p1p2 and g ∈ n 2 such that g ≡ 1 mod n. Oftentimes, g = n + 1.</p><p>• Enc pk (m; r): encrypt a message m ∈ n with randomness r ∈ * n 2 and public key pk as c = g m r n mod n 2 . We write c = Enc pk (m) when the randomness r is not crucial to the explanation.</p><p>• Dec sk (c) decrypt a ciphertext c ∈ * n 2 . Consider function L(x) = (x -1)/n. Decryption is then:</p><formula xml:id="formula_0">L(c λ mod n 2 ) L(g λ mod n 2 )</formula><p>mod n</p><p>The additive homomorphism enables the following:</p><formula xml:id="formula_1">Dec sk " Enc pk (m1) • Enc pk (m2) " = m1 + m2</formula><p>Generalized Paillier. Damgård and Jurik <ref type="bibr" target="#b11">[11]</ref> provide a generalization of the Paillier cryptosystem that yields a larger plaintext domain with relatively less ciphertext expansion. Specifically, a plaintext in n s can be encrypted into a ciphertext in n (s+1) , where the security of the scheme still depends on the bit-length of n. The security of this generalized scheme is proven under the same assumption as the original Paillier scheme.</p><p>Threshold Decryption. The Paillier cryptosystem supports fairly efficient threshold decryption <ref type="bibr" target="#b14">[14]</ref>, even in its generalized form <ref type="bibr" target="#b11">[11]</ref>. It also supports fairly efficient distributed key generation <ref type="bibr" target="#b12">[12]</ref>. In other words, it is possible for k officials to jointly generate a Paillier keypair (pk , sk ) such that each has a share sk (i) of the secret key. It is then possible for an h-sized subset of these k officials to jointly decrypt a ciphertext in a truly distributed protocol.</p><p>Practical Considerations. Paillier relies on the hardness of the factoring problem. Thus, we must assume at least a 1024-bit modulus, and potentially a 2048-bit modulus. Given a κ-bit modulus, plaintext size is κ bits while ciphertext size is 2κ bits. For a larger plaintext domain, we can use Generalized Paillier, as described above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Homomorphic Counters</head><p>The homomorphic voting approach was made practical by Baudron et al. <ref type="bibr" target="#b2">[2]</ref>, using techniques introduced by Benaloh <ref type="bibr">[9,</ref><ref type="bibr" target="#b3">3]</ref>. The homomorphic multi-counter was specifically formalized by Katz et al. <ref type="bibr" target="#b19">[19]</ref>.</p><p>Baudron et al. describe a multi-counter encrypted under an additive cryptographic system, like Paillier. The bitspace of the plaintext is partitioned into separate counters, ensuring that enough bits are dedicated to each counter so that no overflow occurs from one counter to another (as this would violate the correctness of the multi-counter).</p><p>Assuming a message domain of n where b = |n| is the bit-size of n, we encode a value tj for counter j ∈ [1, l] as tj • 2 (j-1)M . Thus, each counter can run only up to 2 M -1, and we must ensure that b &gt; lM. To add 1 to counter j contained within the multi-counter T , we use the additive homomorphic property:</p><formula xml:id="formula_2">T = T • Enc pk (2 (j-1)M )</formula><p>Note that, given the semantic security of the Paillier cryptosystem, an observer cannot tell, from looking at this homomorphic operation, which internal counter was incremented. In other words, given encrypted messages, the homomorphic aggregation into an encrypted counter can be performed and verified by any observer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Proofs of Correctness and NIZKs</head><p>If Alice encrypts a message m into a ciphertext c using the Paillier cryptosystem, she can prove, in honest-verifier zero-knowledge, that c is indeed the encryption of m, using a typical, three-round interactive protocol similar to Guillou and Quisquater's proof of RSA pre-image <ref type="bibr" target="#b15">[15]</ref>.</p><p>Using the techniques of Cramer et al. <ref type="bibr" target="#b10">[10]</ref>, this protocol can be extended to prove that ciphertext c encrypts one of possible values (m1, m2, . . . , m k ), without revealing which one. Combining this with the homomorphic proof technique of Juels and Jakobsson <ref type="bibr" target="#b16">[16]</ref>, one can prove, fairly efficient and in zero-knowledge, that a set of ciphertexts (c1, c2, . . . , c k ) encrypts a permutation of m1, m2, . . . , m k , assuming that no two subsets of {mi} have the same sum:</p><p>• for each ci, prove that ci encrypts one of m1, . . . , m k , • the homomorphic ciphertext sum L i ci is the correct encryption of the plaintext sum</p><formula xml:id="formula_3">P i mi.</formula><p>For more than a handful of plaintexts, more efficient proof techniques are available, including Neff's shuffle proof of known plaintexts <ref type="bibr" target="#b23">[23]</ref>.</p><p>In any case, all of these proofs can be made non-interactive using the Fiat-Shamir heuristic <ref type="bibr" target="#b13">[13]</ref>, where the interactive verifier challenge is non-interactively generated as the cryptographic hash of the prover's first message in the threeround protocol. These types of proof, first introduced by Blum et al. <ref type="bibr" target="#b4">[4]</ref>, are abbreviated NIZKs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Paper Ballots</head><p>Existing paper-based cryptographic methods use two types of ballot layout: the Prêt-a-Voter split ballot, and the Punchscan layered ballot. We review these approaches here, as they can be both adapted to use S&amp;V. Prêt-a-Voter. In Ryan's Prêt-a-Voter, the ballot is a single sheet of paper with a perforated vertical midline. Candidate names appear on the left in a per-ballot-randomized order, with a corresponding space on the right half. After Alice, the voter, has marked her choice in the appropriate space, the two halves are separated: the left half (the one with the candidate names) is discarded, and the right half is cast. The right half contains a mixnet onion that allows administrators to recreate the left half of the ballot and determine the voter's choice. (See Figure <ref type="figure" target="#fig_2">6</ref>.) Punchscan. In Chaum's Punchscan <ref type="bibr" target="#b20">[20]</ref>, the ballot is composed of two super-imposed sheets. The top sheet contains the question, an assignment of candidates to codes (randomized by ballot), and physical, circular holes half-an-inch wide which reveal codes on the bottom sheet. The codes on the bottom sheet match the codes on the top sheet, though their order on the bottom sheet is randomized.</p><p>Alice, the voter, selects a candidate, determines which code corresponds to this candidate, and uses a "bingo dauber" to mark the appropriate code through the physical hole. The use of this thick marker causes both sheets to be marked. Then, Alice separates the two sheets, destroys one, and casts the other. Individually, each sheet displays the voter's choice as either a code or a position, but the correspondence of code to position is only visible when both sheets are together. A hash-committed permutation on both sheets allows the administrators to reconstitute the discarded half and recover the vote. Because Alice chooses which half to destroy and which half to cast, she can eventually get assurance, with 50% soundness, that her ballot was correctly formed: the election officials eventually reveal what the kept halves should look like. Auditing Prêt-a-Voter and Punchscan. In both Prêt-a-Voter and Punchscan, there are two ballot auditing components: verification of the correct ballot form, and verification of correct tallying. In both schemes, a system-wide cut-and-choose is performed before the election: for a randomly selected half of the ballots, election officials reveal the randomization values used in creating the ballots. These audited ballots are thus spoiled, as they no longer protect ballot secrecy. The remaining ballots, now proven to be almost all correct with very high probability, are used in the actual election. Once ballots are cast, they are shuffled, and the postelection audit consists of Randomized Partial Checking <ref type="bibr" target="#b17">[17]</ref> on the shuffle and the prior permutation commitment. Punchscan adds an additional verification of ballot form after the election, thanks to the voter decision of which half to keep and which half to discard. This guarantees that any cheated ballot that made it through the initial audit will be detected with 50% probability.</p><formula xml:id="formula_4">q r m x 8c3sw Adam -x Bob -q Charlie -r David -m 8c3sw q r m x Adam -x Bob -q Charlie -r David -m q r m x 8c3sw q r m x Adam -x Bob -q Charlie -r David -m q r m x 8c3sw</formula><p>Limitations. In the case of Prêt-a-Voter, significant synchronous involvement of election officials is required during all audits. It is particularly challenging to interactively reveal the randomization values for half the ballots while keeping the other half truly secret. Consequently, this audit is performed by election officials in advance. Individual voters must trust that this audit was performed correctly, in particular that election officials didn't collude to produce faulty ballots. This is a slightly weaker verification property than we would like: ideally, voters should get direct assurance that their vote was recorded as intended, without having to trust election officials.</p><p>In the case of Punchscan, there is also some degree of dependence on synchronous involvement of the election officials. While the additional check performed on the ballot form certainly alleviates this situation-Alice now gets direct assurance that her ballot was correctly formed-this assurance comes after the close of elections. This delay may reduce Alice's trust in the system, since the error correction protocol will likely be onerous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE SCRATCH &amp; VOTE METHOD</head><p>We assume a single race for now. Section 4 naturally extends these techniques to multiple races.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Election Preparation</head><p>At some point prior to election day, the list of candidates is certified by election officials and publicized for all to see. The l candidates are ordered in some fashion for purposes of assigning index numbers (alphabetical order is fine). This ordering need not be known by individual voters. Thus, election laws on candidate ordering should not apply to here.</p><p>Election officials then jointly generate a keypair for the election, where official Oi holds share sk (i) of the decryption key sk , and the combined public key is denoted pk . A parameter M is chosen, such that 2 M is greater than the total number of eligible voters. Election officials ensure that b = |n| is large enough to encode a multi-counter for l candidates, each with M bits, i.e. b &gt; Ml. A vote for candidate j is thus encoded as Enc pk (2 (j-1)M ). When all is said and done, the election parameters are publicized: </p><formula xml:id="formula_5">params = " pk , M,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Ballot Preparation</head><p>The Ballot. Our first S&amp;V ballot is based on the Ryan Prêta-Voter ballot <ref type="bibr" target="#b8">[8]</ref>. Each ballot is perforated along a vertical midline. On the left half of the ballot is the list of candidate names, in a randomized order. The right half of the ballot lines up scannable checkboxes (represented as lines in our diagrams) with each candidate on the left half. The voter will mark one of those checkboxes.</p><p>Also on the right half, the S&amp;V ballot contains the representation of ciphertexts that encode votes corresponding to each ordered option. The representation of these ciphertexts can be machine-readable only and should be scannable, e.g. a 2D-barcode <ref type="bibr" target="#b32">[32]</ref>. Just below this barcode, the ballot also includes a scratch surface, under which are hidden the randomization values used to produce the ciphertexts in the barcode. (See Figure <ref type="figure">8</ref> The Proofs. Election officials must also generate NIZK proofs of ballot correctness. These proofs will not be printed on the ballot, as they are too long. Instead, they are kept on the public bulletin board, indexed by the sequence of ciphertexts on the corresponding ballot (or a hash thereof), and used at tallying time to ensure that all ballots contribute at most one vote per race.</p><p>In addition to these proofs, election officials compile an official ballot list, which includes all properly created ballots designated again by the sequence of ciphertexts on each ballot. Officials digitally sign this ballot list, posting the list and signature on the bulletin board. This official ballot list is particularly useful to help prevent various denial-of-service attacks against both voters and election officials.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example. Assume the randomized candidate ordering of a</head><p>given ballot is "Bob, Charlie, David, Alice", or, by index, "2,3,4,1". Recall that M = 28. The machine-encoding on the right ballot half should then be: c1 = Enc pk (2 28 ; r1), c2 = Enc pk (2 56 ; r2), c3 = Enc pk (2 84 ; r3), c4 = Enc pk (2 0 ; r4).</p><p>This encoding requires 4 ciphertexts, or 8192 bits. Under the scratch surface lie, in plaintext, r1, r2, r3, r4. Election officials also generate Π H(c 1 ,c 2 ,c 3 ,c 4 ) , a NIZK of proper ballot form indexed by the ciphertexts, then post it to the bulletin board. The same hash H(c1, c2, c3, c4) is also included in the compiled list of official ballots, which the election officials eventually sign.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Ballot Auditing</head><p>Ballot auditing in S&amp;V uses a cut-and-choose approach to verify candidate ordering (while further ballot correctness is enforced by the bulletin-board NIZK). A random half of the ballots are audited, and almost all remaining ballots are then guaranteed to be correctly constructed: the probability that more than x bad ballots go undetected is 2 -x . Once audited, a ballot is spoiled and cannot be used to cast a vote.</p><p>Auditing a single ballot. This auditing process is similar to that of Prêt-a-Voter and Punchscan, with one major difference: auditing can be performed using only the public election parameters, without election-official interaction.</p><p>1. Scratch: the scratch surface is removed to reveal the randomization values.</p><p>2. Encrypt: the candidate ordering is encrypted with the revealed randomization values.</p><p>3. Match: the resulting ciphertexts are matched against the ciphertexts in the 2D-barcode.</p><p>Note that, to automate this process without having to scan or type in the displayed candidate ordering, one might perform the matching the other way around: read the ciphertexts, try all possible plaintext candidates with each revealed randomization value (effectively a decryption), and display the expected candidate ordering. Matching the actual ordering against this expectation can be performed by the voter herself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Spoiling a ballot. A ballot no longer protects privacy if</head><p>its randomization values are revealed. Thus, if its scratch surface is removed, a ballot should be considered spoiled, and it cannot be cast. This is consistent with existing uses of scratch surfaces, e.g. those used on lottery tickets, and the usual "void if scratched off" message can be printed on top of the scratch surface. This condition for ballot casting must be enforced at ballot casting time, as will be described Section 3.4.</p><p>Who should audit?. Though we find that individual voter auditing is preferable, some might prefer to audit ballots in a centralized fashion. Scratch &amp; Vote supports such an audit method, of course. One can also imagine officials auditing a few ballots on their own before election day, in addition to per-voter auditing. S&amp;V enables all of these auditing combinations.</p><p>Checking for Variability in Ordering. Malicious election officials might attempt to breach Alice's privacy by presenting all voters only ballots with the same candidate ordering. To protect against this de-randomization attack, Alice should select her two ballots herself, ensuring that there is enough variability between the ballots offered to her.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chosen ballot check.</head><p>Alice must also check the ballot she actually uses: she needs assurance that her ballot will count, specifically that it won't be disqualified for some unforeseen reason, e.g. an invalid NIZK proof at tallying time. For this purpose, Alice checks the presence of her ballot on the certified official ballot list, which she can obtain from the bulletin board ahead of time. If, at a later date, Alice's ballot is disqualified for any reason, she can present the signed official ballot list as a complaint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Ballot Casting</head><p>On election day, after having audited and spoiled a first ballot, Alice enters the isolation booth with a second ballot. She fills it out by applying a checkmark (or filling in a bubble) next to the candidate name of her choice. Then, she proceeds to ballot casting:</p><p>1. Detach: Alice detaches the left half of the ballot and discards it in the appropriate receptacle (inside the booth). She then leaves the voting booth.</p><p>2. Confirm: An election official verifies that the scratch surface on Alice's ballot is intact. This is crucial to ensuring the secret ballot: if a voter sees the randomization values for the ballot she actually casts, then she can prove how she voted to a potential coercer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Second Detach:</head><p>The official detaches and discards the scratch surface, in view of all observers, including Alice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Scan:</head><p>Alice feeds the remainder of her ballot through a typical modern scanner, which records the barcode and checkmark position and posts them on a bulletin board along with Alice's name (or other identifier).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>Receipt: Alice retains this same remainder as her encrypted receipt. She can later check that her ballot is indeed on the bulletin board.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Tallying</head><p>For each ballot on the bulletin board, election officials and observers check its NIZK. If it verifies, the ciphertext corresponding to the checkmark position is extracted from the 2D-barcode and aggregated into the homomorphic counter, just like any other homomorphic voting system. Anyone can verify that only valid ballots have been aggregated, as any observer can verify the NIZK and re-perform the appropriate homomorphic aggregation.</p><p>Similarly, all election trustees can independently verify that the homomorphic aggregation has been performed correctly. Then, the single resulting ciphertext counter is decrypted by a quorum of these trustees, along with proofs of correct decryption. The resulting plaintext reveals the vote count for each candidate. The tally and trustee proofs are posted to the bulletin board for all to see.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Practical Considerations</head><p>We consider computation requirements and physical constraints of the ballot:</p><p>• generating the NIZK proofs for each ballot, given that ZK proofs are typically expensive,</p><p>• auditing a ballot at voting time, given the voter's limited time and patience, and</p><p>• fitting all of the ciphertext data in reasonably sized 2D barcodes.</p><p>Consider an election with 5 races, each with 5 candidates.</p><p>Proofs. Each race contains 5 ciphertexts, one per candidate. Using the CDS <ref type="bibr" target="#b10">[10]</ref> proof-of-partial-knowledge technique, each ciphertext must be proven to encrypt one of the 5 candidates. The CDS technique simulates 4 of these proofs and computes a fifth one for real. This requires the equivalent work of 5 proofs, both in terms of computation time and number of bits needed to represent the proof. In addition, the homomorphic sum of the ciphertexts must be proven to encrypt the sum of the candidate representations, which is one more proof. Thus, each race requires 26 proofs, and 5 races thus require 130 proofs. Each of these proofs, whether real or simulated, requires two modular exponentiations. The entire proof thus requires a total of 260 modular exponentiations. Conservatively, modern processors can perform a 1024-bit modular exponentiation is approximately 12ms on a 2.8Ghz machine running GMP <ref type="bibr" target="#b1">[1]</ref>. Thus, a single ballot proof can be performed in just over 3 seconds.</p><p>Each of these proofs is composed of 2 Paillier ciphertext space elements, and one Paillier plaintext space element (the challenge). Assuming a 1024-bit modulus, the ciphertext elements are 2048 bits and the plaintext is 1024 bits. Thus, each proof require 5120 bits, and the entire ballot thus requires 83 kilobytes of proof data, which is posted on the bulletin board (e.g. a web site.) Ballot Verification. At the polls, the only verification cost is the single ballot audit per voter. Given the 5 randomization values, all 5 values of r n can be computed through modular exponentiation, after which only modular multiplications are needed to re-discover the randomized ordering. These multiplications are negligible in comparison to the modular exponentiations. Thus, ballot verification can be performed in 60ms per race, or 300ms for our considered ballot. The scratch-off and the time allotted for each person to vote (1-2 minutes) will likely make the cryptographic cost negligible.</p><p>Barcode Size. The PDF417 2D-barcode standard <ref type="bibr" target="#b31">[31]</ref> can store 686 bytes of binary data per square inch, using a symbol density that is easily printed and scanned. In our example with 25 candidates, 25 Paillier ciphertexts are required, which means 6400 bytes, assuming a 1024-bit modulus for Paillier. Thus, 10 square inches are sufficient to represent all of the ciphertexts we need for this sample election. Even if we factor in significant error correction, this represents less than 1/8th of the surface area of a a US Letter page.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EXTENSIONS</head><p>We now explore a few extensions to make Scratch &amp; Vote more practical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Helper Organizations</head><p>We do not expect individual voters to show up to the polls with the equipment required to audit ballots and check the official ballot list. Instead, helper organizations, e.g. political parties and activist organizations, can provide this service at the polls. Voters can consult one or more of these, at their discretion. Most importantly, these helpers are not trusted with any private election data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Multiple Races &amp; Many Candidates</head><p>When the election contains more than one race, it may outgrow the space of the multi-counter, which can only hold |n|/m counters. One solution is to use higher-degree encryption using the Damgård-Jurik generalization <ref type="bibr" target="#b11">[11]</ref>, so that the counter space can be s|n| rather than |n|, with a corresponding ciphertext length of (s + 1)|n|. Unfortunately, this ciphertext size may outgrow the 2D-barcode encoding, which is expected to hold no more than a few kilobytes.</p><p>Another option is to designate, in the public election parameters, separate multi-counters, potentially one per race. In that case, the parameters must also indicate the race/multicounter assignments. With a separate 2D-barcode per race, most practical cases are accounted for, barring elections such as the California Recall election of 2004, which had more than 100 candidates.</p><p>In such borderline cases, there is no choice but to use the Damgård-Jurik generalization, as the individual ciphertexts for a given race should not be distinguishable and thus cannot be assigned to different multi-counters. If a single 2Dbarcode cannot hold all the required ciphertexts for that one race, we can, as a last resort, designate a separate 2Dbarcode for each candidate. The resulting auditing complexity is an inevitable consequence of these extreme conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Reducing the Scratch</head><p>As the printed material behind the scratch surface may become damaged from the scratching, we cannot expect to reliably store significant amounts of data behind this scratch surface. In fact, it is easy to reduce this data by having election parameters designate a pseudo-random function, call it PRF, which generates all the randomization values from a single short seed, which need only be 128 bits. Such a data length can be easily encoded as alphanumeric characters or as a single-dimension barcode, both of which offer enough redundancy to withstand quite a few scratches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Chain Voting and Scratch Surfaces</head><p>All paper-based voting systems have long been known to be susceptible to chain voting attacks. In these attacks, a coercer gives Alice a pre-marked ballot before she enters the polling location, expecting her to cast this pre-marked ballot and return a blank ballot to him on her way out.</p><p>The well-known countermeasure to chain voting attacks <ref type="bibr" target="#b18">[18]</ref> suggests having unique ballot identifiers on a tear-off slip attached to the ballot. An official writes down the ballot identifier for Alice before she enters the isolation booth. At ballot casting time, the official checks that this ballot identifier still matches the pre-recorded value. Then, for anonymity, the identifier is torn off and discarded.</p><p>This process is, in fact, almost identical to the scratch surface tear-off we suggest. Thus, our election-official verification process can be piggy-backed onto existing practices. In addition to checking the ballot identifier, the election official must simply check the scratch surface integrity. The overhead of our proposal at casting time is thus minimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Write-Ins</head><p>Like the Prêt-a-Voter and Punchscan ballots, Scratch &amp; Vote does not support write-in votes out of the box. A separate system should be used, where a special option named "write-in" is selected by the voter, and the voter can separately cast the content of the write-in. The details of this process can be worked out for all paper-based schemes, possibly using the vector-ballot method of Kiayias and Yung <ref type="bibr" target="#b21">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">ADAPTING PUNCHSCAN</head><p>Recall that Chaum's Punchscan facilitates more races per ballot than Prêt-a-Voter, because the full ballot face can be used without a midline separation. However, Punchscan is also more complicated, because the voter may cast either sheet. This makes the mandatory destruction of the remaining half more delicate, since Alice could easily sell her vote if she successfully preserves the second half.</p><p>Thus, we propose a new ballot that combines the qualities of Punchscan and Prêt-a-Voter and adds the S&amp;V method. As this ballot originated from Punchscan, we call it the Punchscan Scratch &amp; Vote ballot. However, we note that it inherits some properties from Prêt-a-Voter, too. Punchscan Scratch &amp; Vote Ballot. The Punchscan Scratch &amp; Vote ballot, like Punchscan, is composed of two superimposed sheets. Unlike the original Punchscan, the two sheets serve different purposes. Alice, the voter, will be expected to separate both halves and cast the top half in all cases. The bottom half, like Prêt-a-Voter's left half, is generic, and its destruction need not be strongly verified.</p><p>The top sheet lists the races and candidates in standard order, with a standard code assigned to each candidate (e.g. 'D' for democrats, 'R' for republicans.) Again, this differs from the Punchscan ballot, where random codes are assigned to candidates. This top sheet offers checkboxes for each race, and one hole above each checkbox which reveals the code letter displayed on the bottom half at that position. Also included on the top sheet are the S&amp;V components: the ciphertexts in a 2D-barcode, and the randomization values hidden under a scratch surface.</p><p>The bottom sheet contains only the standard candidate codes in random order. The ciphertexts on the front sheet should match this random order. Note, again, that this bottom sheet is entirely generic: it contains no identifier of any kind, no ciphertexts, and no randomization values. It functions exactly like the Prêt-a-Voter left half. Casting the Ballot. Alice marks her ballot in isolation.</p><p>Unlike the original Punchscan method, the markings in the top-sheet bubbles do not bleed through to the bottom half. When she is ready, Alice detaches the bottom half of the ballot and discards it in the proper receptacle (where, again, she can easily grab another bottom half to claim that she voted for someone else.) Alice then presents the top sheet of her ballot to the election official, who treats it exactly like in the Prêt-a-Voter Scratch &amp; Vote ballot: verify the scratch surface, detach and discard it, and scan the remainder. Again, this remainder serves as Alice's receipt. Alice then takes it home as her receipt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">THREAT MODEL</head><p>We consider various threats and how Scratch &amp; Vote handles them. We cover the threats thematically rather than chronologically, as some threats pertain to multiple steps of the election lifecycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Attacking the Ballots</head><p>Election officials. An election official might create bad ballots in two ways: a completely invalid ballot or, more perniciously, a valid ballot that does not match the humanreadable candidate ordering. In either case, the first line of defense is the voter cut-and-choose: only a small number of such ballots can go undetected, since half of them will get audited randomly. In the case of completely invalid ballots, the verification is much more stringent: election officials would have to answer for certified ballots that do not have a proper NIZK proof, and only valid ballots can have proper NIZK proofs.</p><p>External parties. External parties may wish to introduce fraudulent ballots, most likely as a denial-of-service attack against voters at certain precincts, or, by vastly increasing the number of complaints, as a denial-of-service attack against election officials. These problems are thwarted by the certified ballot list. The moment an election official discovers an uncertified ballot, he can begin an investigation. If officials fail to catch the problem, the voters' helper organizations will. Consequently, fraudulent ballots should be caught before the voter enters the isolation booth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Collusion between officials and voters.</head><p>A single maliciously crafted ballot could alter the count significantly in the homomorphic aggregation. This is particularly problematic if the officials collude with a voter who won't perform the proper cut-and-choose audit because he is very much interested in using the fraudulent ballot. Once again, the NIZK proof on the bulletin board prevents this from ever happening, providing a universally verifiable guarantee that each cast ballot only contributes a single vote to a single candidate for each race.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Attacking Ballot Secrecy</head><p>Leaky Ballots. Election administrators could leak information about the ballot candidate ordering using the ciphertext randomness. This threat is somewhat lessened with the use of seed-based randomness, where a portion of the seed is public and selected after the individuals ballot seeds are picked. However, this topic requires further exploration.</p><p>Tampering with the scratch surface. Eve, a malicious voter, may attempt to remove the scratch surface from her ballot, read the randomization values, and replace the scratch surface undetected. This would allow Eve to sell her vote, given that her encrypted vote will be posted on the bulletin board, along with Eve's full name, for all to see and audit. We must assume, as a defense against this threat, that the scratch surface is sufficiently tamper-proof to prevent such an easy replacement that would fool an election administrator. Real-world experiments will be necessary to determine if this is feasible.</p><p>Ballot face recording. One significant weakness of all preprinted paper-based cryptographic voting, including Scratch &amp; Vote, is that election officials who produce the ballots may record the ballot ciphertexts and candidate orderings, thus violating ballot secrecy.</p><p>Even in Prêt-a-Voter and Punchscan, which use multiple authorities in a mixnet setting, the last mix server knows the final candidate ordering. It may be worthwhile to explore clever ways of distributing the ballot generation mechanism, though the best solution may be process-based, where machines produce ballots and immediately forget the randomness used. The recent proposal of Ryan and Schneider <ref type="bibr" target="#b29">[29]</ref> addresses this threat with on-demand ballot printing, though this requires significantly more deployed technology at the precinct level.</p><p>The ballot face recording problem exists for more than just election officials: those who transport ballots may have a chance to record the correspondence of candidate ordering to barcode. We note, again, that Prêt-a-Voter and Punchscan suffer from the same problem. One promising defense in all cases is simply to hide some portion of the ballot such that it can no longer be uniquely identified during transport. For example, individual ballots can be sealed individually in opaque wrappers. Alternatively, the 2Dbarcode can be hidden under opaque plastic that can be peeled off prior to voting. If the printed barcode is particularly resilient, one can even use an additional scratch surface.</p><p>Casting. At ballot casting time, election administrators must ensure that the cast ballot has not revealed its randomization values, for this would enable vote selling. Of course, this verification must be performed without violating ballot secrecy in the process. Our proposal specifically addresses this threat: an election official only sees the encrypted half of the ballot. He can take all the necessary care to verify that the scratch surface is intact, while ballot secrecy remains protected.</p><p>Another threat remains: official-voter collusion. If an election official and voter collude to preserve, rather than discard, the scratch surface, the voter may be able to reveal his selection to the official (and later to other parties.) Sufficient observation of the voting process by competing political parties should address this issue. S&amp;V further mitigates this risk with ballots created such that the "missing half" is generic. Thus, voters can easily pick up alternative "missing halves" to claim they voted differently, and a coercer may not be certain whether the claimed half is, indeed the proper decryptor half for Alice's ballot.</p><p>Coerced Randomization. Recently, a new threat to paperbased voting systems has been pointed out: coerced randomization <ref type="bibr" target="#b5">[5]</ref>. In this attack, a coercer wishes to "reduce to random" Alice's vote. Consider, for example, the situation where Alice votes in a precinct that historically favors one political party by a wide margin. Such precincts are quite common in the United States. A coercer can ask Alice to vote for the first candidate in the list, no matter what that candidate is. The coercer can check this by viewing the bulletin board under Alice's name or voter identification number. Of course, the coercer won't know for sure who Alice voted for-in fact she may, by sheer luck, have obtained a ballot where this position coincides with her preferred choice-but he will have effectively reduced her vote to random. With enough voters, the coercer can statistically reduce the number of votes for the party typically favored by this precinct.</p><p>By way of countermeasure, one can offer the voter enough ballot ordering selections that she can pick a ballot where the prescribed behavior fits her personal choice. Unfortunately, the attack can become much more complex: for example, the prescribed behavior may involve voting for a position on the ballot that depends on the ballot identifier. This issue merits significant research. However, we note that Scratch &amp; Vote does not make this problem any worse: Punchscan and Prêt-a-Voter are equally vulnerable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Attacking the Bulletin Board and the Tally</head><p>Much of the security of the tallying process depends on the bulletin board. An attacker may want to insert fraudulent data, for example to change the election parameters or replace an honest citizen's cast vote. Digital signatures on all posted data can prevent such attacks, assuming that a minimal PKI is deployed to certify the public keys of election officials. Public observers of the bulletin board content, including helper organizations, can then detect bad data.</p><p>Alternatively, an attacker may want to suppress information from the bulletin board. In particular, the bulletin board server itself may suppress information. To protect against this attack, the bulletin board should be implemented by multiple servers. These servers may run a distributed Byzantine agreement protocol to ensure consistency of content <ref type="bibr" target="#b22">[22]</ref>, or observers may simply rely on cryptographic signatures of the content and the redundancy of the servers to catch any server the suppresses content, using, for example hash trees <ref type="bibr" target="#b26">[26]</ref>.</p><p>Given a secure bulletin board implemented as above, attacks on the tallying process can be prevented, because every step is verified with proofs. Ballots are proven well-formed by the NIZK proof on the bulletin board, any observer can re-perform the homomorphic aggregation, and the final tally decryption is also proven correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>We have proposed Scratch &amp; Vote, a simple cryptographic voting system that can be implemented with today's technology, at very low cost and minimized complexity. Most importantly, ballots are self-contained: any helper organization, or the voter herself, can audit the ballot without interacting with election officials, before the voter casts her ballot. Given its intuitive use of scratch surfaces, Scratch &amp; Vote may prove particularly useful in providing an accessible explanation of the power of cryptographic verification for voting systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 4 •Figure 1 :r 1 r 2 r 3 r 4 Figure 2 :Figure 3 :</head><label>41423</label><figDesc>Figure 1: A Scratch &amp; Vote ballot, before and after Alice makes her selection. The ballot is perforated along two axes: down the vertical midline, and between the barcode and scratch surface on the right half.So far, this description uses the Scratch &amp; Vote adaptation of the Ryan Prêt-a-Voter ballot. In section 5, we also show how to achieve the same features based on a new ballot inspired by Chaum's Punchscan<ref type="bibr" target="#b20">[20]</ref>, whose physical layout accommodates numerous races more easily. We consider the threat model and certain extensions to our proposal that further increase practicality.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: Casting the S&amp;V ballot. The election official verifies that the scratch surface is intact, then discards it. The remainder of the ballot is cast using a typical modern scanner. Alice then takes it home as her receipt.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The Prêt-a-Voter Ballot: A ballot is a single sheet of paper with a midline perforation. The Voter fills in her choice, then tears the left half off and destroys it, casting the right half.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The Chaum Ballot: A ballot is composed of two super-imposed sheets. Alice, the voter, marks both sheets simultaneously using a dauber. The two sheets are separated, one is discarded, and the other is scanned and posted on the bulletin board. This same half is also the voter's receipt.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>r 1 r 2 r 3 E 4 Figure 8 :</head><label>348</label><figDesc>Figure 8: Public Election Parameters and the S&amp;V Ballot. Election parameters are on the left. The ballot is midline-perforated. The order of the candidate names is randomized for each ballot. The 2D-barcode on the bottom right corner of the ballot contains ciphertexts encoding the candidates in the corresponding order according to the public election parameters. The scratch surface on the left hides the randomization values r1, r2, r3, r4 used to create the ciphertexts on the right.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: The Punchscan Scratch &amp; Vote variant. The left and middle sheets are superimposed to create the ballot on the right. The bottom sheet contains no identifying information. The top layer has circular holes big enough to let the candidate ordering from the bottom sheet show through. The checkmark locations, represented by small squares, are only on the top layer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: The Punchscan Scratch &amp; Vote ballot separation. Alice separates the top and bottom sheets, depositing the bottom sheet in the appropriate receptacle. The top sheet is effectively an encrypted ballot. Note how the "codes" for each candidate are intuitively chosen, not random.</figDesc><graphic coords="9,222.40,118.32,68.16,77.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Casting a Punchscan Scratch &amp; Vote ballot. An election official verifies that the scratch surface is intact, then tears it off and discards it in view of all observers. The remainder is scanned and cast. Alice then takes it home as her receipt.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>With l = 4 candidates, a candidate ordering is assigned: Adam is #1, Bob #2, Charlie #3, and David #4. With 2 × 10 8 eligible voters (big enough for the entire US), we set M = 28 &gt; log 2 (2 × 10 8 ). A Paillier public key with |n| = 1024 bits is largely sufficient for this single-race election. In fact, we could have up to 35 candidates for this single race, or 7 races with 5 candidates each, without having to alter cryptographic parameters.</figDesc><table /><note><p>{cand 1, cand 2, . . . , cand l } " Example.</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>The authors wish to thank Peter Ryan and David Chaum for useful discussions, Stephen A. Weis for useful suggestions regarding scratch surfaces, and the anonymous reviewers for particularly insightful comments. The authors wish to acknowledge support from a Knight Foundation grant to the Caltech/MIT Voting Technology Project.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The GNU Multi-Precision Arithmetic Library</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Swox</surname></persName>
		</author>
		<ptr target="http://www.swox.com/gmp/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Practical multi-candidate election system</title>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Baudron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre-Alain</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Stern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Poupard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODC</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="274" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Distributing the power of government to enhance the power of voters</title>
		<author>
			<persName><forename type="first">Josh</forename><surname>Benaloh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moti</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODC</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="52" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Non-interactive zero-knowledge and its applications (extended abstract)</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="103" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Coerced Randomization</title>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Neff</surname></persName>
		</author>
		<editor>Andy Neff</editor>
		<imprint>
			<date type="published" when="2006-04">April 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">David</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><surname>Punchscan</surname></persName>
		</author>
		<ptr target="http://punchscan.org" />
		<title level="m">viewed on August 13th</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Secret-Ballot Receipts: True Voter-Verifiable Elections</title>
		<author>
			<persName><forename type="first">David</forename><surname>Chaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security and Privacy</title>
		<imprint>
			<biblScope unit="volume">02</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="38" to="47" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A practical voter-verifiable election scheme</title>
		<author>
			<persName><forename type="first">David</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">A</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steve</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESORICS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Sabrina</forename><surname>De</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Capitani</forename><surname>Di Vimercati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Paul</forename><forename type="middle">F</forename><surname>Syverson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dieter</forename><surname>Gollmann</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3679</biblScope>
			<biblScope unit="page" from="118" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A robust and verifiable cryptographically secure election scheme</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="372" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Proofs of Partial Knowledge and Simplified Design of Witness Hiding Protocols</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Berry</forename><surname>Schoenmakers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Yvo</forename><surname>Desmedt</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">839</biblScope>
			<biblScope unit="page" from="174" to="187" />
			<date type="published" when="1994">1994</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A generalisation, a simplification and some applications of paillier&apos;s probabilistic public-key system</title>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mats</forename><surname>Jurik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Kwangjo</forename><surname>Kim</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1992</biblScope>
			<biblScope unit="page" from="119" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Practical threshold rsa signatures without a trusted dealer</title>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maciej</forename><surname>Koprowski</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="152" to="165" />
		</imprint>
	</monogr>
	<note>In Pfitzmann [25</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">How to prove yourself. practical solutions to identification and signature problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Andrew</forename><forename type="middle">M</forename><surname>Odlyzko</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">263</biblScope>
			<biblScope unit="page" from="186" to="189" />
			<date type="published" when="1987">1987</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Sharing decryption in the context of voting or lotteries</title>
		<author>
			<persName><forename type="first">Pierre-Alain</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Poupard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Yair</forename><surname>Frankel</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1962</biblScope>
			<biblScope unit="page" from="90" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A practical zero-knowledge protocol fitted to security microprocessor minimizing both transmission and memory</title>
		<author>
			<persName><forename type="first">Louis</forename><forename type="middle">C</forename><surname>Guillou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Jacques</forename><surname>Quisquater</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Günther</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">330</biblScope>
			<biblScope unit="page" from="123" to="128" />
			<date type="published" when="1988">1988</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Millimix: Mixing in small batches</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>Jakobsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</author>
		<idno>99-33</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Center for Discrete Mathematics &amp; Theoretical Computer Science (DIMACS)</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Making mix nets robust for electronic voting by randomized partial checking</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>Jakobsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronald</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<editor>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</editor>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="339" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Election Administration in the United States</title>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">P</forename><surname>Harris</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1934">1934</date>
			<publisher>Brookings Institute Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Cryptographic counters and applications to electronic voting</title>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="78" to="92" />
		</imprint>
	</monogr>
	<note>In Pfitzmann [25</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Punchscan: Introduction and System Definition of a High-Integrity Election System</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Carback</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Sherman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IAVoSS Workshop On Trustworthy Elections (WOTE&apos;06)</title>
		<editor>
			<persName><forename type="first">Peter</forename><forename type="middle">A</forename><surname>Ryan</surname></persName>
		</editor>
		<meeting>the IAVoSS Workshop On Trustworthy Elections (WOTE&apos;06)<address><addrLine>Cambridge, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-06">June 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The vector-ballot e-voting approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3110</biblScope>
			<biblScope unit="page" from="72" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On the composition of authenticated byzantine agreement</title>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anna</forename><surname>Lysyanskaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="514" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A verifiable secret shuffle and its application to e-voting</title>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Neff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="116" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems based on composite degree residuosity classes</title>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Paillier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Jacques</forename><surname>Stern</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1592</biblScope>
			<biblScope unit="page" from="223" to="238" />
			<date type="published" when="1999">1999</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2001, International Conference on the Theory and Application of Cryptographic Techniques</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Birgit</forename><surname>Pfitzmann</surname></persName>
		</editor>
		<meeting><address><addrLine>Innsbruck, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">May 6-10, 2001. 2001</date>
			<biblScope unit="volume">2045</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Secrecy, authentication, and public key systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ralph</surname></persName>
		</author>
		<author>
			<persName><surname>Merkle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Arizona Ballot Could Become Lottery Ticket</title>
		<author>
			<persName><forename type="first">Randal</forename><forename type="middle">C</forename><surname>Archibold</surname></persName>
		</author>
		<ptr target="http://www.nytimes.com/2006/07/17/us/17voter" />
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
		</imprint>
	</monogr>
	<note>html?ex=1310788800&amp;en=9626060428eeb1ed&amp;ei= 5088&amp;partner=rssnyt&amp;emc=rss</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Voting technologies and trust</title>
		<author>
			<persName><forename type="first">B</forename><surname>Randell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Y A</forename><surname>Ryan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>IEEE Security &amp; Privacy</publisher>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Prêt à voter with re-encryption mixes</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Y A</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S A</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESORICS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">N Win Ballots To Debut In November</title>
		<ptr target="http://www.theonion.com/content/node/50640" />
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">PDF-417</title>
		<ptr target="http://www.mecsw.com/specs/pdf417.html" />
	</analytic>
	<monogr>
		<title level="m">The Barcode Software Center</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<ptr target="http://en.wikipedia.org/wiki/2Dbarcode" />
		<title level="m">Wikipedia</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
