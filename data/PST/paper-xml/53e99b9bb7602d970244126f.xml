<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Receiver-driven Bandwidth Adaptation for Light-weight Sessions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Elan</forename><surname>Amir</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Steven</forename><surname>Mccanne</surname></persName>
							<email>mccanne@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Randy</forename><surname>Katz</surname></persName>
							<email>randyg@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Receiver-driven Bandwidth Adaptation for Light-weight Sessions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">57E67F1A4B6E67D717716F2E0D8A2A52</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Current Internet multicast conferencing tools treat all sources with equal importance in that they either statically allocate a fixed bandwidth to each source in a session, or they automatically adapt each source's transmission rate independently of all other sources. But not all sources are of equal interest to all receivers. We believe that to effectively support human to human communication, this disparity in receiver interest should be reflected in the rate-adaptation process. To this end, we propose a protocol called "SCUBA" that enables media sources to intelligently account for receiver interest in their rate-adjustment algorithms. SCUBA is orthogonal to and complements existing rate-adaptation schemes and can interoperate with either sender-or receiver-directed control systems. To scale the SCUBA protocol with multicast session size, we decouple the receiver-feedback process from the session size through sampling. This approach introduces a "tunable" tradeoff between convergence time and sampling accuracy that for large sessions is solely dependent on the control traffic bandwidth. In addition to its applicability in video conferencing, our control scheme can be combined with media transcoders to intelligently manage a bottleneck link at a well-known and fixed location in the network. We implemented SCUBA within our video conferencing tool vic and our media gateway rtpgw and feedback from their preliminary deployment indicates that the efficacy of the overall multimedia communication system has been greatly enhanced.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Over the last several years, IP Multicast has been incrementally deployed in the Internet by building a virtual network, embedded in the unicast Internet, called the Multicast Backbone or "MBone". In parallel with the deployment of this Copyright c 1997 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that new copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. new multicast network, the MBone research community developed a number of applications for multimedia conferencing <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b11">12]</ref> that each exploit the simple, efficient, and elegant IP multicast service model and its underlying routing mechanism. These tools, collectively known as the "MBone tools," encapsulate real-time, digital media streams into packets using the Real-time Transport Protocol (RTP) and multicast these packets on the network by simply sending them to a multicast group address. Receivers interested in a particular transmission simply "tune in" by subscribing to the multicast group in question. This loosely coupled, light-weight, real-time multimedia communication model is known as the Light-weight Sessions architecture <ref type="bibr" target="#b10">[11]</ref>.</p><p>Although the MBone tools can be used for a variety of communication styles (e.g., point-to-point internet phone calls, small group design collaborations or research meetings, or seminar distributionto large groups with tightly coupled feedback from the remote audience), a non-interactive, passive style of communication has emerged as the dominant model for MBone sessions. Here a single source "broadcasts" a signal to the MBone in a one-to-many distribution where interaction or feedback from the session participants rarely, if ever, occurs. For example, the regular, ongoing MBone broadcasts of university seminars, conference talks, and the NASA shuttle missions almost never entail multimedia flows from any but the primary source. While this style of transmission is adequate for much of the MBone content, it does not meet the requirements of close-knit collaboration, where the focus of interest may shift rapidly from site to site as the discussion moves about the distributed conference.</p><p>We believe this phenomenon -the rarity of large-scale interactive MBone sessions -is due not to the inherent nature of the MBone and the audio/video conferencing tools, but instead results from the lack of adequate tools and control protocols to make tightly knit collaborations effective across the wide area. In this paper, we focus on one particularly critical barrier to richer collaborations: because session bandwidth is currently allocated in a fixed and inflexible fashion, and because users must manually configure, enable, and disable transmission of their video signals, collaborations using the MBone tools tend to be comprised of a small number of video streams running at a constant transmission rate (typically the full amount of advertised session bandwidth). This is exactly the wrong model for effective human-to-human communication -people interact by shifting their focus from individual to individual not by simulta-neously listening to and looking at a large number of other individuals. We believe that applications should reflect this model by automatically and dynamically shifting the allocation of bandwidth among session participants as the focus in a distributed conference moves about. This dynamic model not only supports effective collaboration, but it also saves network resources since every source need not generate and transmit a continuous video stream.</p><p>In essence, we propose that media sources adapt their transmission rates to meet the collective preferences of the receivers in a multicast session. But this style of adaptation is only one piece of the rate adaptation problem; another important goal of adaptation is to accommodate and avoid network congestion by controlling the aggregate rate of traffic injected into the network across all senders <ref type="foot" target="#foot_0">1</ref> . While several solutions for rate-adaptive audio/video have been proposed <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b23">24]</ref>, none explicitly account for receiver interest in the adaptation process. In fact, existing algorithms adjust the rate of each media source independently and model the impact of competing flows on a given flow's control algorithm simply as background measurement noise.</p><p>We claim that these existing adaptation schemes can be greatly improved by augmenting them with receiver feedback to constrain the media adaptation process. To this end, we decompose the media rate control process as two complementary and orthogonal mechanisms:</p><p>(a) the core adaptation process that adjusts the media delivery rate at each source, and (b) the receiver feedback protocol that disseminates receiver interest throughout the session to constrain the adaptation process.</p><p>A number of existing schemes address part (a) and each approach can be further classified as either sender-or receiverbased. Sender-based schemes like those in ivs <ref type="bibr" target="#b2">[3]</ref> and NeVit <ref type="bibr" target="#b3">[4]</ref> adjust the rate of a source using explicit receiver feedback, while receiver-based schemes like Receiver-driven Layered Multicast (RLM) <ref type="bibr" target="#b16">[17]</ref>, Destination Set Grouping <ref type="bibr" target="#b4">[5]</ref>, and Thin Streams <ref type="bibr" target="#b23">[24]</ref>, tune the delivery rate at each receiver individually. In this latter case, each receiver tunes its inbound reception rate by adjusting its "level of subscription" to a set of hierarchical signal layers that are striped across multiple multicast groups.</p><p>Although the research community has proposed a wide variety of rate-adaptation mechanisms, to our knowledge, no scheme for reflecting receiver interest has yet been proposed, and thus only part (a) of our two part problem has been solved. To address part (b), we have developed a scalable, light-weight, and tunable feedback protocol that reflects receiver interest back to the media sources. We deem the combination of rate-adaptation with receiver interest "intelligent adaptation" and we call our overall scheme Scalable ConsensUs-based Bandwidth Allocation or SCUBA because, roughly speaking, it employs receiver "consensus" to allocate session bandwidth among sources.</p><p>We created two variants of SCUBA -a "flat delivery" variant to complement sender-based adaptation and a "layered delivery" variant to complement receiver-based adaptation. In the flat delivery model, we use receiver feedback to constrain the rate chosen by the sender-based adaptation algorithm, while in the layered delivery model, we use the feedback to control the manner in which source signal layers are mapped onto network channels. Since the layers in a hierarchical distribution are ordered according to their relative importance, we can prioritize the ensemble of sources by controlling where each source falls within the hierarchy. In both the flat and layered delivery models, the feedback signal is identical and thus a single protocol can be shared across the two schemes. Even in the simple case where applications do not adapt (as is commonly the case for MBone broadcasts), SCUBA is still useful -its flat-delivery variant will effectively manage the session's fixed bandwidth by dynamically adjusting each source's rate to reflect receiver interest.</p><p>One of the key advantages of receiver-based multicast over its sender-based counterpart is that the burden of adaptation is moved from the source to the receivers thus enhancing the scalability of the system. One could argue that we could apply this same technique to the receiver-interest problem and eliminate SCUBA altogether. That is, receivers could explicitly tell the network which sources they are interested in (via multiple multicast groups or source-based prunes <ref type="foot" target="#foot_1">2</ref> ) and the network would automatically eliminate unwanted flows from the corresponding regions of the network. If no receiver expressed interest in a given source, the flow would be pruned back all the way to the originating host. While simple and elegant, this approach suffers from two drawbacks. First, the level of interest must be binary (i.e., a receiver must say either they want a source at full quality or not at all). And second, the scheme would share bandwidth inefficiently because it could not account for the constraints of shared paths. SCUBA instead enables sources to share bandwidth intelligently because the receivers convey their interest back to the source and thus effectively agree upon the best way to share the limited bottleneck capacities. We therefore believe a protocol like SCUBA is a necessary and important mechanism for rate-adaptive multimedia applications.</p><p>The rest of this paper describes SCUBA in detail, presents analysis to show that the protocol is viable and scalable, and demonstrates the utility of SCUBA in the context of several real applications. In the next section, we introduce and describe the basic operation of the SCUBA protocol. We then analyze the scalability of SCUBA and, in particular, derive confidence bounds on the algorithm's convergence time. Next we describe the deployment of SCUBA in the context of several applications. Finally, we summarize the status of SCUBA, present our plans for future work, and conclude. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The SCUBA Protocol</head><p>The basic premise of SCUBA is to reflect receiver interest back to the sources in a multicast session using a scalable control protocol. Figures <ref type="figure">1</ref> and<ref type="figure">2</ref> illustrate the core problem and its high-level solution. In current MBone sessions, bandwidth is allocated in a fixed fashion as shown in Figure <ref type="figure">1</ref>. Each sender transmits at some fixed rate, where the rates are chosen either manually or through sender-based adaptation. In either case, an equal amount of bandwidth is typically allocated to each source. Clearly, this outcome is undesirable if the sources are not equally important across all the receivers. But, by integrating receiver feedback into the adaptation process, we can weight each source's transmission rate in proportion to receiver interest. This approach is illustrated in Figure <ref type="figure">2</ref>, where receivers generate feedback that controls each source's sending rate. In this case, source S 0 transmits at a higher rate than source S 1 because more receivers express interest in receiving the S 0 flow. Likewise, because there is no interest in source S 2 , its transmission is disabled entirely.</p><p>However, in a large multicast session composed of heterogeneous receivers with different capabilities, configurations, and preferences, how can we determine a single bandwidth partition that simultaneously satisfies all receivers? As above, one receiver might deem a source S 0 most important while another prefers source S 1 . In light of conflicting feedback like this, we adopt a simple solution: participants reach consensus through voting. If half of the receivers wish to view source A and half wish to view source B, then a reasonable policy is to partition the available session bandwidth equally across the two sources. Now the problem becomes how to poll the receivers, assess the vote, and convey the outcome to each individual source.</p><p>Unfortunately, receivers cannot immediately generate notification messages when there is a state change or event in the session that would cause a shift in focus since uncontrolled control traffic like this could cause large, transient traffic loads. Instead, we scale back the rate at which receivers vote based on the multicast session size, much as the RTP <ref type="bibr" target="#b19">[20]</ref> control protocol, RTCP, adjusts the rate of its control messages to maintain a constant control traffic load independent of session size. However, a lower messaging rate increases the response time and circumvents our fundamental goal of supporting effective human-to-human interaction (i.e., because slow convergence will prevent users from shifting their focus on a natural human time scale).</p><p>To alleviate this problem, we model SCUBA on the "exit poll" principle. In a large vote we can very accurately and with high confidence predict the outcome from only a small (unbiased) sample of the population. In SCUBA, therefore, we derive the source bandwidth partition from a relatively small sample of the receiver population.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Feedback Algorithm</head><p>To conduct the distributed polling process, each receiver associates a weight with every active media source. Qualitatively, the weights define the relative priorities of each source with respect to a given receiver. These weights might be explicitly specified by the user, but more likely (and more naturally), they would be inferred through the user-interface (e.g., when the user manipulates the application to display a given source, the application would automatically instruct SCUBA to give maximum weight to that source).</p><p>Each receiver periodically advertises a source weight report, which is simply a vector of sources and their corresponding weights with respect to that receiver. Report intervals are dynamically sized to limit the control bandwidth to a fixed percentage of the session bandwidth. This scaling mechanism is employed by several announce/listen control protocols <ref type="bibr" target="#b17">[18]</ref>, including RTCP control traffic in RTP, Scalable Reliable Multicast (SRM) <ref type="bibr" target="#b6">[7]</ref> session messages, and the Session Announcement Protocol (SAP) <ref type="bibr" target="#b8">[9]</ref>. We analyze the scalability of the announce/listen metaphor with respect to SCUBA in Section 3.</p><p>As each receiver announces its source weight report by multicasting it to the session, each source listens for these reports, collects them up, and combines them into an aggregate metric, which we call the average source weight. Ideally, this metric would be the arithmetic mean across all reported values for that source, but in practice, we can only approximate the exact mean because maintaining a globally consistent view of every receiver's preference for every source would entail costly if not outright unrealistic overhead. Consequently, we approximate the average source weight as the mean of a sample of reported values taken from the last M reports received by the source. Let S 0 : : :S N?1 be the set of senders, and R 0 : : :R M?1 be the set of receivers. The average source weight for S k , or w k , is then computed as follows:</p><formula xml:id="formula_0">w k = 1 M M?1 X i=0</formula><p>w k;i P N?1 j=0 w j;i where M is the size of the sample of reporting receivers, w j;i is the weight for source S j reported by receiver R i , and N is the number of sources weighted in each report.</p><p>To simplify the calculation and reduce the amount of state maintained at the source, we constrain the sum of weights in a report to be 1, i.e.,</p><formula xml:id="formula_1">N?1 X j=0 w j;i = 1 8i</formula><p>Now the expression for w k is simply:</p><formula xml:id="formula_2">w k = 1 M M?1 X i=0 w k;i</formula><p>To enhance SCUBA's robustness, we deliberately designed the protocol using only soft state <ref type="bibr" target="#b5">[6]</ref>. Sources and receivers can join and leave the session at will without impacting other session members. None of the state maintained at any source alone is critical to the correct execution of the algorithm since all state eventually times out and is refreshed by receiver reports. Hence, failure recovery is built into the protocol; we need no further mechanism to handle network partitions, host failures, and so forth. Finally, SCUBA control messages are idempotent -each message supersedes all previously sent messages -further enhancing the protocol's scalability and its resilience to packet loss.</p><p>Not only is the SCUBA protocol robust and scalable, but it is also quite simple. The algorithm run at each source can be implemented in just a few lines of code. The following pseudo-code implements the weight calculation algorithm: The first stage here computes a weight for each reported source, including the local source. In the second stage, the rate controller is invoked to carry out the consequent action. While the method of computing the source weight is identical for both the flat and layered delivery models, the ratecontrol action in the second stage is not. In the following two subsections, we detail how the average source weight or weights are translated into the sender's rate-control decision in each of the two delivery models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Flat Delivery</head><p>In the flat delivery model, all sources transmit their media over a single network channel that has a uniform aggregate rate. We assume either that the multicast session has a fixed bandwidth allocation or that a sender-based rate-adaptation algorithm computes a rate limit for a given source. In either case, we call this overall bandwidth limit the session bandwidth.</p><p>The flat delivery adjustment decision maps the transmission weight directly to the source transmission bandwidth, i.e., if B k is the transmission rate for source S k , then we set</p><formula xml:id="formula_3">B k = w k B</formula><p>where B is the session bandwidth, and w k is the average source weight for S k .</p><p>More generally, the mechanism that maps the receiver interest vector into a source-rate control decision is arbitrary and can be customized for the application or environment at hand. Having recognized this, we adopt the following rule (assumed for the remainder of the paper): 95% of the session bandwidth is allocated across sources that each have at least one interested receiver (i.e., those whose average weight is non-zero) while the remaining 5% is equally apportioned over the remaining sources (i.e., those whose average weight is zero). As a result, each active source multicasts its signal continuously, though perhaps at a very low rate. Each receiver can then build a thumbnail display of all the active sources, thereby enhancing the "sense of presence" of a multimedia collaboration. The following pseudo-code segment implements this policy: To further illustrate the flat delivery variant of SCUBA, we present the following example. Let S 0 and S 1 be senders and let R 0 ; R 1 and R 2 be receivers. Assume that at a certain time, the source weights of fS 0 ; S 1 g advertised by each receiver are: R 0 : f0:8; 0:2g R 1 : f0:8; 0:2g R 2 : f0:5; 0:5g Upon receipt of these reports (for simplicity we assume the sample set includes all three receivers), the average source weights computed by S 0 and S 1 become 0.7 and 0.3, respectively. Assuming the session bandwidth, B, is 128 kb/s, proportional bandwidth allocation results in S 0 transmitting at 128 0.95 0.7 = 85.12 kb/s and S 1 at 36.48 kb/s.</p><p>To better illustrate the dynamics of this distributed algorithm, we implemented it in the ns network simulator <ref type="bibr" target="#b14">[15]</ref> and ran a simple experiment consisting of four sources and three receivers across a single bottleneck link. All sources were placed on one side of the link while the receivers Figure <ref type="figure" target="#fig_3">3</ref> shows the resulting sample paths. The sources join the session at times 1.4, 1.7, 2.0 and 2.3, respectively. Before time 3, no receivers report interest, and thus the sources equally share the 5% reserve. Then, at times 3.0, 3.2, and 3.3, receivers R 0 , R 2 , and R 3 each respectively announce interest in source S 1 . In response, S 1 transmits at the full 95% allocation (i.e., 380 kb/s). Finally, at time 3.4, R 2 shifts its interest from S 1 to S 3 and from that point on S 1 and S 3 share the 95% allocation in proper proportion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Layered Delivery</head><p>Although SCUBA and sender-based rate adaptation work in concert to effectively incorporate receiver interest into the adaptation process, the sender-based approach is fundamentally limited because it cannot accommodate receiver heterogeneity. More precisely, a particular source's data rate is the same at all receivers, but in a session with heterogeneous qualities of receiver connectivity, congestion-free operation requires the source to set its bandwidth to that of the most constrained link. Running each source at the rate of the slowest link is clearly undesirable and prevents well-connected receivers from fully exploiting their available bandwidth.</p><p>This limitation can be overcome with a layered transmission scheme <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22]</ref>. In this model each source generates a layered media stream that is striped across multiple network channels. The layers are typically cumulative, i.e., if a receiver wishes to decode layer n, it must also receive layer 1 through layer n ? 1, and each additional layer enhances the quality of the reconstructed signal. Thus, to maximize quality, a receiver subscribes to as many network channels as is possible without congesting the network. One approach, known as Receiver-driven Layered Multicast (RLM), is detailed in <ref type="bibr" target="#b16">[17]</ref>.</p><p>In <ref type="bibr" target="#b16">[17]</ref>, each source stripes its data in the most straightforward manner possible -a signal layer k is mapped to the corresponding network layer k as depicted in Figure <ref type="figure" target="#fig_4">4</ref>.</p><p>But this arrangement treats each source equally; in SCUBA, we want to distinguish more important sources from less important ones and reflect this into the transmission algorithm. Fortunately, we can achieve this goal with a novel assignment of signal layers to network channels based on the source weights computed by SCUBA. Given a weight, each source determines its signal layer mapping, i.e., the assignment of each of its signal layers to the corresponding network channel. The source then transmits each of its signal layers on the network channel defined by the mapping. ping that corresponds to a prioritizationof source S 1 over S 0 , while the right-hand configuration corresponds to a prioritization of S 0 over S 1 . Thus, if SCUBA control messages indicate that source S 1 has a larger average weight (i.e., higher priority) over source S 0 , then the layer mapping on the left would be collectively enforced by the sources. Likewise, in the reverse case, the right-hand configuration would be automatically selected.</p><p>We can further illustrate the natural fit between SCUBA and receiver-driven bandwidth adaptation by considering the process whereby an individual receiver incrementally adds network channels to its overall subscription. Suppose a receiver in the context of Figure <ref type="figure" target="#fig_5">5</ref> particular stream is guaranteed to originate from the session's highest priority source, in this case, S 1 . As the receiver subsequently increases its channel subscription, it not only increases the quality of its current flows, but also receives additional sources in priority order. Thus, when the receiver increases its subscription to two network channels, it additionally receives the low quality layer of source S 1 . Upon adding the third channel, it receives equivalent qualities of both sources. The fourth channel then increases the quality of the high priority stream, S 1 . In this way we complement a raw bandwidth adaptation mechanism like RLM with a mechanism that explicitly accounts for the relative importance of media flows across the session. We now formalize the algorithm for determining the signal layer mappings from the set of average weights. In addition to the notation defined earlier, we define the following quantities: Let R j be the transmission rate for signal layer j. Note that we assume that the rate hierarchies induced by all the media sources are homogeneous and further that each layer generates a constant bit-rate flow. Modifying our algorithm to account for heterogeneous and dynamic sources is a topic of future research.</p><p>Let C be the total number of network channels available for transmission and let L k be the bandwidth limit on the k'th network channel. We assume that:</p><formula xml:id="formula_4">C?1 X k=0 L k = B</formula><p>Let j;n be the network channel assigned to signal layer n at source S j .</p><p>Our notation is summarized in Table <ref type="table" target="#tab_0">1</ref>.</p><p>The goal of the algorithm is to compute j;n -i.e., to map signal layers onto network channels -according to the SCUBA weights (w 1 : : :w N ) while adhering to the bit-rate constraints (L 1 : : :L C ). In addition, the algorithm should have the property that a network channel number assigned to layer k for some source is less than or equal to any channel k 0</p><p>(1)</p><formula xml:id="formula_5">while (k &lt; N) f<label>(2)</label></formula><p>ŵk w k</p><p>(3)</p><formula xml:id="formula_6">t k 0 (4) Lk L k (5) k k + 1<label>(6) g (7)</label></formula><p>while (9k s.t. ŵk 6 = 0) f</p><p>l arg max k f ŵk g N?1 k=0</p><p>c l;tl?1</p><formula xml:id="formula_9">(10) r R tl (11) if (r &gt; ŵl B or t l M) f<label>(12)</label></formula><p>ŵl 0 <ref type="bibr" target="#b12">(13)</ref> gelse f</p><p>while (c &lt; C and r Lc ) f (15) c c + 1</p><formula xml:id="formula_11">(16) g (17) if (c &lt; C) f<label>(18)</label></formula><p>l;tl c</p><formula xml:id="formula_12">t l t l + 1<label>(19)</label></formula><p>ŵl ŵl ? r B</p><p>Lc Lc ? r</p><p>gelse f</p><p>ŵk 0 Figure <ref type="figure">6</ref>: Signal Layer Mapping Algorithm assigned to a layer k of any other source with equal or lower priority. In summary, we impose the following constraints on our algorithm:</p><p>1. The network channel limits are observed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>No source S k transmits more than its total share, w k B.</p><p>3. w k w j ) k;n j;n 8n</p><p>One algorithm that obeys these constraints is given in Figure <ref type="bibr" target="#b5">6</ref>. We assume that all values for j;n are initially unde- fined and that a reference to an undefined value (line 10) is interpreted as 0 (including negative index values). t k is a "temporary variable" that represents the next unprocessed signal layer of source S k . Upon completion, j;n contains a feasible layer mapping. A proof that our algorithm adheres to the stated constraints is given in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Scaling Analysis</head><p>Any multicast protocol that makes decisions at a source on behalf of all the receivers in the network is fundamentally prone to scaling problems. There is simply no scalable mechanism to keep a tightly consistent view of every receiver in the network at each source. We explicitly address this scaling problem in SCUBA by sacrificing absolute consistency in favor of scalability through the use of sampling.</p><p>In this section, we examine this tradeoff in detail, outline the parameters that we can adjust to tune SCUBA's scalability, and identify the fundamental limitations of our scheme. There are two principal protocol parameters that limit the scalability of SCUBA with respect to session size: the control message size, and the expected source weight convergence time.</p><p>The size of each control message depends on the number of reported sources. If each receiver includes a weight for every active source, then the report size scales linearly with the number of active sources. In a large session with large numbers of active sources, the resulting message size will quickly exceed a reasonable limit, but we can avoid this problem by simply imposing a fixed limit on the message size. If we limit the number of sources for which each receiver reports to a small constant, then the control packet size is bounded. We claim that this limit is reasonable since human attention can realistically encompass only a handful of sources simultaneously.</p><p>The scalability analysis of the average source weight calculation time is more involved and we present it in the following section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Convergence Time</head><p>As control messages are received, each source incrementally calculates its average source weight and adapts accordingly. But because reports arrive only intermittently (not immediately upon a state change) and because the source uses a fixed sample of the receiver population, some amount of time passes before a (perhaps abrupt) change in receiver interest is reflected back to the sources. For example, the active "speaker" in a conferencing application might change and thus cause each receiver to shift its interest to the new source; only after some amount of time of monitoring SCUBA control messages do the active sources learn of the change in interest. We call this latency the average source weight convergence time (ASCT). More precisely, the ASCT is the expected time between a change in receiver interest and the point at which a source learns an accurate estimate of its average source weight within the session.</p><p>As described in Section 1, the aggregate set of source weights can be viewed as a "consensus" on the allocation of bandwidth to sources across the session. The ASCT -i.e., the time to reach this consensus -should be small. If too large, the computed source weight can become stale. The "usability threshold" is the point where fluctuations in average source weights occur faster than the sources can calculate them. In this case, the weights become invalid even before they have been established. Thus, given that the time-scale of fluctuations in receiver interests is determined by actual users, the average source weights must be computed on the time scale of seconds. In addition, we require that this time bound remain fixed as the number of receivers and/or sources increases.</p><p>To limit the report bandwidth and decouple it from the session size, we allocate a fixed share of the overall session bandwidth for this purpose. But to constrain the bandwidth in this fashion, each receiver's individual messaging rate must decrease in proportion to the session population. Consequently, the convergence time scales linearly with the number of receivers. Assume we have n receivers, and for simplicity assume a fixed report size S. Then, if B is the bandwidth of the control channel, the ASCT, t conv , is given by t conv = nS=B. This O(n) growth implies that in conferences with large numbers of receivers the ASCT will exceed the "usability threshold."</p><p>In order to combat the linear time growth of ASCT, we turn to sampling. Rather than relying upon a control message from every receiver to correctly compute receiver interest, we instead use a sample of receiver reports to determine the average source weight. Specifically, we construct a sample of size N from the last N reports received by the source.</p><p>Our analysis below indicates that a source can compute its average weight within a small confidence interval with high probability using a relatively small number of receiver report samples. This means that a source can calculate its average source weight, within tight probabilistic bounds, in a relatively short amount of time, in particular, within the "usability threshold."</p><p>We now derive the number of sample receiver reports, N, that a source requires to calculate its average weight within error " and confidence 1 ? . " is known as the confidence interval while 1 ? is known as the confidence level where 0 ; " 1. More formally, we want to find the smallest N that satisfies: P(j N ? j &lt; ") 1 ?</p><p>where is the distribution mean, i.e., the actual average source weight, and N is the sample mean, i.e.,</p><formula xml:id="formula_17">N = 1 N N X k=1 X k</formula><p>where X k is a random variable whose value is the weight for this source reported by the k'th sampled receiver report.</p><p>Since the receivers generate reports from independently randomized timers, we can assume that X 1 ; X 2 ; : : :X N are independent and identically distributed (when receiver interest is stationary). A consequence of the Central Limit Theorem is that</p><formula xml:id="formula_18">N = Z 1? =2 " 2<label>(1)</label></formula><p>where is the standard deviation of the weight distribution, and Z p is the p-quantile of the unit normal variate <ref type="bibr" target="#b13">[14]</ref>. Using this result, we can compute the number of samples required to establish the desired confidence level for a given  confidence interval. Equation <ref type="formula" target="#formula_18">1</ref>shows that for given confidence bounds the number of samples is a linear function of the variance of the weight distribution which does not depend on the size of the sample space. This is a key result: we have decoupled the convergence time of the algorithm from the session size and thus SCUBA can scale to arbitrarily large sessions. Moreover, we can fine tune the accuracy of the sample mean by trading off convergence time -larger sample sizes are more accurate but converge more slowly, while small sample sizes converge quickly by sacrificing accuracy.</p><p>Figure <ref type="figure" target="#fig_8">7</ref>(a) shows a plot of the number of samples required to determine the average weight versus the confidence interval, ", for the highest possible variance in a [0,1] distribution 2 = 0:25 which occurs in a strictly bimodal f0,1gvalued distribution. The plot shows a family of curves, each of which corresponds to a different confidence level, varying from 0.9 to 0.99. As a particular example, Figure <ref type="figure" target="#fig_8">7(b)</ref> shows the number of samples required to determine the average weight for a confidence interval of 7%, i.e., " = 0:07.</p><p>Once again, each line in the figure shows the number of samples required for different confidence intervals 1? ranging from 0.9 to 0.99.</p><p>To convert these values to an actual convergence time, we must assume an average report packet size. If we assume that each receiver source weight report is 6 bytes (4 bytes for the source id + 2 bytes for the weight) and constrain the number of sources per report to some number, say 5, then including the 28 byte UDP header and an 8 byte SCUBA header we get an average report size of 66 bytes.</p><p>The right-hand y-axes in Figures <ref type="figure" target="#fig_8">7(a</ref>) and (b) show the the amount of time needed to accumulate the corresponding number of samples assuming a session bandwidth of 128 kb/s with 5% of this bandwidth allocated to the SCUBA control traffic.</p><p>We see that for given confidence bounds the amount of time required by a source to calculate its average weight varies widely depending on several factors, most significantly the variance of the weight distribution and amount of control traffic. In the figures we assumed a relatively conservative session bandwidth and within it a relatively conservative allocation to report messages. Increasing the control  trary "usability threshold" (10 seconds) that we would like to achieve. Thus, according to the desired confidence bounds, we must choose an appropriate control bandwidth. Comparing these results to Figures <ref type="figure" target="#fig_8">7(a</ref>) and (b) we see that allocating 20-25 kb/s to control traffic suffices for very tight confidence bounds on the average weight convergence within the 10 second threshold. These results imply that it is advantageous to modulate the control bandwidth based on event changes to speed up convergence and then slow down the report announcements when the system is idle. For example, a receiver could increase the control bandwidth for 15 seconds after it changes its source weight report allowing this information to be more quickly assimilated by the sources, thereby lowering the convergence time while maintaining an acceptable level of control traffic.</p><p>An alternative interpretation of this bandwidth/delay tradeoff is that the delay represents the width of a moving average filter applied to the incoming samples that is required to achieve the desired confidence bounds. In this interpretation, the window size represents a design tradeoff. As the above analysis has shown, setting the window too small reduces our confidence bounds. On the other hand too large a window causes samples to become widely separated in time decreasing the accuracy of the source weight estimation.</p><p>In summary, our analysis shows that the use of report sampling combats the linear growth of the ASCT. The set of feasible confidence bounds that conform to our "usability threshold" of 10 seconds are independent of the session size but are directly dependent on the amount of control traffic that is allocated to the SCUBA reports. Fortunately, we found that very tight confidence bounds are attained with only 20-25kb/s of control traffic. While this level of control traffic is acceptable in some environments, it is unrealistic for environments like the current MBone where the entire session bandwidth often comprises only 128 kb/s. A more reasonable control bandwidth would be 5 kb/s or so, and in this case, SCUBA is limited to session sizes on the order of 200 to 250 receivers, which in practice, accounts for almost all of the current MBone content. But to scale beyond this, we must resort to an alternative mechanism. Section 5 describes one promising scheme, currently under development, that utilizes hierarchy to enhance SCUBA's scalability. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Applications</head><p>Though SCUBA defines a generic mechanism that complements existing rate-adaptation protocols, our original design goal was much more application specific. We initially set out to develop a robust, distributed protocol for the control of application-level media gateways <ref type="bibr" target="#b1">[2]</ref>, but as the protocol was refined and tuned for this specific application, it became apparent that SCUBA constituted a robust and useful building block in its own right.</p><p>This section details three applications that show how sideinformation generated by SCUBA can improve their perfor-mance. We first describe the integration of SCUBA in our video conferencing tool vic <ref type="bibr" target="#b15">[16]</ref>. We then detail the application of SCUBA to media gateway control. Finally, we show how a floor control application can leverage SCUBA in its design as well as how SCUBA can exploit floor control knowledge to determine its weight allocation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Video Conferencing</head><p>One important application of SCUBA is to control a simple video conference. In this case, receivers can determine the source weights required by SCUBA via the user interface. In our implementation embedded in vic, we infer the set of sources that the user is interested in from the disposition of the user interface, and weight them accordingly with some simple heuristics.</p><p>In addition to the disposition of the vic user interface, SCUBA can utilize cues from cross-media activity. For example, video windows can be configured to automatically switch to the remote user that is currently active on the audio channel. Thus, SCUBA can utilize activity on the audio channel to configure its receiver-interest report on the video channel. Similarly, pen input to a shared whiteboard tool can be used to raise priority of media streams originating from the same source. Some multimedia conferencing tools, e.g., vic <ref type="bibr" target="#b15">[16]</ref> and vat <ref type="bibr" target="#b12">[13]</ref>, use a common control channel (called a "coordination bus") to exchange cross-media control information. For example, when vat receives the first packet of a "talk spurt" it announces the event over the coordination bus. Any tool listening to the bus can then react accordingly. For example, vic could use the audio channel activity notification to allocate more computational resources to decoding and displaying the corresponding participant's video stream as opposed to those from other inactive participants.</p><p>While receivers can utilize cross-media cues to control their behavior, the coordination bus model does not directly extend across the network from receivers to sources. Not only do we want the receiver to allocate more computational resources to decoding the active participant's media, but we also want those media to be transmitted at higher quality. Rather than build an ad hoc protocol for this purpose, SCUBA provides all the requisite functionality. In effect, SCUBA provides a level of indirection that captures cross-media events at the receivers and reflects the desired dependencies back to the sources via receiver interest reports. Figure <ref type="figure" target="#fig_11">9</ref> illustrates an example sequence of events between a source and a receiver, each of which has an audio and video component. When the audio receiver detects data from the source, it notifies the video receiver via a coordination bus message. In response, the video receiver expresses interest in that source via SCUBA control messages. In turn, the video source increases its transmission rate precisely as desired. Thus, there is no need to build a special-purpose voiced-switched video network protocol since SCUBA completely subsumes this functionality with a clean and uniform mechanism. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Media Gateway Control</head><p>A common configuration for multimedia conferences entails one or more users participating across a slow, bottleneck link with the primary set of users participating across a higher performance "well connected" region of the network. For example, a user might tap into an MBone conference via ISDN or a high-speed modem; alternatively, multiple receivers might share a low-speed wireless link. Media gateways <ref type="bibr" target="#b1">[2]</ref> are one approach for managing network bandwidth in these environments. In this model, a gateway sits on the "well-connected" portion of the network and manages the bottleneck link by limiting the rate of incoming media streams through transcoding. In earlier work, we designed a gateway "application programming interface" (API) that enables fine-grained control of the rate of transmission on a per-source basis. We are now developing a comprehensive architecture for launching, configuring, and controlling gateways in arbitrary environments, including the constrained-link example mentioned above.</p><p>One of the difficult challenges in realizing our media gateway architecture was the design of the control protocol that runs between the low-bandwidth receivers and a gateway. The receivers must somehow interact with the gateway API to establish the bandwidth allocations across active sources. One obvious approach is to simply centralize the mechanism and force all network agents to rendezvous at a well known location. But this would introduce a central point of failure. A much better approach is to decentralize control through a distributed mechanism like SCUBA.</p><p>Integrating SCUBA with the media gateway architecture is relatively straightforward because each active transcoder embedded in the gateway can be modeled simply as a SCUBA source. From a receiver's point of view, there is no difference between a rate-controlled output on the origi-nal source or a rate-controlled output of a transcoder within a gateway. Therefore, we can run SCUBA locally among the receivers and the transcoders in the media gateways over a managed subset of the session. Again, the SCUBA protocol subsumes the functionality that would otherwise be implemented by a special-purpose protocol for managing the bandwidth of a locally-administered bottleneck link.</p><p>Figure <ref type="figure" target="#fig_12">10</ref> illustrates how SCUBA operates in tandem with a media gateway. Media streams from MBone sources S 0 ; S 1 ; and S 2 are received by the gateway and are transcoded by per-source transcoders T 0 ; T 1 ; and T 2 . Each transcoder performs format and/or rate conversion on the input media stream and transmits the resulting output stream across the bottleneck link where it is received on the other side of the link by the receivers (R 0 ; : : :; R 3 ). The original high-rate streams are not forwarded across the link.</p><p>By running SCUBA between the low bandwidth linked receivers and the gateway, scarce bottleneck bandwidth can be dynamically apportioned in an intelligent manner among the transcoders. In this way SCUBA provides a robust and distributed control mechanism for the gateway free from the vulnerabilities of centralized control.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Floor Control</head><p>Traditionally, floor control protocols orchestrate access to the constituent media channels of a distributed conference. A potential benefit of the exclusivity of channel access is efficient network utilization because only the sources that are "granted the floor" are allowed to transmit media and consume network bandwidth. SCUBA can further enhance existing floor control protocols by providing the mechanism for throttling media sources in response to floor control activity. For example, if the floor control protocol determines that some source has been granted the floor, then all the receivers could simply register interest in that source via SCUBA. As a result, the active source would increase its transmission rate as is desired. This approach obviates the need to intertwine the floor control protocol directly with source's rate adjustment algorithm. In addition, the method by which the floor configuration is mapped onto sending rates is not fixed at each source, but rather can be tuned at each individual receiver.</p><p>Alternatively, a floor control tool might directly control the source's sending rate. For example, once the floor control tool "grants the floor" to a particular source, that source could begin transmitting at the rate appropriate to the "holder of the floor" and all other sources would immediately limit their rate. Once this transition has occurred, the sources continue adjusting their transmission rates according to the SCUBA reports. Since the holder of the floor will in general be the source of interest, SCUBA reports will only confirm what has already occurred in the session: that the floor holder should receive the highest bandwidth share. Thus, through the use of the floor protocol, we have decreased the convergence time by using the floor control directive to "guess" the next bandwidth partition. Between floor control actions, SCUBA could continue to adapt dynamically to fine-grained changes in receiver interest. In short, SCUBA can effectively augment floor control protocols through the integra-tion of receiver interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Status and Future Work</head><p>To demonstrate a proof of concept of our design work, we implemented SCUBA in both our video conferencing tool, vic <ref type="bibr" target="#b15">[16]</ref>, and our our media gateway, rtpgw <ref type="bibr" target="#b1">[2]</ref>. These implementations follow the algorithms detailed in Section 2.2 and illustrated in Figure <ref type="figure" target="#fig_3">3</ref>. In conjunction with our SCUBAenhanced vic, we deployed and controlled these gateways in the manner described in Section 4.2. In future work we plan to extend our vic and rtpgw implementations for layered transmission and RLM <ref type="bibr" target="#b16">[17]</ref> using the signal mapping algorithm detailed in Section 2.3.</p><p>Section 3 detailed the limitations of the sampling approach to calculating the average source weight in low-bandwidth sessions with large numbers of receivers. We are currently developing an alternative approach to sampling that employs a spatial network hierarchical to enhance the scalability of the announce/listen receiver interest protocol. Each level of the hierarchy corresponds to a "report region" and within each region, a representative is elected. The representative aggregates the reports within that region, summarizes the aggregate information into a single report, and forwards that report up the hierarchy. In this way we greatly enhance the scalability of the protocol since the average weight convergence time is approximately proportional to the number of sources in local regions rather than in the entire session.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Summary</head><p>In this paper we presented a novel protocol called SCUBA that complements existing rate-adaptation algorithms with a mechanism for discovering and exploiting receiver interest. As with RTCP and SRM, SCUBA embraces the announce/listen metaphor and uses periodic and robust receiver reports to explicitly rank active sources. When combined with layered transmission, SCUBA enables a source to infer an arrangement of signal layers onto network channels that best suits a heterogeneous set of layered receivers. We formalized a model for mapping signal layers onto network channels and presented an algorithm that satisfies a number of important and natural constraints.</p><p>By exploiting sampling, we overcame the linear growth in the convergence time of a naive version of the distributed SCUBA algorithm. Each source uses sampling to determine its share of the session bandwidth in a reasonable time with a high level of confidence independent of the session size. We pointed out the shortcomings of this approach and are currently developing new versions of the protocol that we believe will surmount these problems.</p><p>Finally, we outlined how SCUBA could be integrated into and exploited by several important applications such as traditional video conferencing, media gateways, and floor control.</p><p>We believe that reflecting receiver interest back to the sources in a multimedia conference is a key mechanism for future collaboration technologies. SCUBA achieves this goal in a light-weight, robust, and scalable manner. By dynamically accounting for receiver interest in the allocation policy, sources can share the available session bandwidth in a way that best reflects the natural model for human-to-human communication.</p><p>1. Lc represents the unused bandwidth available in net- work channel c. Thus, the check in line 15 guarantees that no source will cause the rate limit of a network channel to be exceeded 2. ŵl B represents the portion of the bandwidth share of source S l that has not been utilized by the source. Thus, the decrementing of ŵl in line 21, along with the check in line 12, guarantees that no source will transmit more that its total share, which is w l B.</p><p>3. The algorithm iterates through the average weight list, A, looking for the largest remaining weight, ŵl . Now assume that for the two sources in question S k , and S j , all signal layers 1; : : :; n ? 1 have been mapped to network channels. Next assume that the result of the algorithm's output for layer n is such that k;n &gt; j;n This along with line 9 imply that ŵk &lt; ŵj</p><p>Line 21 of the algorithm implies that in order for (1) to hold the following must also be true:</p><p>w k ? n?1 X i=1 R i B &lt; w l ?</p><p>n?1 X i=1 R i B + w k &lt; w l Finally, the arg max directive in line 9 furnishes us with the bootstrap for the induction in the first iteration which completes the proof of statement 3 of the claim.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Figure 1: Static bandwidth allocation: sources send at a fixed rate and apportion the link bandwidth equally.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>foreach src in active source list f w = 0 foreach rcvr in sample receiver list f w = w + last reported weight(rcvr,src) g avg weights[src] = w/nsamples g update rate controller(avg weights)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>if (avg weight &gt; 0) f share = 0.95 * avg weight g else f share = 0.05 / zero weight src num g tx rate = session bandwidth * share</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Simulation of the flat-delivery variant of SCUBA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Simple Layered Delivery</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Prioritized Layered Delivery Figure 5 illustrates how signal layers are manipulated by SCUBA. The figure shows how two sources each with four signal layers are mapped onto eight possible network channels. The left-hand side of the figure shows a layer map-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>σ</head><label></label><figDesc>Number of Samples (a) Number of samples vs. Confidence interval for 2 = 0.25. (b) Number of samples vs. 2 for " = 0:07.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Number of SCUBA reports required to determine the average weight within given confidence bounds. The time values assume a control traffic bandwidth of 6.4 kb/s which is 5% of a 128 kb/s session bandwidth.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Time to accumulate N samples vs. Control traffic bandwidth</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Cross-media bandwidth allocation using SCUBA. Data and control messages are designated with solid and dashed arrow, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: SCUBA in the "media gateway architecture."</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>(a) has initially subscribed to just one network channel. At this point, that receiver not only receives a stream of adequately low bandwidth, but this Summary of notation.</figDesc><table><row><cell>B</cell><cell>the session bandwidth</cell></row><row><cell></cell><cell>(e.g., as computed by RLM)</cell></row><row><cell cols="2">N S k media source k the number of active sources w k the average weight for S k computed</cell></row><row><cell cols="2">across the session via SCUBA M the number of signal layers R k the bit-rate of signal layer k C number of network channels L k target bandwidth limit for the k'th network channel</cell></row><row><cell cols="2">j;n the network channel assigned to signal layer n at source S j</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We assume the network provides only best effort service and that applications are thus adaptive. Furthermore, we view the development of realtime network services as a complementary optimization: our protocols will work effectively in concert with real-time services if and when they become widely available.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Source-based pruning is not part of the current IP Multicast specification but is included in the next version, IGMP-3, which is under review by the IETF.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>ftp://ftp.ee.lbl.gov/conferencing/wb</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>ftp://ftp.ee.lbl.gov/conferencing/vat</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>http://www-mash.cs.berkeley.edu/ns/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>http://www.inria.fr/rodeo/ivs.html</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgements</head><p>SCUBA was inspired by Jacobson's "video silence suppression" concept, which uses receiver interest to enable and disable video sources <ref type="bibr" target="#b9">[10]</ref>. We are grateful to Hari Balakrishnan and Venkat Padmanabhan for providing constructive comments and lively discussions throughout the writing of this paper. Anindo Banerjea and Tom Henderson provided helpful comments on and corrected oversights in the paper. We thank Deana McCanne for suggesting several improvements to the paper's presentation. A host of people provided constructive criticism on our work when it was first presented at the UCB Daedalus retreat; in particular, we thank Jim Gemmel, Kevin Mills, Srini Seshan, Mark Handley, and Lixia Zhang for their helpful comments. Finally, the anonymous reviewers provided valuable feedback on our work and its presentation.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head><p>We present a proof of correctness of the signal mapping algorithm detailed in Section 2.3. We use the same notation introduced in Section 2.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claim:</head><p>This signal layer mapping meets the following constraints:</p><p>1. The network channel limits are observed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>No source S k transmits more than its total share, w k B. 3. w k w j ) k;n j;n 8n</p><p>Proof: In the proof we refer to line numbers in the algorithm detailed in Figure <ref type="figure">6</ref>.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A layered DCT coder for Internet video</title>
		<author>
			<persName><forename type="first">E</forename><surname>Amir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vetterli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Image Processing</title>
		<imprint>
			<date type="published" when="1996-09">Sept. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An applicationlevel video gateway</title>
		<author>
			<persName><forename type="first">E</forename><surname>Amir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Multimedia &apos;95</title>
		<meeting>ACM Multimedia &apos;95</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995-11">Nov. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Scalable feedback control for multicast video distribution in the Internet</title>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Bolot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Turletti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Wakeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGCOMM &apos;94</title>
		<meeting>SIGCOMM &apos;94<address><addrLine>University College London, London, U.K.</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994-09">Sept. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Dynamic QoS control of multimedia applications based on RTP</title>
		<author>
			<persName><forename type="first">I</forename><surname>Busse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Deffner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schulzrinne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workship on High Speed Networks and Open Distributed Platforms</title>
		<meeting>the First International Workship on High Speed Networks and Open Distributed Platforms<address><addrLine>St. Petersburg, Russia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On the use of destination set grouping to improve fairness in multicast video distribution</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Y</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Ammar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Infocom &apos;96</title>
		<meeting>IEEE Infocom &apos;96<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-03">Mar. 1996</date>
			<biblScope unit="page" from="553" to="560" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The design philosophy of the DARPA Internet protocols</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGCOMM &apos;88</title>
		<meeting>SIGCOMM &apos;88<address><addrLine>Stanford, CA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1988-08">Aug. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A reliable multicast framework for lightweight sessions and application level framing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-G</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGCOMM &apos;95</title>
		<meeting>SIGCOMM &apos;95<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995-09">Sept. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Xerox Palo Alto Research Center</title>
		<author>
			<persName><forename type="first">R</forename><surname>Frederick</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Network Video (nv). Software on-line 3</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">SAP: Session Announcement Protocol. Internet Draft</title>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-11-19">Nov 19, 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<title level="m">DARTNET Planning and Review Meeting</title>
		<imprint>
			<date type="published" when="1991-12">Dec. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">SIGCOMM &apos;94 Tutorial: Multimedia conferencing on the Internet</title>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994-08">Aug. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><surname>Whiteboard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lawrence Berkeley Laboratory. Software on-line</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Visual Audio Tool</title>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lawrence Berkeley Laboratory. Software on-line</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The Art of Computer Systems PerformanceAnalysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>John Wiley &amp; Sons Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The UCB/LBNL Network Simulator</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<imprint/>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note>Software online 6</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">vic: a flexible framework for packet video</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Multimedia &apos;95</title>
		<meeting>ACM Multimedia &apos;95</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995-11">Nov. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Receiver-driven layered multicast</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vetterli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGCOMM &apos;96</title>
		<meeting>SIGCOMM &apos;96<address><addrLine>Stanford, CA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996-08">Aug. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A multicast user directory service for synchronous rendezvous</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Schooler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-09">Sept. 1996</date>
		</imprint>
		<respStmt>
			<orgName>Computer science department, California Institute of Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Voice communication across the Internet: A network voice terminal</title>
		<author>
			<persName><forename type="first">H</forename><surname>Schulzrinne</surname></persName>
		</author>
		<idno>TR 92-50</idno>
		<imprint>
			<date type="published" when="1992-07">July 1992</date>
			<pubPlace>Amherst, Massachusetts</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, University of Massachusetts</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">A Transport Protocol for Real-Time Applications. Internet Engineering Task Force, Audio-Video Transport Working Group</title>
		<author>
			<persName><forename type="first">H</forename><surname>Schulzrinne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Casner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Frederick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ja-Cobson</surname></persName>
		</author>
		<author>
			<persName><surname>Rtp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-11">Nov. 1991</date>
		</imprint>
	</monogr>
	<note>Internet Draft expires 3/1/96</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Multipoint communication by hierarchically encoded data</title>
		<author>
			<persName><forename type="first">N</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Infocom &apos;92</title>
		<meeting>IEEE Infocom &apos;92</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="2107" to="2114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Multi-rate 3-D subband coding of video</title>
		<author>
			<persName><forename type="first">D</forename><surname>Taubman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zakhor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="572" to="588" />
			<date type="published" when="1994-09">Sept. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">INRIA Video Conferencing System (ivs)</title>
		<author>
			<persName><forename type="first">T</forename><surname>Turletti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Recherche en Informatique et an Automatique. Software on-line</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
		</imprint>
	</monogr>
	<note>Institut National de</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Thin streams: An architecture for multicasting layered video</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Workshop on Network and OS Support for Digital Audio and Video</title>
		<meeting>the Seventh International Workshop on Network and OS Support for Digital Audio and Video<address><addrLine>St. Louis, Missouri</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997-05">May 1997</date>
			<biblScope unit="page" from="183" to="192" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
