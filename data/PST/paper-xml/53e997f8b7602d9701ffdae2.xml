<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Frank</forename><surname>Drewes</surname></persName>
							<email>drewes@cs.umu.se</email>
							<affiliation key="aff0">
								<orgName type="department">Institutionen för Datavetenskap</orgName>
								<orgName type="institution">Umeå Universitet</orgName>
								<address>
									<postCode>S-90187</postCode>
									<settlement>Umeå</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Berthold</forename><surname>Hoffmann</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Fachbereich Mathematik/Informatik</orgName>
								<orgName type="institution">Universität Bremen</orgName>
								<address>
									<addrLine>Postfach 33 04 40</addrLine>
									<postCode>D-28334</postCode>
									<settlement>Bremen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Detlef</forename><surname>Plump</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of York</orgName>
								<address>
									<postCode>YO10 5DD</postCode>
									<settlement>York</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C6759F8503835BB8BEA2B653BDBC46FC</idno>
					<idno type="DOI">10.1006/jcss.2001.1790</idno>
					<note type="submission">Received April 3, 2000; revised September 17, 2001</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>hierarchical graphs; graph transformation</term>
					<term>Contents</term>
					<term>0</term>
					<term>Introduction</term>
					<term>1</term>
					<term>Graph transformation</term>
					<term>2</term>
					<term>Hierarchical graphs</term>
					<term>3</term>
					<term>Hierarchical graph transformation</term>
					<term>4</term>
					<term>Hierarchical graph transformation with variables</term>
					<term>5</term>
					<term>Sorting list graphs</term>
					<term>6</term>
					<term>Relating hierarchical to plain graph transformation</term>
					<term>7</term>
					<term>Related work</term>
					<term>8</term>
					<term>Conclusion</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>When graph transformation is used for programming purposes, large graphs should be structured in order to be comprehensible. In this paper, we present an approach for the rule-based transformation of hierarchically structured hypergraphs. In these graphs, distinguished hyperedges contain graphs that can be hierarchical again. Our framework extends the well-known double-pushout approach from flat to hierarchical graphs. In particular, we show how pushouts and pushout complements of hierarchical graphs and graph morphisms can be constructed recursively. Moreover, we make rules more expressive by introducing variables which allow us to copy and remove hierarchical subgraphs in a single rule application.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0.">INTRODUCTION</head><p>The transformation of graphs by rules has been systematically investigated since about 1970 and has been applied in several areas of Computer Science-see the recent handbook volumes <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b39">40]</ref>. Graph transformation has been used, for example, as an efficient computational model for term rewriting systems and functional programming languages <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b33">34]</ref> and for specifying visual languages and generating associated editors <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b30">31]</ref>. Besides specific applications of graph transformation, several programming languages have been developed that are based on graph transformation rules. Examples of such languages are Progres <ref type="bibr" target="#b42">[43]</ref>, Agg <ref type="bibr" target="#b21">[22]</ref>, Gamma <ref type="bibr" target="#b2">[3]</ref>, Grrr <ref type="bibr" target="#b38">[39]</ref>, and Dactl <ref type="bibr" target="#b23">[24]</ref>.</p><p>Programming tasks of a realistic size require large numbers of rules, making it imperative to develop systems from small components that are easy to comprehend. Recently, structuring concepts for systems of graph transformation rules have received some attention. A module concept for graph transformation is proposed in <ref type="bibr" target="#b1">[2]</ref>, for example, and different proposals for module concepts of graph transformation systems are compared with each other in <ref type="bibr" target="#b26">[27]</ref>.</p><p>We believe that it will be necessary to structure not only the sets of rules but also the graphs that are subject to transformation, in order to cope with complex applications. A mechanism for hiding subgraphs-or abstracting from subgraphs-will allow us to visualize large graphs and to make them comprehensible. Moreover, such a structuring mechanism will support the control of rule applications. Graphs with a hierarchical structure have already been used in CASE tools <ref type="bibr" target="#b45">[46]</ref> and in data base languages like Hyperlog <ref type="bibr" target="#b35">[36]</ref>.</p><p>In this paper we introduce hierarchical hypergraphs in which certain hyperedges, called frames, contain hypergraphs that can be hierarchical again, with an arbitrary depth of nesting. We show that the double-pushout approach to graph transformation <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b14">15]</ref> extends smoothly to these hierarchical hypergraphs, by giving recursive constructions for pushouts and pushout complements in the category of hierarchical graphs. Hierarchical transformation rules consist of hierarchical graphs and can be applied at all levels of the hierarchy, where the ''dangling condition'' known from the transformation of flat graphs is adapted in a natural way.</p><p>To the best of our knowledge, this is the first time that one of the existing approaches to graph transformation has been extended by a hierarchy concept for graphs. Our extension lifts basic results on the existence and uniqueness of direct derivations in a natural way to the hierarchical case and is conservative in that on unstructured graphs the approach coincides with the conventional double-pushout approach. <ref type="foot" target="#foot_0">2</ref> This provides some confidence that most of the theory of the doublepushout approach will extend to the new framework in a straightforward way.</p><p>We also introduce rule schemata containing frame variables to make hierarchical graph transformation more expressive for programming purposes-without damaging the theory. These variables can be instantiated with frames containing hierarchical graphs and can be used to copy or remove frames without looking at their contents. In particular, this makes it possible to move a copy of a frame into another frame. Our running example of a list implementation indicates that this concept is useful, as list entries can be entered, deleted, or looked up, regardless of their structure and size.</p><p>Finally, we relate our notion of hierarchical graph transformation to the conventional transformation of flat graphs by introducing a flattening operation. Flattening recursively replaces each frame in a hierarchical graph by its contents, using hyperedge replacement. The result is a flat graph without frames. Under a mild assumption on the transformed graph, every transformation step on hierarchical graphs gives rise to a conventional step on the flattened graphs by using the flattened rule.</p><p>We would like to stress that the strict hierarchical structure of our graphs provides certain advantages over approaches that allow edges between different component graphs, like <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b20">21]</ref>. Edges across the component structure cause complications when it comes to reasoning about programs. In particular, they prevent compositionality of the form that component graphs can be freely replaced with equivalent components. Consider, for example, the equivalence on hierarchical graphs generated by some set of transformation rules. In our hierarchical setting it is no problem to replace some component graph by an equivalent graph: by the way we define hierarchical graph transformation it will be obvious that the resulting overall graph is equivalent to the original graph. In contrast, if there are edges across components, it is not even clear how to replace components.</p><p>The rest of this paper is structured as follows. In the next section, we recall the double-pushout approach to graph transformation. Hierarchical graphs and their morphisms are introduced in Section 2, and some key properties of the category obtained in this way are studied. These results are used in Section 3 to define the notion of hierarchical graph transformation and to prove that it behaves well. We introduce hierarchical graph transformation with variables in Section 4. In Section 5, a nontrivial example (quicksort) illustrates how hierarchical graph transformation can be used for programming. The flattening operation is studied in Section 6. Finally, in Section 7 and Section 8, we discuss some related work and outline directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">GRAPH TRANSFORMATION</head><p>If S is a set, the set of all finite sequences over S, including the empty sequence l, is denoted by S g . The ith element of a sequence s is denoted by s(i), and its length by |s|. If f: S Q T is a function then the canonical extensions of f to the powerset of S and to S g are also denoted by f. The composition g p f of functions f: S Q T and g: T Q U is defined by (g p f)(s)=g(f(s)) for s ¥ S.</p><p>We will deal with directed, edge-labelled hypergraphs in which the label of a hyperedge determines the number of the incident nodes. A label alphabet (or colour alphabet) is a set C such that each l ¥ C comes with a natural number type(l) \ 0. For the rest of this paper, we consider a fixed label alphabet C. In the following, we simply say graph instead of hypergraph and edge instead of hyperedge. We denote by A H the set V H 2 E H of atoms of H. In order to make this a useful notation, we shall always assume without loss of generality that V H and E H are disjoint, for every graph H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark.</head><p>In order to avoid confusion we remark that the hypergraphs used in the short version of this paper <ref type="bibr" target="#b13">[14]</ref> come with an additional component, namely a sequence of distinguished nodes called points. These are useful in connection with hyperedge replacement <ref type="bibr" target="#b12">[13]</ref>, which is employed by the flattening process considered in Section 6. However, as long as one is not interested in flattening, and in particular as far as the basic theory is concerned, points are of no particular value-they just complicate the whole theory in an unnecessary way. This is the reason why they are omitted in this paper until Section 6.</p><p>Example 1.1 (List Graphs). In our running example, we show how lists can be represented as graphs, and how some of their typical operations can be implemented using graph transformation. Two kinds of edges are used to represent lists as graphs: Unary I-edges designate the item graphs stored in the lists; binary L-edges designate the start and end node of a list graph. The latter consist of a chain of nodes connecting the start point with the end point, where a unique item edge is attached to every node in between.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows two list graphs. Nodes are drawn as circles. Edges are drawn as boxes and are connected with their attachment nodes by lines which are ordered counter-clockwise, starting at noon. Plain binary edges are drawn as arrows from their first to their second attachment node (as in simple graphs); their labels do not matter in our examples and hence are omitted. In the item graphs, the arrowheads are omitted, too. For graphs G and H such that </p><formula xml:id="formula_0">A morphism m: G Q H between graphs G and H is a pair (m V , m E ) of mappings m V : V G Q V H and m E : E G Q E H such that for all e ¥ E G , lab H (m E (e))=lab G (e) and att H (m E (e))=m V (att G (e)).</formula><formula xml:id="formula_1">A G 5 A H =", the disjoint union G+H yields the graph (V G 2 V H , E G 2 E H ,</formula><formula xml:id="formula_2">A G 5 A H ="</formula><p>is not satisfied, it is assumed that some implicit renaming of atoms takes place.) A pushout in a category C (for the definition of categories see, e.g., <ref type="bibr" target="#b0">[1]</ref>) is a tuple</p><formula xml:id="formula_3">(m 1 , m 2 , n 1 , n 2 ) of morphisms m i : O Q O i and n i : O i Q OOE with n 1 p m 1 =n 2 p m 2 , such that for all morphisms n - i : O i Q P (i ¥ {1, 2}) with n - 1 p m 1 =n - 2 p m 2 there is a unique morphism n: OOE Q P satisfying n p n 1 =n - 1 and n p n 2 =n - 2 .</formula><p>Depicted as a diagram, this looks as follows:</p><formula xml:id="formula_4">O Ł m 1 O 1 m 2 ‡ n 1 ‡ O 2 Ł n 2 OOE n - 1 ,! n n - 2 P</formula><p>We recall the following well-known facts about pushouts and pushout complements in the category of graphs and graph morphisms (see <ref type="bibr" target="#b14">[15]</ref>). Let m 1 : G Q H 1 and m 2 : G Q H 2 be morphisms. Then there is a graph H and there are morphisms</p><formula xml:id="formula_5">n 1 : H 1 Q H and n 2 : H 2 Q H such that (m 1 , m 2 , n 1 , n 2</formula><p>) is a pushout. Furthermore, H and the n i are determined as follows. Let HOE be the disjoint union of H 1 and H 2 , and let ' be the equivalence relation on A HOE generated by the set of all pairs (m 1 (a), m 2 (a)) such that a ¥ A G . Then H is the graph obtained from HOE by identifying all atoms a, aOE such that a ' aOE (in other words, H is the quotient graph HOE/ '). Moreover, for i ¥ {1, 2} and a ¥ A H i , n i (a)=[a] ' , where [a] ' denotes the equivalence class of a according to '.</p><p>In order to ensure the existence and uniqueness of pushout complements (that is, the existence and uniqueness of m 2 and n 2 if m 1 and n 1 are given), additional conditions must be satisfied. Below, we are only concerned with the case where both of the given morphisms are injective. In this case it is sufficient to assume that the dangling condition is satisfied. Let</p><formula xml:id="formula_6">m 1 : G Q H 1 and n 1 : H 1 Q H be morphisms. Then n 1 is said to satisfy the dangling condition with respect to m 1 if no edge e ¥ E H 0 n 1 (E H 1 ) is attached to a node in n 1 (V H 1 ) 0 n 1 (m 1 (V G )).</formula><p>It is well known that if m 1 and n 1 are injective, then there are m 2 and n 2 such that (m 1 , m 2 , n 1 , n 2 ) is a pushout, if and only if n 1 satisfies the dangling condition with respect to m 1 . Furthermore, if they exist, then m 2 and n 2 are uniquely determined (up to isomorphism). Definition 1.2 (Transformation Rule). A transformation rule (rule, for short) is a pair t: L P I Q R of morphisms l: I Q L and r: I Q R such that l is injective. The hypergraphs L, I, and R are called the left-hand side, interface, and right-hand side of t, respectively.</p><p>Note that the morphism r: I Q R is not required to be injective. This allows us to merge (identify) nodes or edges in transformations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1.3 (Graph Transformation</head><formula xml:id="formula_7">Ll I Ł r R o ‡ ‡ ‡</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G˜KŁH</head><p>It follows from the facts about pushouts and pushout complements recalled above that these pushouts exist if and only if o satisfies the dangling condition with respect to l, and in this case G, t, and o determine H uniquely up to isomorphism.</p><p>We require that occurrence morphisms are injective to avoid additional difficulties for the hierarchical case. This is because non-injective occurrence morphisms have to satisfy an identification condition that is not easily extended to hierarchical morphisms. Requiring injective occurrence morphisms is no restriction, however, as graph transformation with non-injective occurrence morphisms can be simulated by using quotient rules. More precisely, a rule tOE : LOE P IOE Q ROE is a quotient of a rule t: L P I Q R if there are two pushouts of the form</p><formula xml:id="formula_8">L ˜I Ł R ‡ ‡ ‡</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LOE˜IOEŁROE</head><p>where the vertical morphisms are surjective. In <ref type="bibr" target="#b25">[26]</ref> it is shown that every transformation using a non-injective occurrence morphism and a rule t can be simulated by a transformation using an injective occurrence morphism and a quotient of t. In our framework, graph transformation with non-injective occurrence morphisms corresponds to the special case that the set of rules is closed under the above quotient construction. (Note that for a finite set of rules, the latter can always be achieved by adding a finite number of quotients.) But we shall also give examples that make sense only if some quotients are omitted. Thus, injective occurrence morphisms allow us to control rule applications in a finer way than in the conventional approach. Precise results on the expressiveness gained by injective occurrence morphisms are given in <ref type="bibr" target="#b25">[26]</ref>.</p><p>Example 1.2 (Concatenation of List Graphs). In Fig. <ref type="figure" target="#fig_1">2</ref>, we specify a concatenation rule for list graphs and show a transformation with this rule. The rule concatenates two list graphs by identifying their L-edges, start nodes, and end nodes, respectively. The digits and the letters a, b indicate the morphisms from the interface to the left-and right-hand side. As occurrence morphisms are injective, we need quotients of this rule, for the node identifications 0=1, or 4=5, or both of them since the list graphs may be empty. For instance, the quotient rule given by 0=1 concatenates the empty list graph and a nonempty one.</p><p>A transformation step with another quotient rule is shown in Fig. <ref type="figure">3</ref>. Here a=b, i.e., both list edges are identified, and their attachments as well.</p><p>This quotient rule produces a malformed list graph wherein the last item node is connected to the first item node, and the start and end nodes are isolated. This indicates that quotients need to be added with care; this particular quotient must be excluded. Note that if we had not required that occurrence morphisms are injective then we had no means to prevent undesirable transformations of this kind.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">HIERARCHICAL GRAPHS</head><p>Graphs as defined in the previous section are flat. If some complicated abstract data type shall be implemented by graphs and graph transformation, no mechanism FIG. <ref type="figure">3</ref>. A quotient of the concat rule and its application.</p><p>supports the structuring of these graphs, except for the means that graphs provide themselves. Thus, any structural information has to be coded into the graphs, a solution which is often inappropriate and error-prone. To overcome this limitation, we introduce graphs with an arbitrarily deep hierarchical structure. This is achieved by means of special edges, called frames, which may contain hierarchical graphs again. Moreover, it will be useful to allow some frames to contain variables instead of graphs. The resulting structures will be called hierarchical graphs. Thus, a hierarchical graph consists of a graph, the root of the hierarchy, a designated subset of its edges, the frames, and a mapping assigning to each frame its contents, which is either a hierarchical graph or a variable. Definition 2.1 (Hierarchical Graph). Let X be a set of symbols called variables. The class H(X)=1 i \ 0 H i (X) of hierarchical graphs with variables in X consists of triples H=OG, F, ctsP such that G is a graph, F ı E G is the set of frame edges (or just frames), and cts: F Q H(X) 2 X assigns to each frame f ¥ F its contents cts(f) ¥ H(X) 2 X.</p><p>The sets H i (X) are defined inductively, as follows. A triple H=OG, F, ctsP as above is in</p><formula xml:id="formula_9">H 0 (X) if F=". For i &gt; 0, H ¥ H i (X) if cts(f) ¥ H i -1 (X) for every frame f ¥ F.</formula><p>Notice that H i (X) ı H i+1 (X) for all i \ 0. This is due to the fact that H 0 (X) ı H 1 (X), as an empty set of frames trivially satisfies the requirement; using this, H i (X) ı H i+1 (X) follows by an obvious induction on i. In the following, a hierarchical graph OG, F, ctsP ¥ H 0 (X) will be identified with the graph G. The sets H(") and H i (") (i \ 0) are briefly denoted by H and H i , respectively, and the hierarchical graphs in these sets are said to be variable-free.</p><p>Example 2.1 (Hierarchical List Graphs). To represent lists as hierarchical graphs, we turn I-edges and L-edges into frames that contain item graphs and list graphs, respectively. In order to make it easy to distinguish the end nodes of a list graph from the internal ones (i.e., those to which the item frames are attached), unary edges labelled with a special symbol • are attached to the end nodes. Figure <ref type="figure">4</ref> shows two list frames. Frames have double lines, and their contents are drawn inside. In our figures, we omit frame labels as list and item frames can be distinguished by their arity. Furthermore, the •-labelled edges are not explicitly drawn. Instead, the nodes they are attached to are filled. </p><formula xml:id="formula_10">F G =F H 5 A where cts G (f)=cts H (f) for all f ¥ F G .</formula><p>Notice that G is well-defined due to the assumptions on A.</p><p>We are now going to generalize the concept of a morphism to the hierarchical case. The definition is quite straightforward. A hierarchical morphism h: G Q H consists of an ordinary morphism on the topmost level and, recursively, hierarchical morphisms from the contents of non-variable frames to the contents of their images. Naturally, only variable frames can be mapped to variable frames, but also to any other frame carrying the right label.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.2 (Hierarchical Morphism). Let G, H ¥ H(X). A hierarchical morphism</head><formula xml:id="formula_11">h: G Q H is a pair h=Oh ¯, (h f ) f ¥ F G 0 X G P where • h ¯: G ¯Q H ¯is a morphism, • h ¯(f) ¥ F H for all frames f ¥ F G , where h ¯(f) ¥ X H implies f ¥ X G , and • h f : cts G (f) Q cts H (h ¯(f)) is a hierarchical morphism for every frame f ¥ F G 0 X G .</formula><p>In the following, we usually write h(a) instead of h ¯(a), for atoms a ¥ A G . Furthermore, a hierarchical morphism h: G Q H for which G, H ¥ H 0 will be identified with h ¯. Note that hierarchical morphisms respect and preserve the hierarchical structure. In particular, if h: G Q H is a hierarchical morphism, then the image of G in H has the same hierarchical depth as G.</p><p>The composition h p g of hierarchical morphisms g: G Q H and h: H Q L is defined in the obvious way. It yields the hierarchical morphism l: G Q L such that l ¯=h ¯p g ¯and, for all frames f ¥ F G 0 X G , l f =h g(f) p g f . The hierarchical morphism g is injective if g ¯is injective and, for all f ¥ F G 0 X G , g f is injective. It is surjective up to variables if g ¯is surjective and, for all f ¥ F G 0 X G , g f is surjective up to variables. Finally, g is bijective up to variables if it is injective and surjective up to variables. If G does not contain variables, we speak of surjective and bijective hierarchical morphisms. A bijective hierarchical morphism is also called an isomorphism, and G, H ¥ H are said to be isomorphic, denoted by G 5 H, if there is an isomorphism m: G Q H.</p><p>Let H be the category whose objects are variable-free hierarchical graphs and whose morphisms are the hierarchical morphisms h: G Q H with G, H ¥ H. The main result we are going to establish in order to obtain a notion of hierarchical graph transformation is that H has pushouts. This is proved by induction on the depth of the frame nesting, where the induction basis is provided by the non-hierarchical case recalled in Section 1. In the induction hypothesis, we reduce the depth of a hierarchical graph by the following construction: Given a hierarchical graph H ¥ H i , we take the contents of its frames out of these frames (turning the frames into ordinary edges) and add them disjointly to H ¯, thus obtaining a hierarchical graph in H i -1 (provided that i &gt; 0).</p><p>Formally, let G ¥ H. We will assume, without loss of generality, that</p><formula xml:id="formula_12">A G 5 A cts G (f) ="=A cts G (f) 5 A cts G (fOE) for all distinct f, fOE ¥ F G . On the basis of this assumption, we let j(G) denote the hierarchical graph G ¯+; f ¥ F G cts G (f) (where G īs considered to be an element of H 0 ). For a hierarchical morphism h: G Q H (where G, H ¥ H), j(h) denotes the hierarchical morphism m: j(G) Q j(H) such that, for every atom a ¥ A j(G) , m(a)= ˛h(a) if a ¥ A G h f (a) if a ¥ A cts G (f) for some f ¥ F G ,</formula><p>and</p><formula xml:id="formula_13">m fOE =(h f ) fOE for every f ¥ F G and fOE ¥ F cts G (f) .</formula><p>The following lemma is needed for the construction of pushouts. It states conditions under which a given hierarchical morphism m: j(G) Q j(H) can be turned into a hierarchical morphism h: G Q H such that j(h)=m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2.1. Let G, H ¥ H with GOE=j(G) and HOE=j(H). If m: GOE</head><formula xml:id="formula_14">Q HOE is a hierarchical morphism such that (1) for all e ¥ E G , m(e) ¥ F H if and only if e ¥ F G , (2) m(A G ) ı A H , and (3) for all f ¥ F G , m(A cts G (f) ) ı A cts H (m(f)) , then there is a hierarchical morphism h: G Q H such that j(h)=m. This hierarchical morphism is given by • h(a)=m(a) for all a ¥ A G , • h f (a)=m(a) for all f ¥ F G and a ¥ A cts G (f) , and • (h f ) fOE =m fOE for all f ¥ F G and fOE ¥ F cts G (f) .</formula><p>Proof. By the relevant definitions, if h is defined like this, then j(h)=m. Therefore it remains to show that h is well-defined. However, this is a direct consequence of the fact that m is a hierarchical morphism and, due to the assumptions, every</p><formula xml:id="formula_15">h f (f ¥ F G ) is a hierarchical morphism from cts G (f) to cts H (m(f)). L</formula><p>The next theorem is the main result of this section. It states that the category H has pushouts, and the proof shows how to construct them effectively.</p><formula xml:id="formula_16">Theorem 2.1. For every pair m 1 : G Q H 1 and m 2 : G Q H 2 of morphisms in H there are a hierarchical graph H and morphisms n 1 : H 1 Q H and n 2 : H 2 Q H in H such that (m 1 , m 2 , n 1 , n 2 ) is a pushout. Furthermore, (m 1 , m 2 , n 1 , n 2 ) is a pushout in the category of graphs. Proof. Let H 1 , H 2 ¥ H i .</formula><p>We proceed by induction on i, using Lemma 2.1 to exploit the induction hypothesis in the inductive step. For i=0 it holds that m i =m i , i.e., both morphisms are ordinary graph morphisms. Clearly, every pushout in the category of graphs is also a pushout in H. Thus, in this case the pushout</p><formula xml:id="formula_17">(m 1 , m 2 , n 1 , n 2 )=(m 1 , m 2 , n 1 , n 2 )</formula><p>of m 1 and m 2 in the category of graphs satisfies the assertion. Now, let i &gt; 0 and consider the morphisms</p><formula xml:id="formula_18">(m - j : GOE Q H - j )=j(m j ) (j ¥ {1, 2}</formula><p>), where GOE=j(G) and H - j =j(H j ). By the induction hypothesis, their pushout</p><formula xml:id="formula_19">(m - 1 , m - 2 , n - 1 , n - 2 ) exists and (m - 1 , m - 2 , n - 1 , n - 2 ) is a pushout in the category of graphs. Let n - j have the form n - j : H - j Q HOE.</formula><p>Then, we obtain a hierarchical graph H such that HOE=j(H), by defining</p><formula xml:id="formula_20">• H ¯=HOE| A where A=n - 1 (A H 1 ) 2 n - 2 (A H 2 ), • F H =n - 1 (F H 1 ) 2 n - 2 (F H 2 ), and • for every f ¥ F H , cts H (f)=HOE| A f , where A f is the set of all atoms n - j (a) such that j ¥ {1, 2} and a ¥ A cts H j (fOE) for some fOE ¥ F H j with n - j (fOE)=f.</formula><p>Let us first verify that H is well-defined. For every eOE ¥ E HOE 5 A there are j ¥ {1, 2} and e ¥ E H j such that n - j (e)=eOE (since</p><formula xml:id="formula_21">(m - 1 , m - 2 , n - 1 , n - 2</formula><p>) is a pushout). Consequently, att HOE (eOE)=n - j (att H j (e)) ¥ (V HOE 5 A) g , as required. Concerning the definition of A f for f ¥ F H , by a similar argument as for A we get att HOE (eOE)</p><formula xml:id="formula_22">¥ (V HOE 5 A f ) g for all eOE ¥ E HOE 5 A f .</formula><p>Thus, H is well-defined. Furthermore, one may check in a straightforward way that we even have j(H)=HOE because the set A together with the sets A f (f ¥ F H ) form a partition of A HOE . In order to be able to apply Lemma 2.1 it remains to be noticed that, by construction, for j ¥ {1, 2} and f ¥ F H j , we have n</p><formula xml:id="formula_23">- j (A cts H j (f) ) ı A cts H (n - j (f))</formula><p>. Thus, by Lemma 2.1 there are hierarchical morphisms n j : H j Q H for j ¥ {1, 2}, such that j(n j )=n - j , and these are given by</p><formula xml:id="formula_24">• n j (a)=n - j (a) for all a ¥ A H j , • n f j (a)=n - j (a) for all f ¥ F H j and a ¥ A cts H j (f) , and • (n f j ) fOE =n - j fOE for all f ¥ F H j and fOE ¥ F cts H j (f) .</formula><p>As claimed in the theorem, (m</p><formula xml:id="formula_25">1 , m 2 , n 1 , n 2 ) is a pushout since (m - 1 , m - 2 , n - 1 , n - 2 ) is one and m - j (a)=m - j (aOE) for a ¥ A G implies aOE ¥ A G . It remains to verify that (m 1 , m 2 , n 1 , n 2 )</formula><p>possesses the universal property of pushouts.</p><p>Let L ¥ H and consider hierarchical morphisms</p><formula xml:id="formula_26">l 1 : H 1 Q L and l 2 : H 2 Q L such that (m 1 , m 2 , l 1 , l 2 ) commutes. Then the square (m - 1 , m - 2 , l - 1 , l - 2 )</formula><p>, where (l - j : H - j Q LOE)= j(l j ) for j ¥ {1, 2}, commutes as well. Thus, there is a unique hierarchical morphism lOE: HOE Q LOE such that l - j =l p n - j for j ¥ {1, 2}. Again, the aim is to exploit Lemma 2.1 in order to turn lOE into the required morphism l: H Q L. For this, it must be verified that lOE satisfies the requirements (1)-( <ref type="formula">3</ref>), of the lemma.</p><p>As for (1), since (m 1 , m 2 , n 1 , n 2 ) is a pushout, it holds that for every e ¥ E H there is some j ¥ {1, 2} and some e 0 ¥ E H j such that n j (e 0 )=e. Therefore, lOE(e)=l - j (e 0 ) is an element of F L if and only if e ¥ F H .</p><p>For requirement <ref type="bibr" target="#b1">(2)</ref>, consider some a ¥ A. Then we have a=n - j (a 0 ) for some j ¥ {1, 2} and a 0 ¥ A H j , (again since (m 1 , m 2 , n 1 , n 2 ) is a pushout) and thus lOE(a)=l - j (a 0 )=l j (a 0 ) ¥ A L . The verification of ( <ref type="formula">3</ref>) is quite similar. Consider some f ¥ F H and a ¥ A f , and let j ¥ {1, 2}, f 0 ¥ F H j , and a 0 ¥ A cts H j (f 0 ) be such that n - j (f 0 )=f and n - j (a 0 )=a. (Notice that, again, j, f 0 , and</p><formula xml:id="formula_27">a 0 must exist.) Now lOE(a)=l - j (a 0 )=l f 0 j (a 0 ) ¥ A cts L (l j (f 0 )) = A cts L (lOE(f)) , as required. Therefore, Lemma 2.1 applies, yielding a hierarchical morphism l: H Q L such that j(l)=lOE, where • l(a)=lOE(a) for all a ¥ A H , • l f (a)=lOE(a) for all f ¥ F H and a ¥ A cts H (f) , and • (l f ) fOE =l -fOE for all f ¥ F H and fOE ¥ F cts H (f) .</formula><p>Clearly, for i ¥ {1, 2} this implies l j =l p n j since lOE=lOE p n - j . Furthermore, if k: H Q L was another morphism with this property distinct from lOE then kOE=j(k) would, by the definition of j, be different from lOE and would also satisfy l - j =kOE p n - j for j ¥ {1, 2}, contradicting the uniqueness of lOE. This finishes the proof of the theorem. L</p><p>Notice that the proof of Theorem 2.1 yields a recursive procedure to construct pushouts in H, based on the construction of pushouts in the case of ordinary graph morphisms.</p><p>The construction in the proof of the theorem yields two corollaries which turn out to be useful. The first expresses the fact that, to a certain extent, pushouts are constructed ''levelwise.'' Intuitively, the recursive part of the construction depends only on the way in which m 1 and m 2 relate the frames and their contents (and we know already from Theorem 2.1 that the top level is just the pushout in the category of graphs). Let us say that two hierarchical morphisms h: G Q H and hOE: GOE Q HOE agree on frames if F GOE =F G , F HOE =F H , and hOE(f)=h(f) as well as h -f =h f for all f ¥ F G . Then we have the following.</p><formula xml:id="formula_28">Corollary 2.1. Let (m 1 , m 2 , n 1 , n 2 ) be a pushout in H consisting of hierarchical morphisms m i : G Q H i and n i : H i Q H, and let m - i : GOE Q H - i agree with m i on frames (i ¥ {1, 2}). Then, morphisms n - i : H - i Q HOE such that (m - 1 , m - 2 , n - 1 , n - 2</formula><p>) is a pushout, can be constructed as follows:</p><formula xml:id="formula_29">(1) (m - 1 , m - 2 , n - 1 , n - 2 )</formula><p>is constructed as a pushout of non-hierarchical morphisms (in the way described in Section 1), <ref type="bibr" target="#b1">(2)</ref> </p><formula xml:id="formula_30">F HOE =n - 1 (F H 1 ) 2 n - 2 (F H 2 ), and (3) n - i f =n f i for i ¥ {1, 2} and f ¥ F H i .</formula><p>The second corollary concerns the special case where m 1 and m 2 are injective. Obviously, in this case the hierarchical morphisms m - 1 and m - 2 in the proof are also injective. As a consequence, it follows that</p><formula xml:id="formula_31">(m f 1 , m f 2 , n m 1 (f) 1 , n m 2 (f)</formula><p>2</p><p>) is a pushout for every frame f ¥ F G . This yields the following specialization of Theorem 2.1.</p><formula xml:id="formula_32">Corollary 2.2. Let m 1 : G Q H 1 and m 2 : G Q H 2 be injective hierarchical morphisms in H. Then, one can construct hierarchical morphisms n 1 : H 1 Q H and n 2 : H 2 Q H such that (m 1 , m 2 , n 1 , n 2 ) is a pushout, as follows: • n 1 and n 2 are such that (m 1 , m 2 , n 1 , n 2 ) is a pushout, • for every frame f ¥ F G the hierarchical morphisms n m 1 (f) 1 and n m 2 (f) 2 are con- structed recursively so that (m f 1 , m f 2 , n m 1 (f) 1 , n m 2 (f)</formula><p>2</p><p>) is a pushout, and</p><formula xml:id="formula_33">• for every frame f ¥ F H i 0 m i (F G ) (i ¥ {1, 2}</formula><p>), n f i is an isomorphism. Next, we shall see how pushout complements can be obtained. For simplicity, we consider only the case where the two given hierarchical morphisms are both injective. This enables us to make use of Corollary 2.2 in an easy way, whereas the more general case would be unreasonably complicated as it required a hierarchical version of the so-called identification condition <ref type="bibr" target="#b14">[15]</ref>.</p><p>Clearly, in order to ensure the existence of pushout complements, a hierarchical version of the dangling condition must be satisfied. However, for the hierarchical case it must also be required that, intuitively, no frame is deleted unless its contents are deleted as well.</p><p>Definition 2.3 (Hierarchical Dangling Condition). Let G, H ¥ H and H 1 ¥ H(X), and let m: G Q H 1 and n: H 1 Q H be hierarchical morphisms. Then n satisfies the hierarchical dangling condition (dangling condition, for short) with respect to m if</p><p>• n ¯satisfies the (non-hierarchical) dangling condition with respect to m ¯,</p><p>• for every frame</p><formula xml:id="formula_34">f ¥ F H 1 0 (m(F G ) 2 X H 1 )</formula><p>, n f is bijective up to variables, and</p><formula xml:id="formula_35">• for every frame f ¥ F G 0 X G , n m(f)</formula><p>satisfies the hierarchical dangling condition with respect to m f . Right below, we shall only use the dangling condition in case H 1 ¥ H, but later on the more general case H 1 ¥ H(X) will be needed, too.</p><p>Notice that this condition coincides with the usual one in the special case where m and n are ordinary graph morphisms, because then only the first requirement is relevant, as there are no frames. Intuitively, the second part of the condition states that, as mentioned above, a frame can be deleted only if its contents are deleted as well (at least in the case where H 1 ¥ H; the more general case is not yet our concern). As the proof below shows, this corresponds to the last item in Corollary 2.2 and is thus indeed necessary. </p><formula xml:id="formula_36">Theorem 2.2. Let m 1 : G Q H 1 ,</formula><formula xml:id="formula_37">(m f 1 , m f 2 , n m 1 (f) 1 , n m 2 (f)</formula><p>2</p><p>) is a pushout, and</p><p>(3) for every frame</p><formula xml:id="formula_38">f ¥ F H i 0 m i (F G ) (i ¥ {1, 2}), n f i is an isomorphism.</formula><p>As n 1 satisfies the dangling condition with respect to m 1 , m 2 and n 2 exist and are uniquely determined (since n 1 satisfy the non-hierarchical dangling condition with respect to m 1 ), and (3) is satisfied for i=1 (using the second part of the dangling condition). Furthermore, the induction hypothesis yields the required hierarchical morphisms m f 2 and n m 2 (f) 2 satisfying (2), for every frame f ¥ F G . Together with the remaining requirement in (3) (i.e., the case i=2) this determines m 2 and n 2 up to isomorphism, thus finishing the proof. L</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">HIERARCHICAL GRAPH TRANSFORMATION</head><p>Based on the results of the previous section we are now able to define rules and their application in the style of the double-pushout approach. From now on, a rule t: L P l I Q r R consists of two hierarchical morphisms l: I Q L and r: I Q R, where L, I, R ¥ H and l is injective. The hierarchical graphs L, I, and R are called the lefthand side, interface, and right-hand side of t, respectively.</p><p>The application of rules is defined by means of the usual double-pushout construction, with one essential difference. In order to make sure that transformations can take place on an arbitrary level in the hierarchy of frames, rather than only on the top level, one has to employ recursion. Definition 3.1 (Transformation of Hierarchical Graphs). Let t: L P l I Q r R be a rule. A hierarchical graph G ¥ H is transformed into a hierarchical graph H ¥ H by means of t, denoted by G S t H, if one of the following holds:</p><p>(1) There is an injective hierarchical morphism o: L Q G, called an occurrence morphism, such that there are two pushouts</p><formula xml:id="formula_39">Ll I Ł r R o ‡ ‡ ‡ G˜KŁH in H, or<label>(2)</label></formula><p>G ¯5 H ¯via some isomorphism m: G ¯Q H ¯, and there is a frame</p><formula xml:id="formula_40">f ¥ F G such that cts G (f) S t cts H (m(f)) and cts H (m(fOE)) 5 cts G (fOE) for all fOE ¥ F G 0 {f}.</formula><p>For a set T of rules, we write G S T H if G S t H for some t ¥ T.</p><p>Example 3.1 (Concatenation of Hierarchical List Graphs). In Fig. <ref type="figure" target="#fig_2">5</ref>, we specify a hierarchical version of the concatenation rule of Example 1.2 and show a transformation with this rule. We also need three quotients of this rule in order to handle empty lists. These quotients are characterized by the node identifications 1=2 and 7=8, respectively, and by both identifications together.</p><p>Note that the rule application in Fig. <ref type="figure" target="#fig_2">5</ref> takes place at the root level of the hierarchy, which corresponds to case (1) in Definition 3.1. Making use of Definition 3.1(2), a similar transformation could be made anywhere deeper down in the hierarchy of frames, for example, if some frame in a large hierarchical graph contained the one shown in the figure . 

Since occurrence morphisms are injective, we get the following result as a consequence of Theorems 2.1 and 2.2. Proof. By Theorem 2.2 the pushout on the left exists if and only if the dangling condition is satisfied, and if it exists then it is uniquely determined (up to isomorphism). Moreover, by Theorem 2.1 the pushout on the right always exists, and it is a general fact known from category theory that a pushout (m 1 , m 2 , n 1 , n 2 ) is uniquely determined (up to isomorphism) by the morphisms m 1 and m 2 . L It is worth noting that, by the effectiveness of the results presented in Section 2, given a transformation rule, a hierarchical graph, and an occurrence morphism satisfying the dangling condition, one can effectively construct the required pushouts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">HIERARCHICAL GRAPH TRANSFORMATION WITH VARIABLES</head><p>Unfortunately, the concept of hierarchical graph transformation is not yet expressive enough to be satisfactory for certain programming purposes. There are some effects that one would certainly want to implement as single transformation steps, but which cannot be expressed by a single rule. In the example of lists, for instance, it should be possible to design a rule remove which deletes the first item in a list regardless of its contents. However, this is not possible as the dangling condition requires the occurrence morphism to be bijective on the contents of deleted frames. Similarly, a rule enter should take an item frame, again regardless of its contents, and add it to the list-preferably without affecting the original item frame. In order to realise these effects, we have to circumvent two obstacles. First, hierarchical morphisms preserve the frame hierarchy, which implies that, intuitively, rules cannot move frames across frame boundaries. Second, by now it is simply not possible to delete or duplicate frames together with their contents. This is where variables come into play. The idea is to turn from rules to rule schemata and to transform hierarchical graphs by applying instances of these rule schemata. In order to make sure that an occurrence morphism satisfying the dangling condition always yields a well-defined transformation, we restrict ourselves to left-linear rule schemata. To this end, a hierarchical graph H is called linear if no variable occurs twice in H. More precisely, H must satisfy </p><formula xml:id="formula_41">• cts H (f) ] cts H (fOE) for all distinct variable frames f, fOE ¥ X H , • cts H (f) is linear for every frame f ¥ F H 0 X H , • var(cts H (f)) 5 var(cts H (fOE))=" for all distinct frames f, fOE ¥ F H 0 X H ,</formula><formula xml:id="formula_42">cts(f)= ˛a(cts H (f)) if f ¥ X H , cts H (f) a otherwise, for every frame f ¥ F H .</formula><p>By the definition of hierarchical morphisms, a hierarchical morphism h: G Q H with G ¥ H can also be viewed as a hierarchical morphism from G to Ha, where a is any variable assignment for H. In the following, this hierarchical morphism will be denoted by ha. We define rule schemata and their application based on this observation.  A rule schema t transforms G ¥ H into H ¥ H, denoted by G U t H, if G S tOE H for some instance tOE of t. For a set T of rule schemata, we write G U T H if G U t H for some t ¥ T.</p><p>Example 4.1 (The Rule Schemata enter and remove). In Fig. <ref type="figure" target="#fig_5">6</ref>, we show a rule schema that inserts a framed item graph at the tail of a list graph, and a transformation with this rule. The item frame contains a variable x which makes it possible to duplicate the item graph and to move one copy into the list frame. (We also consider the quotient of enter that merges the two left-most nodes in the list graph, and possibly other quotients that identify any of the nodes outside the list frame.)</p><p>Figure <ref type="figure" target="#fig_6">7</ref> shows a rule schema that removes the first item frame in a list graph, and an application of this rule to the result of the transformation in Fig. <ref type="figure" target="#fig_5">6</ref>. The item graph contains a variable x so that it can be removed entirely. (Again we consider additional quotient rules, analogously to the case of enter.) Note that Definition 4.2 does not allow the interface graph I to contain variables. This avoids pathological cases while leaving the power of the formalism unaffected. To see this, assume that we would allow a ''rule schema'' as in Fig. <ref type="figure">8</ref> and consider the occurrence morphism shown there. Intuitively, the occurrence morphism instantiates x (see also Theorem 4.1 below), but if I is instantiated in this way the morphism from I to L ceases to exist. In fact, one may say that there is already a hidden instantiation of x, namely the one which is determined by the morphism from I to L, and both instantiations are in conflict with each other. Moreover, the left-linearity requirement imposed on L loses its effect. This becomes obvious if the contents of the non-variable frame in L is replaced with the empty graph or a new variable y. To avoid these unwanted effects without imposing complicated conditions, one would have to require that every variable in I is mapped to itself in L. However, then the rule schema has the same effect as the one in which all variables in I are deleted, so that nothing is gained with respect to power. Definition 4.2 does not indicate how to implement hierarchical graph transformation with variables. The problem is that there are infinitely many instances of a rule schema as soon as it contains at least one variable. Therefore, the naive approach to implement U t by constructing all its instances and then testing each of them for applicability does not work. However, one can do better by constructing occurrence morphisms as follows and applying the theorem below.</p><p>Consider some linear hierarchical graph L ¥ H(X) and a hierarchical graph G ¥ H, and let o: L Q G be a hierarchical morphism. Then, due to the linearity of L, o induces a variable assignment a o : var(L) Q H and an occurrence morphism inst(o): La o Q G as follows. For all x ¥ var(L), if there is some</p><formula xml:id="formula_43">f ¥ X L such that cts L (f)=x then a o (x)=cts G (o(f)). Otherwise, a o (x)=a o f (x), where f ¥ F L 0X L is the unique frame such that x ¥ var(cts L (f)). Furthermore, inst(o)=o ¯and for all f ¥ F L , inst(o) f is the identity on cts G (o(f)) if f ¥ X L and inst(o) f =inst(o f ) otherwise.</formula><p>The following theorem states that the transformations given by a rule schema t: L P l I Q r R can be obtained by considering occurrence morphisms o: L Q G which satisfy the dangling condition with respect to l. To simplify our terminology, we may from now on say that o satisfies the dangling condition, skipping the reference to l, if the rule in question is clear from the context. Theorem 4.1. Let t: L P l I Q r R be a rule schema and G ¥ H. (2) If a: var(L) Q H is a variable assignment and q: La Q G is an occurrence morphism satisfying the dangling condition with respect to la, then a=a o and q=inst(o) (up to isomorphism) for some occurrence morphism o: L Q G satisfying the dangling condition with respect to l.</p><p>Proof. Both claims are proved by induction on i, where L ¥ H i (X).</p><p>(1) For i=0, L is a graph. In particular, var(L)=", which implies inst(o)=o and La o =L. Thus, there is nothing left to show. Now consider some i &gt; 0. By definition, La o =L ¯and inst(o)=o ¯. Therefore, inst(o): La o Q G ¯is injective and satisfies the dangling condition for the nonhierarchical case. It remains to check the properties of the hierarchical morphisms inst(o) f for f ¥ F La o =F L . There are three cases.</p><p>Case 1. f ¥ l(F I ). Then f ¨XL because var(I)=". As o f is an occurrence morphism for cts L (f) which satisfies the dangling condition, the induction hypothesis yields that inst(o) f =inst(o f ) is an occurrence morphism for cts L (f) a o f = cts La o (f) which satisfies the dangling condition.</p><p>Case 2. f ¥ X L . Then f ¨l(F I ) (again since var(I)="). Therefore, the dangling condition requires inst(o) f to be an isomorphism, which, according to the definition of inst(o), is the case. Case 3. f ¨XL 2 l(F I ). According to the dangling condition, o f is bijective up to variables. As one can deduce from the definition of inst(o) by a straightforward induction, this implies that inst(o</p><formula xml:id="formula_44">) f : cts La o (f) Q cts G (o(f)) is an isomorphism, as required.</formula><p>(2) As in the first part, the statement is valid for i=0. Therefore, let i &gt; 0.</p><p>Choosing o ¯=q ¯, we immediately get that o ¯satisfies the (non-hierarchical) dangling condition. Now, for f ¥ F L 0 X L , define o f as follows. If f ¥ l(F I ), then o f is the hierarchical morphism obtained by applying the induction hypothesis to a (restricted to var(cts L (f))) and q f . Otherwise, o f : cts L (f) Q cts G (o(f)) is chosen to be any hierarchical morphism which is bijective up to variables and satisfies inst(o f )=q f (notice that such a morphism exists because q satisfies the dangling condition, which means that q f : cts</p><formula xml:id="formula_45">La (f) Q cts G (o(f)) is bijective as f ¨l(F I )).</formula><p>By construction, inst(o)=q and a o =a. Furthermore, o f satisfies the dangling condition for every f ¥ l(F I ) and is bijective up to variables for every f ¥ F L 0 (l(F i ) 2 X L ). Together with the fact that o ¯satisfies the (non-hierarchical) dangling condition this means that o satisfies the dangling condition, which completes the proof. L Linearity of the left-hand sides of rule schemata is crucial for the instantiation of occurrence morphisms by which the pushout complement of a hierarchical graph transformation with variables is constructed. The other condition on the variables of a rule schema, namely that all variables of the right-hand side of a rule schema do already occur in its left-hand side, makes sure that the assignment used to instantiate the occurrence morphism suffices to instantiate the right-hand side of the rule to a hierarchical graph that is variable free again. (Note that similar conditions apply to term rewriting rules for similar reasons.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">SORTING LIST GRAPHS</head><p>In this section we demonstrate how to program by hierarchical graph transformation, by giving a quicksort algorithm for the list graphs considered before. Throughout this section, rule schemata are shown without their interface graphs. For each rule (schema) t: L P l I Q r R, the morphism r is injective and the correspondence between the nodes of L and the nodes of R is indicated by the geometric arrangement of L and R. By convention, the interface graph I is the discrete subgraph of L consisting of all nodes that correspond to nodes in R.</p><p>The algorithm is given by a set of rules which falls into three parts.</p><p>Part 1. Graph Comparison. The rules in Fig. <ref type="figure">9</ref> compare the contents of two item frames with respect to their size, which is considered to be the number of their nodes and edges. The comparison works as follows:</p><p>• The first rule makes working copies of the item frames and their attachment nodes (where the attachment nodes of the left-hand side, drawn in grey, form the interface graph).</p><p>• Rules 2 through 5 remove one node or edge from the contents of the two working copies in parallel. For these rules we need quotients because in the item graph in which two nodes are connected by an edge, these nodes may be identical.</p><p>• If one of the item frames is empty, while the other has an arbitrary contents (expressed by the variable x), it is less or equal to the other in size. This is signaled, in rules 6 and 7, by connecting the item nodes of the original item frames by a ''['' or ''\'' edge. (Note that either rule applies if both working copies are empty, so that the original graphs have been of equal size.) An interesting aspect of rules 6 and 7 should be noticed: Due to the hierarchical dangling condition, it is possible to test whether a frame contains a specific graph (the empty one in this case) by just attempting to delete it. Thanks to that condition, such a rule applies only if the occurrence morphism is bijective on the contents of this frame.</p><p>Part 2. Sorting. The rules in Fig. <ref type="figure" target="#fig_7">10</ref> work as follows:</p><p>• The first rule replaces an application of quicksort to a list frame by the application of qsort to the list graph it contains.</p><p>• Rules 2 and 3 cover the cases of empty and singleton lists, which need not be sorted.</p><p>• If the list contains more than one item, the first item is taken as a pivot to partition the remaining items into two sublists containing the items that are smaller, respectively greater, than the pivot. The unsorted items are ''set aside,'' by disconnecting the second item node from the start node, and the last item node from the end node of the list. The end of this chain of unsorted items is marked by a loop edge. The start node is linked to the pivot, and the pivot to its end node, representing the fact that the lists of smaller respectively greater elements are empty at the beginning. We need quotients for the case where the list contains two item frames. Then the successor of the pivot and the predecessor of the end node are identified.</p><p>Part 3. Partitioning. These rules insert an unsorted item immediately before, or immediately after the pivot (see Fig. <ref type="figure" target="#fig_9">11):</ref> • Depending on whether the comparison determines that the pivot is not greater, or not less than the list element, this item is inserted after the pivot (by the upper rules), or before it (by the lower rules).</p><p>The upper shaded node is (the item node of) the pivot; the lower shaded node is the one which has just been compared with the pivot. The two rules on the left correspond to the case where the end of the list has been reached (which is signified by the loop edge). Thus, they insert the node after, respectively before, the pivot and finish the partitioning process. The other two rules also insert the node, but continue by comparing the next node with the pivot. • If there is no further unsorted item, which is indicated by the loop edge, then qsort is called recursively to sort the sublists of smaller and greater elements (by the rules on the left). Otherwise partitioning continues by comparing the pivot with the next unsorted item.</p><p>We also need some quotients of the partition rules, since the first attachment node of the partition-edge can be identical to the pivot's predecessor, and its last attachment node can be identical to the pivot's successor.</p><p>Figure <ref type="figure" target="#fig_10">12</ref> shows how the quicksort program sorts a list of four item graphs. The intermediate steps of the comparison steps are omitted, and in the last line two applications of qsort, with the entailed applications of partition, compare, and qsort, are omitted as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATING HIERARCHICAL TO PLAIN GRAPH TRANSFORMATION</head><p>The previous section illustrates that frames are useful for programming by graph transformation. The contents of frames may be considered as hidden data, and one may think of an object-oriented system based on hierarchical graph transformation where a rule t can inspect or modify the contents of a frame f only if t belongs to the class by which f is generated (see <ref type="bibr" target="#b27">[28]</ref>). For instance, the concat, enter, and remove rules of our running example do not inspect or modify the contents of item frames.</p><p>A hierarchical graph H may, however, also be considered as a ''nested view'' of a large flat graph G wherein the frames are placeholders that hide their contents. For restoring the flat graph G, it is useful to have a flattening operation which recursively replaces every frame with its contents. (See also <ref type="bibr" target="#b32">[33]</ref> for hiding and restoring transformation rules working on such nested views; the views considered in <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b44">45]</ref> are not nested.)</p><p>A useful notion of flattening should provide a mechanism which allows us to specify that some node of the contents of a frame f corresponds to a node v outside. More precisely, v should be an attached node of f. Thus, if f has k attached nodes, we need to designate a sequence of k nodes in the contents graph of f which the flattening process identifies with the attached nodes of the frame. We mark these k nodes by attaching a special edge to them. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HIERARCHICAL GRAPH TRANSFORMATION</head><p>In the following, let P={p k | k ¥ N} ı C be a set of special labels, where type(p k )=k for all k ¥ N. An edge whose label is in P will be called a P-edge. We define three sets of pointed hierarchical graphs, namely P + , P -, and P, as follows. P + is the set of all hierarchical graphs G such that (i) there is exactly one</p><formula xml:id="formula_46">P-edge p G in E G 0 F G ; point G =att G (p G ) is said to be the sequence of points of G and type(G)=|point G | is its type, and (ii) for every frame f ¥ F G , cts G (f) ¥ P + and type(cts G (f))=|att G (f)|.</formula><p>The set of all hierarchical graphs G which satisfy (ii), but where E G does not contain a P-edge, is denoted by P -, and P=P + 2 P -.</p><p>General Assumption. For the remainder of this section we shall only deal with hierarchical graphs in P. To ensure that transformation preserves points, we assume in the following that L, I, R ¥ P -for every rule t: L P l I Q r R.</p><p>We show in this section that, under modest assumptions, hierarchical graph transformation (with rules of this kind) is compatible with the flattening operation in the following sense: A hierarchical transformation G S t H induces a corresponding ''flat'' transformation GOE S tOE HOE, where GOE, HOE, and tOE are the flattened versions of G, H, and t, respectively. (Obviously, the converse cannot hold as structural information gets lost in the flattening process.)</p><p>For the definition of flattening, we extend the well-known concept of hyperedge replacement (see <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b24">25]</ref>) to hierarchical graphs. Let H be a hierarchical graph. For every set E ı E H of edges, H -E denotes the hierarchical graph obtained by deleting all the edges in E from H, i.e., H -E=OG, F H 0 E, ctsP where G= OV H , E H 0 E, att, labP, att and lab being the restrictions of att H and lab H to E H 0 E, and cts is the restriction of cts H to F H 0 E. Now, consider a mapping s: E Q P such that type(s(e))=|att H (e)| for all e ¥ E, called a hyperedge substitution for H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hyperedge replacement yields the hierarchical graph H[s] obtained from (H -E)+; e ¥ E (s(e) -{p s(e) }) by identifying, for all e ¥ E with att</head><formula xml:id="formula_47">H (e)=u 1 • • • u k and point s(e) =v 1 • • • v k , each node u i with v i , for all i ¥ [k].</formula><p>For all atoms a ¥ (A H 0 E) 2 1 e ¥ E (A s(e) 0 {p s(e) }) we denote by track H, s (a) (or track(a) if there is no danger of confusion) the image of a in H[s], if it is necessary to be particularly precise with respect to this point. Normally, however, we will implicitly assume that track H, s is the identity, in order to avoid unnecessarily complex notation.</p><p>Finally, for all H ¥ P, the flattening of H yields the graph flat(H)=H[s] where s: F H Q P + is given inductively by s(f)=flat(cts H (f)) for all f ¥ F H . Thus, flattening recursively replaces all frames by their contents (and removes the P-edges from the inserted graphs), yielding a flat graph. Example 6.1 (Hyperedge Replacement and Flattening). Figures <ref type="figure" target="#fig_11">13</ref> and<ref type="figure" target="#fig_12">14</ref> illustrate hyperedge replacement and flattening. In these figures, p-edges are not drawn explicitly, but the nodes in the point sequence point G that they indicate are drawn as filled circles. Numbers ascribed to those nodes indicate their position in the point sequence. The ascription ''1=3'' in s(f) and G indicates that this node occurs repeatedly, at position 1 and 3 in the point sequence of the corresponding frame. Hyperedge replacement, applied to a frame as in Fig. <ref type="figure" target="#fig_11">13</ref>, removes the replaced frame regardless of its contents. The contents gets lost. Since nodes 1 and 3 in the point sequence of s(f) are identical, the corresponding attached nodes of f are identified in H[s] (which, in this particular case, turns the edge between the two nodes into a loop). Similarly, repetitions in att(f) can result in identifications of nodes in s(f).</p><p>Flattening, as shown in Fig. <ref type="figure" target="#fig_12">14</ref>, does not discard the contents of frames because every frame gets replaced with its own, flattened contents. To see how this works, first replace the inner frame with its contents, and then the outer one. Of course, repetitions in point sequences or frame attachments result in similar node identifications as in Fig. <ref type="figure" target="#fig_11">13</ref>.</p><p>The following lemma turns out to be useful in proofs. It holds by an obvious induction, using the associativity of hyperedge replacement. Lemma 6.1. For all H ¥ P,</p><formula xml:id="formula_48">flat(H)= ˛H if H ¥ H 0 , flat(H[cts H ])</formula><p>otherwise.</p><p>We can flatten morphisms as well. Consider a hierarchical morphism h: G Q H with G, H ¥ P and let s=flat p cts G and y=flat p cts H . Then flat(h) is the morphism m: flat(G) Q flat(H) defined inductively as follows. For all Notice that the two cases in the definition of m(a) above are consistent with each other, although they intersect. This can be seen as follows. According to the definition of hyperedge replacement, flat(G)=G <ref type="bibr">[s]</ref> and flat(H)=H <ref type="bibr">[y]</ref> </p><formula xml:id="formula_49">a ¥ A flat(G) , if a=track G, s (aOE) for some aOE ¥ A G , then m(a)=h(aOE); if a=track G, s (aOE) for some aOE ¥ A s(f) and f ¥ F G , then m(a)=flat(h f )(aOE).</formula><formula xml:id="formula_50">are obtained from GOE=(G -F G )+1 f ¥ F G (s(f) -{p s(f) }) and HOE=(H -F H )+1 f ¥ F H (y(f) - {p y(f) })</formula><p>, respectively, by identifying certain nodes. Thus, assuming inductively that every flat(h</p><formula xml:id="formula_51">f ) (f ¥ F G ) is a well-defined morphism, m is well-defined if track G, s (u)= track G, s (v) implies track H, y (g(u))=track H, y (g(v)) for all u, v ¥ V GOE , where g: V GOE Q V HOE is given by g(w)= ˛h(w) for w ¥ V G , flat(h f )(w) for w ¥ V s(f) , f ¥ F G .</formula><p>However It was mentioned above that the main result of this section holds only under a certain assumption. The reason is that a morphism flat(h) may be non-injective although h: G Q H itself is injective. This is caused by the fact that the construction of flat(G) may identify some nodes in V G because they are incident with a frame whose contents has repetitions in its point sequence. If the attached nodes of the frame are distinct, hyperedge replacement identifies them (by identifying each with the same point of the contents). Thus, flattening may turn an occurrence morphism into a non-injective morphism, making it impossible to apply the corresponding flattened rule. In fact, the dual situation where there are identical attached nodes of a frame while the corresponding points of its contents are distinct, must also be avoided. The reason lies in the recursive part of the definition of S t . If a rule is applied to the contents of some frame, but the replacement of the frame identifies two distinct points of the contents because the corresponding attached points of the frame are identical, the flattened rule cannot be applied either.</p><p>There are several possible ways to circumvent these problems. First, one may develop the whole theory without requiring occurrence morphisms to be injective, which is probably quite a complicated task. Second, in addition to the flattened rule one could use all its quotient rules. This will probably work, and the proof should not be too difficult. However, there is a third, even simpler possibility which we choose here, namely just to exclude these situations (which appear somewhat unnatural in cases where one is interested in flattening). To this end, call a hierarchical graph H ¥ P identification consistent if every frame f ¥ F H satisfies the following condition:</p><p>(1) For all i, j ¥ [type(cts</p><formula xml:id="formula_52">H (f))], point cts H (f) (i)=point cts H (f) (j) if and only if att H (f)(i)=att H (f)(j), and</formula><p>(2) cts H (f) is identification consistent.</p><p>One should notice that identification consistency is preserved by the application of a rule t: L P l I Q r R if R is identification consistent and r is injective. Thus, if we restrict ourselves to systems with rules of this kind then all hierarchical graphs derivable from some identification consistent graph will be identification consistent as well.</p><p>The following lemma holds by an obvious induction.</p><p>Lemma 6.2. For every injective hierarchical morphism h: G Q H (G, H ¥ P) such that H is identification consistent, flat(h) is injective.</p><p>The main lemma of this section says that the flattening operation turns pushouts of hierarchical morphisms into pushouts of ordinary morphisms.</p><formula xml:id="formula_53">Lemma 6.3. Let m i : G Q H i and n i : H i Q H (i ¥ {1, 2}) be hierarchical morphisms, where G, H 1 , H 2 , H ¥ P. If (m 1 , m 2 , n 1 , n 2 ) is a pushout in H, then (flat(m 1 ), flat(m 2 ), flat(n 1 ), flat(n 2 )</formula><p>) is a pushout as well.</p><p>Proof. We may assume without loss of generality that G, H 1 , H 2 , H ¥ P -, as flattening treats P-edges that occur on the top level like any other edge.</p><p>For a hierarchical morphism h: K Q L with K, L ¥ P -let jOE(h) be the hierarchical morphism hOE:</p><formula xml:id="formula_54">K[cts K ] Q L[cts L ] given by hOE(a)= ˛h(a) if a ¥ A K h f (a) if a ¥ A cts K (f) , f ¥ F K for all a ¥ A K[cts K ]</formula><p>, and h -g =h f g for all f ¥ F K and g ¥ F cts K (g) . Similar to the argumentation for the well-definedness of flat(h) it follows that jOE(h) is indeed a welldefined hierarchical morphism.</p><p>Comparing the definitions of jOE and the mapping j considered in Section 2, it is clear that jOE(h) is obtained from j(h)=(h 0 : K 0 Q L 0 ) by (i) deleting from K 0 and L 0 all edges belonging to F K or F L , respectively, as well as the P-edges, and (ii) identifying in K 0 all nodes u, v such that track K, cts K (u)=track K, cts K (v), and in L 0 all nodes u, v such that track L, cts L (u)=track L, cts L (v). Now, consider the pushout (m 1 , m 2 , n 1 , n 2 ) in the statement of the lemma. By induction on the depth of the frame hierarchy, using Lemma 6.1, it suffices to prove that (jOE(m 1 ), jOE(m 2 ), jOE(n 1 ), jOE(n 2 )) is a pushout. We already know from Section 2 that (j(m 1 ), j(m 2 ), j(n 1 ), j(n 2 )) is a pushout. Therefore, by Corollary 2.1 it remains to be shown that the square (jOE(m 1 ), jOE(m 2 ), jOE(n 1 ), jOE(n 2 )) obtained from (j(m 1 ), j(m 2 ), j(n 1 ), j(n 2 )) by applying (i) and (ii) to each of the morphisms, is a pushout. As we know from Section 1 how pushouts are constructed in the nonhierarchical case, this is not hard to verify. The deletion of frames in (i) does not affect the property of being a pushout because j(m 1 ) maps frames to frames. For a similar reason, the deletion of P-edges is consistent and preserves the pushout properties. Furthermore, (ii) does not destroy the pushout either, because it identifies only those nodes in j(H) whose pre-images in j(H 1 ) or j(H 2 ) are identified, too. Thus, all together, (jOE(m 1 ), jOE(m 2 ), jOE(n 1 ), jOE(n 2 )) turns out to be a pushout, which completes the proof. L</p><p>We can now prove the main theorem of this section: If a rule can be applied to an identification consistent hierarchical graph, then the flattened rule can be applied to the flattened graph, with the expected result. Theorem 6.1. Let t: L P l I Q r R be a rule, and let tOE: LOE P lOE IOE Q rOE ROE be the rule given by lOE=flat(l) and rOE=flat(r). For every transformation G S t H such that G is identification consistent, there is a transformation flat(G) S tOE flat(H).</p><p>Proof. Due to the definition of S t there are two cases to be distinguished. If there is a double-pushout of the form</p><formula xml:id="formula_55">Ll I Ł r R o ‡ ‡ ‡</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G˜KŁH</head><p>for some occurrence morphism o: L Q G, then Lemma 6.3 yields the following double-pushout:</p><formula xml:id="formula_56">LOE˜|| lOE IOE||Ł rOE ROE flat(o) ‡ ‡ ‡ flat(G) / flat(K) 0 flat(H).</formula><p>By Lemma 6.2 the morphism flat(o) is injective, which by the definition of transformation means flat(G) S tOE flat(H).</p><p>The second case to be considered is the recursive one. Suppose there is a frame f ¥ F G such that G ¯5 H ¯via some isomorphism m: G Q H, where cts G (f) S t cts H (m(f)) and cts H (m(fOE)) 5 cts G (f) for all fOE ¥ F G 0 {f}. Assuming inductively that the transformation flat(cts G (f)) S tOE flat(cts H (m(f))) exists, we obtain the following double-pushout of non-hierarchical morphisms:</p><formula xml:id="formula_57">LOE˜|| lOE IOE||Ł rOE ROE o ‡ ‡ ‡ flat(cts G (f)) / K Qflat(cts H (m(f)))</formula><p>By our general assumption, LOE, IOE, and ROE are in P -. Therefore, the unique P-edges in flat(cts G (f)), K, and flat(cts H (m(f))) cannot occur in the images of the vertical morphisms. Furthermore, by the uniqueness of these edges the two morphisms on the bottom line map P-edges to P-edges. Therefore, we obtain a new double-pushout diagram</p><formula xml:id="formula_58">LOEl OE IOE Ł rOE ROE o ‡ ‡ ‡ G 0 ˜K0 ŁH 0</formula><p>by deleting the P-edges from these graphs: Due to the assumed identification consistency, G 0 is a subgraph of flat(G). More precisely, by defining h(a)=a for all a ¥ A G 0 , one obtains an injective morphism h: G 0 Q flat(G). Moreover, if o satisfies the dangling condition, so does h p o, since v ¥ V cts G (f) cannot occur in att flat(G) (e) for some e ¥ E flat(G) 0 E G 0 unless v is a point of cts G (f) (by the definition of hyperedge replacement), and is thus in the image of o p lOE.</p><formula xml:id="formula_59">G 0 =flat(cts G (f)) -{p cts G (f) }, K 0 = K -{p K },</formula><p>This means that the double-pushout above extends to</p><formula xml:id="formula_60">LOEl OE IOEŁ rOE ROE h p o ‡ ‡ ‡ flat(G)P KOEŁHOE</formula><p>for some graphs KOE and HOE. In fact, from the constructions recalled in Section 1 it follows immediately that HOE 5 flat(H). This shows that there is a transformation flat(G) S tOE flat(H) and thus completes the proof. L</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>In this section we review some of the related work one can find in the literature. The contribution of the present paper has been twofold. We have introduced a hierarchical structuring mechanism for graphs together with an appropriate notion of hierarchical graph transformation. Accordingly, two categories of related work can be distinguished. The first one encompasses contributions that define an additional level of structure for graphs, usually motivated by some type of application area. The second one is about approaches that aim at the transformation of hierarchical structures, using ideas which are related to those presented here. Naturally, some papers contribute to both fields.</p><p>Let us first discuss structuring approaches for graphs. These approaches are usually motivated by the observation that large graphs are often incomprehensible both from a visual and an intellectual point of view. Despite the fact that graphs are structures, they lack a global structuring mechanism. Such a mechanism should allow us to designate or encapsulate subgraphs which, for semantic or pragmatic reasons, shall be considered as entities on their own. Normally, it is desirable that such a concept of graphs within graphs may be iterated. Graphs of this kind are therefore often called hierarchical graphs. (This is not to be confused with the meaning of ''hierarchical'' in the graph drawing community, where the term is used for a tree-like layout of flat graphs, as in <ref type="bibr" target="#b31">[32]</ref>.) Below, some of the main structuring concepts for graphs of this type are discussed.</p><p>• The nodes and/or edges of a graph can be allowed to contain other graphs, so-called nested components, which can be nested again. Such a concept has been introduced in this paper, turning a graph from a flat into a recursive structure in which the nested components are pairwise disjoint: neither do they share subgraphs, nor are there edges between their nodes. The strict hierarchical structure is particularly useful for programming by graph transformation because components can be transformed independently of each other, which guarantees that the semantics of transformation is compositional (see the discussion in the Introduction).</p><p>The nested components contained in nodes or edges can be seen as attributes. However, tools like Progres <ref type="bibr" target="#b42">[43]</ref>, Agg <ref type="bibr" target="#b21">[22]</ref>, and DiaGen <ref type="bibr" target="#b30">[31]</ref> either restrict attributes to be primitive, or to be of a (non-graphical) type in their host programming language. Even if this allows us to attribute nodes or edges of a graph by the host language implementation of another graph, transformations can then only be defined componentwise. The edges and nodes in the L-graphs proposed in <ref type="bibr" target="#b41">[42]</ref> are labelled by (flat) graphs. By iteration, this definition can provide nesting of any fixed depth.</p><p>• Another line of research is motivated by system modelling. This motivation results in a slightly different conceptual view than the one described above. A graph is not a priori structured. Instead, the starting point is an underlying flat graph, which is then provided with a structure by associating subgraphs to so-called packages. Packages can be represented by nodes (which are either fresh, or occur in the underlying graph), and there can be edges between them which establish some kind of package dependency. Edges in the underlying graph are often allowed to cross package boundaries, and in some cases, nodes and edges may belong to several packages.</p><p>As discussed in the Introduction, such ''boundary-crossing'' edges prevent compositionality and are thus undesirable for programming (although the dividing-line is blurred and one may think of programming situations in which these edges are useful, similar in character to the use of goto-statements). In contrast to this, boundary-crossing edges are indispensable in many modelling situations and are thus of widespread use in nested visual languages like Uml <ref type="bibr" target="#b40">[41]</ref>. Therefore, it is usually unavoidable to sacrifice compositionality when hierarchical graphs shall be applied for modelling purposes.</p><p>Pratt <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref> was probably the first to consider such a kind of hierarchical graphs. The packages in his H-graphs may depend on each other in an arbitrary way, also recursively. A particular kind of node replacement is used to define Hgraph languages that represent the semantics of programs, e.g., of Lisp expressions. (Note that this is essentially a modelling rather than a programming situation, as the semantics of a source program is represented by a set of graphs.)</p><p>The hierarchical graphs defined in <ref type="bibr" target="#b20">[21]</ref> are equipped with an acyclic package hierarchy as well as export and import relations defining admissible package-crossing edges. However, transformational aspects are not investigated. In <ref type="bibr" target="#b5">[6]</ref> transformation for a simpler version of such graphs is defined. The paper <ref type="bibr" target="#b19">[20]</ref>, where hierarchical graphs are defined by distinguishing ''ordinary'' from ''hierarchy'' edges, includes transformation, but without considering export, import, and conditions for the preservation of the hierarchy's consistency.</p><p>In <ref type="bibr" target="#b7">[8]</ref>, an abstract notion of hierarchical graphs is introduced where the package hierarchy, the underlying graph, and their coupling are represented by three flat graphs, and transformation is defined as componentwise application of rules to these three graphs (even heterogeneously, specified in different transformation approaches of the kind formalized in <ref type="bibr" target="#b1">[2]</ref>). This framework is used in <ref type="bibr" target="#b6">[7]</ref> to compare the approach introduced here, and the one by Pratt. It may also be used to equip arbitrary graph classes and transformation approaches with a hierarchy concept.</p><p>• The basic idea of distributed graph transformation is to extract several subgraphs from a graph, and to transform them independently so that a common interface remains intact <ref type="bibr" target="#b43">[44]</ref>. This creates a shallow hierarchical structure of depth 2. The distributed encapsulated graph objects of <ref type="bibr" target="#b44">[45]</ref> extend distributed graph transformation by export and import specifications for the local graphs.</p><p>• Several papers have investigated concepts which allow abstracting from details in graphs. Often, graphs which are obtained from an underlying graph by abstracting away certain parts are called views. In <ref type="bibr" target="#b18">[19]</ref>, two views of a graph are created so that the transformation of one view updates the other consistently. Multilevel graph grammars <ref type="bibr" target="#b32">[33]</ref> define the transformation of graphs wherein details can be hidden by abstracting transformations that can be undone as needed. The graphs in <ref type="bibr" target="#b29">[30]</ref> support rigidly layered views. Graphs and the morphisms between them are abstracted to nodes and edges of the next layer. Let us finally discuss some aspects of our notion of transformation which are related to concepts discussed in the literature.</p><p>In the hierarchical setting, the ability of copying, moving, or deleting the contents of frames seems to be of central importance in order to obtain an appropriate notion of transformation. The idea of using variables in order to achieve such effects is also followed in the so-called substitution-based approach to graph transformation <ref type="bibr" target="#b34">[35]</ref>. While this approach was originally defined for flat hypergraphs, the recent paper <ref type="bibr" target="#b28">[29]</ref> introduces a substitution-based version of hierarchical graph transformation that employs a slightly more general concept of variables than in the present paper.</p><p>A rather new idea which has received wide interest is the ambient calculus <ref type="bibr" target="#b8">[9]</ref>. It can be seen as a formalism which allows us to describe the transformation of hierarchical structures of a certain kind. Translated into the setting and terminology of the present paper, the calculus allows frames to execute transformations which move them from one place in the hierarchy to another. Three basic transformations, which are parameterized with the name of another frame, are possible. The transformation in n, executed by a frame m, moves m into n if n is (the name of) one of the frames in the neighbourhood of m:</p><p>The transformation out n, executed by a frame m whose parent frame is n, moves m out of n:</p><p>Finally, if n is a frame within a frame m then the transformation open n, executed by m, erases the frame border around the contents of n and adds it to the contents of m:</p><p>The ambient calculus is intended to describe the behaviour of mobile processes (called ambients) in networks such as the internet, where ambients can move from one place to another under certain conditions. The use of names plays a central role as it allow us to model restricted access: An ambient m cannot get into, move out of, or open another ambient unless it knows its name.</p><p>Due to the different motivations and basic assumptions it seems neither useful nor possible to make a direct comparison of hierarchical graph transformation and the ambient calculus. However, some similarities are obvious. The three transformations described above are quite similar to transformations in our sense, using appropriate rule schemata. A slightly more general concept of variables (based on the substitution-based approach mentioned above) should make it possible to model in n, out n, and open n by rule schemata in a rather straightforward way. However, these rule schemata could be applied everywhere; to incorporate the access restrictions provided by the role of names in the ambient calculus seems to require additional concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>In this paper we have extended graphs to hierarchical graphs wherein certain edges, called frames, contain graphs that may be hierarchical again. We have lifted double-pushout graph transformation to hierarchical graphs by showing how pushouts and pushout complements can be constructed in the category of hierarchical graphs. Furthermore, we have extended rules by frame variables by which frames can be deleted or duplicated with their entire contents, in a single transformation step. This turns out to be valuable for programming with hierarchical graph transformation.</p><p>One direction for future work on hierarchical graph transformation is to lift results of the double-pushout approach to the hierarchical setting, like sequential and parallel commutativity, results on parallelism, concurrency, amalgamation, confluence, and termination.</p><p>Hierarchical graph transformation should also be combined with concepts for structuring and controlling systems of rules. As mentioned in the Introduction, several such concepts (mainly for flat graphs) have been proposed recently <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>A further topic of research is to develop hierarchical graph transformation towards object-oriented programming, as outlined in <ref type="bibr" target="#b27">[28]</ref>. There the idea is to restrict the visibility of frames so that only rules designated to some frame type may inspect or update the contents of frames of this type. Such frame types come close to ''classes,'' and the designated rules correspond to ''methods.'' Then frames can be seen as instantiations of their classes that can only be manipulated by invoking the methods of the class.</p><p>Typing is another concept to be considered if hierarchical graph transformation is to be the basis for a programming language. In <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b28">29]</ref>, types are context-free graph languages specified by hyperedge replacement grammars. The challenge is then to provide algorithms that can statically check whether operations in the form of general transformation rules will always preserve the specified types.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIG. 1 .</head><label>1</label><figDesc>FIG. 1. Two list graphs representing (a) an empty list, (b) a list of length 2.</figDesc><graphic coords="4,90.84,562.05,197.04,60.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FIG. 2 .</head><label>2</label><figDesc>FIG. 2.The concatenation rule and its application.</figDesc><graphic coords="7,42.93,43.21,292.80,158.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIG. 5 .</head><label>5</label><figDesc>FIG. 5.The concatenation rule and its application.</figDesc><graphic coords="15,12.99,41.62,350.64,166.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 3 . 1 .</head><label>31</label><figDesc>Let t: L P l I Q r R be a rule, G ¥ H, and o: L Q G an occurrence morphism. Then the two pushouts in Definition 3.1(1) exist if and only if o satisfies the dangling condition with respect to l. Furthermore, in this case the pushouts are uniquely determined up to isomorphism.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 4 . 2 (</head><label>42</label><figDesc>Transformation by Rule Schemata). A rule schema, denoted by t: L P l I Q r R, is a pair of hierarchical morphisms l: I Q L and r: I Q R, where L, R ¥ H(X), I ¥ H, L is linear, and var(R) ı var(L). If a is a variable assignment for L, then the rule tOE: La / la I 0 ra Ra is an instance of t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>FIG. 6 .</head><label>6</label><figDesc>FIG. 6.The rule schema enter and its application.</figDesc><graphic coords="17,9.00,43.93,359.00,180.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FIG. 7 .</head><label>7</label><figDesc>FIG. 7.The rule schema remove and its application.</figDesc><graphic coords="17,7.00,460.43,364.04,162.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>( 1 )</head><label>1</label><figDesc>If o: L Q G is an occurrence morphism satisfying the dangling condition, then inst(o) is an occurrence morphism for La o satisfying the dangling condition with respect to la o .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>FIG. 9 .FIG. 10 .</head><label>910</label><figDesc>FIG. 9.The compare rules.</figDesc><graphic coords="20,31.95,403.47,314.88,219.06" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>FIG. 11 .</head><label>11</label><figDesc>FIG. 11. The partition rules.</figDesc><graphic coords="22,29.96,41.08,320.16,129.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>FIG. 12 .</head><label>12</label><figDesc>FIG.12. Sorting a list graph by quicksort.</figDesc><graphic coords="23,30.96,74.70,316.32,514.14" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>FIG. 13 .</head><label>13</label><figDesc>FIG. 13. Frame substitution.</figDesc><graphic coords="25,15.99,42.47,346.56,89.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>FIG. 14 .</head><label>14</label><figDesc>FIG. 14.Flattening.</figDesc><graphic coords="25,20.98,509.43,336.72,113.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Definition 1.1 (Hypergraph). A hypergraph H=(V H , E H , att H , lab H ) is a system consisting of two finite sets V H and E H of nodes (or vertices) and hyperedges, a labelling function lab H : E H Q C, and an attachment function att H : E H Q V g H such that, for each hyperedge e, |att H (e)|=type(lab H (e)).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>). A rule t: L P I Q R transforms a graph G into a graph H, denoted by G S t H, if there are an injective morphism o: L Q G, called an occurrence morphism, and two pushouts of the following form:</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Unless they are explicitly named, the three components of a hierarchical graph H are denoted by H ¯, F H , and cts H , respectively. The notations V H , E H , att H , lab H , and A H are used as abbreviations denoting V H ¯, E H ¯, att H ¯, lab H ¯, and A H ¯, respectively. Two list frames representing (a) an empty list, (b) a list of length 2.Furthermore, we denote by X H the set {f ¥ F H | cts H (f) ¥ X} of variable frames of Let G and H be hierarchical graphs such that A G 5 A H =". The disjoint union of G and H is denoted by G+H and yields the hierarchical graph K such thatK ¯=G ¯+H ¯, F K =F G 2 F H , and cts K (f) equals cts G (f) if f ¥ F G and cts H (f) if f ¥ F H .For a hierarchical graph G and a set S={H 1 , ..., H n } of hierarchical graphs, we denote G+H 1 + • • • +H n by G+; H ¥ S H. If H is a hierarchical graph, and A ı A H is such that e ¥ E H 5 A implies att H (e) ¥ (V H 5 A) g , then H| A denotes the restriction of H by A. More precisely, H| A is the hierarchical graph G such that V G =V H 5 A, E G =E H 5 A, att G and lab G are the restrictions of att H and lab H to E G , and</figDesc><table><row><cell>H and by</cell><cell></cell></row><row><cell>var(H)=cts H (X H ) 2 0</cell><cell>var(cts H (f))</cell></row><row><cell>f ¥ F H 0 X H</cell><cell></cell></row><row><cell>the set of variables occurring in H.</cell><cell></cell></row></table><note><p>FIG. 4.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>and n 1 : H 1 Q H be injective hierarchical morphisms in H. Then there are hierarchical morphisms m 2 : G Q H 2 and n 2 : H 2 Q H such that (m 1 , m 2 , n 1 , n 2 ) is a pushout, if and only if n 1 satisfies the dangling condition with respect to m 1 . In this case m 2 and n 2 are uniquely determined. Proof. Let G ¥ H i . Again, we proceed by induction on i. Clearly, if m 2 and n 2 exist, then m 2 must be injective since n 1 p m 1 =n 2 p m 2 is injective. By Corollary 2.2 HIERARCHICAL GRAPH TRANSFORMATION this means that m 2 and n 2 exist if and only if they can be constructed in such a way that the following are satisfied: (1) m 2 and n 2 are such that (m 1 , m 2 , n 1 , n 2 ) is a pushout, (2) for every frame f ¥ F G , the hierarchical morphisms m f 2 and n m 2 (f)</figDesc><table><row><cell>2</cell><cell>are</cell></row><row><cell>constructed recursively, so that</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>and • cts H (f) ¨var(cts H (fOE)) for all variable frames f ¥ X H and all frames fOE ¥ F H 0 X H . Definition 4.1 (Variable Assignment). A variable assignment for H ¥ H(X) is a mapping a: var(H) Q H. The application of a to H is denoted by Ha and is called the instantiation of H by a. It turns every variable frame f ¥ X H into a frame whose contents is a(cts H (f)). That is, Ha=OH ¯, F H , ctsP where</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>, track G, s (u)=track G, s (v) holds only if there are nodes v 0 , ..., v n ¥ V GOE such that v 0 =u, v n =v, and for everyi ¥ [n] there is some f ¥ F G and an index j ¥ [type(s(f))] for which {v i -1 , v i }={att G (f)(j), point s(f) (j)}. The latter implies {g(v i -1 ), g(v i )}={att H (h(f))(j), point y(h(f)) (j)}, which yields the required equation track H, y (g(u))=track H, y (g(v 0 ))=track H, y (g(v n ))=track H, y (g(v)).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>and H 0 =flat(cts H (m(f))) -{p cts H (m(f)) }. Using this, one can construct the required transformation flat(G) S tOE flat(H) as follows.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>To be precise, our approach extends the double-pushout approach with injective matching which is thoroughly studied in<ref type="bibr" target="#b25">[26]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>We thank the referees for helpful remarks and suggestions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Abstract and Concrete Categories</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ada ´mek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Herrlich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Strecker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Graph transformation for specification and programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Andries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kuske</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Computer Programm</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="1" to="54" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Gamma and the chemical reaction model: Ten years after, in &apos;&apos;Coordination Programming: Mechanisms, Models, and Semantics</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Bana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lemétayer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>World Scientific</publisher>
			<biblScope unit="page" from="3" to="41" />
			<pubPlace>Singapore</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Application of graph transformation to visual languages</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bardohl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Minas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
		<editor>Ehrig et al.</editor>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="105" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Graph rewriting aspects of functional programming</title>
		<author>
			<persName><forename type="first">E</forename><surname>Barendsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smetsers</surname></persName>
		</author>
		<editor>Ehrig et al.</editor>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="63" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A framework for adding packages to graph transformation approaches, in &apos;&apos;Theory and Application of Graph Transformation (TAGT&apos;98), Selected Papers</title>
		<author>
			<persName><forename type="first">G</forename><surname>Busatto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mehner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1764</biblScope>
			<biblScope unit="page" from="352" to="367" />
			<date type="published" when="2000">2000</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York/Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Comparing notions of hierarchical graph transformation, in &apos;&apos;Proc. Graph Transformation and Visual Modelling Techniques</title>
		<author>
			<persName><forename type="first">G</forename><surname>Busatto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hoffmann</surname></persName>
		</author>
		<ptr target="http://www.elsevier.nl/locate/entcs" />
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2001">2001</date>
			<publisher>Elsevier</publisher>
			<pubPlace>Amsterdam/New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Abstract Hierarchical Graph Transformation,&apos;&apos; Informatik-Bericht 1/01</title>
		<author>
			<persName><forename type="first">G</forename><surname>Busatto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kuske</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Fachbereich Mathematik-Informatik, Universität Bremen</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Mobile ambients</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">240</biblScope>
			<biblScope unit="page" from="177" to="213" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Graph Grammars and Their Application to Computer Science and Biology, Selected Papers</title>
		<author>
			<persName><forename type="first">V</forename><surname>Claus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Ehrig</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<date type="published" when="1979">1979</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York/Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Algebraic approaches to graph transformation-Part I. Basic concepts and double pushout approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Corradini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Löwe</surname></persName>
		</author>
		<editor>Rozenberg</editor>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="163" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Graph Grammars and Their Application to Computer Science, Selected Papers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Cuny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1073</biblScope>
			<date type="published" when="1996">1996</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York/Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Hyperedge replacement graph grammars</title>
		<author>
			<persName><forename type="first">F</forename><surname>Drewes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Rozenberg</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="95" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<author>
			<persName><forename type="first">F</forename><surname>Drewes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hierarchical graph transformation, in &apos;&apos;Proc. Foundations of Software Science and Computation Structures (FOSSACS 2000)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>New York/Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1784</biblScope>
			<biblScope unit="page" from="98" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Introduction to the algebraic theory of graph grammars</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<editor>Claus et al.</editor>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A view-oriented approach to system modelling using graph transformation, in</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">&apos;&apos;Proc. ESEC/FSE &apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>New York/Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1301</biblScope>
			<biblScope unit="page" from="327" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Handbook of Graph Grammars and Computing by Graph Transformation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename></persName>
		</author>
		<editor>. Kreowski, and G. Rozenberg</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>World Scientific</publisher>
			<biblScope unit="volume">II.</biblScope>
			<pubPlace>Singapore</pubPlace>
		</imprint>
	</monogr>
	<note>Applications, Languages, and Tools</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Handbook of Graph Grammars and Computing by Graph Transformation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<editor>U. Montanari, and G. Rozenberg</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>World Scientific</publisher>
			<biblScope unit="volume">III.</biblScope>
			<pubPlace>Singapore</pubPlace>
		</imprint>
	</monogr>
	<note>Concurrency, Parallelism, and Distribution</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">A view-based approach to system modelling based on open graph transformation systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
		<editor>Ehrig et al.</editor>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="639" to="668" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Graph transformation as a conceptual and formal framework for system modelling and evolution, in</title>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">&apos;&apos;Proc. Automata, Languages, and Programming (ICALP 2000)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1853</biblScope>
			<biblScope unit="page" from="127" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Encapsulated hierarchical graphs, graph types, and meta types, in &apos;</title>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<ptr target="http://www.elsevier.nl/locate/entcs" />
	</analytic>
	<monogr>
		<title level="j">Proc. Joint Compugraph/Semagraph Workshop on Graph Rewriting and Computation</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">The Agg approach: Language and environment</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ermel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rudolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
		<editor>Ehrig et al.</editor>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="551" to="603" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">P</forename><surname>Fradet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Le</forename><surname>Métayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Structured Gamma, Sci. Comput. Programm</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="263" to="289" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Dactl: An experimental graph rewriting language, in &apos;&apos;Graph Grammars and Their Application to Computer Science, Selected Papers</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Glauert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kennaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Ronan</forename><surname>Sleep</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">532</biblScope>
			<biblScope unit="page" from="378" to="395" />
			<date type="published" when="1991">1991</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York/Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Hyperedge Replacement: Grammars and Languages</title>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">643</biblScope>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York/Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Double-pushout graph transformation revisited</title>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Structures Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="637" to="688" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Classification and comparison of module concepts for graph transformation system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Heckel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
		<editor>Ehrig et al.</editor>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="669" to="689" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">From graph transformation to rule-based programming with diagrams, in &apos;&apos;Proc Applications of Graph Transformations with Industrial Relevance (AGTIVE &apos;99), Selected Papers</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hoffmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1779</biblScope>
			<biblScope unit="page" from="165" to="180" />
			<date type="published" when="2000">2000</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Shapely hierarchical graph transformation, in &apos;&apos;Proc. Int. Symposium of Visual Languages and Formal Methods (VLFM &apos;01)</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hoffmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>IEEE Computer Press</publisher>
			<biblScope unit="page" from="30" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">AGG-An implementation of algebraic graph rewriting, in &apos;&apos;Proc. Rewriting Techniques and Applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Löwe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Beyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">690</biblScope>
			<biblScope unit="page" from="451" to="456" />
			<date type="published" when="1993">1993</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York/Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Concepts and realization of a diagram editor generator based on hypergraph transformation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Minas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Programm</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The Design of an Extendible Graph Editor</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Newbery</forename><surname>Paulisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">704</biblScope>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York/Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Multi-level graph grammars, in &apos;&apos;Graph-Theoretical Concepts in Computer Science (WG &apos;94)</title>
		<author>
			<persName><forename type="first">F</forename><surname>Parisi-Presicce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Piersanti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">903</biblScope>
			<biblScope unit="page" from="51" to="64" />
			<date type="published" when="1995">1995</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York/Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Term graph rewriting, in &apos;&apos;Handbook of Graph Grammars and Computing by Graph Transformation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>World Scientific</publisher>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="3" to="61" />
			<pubPlace>Singapore</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Graph unification and matching</title>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<editor>Cuny et al.</editor>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="75" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Hyperlog: A graph-based system for database browsing, querying, and update</title>
		<author>
			<persName><forename type="first">A</forename><surname>Poulovassilis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Hild</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Knowledge Data Eng</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="216" to="333" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Pair grammars, graph languages and string-to-graph translations</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Pratt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="560" to="595" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Definition of programming language semantics using grammars for hierarchical graphs</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Pratt</surname></persName>
		</author>
		<editor>Claus et al.</editor>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="389" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A graph rewriting programming language for graph drawing, in &apos;</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Rodgers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th IEEE Symposium on Visual Languages</title>
		<meeting>14th IEEE Symposium on Visual Languages</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Handbook of Graph Grammars and Computing by Graph Transformation</title>
	</analytic>
	<monogr>
		<title level="j">I. Foundations,&apos;&apos; World Scientific</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Singapore</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The Unified Modelling Language Reference Manual</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Booch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Object Technology Series</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<pubPlace>Addison-Wesley, Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">On categorical graph grammars integrating structural transformations and operations on labels</title>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">109</biblScope>
			<biblScope unit="page" from="257" to="274" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">The PROGRES approach: Language and environment, in &apos;&apos;Handbook of Graph Grammars and Computing by Graph Transformation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zündorf</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>World Scientific</publisher>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="487" to="550" />
			<pubPlace>Singapore</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Hierarchically distributed graph transformation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
		<editor>Cuny et al.</editor>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="304" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">DIEGO, another step towards a module concept for graph transformation systems, in &apos;&apos;Proc. Joint Compugraph/Semagraph Workshop on Graph Rewriting and Computation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<ptr target="http://www.elsevier.nl.locate/entcs" />
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><surname>Tapken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Implementing hierarchical graph structures, in &apos;&apos;Proc. Formal Aspects of Software Engineering (FASE&apos;99)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>New York/ Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1577</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
