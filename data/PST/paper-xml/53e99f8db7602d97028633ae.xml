<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">QUAD: A Practical Stream Cipher with Provable Security</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Côme</forename><surname>Berbain</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Telecom Research and Development</orgName>
								<address>
									<addrLine>38-40 rue du Général Leclerc</addrLine>
									<postCode>F-92794</postCode>
									<settlement>Issy-les-Moulineaux</settlement>
									<country>France, France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Henri</forename><surname>Gilbert</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Telecom Research and Development</orgName>
								<address>
									<addrLine>38-40 rue du Général Leclerc</addrLine>
									<postCode>F-92794</postCode>
									<settlement>Issy-les-Moulineaux</settlement>
									<country>France, France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jacques</forename><surname>Patarin</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Université de Versailles</orgName>
								<address>
									<addrLine>45 avenue des Etats-Unis</addrLine>
									<postCode>F-78035</postCode>
									<settlement>Versailles cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">QUAD: A Practical Stream Cipher with Provable Security</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4CD0BC2FD4D2BBE1567E7579C248A278</idno>
					<idno type="DOI">10.1007/978-3-540-34547-3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce a practical stream cipher with provable security named QUAD. The cipher relies on the iteration of a multivariate quadratic system of m equations in n &lt; m unknowns over a finite field. The security of the keystream generation of QUAD is provably reducible to the conjectured intractability of the MQ problem, namely solving a multivariate system of quadratic equations. Our recommended version of QUAD uses a 80-bit key, 80-bit IV and an internal state of n = 160 bits. It outputs 160 keystream bits (m = 320) at each iteration until 2 40 bits of keystream have been produced.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Stream ciphers represent, together with block ciphers, one of the two main classes of symmetric encryption algorithms. Generally speaking stream ciphers seem to allow faster encryption and to require lower computing resources than block ciphers, and the fastest known stream ciphers (e.g. SEAL, RC4, SNOW 2.0, the Shrinking Generator) are indeed significantly faster in software than an efficient block cipher such as AES <ref type="bibr" target="#b26">[27]</ref>. However, the design of secure stream ciphers is not currently as well understood as the design of secure block ciphers. The state of the art of the cryptanalysis of stream ciphers, e.g. LFSR based stream ciphers, has evolved significantly over the last ten years and many recent proposals still suffer from security weaknesses. This is illustrated by the fact that none of the candidate stream ciphers submitted to the call for cryptographic primitives of the European project NESSIE were retained since attacks more efficient than exhaustive search were found for all candidates during the evaluation period. This is also illustrated by the ongoing eSTREAM <ref type="bibr" target="#b10">[11]</ref> call for stream ciphers proposals of the European project ECRYPT. Stream ciphers complying with two main profiles have been called for, namely stream ciphers allowing much faster software encryption than existing block ciphers (profile 1) and stream ciphers requiring much lower resources for hardware implementation than existing block ciphers (profile 2). However, more than one third of the 34 submitted stream ciphers, which cover these two profiles, have already been shown to be insecure.</p><p>Our aim is to propose a practical cipher with unusually strong security arguments. The novel stream cipher we propose was designed with another tradeoff between security, speed and computing resources than reflected by the eS-TREAM profiles 1 and 2. We slightly relax the requirements on speed and computing resources, i.e. we only require a stream cipher that is sufficiently fast for most practical purposes. But we introduce an unusually strong security requirement for symmetric cryptography (which is out of reach of the current state of the art for block ciphers), namely that the security of the cipher be provably reducible to the conjectured intractability of a well-known and studied mathematical problem. The security of the novel stream cipher is provably reducible to the intractability of the MQ problem <ref type="bibr" target="#b14">[15]</ref>, which consists of finding a solution (if any) to a multivariate quadratic system of m quadratic equations in n variables over a finite field GF (q), typically GF <ref type="bibr" target="#b1">(2)</ref>. The MQ problem is conjectured to be difficult for suitably chosen values of n and m. In general the associated decision problem is known to be NP-complete even in the case where the considered field is GF <ref type="bibr" target="#b1">(2)</ref>, and moreover no efficient algorithm to solve MQ with a significant success probability is known to exist for sufficiently large values of n (say n &gt; 100) when the quadratic equations are randomly chosen. The implementation complexity of our stream cipher is reasonable and the encryption speed (4.6 Mbit/s for a software implementation in C on a standard PC), though lower than AES, is more than sufficient for many practical purposes.</p><p>Constructing a provably secure stream cipher is not a novel topic. However, designing a practical provably secure stream cipher is an open problem. Following seminal work by Shamir, Blum and Micali <ref type="bibr" target="#b3">[4]</ref>, Yao <ref type="bibr" target="#b30">[31]</ref>, Levin and Goldreich <ref type="bibr" target="#b24">[25]</ref> in the 80's, considerable research effort has been dedicated to the construction of provably secure pseudo-random number generators (PRNG) that expand a short seed (e.g. a key) into a larger bit string. This can be used as the keystream for encryption purposes. Available security results typically state that if the iterated function underlying the construction of a number generator satisfies suitable onewayness properties, then the generator is a secure PRNG, i.e. its L-bit output is computationally indistinguishable from the uniform distribution over {0, 1} L . This research effort has led to remarkable generic results, e.g. the proof by Impagliazzo, Levin, Luby and Håstad <ref type="bibr" target="#b20">[21]</ref> that a secure PRNG can be constructed based upon any one way function (OWF). It has also led to provably secure PRNG constructions based on the conjectured intractability of specific problems. The first provably secure PRNG was introduced by Blum and Micali <ref type="bibr" target="#b3">[4]</ref> and relates the security of the PRNG to the one-wayness of exponentiation modulo a prime number. The provably secure PRNG proposed by L. Blum, M. Blum and M. Shub <ref type="bibr" target="#b2">[3]</ref> exploits the conjectured intractability of quadratic residuosity modulo Blum integers. Alexi, Chor, Goldreich and Schnorr proposed a PRNG construction with security that relies upon the RSA assumption. Impagliazzo and Naor <ref type="bibr" target="#b23">[24]</ref> and Fisher and Stern <ref type="bibr" target="#b12">[13]</ref> proposed PRNG constructions respectively relying on the difficulty of the subset sum problem and of the syndrome decoding problem. Even in the case of specific constructions, current provably secure PRNGs are too inefficient to provide a practical stream cipher. This is due to the fact that the function iterated by the PRNG is usually too computationally expensive, and that only a restricted number of bits can be produced at each iteration (this number is generally at most proportional to the logarithm of the input length n of the iterated function). However some efforts have been made to improve the constructions. A first idea is to extract more than log n bits at each round. Constructions based on the discrete logarithm problem makes it possible to extract nlog(n) bits at each iteration instead of log n. Despite this fact, the fastest generator based on discrete logarithm proposed by Gennaro <ref type="bibr" target="#b15">[16]</ref> is still impractical: it requires 350 multiplications of 3000-bit numbers to extract 2775 bits. Another problem for which it is possible to extract more than log n bits is the syndrome decoding problem. A PRNG has been proposed by Fisher and Stern in <ref type="bibr" target="#b12">[13]</ref> but the number of extracted bits, although higher than log n, is still small for practical values of n. Another recently proposed idea is to replace a slow iterated function by some primitive which is much faster to compute. Håstad and Näslund proposed BMGL <ref type="bibr" target="#b29">[30]</ref>, a stream cipher with security that relies on the difficulty of extracting the key from one plaintext ciphertext couple in AES. Their practical construction consists of iterating AES and extracting log n bits at each round. This cipher is fast, especially compared to other provably secure ciphers, but its security relies only on the security of the AES and not on a simple and well-studied mathematical problem.</p><p>On the contrary, MQ is a simple and well-studied mathematical problem and the values of n for which the problem is difficult are small (around 100 bits), particularly when compared to discrete logarithm or factorisation, where at least 1024 bits are required. Furthermore a large number of bits (e.g. n</p><p>2 ) bits or even more can be produced at each iteration.</p><p>This paper is organized as follows. We first give some preliminary background on the status of the MQ problem and basic security definitions in a concrete (non asymptotic) security model. Then we describe the new construction and give a formal proof of security for the associated keystream generator. Finally we give the encryption speed of software implementations of our stream cipher.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Multivariate Quadratic Systems</head><p>We consider a finite field GF (q). A multivariate quadratic equation (or equivalently a multivariate quadratic form) in n variables over GF (q) is a polynomial of degree at most 2 in GF (q)[x 1 , . . . , x n ] which can be written as</p><formula xml:id="formula_0">Q(x) = 1≤i≤j≤n α i,j x i x j + 1≤i≤n β i x i + γ</formula><p>with all the coefficients α i,j , β i , and γ in GF (q). In the particular case q = 2, which will be considered in the sequel, the monomial forms x i x i and x i are equal.</p><p>It is easy to see that the set Q of multivariate quadratic forms in n variables is an N -dimensional vector space over GF (q), where N = n(n+3) 2 + 1 if q = 2 and N = n(n+1) 2 + 1 if q = 2. A basis of this vector space is given by the N -1 distinct monomial functions of degree 1 or 2 and the constant form 1. Any element of Q can be represented by the N -tuple of its GF (q) coefficients in this basis. Throughout the rest of this paper, we mean by a randomly chosen quadratic form in n unknowns the quadratic form represented in the above basis by a uniformly and independently drawn N -tuple of GF (q) coefficients.</p><p>A multivariate quadratic system S of m quadratic equations in n variables over GF (q) is a set (Q 1 , . . . Q m ) of m quadratic equations in n variables over GF (q). In the sequel, we mean by a randomly chosen system of m quadratic form in n unknowns, n independently and randomly chosen quadratic forms. Such a system is represented by mN uniformly and independently drawn GF (q) coefficients.</p><p>A quadratic form Q over n unknowns over GF (2) is called non degenerate iff Q is not equivalent to a quadratic form in strictly fewer than n linear combinations of the n input variables. There exists a polynomial time algorithm to check whether a given quadratic form is non degenerate and more generally to compute the so-called rank of a quadratic form <ref type="bibr" target="#b25">[26]</ref>. The number of solutions of the quadratic equation Q = 0 associated with a non degenerate quadratic form Q</p><formula xml:id="formula_1">over n unknowns is either 2 n-1 or 2 n-1 + 2 n-2 2 or 2 n-1 -2 n-2 2</formula><p>depending on the parity of n and the value of γ. Thus for sufficient large values of n, say n &gt; 100, non degenerate quadratic forms are either perfectly balanced (odd n values) or have an undetectable bias (even n values).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Status of the MQ Problem</head><p>We define the problem of solving simultaneous multivariate quadratic equations (MQ problem) as follows: given a multivariate quadratic system of m quadratic equations over GF (q) S = (Q 1 , . . . , Q m ), find a value x ∈ GF (q) n , if any, such that Q i (x) = 0 for all 1 ≤ i ≤ m.</p><p>Depending on the respective values of n and m, instances of MQ can be either easy or very difficult to solve. For m = 1 the number of solutions is known <ref type="bibr" target="#b25">[26]</ref> and it is quite easy to find one solution. When m is significantly smaller than n, that is for an underdefined quadratic system, finding a solution is easy <ref type="bibr" target="#b5">[6]</ref>. In the opposite situation of an overdefined system (m &gt; n) providing N = n(n+1) 2 + 1 (q = 2 case) or n(n+3) 2 + 1 (q = 2 case) linearly independent quadratic equations, or more generally when nearly N linearly independent quadratic equations are available, solving an MQ problem is easy by linearization. The total complexity is then only O(n 6 ). However for general values of m and n the MQ problem is known to be NP-hard, even when restricted to quadratic equations over GF (2) <ref type="bibr" target="#b14">[15]</ref>  <ref type="bibr" target="#b13">[14]</ref> or over any finite field <ref type="bibr" target="#b27">[28]</ref>.</p><p>Moreover, what seems to make the MQ problem particularly well suited to cryptographic applications is that it is conjectured to be very difficult not only asymptotically and in worst case, but already for small suitably selected values of m and n and in terms of the average complexity of solving a random instance. The problem seems to be most difficult when m is close to n. For m = n and q = 2 the complexity of the best known solving algorithms is 2 n-O( √ (n)) and thus rather close to the 2 n complexity of exhaustive search, and totally out of reach of existing computers for a random instance and n values larger than 100. Even when q = 2, m = kn and k &gt; 1 is small enough compared with n 2 , the best known computer algebra algorithms such as XL <ref type="bibr" target="#b9">[10]</ref> and improved variants of Buchbergers's Groebner basis computation algorithm such as Faugère's F4 and F5 algorithms <ref type="bibr" target="#b11">[12]</ref> are exponential in n for a randomly chosen quadratic system. Much research has been dedicated in the past years to the above problem <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b6">[7]</ref>. Magali Bardet's PHD thesis <ref type="bibr" target="#b0">[1]</ref> provides an accurate analysis of the complexity of the most efficient known Groebner basis computation algorithm for solving a random system of m = kn equations in n unknowns. We will use some complexity estimates of <ref type="bibr" target="#b0">[1]</ref> when discussing practical recommendations of the parameter values of our cipher.</p><p>Though we expect degenerate instances of the systems used in our construction leading to a weak stream cipher to be extremely unlikely, we suggest the following extra precaution when drawing these systems at random to provide some extra guaranties that some of the weakest instances are avoided: check that each quadratic equation is non degenerate or at least has a high rank value close to the one of a non degenerate form, and discard any quadratic equation which would not satisfy this condition. In order to discard a slightly larger subset of weak instance, one can also check that low weight linear combinations of the selected quadratic equations satisfy the above rank conditions. Also check that the obtained quadratic equations are linearly independent in Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Basic Security Notions</head><p>All the security definitions used throughout this paper relate to the concrete (non asymptotic) security model. We are using the following basic security notions that we state here informally. Two probability distributions D 1 and D 2 over a finite set Ω are said to be computationally distinguishable with computing resources R and advantage if there exits a probabilistic testing algorithm A which on any input value x ∈ Ω outputs a binary answer "1" (accept) or "0" (reject) using computing resources at most R and satisfies</p><formula xml:id="formula_2">|P r x∈D1 (A(x) = 1) -P r x∈D2 (A(x) = 1)| ≥ .</formula><p>Though this is not explicitly reflected in our notation, the above probabilities are not only taken over x values distributed according to D 1 or D 2 , but also over the random choices of algorithm A. Algorithm A is called a distinguisher with advantage . If no such algorithm exists, then we say that D 1 and D 2 are computationally indistinguishable with advantage better than . When the computing resources R is not specified, we implicitly mean feasible computing resources (i.e. say less than 2 80 simple operations).</p><p>Let n and L denote integers such that L &gt; n. A n-bit to L-bit function G is said to be a Pseudo Random Number Generator (PRNG) if for a ran-dom n-bit input variable x selected according to the uniform law on {0, 1} n the probability distribution of the random variable G(x) is computationally indistinguishable from the uniform law over {0, 1} L .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">QUAD: A New Stream Cipher</head><p>We now introduce the proposed stream cipher, named QUAD. S = (Q 1 , . . . , Q kn ) denotes a multivariate quadratic system of kn randomly chosen equations in n variables over GF (q), and S 0 and S 1 denote two (k times smaller) additional multivariate systems of n randomly chosen equations in n variables over GF (q). S, S 0 and S 1 are fixed and publicly known. During the key and IV loading and the keystream generation, the internal register state is a x = (x 1 , . . . , x n ) n-tuple of GF (q) values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Keystream Generation and Encryption</head><p>The keystream generation process simply consists in iterating the three following steps in order to produce (k -1)n GF (q) keystream values at each iteration.</p><formula xml:id="formula_3">-Compute the kn-tuple of GF (q) values S(x) = (Q 1 (x), . . . , Q kn (x)) where x</formula><p>is the current value of the internal state;</p><formula xml:id="formula_4">-Output the sequence S out (x) = (Q n+1 (x), . . . , Q kn (x)) of (k -1)n GF(q)</formula><p>keystream values -Update the internal state x with the sequence of n GF(q) first generated values</p><formula xml:id="formula_5">S it (x) = (Q 1 (x), . . . , Q n (x))</formula><p>The maximal keystream sequence that may be generated with a single (key,iv) pair is L GF (q) values. In order to encrypt a plaintext of length l ≤ L GF (q) symbols, each of the first l GF(q) values of the keystream sequence is added (using the GF (q) addition) with the corresponding plaintext value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>x S it (x)</head><p>S out (x)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Key and IV Setup</head><p>Before generating any keystream we need to initialize the internal state x, with the key K and the initialization vector IV , which are respectively represented by a sequence of GF (q) elements of length |K| and a binary sequence of {0, 1} values of length |IV |. We assume for the time being, for simplicity of the subsequent proofs<ref type="foot" target="#foot_0">1</ref> that |K| is chosen exactly equal to n. The initialization is done as follows : we use two carefully randomly chosen multivariate quadratic systems S 0 and S 1 of n equations over n unknowns. We initially set the internal state value x to the n bit value K. Then for each of the |IV | bits IV 1 to IV |IV | of the IV value the internal state x is updated as follows: if IV i = 0, x is replaced by the GF (q) n value S 0 (x) ; if IV i = 1, x is replaced by the GF (q) n value S 1 (x). These |IV | steps provide a key and IV dependent internal state value x. We then clock the cipher |IV | additional times as described in section 3.1, but without outputting the keystream in order to further transform the internal state value x, and then enter the keystream generation mode to produce the keystream.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Security</head><p>We now give a proof that for a randomly chosen multivariate quadratic system our PRNG is secure. For simplicity of the proof we will work over GF <ref type="bibr" target="#b1">(2)</ref>. The proof can be divided in three parts, which can be informally outlined as follows.</p><p>In the first part (Theorem 1), we prove that if the L-bit keystream sequence associated with a known fixed or randomly chosen system S of m = kn quadratic equations and an unknown randomly chosen initial internal state x ∈ {0, 1} n is distinguishable from the L-bit output of a perfectly uniform generator, then for a known random quadratic system S of m = kn equations and an unknown randomly chosen input value x ∈ {0, 1} n , S(x) is distinguishable from a random kn bit word.</p><p>In the second part (Theorem 2), we prove that if for a known randomly chosen quadratic system S and an unknown randomly chosen x, S(x) is distinguishable from a random kn bit word then, for any n-bit to 1-bit quadratic form R (in particular any linear form R), one has the property that for a randomly chosen n bit value x, R(x) can be predicted better than at random given S(x).</p><p>In the third part (Theorem 3), we prove that, for a known fixed or randomly chosen S and a randomly chosen linear form R, R(x) can be predicted better than at random given S(x), then with non negligible probability a preimage of S(x) can be efficiently computed given S(x). Thus S is not strongly one way. This part is essentially a proof of Goldreich-Levin's theorem <ref type="bibr" target="#b24">[25]</ref>, in which a fast Walsh transform computation is used to get a tighter reduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Distinguishing the Keystream Allows to Distinguish the Output of a Random Quadratic System</head><p>Theorem 1 states that if one can distinguish the keystream of the generator based on the iteration of a quadratic system S from a random L-bit sequence, then one can distinguish the output of S from a random m-bit sequence. Though we consider a randomly chosen system S because we need distinguishing properties related to a random system for the sequel, the property we prove would also hold if we considered a fixed system S. Our proof is inspired by the proof given in <ref type="bibr" target="#b19">[20]</ref> that a similar result holds for the generator based on iteration of any fixed n-bit to m-bit function, where m &gt; n, but provides a tighter bound for the advantage.</p><p>Theorem 1. Let L = λ(k -1)n be the number of keystream bits produced in time λT S using λ iterations of our construction. Suppose there is an algorithm A that distinguishes the L-bit keystream sequence associated with a known randomly chosen system S and an unknown randomly chosen initial internal state x ∈ {0, 1} n from a random L-bit sequence in time T with advantage . Then there exists an algorithm B that for a randomly chosen S distinguishes S(x) corresponding to an unknown random input x, from a random value of size kn in time T = T + λT S with advantage λ .</p><p>Proof. We introduce the hybrid probability distributions D i (S) over {0, 1} L xi. For 0 ≤ i ≤ λ respectively associated with the random variables</p><formula xml:id="formula_6">t i (S, x) = (r 1 , r 2 , . . . , r i , S out (x), S out (S it (x)), . . . , S out (S λ-i-1 it (x)))</formula><p>where the r j and x are random independent uniformly distributed values of {0, 1} n and the notational conventions that (r 1 , r 2 , . . . , r i ) is the null string if i = 0 and that (S out (x), . . . , S out (S</p><formula xml:id="formula_7">λ-i-1) it (x))</formula><p>) is the null string if i = λ. Consequently D 0 (S) is the distribution of the L-bit keystream and D λ (S) is the uniform distribution over {0, 1} L . We denote by p i (S) the probability that A accepts a random L-bit sequence distributed according to D i (S), and denote by p i the average value of p i (S) over the (k -1)n(n (n+1) 2 + 1)-dimensional vector space of quadratic systems S. We have supposed that algorithm A distinguishes between D 0 (S) and D λ (S) with advantage , in other words that |p 0p λ | ≥ . Algorithm B works as follows : on input (x 1 , x 2 ) ∈ {0, 1} kn with x 1 ∈ {0, 1} n and x 2 ∈ {0, 1} (k-1)n , it selects randomly an i such that 0 ≤ i ≤ λ -1 and constructs the L-bit vector</p><formula xml:id="formula_8">t(S, x 1 , x 2 ) = (r 1 , r 2 , . . . , r i , x 2 , S out (x 1 ), S out (S it (x 1 )), . . . , S out (S λ-i-2 it (x 1 ))). If (x 1 , x 2 ) is distributed accordingly to the output distribution of S, i.e. (x 1 , x 2 ) = S(x) = (S it (x), S out (x)) for a uniformly distributed value of x, then t(S, x 1 , x 2 ) = (r 1 , r 2 , . . . , r i , S out (x), S out (S it (x)), . . . , S out (S λ-i-1 it (x))) is distributed according to D i (S). Now if (x 1 , x 2 ) is distributed according to the uniform distribution, then t(S, x 1 , x 2 ) = (r 1 , r 2 , . . . , r i , x 2 , S out (x 1 ), S out (S it (x 1 )), . . . , S out (S λ-i-2 it (x 1 ))).</formula><p>Thus t(S, x 1 , x 2 ) is distributed according to D i+1 (S). In order to distinguish the output distribution of S from the uniform law, algorithm B calls algorithm A with inputs (S, t(S, x 1 , x 2 )) and returns the value returned by A.</p><formula xml:id="formula_9">Thus |P r S,x (B(S, S(x)) = 1) -P r S,x1,x2 (B(S, (x 1 , x 2 )) = 1)| = | 1 λ λ-1 i=0 p i - 1 λ λ i=1 p i | = 1 λ |p 0 -p λ | ≥ λ .</formula><p>Thus B distinguishes the output distribution of S from the uniform distribution with probability at least λ in time T + λT S .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Distinguishing the Output of a Random Quadratic System Allows to Predict Any Quadratic Equation</head><p>Now we prove that if there exists a distinguisher between S(x) and a kn-bit random value such as the one considered in the above theorem, it can be converted into an algorithm that predicts the result of any quadratic polynomial (and in particular any linear polynomial).</p><p>Theorem 2. Suppose there is an algorithm A that, given a randomly chosen known multivariate quadratic system S of kn equations in n unknowns, distinguishes S(x), where x is an unknown random input value, from a random string of length kn with advantage at least and in time T . Then there is an algorithm B that, given a randomly chosen quadratic system S of kn equations in n unknowns, any n-bit to 1-bit quadratic form R, and y = S(x) where x is a random input value, predicts R(x) with success probability at least 1 2 + 4 using at most T = T + 2T S operations.</p><p>Proof. We first show that there exists an algorithm A which returns 1 on input (S, S(x)) with probability at least 1  2 + 2 and returns 1 on input (S, u) for some random u with probability 1 2 : if the acceptance probability of A is larger (by at least ) on an input (S, S(x)) than on a random input. Then it suffices to consider A which on input (S, r) either returns A(S, r) or draws a random value u and returns 1 -A(S, u) with probability 1  2 for each case. In the opposite situation, it suffices to consider A which on input (S, r) either returns 1 -A(S, r) or draws a random value and returns A(S, u) with probability 1  2 for each case. Algorithm B works as follows. On input S = (Q 1 , . . . Q kn ),R and a kn-bit value y, B selects a random kn-bit vector a = (a 1 , . . . , a kn ) and a random bit b, which represents an hypothesis for R(x). Then it computes for all i from 1 to kn the quadratic equation</p><formula xml:id="formula_10">P i = Q i + (a i • R).</formula><p>All the equations P i form the quadratic system S . Then B invokes the algorithm A with input the new quadratic system S and the value y + (b • a). Finally B returns what A returns. Now assume that y = S(x) where x is an unknown random value. We have ∀i, x,</p><formula xml:id="formula_11">P i (x) = Q i (x) + (a i • R(x)) = y i + (a i • R(x)).</formula><p>Suppose b is really equal to R(x), then S (x) = y + (b • a) so the distinguisher A' has been fed with the random quadratic system S = (P 1 , • • • , P kn ) and S (x): Thus we have:</p><formula xml:id="formula_12">P r S,x∈Un (B(S, S(x), R) = R(x)) ≥ 1 2 1 2 + 2 + 1 2 = 1 2 + 4</formula><p>The total running time of B is at most T + 2T S , since computing the kn P i requires for each i to compute all the n(n-1) 2 monomials of Q i and R, which does not cost more than two evaluations of the system for some entry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">A Linear Form Is a Hard Core Bit for Any One Way Function</head><p>Now we show that if for a fixed or random quadratic system S and more generally any fixed or random n-bit to m-bit function f there exists a predictor such as the one considered in the former theorem, i.e. a predictor allowing, given an n-bit to 1-bit linear form R, to predict R(x) with a success probability (over all S and x values) strictly larger than 1  2 , then a preimage of S(x) (resp. f(x)) can be efficiently computed, so that S (resp f) is not one way. This result is the Goldreich-Levin theorem <ref type="bibr" target="#b24">[25]</ref> that we prove as to get a tight reduction. Before proving the theorem, which relates to the computation, given the image S(x) or f (x) for a random unknown value x and a random system S, of a list containing x, we first establish a lemma representing the technical core of the proof in which a fixed (unknown) value of x is considered. Our proofs are inspired by the simplified treatment of the original Goldreich-Levin proofs developed by Rackoff, Goldreich <ref type="bibr" target="#b17">[18]</ref> and Bellare <ref type="bibr" target="#b1">[2]</ref>, and also by the proofs provided by Håstad and Näslund in their BMGL paper <ref type="bibr" target="#b29">[30]</ref>. 1  2 + over R, using at most T operations. Then there exists an algorithm C, which given f (x) produces in time at most T a list of at most 4n 2 -2 values such that the probability that x appears in this list is at least 1/2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1. Let us denote by x a fixed unknown n-bit value and denote by f a fixed n-bit to m-bit function. Suppose there exists an algorithm B that given the value of f (x) allows to predict the value of any linear equation R over n unknowns with probability</head><formula xml:id="formula_13">T = 2n 2 2 T + log 2n 2 + 2 + 2n 2 T f</formula><p>The proof of lemma 1 is given in the Appendix. Lemma 1 applies to a fixed x and a fixed system S (or a fixed n-bit to m-bit function f ). However, the success probability of the predictor of Theorem 2 is taken over all (x, S) pairs for any linear form R. Consequently, we need a theorem allowing us to exploit the existence of such a predictor to show the applicability of the lemma to a non-negligible fraction of (x, S) pairs. Theorem 3. Suppose there is an algorithm B, that given a randomly chosen quadratic system S of m quadratic equations, a randomly chosen n-bit to 1bit quadratic form R and the image S(x) of a randomly chosen (unknown) nbit value x, predicts the value of R(x) with probability at least 1  2 + over all possible (x, S, R) triplets using T operations. Then there is an algorithm C, which given the image S(x) of a randomly chosen (unknown) n-bit value x produces a preimage of S(x) with probability at least /2 (over all possible values of x and S) in time T .</p><formula xml:id="formula_14">T = 8n 2 2 T + log 8n 2 + 2 + 8n 2 T f Proof.</formula><p>The assumption about algorithm B can be written as</p><formula xml:id="formula_15">P r (x,S,R)∈{0,1} n+mN +n {B(S, S(x), R) = R(x)} ≥ 1 2 + .</formula><p>It results that for a fraction at least of all the (x, S) pairs one has</p><formula xml:id="formula_16">P r R∈{0,1} n {B(S, S(x), R) = R(x)} ≥ 1 2 + 2 .</formula><p>Otherwise, there would exist a fraction at least 1of the (x, S) pairs which associated prediction probability over the R values would be strictly less than 1 2 + 2 , and therefore P r (x,S,R)∈{0,1} n+mN +n {B(S, S(x), R) = R(x)} would be upper bounded by (1 -)( 1 2 + 2 ) + = 1 2 + -2 , which contradicts the assumption about Algorithm B.</p><p>Thus for a fraction at least of all the (x, S) pairs the conditions of lemma 1 are met and algorithm C of the lemma provides a preimage of S(x) with probability at least 1/2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">A Security Proof for the Proposed PRNG</head><p>Now it is easy to see that if we sequentially apply theorems 1, 2, and 3, we obtain the following reduction theorem, which states that if, for a random system and a random initial value, the L-bit keystream sequence was distinguishable from a random L-bit sequence then there would exist an efficient algorithm allowing to find a preimage of the image of a random n-bit input value by a random quadratic n-bit to m-bit system, which for suitably chosen values of n would contradict the assumptions made in Section 2 on the difficulty of solving MQ. Theorem 4. Let L = λ(k -1)n be the number of keystream bits produced by in time λT S using λ iterations of our construction. Suppose there exists an algorithm A that distinguishes the L-bit keystream sequence associated with a known randomly chosen system S and an unknown randomly chosen initial internal state x ∈ {0, 1} n from a random L-bit sequence in time T with advantage . Then there exists an algorithm C, which given the image S(x) of a randomly chosen (unknown) n-bit value x by a randomly chosen n-bit to m-bit quadratic system S produces a preimage of S(x) with probability at least 2 3 λ over all possible values of x and S in time upper bounded by T .</p><formula xml:id="formula_17">T = 2 7 n 2 λ 2 2 T + (λ + 2)T S + log 2 7 nλ 2 2 + 2 + 2 7 nλ 2 2 T S</formula><p>Proof. Theorems 1 to 3 state that if an algorithm X exists, then another algorithm Y exists. In the case of Theorem 1, the resulting algorithm Y can be directly play the role of algorithm X in Theorem 2. In the case of Theorem 2, the resulting algorithm Y , named algorithm B, has the property</p><formula xml:id="formula_18">∀R ∈ {0, 1} N P r (x,S)∈{0,1} n+mN {B(S, S(x), R) = R(x)} ≥ 1 2 + 4 which implies P r (x,S,R)∈{0,1} n+mN +N {B(S, S(x), R) = R(x)} ≥ 1 2 + 4</formula><p>Thus algorithm Y can play the role of algorithm X in Theorem 3, and if we compose the distinguishing probability and complexity expressions of the three concatenated theorems, we obtain the claimed distinguishing probability and complexity bounds.</p><p>Discussion. Theorem 4 above relates to the keystream generation part of QUAD, i.e. to the expansion of a randomly chosen initial state into the keystream and does not include the key and IV loading for deriving the initial state. Moreover it does not guarantee the strength of a particular instance of QUAD associated with a fixed system S but (informally) it shows that if MQ is intractable then most instances of QUAD are secure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Specifying the Parameter Values for QUAD</head><p>We now propose concrete parameters n, k, L, |K| and |IV | for our construction. We restrict ourselves to the GF (2) case. We want to ensure a security level of at least 2 80 . More precisely we want Theorem 4 to ensure that if for a random system and a random initial internal state value at the beginning of the keystream generation there exists a testing algorithm that allows us to distinguish an L-bit keystream produced by QUAD from a uniformly drawn keystream sequence with an advantage of more than = 1 100 in time less than T = 2 80 this would imply the existence of an inversion algorithm of non negligible success probability = 2 3 λ allowing, given a random n-bit to kn-bit system of quadratic equations and the S(x) image by S of a random input value x, to find a preimage by S of S(x) in time T lower by a factor of more than than the best known inversion algorithms for the MQ problem, and thus result in the existence of a large set of weak instances of MQ.</p><p>Depending on the intended application of the stream cipher, the maximum keystream length L can vary from a few hundreds bits for a mobile phone application to up to 2 40 bits. Consequently the allowed parameter values for n and k will also vary, since it is much more demanding to get a security argument for L = 2 40 bits than for L = 1000 bits. We will however retain the latter value L = 2 40 for a first estimate of the corresponding required value of n.</p><p>In her thesis, Magali Bardet <ref type="bibr" target="#b0">[1]</ref> shows that the best Groebner basis algorithm to solve a system of kn equations in k unknowns has (in the case of a regular system) a complexity of T (k, n) = n+1 D 2.37 , where D is close to</p><formula xml:id="formula_19">-k + 1 2 + 1 2 2k 2 -10k -1 + 2(k + 2) k(k + 2) n.</formula><p>To obtain a contradiction, we need to have T lower than T (k, n). For k = 2 and with the previous values of L = 2 40 , T = 2 80 and = 1 100 , we get = 2 -42 and we need to have n greater than 350. For n = 256 and k = 2, we only get a contradiction if we produce less than L = 2 22 = 4 Mbits of keystream for each key and IV pair.</p><p>Practical Values. For practical use of QUAD we recommend an internal state length of n = 160 bits and an expansion factor k of 2 and a maximum keystream length L = 2 40 . We further recommend an IV length |IV | of 80 bits. For such n, k and L values, we do not get a contradiction as for the former parameter values. However our proof reduction is not optimal, and we expect that these parameter values suffice to provide the desired security level of about 2 80 .</p><p>If instead of the n-bit key length assumed (for simplicity of the security arguments) in sections 2 and 3, a keylength |K| strictly lower than n is preferred in order for |K| to better reflect the expected security level, we suggest the following extension of the key loading method described in section 3: periodically repeat the |K| bits of K to get an expanded key of length n, and apply the key and IV procedure of section 3 to this expanded key. We suggest, if this extended key loading method option is retained, to select a key length |K| = 80. Though the shorter key option weakens the security arguments of section 4 and can thus be considered less conservative than the full length n = 160-bit key, we are not aware of any major security weakness resulting from this option.</p><p>An indication of the advantages of the use of the MQ problem for constructing a provably secure stream cipher, in terms of the required internal state size, is given by a comparison with the fastest known provably secure stream cipher, namely a discrete log based construction proposed by Gennaro in <ref type="bibr" target="#b15">[16]</ref> with internal state length n = 3000 bits (to be compared with the n = 350 and 256 internal state lengths derived above) and which produces 2775 bits per iteration and applies 335 modular multiplications of 3000-bit numbers at each iteration. Moreover the security argument of <ref type="bibr" target="#b15">[16]</ref> does not assume the existence of a keystream sequence distinguishing algorithm in time T = 2 80 to get a contradiction, but only a distinguishing algorithm in time T = 3.5 • 10 10 2 35 . Another advantage of MQ is that MQ is NP-hard, whereas the Discrete Logarithm Problem is only in NP ∩ co-NP. Moreover the best known algorithm to solve the Discrete Logarithm problem are subexponential, while for MQ, those algorithm are exponential.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Cryptanalysis</head><p>In this section, we consider various attacks and verify whether they are applicable to our construction. We focus on security aspects not covered by the proof of security of the former section, e.g. the protection against resynchronization attacks provided by the key and IV loading mechanism.</p><p>Resistance Against Algebraic Attacks. QUAD was designed to resist algebraic attack techniques. As a matter of fact, the key and IV loading and keystream generation mechanisms of QUAD are based upon the iteration of quadratic systems whose associated equations are conjectured to be computationally impossible to solve<ref type="foot" target="#foot_2">2</ref> . In more details, recovering the initial state x of the keystream generator from the whole keystream is more difficult than recovering x from S(x), i.e. solving an intractable quadratic system of kn equations. As for the key and IV loading mechanism, it is possible to express any keystream block, as a set of (k -1)n algebraic equations on the |K| ≥ 80 key bits. However since the key and IV setup consists of 2|K| rounds of a quadratic function, this set consists of (k -1)n equations of degree |K| or nearly |K| on the |K| key bits. It is quite natural to conjecture that such a system is highly intractable.</p><p>Correlation Attacks and Distinguishing Attacks. We expect QUAD to be immune to such attacks except for extremely unlikely degenerate instances of the quadratic system S, for example if one of the n-bit to 1-bit quadratic forms of S out or a linear combination of these (k -1)n quadratic forms has an exceptionally low rank and therefore (for even values of n) a detectable bias. Time-Memory-Data Tradeoffs and other Generic Attacks. The internal state of our construction has a size n of at least 160 bits in order to resist against generic time-data tradeoff, which have a complexity of 2 n 2 . Since QUAD is based upon the iteration of the quadratic system S it , the keystream sequences it produces are ultimately periodic. Moreover, since S it is not one to one, the order of magnitude of the period can be expected to be 2 n 2 (k -1)n-bit keystream blocks. One of the consequences of specifying a maximal keystream length L &lt;&lt; 2 n 2 (a typical order of magnitude is L = 2 40 ) is that the detection of short cycles is extremely unlikely.</p><p>Guess and Determine Attacks. The analysis of attacks of this type allows us to fix an upper bound on k. Let us assume that an adversary is able to guess p bits of the internal state. Then this adversary gets a system of (k -1)n equations in the (np) remaining internal state variables. If the number of monomials generated by these np variables n p = 1 2 (np)(np + 1) is close to (k -1)n, the adversary can linearize the system and recover the internal state. Solving</p><formula xml:id="formula_20">n p = (k -1)n gives us a number p 0 = n + 1- √ 1+8n(k-1) 2</formula><p>such that for p ≥ p 0 the linearization is possible. The complexity C of the resulting "attack" is about 2 p0 ((k -1)n) ω , where ω is between 2 and 3. If C is lower than 2 |K| , then the attack is better than exhaustive search. Consequently, k has to be chosen such that C be larger than 2 |K| . For instance for n = 160 and |K| = 80, k &lt; 21 implies that p 0 &gt; 80, and therefore C &gt;&gt; 2 80 . More conservative (i.e. lower) values of k than the one given by this simple bound are of course recommended.</p><p>Unsurprisingly, the attack would become more efficient for unlikely degenerate instances of S, for instance if several quadratic forms of S could be all expressed as quadratic functions of substantially less than n linear combinations of the n state variables.</p><p>Resistance to Resynchronization Attacks with Chosen IVs. Our proof does not cover the Key and IV setup but only the keystream generation. They provide a strong argument towards the conjecture that the keystream sequence resulting from any single known or chosen IV value cannot be distinguished from a random sequence, but do not provide guarantees regarding the independence of the sequences resulting from several chosen IVs and the resistance of QUAD against resynchronization attacks. However the following informal argument indicates that the key and IV setup construction of QUAD prevents such resynchronization attacks, or more generally any detectable statistical bias on the joint distribution of the keystream sequences resulting from the same key and several chosen IVs. Let us consider any t-tuple (IV 1 , • • • , IV t ) of t distinct IV values and one randomly chosen n-bit initial state value before IV loading x. By applying the security proofs of section 4 to the S = (S 0 , S 1 ) system of 2n quadratic equations, the n-bit to 2n-bit mapping S 0 , S 1 is a strong pseudorandom generator. However, the key and IV loading consists of applying a tree-based construction proposed by Goldreich, Goldwasser and Micali <ref type="bibr" target="#b18">[19]</ref> to this generator, so that we can expect the distribution of the (x 1 , • • • , x t ) t-tuple of internal state values resulting from the loading of x and IV 1 to IV t to be indistinguishable from a t-tuple of random independent values. Moreover, the subsequent runnup rounds during which the keystream generator is run without outputting keystream bits provide an extra security margin, since only high degree functions of x 1 to x t are available to an adversary instead of quadratic functions. If instead of the proposed key and IV setup the key and IV values the IV had been loaded into the initial state and an insufficient number of quadratic mappings had been applied to the initial state before activating the keystream generation, then chosen-IV attacks exploiting the higher degree differential properties of low degree functions could have been mounted.</p><p>Dual Ciphers. Because of the structure of the QUAD equations, it is easy to find dual ciphers of QUAD, i.e. simple (e.g. linear) transformations f and g of the key K and the keystream as to ensure that for each triplet of quadratic systems (S, S 0 , S 1 ) there exist quadratic systems (S , S 0 , S 1 ) such that for any key K and any IV value IV , the keystream associated with (f (K), IV, S , S 0 , S 1 ) is the image by g of the keystream associated with (f (K), IV, S, S 0 , S 1 ). We do not expect this property to represent a security threat for QUAD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Performance</head><p>In this Section we give performance results for our recommended version of QUAD, which has 160 bits of internal state, an expansion factor of 2 and a 80bit key and IV length. On a Pentium IV clocked at 2.5GHz with 512 kByte of cache and using the Intel compiler, our recommended version of QUAD reaches a speed of 4347 cycles/byte (4.6 Mbit/s). On a Pentium 4 with 1MByte of cache, the same version reaches a speed of 2915 cycles/byte (5.7 Mbit/s). This cache effect is due to the fact that the quadratic system used contains more than 4 millions of binary coefficients, which requires around 1MByte to store. A version of QUAD running on an Opteron clocked at 2.1 GHz with a 64-bit architecture reaches the speed of 2176 cycles/byte (quite close from 1MByte/s). An optimised version of Blum Blum Shub's generator with an internal state of 1024 bits, which is far from the number of bits of the internal state required for proven security, reaches 30374 cycles/byte. In his paper <ref type="bibr" target="#b15">[16]</ref>, Gennaro claimed his discrete logarithm based generator to be twice faster for these parameters. We can therefore assume that this generator runs at about 15000 cycles/byte. Though QUAD is significantly slower than AES, which runs at 25 cycles/byte, it is much more efficient than other provably secure pseudo random generator. Moreover, implementations of QUAD with quadratic system over larger fields (e.g. GF <ref type="bibr" target="#b15">(16)</ref> or GF (256)) are much faster and even reach 106 cycles/byte.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this paper we introduced QUAD, a novel synchronous stream cipher based on MQ with a security proof in the concrete security model. Eventhough this construction relies on a mathematical problem and has a proof of security, its internal state is of small size n and it extracts a small multiple of n bits at each round. A software implementation of our recommended version of QUAD reaches a speed of 4.6 Mb/s on a standard PC. This makes QUAD of great interest for applications where security is the main concern. We do not preclude that it might be possible to derive tighter bounds in some parts of the proof, which would allow us to further reduce the internal state size and increase the number of extracted bits.</p><p>We would like to thank Matt Robshaw and Olivier Billet for helpful comments. R 1 , . . . , R t to randomize our requests to algorithm B. For each L i (x) we want to retrieve, we call algorithm B 2 t times, using the 2 t linear combinations j α j R j of the R k forms in order to randomize L i . Suppose we know the t values for R j (x), then for any α we can also compute the value of j α j R j (x) and add this value to B( j α j R j ⊕ L i , f(x)). We denote</p><formula xml:id="formula_21">C(i, α) = B( j α j R j ⊕ L i , f(x)) ⊕ j α j R j (x)</formula><p>If we make a correct assumption on the t values R 1 (x) to R t (x) and if B returned the right value of ( j α j R j ⊕ L j )(x) , then we have</p><formula xml:id="formula_22">C(i, α) = ( j α j R j ⊕ L i )(x) ⊕ j α j R j (x) = L i (x) ⊕ j α j R j (x) ⊕ j α j R j (x) = L i (x).</formula><p>For all the possible α values, we collect the vote C(i, α) for the value of L i (x). Since algorithm B is supposed to answer correctly most of the time, taking the majority of the votes C(i, α) will provide us with the value of L i (x) with a high probability if we assume that 2 t requests are enough. The counterpart of this technique is that we have to guess the real values of R j (x) for all j but since t is of logarithmic size this is achievable.</p><p>We now give a more formal proof with a small difference: we use fast Walsh transform computations to simultaneously compute the 2 t results of the votes on the C(i, α) values for all the 2 t possible t-tuples of assumptions R j (x), 1 ≤ j ≤ t, instead of computing them independently.</p><p>Before we give the proof, we need to recall some results on the Walsh transform. Given a real function of t binary variables g(x 1 , . . . , x t ), the Walsh transform of g is the real function of t binary variables G = W (g) defined by G(u 1 , . . . , u t ) = x1,...,xt∈{0,1} t f (x 1 , . . . , x t )(-1) u1x1+...+utxt It is known that the time needed to compute the Walsh transform of a function of t binary variables is t • 2 t .</p><p>Proof. The algorithm C works as follows : first it randomly selects t elements R 1 , . . . , R t of the n-dimensional vector space over GF (2) of the n-bit to 1-bit linear forms.</p><p>Then for each i = 1, . . . , n it executes the following process: for all the 2 t possible α = (α 1 , . . . α t ) t-tuples ∈ {0, 1} t store (-1) B( j αj rj ⊕Li,f (x)) in a table of size 2 t , say (c 0 , . . . c 2 t -1 ) (thus the coefficient associated with α is c t-1 j=0 αj •2 j-1 ). Then it applies the Walsh transform to this table (which represents a function of α. This gives 2 t numbers (β i 0 , . . . , β i 2 t -1 ) such that β i k is the difference of the number of 0 votes and 1 for L i (x) corresponding to the assumption that R j (x) = k j for all j comprised between 1 and t. Consequently if β i k is positive, then C sets bit i of the n-bit candidate value C k associated with the assumption k to C i k = 0, otherwise this bit is set to C i k = 1. After this process has been completed for all the n values of i, one is left with a list of 2 t n-bit candidate values for x corresponding to each of the 2 t assumptions for R 1 (x) to R t (x). For each candidate value C k , algorithm C then computes f (C k ) and compares it to f (x). If a match occurs, C keeps C k in the list of at most 2 t candidate values for x it outputs, otherwise C k is discarded from the list.</p><formula xml:id="formula_23">β i k = α (<label>-</label></formula><p>The total running time of algorithm C is n2 t (T + t + 2) + 2 t T f where T f is the time needed to compute f (y) for an n-bit value y.</p><p>Let us now upper bound the probability that algorithm C fails to select x in the list of pre-images of f (x) it produces. Over the 2 t assumptions for R 1 (x) to R t (x), only the correct one is to be considered. The failure probability of C is upper bounded by the sum of the n probabilities p i that the vote for L i (x) is incorrect and we have: . By applying Chebyshev's inequality, we have</p><formula xml:id="formula_24">p i = P r |{α|C(i, α) = L i (x)}| &lt; 2 t 2 |{α|C(i, α) = L i (x)</formula><formula xml:id="formula_25">p i = P r α C(i, α) ⊕ L i (x) ⊕ 1 &lt; 2 t 2 = P r α C(i, α) ⊕ L i (x) ⊕ 1 -μ &lt; - 2 t 2 ≤ P r α C(i, α) ⊕ L i (x) ⊕ 1 -μ &gt; 2 t 2 ≤ σ 2 (2 t 2 ) 2 ≤ 1 2 t 2</formula><p>Thus the failure probability of C is upper bounded by n 2 t 2 . If we want to have a probability of success for algorithm C higher than 1  2 , then we have to choose t such that 2 t = n 2 . Finally the total complexity of algorithm C is given by 2n </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2 + 2 .</head><label>22</label><figDesc>P r S,x∈Un (B(S, S(x), R) = R(x)) = P r S ,x∈Un (A (S , S (x)) = 1) ≥ 1 On the contrary, suppose b is not equal to R(x), then S (x) = y + ((1 + b) • a) = (y + (b • a)) + a. Thus there is an error of a on the value furnished to A as compared with S (x). Because a is randomly chosen, we have: P r S,x∈Un (B(S, S(x), R) = R(x)) = P r S ,x∈Un (A (S , S (x) + a) = 0) = P r S ,t∈U kn (A (S , t) = 0) = 1 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>1) B( j αj Rj ⊕Li,f (x)) (-1) &lt;k,α&gt; = |{α|C(i, α) = 0}| -|{α|C(i, α) = 1}|</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>}| is the sum of the 2 t pairwise independent 0-1 variablesC(i, α) ⊕ L i (x) ⊕ 1 of average value μ α ≥ 12 + 2 and variance v α = 1 4 -Thus p i has average value μ = 2 t 1 2 + 2 and variance σ 2 = 2 t 1 4 -</figDesc><table /><note><p>2 4 . 2 4</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note however that we will consider later on, in section 4.5, an extended key loading method allowing to set the key length to values strictly lower than n, for instance to |K| = n</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>if one wishes the key length to reflect the complexity of the best known attack.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>except for a small fraction of degenerate instances of S, S0 and S1 whose occurrence is extremely unlikely if these systems are selected as described in section 4.5.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The work described in this paper has been supported by the French Ministry of Research RNRT X-CRYPT project and by the European Commission through the IST Program under Contract IST-2002-507932 ECRYPT.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix. Proof of Lemma 1</head><p>We denote by L i , 1 ≤ i ≤ n the n-bit to 1-bit linear forms defined by L i (x)=x i , where x is represented by the binary string x 1 x 2 • • • x n . The idea of the proof is to call algorithm B sufficiently many times to recover all the x i = L i (x) one by one. To do so, we introduce a parameter t, whose order of magnitude is log n which will be specified later. We use t randomly chosen n-bit to 1-bit linear forms</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Étude des systèmes algébriques surdéterminés. Applications aux codes correcteurs et à la cryptographie</title>
		<author>
			<persName><forename type="first">Magali</forename><surname>Bardet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>Université Paris VI</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<ptr target="http://www-cse.ucsd.edu/users/mihir/courses.html" />
		<title level="m">The Goldreich-Levin Theorem</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A simple unpredictable pseudorandom number generator</title>
		<author>
			<persName><forename type="first">Lenore</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Shub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="364" to="383" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">How to generate cryptographically strong sequences of pseudo-random bits</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="850" to="864" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Cryptanalysis of stream ciphers with linear masking</title>
		<author>
			<persName><forename type="first">Don</forename><surname>Coppersmith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charanjit</forename><forename type="middle">S</forename><surname>Jutla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2002</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Moti</forename><surname>Yung</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2442</biblScope>
			<biblScope unit="page" from="515" to="532" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Solving underdefined systems of multivariate quadratic equations</title>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Courtois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louis</forename><surname>Goubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Willi</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Daniel</forename><surname>Tacier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="211" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient algorithms for solving overdefined systems of multivariate polynomial equations</title>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Courtois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Klimov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Patarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adi</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Bart</forename><surname>Preneel</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1807</biblScope>
			<biblScope unit="page" from="392" to="407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Algebraic attacks on stream ciphers with linear feedback</title>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Courtois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Willi</forename><surname>Meier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Eli</forename><surname>Biham</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="345" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">About the XL Algorithm over GF (2)</title>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Courtois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Patarin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topics in Cryptology -CT-RSA 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Joye</forename><surname>Marc</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2612</biblScope>
			<biblScope unit="page" from="141" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The XL-Algorithm and a Conjecture from Commutative Algebra</title>
		<author>
			<persName><forename type="first">Claus</forename><surname>Diem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT 2004</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Pil</forename><surname>Joong</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lee</forename></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3329</biblScope>
			<biblScope unit="page" from="323" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">ECRYPT Stream Cipher Project, IST-2002-507932</title>
		<author>
			<persName><surname>Ecrypt</surname></persName>
		</author>
		<author>
			<persName><surname>Estream</surname></persName>
		</author>
		<ptr target="http://www.ecrypt.eu.org/stream/" />
		<imprint>
			<date type="published" when="2005-09-29">September 29, 2005, 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Comparison Between XL and Grbner Basis Algorithms</title>
		<author>
			<persName><forename type="first">Jean-Charles</forename><surname>Faugère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hideki</forename><surname>Imai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mitsuru</forename><surname>Kawazoe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Makoto</forename><surname>Sugita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gwénolé</forename><surname>Ars</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT 2004</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Pil</forename><surname>Joong</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lee</forename></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3329</biblScope>
			<biblScope unit="page" from="338" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An efficient pseudo-random generator provably as secure as syndrome decoding</title>
		<author>
			<persName><forename type="first">Jean-Bernard</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="245" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Complexity of solving algebraic equations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Aviezri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yaacov</forename><surname>Fraenkel</surname></persName>
		</author>
		<author>
			<persName><surname>Yesha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4/5</biblScope>
			<biblScope unit="page" from="178" to="179" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>W H Freeman &amp; Co</publisher>
		</imprint>
	</monogr>
	<note>chapter 7.2 Algebraic Equations over GF</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An improved pseudo-random generator based on discrete log</title>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="469" to="481" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Three xor-lemmas an exposition</title>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<pubPlace>Revohot, Israel</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Weizmann Instritute of Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Oded Goldreich. Fondationsof Cryptography</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="2001">2001</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">How to construct random functions</title>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="792" to="807" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Lecture notes on cryptography</title>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<ptr target="http://www-cse.ucsd.edu/users/mihir/courses.html" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A pseudorandom generator from any one-way function</title>
		<author>
			<persName><forename type="first">Johan</forename><surname>Håstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Russell</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1364" to="1396" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Pseudo-random generation from one-way functions</title>
		<author>
			<persName><forename type="first">Russel</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21th ACM Symposium on Theory of Computing -STOC &apos;89</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="12" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient cryptographic schemes provably as secure as subset sum</title>
		<author>
			<persName><forename type="first">Russel</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moni</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="199" to="216" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient cryptographic schemes provably as secure as subset sum</title>
		<author>
			<persName><forename type="first">Russell</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moni</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="199" to="216" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A hard-core predicate for all one-way functions</title>
		<author>
			<persName><forename type="first">Leonid</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21th ACM Symposium on Theory of Computing -STOC &apos;89</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Rudolf</forename><surname>Lidl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haradl</forename><surname>Niederreiter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Cambride University Press</publisher>
		</imprint>
	</monogr>
	<note>Finite Fields</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">FIPS-197: Advanced Encryption Standard</title>
		<ptr target="http://csrc.nist.gov/publications/fips/" />
		<imprint>
			<date type="published" when="2001-11">November 2001</date>
		</imprint>
		<respStmt>
			<orgName>National Institute of Standards and Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Asymmetric cryptography with s-boxes</title>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Patarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louis</forename><surname>Goubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICICS</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="369" to="380" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Asymmetric cryptography with s-boxes</title>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Patarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louis</forename><surname>Goubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICICS</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="369" to="380" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Bmgl: Synchronous key-stream henerator with provable security</title>
		<author>
			<persName><forename type="first">Johan</forename><surname>Håstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mats</forename><surname>Näslund</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>submitted to Nessie Project</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Theory and applications of trapdoor function</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Cryptography FOCS 1982</title>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
