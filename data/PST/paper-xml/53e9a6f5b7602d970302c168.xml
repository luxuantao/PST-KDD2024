<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">XML Tree Finder System: a First Step towards XML Data Mining Final Report</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2004-04-05">April 5, 2004</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Anguo</forename><surname>Dong</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Calgary</orgName>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Dr</roleName><forename type="first">Reda</forename><surname>Alhajj</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Calgary</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">XML Tree Finder System: a First Step towards XML Data Mining Final Report</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2004-04-05">April 5, 2004</date>
						</imprint>
					</monogr>
					<idno type="MD5">2C168740EF7DA9826AE54172DE61CF30</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The problem of searching frequent trees from a collection of tree-structured XML data modeling is considered. The aim of this XML Tree Finder system(XTFS) is to find the tree whose exact or perturbed copies are frequent in a collection of the labeled trees. The definition of the labeled tree will be given later.Frequent here means that the tree we find is the Maximal Common Tree of the collection of the labeled tree.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>An XML Tree Finder System(XTFS) is introduced in this paper. This system takes a group of XML documents as input, clusters them into different clusters and find the maximal common tree of each cluster. Some idea behind the Alexandre TreeFinder System are also used in this system. These will be introduced in later sections.</p><p>As the Alexandre TreeFinder, the main motivating application of this work is the construction of a tree-based mediated schema for integrating multiple and heterogeneous sources of XML data. The construction can be considered as extraction of useful knowledge and then reorganizing or rebuilding them. This task is important to the actual mining system or application so that we call it the basic step or the first step to XML data mining.</p><p>The paper is organized as follows. In the Formal Backgroud section, we introduce some important knowledge and terminology used in this paper. In section 3 Motivation Example, one specific XML tree structure is illustrated and is used to give the motivated impression about the frequent tree. We also give the definition of Maximal Common Tree here. The overview of the System is gone through in section 4 Overview of the TreeFinder System. Finally, it is the section 5 Conclusion and Future Work which will summarize the whole system and illustrate the future work.</p><p>2 Formal Background</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Introduction of Data Mining</head><p>Data mining is motivated by the decision support problem faced by most large retail organizations. <ref type="bibr" target="#b2">[3]</ref> Bar-code technology made it possible for retail organizations to collect and store massive amounts of sales data, referred to as the basket data. Successful organizations view such databases as important pieces of the marketing infrastructure Organizations are interested in instituting information-driven marketing processes, managed by database technology, that enable marketers to develop and implement customized marketing programs and strategies. <ref type="bibr" target="#b4">[5]</ref> Data mining includes several steps: problem analysis, data extraction, data cleansing, rules develop-ment, output analysis and review. <ref type="bibr" target="#b7">[8]</ref> Data mining sources are typically flat files extracted from on-line sets of files, from data warehouses or other data source. Data may however be derived from almost any source. Whatever the source of data, data mining will often be an iterative process involving these steps.</p><p>Data mining tools offer great potential for corporate data warehouses since they discover rather than confirm trends or patterns in data. <ref type="bibr" target="#b10">[11]</ref> Most of these symbolic classifiers are also known as rule-induction programs or decision tree generators. They use statistical algorithms or machine learning algorithms such as ID3, C4.5, AC2, CART, CHAID, CN2, or modifications of these algorithms. <ref type="bibr" target="#b12">[12]</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">XML and Modeling XML Data</head><p>Structure <ref type="bibr" target="#b20">[20]</ref> In a very short space of time, XML has become a hugely popular format for marking up all kinds of data, from web content to data used by applications <ref type="bibr" target="#b8">[9]</ref>. It is finding its way across all tiers of development: storage, transport, exchange, and display. So There are rich and compelling reasons for data mining or the knowledge discovery system to keep up with the pace of XML development. <ref type="bibr" target="#b9">[10]</ref> XML can also be used to store data in files or in databases <ref type="bibr" target="#b14">[14]</ref>. Applications can be written to store and retrieve information from the store, and generic applications can be used to display the data. XML can be generated from a database without any installed XML software. <ref type="bibr" target="#b22">[22]</ref> The XML response from the previous example can easily be modified to fetch its data from a database. <ref type="bibr" target="#b5">[6]</ref> Suppose we have a database called databse.mdb which has a table named GuestBook. This table contains two fields f name and lname. To generate an XML database response from the server, we can simply write the following code and save it as an ASP file: <ref type="bibr">[</ref> In this system, XML data structure(e.g., a DTD) is modelled as labelled tree <ref type="bibr" target="#b20">[20]</ref>. While doing this, we will ignore the ID-references and hyper links which are less useful for the model. In addition, the elements and attributes are not distinguished as well since they can be actually considered to be the same data element in the labelled tree <ref type="bibr" target="#b17">[17]</ref>. Another important assumption of this data structure is that there exists a one-to-one correspondence between all labels and real world concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Parsing XML File and Data Binding [21]</head><p>The main point behind data binding is to generate a correspondence or interface between these XML Figure <ref type="figure">1</ref>: Data Binding Shcema schemas and Java classes and then exploit this mapping when converting XML documents to and from Java objects. Our goal is to process XML using Java code. The data binding schema can be illustrated in Figure <ref type="figure">1</ref>.</p><p>Among lots of methods of data binding and processing XML schemas, two of the most popular approaches are the Simple API for XML Parsing (SAX) and the Document Object Model (DOM). We can access SAX and DOM through the Java API for XML Parsing (JAXP) that is a part of the Java 1.4 release.</p><p>SAX is an event-based approach. As the parser works its way through the XML document, you can have it notify you of certain events.</p><p>Alternatively, DOM is a tree-based approach. The result of parsing an XML file with a DOMbased parser is a document object that contains a structured representation of the file. DOM is paid more attention to illustrate since we use it in this system.</p><p>Navigating the DOM usually involves code that looks like conferenceN-odeList.item(i).getFirstChild().getFirstChild().getData(). Here's a DOM tree view of the document: </p><formula xml:id="formula_0">&lt;?xml</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Computing Similarity between XML Documents</head><p>There are some methods to compute similarity between two sets of extended-element vectors representing two XML documents. In Preparation for Semantics-Based XML, the author introduce one methodology for computing the similarity by taking account of XML semantics to prepare XML document for XML mining. Mining The computing is divided into three steps which are Generating extended-element vectors, Measure of element similarity, and Constructing of the similarity matrix. <ref type="bibr" target="#b17">[17]</ref> Generating the extended-element vectors for an XML document is as follows. <ref type="bibr" target="#b16">[16]</ref> • Parse an XML document to extract elements and generate a DOM(Document Object Model) tree.</p><p>• Sift meaningful tokens by filtering delimiters such as space, hyphen, and underscore.</p><p>• Delete tokens included in a stop-list.</p><p>• Extract stems or original form of the tokens through stemming process.</p><p>• Extend elements thus found, using the WordNet thesaurus and a User-defined word library, with synonyms, compound words, and abbreviations.</p><p>The basis of the measures is the degree of match between original elements, between an original element and a term in the extended-element vector of another element <ref type="bibr" target="#b24">[24]</ref>. The levels are divided into six with Level 0 is the least similar and Level 6 is the most similar.</p><p>Finally, the similarity matrix for two set of extended-element vectors representing two XML documents is constructed. One set of extendedelement vectors forms the column, and another the row of the matrix. <ref type="bibr" target="#b17">[17]</ref> Based on the above methodology, we ignore the process to compute the similarity and suppose that all the nodes of the labeled tree with the minimal similarity are the same. For example, we consume that "Conf erenceN ame", "Conf N ame", and "M eetingN ame" have the same meaning for the name of the conf erence, and we can use only one label to represent them. For instance, we use "Conf N ame" to stand for all these three terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">θ-subsumption [7]</head><p>θ-subsumption is used to define the ordering of the program clause or the tree nodes. <ref type="bibr" target="#b23">[23]</ref> It is the basic term for us to define the Inclusion by Tree Subsumption which is one of the most important term in the TreeFinder system. θ-subsumption is defined below.</p><p>Definition (θ-Subsumption)A substitution θ = {V 1 /t 1 , ..., V n /t n } is an assignment of terms t i to variables V i . Applying a substitution θ to a term, atom, or clause F yields the instantiated term, atom, or clause Fθ where all occurrences of the variables V i are simultaneously replaced by the term t i . Let c and c be two program clauses. Clause c θ-subsumes c if there exists a substitution θ, such that cθ ⊆ c <ref type="bibr" target="#b19">[19]</ref>.</p><p>To illustrate the above notions, consider the clause c = daughter(X, Y )← parent(Y,X). Applying the substitution θ = {X/mary, Y /ann} to clause c yields cθ = daughter(mary,ann)← parent(ann, mary).</p><p>Clauses can be viewed as sets of literals: the clausal notation daughter(X, Y )← parent(Y, X) thus stands for {daughter(X, Y ), ¬parent(Y, X)} where all variables are assumed to be universally quantified, and the commas denote disjunction. According to the definition, clause c θ-subsumes c if there is a substitution θ that can be applied to c such that every literal in the resulting clause occurs in c .</p><p>θ-subsumption introduces a syntactic notion of generality. <ref type="bibr" target="#b6">[7]</ref> Clause c is at least as general as clause</p><formula xml:id="formula_1">c (c ≤ c ) if c θ-subsumes c . Clause c is more general than c (c &lt; c ) if (c ≤ c ) holds and (c ≤ c) does not.</formula><p>In this case, we say that c is a specialization of c and c is a generalization of c . If the clause c is a specialization of c then c is also called a refinement of c.</p><p>There are two important properties of θsubsumption: <ref type="bibr" target="#b3">[4]</ref> • If c θ-subsumes c then c logically entails c , c |= c .</p><p>• The relation ≤ introduces a lattice on the set of reduced clauses <ref type="bibr" target="#b19">[19]</ref>. This means that any two reduced clauses have a least upper bound (lub) and a greatest lower bound (glb). Both the lub and the glb are unique up to equivalence (renaming of variables) under θ-subsumption. Reduced clauses are the minimal representatives of the equivalence classes of clauses defined by θsubsumption. For example, the clauses daughter(X, Y )← parent(Y, X), parent(W, V ) and daughter(X, Y )← parent(Y, X) θ-subsume one another and are thus equivalent. The latter is reduced, while the former is not.</p><p>The second property of θ-subsumption leads to . The LGG will be introduced in more detail in later section. Note that θ-subsumption and least general generalization are purely syntactic notions since they do not take into account any background knowledge <ref type="bibr" target="#b18">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Tree inclusion and the relationship with θ-subsumption [7]</head><p>Definition (Labelled Tree) A labelled tree is a pair t,label where (i )t is a finite tree whose nodes are in N . (ii )label is a labelling function that assigns a label to each node in it. <ref type="bibr" target="#b20">[20]</ref> Figure <ref type="figure">3</ref> gives some examples of labeled trees. The labels are the key point here since they play the role of the begin-end tag in XML data models. In this project, the labelled tree model for XML data structure will be used too. From there, the efficient and scalable Tree Finder System will be constructed.</p><p>Definition (Inclusion by tree subsumption) <ref type="bibr" target="#b20">[20]</ref> let t and t be two labeled trees. We say that t is included according to tree subsumption (or included when no confusion is possible) in t if there exists a mapping f from the nodes of t into the set of nodes of t such that f preserve the ancestor relation:</p><formula xml:id="formula_2">∀ u in t, label(u) = label(f (u)) and ∀u, v in t, anc(u, v)-→anc(f (u), f (v)).</formula><p>The advantage of the above definition is the following: if we choose to represent labeled trees as relational formulas, then tree subsumption is equivalent to the θ-suubsumption relation defined by <ref type="bibr">( [7]</ref>).</p><p>Definition (Relational description of labeled trees) <ref type="bibr" target="#b20">[20]</ref> Let t be a labeled tree. Rel(t) is the conjunction of all atoms ab(u, v), such that u and v are nodes in t, with label(u) = a, label(v) = b and u is the parent node of v. Rel + (t) is the conjunction of atoms a * b(u, v), such that u and v are nodes in t, with label(u) = a, label(v) = b and u is the ancestor node of v.</p><p>Figure <ref type="figure" target="#fig_5">4</ref> illustrates the two encoding function Rel and Rel + for two labeled trees LT 1 and LT 2 . Using the encoding function, we will get the final tree as shown in Figure <ref type="figure">5</ref> going through the XML Tree Finder System.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Method of Discovering Large Item</head><p>Sets-AprioriAlgorithm</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7.1">Formal Definition of Data Mining Association Rules</head><p>Algorithms for discovering large item sets make multiple passes over the data. In the first pass, we count the support of individual items and determine which of them are large (with minimum support). In each subsequent pass, we start with a seed set of item sets found to be large in the previous pass, then use this seed set for generating new potentially large item sets, called candidate item sets, and count the actual support for these candidate item sets during the pass over the data. At the end of the pass, we determine which of the candidate item sets are actually large, and they become the seed for the next pass. This process continues until no new large item sets are found. <ref type="bibr" target="#b15">[15]</ref>. We say a transaction T contains X, a set of some items in I, if X⊆T.</p><p>Definition(Association Rule) An association rule is an implication of the form X =⇒ Y, where X⊂I, Y⊂I, and X∩Y =∅. <ref type="bibr" target="#b13">[13]</ref> Definition(Support)X=⇒Y has support s in the transaction set D if s% of transactions in D contain X⇒Y. <ref type="bibr" target="#b13">[13]</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7.2">AprioriAlgorithm [2]</head><p>Some notation used in the AprioriAlgorithm:</p><formula xml:id="formula_3">K-itemset An itemset having k items.</formula><p>L k Set of large k-itemsets (those with minimum support). Each member of this set has two fields: i) itemset and ii) support count.</p><p>C k Set of candidate k-itemsets (potentially large itemsets). Each member of this set has two fields: i) itemset and ii) support count.</p><p>The AprioriAlgorithm:</p><formula xml:id="formula_4">L 1 = {large 1-itemsets};</formula><p>for ( k = 2; L k-1 = ∅; k++ ) do begin</p><formula xml:id="formula_5">C k = apriori-gen(L k-1 ); // New candidates forall transactions t ∈ D do begin C t = subset(C k , t); Candidates contained in t forall candidates c ∈ C t do c.count++; end L k = {c ∈ C k |c.count ≥ minsup} Answer = ∪ k L k ; 2.7.3</formula><p>The apriori -gen function</p><p>The apriori -gen function takes as argument L k-1 , the set of all large (k-1)-itemsets. It returns a superset of the set of all large k-itemsets. First, in the join step, we join L k-1 with L k-1 :</p><formula xml:id="formula_6">insert into C k select p.item 1 , p.item 2 ,... , p.item k-1 , q.item k-1 from L k-1 p, L k-1 q</formula><p>where p.item 1 = q.item 1 , ... ,p.item k-2 = q.item k-2 , p.item k-1 &lt; q.item k-1</p><p>Next, in the prune step, we delete all itemsets c ∈ C k such that some (k-1)-subset of c is not in L k-1 :</p><formula xml:id="formula_7">forall itemsets c ∈ C k do forall (k-1)-subsets s of c do if (s ∈ L k-1 ) then delete c from C k ; 2.7.4 apriori -gen Function Example Let L 3 be {{1 2 3}, {1 2 4}, {1 3 4}, {1 3 5}, {2 3 4}}</formula><p>1. In the join step:</p><formula xml:id="formula_8">• {1 2 3} joins with {1 2 4} to produce {1 2 3 4}</formula><p>• {1 3 4} joins with {1 3 5} to produce {1 3 4 5}</p><p>• After the join step, C 4 will be {{1 2 3 4}, {1 In the prune step:</p><p>• {1 2 3 4} is tested for existence of 3-item subsets within L 3 , thus for {1 2 3}, {1 3 4}, and {2 3 4}</p><p>• {1 3 4 5} is tested for {1 3 4}, {1 4 5}, and {3 4 5}, with {1 4 5} not found, and thus this set is deleted 3. We then will be left with only {1 2 3 4} in C 4</p><p>Consider an example transaction database given in Figure <ref type="figure" target="#fig_2">6</ref>. In each iteration (or each pass), Apriori construct a candidate set of large itemsets, counts the number of occurences of each candidate itemsets, and then determines large itemsets based on a predetermined minimum support. In the first iteration, Apriori simply scans all the transactions to count the number of occurrences for each item. The set of candidate 1-itemsets, C 1 , obtained is shown in Figure <ref type="figure">7</ref>, Assuming that the minimum transaction support required is 2 (i.e., s=40%), the set of large 1-itemsets, L 1 , composed of candidate 1-itemssets with the minimum support required, can then be determined. To discover the set of large 2-itemsets, in view of the fact that any subset of a large itmeset must also have minimum support, Apriori uses L </p><formula xml:id="formula_10">L 1 C 2 L 2 Scan D C 2 C 3 C 3 L 3</formula><p>Scan D</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 7: Generation of candidate itemsets and large itemsets</head><p>The set of candidate itemsets, C 3 , is generated from L 2 as follows. From L 2 , two large 2-itemsets with the same first item, such as {B C} and {B E}, are identified first. Then, Apriori tests whether the 2-itemset {C E}, which consists of their second items, constitutes a large 2-itemset or not. Since {C E} is a large itemset by itself, we know that all the subsets of {B C E} are large and then {B C E} becomes a candidate 3-itemset. There is no other candidate 3-itemset from L 2 . Apriori then scans all the transactions and discovers the large 3-itmesets L 3 in Figure <ref type="figure">7</ref>. Since there is no candidate 4-itemset to be constituted from L 3 , Apriori ends the process of discovering large itemsets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Motivating Example</head><p>We can use the tree structure in Figure <ref type="figure">8</ref> to illustrate the various XML database or XML documents. For instance, the root node Conf erence in Figure7.A relates to the root element in the XML structures, Conf ID to the inner node, and City to the most inner node.</p><p>Although the structures of the trees in Figure <ref type="figure">8</ref> vary so much, we still can group them into two groups since the tree t 1 in Figure <ref type="figure">9</ref> is commonly included by tree A, B, and C in Figure <ref type="figure">8</ref> and the tree t 2 in Figure <ref type="figure">9</ref> is commonly included by tree D, and E. We call t 1 and t 2 frequent trees corresponding to the input trees of Figure <ref type="figure">8</ref>.</p><p>The common tree for tree A, B, and C is tree t 1 in Figure <ref type="figure">9</ref>. The common tree for tree C, and D is tree t 2 in Figure <ref type="figure">9</ref>.</p><p>Definition (Maximal common Tree) Let t, t 1 , t 2 , ..., t n be labelled trees. We say that t is a maximal common tree of t, t 1 , t 2 , ..., t n if f :</p><formula xml:id="formula_11">• ∀i ∈ [1..n] t is included in t i</formula><p>• t is maximal for the previous property, i.e if there is a labelled tree t such as t is included in t and ∀i ∈ [1.</p><p>.n] t is included in t i then t is identical to t. For instance, the tree t 1 in Figure <ref type="figure">9</ref> is the maximal common tree of A, B, and C in Figure <ref type="figure">8</ref>, and t 2 is the maximal common tree of D and E in Figure <ref type="figure">8</ref>.</p><p>4 Overview of the XML Tree Finder System</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Interface Illustration of the XML Tree Finder System</head><p>A friendly interface of this XML Tree Finder System can be viewed in Figure <ref type="figure">10</ref>. As shown, there is one simple description of the system, and one text area to show the sequent running results. Two buttons Start and Exit can be used to start and exit the system. As for the threshold text field, user can specify the threshold between 0 and 1 here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Parse XML schema into DOM Tree</head><p>The first step of this XML Tree Finder System will parse each XML schema of a group of XML documents into DOM trees. Therefore, it traverses the DOM tree and generates the abstraction of it T = {t 1 , ..., t n }, where each t i is viewed as a transaction item made of all the items l * m such that l is the label of an ancestor of a node labeled by m in t i . Each item l * m has a unique identifiers. We call this abstraction of the DOM tree as XM L node -based input transaction corresponding to the XML schema from which it is generated. For instance, the XM l node -based input transaction corresponding to tree A of Figure <ref type="figure">8</ref>  This splitting makes possible the use of a standard frequent item sets algorithm for discovering frequent label pairs in the input trees. This XM L node-based input transaction will be also used to generate the transaction item pool defined later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Generate the Transaction Item Pool</head><p>Definition (Item Pool)An ItemP ool is a container that is made up of the whole distinct items found in all of the XM L node -based transactions. Each item in item pool has an identified item ID in order to distinguish one item from others.</p><p>We put all the items in the XM L node -based transactions into the item pool. During the inserting, the item pool will delete the duplicate item such that an item pool is the container that hold all of the distinct items that a group of XML documents have. In addition, each item in the item pool is given an fixed and distinct item number called item ID. Figure <ref type="figure" target="#fig_6">11</ref> shows the item pool of the specific example we explore of the DOM trees in  ID is kept same as the item ID in the later converted item ID in the XM L text -based transaction. In addition, the system will use the item ID to retrieve the corresponding item name which is the node pair name in the final maximal common tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Convert XML Node-based Transaction to Text-based Transaction</head><p>The purpose of this conversion is to simplify the computation for the next step which implement the apriori algorithm to cluster the XML documents and return the maximal common tree for each cluster. Therefore, it will increase the efficiency of the tree finder system too. The structure of the text -based transaction of the XML document is a list of item node whose data structure is a pair (itemID, status). Each transaction has the same total number of items as in the item pool. For the case we exam above, each transaction has 40 items whose itemIDs among 0 to 39. The status field indicates whether the transaction contains this item or not. O stands for not containing, and 1 for containing. All item statuses of each transaction are initialized to 0 which means that transaction doesn't contain any item from the beginning.</p><p>The DOM trees then are traversed again one by one and compare their node pairs with the node pairs in    If the node pair in the DOM tree can be found in the item pool, the corresponding status is changed to 1 which means that transaction contain this item (node pair). Otherwise, it keeps 0 indicating that there is no this item in this transaction. In the running example, the item pool is as Figure <ref type="figure" target="#fig_6">11</ref>. We can get the table to show the item ID and corresponding node pair as in Figure <ref type="figure" target="#fig_8">12</ref>. The XM L text-based input transaction after conversion corresponding to tree A of Figure <ref type="figure">8</ref> is as figure <ref type="figure" target="#fig_9">13</ref>. We call it xmlT . In this xmlT , we can tell that the status of of item ID 2 is 1 because the DOM tree of tree A of Figure <ref type="figure">8</ref> contains the node pair Conf erence * Conf Loc whose ID in item pool is 2. But the status of item ID 18 is 0 because there is no node pair Organization * Conf Loc whose ID is 18 in the item pool for the DOM tree of tree A of Figure <ref type="figure">8</ref>. The running screen shoot can be seen in Figure <ref type="figure" target="#fig_10">14</ref> in which the first two XML document's text -based input transaction are shown.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Compute and Return the Maximal Common Tree of each Cluster of the Labeled Tree</head><p>The Apriori Algorithm <ref type="bibr" target="#b23">[23]</ref> which is one of the famous clustering method is implemented to apply to . The screen shoot of input condition can be seen in Figure <ref type="figure" target="#fig_10">14</ref> for the specific example.</p><p>As for the tree structure in Figure <ref type="figure">8</ref>, the five XML DOM trees will be divided into two clusters as follows. Cluster c 1 is made up of tree A, B, and C. Whereas, cluster c 2 contains tree D and E. Let LFI be the abbreviation of Largest Frequent Item. Therefore, we will get the following output after this step with the threshold = 0.4. While, 0, 1, 2, 31, 32, 33, and 34 are the item ID.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LFI(c</head><formula xml:id="formula_12">1 ) = {0, 1, 2} LFI(c 2 ) = {31, 32, 33, 34}</formula><p>If the frequent threshold is set to 0.6, the output should be as following. The reason is the minimum support of item 0, 1, and 2 is 0.6. On the other hand, the minimum support of item 31, 32, 33, and 34 is only 0.4 so that they won't show up in the final output.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LFI(c</head><formula xml:id="formula_13">1 ) = {0, 1, 2} LFI(c 2 ) = ∅</formula><p>When the frequent threshold is set to 0.8, both LFI(c 1 ) and LFI(c 2 ) will become ∅, since no item has The output of the above step is text-based maximal common tree which is composed of a collection of item ID. For instance, {0, 1, 2}. We need to retrieve the corresponding node pair based on the original item pool we got from the XML document. The last step of the XML Tree Finder System will do this job. Let MCT stand for Maximal Common Tree. For the case with = 0. The screen shoot of this case can be seen in Figure <ref type="figure" target="#fig_11">15</ref>.  Another significant test case is when the frequent threshold has the lower value like 0.2 that returns both MCT(c 1 ) and MCT(c 2 ) bigger maximal common trees. In addition, it increases the system running time sharply to get the result. For all of the cases with minimum support more than 0.4, the running time is around 3 seconds. But it takes 325 seconds to return the maximal common tree with = 0.2. The screen shoot of this case is showed in Figure <ref type="figure">19</ref>.</p><p>MCT(c 1 ) = ∅ MCT(c 2 ) = ∅</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion and Future Work</head><p>In this paper, we proposed an XML Tree Finder System which is the fundamental step for follow-up XML data mining. Based on the formal background knowledge, the whole process of the system was illustrated. Some test cases were given and analyzed.</p><p>As for the future work, there are many related and future ones that can be done based on this system. First of all, the data can be grasped directly from XML database, since the current system assume that those XML documents are already captured from the database. Secondly, it can use SAX other than DOM for the data binding because using DOM is more memory consumed so that it will make the system worse when it compute massive data. Thirdly, the current return result is the node pairs of the maximal common tree. It will be better if the true tree structure is shown on screen. Finally, the standard apriori-algorithm is implemented in this system, but there is some point in this algorithm which can be improved in order to make the system faster.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2 Figure 3 :</head><label>23</label><figDesc>Figure 3: Labeled Tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: LT 1 and LT 2 relational encoding</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: An example transaction database for data mining</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 8 : 2 Figure 9 Figure 10 :</head><label>82910</label><figDesc>Figure 8: Various Tree Structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>is: A= {Conf erence * Conf N ame, Conf erence * Conf Loc, Conf erence * Conf Date, Conf erence * Sponser, Conf erence * Country, Conf erence * City, Conf erence * State, Conf erence * SprN ame, Conf erence * SprAmount, Conf Loc * Country, Conf Loc * State, Conf Loc * City, Sponser * SprN ame, Sponser * SprAmount}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 .</head><label>4</label><figDesc>There are totally 40 items in this item pool, each of which has an item ID. For instance, the item ID of Conf erence * Conf Date is 1, Conf erence * City is 8, and Organization * Conf Loc is 18 etc. This item</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Item Pool of a group of XML Document</figDesc><graphic coords="10,316.93,124.80,216.04,169.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: ItemId and Corresponding Node Pair in Item Pool</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: XMl Text-based Input Transaction after Conversion</figDesc><graphic coords="11,316.93,124.80,216.04,166.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Input Condition of the Tree Finder System</figDesc><graphic coords="12,78.32,124.80,214.33,166.05" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: Output of Tree Finder System with Threshold 0.4</figDesc><graphic coords="12,316.93,124.80,215.99,166.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 16 :Figure 17 :</head><label>1617</label><figDesc>Figure 16: Output of Tree Finder System with Threshold 0.6</figDesc><graphic coords="13,78.32,124.80,215.95,166.89" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 18 : 1 Figure 19 :</head><label>18119</label><figDesc>Figure 18: Output of Tree Finder System with Threshold 1</figDesc><graphic coords="13,316.93,437.36,216.04,169.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>1 *L 1 to generate a candidate set of itemsets C 2 where * is an operation for concatenation in this case. C 2 consists of |L 1 | 2-itemsets. Next, the four transactions in D are scanned and the support of each candidate itemset in C 2 is counted. The middle table of the second row in Figure 7 represents the result from such counting in C 2 . The set of large 2-itemsets, L 2 , is therefore determined based on the support of each candidate 2-itemset in C 2 .</figDesc><table><row><cell></cell><cell>C 1</cell><cell></cell></row><row><cell></cell><cell>Itemset</cell><cell>Support</cell></row><row><cell>Scan D</cell><cell>{A}</cell><cell>2</cell></row><row><cell></cell><cell>{B}</cell><cell>3</cell></row><row><cell></cell><cell>{C}</cell><cell>3</cell></row><row><cell></cell><cell>{D}</cell><cell>1</cell></row><row><cell></cell><cell>{E}</cell><cell>3</cell></row><row><cell>Itemset</cell><cell>Support</cell><cell></cell></row><row><cell>{A}</cell><cell>2</cell><cell></cell></row><row><cell>{B}</cell><cell>3</cell><cell></cell></row><row><cell>{C}</cell><cell>3</cell><cell></cell></row><row><cell>{E}</cell><cell>3</cell><cell></cell></row><row><cell>Itemset</cell><cell>Itemset</cell><cell>Support</cell></row><row><cell>{A B}</cell><cell>{A B}</cell><cell>1</cell></row><row><cell>{A C}</cell><cell>{A C}</cell><cell>2</cell></row><row><cell>{A E}</cell><cell>{A E}</cell><cell>1</cell></row><row><cell>{B C}</cell><cell>{B C}</cell><cell>2</cell></row><row><cell>{B E}</cell><cell>{B E}</cell><cell>3</cell></row><row><cell>{C E}</cell><cell>{C E}</cell><cell>2</cell></row><row><cell>Itemset</cell><cell>Support</cell><cell></cell></row><row><cell>{A C}</cell><cell>2</cell><cell></cell></row><row><cell>{B C}</cell><cell>2</cell><cell></cell></row><row><cell>{B E}</cell><cell>3</cell><cell></cell></row><row><cell>{C E}</cell><cell>2</cell><cell></cell></row><row><cell>Itemset</cell><cell>Itemset</cell><cell>Support</cell></row><row><cell>{B C E}</cell><cell>{B C E}</cell><cell>2</cell></row><row><cell>Itemset</cell><cell>Support</cell><cell></cell></row><row><cell>{B C E}</cell><cell>2</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>4, the system will return the following maximal common tree, because Conf erence * Conf N ame has item ID 0, Conf erence * Conf Date has item ID 1 etc.</figDesc><table><row><cell>MCT(c 1 )</cell><cell>=</cell><cell>{Conf erence  *  Conf N ame,</cell></row><row><cell cols="3">Conf erence  *  Conf Date, Conf erence  *  Conf Loc}</cell></row><row><cell>MCT(c 2 )</cell><cell>=</cell><cell>{Association  *  AssoN ame,</cell></row><row><cell cols="3">Association  *  Reviewer, Reviewer  *  RewN ame,</cell></row><row><cell cols="3">Association  *  RewN ame}</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Using jdbc to insert data from xml into a database</title>
		<imprint/>
	</monogr>
	<note>Presented by developerWorks of IBM</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">This chapter 8 contains examples of how data mining is used in banking/finance, retailing, healthcare, and telecommunications. The purpose of this chapter is to give the user some ideas of the types of activities in which data mining is already being used and what companies are using them</title>
	</analytic>
	<monogr>
		<title level="m">Industry applications of data mining</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Xmltk: An xml toolkit for scalable xml stream processing. Describe a toolkit for highly scalable XML data processing</title>
		<author>
			<persName><forename type="first">Iliana</forename><surname>Avila-Campillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Greeny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Makoto</forename><surname>Onizukaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Demian</forename><surname>Raven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>consisting of two components</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">XML Data Management: Native XML and XML-Enabled Database Systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Akmal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Awais</forename><surname>Chaudhri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Rashid</surname></persName>
		</author>
		<author>
			<persName><surname>Zicari</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Data mining: An overview from database perspective</title>
		<author>
			<persName><forename type="first">Ming-Syan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m">Introduction to Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="page">10500</biblScope>
		</imprint>
		<respStmt>
			<orgName>Two Crows Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multi-relational data mining: An introduction</title>
		<author>
			<persName><forename type="first">Saso</forename><surname>Dzeroski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Jozef Stefan Institute</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page">1000</biblScope>
			<pubPlace>Ljubljana, Slovenia</pubPlace>
		</imprint>
	</monogr>
	<note>Jamova</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Nuggets r and data mining. Data Mining Technologies Inc.1055 Stewart Avenue, Suite 1, Bethpage, NY 11714 Email mgilman@data-mine</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Gilman</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>com</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Designing XML Databases. Prentice Hall PTR</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Graves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NJ</title>
		<imprint>
			<biblScope unit="volume">07458</biblScope>
			<date type="published" when="2002">2002</date>
			<pubPlace>Upper Saddle River</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">A comprehensive, highly technical look at the math and science behind extracting useful information from large databases</title>
		<author>
			<persName><forename type="first">David</forename><surname>Hand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heikki</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Padhraic</forename><surname>Smyth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>A Bradford Book The MIT Press</publisher>
			<pubPlace>Cambridge Massachusetts and London England</pubPlace>
		</imprint>
	</monogr>
	<note>Principles of Data Mining</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">A database approach to content-based xml retrieval</title>
		<author>
			<persName><forename type="first">Djoerd</forename><surname>Hiemstra</surname></persName>
		</author>
		<imprint/>
		<respStmt>
			<orgName>University of</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Centre for Telematics and Information Technology P</title>
		<author>
			<persName><surname>Twente</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">217</biblScope>
			<pubPlace>AE Enschede, The Netherlands</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Oracle9i XML Database Developer&apos;s Guide -Oracle XML DB</title>
		<author>
			<persName><forename type="first">Shelley</forename><surname>Higgins</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Oracle Corporation</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">An xml query engine for network-bound data</title>
		<author>
			<persName><forename type="first">Zachary</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">S</forename><surname>Weld</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="98195" to="92350" />
			<pubPlace>Box 352350, University of Washington, Seattle, WA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>VLDB. Department of Computer Science and Engineering</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Collective data mining: A new perspective toward distributed data mining</title>
		<author>
			<persName><forename type="first">Hillol</forename><surname>Kargupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Byung-Hoon</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daryl</forename><surname>Hershberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erik</forename><surname>Johnson</surname></persName>
		</author>
		<idno>WA99164-2752</idno>
		<imprint>
			<pubPlace>USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>School of Electrical Engineering &amp; Computing Science Wsshington State University Pullman</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Algorithms for mining distance-based outliers in large datasets</title>
		<author>
			<persName><forename type="first">Edwin</forename><forename type="middle">M</forename><surname>Knorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raymond</forename><forename type="middle">T</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB</title>
		<imprint>
			<biblScope unit="page" from="392" to="403" />
			<date type="published" when="1998-08-24">1998. August 24-27</date>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Preparation for semantics-based xml mining</title>
		<author>
			<persName><forename type="first">Jung-Won</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Won</forename><surname>Kim</surname></persName>
		</author>
		<idno>IEEE, 0-7695-1119-8/01:345-352</idno>
	</analytic>
	<monogr>
		<title level="j">Cyber Database Solutions Anstin</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<pubPlace>Texas</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science &amp; Engineering, Ewha Institute of Science and Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Universitá degli Studi di Torino Dipartimento di Informatica Universitá degli Studi di Bergamo Facoltá di Ingegneria</title>
		<author>
			<persName><forename type="first">Rosa</forename><surname>Meo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Psaila</surname></persName>
		</author>
		<idno>IEEE, 0- 7695-1754-4/02:665-668</idno>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Toward xmlbased knowledge discovery systems</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A study of generalisation in logic programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Niblett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third European Working Session on Learning</title>
		<meeting>the Third European Working Session on Learning<address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page">131138</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A note on inductive generalization</title>
		<author>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Intelligence 5</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Meltzer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<meeting><address><addrLine>Edin-burgh</addrLine></address></meeting>
		<imprint>
			<publisher>Edinburgh University Press</publisher>
			<date type="published" when="1969">1969</date>
			<biblScope unit="page">153163</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Treefinder: a first step towards xml data mining</title>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Termier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Christine</forename><surname>Rousset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michéle</forename><surname>Sebag</surname></persName>
		</author>
		<idno>IEEE, 0-7695-1745- 4/02:450-457</idno>
		<imprint>
			<date type="published" when="2002">2002. 91405</date>
			<publisher>LRI-CNRS UMR</publisher>
			<biblScope unit="volume">8623</biblScope>
			<pubPlace>Orsay</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Université Paris-Sud</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<ptr target="https://www6.software.ibm.com/developerworks/educjaxb/index.html" />
		<title level="m">? Introduction to Data Binding, Unmashalling: from XML to Java objects, Mashalling: from Java objects to XML, and future exploration in Data Binding</title>
		<imprint>
			<publisher>W3School</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m">W3Schools -Full Web Building Tutorials. At W3Schools you will find all the Web-building tutorials you need, from basic HTML and XHTML to advanced XML, XSL, Multimedia and WAP</title>
		<imprint>
			<publisher>W3School</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">In this text, an international team of 44 data mining experts specifically explore new methodologies or examine case studies in this new and multidisciplinary topic</title>
		<author>
			<persName><forename type="first">John</forename><surname>Wang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>Data Mining: Opportunities and Challenges. Idea Group Publishing</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Professional XML Databases</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Brundage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Dengler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Gabriel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Hoskinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Maxwell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Ochoa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johnny</forename><surname>Papa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohan</forename><surname>Vanmane</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Wrox Press Ltd</publisher>
			<pubPlace>Arden House, 1102 Warwick Road, Acocks Green, Birmingham, B27 6BH, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
