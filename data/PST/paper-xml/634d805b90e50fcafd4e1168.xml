<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">This paper is included in the Proceedings of the 16th USENIX Symposium on Operating Systems Design and Implementation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yuxin</forename><surname>Ren</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Kang</forename><surname>Zhou</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jianhai</forename><surname>Luan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Yunfeng</forename><surname>Ye</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Shiyuan</forename><surname>Hu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Xu</forename><surname>Wu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Wenqin</forename><surname>Zheng</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Wenfeng</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Xinwei</forename><surname>Hu</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<address>
									<postCode>2022 ?</postCode>
									<settlement>July 11-13, Carlsbad</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">Poincare lab</orgName>
								<orgName type="institution">Huawei Technologies Co</orgName>
								<address>
									<settlement>Ltd</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">Poincare lab</orgName>
								<orgName type="institution">Huawei Technologies Co</orgName>
								<address>
									<settlement>Ltd</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">This paper is included in the Proceedings of the 16th USENIX Symposium on Operating Systems Design and Implementation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The dynamic linker and loader has been one of the fundamental software, and more than 99% of binaries are dynamically linked on Ubuntu. On one hand, vendors are going to break production software into more and more dynamic libraries to lower the maintenance cost. On the other hand, customers require the dynamic loader to provide rich functionalities to serve their isolation, security, and performance demands. However, existing dynamic loaders are implemented in a monolithic fashion, so they are difficult to extend, configure and optimize.</p><p>This paper presents iFed, an infrastructure for extensible and flexible dynamic library transformation. We design iFed in a pass-based architecture to compose various functional and optimization passes. iFed uses a runnable in-memory format to represent libraries and coordinate among multiple transformation passes. We further implement two optimization passes in iFed, which efficiently leverages hugepages and eliminates relocation overhead. iFed is implemented as a dropin replacement of the current system default dynamic loader. We evaluate iFed and its optimization passes with a wide range of applications on different hardware platforms. Compared to the default glibc dynamic loader, iFed reduces an order of magnitude of TLB miss. We improve the throughput of a dynamic website by 13.3%, along with a 12.5% reduction of tail latency without any modifications to the applications.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Since the 1990s, dynamic linkers and loaders have been one of the most critical software tools for computer programs and applications <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b22">23]</ref>. Opposite to static linking, which generates a single big application binary, dynamic loading <ref type="foot" target="#foot_0">1</ref>permits complex software to be shipped, delivered, and distributed as a collection of libraries, modules, or components. For low-level languages, such as C/C++ and Rust, these components are implemented as dynamic libraries, also called dynamic-link libraries (.dll in Windows) or shared objects (.so in Linux). Only when a program starts will its dynamic libraries be integrated to form a runnable application by the dynamic loader. In this way, each dynamic library can be distributed and patched individually without modifying the entire application. As a result, software maintenance cost is greatly reduced while it gains much more flexibility. A study shows that more than 99% of binaries are dynamically linked on Ubuntu <ref type="bibr" target="#b44">[46]</ref>.</p><p>While the dynamic loader's functional structure has been mature and stable for more than one decade, we found it cannot meet the requirements of rapidly developing software and complicated architectures today. Two primary driving factors call out a new infrastructure for extensible and modular transformation on dynamic libraries: <ref type="bibr" target="#b0">(1)</ref> the massively increasing number of dynamic libraries used in an application and (2) the emerging diversity of manipulation and operations on dynamic libraries.</p><p>Complex commercial software heavily relies on dynamic libraries to decompose a single huge binary into many looselycoupled, fine-grained modules. This is particularly motivated by two considerations. First, some open source license requires all statically linked code should also be open-sourced. This is so-called "license contamination". GPL license <ref type="bibr" target="#b11">[12]</ref> (used by glibc) is one such example. Consequently, production software has to use dynamic libraries to avoid "license contamination".</p><p>Second, modern software needs frequent updates because of CVE fixes, bug fixes, or adding new features. However, it is painful for vendors to re-compile or link the whole software, and ask customers to reinstall the entire application. Therefore, vendors always break up software into many finegrained dynamic libraries, and each library can be maintained, phase when programs are launched. updated, or replaced independently. For instance, Figure <ref type="figure" target="#fig_0">1</ref> lists the number of dynamic libraries shipped in the CUDA Toolkit. As it shows, the number has grown rapidly over the last decade. Based on our observation from the industry, this trend will continue in the future.</p><p>Along with the growing dynamic library count, the dynamic loader is required to provide more features to make better use of emerging hardware and software technologies. For example, when using recent hardware memory protection (e.g. Intel MPK <ref type="bibr" target="#b16">[17]</ref> and SGX <ref type="bibr" target="#b15">[16]</ref>) to achieve in-process isolation, the dynamic loader has to perform more work. It loads isolated libraries into different memory regions, setups up memory protection and permission properties, and optionally verifies the signature of loaded binaries <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b35">37,</ref><ref type="bibr" target="#b36">38,</ref><ref type="bibr" target="#b38">40]</ref>. Load time code randomization and binary rewriting, provided by the dynamic loader, are widely adopted for profiling, security hardening, and architectural adaptation <ref type="bibr" target="#b49">[51,</ref><ref type="bibr" target="#b51">53,</ref><ref type="bibr" target="#b52">54]</ref>. Library debloating relies on the dynamic loader to examine and eliminate unused library code from program memory <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b33">35]</ref>. Control-Flow Integrity (CFI) and Sandbox also require miscellaneous modifications to the dynamic loader, such as analyzing relocation entries and overwriting the entry point <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b56">58]</ref>.</p><p>However, the current dynamic loading infrastructure is insufficient and inefficient to offer rich functionalities over a large number of dynamic libraries. This leads to ad-hoc changes to the dynamic loader to satisfy various requirements from different productions. Such customized modifications are incompatible with each other, and cannot be integrated or reused, causing enormous development and maintenance costs. Even worse, the fundamental infrastructure of dynamic loader has been kind of ignored by academia and industry. Thus neither research nor open source community proposes systematic solutions to deal with these issues. For instance, while there are 100+ commits in glibc related to the dynamic loader in the last two years, they are almost bug fixes or cleanup without new features developed.</p><p>According to our many years' industry experience and realistic production requirements, intrusive and customized modifications cause unacceptable maintenance cost. On the one hand, a large number of source code patches are hard to be accepted by upstream. This also happens to academia work listed above. On the other hand, production departments do not have enough source code level knowledge to maintain patches. Therefore, it is painful for the OS department to maintain many ad-hoc patches and sometimes it has to release different OS distributions with different loaders (along with glibc). As a result, it motivates a new infrastructure which satisfies following requirements: ? It offers more functionalities than existing loader.</p><p>? It can be flexibly configured for different trade-off and extended to adopt future enhancements. ? Its modifications can be implemented in a modular way that minimizes the effort to align with upstream and fix conflicts due to patch maintenance. In summary, the issue of current loader design is that it has no interface to allow extensions, thus intrusive modifications cannot be avoided. The loader is historically designed for a few simple functionalities and acts as a "translator". However, now it has to be redesigned, instead of re-engineer, to adopt emerging functionalities and allow future updates in a modular and flexible way, and becomes another platform for application optimization.</p><p>We address these challenges by designing iFed, a new infrastructure that achieves extensibility, modularity, and flexibility for dynamic library operations. Our key idea is to organize the iFed as a pipeline of distinct transformation passes instead of a monolithic tool. Each pass only implements some specific manipulation on dynamic libraries to realize its desired functionality, such as security enhancement, memory isolation, or performance optimization. We also design a runnable in-memory format (RiMF) to describe the runtime status and properties of an application and its dynamic libraries ( ?3.4). RiMF serves as an intermediate representation that every pass operates on, thus different passes are decoupled. By including complete status and information of all dynamic libraries, RiMF further enables iFed passes to do global and aggressive analysis and optimizations. A pass manager orchestrates the series of passes to be applied upon program launch ( ?3.5). Combined, these features produce the first infrastructure, as far as we know, that satisfies diverse functional requirements without loss of extensibility, flexibility, and modularity.</p><p>With various transformation passes plugged in, iFed is able to support much richer features beyond existing dynamic linking and loading. We demonstrate this by implementing two performance optimization passes. The first pass combines the same type of sections from different dynamic libraries into a continuous one, and then leverages hugepages to load the combined section ( ?3.6). The second one converts relocation branches into direct function calls, thus reducing the overhead of cross-library function calls ( ?3.7). iFed and its optimization passes are implemented to replace the GNU dynamic loader. We evaluate iFed with a large range of application benchmarks on different architectures. The results illustrate how iFed optimization passes offer better throughput, latency, and predictability than current dynamic loaders. Without any modifications to the applications in a dynamic website, iFed improves the throughput by 13.3% and reduces the average end-to-end response time by 12.5%.</p><p>Our contributions are not only enhancing current loader with some specific optimizations, but also proposing a new infrastructure that is capable to host many other loader features in production. Concretely, the contributions of this paper include:</p><p>? We introduce iFed, a pass-based infrastructure for extensible, flexible, and modular transformation on dynamic libraries during load time. ? We design two performance optimization passes in iFed.</p><p>One pass enables efficient utilization of hugepages by rearrangement and concatenation of multiple libraries. The other pass aggressively eliminates the overhead of crosslibrary invocations resulting from inefficient relocation. ? We implement iFed infrastructure with the above optimization passes as a drop-in replacement of the default dynamic loader in Linux (ld.so in glibc). iFed is fully compatible with ld.so and its all interfaces. ? An exhaustive evaluation of iFed on different architectures with a wide range of applications. The rest of this paper is organized as follows. ?2 provides background and motivation for the redesigned dynamic loaders. ?3 introduces iFed and discusses its design, while ?4 details the implementation of iFed. In ?5, we present the performance evaluation of iFed for a wide range of applications.</p><p>?6 discusses the related work, and ?7 concludes.</p><p>2 Background and Motivation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Insufficient Functionality</head><p>The basic functionalities of dynamic loading include three parts: (1) library lookup and collection; (2) memory layout preparation; and (3) symbol resolution and name binding.</p><p>The core jobs to implement these functionalities in existing dynamic loaders are simple. The loader allocates memory and maps libraries into the address space with the given layout specified in library object files. Then it resolves external symbols by populating some lookup tables with the actual memory address. While these steps are just enough to execute programs with dynamic libraries, they are not able to further transform libraries to meet diverse isolation, security, and execution requirements. Thus, many projects have to customize the loader to fulfill their system objectives. We list a few examples here.</p><p>? CubicleOS <ref type="bibr" target="#b36">[38]</ref>  loader. The loader is responsible for cubicle creation and component loading. It additionally scans binaries to ensure that there are no any MPK-related operations, and resoles cross-cubicle calls with special trampolines. ? BlankIt <ref type="bibr" target="#b31">[33]</ref> is a dynamic loading framework that predicts and loads only the set of library functions that will be used by the application. At load time, BlankIt iterates over all executable's dynamic libraries, wipes out unused functions it predicates, and overwrites these functions with a mispredication trampoline.</p><p>? Shuffler <ref type="bibr" target="#b51">[53]</ref> patches the loader to support continuous code re-randomization. The modified loader implements constructor prioritization in multiple libraries, and employs binary rewriting to track and update all code pointers.</p><p>In summary, while many projects illustrate the necessity and benefit of loader modification, they have to do some redundant work, yet their own work cannot be easily integrated by others. Hence, a new infrastructure for extensible and modular dynamic loading is necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Inefficient Performance</head><p>Even worse, current dynamic loaders fail to effectively utilize modern hardware capabilities and global system resources, resulting in sub-optimal performance. A representative case is ineffective hugepage usage.</p><p>The current loader loads each dynamic library individually, and within each library, maps code and data section randomly. Thus sections are likely loaded into fragmented memory which only uses small pages (4K) for physical memory. This leads to more TLB miss, slower library function calls, and unpredictable execution time. A better loading strategy is combining the same sections of all libraries into a big one, and loading it into hugepage memory. We study performance penalties incurred by the current loader from glibc. On an Intel machine, we conduct a micro-benchmark that simply invokes 100 dynamic libraries, and each library contains only one function accessing memory (full details in ?5). Table <ref type="table" target="#tab_0">1</ref> depicts the micro-architecture impact of (instruction) TLB miss and instruction per cycle (IPC), as well as benchmark results of 99th percentile library function call latency and total execution time. Due to loading libraries with small pages, the benchmark suffers frequent TLB miss, which further leads to slow and unpredictable execution. In contrast, dynamic library concatenation pass in iFed effectively loads libraries  The workflow of program launch starts from the operating system kernel, which loads both application and iFed binary. After iFed gets the control, it discovers, parses and transforms dynamic libraries and finally boots up the application. into hugepages, providing an order of magnitude reduction on TLB miss and 23.6% improvement on execution time. Next, we discuss how iFed enables more optimization and transformation of dynamic libraries in a modular and flexible way.</p><p>3 iFed Design</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Design Principles</head><p>iFed integrates the lessons we learned from the experience of supporting diverse production demands on the dynamic loader. We below outline the key principles, the guidance throughout iFed design. Extensibility and Modularity (P1). Due to different security or performance considerations, different production always requires a distinct subset of loader features. Therefore, various functionality should be organized in a loosely-coupled way instead of a monolithic implementation. Additionally, iFed should allow applying new features easily without intrusive modification to the loader itself. Flexibility and Customizability (P2). It is desirable that iFed capabilities can be customized on per-application, customer, or even per-run basis. Such flexibility is important for system managers and end customers to have more control over running applications, opposite to accepting everything from the current loader passively. Compatibility and Transparency (P3). Compatible with the existing loader interface is critical for iFed to be production-ready. Changes to the loader should be transparent to application developers, and require minimal modification of legacy code. Thus, we aim to design iFed as a drop-in replacement for the existing loader from the beginning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">iFed Functionality and Usage</head><p>As discussed in ?2.1, current dynamic loaders cannot keep up with application demands on new functionalities. According to these demands, we summarize the desired features a loader should provide beyond existing ones.</p><p>? Memory management. The loader should be responsible for memory allocation, library address space layout, and content initialization. This has a large impact on application performance or memory consumption. Some examples of load time memory management are library debloating <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b33">35]</ref>, replaying the profiled hot regions <ref type="bibr" target="#b27">[28]</ref>, and hugepage optimization ( ?3.6). ? Isolation. The loader is the first place to partition and load different libraries into isolated regions. The customers' strong demand to isolate untrusted or vulnerable third-party libraries paired with the emerging MPK and SGX technologies, motivate the loader to offer more isolation capabilities <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b38">40,</ref><ref type="bibr" target="#b48">50]</ref> beyond the traditional read/write/execute permission restrictions. ? Security enhancement. The loader is convenient to perform transparent security hardening regardless of running applications. For instance, we can enable CFI or sandbox <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b56">58]</ref>, apply code randomization <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b49">51]</ref> or perform binary encryption/decryption or signature verification <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b54">56]</ref>. ? Binary rewriting and execution control. In addition to traditional relocation, the loader is feasible to perform more advanced binary rewriting and control program execution, such as Shuffler <ref type="bibr" target="#b51">[53]</ref> and Egalito <ref type="bibr" target="#b52">[54]</ref>. Furthermore, load time transformation is also necessary to migrate applications among heterogeneous environments or offload execution to smart devices <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b50">52]</ref>. We will discuss a relocation elimination pass in iFed in ?3.7.</p><p>Current usage of dynamic loader is a mass of interplay among build toolchains, such as compiler and linker. Some configurations and functionalities are scattered in various parts. For example, to prevent GOT overwrite attack <ref type="bibr" target="#b17">[18]</ref>, the following gcc options are widely used: -Wl,-z,relro,-z,now. gcc passes these options down to the linker, but these options do not take effect until the dynamic loader marks the corresponding memory region as read-only. However, existing usage is not appropriate. We argue that the dynamic loader should be hidden from application developers, but configured and controlled totally by end users or system administrators. This is because customers do not trust that developers properly build the software to meet their requirements. Thus, iFed consolidates all loader-related operations in one place, and gives the control to end users who actually run the application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">iFed Architecture</head><p>When designing a loader, we should separate functional modules from low-level infrastructure. Functional modules will impact the application run-time behavior and the infrastructure orchestrates these modules. Furthermore, functional modules can be easily replaced or combined without intrusive modifications to the infrastructure and other modules. We choose pass-based architecture for the loader design. As a result, source code patches are no longer needed, and independent modules with enough semantics can be developed, configured and maintained. The overall iFed architecture is shown in Figure <ref type="figure" target="#fig_1">2</ref>. The core component in iFed is a series of transformation and optimization passes that manipulate and transform dynamic libraries for various purposes related to security, isolation, and performance. Each pass is a separate module which can be enabled or disabled independently. Such pass-based modular architecture gives great flexibility and extensibility to users to customize iFed functionality according to their own demands. All passes are managed and controlled by a pass manager ( ?3.5). Users configure the pass manager to instruct it to construct and execute the pass pipeline. The pass manager also maintains all libraries' in-memory status, and organizes them using RiMF format ( ?3.4). RiMF is an intermediate representation that is shared by all passes. In this way, passes are able to retrieve global information scatted in many libraries and to perform advanced inter-library transformations. Same as the existing loader, iFed offers other utility components as well, such as library discovery and elf parser.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Runnable In-memory Format</head><p>A main goal of iFed is splitting the current monolithic dynamic loader into extensible passes. On the one hand, it is desirable that a pass does not rely on another, thus enabling different passes to be developed and evolve independently. On the other hand, when multiple passes run together, they should be aware of how others transform libraries. Hence, we need a kind of intermediate representation that captures all libraries' status originating from library objects and generated by iFed passes on the fly. Runnable in-memory format (RiMF) is intended to coordinate iFed passes by providing a central place to hold library information at load time.</p><p>Passes in iFed do not communicate with each other directly, instead, the shared RiMF is the only interface for library transformation any pass can use. In this way, RiMF hides iFed internal complexity and other pass's implementation details to pass developers. Currently, whenever modifying the dynamic loader to add new features, a developer has to understand most of its codebase, even though much of them are irrelevant. In contrast, all a developer needs to know to write a transformation pass in iFed is the format and properties inside RiMF, and the operations it exposes. iFed maintains a single RiMF image which includes all dynamic libraries a program requires, instead of a separate object file for every library as today. Thus, iFed pass has more opportunities to apply global analysis and optimization. Our dynamic library concatenation pass demonstrates the power of global RiMF. Different from ELF object file which is designed for the dense on-disk format, RiMF rather focuses on load time in-memory representation, such as isolation constraints, memory placement and attributes, and code interposition.</p><p>The first-class object in RiMF is the isolation domain, which composes a subset of libraries within the same protection boundary. The actual isolation domain implementation depends on the iFed pass. It could be implemented by MPK, SGX or even device offloading. At the top level, RiMF consists of a list of isolation domains, inter-domain invocations that need to be resolved specially and a global application entry point. Inside each isolation domain, similar to an ELF file, RiMF provides sections, exposed symbols, and relocation records. These information are organized in a set of tables. Primary tables provided by RiMF are: (1) memory-mapping tables which describe library address space layout and memory attributes; (2) symbol tables dealing with symbol definition, binding, reference, and so forth; (3) section metadata tables that associate RiMF sections to original ELF object files. A RiMF section does not contain the actual binary, but maps to one or more ELF sections initially. RiMF varies throughout the iFed transformation pipeline. RiMF exports multiple interfaces to query, insert, modify and commit its internal tables. For example, a pass can update section metadata tables to combine different ELF sections into a new RiMF section. By manipulating symbol tables, a pass is able to remove unused code or override a function call with a customized trampoline. The commit interface is used to apply table modifications to the actual binary, such as interposing them in the library code and loading sections to memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">iFed Pass Manager</head><p>The iFed pass manager orchestrates transformation passes to operate on RiMF sequentially. The pass manager takes a user-provided configuration file and invokes each pass accordingly. In essence, the pass manager is mainly responsible for two tasks. First, the pass manager maintains the RiMF image and provides interfaces to various passes to query and modify RiMF. Second, the pass manager acts as a meta loader, which loads and executes each transformation pass. Consistent with iFed overall design principle, each transformation pass is also implemented as a dynamic library, which needs to be loaded before execution as well. For simplicity, we reuse the existing glibc loader for this minimal meta loader, so any transformation trick is not applied to pass libraries. Current iFed does not contain a sophisticated scheduling policy for running passes nor supports parallel pass execution. We leave these as future work. Thus, the user has to explicitly deal with pass dependency and pass confliction in the configuration file. Pass Dependency. In general, passes are not aware of each other because they only use RiMF as the communication medium. However, the order of passes impacts the runtime overhead a lot in some use cases. For example, a binary verification pass is preferred to run as early as possible, so following passes will not waste time on bad libraries. It is also beneficial to place one pass behind another, if it can reuse the analysis result from the previous pass, avoiding repeated work.</p><p>Some special cases must be handled carefully. vDSO is one such tricky example. vDSO is a virtual dynamic library (e.g. linux-vdso.so) inserted into the application by the kernel, but still uses the standard dynamic loading mechanisms. Popular usage of vDSO is mapping some kernel regions into the application's address space, thus some system calls can directly execute on these regions. As a consequence, vDSO libraries must be loaded earlier than any pass that will issue vDSO related system calls. Otherwise, iFed pass itself will fault due to incomplete vDSO even before the application starts running. Similarly, if a pass relies on malloc from libc, it has to make sure that malloc is working properly ahead of the pass execution. Pass confliction. With more passes integrated together, they are possible to introduce conflict transformations on libraries. Different passes may partition libraries into different isolation domains, or they have opposite optimization objectives. Currently, iFed relies on users to construct the transformation pipeline properly. Automatic dependency extraction and confliction detection will be supported in the future.</p><p>Figure <ref type="figure" target="#fig_1">2</ref> demonstrates a potential iFed transformation pass pipeline. All libraries are verified first using security signatures in the first verification pass. Then an isolation pass divides libraries into several isolation domains. Libraries in each domain are loaded into memory, where the memory management pass allocates and sets up memory permissions appropriately. The last binary rewriting pass completes symbol resolution, relocation, and other intent manipulations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Dynamic Library Concatenation</head><p>Hugepages (superpages) can greatly reduce the address translation overhead, because it eliminates one level page table hierarchy and occupies fewer TLB entries. However, the current loader does not explicitly leverage hugepages. As shown in Figure <ref type="figure">3</ref> (a), the current loader individually maps every section in each library into the process's address space. If these sections use a small amount of memory (i.e. smaller than the size of a hugepage), the operating system is unlikely to allocate hugepages for them automatically. As a result, The industry has two approaches to mitigate the impact of high TLB miss, but neither of them is ideal. Figure <ref type="figure">3</ref> (b) depicts the first approach, which allocates hugepages to hold all sections in the same library. While this approach reduces the number of used TLB entries, it brings many security vulnerabilities. Since all sections are in the same hugepage, that page should have all read/write/execute permissions required by different sections. For example, .code section becomes writeable and .data section is executable. Thus, this approach is only used in some closed environments. This, once again, indicates that the loader is capable to alter any policies designated during the development phase, making those policies unreliable. Therefore, the loader should provide capabilities to enforce security policies at load time.</p><p>The second method is illustrated in Figure <ref type="figure">3</ref> (c), such as the transparent hugepages for file systems proposed in the Linux kernel <ref type="bibr" target="#b26">[27]</ref>. In this case, hugepages are used for large sections in each library. While it works well for applications using only a few large libraries, it cannot scale to a larger number of libraries. However, as we discussed in ?1, using more and more libraries is the trend for production software, which leads to that such method will be less effective.</p><p>In iFed, we design a different approach and implement using in a iFed pass called dynamic library concatenation. The basic idea is intuitive as Figure <ref type="figure">3 (d)</ref> shows. We collect the same sections, such .code, from all dynamic libraries and concatenate them one by one to form a big section. This combined section is large enough to fit in hugepages. More importantly, all the sections share the same memory permissions, so it is safe to place them in the same hugepage. Thanks to RiMF holding all libraries' information, the dynamic library concatenation pass is able to disassemble and rearrange libraries easily.</p><p>By combining all libraries .code sections into a big one, we might reduce the possible address range used by address space layout randomization (ASLR). To mitigate this security concern, we have some options. <ref type="bibr" target="#b0">(1)</ref> We can concatenate these libraries in random order. <ref type="foot" target="#foot_1">2</ref> (2) Hugepages do not have to be continuous in the virtual address space as long as the original section does not cross two hugepages. (3) We can leverage other code randomization techniques at load time <ref type="bibr" target="#b49">[51]</ref> or run time <ref type="bibr" target="#b51">[53]</ref>, which is easier to employ in iFed.</p><p>Another potential negative impact introduced by dynamic library concatenation is library sharing. Dating back to the early days of computing, the motivation for using dynamic libraries is to save limited memory. When multiple running processes require the same library, they only share a single in-memory copy of the libraries. Library concatenation makes the sharing more difficult, as different processes have to use the same set of libraries. However, from our experience, this issue is acceptable for the following reasons. (1) The shared region is mainly the immutable code section. However, the code size of libraries is negligible compared to today's memory capacity. For instance, glibc has around 1.3 million lines of code and its un-stripped binary is only 17 MB, while a common server in the data center has 500 GB memory. (2) Thanks to the customizability of iFed, we can apply library concatenation only to key applications, while other utility or background processes still use the default memory management policy to share dynamic libraries. (3) In some cases, such as edge computing or micro-service, the same process will fork multiple times to serve different customers <ref type="bibr" target="#b34">[36]</ref>. Since the forked process has the same address layout, they can share the concatenated library without any problem. (4) In the extreme case where the library must be shared, we align sections from different libraries at the 4K boundary. Thus, the 4K page in the middle of a hugepage can still be mapped to other applications at the cost that others are unable to utilize hugepages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Relocation Branch Elimination</head><p>An important job accomplished by dynamic loaders is relocation, because the compiler cannot statically resolve crosslibrary function calls due to lack of address information. After the dynamic loader maps all libraries into process address space, it populates the actual address of unresolved functions in a lookup table. Then every call to a function in a dynamic library first retrieves the address from the lookup table and jumps to that destination. These extra actions result in a trampoline code, which is stored in another table.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> (a) shows a simplified execution flow of relocation. The table used to serve address lookup is usually called global offset table (.got) and the procedure linkage table (.plt) saves the trampoline code. When functions in foo.so (e.g. foo1 and foo2) call the function bar in bar.so, they call the trampoline (bar@plt) instead. The trampoline issues an indirect jump instruction, whose destination address is fetched  from an entry in .got (bar@got). Thus, the execution finally branches to the real address of bar (bar@bar.so). <ref type="foot" target="#foot_2">3</ref>The above relocation mechanism is applied to every function calls across dynamic libraries, thus incurring pervasive performance overhead. Figure <ref type="figure" target="#fig_3">4</ref> (b) depicts the performance cost in detail. More executed instructions. Obviously, the single call instruction is expanded to multiple trampoline instructions, consuming more CPU cycles. Even worse, the additional indirect jump puts more challenge on the branch predictor. This is exacerbated by the fact that the trampoline code is not densely packed and .plt is often sparsely accessed, leading to more branch misses. Extra memory access. The existing relocation approach also introduces more memory access. First, .plt asks for more memory to store the trampoline. Second, the trampoline needs to load from the extra .got memory. More memory access compete for the TLB and cache more frequently. Worse still, they are likely to be evicted from TLB and cache by other data access within the applications, especially in data-intensive scenarios, causing increased function call latency and unpredictability.</p><p>However, there are no practical solutions to eliminate these performance penalties. Switching to statically linked libraries is not always feasible as discussed in ?1, and some hardware methods <ref type="bibr" target="#b0">[1]</ref> are not available in production due to architectural modifications. It is also difficult to replace the relocation mechanism in the current dynamic loader with little effort.</p><p>Thanks to iFed, we have a chance to insert an optimization pass to reduce the relocation cost in an extensible manner. We design the relocation branch elimination pass for this purpose.</p><p>The key idea inside relocation branch elimination is pretty intuitive. As shown in Figure <ref type="figure" target="#fig_3">4</ref> (c), we can directly rewrite the call instructions to replace their target address using the address of library functions, instead of the address of the trampoline in .plt. The performance gain is obvious. We eliminate the extra two memory access and one instruction branch as shown in Figure <ref type="figure" target="#fig_3">4 (d)</ref>. As a result, we essentially achieve the performance of static linking on top of dynamic libraries. Despite its simple idea, we have to deal with instruction decoding, relocation sites management, and other implementation issues carefully. Implementation details are discussed in ?4.</p><p>Rewriting instructions causes it more difficult to share libraries among applications, since they have to be organized in the exact same address space layout. Thus, the relocation branch elimination pass is to be used in environments with sufficient memory. Another challenge that needs to be overcome is the distance restriction of a relative branch. When using relative addressing mode, the CPU has restrictions on the distance between the call site and the target address. <ref type="foot" target="#foot_3">4</ref> Therefore, only rewriting the target address is not always possible if the library functions are loaded far from the call sites. This issue can be handled in multiple ways.</p><p>(1) When combined with the dynamic library concatenation pass, it is rare that the distance exceeds the architectural constraint. <ref type="bibr" target="#b1">(2)</ref> We can change the relative addressing to absolute addressing mode at the cost of an extra instruction to load the address into a register. This change can be done by recompiling the code or rewriting the instructions by the loader. For instance, the Linux kernel module loader rewrites the instructions when detecting the constraint violation. (3) For the call sites that are far away from the target function, we can fall back to the existing relocation method using .plt and .got.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Discussion and Summary</head><p>The pass-based architecture enables iFed to accommodate much more load time technologies and functionalities. However, we do not argue that our architecture is the only or best way to design a loader. Other methods are possible, such as "Linux kernel module" or "systemd service unit" approach.</p><p>This is an open and new research area, and researchers are welcome to investigate more. iFed also brings side effects to program launch time and binary size, and we discuss these trade-offs below. Loading Time. While iFed infrastructure itself does not introduce additional overhead to program launch, boot time will increase as more iFed transformation passes are enabled. End users have to make the judgment on the trade-off between longer loading time and securer or faster application in run time. According to our experience so far, the increased loading time in iFed is acceptable. This is because (1) For applications that already require a modified loader to provide new functionalities, they do not suffer more extra launch costs after switching to iFed; (2) For long-running services, such as web server and database, the one-time overhead during the startup is always negligible; and (3) For short-lived tasks in high churn environments, we can explore process template and in-memory caching technology <ref type="bibr" target="#b34">[36]</ref> to fork processes from an initialized template, thus all forked processes will bypass iFed loading phase and its associated overhead. We study how our dynamic library concatenation and relocation branch elimination passes impact loading time in ?5. Binary Size. As some iFed transformation passes may need extra binary information to perform in-depth analysis, it is likely to bloat the application binaries. For example, the relocation branch elimination optimization requires the linker to retain all relocations in the executable file, resulting in larger binaries. While it is possible to scan the binary to re-generate these information, it is not wise to waste time on these redundant work. So far, the bloated binaries are not a big deal given the current massive persistent storage, but we argue the ELF-based binary scheme can be improved in the following senses. First, developers should keep relevant binary information (e.g. data generated by static analysis or bitcode of LLVM IR) as much as possible to reflect more comprehensive semantics close to the source code, instead of throwing them away at build-time and hiding them from the users. It is the user who makes the decision whether these information should be stripped at deploy-or install-time. Second, while iFed uses ELF-based objects for compatibility now, it is better to have a different object file format in iFed to match the passbased structure and RiMF image. Particularly, object files can be disassembled into per-pass pieces, and these pieces can be fetched, trimmed, or analyzed through per-pass configuration. These improvements are left as future work. Summary. We summarize how iFed resolves the issues discussed in ?1 based on our design principles. Organizing iFed with a collection of transformation passes inherently achieves modularity (P1). Passes do not directly interact with each other, but rely on the pass manager to mediate and operate on RiMF image as the only interface for collaboration. New passes are easily plugged into iFed, which significantly improves extensibility in iFed (P1). Therefore, vendors do not need to randomly modify the loader nor maintain multiple versions to satisfy customers' different demands, and in the meantime, customers are able to enjoy more features for free. Since users can choose which pass to be used in iFed via iFed configuration, they can flexibly construct transformation pipelines to customize the application at load time (P2). Paired with the iFed's capability to transform libraries with a global view, customers are flexible to determine the tradeoff among security, isolation, and performance. iFed is implemented to be compatible with the current loader, so no application modification is required (P3). More importantly, iFed enables another level of transparency for system administrators. For example, managers can insert a default security enhancement pass to iFed, regardless of if applications are built with security options.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">iFed Implementation</head><p>Figure <ref type="figure" target="#fig_1">2</ref> depicts the typical workflow of iFed during program launch. A program's binary is first loaded by the operating system, which then loads the dynamic loader's binary if necessary. Next, the kernel returns to user space and hands over the control to iFed. After discovering all required libraries, iFed invokes the pass manager with an initial RiMF image which simply contains all libraries in a single isolation domain. Based on the iFed configuration, the pass manager loads and executes each pass in sequence. Finally, iFed invokes the application's entry point and completes the loading phase. Compatibility. Current iFed is implemented on top of glibc 2.28. We reuse some utility components, such as library discovery and ELF parser from the glibc. As a result, iFed is able to load unmodified ELF binaries and supports common loader extensions, such as LD_PRELOAD. For compatibility, the existing dynamic loader (i.e. ld.so) is organized as a special fake pass in iFed. Linux allows an application to specify the dynamic loader it will use. Thus, we use this facility to enable the usage of iFed within applications. Dynamic Library Concatenation. In this pass, we collect the same sections from all libraries and pack them into continuous memory backed by hugepages. To save memory, the last page is converted to small pages if less than 64 KB memory is occupied. While the implementation is intuitive, we must fixup the global variable access. Global variables are always accessed via offset, which is the difference between the address of the accessing instruction and the variable itself. For example, in Figure <ref type="figure">3</ref> (a) and (d), the offset between the .code and .data section within the foo.so is changed due to the rearrangement. Thus accessing variables in the .data section is broken. Our current solution is to instruct the compiler to emit all the symbol access information (e.g. using emit-relocs options in gcc), and to fix the offset during the pass execution. The book-keeping infomation inside iFed is also updated according to the finalized address, so as to serve run-time loader interfaces, such as dlsym() and dladdr(). We only rearrange the libraries which are position independent. Relocation Branch Elimination. This pass rewrites the branch instructions so that they do not need indirect jump based on .plt and got. First, we identify all branch instructions from the relocation records. Each record saves the position of the instruction and the remote symbol it references. The symbol could be either a function or a variable. Then, we find the actual address of the symbol and modify the instruction to use the address instead. Modifying instructions is architecture-dependent. We further optimize the function pointer invocations. In case of the function address can be determined at the loading time, we substitute the function pointer with the actual function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>Our evaluation goals include:</p><p>? Illustrate the effectiveness of dynamic library concatenation and relocation branch elimination pass using microarchitecture statistics. ? Understand the applicability of iFed along with our optimization with a wide range of applications. ? Assess the generality when running iFed on different hardware architectures. Setup. We evaluate iFed on two architectures. The first one is two 26-core sockets Intel(R) Xeon(R) CPU @ 2.3GHz, with hyper-threading enabled, resulting in 104 cores in total. The other is ARM Kunpeng-920 CPU @ 2.6GHz with four NUMA nodes, and each node has 24 cores. All experiments run on openEuler 20.03 [30] based on Linux 4.19 kernel. We compare iFed with the system default dynamic loader, ld.so in glibc 2.28.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Micro-benchmarks</head><p>We conduct a set of micro-benchmarks to evaluate the performance improvement of library concatenation and relocation branch elimination passes in iFed. Each test calls functions provided by a configurable number of dynamic libraries, and each function accesses a certain amount of memory. Figure <ref type="figure" target="#fig_5">5</ref> and Figure <ref type="figure">6</ref> study the impact of different library counts and working set sizes in the library function, respectively. All tests are run 500K iterations on the Intel machine. We compare four different implementations, (1) glibc -the system default dynamic loader. (2) iFed-hugepage -iFed with only dynamic library concatenation pass. (3) iFed-relocation -iFed with only relocation branch elimination pass. (4) iFed-iFed with both optimization passes. Micro-architecture Impact. Figure <ref type="figure" target="#fig_5">5</ref> (a) shows the number of misses in instruction TLB. With more libraries involved, the total iTLB miss grows rapidly. glibc incurs the most iTLB miss because it uses 4K pages to load libraries and runs out of the limited number of iTLB entries. iFed-    relocation has little difference with glibc as it uses 4K pages, too. However, iFed-hugepage and iFed perform much better than glibc (note the log scale of y axis). Thanks to the usage of hugepage, they reduce the iTLB miss by an order of magnitude when the library count is smaller than 160, and by 40% with larger library counts. Less TLB miss leads to higher IPC as shown in Figure <ref type="figure" target="#fig_5">5</ref> (b). In addition to TLB miss, fewer code branches also decrease IPC. Thus, glibc has lower IPC than iFed-relocation, and iFed performs the best after integrating both optimizations. While the purposed optimizations almost work on .code sections, they also get benefits with a varied amount of data access as shown in Figure <ref type="figure">6</ref>. With more data access, they compete for the cache and TLB when shared with .code, .plt and .got sections. This is illustrated in Figure <ref type="figure">6</ref> (a) where iFed-relocation triggers less TLB miss than glibc. In Figure <ref type="figure">6</ref> (b), IPC increases with the larger working set, as the memory access dominates the program execution. However, glibc performs worse than all iFed variants. Latency Analysis. The improvements on micro-architecture further lead to the reduction in total execution time as depicted in Figure <ref type="figure" target="#fig_5">5</ref> (c) and Figure <ref type="figure">6 (c</ref>). All execution time rise linearly with the test scale, but iFed runs faster than glibc in all cases. For instance, with 200 libraries and a 256 KB working set, iFed is 6% faster than glibc. More importantly, due to less TLB miss and branch, the predictability of library function invocation is improved a lot. To better understand the latency of library function calls, Figure <ref type="figure">7</ref> presents a CDF of function call latencies under different configurations. From the results, we observe that glibc has higher tail latency than iFed. For the 99th percentile latencies under the three configurations, iFed has improvements of 19%, 27%, and 3%, respectively. Loading Time Discussion. Since iFed incorporates more functionalities, it inevitability slows down the time to launch a program. Table <ref type="table">2</ref> reports the loading time spent in the interval from the exec system call to the program's main function, when loading a redis server. As discussed in ?4, the current iFed contains the glibc loader for compatibility, thus the result differences indicate the overhead of iFed optimization passes. Dynamic library concatenation overhead mainly comes from memory movement. The cost of relocation branch elimination depends on the number of relocation sites that has to be rewritten, thus it may incur a larger overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Application Benchmarks</head><p>We evaluate iFed with Phoronix test suite v10.4.0 <ref type="bibr" target="#b40">[42]</ref>, which has a wide range of common applications and realistic workloads. We selected 23 applications from multiple domains that stress different components in the system, such as memory (zstd-compress), processor (botan), disk (postmark) and network (iperf). These tests also cover different running forms of multi-process, single-and multi-thread. We run these tests in two environments, the ARM Kunpeng server and a 60-core KVM-based virtual machine hosted in the Intel machine, because VMs are popularly deployed to hold applications today. Hardware virtualization is enabled, and the VM is configured with 128G memory. The guest OS is also openEuler 20.03 based on Linux 4.19 kernel. We enable all optimization passes in iFed, and report the average performance speedup compared to glibc in Figure <ref type="figure">8</ref> and Figure <ref type="figure">9</ref>. The data is gathered from the built-in performance comparison tool in Phoronix. Since better hugepage usage and eliminated .got/.plt indirection in iFed will improve many tightly correlated micro architecture factors, we use perf to measure some typical CPU events for each bench-mark. Table <ref type="table" target="#tab_4">3</ref> lists the percentage of TLB miss reduction, branch miss reduction, and IPC improvement compared to glibc on both ARM and Intel testbeds.</p><p>Whether an application can get benefits from iFed depends on its bottleneck. For computing intensive applications who do not suffer from TLB miss or branch mispredictions, iFed keeps the same performance with glibc. For example, botan is a C++ crypto library and the benchmark measures the performance of many cryptographic algorithms. iFed has less than 1.5% performance difference with glibc in all test cases. As shown in Table <ref type="table" target="#tab_4">3</ref>, iFed has a negligible impact on IPC. xsbench tests a key computational kernel of the Monte Carlo neutronics application OpenMC. iFed does not reduce branch misses on ARM, thus the performance difference between iFed and glibc is less than 2%.</p><p>When the application is memory bound and its data compete for the shared TLB and cache with the code, iFed is able to mitigate the interference and improve the performance. For instance, the zstd-compress benchmark compresses and decompresses a 1 GB Linux kernel image. iFed reduces the number of TLB misses by 16.56% and 19.4% on Intel and ARM machine, respectively. Please note that our dynamic library concatenation deals with both .code and .data section, thus iFed does not only reduce iTLB misses. As a result, iFed speedups the benchmark by 7.3% on Intel and 25.7% on ARM.</p><p>For complicated applications that have complex function call patterns across libraries or use many dynamic libraries, iFed can boost their performance. For example, leveldb from Google gets 1.1% and 21.2% better performance on Intel and ARM platform, respectively. On ARM, glibc in-curs 10 9 instruction TLB misses, while iFed just incurs 10 5 iTLB misses! ncnn is a mobile neural network inference framework developed by Tencent. Its IPC is improved by 3.04% and 6.36% on Intel and ARM platform respectively, and correspondingly iFed gets 7.7% and 24% overall better performance. iperf and nuttcp have a large performance boost because both benchmark server and client are loaded by iFed.</p><p>In some cases, iFed shows large relative improvements on perf events while has little impacts on the benchmark performance. That is because the event's absolute numbers are so small that slight variations of the event result in large percentage difference. For example, on the Intel machine, optcarrot shows 10.45% less TLB misses while its performance is only 2.9% better. After examining the absolute number of TLB misses, we found there are only 1.8 million misses with glibc and iFed lowers it to 1.6 million. Those numbers are several orders of magnitude smaller than those in other memory intensive benchmarks. Another example is branch miss reduction in botan benchmark on the ARM platform. botan experiences around 323K and 311K branch misses under glibc and iFed respectively. Despite 3.65% reduction in branch misses, iFed does not have speedup over glibc.</p><p>To further validate our results, we analyse the rocksdb benchmark on the Intel VM in depth. The benchmark contains 3857 .got entries and 8153 .plt entries, and 94327 relocation sites point to these entries. With glibc, 15.6% of total cycles are spent on page table walk due to TLB misses, while this ratio is reduced to 10% after iFed optimization. Relocation branch elimination pass contributes 6% improvement, and dynamic library concatenation pass continues to improve 10%, leading to an overall improvement of 18%. We also tested a statically linked version which performs 9% better than the dynamic one with glibc. This improvement is less than iFed with the hugepage optimization, but is better than iFed with relocation elimination since static linking has more chance to apply link-time optimization.</p><p>In general, we do not observe the loading time overhead causing performance degradation even for the benchmarks which need to frequently boot up and shut down the test programs. On the Intel virtual machine, compared to glibc, the average TLB miss is reduced by 8.58%, the average branch miss is reduced by 3.28%, and the average IPC is improved by 3.02%. iFed is 3.7% better than glibc on average and achieves 18% maximum improvement.    machine, iFed reduces 13.04% TLB miss, lowers the branch miss by 1.85%, and improves the IPC by 7.33%, on average. The average speedup is 7% and the largest improvement is 33%. In most cases, iFed achieves a larger improvement on the physical machine than the virtual machine. This is because VMs have an extra address translation layer. Thus if the host OS allocates small pages to the guest OS, iFed will get less benefit by enabling hugepage in the guest OS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Web Serving</head><p>Finally, we evaluate iFed in a system-wide scenario with a web serving benchmark from Clousuite <ref type="bibr" target="#b9">[10]</ref>. This benchmark is a dynamic website hosting a production-quality social networking engine. Since the current Clousuite is not supported on ARM architecture, we port it to our ARM machine, and upgrade its components to newer versions. Particularly, we use nginx 1.16.1, mysql 8.0.17, PHP 7.2.10, and elgg 3.0.7. We run the client and server on two ARM machines under the same ToR switch. The client simulates multiple users who browse the website and issue different operations, such as register, login, and send messages to a friend. These operations are mixed in a distribution that favors common operations (e.g. send a message and post a tweet), while containing fewer login/logout operations. Each test case runs 5 minutes, and Clousuite collects the throughput and response time.</p><p>Figure <ref type="figure" target="#fig_10">10</ref> shows the normalized performance with various simulated concurrent users. The efficiency is seen in the improved throughput, reduced response time, and tail latency. The performance keeps increasing with more users until the system is saturated. For the peak performance, iFed has 13.3% higher throughput, 14.7% smaller average response, time and 12.5% lower 99th percentile latency. Figure <ref type="figure" target="#fig_11">11</ref> shows the detailed performance statistics of each operation with 110 concurrent users. iFed is better than glibc in most cases. For the throughput of register operation, iFed is lower because the client issues less register operation due to the probabilistic workload distribution. This is also confirmed by the reduced response time from Figure <ref type="figure" target="#fig_11">11</ref> (b) and (c). To summarize, these results demonstrate that optimizations in iFed are effective in the realistic multi-application environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Loader modification and improvement. Many projects have to modify the loader to achieve their specific goals, even though the loader is not of their research contribu-tion. However, the current dynamic loading infrastructure is neither flexible nor extensible to accommodate those modifications, causing their research to have limited applications in the industry. When utilizing MPK <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b36">38,</ref><ref type="bibr" target="#b48">50]</ref> or SGX <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b35">37,</ref><ref type="bibr" target="#b38">40,</ref><ref type="bibr" target="#b42">44,</ref><ref type="bibr" target="#b58">60]</ref> for stronger isolation or security, most works have to modify the loader to be aware of such isolation facility. Besides hardware-assistant isolation, software implementation also require to coordinate with loader, such as sandbox <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b53">55]</ref> and CFI <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b56">58]</ref>. It is necessary to change the loader to support program migration and execution on remote, heterogeneous, or smart devices <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b50">52]</ref>. Kard <ref type="bibr" target="#b1">[2]</ref> leverages MPK for per-thread memory protection to implement a dynamic data race detector, which uses a custom loader to handle global variables. Shuffler <ref type="bibr" target="#b51">[53]</ref> continuously re-randomizes code locations in a separate thread, but requires a small loader patch for bootstrap. With iFed, these modifications will be made easily and further reused across different projects.</p><p>Agrawal et al. propose a speculative hardware mechanism to avoid executing relocation trampolines <ref type="bibr" target="#b0">[1]</ref>, while we provide a pure software approach to eliminate relocation overhead in iFed. Stephen Kell et al. describe the formal semantics for static linking <ref type="bibr" target="#b18">[19]</ref>. As iFed decouples a monolithic dynamic loader into smaller pieces, we expect a similar formal method can be applied to dynamic linking as well. Load time technologies. There is a large body of research focusing on load time technology. Paschalis Mpeis et al. introduce a capture and replay mechanism <ref type="bibr" target="#b27">[28]</ref> that detect and profile hot code regions, and optimize them offline. Instead of the original code from binary, these captured and optimized hot regions are fed into the loader to replay. Egalito <ref type="bibr" target="#b52">[54]</ref> is a binary transformation framework that supports dynamic analyses or code-generation at load time. Load time binary stirring <ref type="bibr" target="#b49">[51]</ref> randomly reorders some code sections and repairs code pointers accordingly. ASLR-Guard <ref type="bibr" target="#b25">[26]</ref> contains a dynamic loader, which decouples code sections from data sections and encrypts some sensitive regions. Library debloating <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b33">35]</ref> is a type of load time optimization that loads only the set of library functions that will be used at each library call site within the application at runtime. iFed provides a platform to explore and integrate broader load time technologies. Wei Dong et al. propose a holistic dynamic linking and loading mechanism in networked embedded systems to generate minimal code size <ref type="bibr" target="#b8">[9]</ref>. Loader on new system and architecture. Since dynamic loader is a basic toolkit, it has to be rewritten whenever a new system or hardware comes. For example, RedLeaf <ref type="bibr" target="#b28">[29]</ref> is a rust-base OS with a new abstraction, called Domains, for lightweight isolation, and supports dynamically loaded Domains. CARAT <ref type="bibr" target="#b39">[41]</ref> allows programs to run efficiently in a physical address space and needs a loader to collaborate properly. Different loaders are also implemented within different system architectures, such as microkernel <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b47">49]</ref>, unikernel <ref type="bibr" target="#b41">[43]</ref> or LibOS <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b32">34,</ref><ref type="bibr" target="#b43">45,</ref><ref type="bibr" target="#b57">59]</ref>. Similarly, the loader is always needed to be updated to explore new hardware features for isolation <ref type="bibr" target="#b37">[39]</ref>, security <ref type="bibr" target="#b29">[31]</ref>, communication <ref type="bibr" target="#b46">[48]</ref>, container <ref type="bibr" target="#b55">[57]</ref>, and embedded device <ref type="bibr" target="#b20">[21]</ref>. With the help of iFed's modular design, we are able to extract the system agnostic or architecture independent parts and reduce the porting effort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>We introduce iFed, an infrastructure for dynamic library transformation. While iFed is compatible with the current dynamic loader, its function goes beyond the traditional dynamic linking and loading. By a pass-based architecture and RiMF, iFed can provide much richer functionalities over isolation, security, and optimizations in a flexible, extensible, and modular way. We demonstrate the extensibility of iFed by implementing two optimization passes. One pass reduces TLB miss and improves IPC because of the effective usage of hugepages. The other pass rewrites the call sites to eliminate function relocation overhead. Modularity and extensibility are crucial to reducing the development, deployment, and maintenance costs of today's complicated system software. We believe it is an open research area to investigate modular design in many other monolithic system software, not just in the loader.</p><p>Our evaluation shows optimizations in iFed improve performance and predictability for a wide range of applications on multiple architectures and platforms. On an ARM physical machine, iFed achieves up to 33% speedup, and on an Intel virtual machine, iFed gets a maximum improvement of 18%. In a complex dynamic website that requires collaboration among multiple applications, iFed improves the throughput by 13.3% and achieves a 12.5% reduction of end-to-end 99th percentile latency. More importantly, iFed boosts the performance transparently with no application changes. Building on both customers' demands from industry and load time technology advances from academia, the dynamic library manipulation infrastructure is a promising area of research. We believe that iFed paves the first example of a new generation of dynamic loaders for integrating research advancement of load-time transformations and technologies.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The number of dynamic libraries included in the CUDA Toolkit over the past decade.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: iFed architecture and workflow. The pass manager loads and invokes a series of transformation passes, which interact with RiMF.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Function call relocation for dynamic libraries. Function foo1 and foo2 in foo.so call function bar in bar.so. In (a), function calls are first redirected to .plt, and consult .got entries to get the destination address, and finally branch to the destination.(b) depicts that the current relocation method incurs three memory access and two code branches. As shown in (c), the relocation branch elimination pass in iFed rewrites the function call sites so that they directly jump to the destination. As a result, only one memory access and code branch is needed in (d).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Micro-benchmarks: the working set is fixed at 256 KB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>Figure 6: Micro-benchmarks: the number of dynamic library is 100.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>2 :</head><label>2</label><figDesc>Loading time overhead comparison. These are the cost to load a redis server which has 36195 relocation sites.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :SpeedupFigure 9 :</head><label>89</label><figDesc>Figure 8: Phoronix test suite on ARM physical machine.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Dynamic web serving performance. All data are normalized to the result of 10 concurrent users with glibc. (a) shows the throughput across all operations, the higher the better; (b) shows the average response time of postwire operation (similar to posting a tweet), the lower the better; (c) shows the 99th percentile latency of postwire operation, the lower the better.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Performance of each operation with concurrent 110 users. All data are the speedup ratio normalized to the the higher the better.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic url="image-1.png" coords="1,-9.00,-10.01,630.00,255.87" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic url="image-2.png" coords="1,-9.00,543.00,630.00,259.01" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Performance comparison between glibc and iFed on x86 machine.</figDesc><table><row><cell></cell><cell>TLB</cell><cell></cell><cell cols="2">99th percentile Execution</cell></row><row><cell></cell><cell>miss</cell><cell>IPC</cell><cell>latency (cycle)</cell><cell>time (s)</cell></row><row><cell cols="4">glibc 1,231,950 1.96 318</cell><cell>6.01</cell></row><row><cell>iFed</cell><cell>117,782</cell><cell cols="2">2.43 232</cell><cell>4.86</cell></row></table><note><p>is a library OS that isolates components in MPK protected memory regions, called cubicles. It implements a new cubicle loader who acts as the dynamic</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Application benchmarks: percentage of TLB miss reduction, branch miss reduction, and IPC improvement..</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Dynamic loading is also referred to as run-time loading, a mechanism that an application opens, loads, and executes a library by explicitly calling loader interfaces during program execution. As run-time loading shares almost the same backend technology with dynamic loading, throughout this paper, we use dynamic loading to refer to the integrated linking and loading</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Existing loader (e.g. ld.so) loads libraries in a deterministic way, which is decided by its internal library discovery algorithm according to the dependency information from application binaries.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This simplified execution flow omits some complexities. .got entries are initially populated with a pointer to a loader's own resolver function. So when a library function is invoked at its first time, it branches to the resolver function, which then updates the .got entry using the actual address. This also requires additional instructions to be patched into the trampoline.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>This is because only a subset of bits in the branch instruction is available to encode the address. For example, x86 limits the range as ?2 GB, while ARM has a limitation of ?128 MB.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>We sincerely thank our shepherd <rs type="person">Andreas Haeberlen</rs> for his insightful feedback. We are grateful to the OSDI anonymous reviewers for their valuable comments and suggestions. We thank the <rs type="institution">EulerOS team at Huawei</rs> for their contributions to this work, including but not limited to, <rs type="person">Zixian Liu</rs>, <rs type="person">Bin Wang</rs>, <rs type="person">Sirui Liu</rs>, <rs type="person">Pan Zhang</rs>, <rs type="person">Lin Fu</rs>, <rs type="person">Xiangyang Yu</rs>, <rs type="person">Yanchao Yang</rs>, <rs type="person">Chao Liu</rs>, <rs type="person">Danni Xia</rs>, <rs type="person">Jiaqi Yang</rs>, <rs type="person">Yining Shen</rs>, <rs type="person">Tianxiong Lu</rs>, <rs type="person">Haomin Cai</rs>, <rs type="person">Wei Du</rs>, and <rs type="person">Guiping Zhang</rs>.</p></div>
			</div>			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Architectural support for dynamic linking</title>
		<author>
			<persName><forename type="first">Varun</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhiroop</forename><surname>Dabral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tapti</forename><surname>Palit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yongming</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Ferdman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;15)</title>
		<meeting>the 20th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;15)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Lightweight data race detection with per-thread memory protection</title>
		<author>
			<persName><forename type="first">Adil</forename><surname>Ahmad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Byoungyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><surname>Kard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;21)</title>
		<meeting>the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;21)</meeting>
		<imprint>
			<biblScope unit="page">2021</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Breaking the boundaries in heterogeneous-isa datacenters</title>
		<author>
			<persName><forename type="first">Antonio</forename><surname>Barbalace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Lyerly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Jelesnianski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Carno</surname></persName>
		</author>
		<author>
			<persName><surname>Ho-Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Chuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Binoy</forename><surname>Legout</surname></persName>
		</author>
		<author>
			<persName><surname>Ravindran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;17)</title>
		<meeting>the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;17)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Composing os extensions safely and efficiently with bascule</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Baumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongyoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lisa</forename><surname>Glendenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacob</forename><forename type="middle">R</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barry</forename><surname>Bond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reuben</forename><surname>Olinsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Galen</forename><forename type="middle">C</forename><surname>Hunt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM European Conference on Computer Systems (Eu-roSys&apos;13)</title>
		<meeting>the 8th ACM European Conference on Computer Systems (Eu-roSys&apos;13)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Dune: Safe user-level access to privileged CPU features</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Belay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Bittau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Mashtizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Terei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mazi?res</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Kozyrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th USENIX Symposium on Operating Systems Design and Implementatio (OSDI&apos;12)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Xios: Extended application sandboxing on ios</title>
		<author>
			<persName><forename type="first">Mihai</forename><surname>Bucicoiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lucas</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Razvan</forename><surname>Deaconescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security (Asia CCS&apos;15)</title>
		<meeting>the 10th ACM Symposium on Information, Computer and Communications Security (Asia CCS&apos;15)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Graphene-sgx: A practical library OS for unmodified applications on SGX</title>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Chia Che Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mona</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><surname>Vij</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 USENIX Annual Technical Conference (ATC&apos;17)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Flick: Fast and lightweight isa-crossing call for heterogeneous-isa environments</title>
		<author>
			<persName><forename type="first">Shenghsun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Han</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergey</forename><surname>Madaminov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Milder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA&apos;20)</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dynamic linking and loading in networked embedded systems</title>
		<author>
			<persName><forename type="first">Wei</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chun</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xue</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiajun</forename><surname>Bu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yunhao</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 IEEE 6th International Conference on Mobile Adhoc and Sensor Systems</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="554" to="562" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Clearing the clouds: A study of emerging scale-out workloads on modern hardware</title>
		<author>
			<persName><forename type="first">Almutaz</forename><surname>Michael Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Adileh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stavros</forename><surname>Kocberber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Djordje</forename><surname>Alisafaee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cansu</forename><surname>Jevdjic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><forename type="middle">Daniel</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasia</forename><surname>Popescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Babak</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;12)</title>
		<meeting>the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dynamic linking of software components</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Franz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="74" to="81" />
			<date type="published" when="1997-03">March 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Gnu lesser general public license</title>
		<ptr target="https://www.gnu.org/licenses/lgpl-3.0.html" />
		<imprint/>
	</monogr>
	<note>Free Software Foundation (FSF)</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Repurposing segmentation as a practical lvi-null mitigation in sgx</title>
		<author>
			<persName><forename type="first">Lukas</forename><surname>Giner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Kogler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Canella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st USENIX Security Symposium (USENIX Security&apos;22))</title>
		<imprint>
			<biblScope unit="page">2022</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Hodor: Intra-process isolation for highthroughput data plane libraries</title>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Hedayati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Spyridoula</forename><surname>Gravani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ethan</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Criswell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Marty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference (ATC&apos;19)</title>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An approach to genuine dynamic linking</title>
		<author>
			<persName><forename type="first">W</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Wilson</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronald</forename><forename type="middle">A</forename><surname>Olsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software-Pratice and Experience</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="375" to="390" />
			<date type="published" when="1991-04">April 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<ptr target="https://www.intel.com/content/www/us/en/architecture-and-technology/software-guard-extensions.html" />
	</analytic>
	<monogr>
		<title level="j">Intel. Intel(R) Software Guard Extensions</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Intel R 64 and IA-32 Architectures Software Developer</title>
		<author>
			<persName><surname>Intel</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>s Manual</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A cfi countermeasure against got overwrite attacks</title>
		<author>
			<persName><forename type="first">Seunghoon</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jaejoon</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyukjin</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongkyoo</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="36267" to="36280" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The missing link: Explaining elf static linking, semantically</title>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Kell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dominic</forename><forename type="middle">P</forename><surname>Mulligan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Sewell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA&apos;16)</title>
		<meeting>the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA&apos;16)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Sel4: Formal verification of an os kernel</title>
		<author>
			<persName><forename type="first">Gerwin</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Elphinstone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">June</forename><surname>Andronick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Cock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><surname>Derrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dhammika</forename><surname>Elkaduwe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Engelhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafal</forename><surname>Kolanski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Norrish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harvey</forename><surname>Tuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Winwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles (SOSP&apos;09)</title>
		<meeting>the ACM SIGOPS 22nd Symposium on Operating Systems Principles (SOSP&apos;09)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Trustlite: A security architecture for tiny embedded devices</title>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Koeberl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steffen</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Varadharajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth European Conference on Computer Systems (EuroSys&apos;14)</title>
		<meeting>the Ninth European Conference on Computer Systems (EuroSys&apos;14)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Code-pointer integrity</title>
		<author>
			<persName><forename type="first">Volodymyr</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L?szl?</forename><surname>Szekeres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Candea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation</title>
		<meeting>the 11th USENIX Conference on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">R</forename><surname>Levine</surname></persName>
		</author>
		<title level="m">Linkers and Loaders</title>
		<meeting><address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>st edition</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Minibox: A two-way sandbox for x86 native code</title>
		<author>
			<persName><forename type="first">Yanlin</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Mccune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brandon</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Will</forename><surname>Drewry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 USENIX Annual Technical Conference (ATC&apos;14)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Controlflow carrying code</title>
		<author>
			<persName><forename type="first">Yan</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaoyang</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Debin</forename><surname>Gao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 ACM Asia Conference on Computer and Communications (AsiaCCS&apos;19</title>
		<meeting>the 2019 ACM Asia Conference on Computer and Communications (AsiaCCS&apos;19</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Aslr-guard: Stopping address space leakage for code reuse attacks</title>
		<author>
			<persName><forename type="first">Kangjie</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Byoungyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><forename type="middle">P</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenke</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security (CCS&apos;15)</title>
		<meeting>the 22nd ACM SIGSAC Conference on Computer and Communications Security (CCS&apos;15)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><surname>Lwn</surname></persName>
		</author>
		<author>
			<persName><surname>Net</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/789159/" />
		<title level="m">Transparent huge pages for filesystems</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Developer and user-transparent compiler optimization for interactive applications</title>
		<author>
			<persName><forename type="first">Paschalis</forename><surname>Mpeis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pavlos</forename><surname>Petoumenos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><surname>Hazelwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugh</forename><surname>Leather</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI&apos;21)</title>
		<meeting>the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI&apos;21)</meeting>
		<imprint>
			<biblScope unit="page">2021</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Redleaf: Isolation and communication in a safe operating system</title>
		<author>
			<persName><forename type="first">Tianjiao</forename><surname>Vikram Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Detweiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhaofeng</forename><surname>Appel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerd</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anton</forename><surname>Zellweger</surname></persName>
		</author>
		<author>
			<persName><surname>Burtsev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th USENIX Symposium on Operating Systems Design and Implementation (OSDI&apos;20)</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Closing controlled channels with selfpaging enclaves</title>
		<author>
			<persName><forename type="first">Meni</forename><surname>Orenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Baumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName><surname>Autarky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth European Conference on Computer Systems (EuroSys&apos;20)</title>
		<meeting>the Fifteenth European Conference on Computer Systems (EuroSys&apos;20)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Safebricks: Shielding network functions in the cloud</title>
		<author>
			<persName><forename type="first">Rishabh</forename><surname>Poddar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chang</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raluca</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ada</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvia</forename><surname>Ratnasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">15th USENIX Symposium on Networked Systems Design and Implementation (NSDI&apos;18)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Blankit library debloating: Getting what you want instead of cutting what you don&apos;t</title>
		<author>
			<persName><forename type="first">Chris</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Girish</forename><surname>Mururu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prithayan</forename><surname>Barua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santosh</forename><surname>Pande</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;20)</title>
		<meeting>the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;20)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Rethinking the library os from the top down</title>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silas</forename><surname>Boyd-Wickizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reuben</forename><surname>Olinsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Galen</forename><forename type="middle">C</forename><surname>Hunt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;11)</title>
		<meeting>the Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Debloating software through piece-wise compilation and loading</title>
		<author>
			<persName><forename type="first">Anh</forename><surname>Quach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aravind</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lok</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium (USENIX Security&apos;18))</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Fine-grained isolation for scalable, dynamic, multi-tenant edge clouds</title>
		<author>
			<persName><forename type="first">Yuxin</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guyue</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vlad</forename><surname>Nitu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenyuan</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riley</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriel</forename><surname>Parmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alain</forename><surname>Tchana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 USENIX Annual Technical Conference (ATC&apos;20)</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Spons &amp; shields: Practical isolation for trusted execution</title>
		<author>
			<persName><forename type="first">Vasily</forename><forename type="middle">A</forename><surname>Sartakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O'</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Keeffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Llu?s</forename><surname>Eyers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Vilanova</surname></persName>
		</author>
		<author>
			<persName><surname>Pietzuch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments (VEE&apos;21)</title>
		<meeting>the 17th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments (VEE&apos;21)</meeting>
		<imprint>
			<biblScope unit="page">2021</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Cubicleos: A library os with software componentisation for practical isolation</title>
		<author>
			<persName><forename type="first">Vasily</forename><forename type="middle">A</forename><surname>Sartakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Llu?s</forename><surname>Vilanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Pietzuch</surname></persName>
		</author>
		<idno>ASP- LOS&apos;21</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the 26th International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<biblScope unit="page">2021</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Domain keys -efficient inprocess isolation for risc-v and x86</title>
		<author>
			<persName><forename type="first">David</forename><surname>Schrammel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Weiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Steinegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Schwarzl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName><surname>Donky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th USENIX Security Symposium (USENIX Security&apos;20)</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Occlum: Secure and efficient multitasking inside a single enclave of intel sgx</title>
		<author>
			<persName><forename type="first">Youren</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongliang</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Runji</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yubin</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shoumeng</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note>ASP-LOS&apos;20</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Carat: A case for virtual memory through compiler-and runtime-based address translation</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Suchy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simone</forename><surname>Campanoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikos</forename><surname>Hardavellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Dinda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;20)</title>
		<meeting>the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;20)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="329" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<ptr target="https://www.phoronix-test-suite.com/" />
		<title level="m">Phoronix Test Suite</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Intra-unikernel isolation with intel memory protection keys</title>
		<author>
			<persName><forename type="first">Mincheol</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Olivier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Lankes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Binoy</forename><surname>Ravindran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments (VEE&apos;20)</title>
		<meeting>the 16th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments (VEE&apos;20)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">rkt-io: a direct I/O stack for shielded execution</title>
		<author>
			<persName><forename type="first">J?rg</forename><surname>Thalheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harshavardhan</forename><surname>Unnibhavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Priebe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pramod</forename><surname>Bhatotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">R</forename><surname>Pietzuch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Computer Systems (EuroSys&apos;21)</title>
		<imprint>
			<biblScope unit="page">2021</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Cooperation and security isolation of library oses for multi-process applications</title>
		<author>
			<persName><forename type="first">Chia-Che</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kumar</forename><surname>Saurabh Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nehal</forename><surname>Bandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bhushan</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Jannen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jitin</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harry</forename><forename type="middle">A</forename><surname>Vrushali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Oliveira</surname></persName>
		</author>
		<author>
			<persName><surname>Porter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth European Conference on Computer Systems (EuroSys&apos;14)</title>
		<meeting>the Ninth European Conference on Computer Systems (EuroSys&apos;14)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A study of modern linux api usage and compatibility: What to support when you&apos;re supporting</title>
		<author>
			<persName><forename type="first">Chia-Che</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bhushan</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nafees</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmed</forename><surname>Abdul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh European Conference on Computer Systems (EuroSys&apos;16)</title>
		<meeting>the Eleventh European Conference on Computer Systems (EuroSys&apos;16)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Practical context-sensitive cfi</title>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Victor Van Der Veen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Enes</forename><surname>Andriesse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>G?kta?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lionel</forename><surname>Gras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Asia</forename><surname>Sambuc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Herbert</forename><surname>Slowinska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristiano</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName><surname>Giuffrida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security (CCS&apos;15)</title>
		<meeting>the 22nd ACM SIGSAC Conference on Computer and Communications Security (CCS&apos;15)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Yoav Etsion, and Mateo Valero. Direct inter-process communication (dipc): Repurposing the codoms architecture to accelerate ipc</title>
		<author>
			<persName><forename type="first">Llu?s</forename><surname>Vilanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Jord?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nacho</forename><surname>Navarro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth European Conference on Computer Systems (EuroSys&apos;17)</title>
		<meeting>the Twelfth European Conference on Computer Systems (EuroSys&apos;17)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">SPeCK: a kernel for scalable predictability</title>
		<author>
			<persName><forename type="first">Qi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuxin</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matt</forename><surname>Scaperoth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriel</forename><surname>Parmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st IEEE Real-Time and Embedded Technology and Applications Symposium (RTAS&apos;15)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Secure and efficient in-process monitor (and library) protection with intel mpk</title>
		<author>
			<persName><forename type="first">Xiaoguang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sengming</forename><surname>Yeoh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Olivier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Binoy</forename><surname>Ravindran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th European Workshop on Systems Security (EuroSec&apos;20)</title>
		<meeting>the 13th European Workshop on Systems Security (EuroSec&apos;20)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Binary stirring: Self-randomizing instruction addresses of legacy x86 binary code</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Wartell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vishwath</forename><surname>Mohan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">W</forename><surname>Hamlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiqiang</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS&apos;12)</title>
		<meeting>the 2012 ACM Conference on Computer and Communications Security (CCS&apos;12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Tapping into the fountain of cpus: on operating system support for programmable devices</title>
		<author>
			<persName><forename type="first">Yaron</forename><surname>Weinsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Anker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muli</forename><surname>Ben-Yehuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pete</forename><surname>Wyckoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS&apos;08</title>
		<meeting>the 13th International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS&apos;08</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Shuffler: Fast and deployable continuous code re-randomization</title>
		<author>
			<persName><forename type="first">David</forename><surname>Williams-King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Graham</forename><surname>Gobieski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kent</forename><surname>Williams-King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">P</forename><surname>Blake</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xinhao</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Colp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michelle</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vasileios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junfeng</forename><surname>Kemerlis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><surname>Aiello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX Symposium on Operating Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Egalito: Layout-agnostic binary recompilation</title>
		<author>
			<persName><forename type="first">David</forename><surname>Williams-King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hidenori</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kent</forename><surname>Williams-King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Graham</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Spano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><forename type="middle">Jian</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junfeng</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vasileios</forename><forename type="middle">P</forename><surname>Kemerlis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;20)</title>
		<meeting>the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;20)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Native client: A sandbox for portable, untrusted x86 native code</title>
		<author>
			<persName><forename type="first">Bennet</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><surname>Dardyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bradley Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tavis</forename><surname>Ormandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shiki</forename><surname>Okasaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neha</forename><surname>Narula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Fullagar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>S&amp;P&apos;09</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Architectural support for containment-based security</title>
		<author>
			<persName><forename type="first">Hansen</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumyadeep</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jordan</forename><surname>Fix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sotiris</forename><surname>Apostolakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">R</forename><surname>Beard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nayana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taewook</forename><surname>Nagendra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">I</forename><surname>Oh</surname></persName>
		</author>
		<author>
			<persName><surname>August</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;19)</title>
		<meeting>the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Architectural support for containment-based security</title>
		<author>
			<persName><forename type="first">Hansen</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumyadeep</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jordan</forename><surname>Fix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sotiris</forename><surname>Apostolakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">R</forename><surname>Beard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nayana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taewook</forename><surname>Nagendra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">I</forename><surname>Oh</surname></persName>
		</author>
		<author>
			<persName><surname>August</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;19)</title>
		<meeting>the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Control flow integrity for COTS binaries</title>
		<author>
			<persName><forename type="first">Mingwei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd USENIX Security Symposium (USENIX Security&apos;13)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Kylinx: A dynamic library operating system for simplified and efficient cloud virtualization</title>
		<author>
			<persName><forename type="first">Yiming</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Crowcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongsheng</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengfen</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huiba</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yaozheng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yongqiang</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guihai</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference (ATC&apos;18)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Mptee: Bringing flexible and efficient memory protection to intel sgx</title>
		<author>
			<persName><forename type="first">Wenjia</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kangjie</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yong</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saiyu</forename><surname>Qi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth European Conference on Computer Systems (EuroSys&apos;20)</title>
		<meeting>the Fifteenth European Conference on Computer Systems (EuroSys&apos;20)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
