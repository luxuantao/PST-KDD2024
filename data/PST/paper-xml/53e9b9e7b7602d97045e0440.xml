<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Normal Vector Voting: Crease Detection and Curvature Estimation on Large, Noisy Meshes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Page</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Imaging, Robotics, and Intelligent Systems Laboratory</orgName>
								<orgName type="institution">University of Tennessee</orgName>
								<address>
									<postCode>37996-2100</postCode>
									<settlement>Knoxville</settlement>
									<region>Tennessee</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Imaging, Robotics, and Intelligent Systems Laboratory</orgName>
								<orgName type="institution">University of Tennessee</orgName>
								<address>
									<postCode>37996-2100</postCode>
									<settlement>Knoxville</settlement>
									<region>Tennessee</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Koschan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Imaging, Robotics, and Intelligent Systems Laboratory</orgName>
								<orgName type="institution">University of Tennessee</orgName>
								<address>
									<postCode>37996-2100</postCode>
									<settlement>Knoxville</settlement>
									<region>Tennessee</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">J</forename><surname>Paik</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Imaging, Robotics, and Intelligent Systems Laboratory</orgName>
								<orgName type="institution">University of Tennessee</orgName>
								<address>
									<postCode>37996-2100</postCode>
									<settlement>Knoxville</settlement>
									<region>Tennessee</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Abidi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Imaging, Robotics, and Intelligent Systems Laboratory</orgName>
								<orgName type="institution">University of Tennessee</orgName>
								<address>
									<postCode>37996-2100</postCode>
									<settlement>Knoxville</settlement>
									<region>Tennessee</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Normal Vector Voting: Crease Detection and Curvature Estimation on Large, Noisy Meshes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">FA84CF4DD4A222B9D955677B0B420492</idno>
					<idno type="DOI">10.1006/gmod.2002.0574</idno>
					<note type="submission">Received September 12, 2001; accepted May 14, 2002</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>curvature estimation</term>
					<term>normal vector estimation</term>
					<term>crease detection</term>
					<term>dense triangle meshes</term>
					<term>piecewise-smooth surfaces. 199</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes a robust method for crease detection and curvature estimation on large, noisy triangle meshes. We assume that these meshes are approximations of piecewise-smooth surfaces derived from range or medical imaging systems and thus may exhibit measurement or even registration noise. The proposed algorithm, which we call normal vector voting, uses an ensemble of triangles in the geodesic neighborhood of a vertex-instead of its simple umbrella neighborhood-to estimate the orientation and curvature of the original surface at that point. With the orientation information, we designate a vertex as either lying on a smooth surface, following a crease discontinuity, or having no preferred orientation. For vertices on a smooth surface, the curvature estimation yields both principal curvatures and principal directions while for vertices on a discontinuity we estimate only the curvature along the crease. The last case for no preferred orientation occurs when three or more surfaces meet to form a corner or when surface noise is too large and sampling density is insufficient to determine orientation accurately. To demonstrate the capabilities of the method, we present results for both synthetic and real data and compare these results to the G. Taubin (1995, in Proceedings of the Fifth International Conference on Computer Vision, pp. 902-907)  algorithm. Additionally, we show practical results for several large mesh data sets that are the motivation for this algorithm.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Large triangle meshes are becoming ubiquitous in both computer vision and medical imaging applications. The magnitude of their triangle count and not necessarily the actual dimensions of these meshes is of interest in computer graphics. Typically these meshes are reconstructions of real-world scenes and objects and thus require dense samplings to capture the fidelity of the original surface. The resulting mesh approximations require special processing techniques. These techniques must take into account the dense structure of the meshes themselves and the memory constraints of a computer graphics system. We focus on this first trait in this paper where we leverage the dense nature of these meshes to overcome sampling errors. We do not, however, address the second issue, which is commonly known as out-of-core memory management. Specifically, we address the problem of surface curvature estimation given a mesh approximation of a surface and we employ the underlying dense triangulation of a large mesh to improve the estimation accuracy.</p><p>Surface curvature plays a key role in tasks such as registration, segmentation, simplification, recognition, and analysis. For large meshes, we find curvature in reverse engineering <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b49">50]</ref>, medical visualization <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b39">40]</ref>, and robot navigation <ref type="bibr" target="#b10">[11]</ref> among other applications. The importance of curvature is that as a local surface feature it is invariant to rigid transformations and thus serves as a valuable shape description. The major drawback, however, is that it follows from the second derivative of a surface and as such is often difficult to estimate in the discrete world of graphical models. Our goal is to estimate the curvature of a surface from a dense mesh approximation of that surface and in so doing we recognize two key challenges-surface noise and smoothness discontinuities. As stated previously, we intend to utilize the dense nature of large meshes to address these challenges.</p><p>First, we consider surface noise. Errors in measurement and registration manifest themselves as noise in the geometry of the mesh. Range imaging in computer vision for example samples the surfaces of a scene and creates point-cloud models. The precision in estimating the position of these points is a function of the sensor mechanics, instrument electronics, surface orientations, and reflective properties. With the variability among these elements, measurement error is inevitable. Additionally, registration error results from reconstruction algorithms that take multiple point clouds as input and attempt to recover the topological relationship among those points relative to the original surface topology. The complexity of aligning the coordinate systems of independent point clouds is a common source of error. Beyond measurement and registration error, isosurface extraction in medical imaging introduces another source of error into large meshes. Most medical imaging systems generate gridded volume data. Extraction algorithms sift through these grids to create an isosurface mesh. The nature of these algorithms is such that artifacts usually corrupt the output. Although these sources of error listed above are systematic and not necessarily random, we model them as surface noise on the mesh. Filtering and processing often minimize the effects of this noise, but they do not eliminate it entirely. Since curvature is a local second-order property, a robust algorithm that estimates curvature despite noise is a primary motivation for this paper.</p><p>Second, another challenge is the detection of smoothness discontinuities. Since we assume that our meshes approximate some unknown real-world surface, a question that we must consider is what class of surfaces do we expect. As a practical matter, we restrict ourselves to piecewise-smooth surfaces. This assumption implies that curvature discontinuities are present where two or more smooth surfaces join. Since curvature is singular at such junctions, we must account for these discontinuities. We justify our choice of piecewise-smooth surfaces since most computer vision applications and most medical applications assume a scene consisting of either rigid or nonrigid objects, respectively <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b12">13]</ref>. Alternatives might include entirely smooth surfaces or piecewise-linear ones, which intuition suggests are not practical models of real-world surfaces. Piecewise smooth is the most appropriate choice but for curvature estimation requires careful consideration at creases.</p><p>In this paper, we propose an algorithm called normal vector voting that addresses both of the above issues and robustly estimates curvature for large dense triangle meshes. This paper is an enhancement and extension of the original algorithm first presented in <ref type="bibr" target="#b32">[33]</ref>. The contributions of normal vector voting are as follows:</p><p>• application of geodesic neighborhoods to improve curvature estimation on large dense meshes,</p><p>• robust classification of surface orientation to account for curvature singularities at creases and corners, and</p><p>• robust estimation of principal directions and principal curvatures to overcome surface measurement noise.</p><p>One contribution of this paper is the application of geodesic operations to curvature estimation. The dense triangulations of large meshes from computer vision and medical imaging enable geodesic operations to overcome sampling noise and thus to improve the quality of estimation. Another contribution is the crease detection scheme that allows the algorithm to designate a mesh vertex as either on a smooth surface, at a crease junction, or with no preferred orientation. The advantage of this classification is the detection and avoidance of curvature singularities. Finally, a third contribution is the robust estimation of both the principal directions and principal curvatures. Previous methods have demonstrated robust computation of the principal curvatures alone but not the directions <ref type="bibr" target="#b42">[43]</ref> while others have demonstrated the computation of both but not in a robust manner <ref type="bibr" target="#b43">[44]</ref>. Normal vector voting bridges the gap.</p><p>In the following sections, we present the normal vector voting algorithm and demonstrate its capabilities with several results. We first however present a quick background into curvature in Section 2 and follow with a statement of our problem in Section 3. Then we briefly survey and categorize previous research in Section 4. In Section 5, we then outline Taubin's <ref type="bibr" target="#b43">[44]</ref> formulation of the discrete estimation problem for curvature. Using Section 5 as a starting point, we next outline in Section 6 the details of our normal vector voting algorithm. This discussion includes a description of the voting process and orientation classification as well as the curvature estimation. Section 7 presents practical results from the algorithm for large mesh examples while Section 8 compares the performance of our algorithm to Taubin's original one. Finally we conclude in Section 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>Before we explore the normal vector voting algorithm, we first present a brief overview of surface curvature to clarify our notation. Surface curvature is a concept rooted in differential geometry <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b31">32]</ref>. The curvature of a surface intrinsically describes the local shape of that surface. Consider Fig. <ref type="figure" target="#fig_0">1</ref>. The point p lies on a smooth surface S, and we specify the orientation of S at p with the unit-length normal N . We define S as a manifold embedded in R 3 . We can now construct a plane p that contains p and N , and the intersection of p with S forms a contour α on S. For this contour, we can arbitrarily define an arc parameterized by length s, α(s), where α(0) = p and α (0) = T . We carefully choose this parameterization such that T is the unit-length tangent vector at p. With this construction, we now have a parameterized contour on S, and thus we can find the curvature of that contour. We define the normal curvature κ p (T ) of S at p in the direction of T as α (0) = κ p (T )N . The normal curvature is for a single contour on S passing through p. This curvature κ p (T ) does not however specify the surface curvature of S at p.</p><p>For surface curvature, we need to do a little more work since p is not a unique plane. If we rotate p around N , we form a new contour on S with its own normal curvature. We can see that we actually have an infinite set of these normal curvatures around p in every direction. Fortunately, herein enters the elegance of surface curvature. For this infinite set, we can construct an orthonormal basis {T 1 , T 2 } that completely specifies the set. The natural choice for this basis is the tangent vectors associated with the maximum and minimum normal curvatures at p since the directions of these curvatures are always orthogonal <ref type="bibr" target="#b8">[9]</ref>. These maximum and minimum directions {T 1 , T 2 } are the principal directions of S at p. The added benefit of choosing the principal directions as the basis set is that the curvatures κ 1 p = κ p (T 1 ) and κ 2 p = κ p (T 2 ) associated with these directions lead to the following relationship for any normal curvature at p,</p><formula xml:id="formula_0">κ p (T θ ) = κ 1 p cos 2 (θ) + κ 2 p sin 2 (θ),<label>(1)</label></formula><p>where T θ = cos(θ )T 1 + sin(θ )T 2 and -π ≤ θ &lt; π is the angle to vector T 1 in the tangent plane. The maximum and minimum curvatures are known as the principal curvatures.</p><p>The principal directions along with the principal curvatures completely specify the surface curvature of S at p, which is what we are seeking. Combinations of the principal curvatures lead to other common definitions of surface curvature. The first of these-and perhaps the most common-is Gaussian curvature, which is the product of the principal curvatures K = κ 1 p κ 2 p . This definition highlights negative surface curvature that occurs at hyperbolic patches since these patches occur where only one principal curvature is negative. The second definition of curvature is mean curvature. We specify mean curvature as the average sum of both principal curvatures H = 1 2 (κ 1 p + κ 2 p ). Mean curvature gives insight to the degree of flatness of the surface. Although neither Gaussian nor mean curvature specify the orientation of curvature, they are common definitions found in the estimation literature, as we will see in the next section. We emphasize however that we are not interested in just the principal curvatures, which lead to the Gaussian and mean curvatures, but also the principal directions.</p><p>Our challenge in estimating curvature is unfortunately that we are not dealing with a completely smooth surface such as S above but rather a piecewise-smooth surface Š where we apply the definition of a piecewise-smooth surface as in <ref type="bibr" target="#b1">[2]</ref>. The surface Š may for example be the union of three smooth surfaces S j , S k , and S l , manifolds embedded in R 3 , such that Š = S j ∪ S k ∪ S l . We assume that S j , S k , and S l are orientable manifold surfaces, possibly with piecewise-smooth boundaries <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b21">22]</ref>, and that their subsequent union Š also conforms to this same definition of a surface. Although this assumption may seem obvious, we explicitly state it for clarity. The subsequent piecewise-smooth surface has discontinuity contours C jk = S j ∩ S k where two smooth surfaces join. The principal curvatures across these contours are singular while their orthogonal counterparts, i.e., the principal curvatures along the contours, are not. Other discontinuities occur at corner points c jkl = S j ∩ S k ∩ S l where three or more surfaces join. Both principal curvatures are singular for such corners.</p><p>Another challenge is that we are not actually working with Š but rather with the mesh M that approximates Š. We specify M as the pair M = (K , V ) where K defines the topology and V defines the geometry. We assume as with Š that M is an orientable triangulated manifold surface, possibly with boundary <ref type="bibr" target="#b21">[22]</ref>. The vertices V are samples of Š such that noise may corrupt these samples. We have the following</p><formula xml:id="formula_1">v = p + e, (<label>2</label></formula><formula xml:id="formula_2">)</formula><p>where v ∈ V is a specific vertex of M, p ∈ Š is a sample point on Š, and e is a noise vector that accounts for measurement, registration, and isosurface extraction error. We can think of V as a point cloud and K as the interconnection of V to form the edges and faces of the triangles in M.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROBLEM STATEMENT</head><p>With the above background, we can now state our objective. The following statements define the input and output of the normal vector voting algorithm.</p><p>Given a triangle mesh M = (K , V ) that approximates a piecewise-smooth surface Š with crease discontinuities C jk and corner points c jkl .</p><p>Estimate the principal curvatures κ 1 v and κ 2 v and corresponding principal directions T 1 and T 2 for each vertex v ∈ V , which is a sample of p ∈ Š.</p><p>The difficulty for this problem is that we must account for the singularities along the creases p ∈ C jk and at corners p = c jkl and not allow these singularities to affect the estimation of other samples near them. We must also account for the noise e that corrupts each sample. In the next section, we briefly review previous research into this problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PREVIOUS WORK</head><p>We have identified robust curvature estimation as a weakness in the current literature with regard to triangle meshes. In particular, we have not found a method that robustly estimates both principal curvatures and principal directions. Our proposed research intends to address this issue. Most research in the literature addresses curvature estimation in the context of range images with little work available for the more general problem of surface meshes. Since image processing and mesh processing require different tools, we do not intend to address the direct estimation of curvature from range images. Our interest instead is to address the more general problem of curvature for a mesh data set. From our perspective we can readily convert a range image into a triangle mesh, but to convert a mesh into a set of range images is not trivial and probably counterproductive. We refer the interested reader to <ref type="bibr" target="#b12">[13]</ref> and <ref type="bibr" target="#b40">[41]</ref> for excellent surveys into curvature-from-range methods.</p><p>Our review of the research literature reveals that only a few papers address the issue of curvature estimation on triangle meshes. Of those papers we have identified three classes of techniques:</p><p>• Surface fitting methods (SFMs),</p><p>• Total curvature methods (TCMs), and • Curve fitting methods (CFMs).</p><p>We discuss each class briefly with special emphasis on the curve fitting methods as those offer the most promise.</p><p>SFMs fit an analytic surface to the data of interest and then use differential geometry to compute curvature from that function. With some modifications, we can use many of the analytic methods for range images listed in <ref type="bibr" target="#b12">[13]</ref> and <ref type="bibr" target="#b40">[41]</ref>. We must construct however a local parameterization of the surface similar to the parameterization that an image provides for range data. The approaches of <ref type="bibr" target="#b17">[18]</ref> and <ref type="bibr" target="#b37">[38]</ref> provide possible choices for this parameterization. Also Rössl et al. <ref type="bibr" target="#b37">[38]</ref> use thresholds and morphological operations on a mesh to identify smoothness discontinuities after estimation of curvature. Once we have a local parameterization, we can use methods such as linear regression <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b38">39]</ref> or splines <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b46">47]</ref> to estimate curvature. A more recent paper <ref type="bibr" target="#b36">[37]</ref> uses a local fit of a biquadratic polynomial and applies smoothing to improve the analytic estimate of curvature.</p><p>TCMs are another class of algorithms. These algorithms use the topology and geometry of the mesh directly to estimate curvature. Total curvature-to be precise-is an integration of local curvature <ref type="bibr" target="#b31">[32]</ref>, and as such this class name may be misleading. Our intent in choosing this nomenclature is to denote that these methods estimate curvature for a region and not just at a single point. The other methods such as SFMs may use a region in their algorithms but their output is for a specific point on the mesh.</p><p>Since a triangle mesh is a piecewise-flat surface, the local curvature of such a surface is seemingly paradoxical <ref type="bibr" target="#b29">[30]</ref>. The curvature is singular at each point on the surface-infinite at vertices and edges and zero on triangle faces. We can however refer to the total curvature for regions on these surfaces. Lin and Perry <ref type="bibr" target="#b22">[23]</ref> use the angle excess around each vertex to estimate the total Gaussian curvature. Angle excess itself is well known with <ref type="bibr" target="#b29">[30]</ref> providing a nice discussion in the context of computer graphics and the Gauss-Bonnett theorem. We find another application of angle excess in a series of papers <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> by Delingette. He lays out a framework for a surface representation that he calls a simplex mesh that is a dual to a triangle mesh. He discusses the total mean and the total Gaussian curvature for this surface representation and shows these formulations are directly related to angle excess for a triangle mesh. We find another angle excess approach in the discrete minimal surface and straightest geodesic work of Polthier and his coauthors <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b34">35]</ref>. Following this line of research, Desbrun et al. <ref type="bibr" target="#b6">[7]</ref> define a curvature normal vector as a discrete definition of mean curvature for triangle meshes. As with the angle excess methods, Desbrun et al. use interior angles of triangles for their formulation. With a different approach, Gourley <ref type="bibr" target="#b16">[17]</ref> presents a total pseudo-curvature based on the dispersion of face normals around a vertex while Mangan and Whitaker <ref type="bibr" target="#b25">[26]</ref> refine this measure as the norm of a covariance matrix for these face normals. This pseudo-curvature is proportional to the magnitude of Gaussian curvature. A novel algorithm from Wu and Levine <ref type="bibr" target="#b48">[49]</ref> is a physics-based approach where they simulate the distribution of charge density across a mesh. They relate this charge distribution to surface curvature. This approach also yields a pseudo-curvature measure that is monotonically increasing relative to Gaussian curvature.</p><p>We finally consider the CFMs. With these methods, we fit a family of curves individually around a point and then use the ensemble to estimate curvature. Martin <ref type="bibr" target="#b26">[27]</ref> proposes a method that selects vertex triples from a mesh and fits circles to those triples. Tookey and Ball <ref type="bibr" target="#b44">[45]</ref> describe a more sophisticated method that uses five points instead of three but is only valid for data on a regular grid. Várady and Hermann <ref type="bibr" target="#b45">[46]</ref> present an algorithm for computing principal curvature from a collection of surface curves using a linear system. A very interesting paper by Tang and Medioni <ref type="bibr" target="#b42">[43]</ref> proposes a novel approach to infer the sign of Gaussian curvature and compute principal directions from noisy data. This method is an evolution of Medioni's tensor voting theory <ref type="bibr" target="#b27">[28]</ref>, which uses circular curves to discern features from a point cloud. From the Duplin indicatrix, Chen and Schmitt <ref type="bibr" target="#b3">[4]</ref> formulate a quadratic representation of curvature at each vertex and then derive the principal curvatures using a least squares minimization of the resulting overdetermined system. Inspired by this approach, Taubin <ref type="bibr" target="#b43">[44]</ref> developed an algorithm that defines a symmetric matrix that has the same eigenvectors as the principal directions and eigenvalues that are related by a fixed homogeneous linear transformation to the principal curvatures. He estimates this matrix in discrete form for a triangle mesh using vertex pairs that share a common edge. In the context of surface reconstruction, Gopi et al. <ref type="bibr" target="#b15">[16]</ref> extend Taubin's algorithm beyond adjacent vertex pairs to arbitrarily close pairs and use a different weighting scheme. We finally note the curvature work in the context of mesh simplification in Heckbert and Garland <ref type="bibr" target="#b18">[19]</ref>. This paper outlines the relationship of the quadric error metric <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b23">24]</ref> for triangle normals to curvature.</p><p>The SFMs require the most computational effort since they typically employ optimization in the fitting process. This optimization does provide some robustness to noise but does not inherently deal with discontinuities. The TCMs on the other hand are more computationally efficient but are more susceptible to noise errors. The exception is the method of Wu and Levine <ref type="bibr" target="#b48">[49]</ref> that does demonstrate robust results. None of the TCMs, however, directly estimate the principal directions or principal curvatures that we seek. The CFMs are the most promising of the three classes. In particular, Tang and Medioni <ref type="bibr" target="#b42">[43]</ref> and Taubin <ref type="bibr" target="#b43">[44]</ref> offer unique contributions. Tang and Medioni's method is robust but their algorithm does not estimate principal curvatures, only principal directions. They construct a matrixsimilar to Taubin-whose eigenvectors relate to the principal directions but they do not show how the eigenvalues relate to the principal curvatures. As stated above Taubin's algorithm does. Taubin relates the eigenvalues to the principal curvatures. Our contribution is to extend both Tang and Medioni's and Taubin's methods with a new algorithm that employs a geodesic neighborhood, a voting scheme, and Taubin's discrete formulation to generate robust results. Before we present this novel approach, we next review Taubin's formulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">DISCRETE ESTIMATION</head><p>Our final preliminary step is to introduce the discrete formulation of curvature in accordance with Taubin <ref type="bibr" target="#b43">[44]</ref>. Taubin shows that for a point p on a smooth surface the symmetric matrix</p><formula xml:id="formula_3">B p = 1 2π π -π κ p (T θ )T θ T t θ dθ,<label>(3)</label></formula><p>with superscript t denoting transpose and T θ as defined in Section 2, has eigenvectors that are equivalent to the principal directions {T 1 , T 2 } and eigenvalues that are related by a fixed homogeneous linear transformation to the principal curvatures as</p><formula xml:id="formula_4">κ 1 p = 3b 1 p -b 2 p (4) κ 2 p = 3b 2 p -b 1 p ,</formula><p>where b 1 p and b 2 p are the eigenvalues of B p associated with T 1 and T 2 , respectively. The third eigenvalue is zero and corresponds to the eigenvector equal to the surface normal at p. For a vertex v on a discrete mesh, Taubin approximates Eq. ( <ref type="formula" target="#formula_3">3</ref>) as</p><formula xml:id="formula_5">Bv = 1 2π w i κ i T i T t i (5)</formula><p>for a finite set of directions T i in the tangent plane of v. The weight w i is the discrete integration step and has the constraint w i = 2π. Taubin's algorithm computes Bv for a vertex on a mesh and then decomposes the matrix with a Householder transformation and a Givens rotation. The resulting eigenvectors and eigenvalues lead to the principal directions and principal curvatures via Eq. ( <ref type="formula">4</ref>).</p><p>The question at hand is how do we estimate κ i and T i in Eq. ( <ref type="formula">5</ref>). Taubin employs a truncated Laurent series to approximate these values, but this approach is not robust. Tang and Medioni <ref type="bibr" target="#b42">[43]</ref> suggest a more robust solution. Building on these algorithms, we have developed our normal vector voting algorithm as a robust method to estimate the individual κ i and T i and thus the principal directions and principal curvatures for a vertex on a mesh. We now take an in-depth look at this algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">NORMAL VECTOR VOTING ALGORITHM</head><p>Normal vector voting is a two-pass algorithm. For the first pass through a mesh, we estimate the normal vector orientation for each vertex. For the second pass, we estimate curvature. First, we consider normal estimation. The basic idea is to select a surface region around a vertex. A user-specified distance bounds this region in terms of geodesic distance from the vertex where the vertex is the center of the geodesic patch. Each triangle in this patch-or geodesic neighborhood-votes at that center vertex in order to estimate the orientation of that vertex. Note the simple example in Fig. <ref type="figure">2</ref>. Here, triangle f i in the mesh neighborhood M v of vertex v has a normal N that generates a normal vote N i at v. We collect these votes in a covariance matrix and decompose this matrix using eigen-analysis. The eigenvectors and eigenvalues estimate the orientation for v. We illustrate this sequence of events in Fig. <ref type="figure" target="#fig_1">3</ref>. With a few slight modifications, this same sequence estimates the curvature at v for the second pass.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIG. 2.</head><p>A triangle with normal N generates vote N i for the orientation of the surface at v. The circular arc follows the perceptual continuity constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Geodesic Neighborhood</head><p>The first step in normal vector voting for both the first or the second pass is to find the triangles or vertices that are close in a geodesic sense to the vertex of interest. The geodesic neighborhood problem, which follows the discrete geodesic problem <ref type="bibr" target="#b28">[29]</ref>, is to find the m triangles that are within a user-specified distance of the vertex. The key is that the distance is not the Euclidean distance but rather the shortest geodesic distance along the surface of the mesh. As noted in the literature this problem closely resembles the shortest path problem for a graph, which the Dijkstra algorithm <ref type="bibr" target="#b7">[8]</ref> solves. The difference is that the shortest path along the edges and nodes of a graph is not necessarily equivalent to the shortest geodesic path over the surface, which includes the triangle interiors and not just the edges. Kimmel and Sethian <ref type="bibr" target="#b20">[21]</ref> present an elegant algorithm that solves this problem in O(m log m) time and Sun and Abidi <ref type="bibr" target="#b41">[42]</ref> propose a simplification that is readily adaptable to our domain. The time complexity is important when compared to such Euclidean algorithms as k-d trees that require O(m + 3n 2/3 ) time where n is the number of triangles in the whole mesh <ref type="bibr" target="#b47">[48]</ref>. Also, k-d trees require additional O(n) storage space beyond the current space required for the mesh itself. The Kimmel and Sethian algorithm requires no additional storage.</p><p>As a brief aside, we distinguish the Kimmel and Sethian definition of shortest geodesics from the straightest geodesics of Polthier and Schmies <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b35">36]</ref>. The latter ensures the uniqueness of a geodesic path on a polyhedral surface. Since we are only concerned with a neighborhood and not the actual path, this trait is not crucial to our problem. We are interested in shortest and not straightest geodesics.</p><p>Figure <ref type="figure" target="#fig_2">4</ref> shows three different sizes of geodesic neighborhoods. The smallest neighborhood in this figure consists of just the immediate triangles adjacent to the vertex of interest. We also refer to this simple patch as the umbrella neighborhood since it figuratively  resembles a collapsible rain umbrella with a canopy of triangles mounted on its central vertex. Another common term for the umbrella is the one-ring neighborhood. Subdivision surfaces refer to the k-ring neighborhood of a vertex where a ring is the set of triangles within k edges of the vertex. A k-ring is a topological neighborhood definition. We will compare k-ring topological neighborhoods and geodesic ones shortly. Most algorithms that require a neighborhood usually work with the umbrella patch. Taubin's curvature algorithm <ref type="bibr" target="#b43">[44]</ref>, for example, employs such a neighborhood. Our research has shown-and hopefully normal vector voting demonstrates-that significant advantages arise if we enlarge beyond the umbrella neighborhood. The choice of the neighborhood size depends on the application but in our context we identify feature size, noise level, and sampling density as the variables that dictate this choice. These variables have competing interests and thus tradeoffs among them exist. For example a mesh that contains small features requires a small neighborhood to preserve those features. If that same mesh, however, has significant noise corruption, then a large neighborhood is necessary to smooth out the noise. Similar arguments follow for sampling density. Because of these competing issues, we have defined the neighborhood size as a user-specified parameter. The user simply specifies the geodesic distance that bounds the neighborhood. Actually, the user specifies an integer multiple of the average length of the triangle edges in the mesh to eliminate scaling issues. As a result we define the k-geodesic neighborhood as the neighborhood with a geodesic boundary that is k times the average edge length. We derive the term k-geodesic in the spirit of the k-ring designation.</p><p>A question that arises is what is the benefit of a k-geodesic neighborhood over a k-ring neighborhood? In particular, does the computational burden to find a k-geodesic overshadow that for a k-ring? For insight we outline the Kimmel and Sethian algorithm. We begin at the vertex of interest and simply walk outward to the one-ring vertices. We use the equations in <ref type="bibr" target="#b41">[42]</ref> to estimate the shortest geodesic distance back to the center vertex from each one-ring vertex. We then place these vertices on a heap with their distance as a key into the heap. We now walk to the closest one by removing the top vertex from the heap-the vertex with the shortest distance. We compute the geodesic distances for each of its one-ring vertices back to the original center and place them on the heap. The algorithm again removes the closest vertex from the heap and repeats. We see that this walking algorithm is very similar to a k-ring neighborhood algorithm. The only differences are the computation of the geodesic distance for each vertex and the priority of the walk driven by the heap. A ring algorithm would simply prioritize the walk as a function of the current ring state where the walk proceeds after extending the neighborhood to a complete ring. The geodesic neighborhood algorithm walks toward the closest vertex regardless of how close or how far that vertex is in terms of a ring. Although this priority walking does require some additional computation, the benefits, especially for small neighborhoods, far outweigh this minor cost as the following examples illustrate. For the regular triangulations that we see with range images and isosurface algorithms, we often find a bias of a one-ring neighborhood as shown in Fig. <ref type="figure" target="#fig_3">5a</ref>. The thick dark circles in this figure represent k-geodesic boundaries while the alternating bands of white and shaded triangles represent the various k-ring neighborhoods. Inside the first dark circle, the small one-ring neighborhood has a bias toward the right side of the figure. A onegeodesic neighborhood, however, defined by the first circle, includes the one-ring triangles and the triangles labeled with an "A" where we consider a triangle to be in the one-geodesic neighborhood if each of its three vertices falls within the region bounded by the circle. These additional triangles balance the support of the neighborhood and eliminate the unintended bias of a simple one-ring. Similarly, the white two-ring also has a bias toward the right where the inclusion of the "B" triangles offers a more balanced two-geodesic neighborhood. Similarly, triangulations that are not quite as regular such as the one in Fig. <ref type="figure" target="#fig_3">5b</ref> have a bias as well since triangle sizes and configurations have more variation. We again use the "A" and "B" labels to illustrate the comparison. For curvature estimation our experience suggests that the balanced support of geodesic neighborhoods is a significant benefit especially in the context of the discrete equation ( <ref type="formula">5</ref>) where adequate directional sampling around a vertex is important.</p><p>Since normal vector voting is a neighborhood-oriented operation with a geodesic definition, we label it as a geodesic operation. We use this label in the spirit of the so-called mask operations <ref type="bibr" target="#b14">[15]</ref> from image processing. With mask operations, we analyze an image pixel in terms of its own gray level and of the gray levels of its neighbors. We often specify the mask neighborhood as k × k where k is the width in pixels of the mask centered at the pixel of interest. We see that our geodesic operation is similar except we specify the k-geodesic neighborhood of interest. We now have a geodesic neighborhood M v . Our next step is to vote and determine the orientation of v or curvature at v depending on the pass.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Vote Collection</head><p>For the first pass, the next block in the diagram of Fig. <ref type="figure" target="#fig_1">3</ref> involves the voting of the triangle faces f i ∈ M v at the vertex v. We must address two questions:</p><p>• How does face f i cast a vote? • How does vertex v collect these votes?</p><p>To answer these questions, we are inspired by tensor voting in Medioni et al. <ref type="bibr" target="#b27">[28]</ref>. Tensor voting is a computational framework that infers structures such as boundaries and surfaces from unstructured, sparse, and often noisy 3D point clouds. This framework employs perceptual constraints from theories of human vision and subsequent definitions of tensor voting fields to extract structure. The implementation of tensor voting requires a discrete voxel representation of space where input points cast votes and voxels collect votes in the context of tensor algebra. Medioni et al. suggest a system of tensor voting fields in conjunction with coordinate frame rotations and convolution-like operations with those fields to encode local geometric structure at each voxel. After the voting process, they extract salient global structures such as surfaces, curves, and junctions by sifting through these voxels with a level-crossing detection algorithm. Although the application of this approach to triangle meshes is possible, we reformulate the tensor voting notions and propose a more natural vector framework for triangle meshes. We use the same perceptual continuity constraints as Medioni et al. to govern vote casting but we define a more appropriate vector geometry instead of the tensor voting fields. For vote collection, we use a covariance matrix similar to the quadric error matrix in <ref type="bibr" target="#b18">[19]</ref>, which has a direct relationship to the tensor algebra in Medioni et al. Interestingly, Heckbert and Garland <ref type="bibr" target="#b18">[19]</ref> show a relationship between this covariance matrix-in the limit-to surface curvature. We, however, use this matrix to estimate orientation and later follow Taubin's approach to estimate curvature. We have found that, in the presence of surface noise, this two-step approach is more robust than directly extracting curvature from the covariance matrix.</p><p>We first consider how a triangle f i generates a normal vote N i at vertex v. A couple of approaches are possible. For example, one method is to set N i at v equal to the normal N of the plane that contains f i as in Fig. <ref type="figure" target="#fig_4">6a</ref>, so that N i = N . This simple method works well with low curvature surfaces but leads to significant error as curvature increases. With some insight, we see that an improvement to this method is to fit a smooth curve from f i to v and allow the normal vote to follow the curve. The perceptual continuity constraint suggests that the most appropriate curve is a circular arc with shortest arc length. Following this argument, we construct the geometry in Fig. <ref type="figure" target="#fig_4">6b</ref>. For the shortest arc-length circle, the curve must lie entirely in the plane i that contains the triangle normal N -rooted at centroid c i of triangle f i -and the vertex v. We can compute θ i in the figure as where vc i = c i -v and 0 ≤ θ i ≤ π. This equation leads to the normal vote</p><formula xml:id="formula_6">cos θ i = - N t vc i vc i ,</formula><formula xml:id="formula_7">N i = N + 2 cos θ i vc i vc i . (<label>6</label></formula><formula xml:id="formula_8">)</formula><p>We next address how v collects the N i votes from each f i ∈ M v . One possibility is as a weighted vector sum w i N i . This approach is a common method for normal vector estimation at vertices in a triangle mesh, typically with an umbrella neighborhood. The limitation of this scheme is that normals with opposite orientation annihilate each other (N j = -N i , N j + N i = 0), and we therefore lose variance information. This situation occurs near crease and corner discontinuities in particular. As an alternative, we represent N i as a covariance matrix V i = N i N t i and collect votes as a weighted matrix sum V v with</p><formula xml:id="formula_9">V v = w i V i = w i N i N t i , (<label>7</label></formula><formula xml:id="formula_10">)</formula><p>where the summation is over the M v neighborhood. Unfortunately, the downside is that we now lose absolute sign orientation. The covariance matrix V i does not designate which side of the mesh is the outside of the surface. Consider N j = -N i . How do we distinguish N i N t i = N j N t j ? The benefit is that these votes no longer annihilate each other. We can track the variance of the votes. This capability outweighs the loss of the absolute sign information since the variance allows us to draw conclusions about the relative orientation of the vertex. We will see in a later section that eigen-analysis of this variance leads to an interesting classification scheme for the vertex. With regard to the absolute sign, we should be able to recover this information with a simple ad hoc algorithm such as a quick averaging of the umbrella neighbors. Only under a pathological case does such an approach fail. So we can readily overcome the sign problem.</p><p>Our final issue to address is the weighting term w i . Two factors effect this term: surface area of f i and geodesic distance g i of c i from v. Naturally, a triangle closer to v should have a stronger vote than a triangle farther away while a larger one should also have a stronger vote than a smaller one. We choose an exponential decay to reflect these notions</p><formula xml:id="formula_11">w i = A i A max exp - g i σ , (<label>8</label></formula><formula xml:id="formula_12">)</formula><p>where σ controls the rate of decay, A i is the area of f i , and A max is the area of the largest triangle in the entire mesh. In practice, the value σ is a function of the maximum geodesic distance that the user specifies. We define this value to be 3σ = g m so that votes beyond the neighborhood have negligible influence and can be ignored. The above equations lead to a covariance matrix V v for each vertex v in the mesh. This matrix represents the variance of the votes in the geodesic neighborhood M v around v. In the next section, we use eigen-analysis to investigate the orientation of v using this variance information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Orientation Classification</head><p>While still in the first pass of the algorithm, the third step in Fig. <ref type="figure" target="#fig_1">3</ref> is to decompose V v using eigen-analysis and then to classify v. Since V v is a symmetric semidefinite matrix, eigen-decomposition generates real eigenvalues λ 1 ≥ λ 2 ≥ λ 3 ≥ 0 with corresponding eigenvectors E 1 , E 2 , and E 3 . We can visualize this eigensystem as in Fig. <ref type="figure" target="#fig_6">7a</ref>. The eigenvalues, and thus the shape of the eigen-ellipsoid, yield insight into the vote agreement within V v . Figures <ref type="figure" target="#fig_6">7b-7d</ref> show three variations of the eigenvalues and how we might interpret these variations.</p><p>In tensor voting, Medioni et al. <ref type="bibr" target="#b27">[28]</ref> define saliency maps over the entire voxel space with eigenvalues from their tensors. They then use an extremal search algorithm to extract salient global structures from these map definitions. The saliency maps use the following relationships for their tensor eigenvalues: (</p><formula xml:id="formula_13">S s = λ 1 -λ 2 ,</formula><formula xml:id="formula_14">)<label>9</label></formula><p>Since we seek to classify the preferred orientation of a vertex as opposed to the global structure through a voxel, we take a different approach and do not employ a search algorithm to sort through voxels. For our vector voting, we propose the following vertex classification scheme for the eigenvalues of V v at each vertex:</p><formula xml:id="formula_15">max{S s , εS c , εηS n } =      S s : surface patch with normal N v = E 1 εS c :</formula><p>crease junction with tangent T v = E 3 εηS n : no preferred orientation <ref type="bibr" target="#b9">(10)</ref> where 0 ≤ ε &lt; ∞ and 0 ≤ η &lt; ∞ are constants that control the relative significance of the saliency measures. These constants are not user parameters since they are fixed for a given system. When we design a system, however, we need to carefully select these constants to balance noise tolerance and crease detection.</p><p>We demonstrate the design impact of ε and η with examples. First, consider one extreme where we design ε = η = 0. This system always classifies a vertex as a surface patch regardless of any corners or creases in the original piecewise-smooth surface. Consider lim ε,η→0 max{S s , εS c , εηS n } = S s .</p><p>This design associates a surface normal with each vertex even if the vertex is a sample of a crease or a corner. Thus, the design does not detect curvature discontinuities. This approach is very similar to a normal estimation algorithm that averages the triangle normals of a onering neighborhood for a vertex. Another design extreme lets ε, η → ∞. Such a system never classifies a vertex as a surface patch regardless of smoothness and instead classifies each vertex as a corner. This design never assigns surface normals to vertices. The third extreme is a design where ε → ∞ and η = 0. As we might expect, this system always classifies a vertex as a crease and associates a tangent vector with the vertex. Although the first design may have some use, the latter two designs have little practical use, but they do illustrate the choice of the constants (ε, η). When designing a system, we fix ε to discriminate the types of creases that we expect in the piecewise-smooth surfaces and η to discriminate the amount of surface noise that we wish to tolerate in our sensors.</p><p>For a system design, we need to decide how much noise we can tolerate and what crease angles we need to detect. If we choose to detect small creases, we reduce the overall robustness of the system. On the other hand, less tolerance to small creases allows more tolerance to noise. The constant ε controls these design considerations. In our experiments, the system ε = 2 offers a balanced compromise of detecting creases and allowing variation. As a rule of thumb, we have the following equation</p><formula xml:id="formula_16">tan φ 2 = 1 ε + 1 , (<label>11</label></formula><formula xml:id="formula_17">)</formula><p>where φ is the minimum dihedral crease angle that the system can detect. We illustrate examples of crease angles in Fig. <ref type="figure" target="#fig_7">8</ref>. We emphasize that this angle is not for edges in the mesh but for the creases of the original piecewise-smooth surface. So, for ε = 2, we detect creases in the original surface with φ ≥ π 3 . If however that surface has creases with φ &lt; π 3 , the system classifies vertices that are samples near these creases as surface patches, but the benefit is robustness to noise. Following a similar example and argument, we can see that η = 2 also offers a balance between noise and crease detection. We can formulate the following equation</p><formula xml:id="formula_18">tan ψ 2 = 1 η + 1 , (<label>12</label></formula><formula xml:id="formula_19">)</formula><p>where ψ is the angle of variation between a crease decision and a no-preferred-orientation decision relative to the eigen-analysis of V v from the previous section. With most systems, we suggest ε = 2 and η = 2. With our first pass through the mesh, this classification estimates the normals for each vertex on a surface patch and detects each vertex along a crease discontinuity. Using this information with extensions to Taubin's algorithm, we discuss in the next section how a second pass through the mesh generates estimates for the curvature at each vertex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Curvature Estimation</head><p>Our second pass through the mesh follows the same sequence as in the first pass. Recall Fig. <ref type="figure" target="#fig_1">3</ref>. This time, however, we use the normal estimates from the previous section to estimate the curvature at each vertex. We again use a geodesic neighborhood M v around each vertex but for this pass we are interested in the vertices v i ∈ M v , and not the triangles, in this neighborhood. Each vertex v i votes at the center vertex v where we collect the votes in a matrix Bv from Eq. ( <ref type="formula">5</ref>). We decompose this matrix with eigen-analysis and use the subsequent eigenvectors and eigenvalues to estimate the directions T 1 and T 2 and principal curvatures κ 1 v and κ 2 v at v with the linear transformations in Eq. ( <ref type="formula">4</ref>). We now specify the weights w i , tangent directions T i , and normal curvatures κ i in the matrix sum of Bv .</p><p>We begin with the weights since they are the simpliest terms to define. As with the first pass, we use the same decay function in Eq. ( <ref type="formula" target="#formula_11">8</ref>) except that we remove the area components A i and A max . Also, we constrain w i = 2π for all the weights around v. This constraint is necessary to maintain translation invariance among the votes. Again, the decay function places more emphasis on votes that are closer to v than ones that are farther away.</p><p>We use the geometry in Fig. <ref type="figure" target="#fig_4">6c</ref> to define the tangent directions T i of each vote. The figure demonstrates that we project the vector from v i to v into the tangent plane of v and normalize the result. The following equation is more precise</p><formula xml:id="formula_20">T i = t i t i , t i = vv i -N t v vv i N v , (<label>13</label></formula><formula xml:id="formula_21">)</formula><p>where</p><formula xml:id="formula_22">vv i = v i -v.</formula><p>This direction is for any vertex v i in the geodesic neighborhood of v and not just the umbrella neighbors as in Taubin's algorithm. The normal N v is the estimate from the previous section. Last we consider the normal curvatures κ i . We propose a discrete definition using the changes in turning angle ϑ i and in arc length s where</p><formula xml:id="formula_23">κ i = ϑ i s . (<label>14</label></formula><formula xml:id="formula_24">)</formula><p>An important consideration is that we properly define the turning angle for the normal curve and not just the curve connecting v i and v. The change in the turning angle describes the change in the normal vector as we move along the curve. To this end, we project the normal estimate N v i at v i into the plane i that contains N v -rooted at v-and v i as</p><formula xml:id="formula_25">n i = N v i -P t i N v i P i , (<label>15</label></formula><formula xml:id="formula_26">)</formula><p>where n i is the projection and P i = N v × T i defines the plane that contains the normal curve.</p><p>The turning angle thus becomes</p><formula xml:id="formula_27">cos( ϑ i ) = N t v n i n i . (<label>16</label></formula><formula xml:id="formula_28">)</formula><p>The sign of κ i is the same as the sign of T t i n i . Finally, the change in arc length is simply the geodesic distance between the two vertices</p><formula xml:id="formula_29">s = g i . (<label>17</label></formula><formula xml:id="formula_30">)</formula><p>We estimate g i from the geodesic neighborhood algorithm discussed in Section 6.1. For a vertex v, we collect the curvature votes from the equations above into the matrix Bv of Eq. ( <ref type="formula">5</ref>), and eigen-decomposition leads to the principal directions T 1 and T 2 and principal curvatures κ 1 v and κ 2 v from the relation in Eq. (4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5.">Remarks</head><p>We have reached our goal. After the second pass, we have an estimate for the curvature at each vertex. We discuss a few caveats, however. First we only compute surface curvature if we classify a vertex as a surface patch. If a vertex has no preferred orientation, surface curvature is meaningless. A vertex on a crease on the other hand is a little different since we can estimate the curvature in the direction of the crease. With slight modifications of the above equations, we can generate a tangential curvature estimate. The other principal curvature, which is orthogonal to this one, is infinite, but we can estimate the cusp angle across the crease as either φ = 2 arctan λ 1 λ 2 or (π -2φ) where λ 1 and λ 2 are the eigenvalues from the first pass through the mesh in Section 6.3. The choice for the angle depends on the absolute sign information that our ad hoc umbrella method resolves. We further note that our classification scheme does not enforce crease continuity, i.e., topologically link crease vertices. If such topological connectivity is important, we suggest morphological operations <ref type="bibr" target="#b37">[38]</ref> or watershed methods <ref type="bibr" target="#b25">[26]</ref>. The final caveat relates to the neighborhood definition. The neighborhood algorithm is a fast marching method that begins at the vertex of interest v as the center and marches out to form the neighborhood M v . For curvature estimation as the algorithm marches outward, we check the classification of the current vertex and only proceed if it is a surface patch. This qualification does not allow the marching algorithm to cross crease discontinuities and thus restricts M v to the same smooth patch as v. This approach improves the curvature estimate since vertices on the other side of a discontinuity do not corrupt the estimation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EXPERIMENTAL RESULTS</head><p>We have implemented the proposed algorithm in C++ code. To demonstrate the algorithm capabilities, we have experimented with a variety of data sets from CAD models to range reconstructions to medical isosurfaces. In this section, we present the qualitative results of these experiments and follow in the next section with quantitative results from a more controlled experiment. In the discussions that follow, we designate the single user parameter of the normal vector voting algorithm g m as an integer multiple of the average edge length l ave for mesh triangles. So g m = 5l ave means that we set the geodesic neighborhood boundary to five times the average edge length. We alternatively use the term five-geodesic neighborhood presented in a previous section. When pertinent we also call out the system constants ε and η that we used for a particular design. These constants in practice are fixed and should not change. Rather, we control the algorithm with the neighborhood boundary and not these constants.</p><p>We first consider two illustrative data sets: a fandisk in Fig. <ref type="figure" target="#fig_8">9</ref> and a torus in Fig. <ref type="figure" target="#fig_9">10</ref>. The fandisk is a CAD model that exemplifies free-form smooth surfaces, and the torus is a  simple object with a genus one topology. We add noise to these data sets to demonstrate the robustness of our algorithm. To the original fandisk in Fig. <ref type="figure" target="#fig_8">9a</ref>, we have added Gaussian noise to each coordinate of the mesh's vertices where we specify the variance of the Gaussian distribution as 0.1% of l ave . Figure <ref type="figure" target="#fig_8">9b</ref> illustrates this noise, which simulates the errors that we might encounter from reconstruction algorithms in computer vision. For the torus, we use a marching cubes algorithm <ref type="bibr" target="#b24">[25]</ref> to introduce noise into the data set. Marching cubes is a common method in medical imaging to extract isosurfaces from volume data sets. The nature of the marching cubes algorithm corrupts the ideal smooth surface of the original torus in Fig. <ref type="figure" target="#fig_9">10a</ref> with the more jagged surfaces in Fig. <ref type="figure" target="#fig_9">10b</ref>.</p><p>We now look at the crease detection and normal estimation capabilities of our algorithm. Figures <ref type="figure" target="#fig_8">9c</ref> and<ref type="figure" target="#fig_8">9d</ref> show the crease detection results for the fandisk both without noise and with it. Without noise, we design ε in Eq. ( <ref type="formula">10</ref>) with a large enough value to detect accurately the crease on the left side of Fig. <ref type="figure" target="#fig_8">9c</ref>. With noise, however, we must decrease ε to account for the noise variation, and thus we no longer detect that particular crease. We do on the other hand detect the right-angle creases for both cases despite the increase in noise. This example highlights the tradeoff between allowing noise variation and detecting surface discontinuities. When designing a system and thus choosing ε and η, the designer must balance the level of noise to tolerate and the angle of creases to detect. Then a user can choose various neighborhood sizes (g m ) to balance noise levels, feature scales, and sampling densities for a particular mesh.</p><p>The torus example illustrates normal estimation. Figure <ref type="figure" target="#fig_9">10c</ref> shows a zoom view for the edge of the torus. The vectors extending from the mesh's vertices are normal estimates derived from a simple average of the triangle normals adjacent to each vertex. Figure <ref type="figure" target="#fig_9">10d</ref> shows the same view but with normals derived from the normal voting algorithm. The neighborhood size for the latter is an eight-geodesic neighborhood (g m = 8l ave ). The larger neighborhood allows for an improvement in the estimation of the normals. We see that the normals in Fig. <ref type="figure" target="#fig_9">10c</ref> adhere to the marching cube artifacts while in Fig. <ref type="figure" target="#fig_9">10d</ref> they more closely follow the smooth surface of the original torus. This smoothing characteristic of a larger neighborhood is the primary strength of the normal vector voting algorithm.</p><p>Figures 11 through 13 demonstrate the robustness of the curvature estimate. Again, we use the fandisk and torus for these examples. In these figures, the vector at each vertex is the estimate for the principal direction of the maximum curvature. Figures <ref type="figure" target="#fig_10">11</ref> and<ref type="figure" target="#fig_11">12</ref> show the effects of the neighborhood size. The small neighborhoods in Figs. <ref type="figure" target="#fig_10">11a, 11c</ref> and<ref type="figure" target="#fig_11">12a</ref>, 12c are unable to overcome the surface noise such that the zoom views reveal the random distribution of the principal directions. The larger neighborhoods in Figs. 11b, 11d and 12b, 12d yield improvement with strong local agreement of the principal directions shown in the zoom views. Notice how the principal directions flow along the surface curvature of the object. These figures highlight the robustness of the curvature estimation via selection of the neighborhood size. As noted previously, this capability is the major contribution of this paper.</p><p>One drawback to enlarging the neighborhood is that significant error is introduced at discontinuity creases. Consider one of the creases in the fandisk model. Figure <ref type="figure" target="#fig_12">13a</ref> shows a crease at the top of the figure with corresponding crease tangents. The principal directions just below that crease erroneously point across the crease. The problem is that normals on the other side of the discontinuity vote during the curvature estimation. To resolve this problem, we restrict the neighborhood from crossing the discontinuity. Figure <ref type="figure" target="#fig_12">13b</ref> illustrates the results. The principal directions near the crease now follow the curvature of the surface as we desire.</p><p>The final set of examples is in Figs. <ref type="figure" target="#fig_2">14</ref> and<ref type="figure" target="#fig_3">15</ref>. In these figures, we visualize curvature at a vertex by placing the value of the mean curvature as a material property of each vertex. Recall that the mean curvature is simply the average curvature of both principal curvatures. This visualization allows us to investigate the relative accuracy between normal vector voting and Taubin's algorithm. The zoom views demonstrate this comparison. Notice that the middle column for normal vector voting exhibits a smoother variation in curvature despite the surface noise for each data set while the right column for Taubin's algorithm follows the noise. The right column zooms are more splotchy than the middle ones, which is indicative of noise. These figures and the previous ones give insight to the relative capabilities of normal vector voting, but in the next section, we explore a more quantitative analysis to identify more clearly these capabilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">COMPARISON RESULTS</head><p>The previous examples show the capabilities of the normal vector voting algorithm but do not provide a baseline for comparison. <ref type="bibr">Figures 16,</ref><ref type="bibr" target="#b17">18</ref>, and 20 attempt to do so. In these figures, we graph the error of the algorithm for both synthetic and real data where we use ground truth to establish the error. For these graphs, we manipulate three variables: surface type, noise level, and neighborhood size.</p><p>We first consider synthetic data to evaluate noise sensitivity. We choose three surface types: planar, cylindrical, and spherical. The radius of curvature for the cylinder and the sphere is 31 mm. Figures <ref type="figure" target="#fig_13">16a,</ref><ref type="figure" target="#fig_13">16c</ref>, and 16e show these surfaces with Gaussian noise added to the Z coordinate using a distribution variance of 10% of l ave . The graphs in Figs. <ref type="figure" target="#fig_13">16b,</ref><ref type="figure" target="#fig_13">16d</ref>, and 16f compare the performance of the normal vector voting algorithm for a threeand five-geodesic neighborhood (g m = 3l ave and g m = 5l ave ) to Taubin's one-ring algorithm. We have chosen to compare to Taubin's algorithm since it serves as the foundation for our algorithm. We do not compare results for Tang and Medioni's algorithm since their algorithm is for point-cloud data sets and since they do not compute principal directions for surface curvature.</p><p>Taubin's algorithm serves to baseline the performance of our method. However, for noisy surfaces, a direct comparison is perhaps not appropriate since-as Taubin noteshis algorithm requires a smoothing step to preprocess any surface noise. In fairness to Taubin, we emphasize that we baseline the benefits of the k-geodesic neighbors and do not</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIGS. 14 &amp; 15.</head><p>The following meshes represent a variety of data sources. For each example, the left column shows the whole object with mean curvature as the vertex color. The mean curvature results from the curvature estimate with the normal vector voting algorithm and an appropriate neighborhood size. The middle column shows a zoom view to illustrate the smoothing of the normal vector voting algorithm. For comparison, the right column shows the same zoom view but the estimation is from Taubin's algorithm. (a-c) Human femur created using marching cubes algorithm from medical CT scans. Available at http://miles.cnu-ce.cnr.it/cg/homepage.html. The mesh size is 76,794 vertices and 153,322 triangles. (d-f ) Automotive fan scanned by 3D Digital Corporation range system. Available at www.3ddigitalcorp.com. The mesh size is 122,426 vertices and 243,347 faces. (g-i) Automotive disc brake we have scanned in-house with an IVP Ranger System <ref type="bibr" target="#b19">[20]</ref>. The mesh size is 32,602 vertices and 64,334 faces. ( j-l) Watering can scanned by Polhemus FastSCAN system. Available at www.polhemus.com. The mesh size is 7,345 vertices and 14,463 faces. (m-o) Stanford bunny model. Available at www-graphics.stanford.edu/data/. The mesh size is 34,834 vertices and 69,451 faces. (p-r) Turbine blade created using marching cubes algorithm from industrial CT scans. Available at www.cc.gatech.edu/projects/largemodels. The mesh size is 882,954 vertices and 1,765,388 faces. competitively compare the algorithms. To do so, we would need to select and implement an appropriate smoothing algorithm.</p><p>We look at the normal estimation for the plane in Fig. <ref type="figure" target="#fig_13">16b</ref>. The percentage error in this graph is</p><formula xml:id="formula_31">err = 1 -N t p N v × 100%,<label>(18)</label></formula><p>where N p = Z is the ground-truth normal and N v is the estimation. This graph is a histogram plot with vertex bins across the horizontal axis and a log scale for the vertical. Figure <ref type="figure" target="#fig_13">16d</ref> uses a similar error measure and compares the estimation of the principal directions T v for the cylinder. Let T p = X be the ground truth for the minimum principal direction. The third graph in Fig. <ref type="figure" target="#fig_13">16f</ref> compares the estimation of the principal curvatures for the sphere. We use a different error measure</p><formula xml:id="formula_32">err = κ 1 p -κ 1 v κ 1 v × 100%,<label>(19)</label></formula><p>where κ 1 p = 1 31mm is the ground truth and κ 1 v is the estimate. For each of these graphs, we see a similar trend. The normal vector voting algorithm for both neighborhoods provides improved performance over Taubin's algorithm. This improvement is evident for bins near the 0% error to the left side of the graphs. The more vertices that accumulate in these lower error bins the better.</p><p>We next consider the effect of different noise levels. As before for each synthetic surface, we corrupt the Z coordinate of each vertex with Gaussian noise. We specify four levels of noise via the distribution variance: 50, 10, 5, and 1% of l ave . Figure <ref type="figure" target="#fig_14">17</ref> illustrates these noise levels fot the planar surface. Using the previous error measures and graphs, Figs. 18 plots the normal vector voting error for surface type and noise level with only the three-geodesic neighborhood size (g m = 3l ave ). Although the 50% level seems to overwhelm the normal vector voting algorithm, the other three levels offer useful results for most applications. Again, these graphs demonstrate the robustness of the algorithm.</p><p>Finally we explore real data from an IVP Ranger System <ref type="bibr" target="#b19">[20]</ref>, which is a sheet-of-light profile scanner. Figure <ref type="figure" target="#fig_16">19a</ref> shows the experimental configuration for this system within our laboratory. The basic output of the scanner is a single range profile in the plane of the sheet of light. For our tests we stack 512 profiles together to form a 512 × 512 range image with 256 range bins at 0.62 mm resolution. With proper system calibration, we convert these range images into appropriate triangle meshes. We again use three surface types as with the synthetic data. The actual objects for these surfaces appear in Fig. <ref type="figure" target="#fig_16">19b</ref>. As ground truth, the cylinder has a radius of 26 mm, and the sphere has a radius of 28.5 mm. With slight modifications, we use the same error measures and graphs as with the synthetic data. Since we do not know the absolute orientation of the objects relative to the scanner, we must account for this uncertainty. For the plane, we average the normal estimates to serve as the ground truth N p = 1 n N v for each vertex, and for the cylinder, we average the minimum principal direction estimates T p = 1 n T v . These ad hoc formulations of ground truth introduce some error, but the error is constant across our analysis and is tolerable. Figure <ref type="figure" target="#fig_17">20</ref> shows the scanned surfaces on the left column and the error graphs on the right. These results are similar to the synthetic data where again the normal vector voting algorithm shows improvement over Taubin's algorithm.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSIONS</head><p>We have introduced a novel and original algorithm that robustly estimates surface curvature on a triangle mesh. This algorithm bridges the gap in the literature between Taubin's algorithm <ref type="bibr" target="#b43">[44]</ref> and Tang and Medioni's algorithm <ref type="bibr" target="#b42">[43]</ref>. Taubin formulates a discrete estimate for curvature on a mesh but he does not address surface noise. Tang and Medioni on the other hand do address noise, but their algorithm does not completely estimate surface curvature. In particular, Tang and Medioni do not show how to estimate principal curvatures.</p><p>Our algorithm completely estimates surface curvature, including principal curvatures, and does so in a robust manner despite surface noise.</p><p>Two additional contributions of this research are the application of geodesic neighborhoods to large meshes and a new surface classification scheme for smoothness discontinuities. The normal vector voting algorithm allows the user to specify a geodesic distance that bounds the voting neighborhood of the algorithm. To generate these neighborhoods, we have modified Kimmel and Sethian's fast marching algorithm <ref type="bibr" target="#b20">[21]</ref>. This algorithm, and geodesic operations in particular, should be of interest to other 3D modeling applications beyond our curvature algorithm. Another contribution is the classification scheme for detecting surface discontinuities. Since we assume that our meshes approximate piecewise-smooth surfaces, we must be careful when estimating curvature along, or near, crease discontinuities. To identify these creases, we have presented a novel detection scheme that labels each vertex in the mesh as either on a smooth surface patch, along a crease discontinuity, or with no preferred orientation. This scheme allows us to handle appropriately the corresponding curvature singularities that occur. Other computer graphics and computer vision applications such as simplification, smoothing, and segmentation algorithms should find this detection scheme beneficial as well.</p><p>We have presented results for our algorithm using both synthetic and real data sets. For the synthetic data, we have used controlled experiments with ground truth to evaluate the performance of the algorithm with respect to varying levels of noise. For the real data, we have generated meshes within our laboratory using an IVP Ranger imaging system and have used online data from a wide variety of sources including medical and industrial scanners. The emphasis for each data set is a large dense triangle mesh with different degrees of measurement noise across the entire data set. In addition to a qualitative analysis of our results, we have presented an in-depth quantitative analysis as well. In particular, we have directly compared the results of our algorithm to Taubin's original algorithm <ref type="bibr" target="#b43">[44]</ref>. As a side note, since Tang and Medioni <ref type="bibr" target="#b42">[43]</ref> formulate their algorithm for point clouds and since they do not estimate principal curvatures, we do not compare our algorithm to theirs. The success of these results demonstrate the stable and robust performance of our algorithm in the presence of different types of surface noise.</p><p>An issue of future research is to improve the overall performance of our implementation. The graph in Fig. <ref type="figure" target="#fig_0">21</ref> shows a simple timing analysis of the proposed algorithm for the fandisk model in Fig. <ref type="figure" target="#fig_8">9</ref>. The computing platform is an SGI Octane with a single FIG. <ref type="figure" target="#fig_0">21</ref>. A graph depicting the computational performance time for the normal vector voting algorithm as a function of k-geodesic neighborhood size. The analysis is for the fandisk model and the times are in seconds. Each data point on the graph represents a single run of the two-pass algorithm through the entire mesh.</p><p>195 Mhz MIPS R10000 processor and 128 megabytes of memory. Although we have not optimized the current code configuration, the trend in the plot is interesting. As we increase the k-geodesic neighborhood with the intent of improving our curvature estimate, the computational time grows non-linearly. The three-and five-geodesic neighborhoods show reasonable performance compared to the one-geodesic neighborhood that is equivalent to the one-ring algorithm of Taubin. Thus we argue that the improvement in accuracy, as demonstrated in Figs. <ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref>, with modest increases in neighborhood size are worth the slight increase in processing time.</p><p>For our direct comparison of Taubin's algorithm to our proposed algorithm, we have chosen not to include smoothing as a preprocessing step for Taubin's algorithm. Although a fair comparison would require such processing, we have argued that our intent is to baseline our algorithm. However, some additional comments might be of interest especially in the context of the timing information above. First, preprocessing with a smoothing algorithm requires additional computation effort. That effort should bring the performance of our larger neighborhoods inline with the combination of smoothing and Taubin's algorithm. Second, an interesting challenge is the choice of a smoothing algorithm itself since such a choice has a tremendous impact. In particular, we would be interested in whether the smoothing algorithm preserves crease discontinuities. Additionally, another question arises with regard to handshaking between a smoothing algorithm and Taubin's curvature estimation to ensure that we handle curvature discontinuities properly. Taubin's algorithm does not address the possibility of curvature singularities.</p><p>In conclusion, the major contribution of this research is a new robust algorithm that estimates both principal directions and principal curvatures for vertices of a triangle mesh where this mesh is an approximation of a piecewise-smooth surface. This algorithm addresses a fundamental problem in differential geometry relative to practical implementation on 3D graphical models. The future direction for this research is to employ this algorithm to govern both mesh simplification and mesh segmentation algorithms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIG. 1 .</head><label>1</label><figDesc>FIG. 1. Illustration of curvature for a surface. (a) Shows a normal curvature on the surface S at the point p. The plane p contains the unit surface normal N and the unit tangent vector T for point p. (b) The principal directions T 1 and T 2 form an orthonormal basis for the infinite set of normal curvatures at p.</figDesc><graphic coords="4,53.19,44.09,287.04,116.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FIG. 3 .</head><label>3</label><figDesc>FIG. 3. This block diagram shows the flow of the normal voting process for a single vertex. With slight modifications, the same diagram applies for the estimation of the surface normal for a vertex and of the surface curvature for a vertex.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIG. 4 .</head><label>4</label><figDesc>FIG. 4. Examples of different sizes of geodesic neighborhoods for the same vertex on a cylindrical surface mesh. (a), (b), and (c) have one-, three-, and five-geodesic neighborhoods, respectively.</figDesc><graphic coords="10,57.19,44.00,278.88,71.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FIG. 5 .</head><label>5</label><figDesc>FIG. 5. Examples of geodesic neighborhoods versus ring neighborhoods. The alternating rings of shaded and white triangles depict the various rings. The thick circles bound geodesic neighborhoods. (a) The "A" triangles distinguish a one-ring neighborhood from a one-geodesic neighborhood. The "B" triangles show a similar difference for a two-ring and a two-geodesic. (b) When triangulations are not as regular, we often see more exaggerated differences. (c,d) Triangulations that exhibit the behavior depicted in (a) and (b).</figDesc><graphic coords="11,91.33,44.16,212.64,238.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FIG. 6 .</head><label>6</label><figDesc>FIG. 6. Geometries for normal vector voting. (a) A simple translation of N (N i = N ). (b) A slightly more sophisticated vote where we rotate N by (2θ i -π ) in plane i . (c) Curvature estimation geometry where N v , n i , and T i lie in the plane i and n i is the projection of N v i onto the plane.</figDesc><graphic coords="13,48.33,43.39,297.84,110.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>surface patch saliency; S c = λ 2 -λ 3 , crease junction saliency; andS n = λ 3 ,no preferred orientation saliency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FIG. 7 .</head><label>7</label><figDesc>FIG. 7. These ellipsoids depict possible variations in the eigenvalues. We interpret these variations of V v as the orientation saliency of the neighborhood around v. (a) Covariance matrix V v where the eigenvalues λ 1 , λ 2 , and λ 3 define the shape. (b) Surface patch where λ 1 is much larger than λ 2 , and λ 3 . (c) Crease discontinuity where λ 1 , and λ 2 are similar in value but larger than λ 3 . (d) Patch with no preferred orientation where each eigenvalue is similar in value.</figDesc><graphic coords="14,64.19,457.30,265.20,127.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>FIG. 8 .</head><label>8</label><figDesc>FIG. 8. These examples illustrate different dihedral angles for creases on piecewise-smooth surfaces. The normal vectors N 1 and N 2 are for the respective smooth patches adjacent to the crease.</figDesc><graphic coords="16,76.69,43.56,240.48,109.17" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>FIG. 9 .</head><label>9</label><figDesc>FIG. 9. The fandisk model is an example of a free-form CAD model with sharp edges and sophisticated surface curvature. (a) The original triangle mesh is from the distribution available at http://research.microsoft.com/research/graphics/hoppe/. The mesh size is 6,475 vertices with 12,946 triangles. (b) Same model with Gaussian noise added to the vertices of the mesh. The variance of the Gaussian distribution is 0.1% of l ave . (c) The Normal Vector Voting algorithm with a one-geodesic neighborhood (ε = 32, g m = l ave ) labels the creases of the original mesh as we might expect. (d) With noise the algorithm using a five-geodesic neighborhood (ε = 2, g m = 5l ave ) is robust but does not detect the small crease on the left side of the figure.</figDesc><graphic coords="18,91.18,322.06,211.68,232.83" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>FIG. 10 .</head><label>10</label><figDesc>FIG. 10. The torus model exhibits a genus one topology. (a) The smooth surfaces of the original model. (b) If we consider the torus as a volume data set and apply a marching cube algorithm, we introduce systematic artifacts in the mesh. This mesh has 7,302 vertices and 14,604 triangles. (c) A zoom view of the side of the mesh in (b) with normals shown extending from each vertex. (d) The same zoom area where the normals are estimated using normal vector voting with an eight-geodesic neighborhood (g m = 8l ave ).</figDesc><graphic coords="19,91.33,43.98,212.16,232.74" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>FIG. 11 .</head><label>11</label><figDesc>FIG. 11. Curvature estimation for the fandisk model. (a) Illustrates a small one-geodesic neighborhood (g m = l ave ) for a single vertex. (b) A larger five-geodesic neighborhood (g m = 5l ave ) for the same vertex. (c) Estimates for the principal directions with 0.1% Gaussian noise added to the fandisk. The zoom area is for the small neighborhood in (a). (d) The same zoom area showing estimates for the larger neighborhood of (b).</figDesc><graphic coords="20,90.69,43.92,211.68,232.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>FIG. 12 .</head><label>12</label><figDesc>FIG. 12. Curvature estimation for the torus. (a) Illustrates a small one-geodesic neighborhood (g m = l ave ) for a single vertex. (b) A larger eight-geodesic neighborhood (g m = 8l ave ) for the same vertex. (c) Shows the principal directions for small neighborhood in (a). (d) The same zoom area showing estimates for the larger neighborhood of (b).</figDesc><graphic coords="21,91.33,43.44,212.16,233.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>FIG. 13 .</head><label>13</label><figDesc>FIG. 13. Increasing the neighborhood leads to errors in the curvature estimate near the crease discontinuities. (a) The zoom view shows a crease from the fandisk at the top of this image. The principal directions near this crease tend to point erroneously across the discontinuity. (b) When we restrict the neighborhood from crossing the discontinuity, the estimates for the principal directions improve.</figDesc><graphic coords="21,83.83,462.84,227.52,132.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>FIG. 16 .</head><label>16</label><figDesc>FIG. 16. Algorithm comparison for synthetic surfaces with Gaussian noise added. The variance of the noise distribution is 10% of l ave . The comparison graphs show the normal vector voting algorithm with a three-and a five-geodesic neighborhood size (g m = 3l ave and g m = 5l ave ) compared to the original algorithm of Taubin. The graphs are bin plots with log scales, and each mesh contains 1,024 vertices and 1,922 triangles. (a,b) Planar surface, (c,d) cylindrical surface, and (e,f ) spherical surface.</figDesc><graphic coords="24,31.69,43.56,330.24,422.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>FIG. 17 .</head><label>17</label><figDesc>FIG. 17.A synthetic planar surface with various noise levels for our experiments. The noise variance is (a) 50% l ave , (b) 10% l ave , (c) 5% l ave , and (d) 1% l ave .</figDesc><graphic coords="25,26.33,43.41,341.76,67.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>FIG. 18 .</head><label>18</label><figDesc>FIG. 18. Comparison for synthetic data with different levels of Gaussian noise added. The variances of the noise distribution are 50, 10, 5, and 1% of l ave . The graphs show the normal vector voting algorithm for a threegeodesic neighborhood (g m = 3l ave ) and are bin plots with log scales. Each mesh contains 1,024 vertices and 1,922 triangles. (a,b) Plane, (c,d) cylinder, and (e,f ) sphere.</figDesc><graphic coords="26,19.19,43.72,354.72,279.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>FIG. 19 .</head><label>19</label><figDesc>FIG. 19. (a) Experimental configuration for the IVP Ranger System, which is sheet-of-light profiling system. (b) Ground truth objects for our real range data comparison.</figDesc><graphic coords="26,87.19,481.04,219.36,136.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>FIG. 20 .</head><label>20</label><figDesc>FIG. 20. Algorithm comparison for real data from IVP Ranger. The comparison graphs show the normal vector voting algorithm with a three-and a five-geodesic neighborhood size (g m = 3l ave and g m = 5l ave ) compared to the original algorithm of Taubin. The graphs are bin plots with log scales. Note the quantization noise on each surface. (a,b) Plane with 10,507 vertices and 20,578 triangles. (c,d) Cylinder with 7,407 vertices and 14,424 triangles. (e,f ) Sphere with 4,026 vertices and 7,732 triangles.</figDesc><graphic coords="27,48.33,43.56,298.56,422.16" type="bitmap" /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was supported by the University Research Program in Robotics under Grant DOE-DE-FG02-86NE37968, by the DOD/TACOM/NAC/ARC Program, R01-1344-18, and by FAA/NSSA Program, R01-1344-48/49.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Automatic segmentation of digitized data for reverse engineering applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Alrashdan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Motavali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Fallahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IIE Trans. 32</title>
		<imprint>
			<biblScope unit="page" from="59" to="69" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Piecewise smooth subdivision surfaces with normal control</title>
		<author>
			<persName><forename type="first">H</forename><surname>Biermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zorin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Preceedings (SIGGRAPH 2000</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="113" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A survey of free-form object representation and recognition techniques</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Flynn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Vision Image Understanding</title>
		<imprint>
			<biblScope unit="volume">81</biblScope>
			<biblScope unit="page" from="166" to="201" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Intrinsic surface properties from surface triangulation</title>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Schmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Computer Vision</title>
		<meeting>the European Conference on Computer Vision<address><addrLine>Santa Margherita Ligure, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="739" to="743" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<author>
			<persName><forename type="first">H</forename><surname>Delingette</surname></persName>
		</author>
		<idno>2214</idno>
	</analytic>
	<monogr>
		<title level="m">Simplex Meshes: A General Representation for 3D Shape Reconstruction</title>
		<imprint>
			<date type="published" when="1994-03">March 1994</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">General object reconstruction based on simplex meshes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Delingette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Comput. Vision</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="111" to="146" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Implicit fairing of irregular meshes using diffusion and curvature flow</title>
		<author>
			<persName><forename type="first">M</forename><surname>Desbrun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H</forename><surname>Barr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings (SIGGRAPH&apos;99)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="317" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A note on two problems in connexion with graphs</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numer. Math</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="269" to="271" />
			<date type="published" when="1959">1959</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Carmo</surname></persName>
		</author>
		<title level="m">Differential Geometry of Curves and Surfaces</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Deriving coarse 3D models of objects</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ferrie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Levine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings International Conference on Computer Vision and Pattern Recognition</title>
		<meeting>International Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="1988-06">June 1988</date>
			<biblScope unit="page" from="345" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Darboux frames, snakes, and super-quadrics: Geometry from the bottom up</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Ferrie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lagarde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Whaite</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="771" to="784" />
			<date type="published" when="1993-08">August 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Surface classification: Hypothesis testing and parameter estimation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Flynn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the International Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="1988-06">June 1988</date>
			<biblScope unit="page" from="261" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On reliable curvature estimation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Flynn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the International Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="110" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Surface simplification using quadric error metrics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings (SIGGRAPH&apos;97)</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Woods</surname></persName>
		</author>
		<title level="m">Digital Image Processing</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Surface reconstruction based on lower dimensional localized Delaunay triangulations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gopi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Gross</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">R A</forename><surname>Hopgood</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2000">Eurographics 2000. 2000</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="C467" to="478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Pattern Vector Based Reduction of Large Multimodal Data Sets for Fixed Rate Interactivity during Visualization of Multiresolution Models</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Gourley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-12">December 1998</date>
			<pubPlace>Knoxville, TN</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Tennessee</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Simulation based modeling</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Heinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thesing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schreiber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Shape Modeling</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="143" to="164" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Optimal triangulation and quadric-based surface simplification</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Geom. Theory Appl</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="49" to="65" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Integrated Vision Products, Sweden, User Documentation: MAPP Ranger System, Version 1</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Computing geodesic paths on manifolds</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kimmel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Sethian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci. 95</title>
		<meeting>Natl. Acad. Sci. 95</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="8431" to="8435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Kinsey</surname></persName>
		</author>
		<title level="m">Topology of Surfaces</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Shape description using surface triangulation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Perry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Workshop on Computer Vision: Representation and Control</title>
		<meeting>the IEEE Workshop on Computer Vision: Representation and Control</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="38" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Fast and memory efficient polygonal simplification</title>
		<author>
			<persName><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;98</title>
		<meeting>Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="279" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Marching cubes: a high resolution 3D surface construction algorithm</title>
		<author>
			<persName><forename type="first">W</forename><surname>Lorenson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings (SIGGRAPH &apos;87)</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Partitioning 3D surface meshes using watershed segmentation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Mangan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Whitaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Visual. Comput. Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="308" to="321" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Estimation of principal curvatures from range data</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Shape Modeling</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="99" to="109" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">A Computational Framework for Segmentation and Grouping</title>
		<author>
			<persName><forename type="first">G</forename><surname>Medioni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Tang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Elsevier</publisher>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The discrete geodesic problem</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S B</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Mount</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="647" to="668" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Mortenson</surname></persName>
		</author>
		<title level="m">Geometric Modeling</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Spline-based surface fitting on range images for CAD applications</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the International Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="1988-06">June 1988</date>
			<biblScope unit="page" from="249" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>O'neill</surname></persName>
		</author>
		<title level="m">Elementrary Differential Geometry</title>
		<meeting><address><addrLine>Orlando, FL</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Robust crease detection and curvature estimation of piecewise smooth surfaces from triangle mesh approximations using normal voting</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Koschan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Paik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abidi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the International Conference on Computer Vision and Pattern Recognition<address><addrLine>Kauai, Hawaii</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-12">December 2001</date>
			<biblScope unit="volume">I</biblScope>
			<biblScope unit="page" from="162" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Computing discrete minimal surfaces and their conjugates</title>
		<author>
			<persName><forename type="first">U</forename><surname>Pinkall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Polthier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Experimental Math</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="15" to="36" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Straightest geodesics on polyhedral surfaces</title>
		<author>
			<persName><forename type="first">K</forename><surname>Polthier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schmies</surname></persName>
		</author>
		<editor>Mathematical Visualization (K. Polthier and H. C. Hege</editor>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="391" to="409" />
			<pubPlace>Berlin/New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Geodesic flow on polyhedral surfaces</title>
		<author>
			<persName><forename type="first">K</forename><surname>Polthier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schmies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Joint Eurographics and IEEE TCVG Symposium on Visualization</title>
		<meeting>the Joint Eurographics and IEEE TCVG Symposium on Visualization</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="179" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Curvature Based Segmentation for 3-Dimensional Meshes, Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Pulla</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<pubPlace>Tempe, AZ</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Arizona State University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Extraction of feature lines on triangulated surfaces using morphological operators</title>
		<author>
			<persName><forename type="first">C</forename><surname>Rössl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Smart Graphics (AAAI Symposium 2000)</title>
		<meeting><address><addrLine>Menlo Park, CA; New York</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="71" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Stable surface estimation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Sander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Zucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth International Conference on Pattern Recognition</title>
		<meeting>the Eighth International Conference on Pattern Recognition<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="1165" to="1167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Inferring surface trace and differential structure from 3-D images</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Sander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Zucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="833" to="854" />
			<date type="published" when="1990-09">September 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Three-Dimensional Object Recognition from Range Images</title>
		<author>
			<persName><forename type="first">M</forename><surname>Suk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Bhandarkar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Tokyo; Berlin/New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Surface matching by 3D point&apos;s fingerprint</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Abidi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth International Conference on Computer Vision</title>
		<meeting>the Eighth International Conference on Computer Vision</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="263" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Robust estimation of curvature information from noisy 3D data for shape description</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Medioni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Conference on Computer Vision</title>
		<meeting>the Seventh International Conference on Computer Vision<address><addrLine>Kerkyra, Greece</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-09">September 1999</date>
			<biblScope unit="page" from="426" to="433" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Estimating the tensor of curvature of a surface from a polyhedral approximation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Conference on Computer Vision</title>
		<meeting>the Fifth International Conference on Computer Vision</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="902" to="907" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Estimation of curvatures from planar point data</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Tookey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Ball</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Mathematics of Surfaces VII, Information Geometers</title>
		<meeting><address><addrLine>Winchester</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="131" to="141" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Best fit surface curvature at vertices of topologically irregular curve networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Várady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Mathematics of Surfaces VI</title>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="411" to="427" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Curvature-based representation of objects from range data, Image and Vision Comput</title>
		<author>
			<persName><forename type="first">B</forename><surname>Vemuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mitiche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Aggarwal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Weiss</surname></persName>
		</author>
		<title level="m">Data Structures and Algorithm Analysis in C++</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">3D part segmentation using simulated electrical charge distributions</title>
		<author>
			<persName><forename type="first">K</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Levine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1223" to="1235" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Segmentation of measured point data using a parametric quadric surface approximation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="449" to="457" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
