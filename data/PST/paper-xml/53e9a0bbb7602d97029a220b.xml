<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Software architecture styles as graph grammars</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Daniel</forename><surname>Le M~tayer</surname></persName>
							<email>lemetayer@irisa.fr</email>
							<affiliation key="aff0">
								<orgName type="department">IRISA/INRIA</orgName>
								<address>
									<addrLine>Campus de Beaulieu</addrLine>
									<postCode>35042</postCode>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Software architecture styles as graph grammars</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7FC81D2B8CC7F4F23E9176EE7295F42F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>coordination</term>
					<term>graph rewriting</term>
					<term>software architecture</term>
					<term>static verification</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a formalism for the definition of software architectures in terms of graphs. Nodes represent the individual agents and edges define their interconnection. Individual agents can communicate only along the links specified by the architecture. The dynamic evolution of the overall architecture is defined independently by a 'coordinator'. An architecture style is a class of architectures characterised by a graph grammar. The rules of the coordinator are statically checked to ensure that they preserve the constraints imposed by the architecture style.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Motivation and approach</head><p>Software systems tend to grow in size and complexity; they are often developed through a long period of time and become extremely difficult to understand and to maintain. The cost incurred by this complexity is becoming a serious concern and a major challenge today is to provide ways of organising software in order to make large applications manageable and to favour the reuse of existing products. Several languages or systems have been proposed recently to tackle these problems: they are called software architecture languages <ref type="bibr" target="#b11">[12]</ref>, configuration languages <ref type="bibr" target="#b17">[18]</ref> or coordination languages <ref type="bibr">[6,</ref><ref type="bibr" target="#b13">14]</ref>. Despite some differences of emphasis, these works share a common point of view: the definition of a software application should make a clear distinction between individual components and their interaction in the overall software organisation.</p><p>Several authors [1, 2, <ref type="bibr" target="#b15">16</ref>, 27] have emphasized the importance of a framework for the formal definition of software architectures. Not only is it a prerequisite for a rigorous analysis of architectures, but it also increases their usefulness and reusability by removing the sources of ambiguity Permission to make digital/hard copy of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage, the copyright notice, the title of the publication and its date appear, and notice is given that copying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. SIGSOFT'96 CA, USA © 1996 ACM 0-89791-797-9/96/0010...$3.50 which are unavoidable in informal descriptions. Another major requirement for a software architecture model is its ability to express standard software design choices in a natural way. The common practice of software engineers is to represent architectures informally as 'box and line' drawings <ref type="bibr">[2,</ref><ref type="bibr" target="#b16">17]</ref>. Starting from this observation, we propose to define software architectures formally in terms of graphs, which constitute the mathematical model closest to the intuition conveyed by 'box and line' drawings. The nodes of the graph represent the individual entities which can themselves be described in conventional programming languages. The edges correspond to the communication links between entities. An architecture style is a class (or set) of architectures exhibiting a common shape. For example: are two architectures of a style 'pipeline' (with ei representing entity names and S directed links between entities). Technically, architecture styles are defined as context-free graph grammars.</p><p>The architecture can be seen as the skeleton of an application. In order to be executable, it must be 'fleshed', or completed with a mapping from nodes to entities defined in a given language. This complete description is called an architecture instance. The specification of the computation of an architecture instance mirrors its hierarchical organisation:</p><p>• The evolution of the local states of the entities follows the rules of the operational semantics of their programming language.</p><p>• A 'coordinator' is used to pilot the overall application. The coordinator is in charge of managing the architecture itself (creating and removing entities and links).</p><p>The coordinator is expressed in terms of conditional graph rewriting in the spirit of <ref type="bibr" target="#b9">[10,</ref><ref type="bibr">28]</ref>. The conditions bear on the public variables of the entities and represent the only possible interactions between a coordinator and the individual components (apart from the creation and destruction of links and entities).</p><p>The standard way to describe distributed systems is to resort to traditional sequential programming languages enhanced with facilities for process creation and communication (possibly through operating system procedure calls). On the other hand, specification languages like CSP <ref type="bibr" target="#b12">[13]</ref>,</p><p>and the ~r-calculus <ref type="bibr">[23]</ref> are inherently parallel languages providing powerful and integrated constructions for process creation and synchronisation. None of these approaches makes it easy to extract the underlying communication topology from the application. As an illustration, <ref type="bibr" target="#b21">[22,</ref><ref type="bibr">25]</ref> propose sophisticated analyses to derive information about the topology of CSP and CML programs. We believe that a better basis for understanding the structure of a system is to consider its topology as an explicit feature rather than trying to dig it up from the program a posteriori. In other words, we propose that the 'skeleton' of the application is specified independently, with the 'flesh' described in a separate way.</p><p>Among the benefits of our approach, let us mention the following:</p><p>• It makes it possible to reconcile a dynamic view of the architecture, which is crucial for a large class of applications, with the possibility of static checking, ensuring that the evolution of the architecture conforms to its style. This verification can be seen as a form of static type checking of the coordinator (the type being the graph grammar defining the architecture style). In our framework, this amounts to a proof of convergence of graph rewrite rules.</p><p>• It provides a high-level view of software systems which is both intuitive and formally based. The clean separation between the computation of the individual entities and their coordination makes it easier to check global properties of the system. In particular, properties about the information flows in an application can be derived from the architecture style. This is of prime importance to be able to enforce the requirements imposed by a given security policy (confidentiality, integrity).</p><p>The presentation of the paper follows this two-level decomposition. In the next section, we introduce our view of architectures as graphs and architecture styles as graph grammars. Section 3 defines coordination as conditional graph rewriting and describes an algorithm for the static checking of a coordinator with respect to a given style. Sections 2 and 3 are independent of the definition of the atomic components of the architecture. In section 4, we complete the picture with a language for programming the individual entities. We provide a structural operational semantics of this language and we show how it cooperates with the semantics of coordination. In the conclusion, we relate our approach to previous work in this area and we suggest avenues for further research.</p><p>We use the 'client-server' model as a case study throughout the paper. Following the top-down presentation of the material, the client-server architecture style itself is introduced in section 2; a first version of the coordinator is presented in section 3 and the complete application is described in section 4 (Figure <ref type="figure" target="#fig_2">1</ref>). A second example is presented in the appendix (a distributed hospital ward monitoring system inspired by <ref type="bibr" target="#b17">[18]</ref> and <ref type="bibr" target="#b14">[15]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Architecture styles</head><p>Our notion of graphs is inspired by previous work on the chemical reaction model <ref type="bibr">[3,</ref><ref type="bibr">4,</ref><ref type="bibr" target="#b9">10]</ref> and set-theoretic graph rewriting <ref type="bibr">[28]</ref>. Formally, a graph is a multiset of relation tuples noted R(el,..., e,~) where R is a n-ary relation name and el are entity names (we assume appropriate countable sets of names). We consider only binary and unary relations here. In our context, a binary relation L(el, e2) represents a directed link of name L between el and e2. A unary relation U(e) characterises the role of an entity e in the architecture.</p><p>As an illustration, the following (unconnected) graph represents an example of a client-server architecture.</p><p>Unary relations are represented by circles and binary relations by arrows. C, S, M and X correspond respectively to client, server, manager and external entities. The external entity stands for the external world; it records requests for new clients wanting to be registered in the system. CR and CA correspond to client request links and client answer links respectively (SR and SA are the dual links for servers). The architecture represented by the above graph involves two clients cl and c2, two servers sl and s2, a manager m and x. It is formally defined as the multiset A:</p><formula xml:id="formula_0">{X(x), M(m), C(cl), C(c2), S(sl), S(s2), CR(cl, m), OR(c2, m), CA(m, cl), CA(m, c2), SR(m, sl), SR(m, s2), SA(sl, m), SA(s2, m)}</formula><p>It should be clear that A is just one particular representative of a more general class of client-server architectures. Architectures belonging to this class must include values X(x) and M(m) and any number of servers and clients. Furthermore, they must follow the communication link pattern exhibited by A. We propose to specify such a class as a context-free graph grammar. Different notions of contextfree graph grammars have been studied in the literature. They are defined either in terms of node replacement <ref type="bibr" target="#b8">[9]</ref> or in terms of hyper-edge replacement <ref type="bibr">[7]</ref>. Graph rewriting is also used in <ref type="bibr" target="#b7">[8]</ref> as a model for distributed systems, but a dual approach is taken, with hyper-edges representing processes and nodes representing ports (also the process rewrite rules are essentially used to model synchronisation requirements). Our definition of graphs as multisets allows us to express hyper-edge replacement in a very natural way. A grammar is a four-tuple [NT, T, PR, AX] where NT and T are sets of non-terminal and terminal symbols (each one with a given arity), PR is a finite set of production rules and AX is an axiom (the origin of the derivation). Terminal symbols correspond to the relations of the architecture. The production rules are pairs (l, r) where l is a singleton {A(xl,..., x,)} (with A a non-terminal of arity i) and r is a multiset of terms B(y~,..., y~) with B E NT U T.</p><p>Continuing our example, the client-server architecture style is defined as:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hcs [{CS, CS1}, {M, X, C, S, CR, CA, SR, SA}, R, CS]</head><p>with R the following set of rules (we use the concrete syntax Left =~ Right to represent a pair ({Left}, {Right}):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CS ~ CSt(m) CSI(m) ~ CR(c,m), CA(re, c), C(c), CSI(m) CS1 (m) =~ SR(m, s), SA(s, m), S(s), CSl(m) CSl(m) ~ M(m), X(x)</head><p>Formally, a graph grammar H = [NT, T, PR, AX] defines a rewrite system --~H between multisets:</p><formula xml:id="formula_1">M-+HM' ¢* M' = M--ml+m~</formula><p>with rnl C M, (Ne(m~)-Ne(ml)) N Ne(M) = 0, and mz = a l, m~ = a r, with a an injective substitution and (l, r) 6 PR. The substitution ~ maps variables to entity names. N~(M) is the set of entity names occurring in the multiset M. The second condition ensures that new variables occurring on the right-hand side of a rule are instantiated with entity names which are distinct from all other existing names. This constraint, which is usual in graph rewriting <ref type="bibr">[28]</ref>, is necessary to avoid unexpected variable sharing. It is crucial in our context to be able to state precisely the actual connections between entitles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The style defined by a grammar H = [NT, T, PR, AX]</head><p>is the set of all terminal graphs (graphs containing only terminal relation symbols) produced by --~H rewritings:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Class(H) = {G] {AX} ~ G and G terminal}</head><p>For example, it is easy to check that the graph A defined above belongs to the client-server class: A 6 Class(Hcs).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Coordination</head><p>As mentioned in the introduction, it is often the case that the architecture of an application should be able to evolve dynamically. For instance, a client-server organisation must allow for the introduction of new clients or their departure, a pipeline may grow or shrink dynamically depending on the size of the data being processed, facilities for dealing with mobile computing may be required. In our framework, the evolution of the architecture is defined by a coordinator. The task of the coordinator is expressed by conditional graph rewrite rules in the style of <ref type="bibr">[3,</ref><ref type="bibr">4]</ref>. The semantics of the rules is similar to the definition used above for the rewrite system associated with graph grammars, except that we may have additional side conditions in coordination rules. These conditions bear on the local states of the individual entities; they do not play any role at this stage, so we do not consider them until the next section.</p><p>As an illustration, we introduce the following coordinator</p><p>Coocs which applies to a client-server architecture:</p><formula xml:id="formula_2">X(x), M(m)--+ X(x'), M(m), Cn(c,m), CA(m,c), C(e) CR(c,m), CA(re, c), C(c) -~ O</formula><p>The two rules describe respectively the introduction of a new client in the architecture and its departure. Note that these rules are completed with side conditions on the states of the entities in the complete version of the coordinator presented in the next section (Figure <ref type="figure" target="#fig_2">1</ref>); otherwise, the coordinator could clearly lead to infinite behaviours.</p><p>The possibility of expressing architecture transformations is definitely a useful feature but it also raises a new question: is it possible to ensure that a coordinator does not break the constraints of a given architecture style? For example, had we forgotten, say CR(c, rn) in the right-hand side of the first rule, then the coordinator would have been able to transform a client-server architecture into an architecture which does not belong any longer to the client-server class defined by Hes. What is needed is a static style checker which would be the counterpart for coordinators of the type checking algorithms of classical languages.</p><p>In order to define a checking algorithm for a given style The coordinator Coo defines a second graph rewrite relation -+Coo and the checking algorithm must ensure that:</p><formula xml:id="formula_3">V G such that G 4-H 1 {AX}, G-+coo a' =~ a' C+-H ~ {AX}</formula><p>The checking algorithm proceeds in two stages.</p><p>I. First, all the Coo rules (ll, rl) are considered in turn.</p><p>For each Ii, the set Si of all its minimal contexts C~ </p><formula xml:id="formula_4">l, + CJi -5,-H 1 {N](x~,...,x~)}.</formula><p>The minimal contexts C~ are the smallest multisets which have to be added to the Ii to reduce to a nonterminal (in other words, they are completely consumed by the reduction). They are computed by constructing all the possible superpositions (non empty intersections) of li with left-hand sides of -+H 1 rules and performing the corresponding reductions until a non-terminal is reached (or a term isomorphic to one of its ancestors). This iteration terminates because the reductions cannot increase the size of a term and the number of terms of a given size is finite (up to variable renaming). 'Impossible contexts' (contexts which cannot lead to a single non-terminal, and thus cannot lead to the axiom AX) are removed during the course of this process for a better precision of the analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The second stage consists in applying --+H ~ rules, to</head><p>show that all pairs (h, rl) satisfy:</p><formula xml:id="formula_5">V(C~, N[(xl,...,x~)) 6 Si, r, + C{ 2+-H 1 {N](Xl,...,x,)}.</formula><p>The second stage terminates for the same reason as the first one. If the above property holds, then Coo is correct with respect to the style H.</p><p>The correctness of the algorithm is proven in <ref type="bibr" target="#b9">[10]</ref>. As This concludes the verification that Coocs is a correct coordinator with respect to the client-server style CS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Architecture instances</head><p>We have presented architecture styles and architecture transformations without any assumption on the individual entities so far. This section completes the picture by introducing a small language for entities. We provide its formal definition in terms of a structural operational semantics and we show how it interacts with the actions of the coordinator. The syntax of the language of entities is better introduced through the complete version of the client-server application in Figure <ref type="figure" target="#fig_2">1</ref>. First note that the relations defining the links of the architecture are typed (and so are the variables they bear on). The basic types are names of entities (client, server, manager, external here). For instance, the type attached to CR specifies a link from a client entity to a manager entity. Each entity defines public and private variables, output and input links and entity names. The public variables can be checked (but not assigned) by the coordinator. The public variable v of an entity a is denoted by a.v in the definition of the coordinator. For example, the complete definition of Coocs creates a new client only if the boolean variable newc of the entity x is true. A new instance x' of the external entity is created in the same rule (which prevents the immediate re-application of the rule).</p><p>Similarly, clients use a public variable leave to indicate their intention to leave the system. The output and input links of the entities must conform to the edges of the architecture (this can be checked statically).</p><p>The commands of the language are very much in the spirit of CSP except for the following generalisation: the semantics of input and output commands of the form a6L?v and a6L!E are closer to the standard CSP rendez-vous since the names of the partner entity is explicitly specified. This facility is necessary for an entity to realise a series of communications with the same partner: for instance, the manager must send the answer to the client which has issued the initial request.</p><p>The complete syntax of the commands of the language of entities is the following:</p><formula xml:id="formula_6">C --v :--E [ skip I C1 ; C2 [ Corn [a -~ C(D a-~ C)*] I • [C -+ C(D G-~ C)*] Corn = H!E I H?v H = a:L I a6L G = B I Corn I (B, Corn)</formula><p>Symbols E and B denote respectively expressions (of any type) and boolean expressions, L is a link symbol declared in the out or in section, a is an entity variable and v any other (public or private) variable. As in CSP, a guard may be a combination of a boolean expression and a communication command. The semantics of the language is defined in the top part of Figure <ref type="figure" target="#fig_3">2</ref> as a labelled transition system on local configurations of the form &lt; C, S &gt;, with C a command and S a store. As usual, the label e is used for silent transitions (transitions involving no communication). Sem [E] S is the semantics of expression E in store S and S[val/v] is the same as S except that variable v takes the value val. ~(Com, S, Corn', S') is an intermediate relation associating the label Corn' and the new store S' with the communication command Corn and store S. R plays a similar role for guards. The label Corn' and the new store S' are specified by the relation p, which formalises the above discussion on input and output commands. A repetitive command terminates when each guard includes a false boolean condition. Note that we do not follow the original CSP convention indicating the termination of the repetitive command when all processes addressed in the input/output guards have terminated <ref type="bibr" target="#b12">[13]</ref>. This option would not make sense in our setting since, as explained above, a communication command may avoid to name the partner process explicitly and new processes and links can be added by the coordinator.</p><p>Let us now focus on the bottom part of Figure <ref type="figure" target="#fig_3">2</ref> which defines the semantics of the coordinator and show how it fits with the semantics of the underlying language of entities. Global configurations are triples <ref type="bibr">[Coo, G, Val]</ref> where Coo is the set of conditional rewrite rules defining the coordinator, G is the graph representing the architecture and Val is a function mapping entity names onto local configurations (pairs &lt; C, S &gt;). The three rules defining the semantics of coordination correspond to the following cases:</p><p>• The first rule simply propagates at the level of global configurations the silent transitions of local configurations.</p><p>• The second rule ensures proper matching of local transitions involving communications.  An important observation concerning the process language described here is that it is very minimal indeed: it does not provide any facility for parallelism (no process creation, no parallel construct). This follows our original design choice of keeping a clear separation between the computation at the level of entities and the management of concurrency and communication at the level of the coordinator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>~(H, S, H', S') ~(H ! E, S, H' ! (Sern [E] S) ,S') p(H, S, H', S') ~(H ? v , S, H' ? val, S'[val/v]) p(a 6 L, S, p : L, S[pla]) p(a : L, S, S(a) L, S)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics of coordination --*lc Vat(p) " ' [Coo, G, Vat] ~-* [Coo, G, Val[tc'/p]]</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>The need for specific languages and formal frameworks for describing the overall organisation of large software systems has triggered a considerable interest for software architectures and coordination languages during the last decade. Up-to-date surveys of formalisms and current trends can be found in <ref type="bibr" target="#b11">[12,</ref><ref type="bibr">29]</ref>. In order to relate our contribution to previous work in this area, let us focus on two complementary issues: the formal model used to describe software architectures and the features provided by specific software architecture or coordination languages.</p><p>• Formal models: Among the formal frameworks used to specify software architectures, let us mention the specification language Z [1], CSP [2], the chemical abstract machine <ref type="bibr" target="#b15">[16]</ref>, the ~r-calculus <ref type="bibr" target="#b20">[21]</ref>, partial ordered sets of events <ref type="bibr" target="#b19">[20]</ref> and first-order logical theories [24]. These formalisms have been extensively studied and their respective advantages have been identified: Z is a widely used state-based specification language which allows for a clean decomposition of applications into collections of schemas (in the context of software architectures, schemas can be components, connectors, configurations [1]); CSP <ref type="bibr" target="#b12">[13]</ref> and the ~r-calculus [23] are process algebra which highlight the concurrency and communication issues; the ~r-calculus includes powerful features for manipulating channels as first-class values which increases its potential for describing dynamic architectures; the chemical abstract machine [5] is based on the chemical reaction metaphor [4] which allows for a higher level of abstraction promoting parallelism as a basic computational model; the eventbased structures of <ref type="bibr" target="#b19">[20]</ref> are well suited to the explicit representation of timing properties; the logical theories used in <ref type="bibr">[24]</ref> form the basis of a definition of a notion of architecture refinement.</p><p>• Software architecture languages: there is a great variety of needs for software architectures [29] and this fact is reflected in the variety of papers published in this active area during the last few years. Aesop <ref type="bibr" target="#b10">[11]</ref> provides facilities for the design and graphical visualisation of architectures following the rules prescribed by specific styles. Architecture styles are defined in a generic object model and include the specification of a vocabulary and constraints on the connections between elements. Unicon <ref type="bibr" target="#b22">[30]</ref> supports a variety of components (such as 'shared data', 'filter', 'sequential file') and connectors (such as 'pipes', 'remote procedure calls') which have been implemented and used as a testbed for experimenting system construction mechanisms. Other proposals put more emphasis on the dynamic aspects of the system, introducing a separation between the sequential computation of individual agents and their coordination expressed in a specific languages <ref type="bibr">[6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b17">18]</ref>. In Linda [6], activities cooperate through a global tuple space using specific associative access primitives. The Conic environment provides a neat separation between individual tasks with explicit interfaces and a configuration level describing the overall application (which involves specifying the task components and establishing links between their ports). The Conic environment supports graphic tools for configuration programming and monitoring. Concoord <ref type="bibr" target="#b13">[14]</ref> introduces a notion of coordinator which is in charge of a collection of processes. A coordinator has access to the state variables of its processes and can test them to trigger the creation (or deletion) of processes and the binding (and unbinding) of ports.</p><p>As far as formalisation is concerned, our approach to software architectures is in the spirit of previous proposals based on process calculi like CSP [2] or the ~r-calculus <ref type="bibr">[23]</ref>. On the other hand, our computational model based on a clean separation between individual entities and a coordinator is inspired by <ref type="bibr" target="#b13">[14]</ref> (but no formal model is provided for Concoord <ref type="bibr" target="#b13">[14]</ref> and a number of technical choices differ from our own approach).</p><p>The main departure of our contribution with respect to the above process calculi based proposals is the emphasis put on the geometry of the architecture (following the 'box and line' drawing analogy), promoting it as an independent object. We believe that graph grammars provide a useful device for an intuitive and unambiguous understanding of the overall organisation of a system and form a suitable basis for various analyses. We observe, for example, that any powerful proof technique for parallel languages must include some form of analysis to obtain information about the communication topology of the program. The difficulty of this task is illustrated in various papers <ref type="bibr" target="#b21">[22,</ref><ref type="bibr">25]</ref>. Such analyses become much simpler in our framework because the topology is directly available from the specification of the architecture.</p><p>A significant benefit of our approach is that the direct information flows of a system are made explicit. This is because the coordinator cannot perform any assignment and the individual entities can only communicate through the links specified by the architecture. The latter property cannot be enforced by our model because it depends on the underlying language, but it can be ensured by a complementary e~ect analysis. The advantage is that such an analysis is easier to perform because all the parallelism issues are lifted at the level of the coordinator.</p><p>As an illustration of the relevance of our approach for the analysis of non-functional properties, let us consider a simplified version of the well-known 'Bell and LaPadula' security model <ref type="bibr" target="#b18">[19]</ref>. The following graph represents in our setting a small platform with two levels of confidentiality (Confidential and Secret with Confidential &lt; Secret). M:(x) is a server for subjects of clearance Confidential and M: (z) is a server for subjects of clearance Secret (and similarly for M2(y) and M2(t) which are object servers). The links W, R and A represent respectively write requests, read requests and answers to read requests. The links specified by the architecture ensure that:</p><p>• No subject has read access to any object that has a classification greater than the clearance of the subject.</p><p>• No subject has write access to any object that has a classification less than the clearance of the subject.</p><p>Another important issue is the possibility of defining formally a notion of refinement between software architectures. We proposed in <ref type="bibr" target="#b9">[10]</ref> a refinement relation which corresponds to class containment and which can be checked statically on the rules of the graph grammar. This notion of refinement was used in a different context (the transformation of parallel programs to optimise their implementation) and we are now exploring its applicability to software architectures. There does not seem to be a single answer to this problem because different usages may put different requirements on the notion of refinement. For instance, securityrelated properties may be preserved through refinements corresponding to multiset inclusion (because removing links or entities decrease the global information flow), but this form of refinement may not be acceptable for functional properties (because removing links or entities may alter the services provided by the system).</p><p>It should be clear that we have focused on specific aspects of software architectures in this paper and a number of important issues have not been considered. Our framework tackles the coordination problems, but it should be complemented with an appropriate interface to manage the data conversions required to support interoperability. One natural solution would be to rely on the interface definition language of a standard platform like CORBA. Also the types associated with the links in the architecture do not include a communication protocol dimension. We have assumed a rendez-vous mechanism here but a useful extension would be to associate links with user-defined communication protocols. One promising research direction is the notion of regular processes used in <ref type="bibr">[26]</ref> to specify protocols for object behaviours.</p><p>Another issue deserving further work is the design of a user friendly interface supporting externally initiated changes to the architecture <ref type="bibr" target="#b17">[18]</ref>. In our framework, these changes could be expressed, and formally controlled, through the 'external agents' as exemplified by the client-server case study.</p><p>Considering graph grammars themselves, a potentially interesting generalisation would be to consider context sensitive grammars. This would allow us to specify topologies like square grids which are out of reach of context free grammars. Further experience is necessary to assess the usefulness of this extension.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix: a hospital ward monitoring system</head><p>The distributed monitoring of a hospital ward system was used as a case study in <ref type="bibr" target="#b17">[18]</ref> and <ref type="bibr" target="#b14">[15]</ref>. The system consists of a number of nurses, beds and a secretary. Each nurse is associated with a collection of beds, some of them being occupied by a patient. Nurses check the state of their patients regularly and decide when they are allowed to leave the hospital. Patients can also send an alarm to their nurse when their state becomes critical. The following graph represents a possible configuration with two nurses nl and n2. Nurse nl has two free beds fl and f2 and one occupied bed bx. Nurse n2 has one occupied bed b~ and one free bed f3. Links C, R, L are used respectively for asking the state (e.g. temperature) of a patient, receiving his state and sending back the decision taken by the nurse (a boolean value indicating if the patient is allowed to leave the hospital). A is the alarm link and E is used to connect a nurse with her free beds. o Figure <ref type="figure" target="#fig_4">3</ref> shows the architecture style of the application, the coordinator and the programs defining the individual entities. The secretary plays a role similar to the external entity in the client-server architecture. When its newp variable is set to true, the coordinator allocates a new patient to a nurse who has a bed available. Upon request, a nurse receives the temperature t of a patient and uses function F(t) to decide whether the patient is allowed to leave the hospital. The patient receives the decision and stores it in the public variable leave which is used by the coordinator to modify the architecture according to this decision (replacing the occupied bed by a new instance of a free bed). Free beds are inactive entities and the associated program body is the skip command. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>H = [NT, T, PR, AX],we first consider the graph rewrite system __+~1 obtained by a right to left reading of the rules in PR (with the appropriate dual restrictions on variables appearing only on the right-hand side of a rule). Obviously, if G is a graph belonging to the style H, then G 4H 1 {AX}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>an illustration, let us apply it to the coordinator Coors presented above. The first rule of Coovs is:({X(x), M(m)}, {X(x'), M(m), CR(c, m), CA(m, c), C(c)}).There is only one superposition of X(x), M(m) with lefthand sides of __+-1 namely X(x), M(m) itself. The only CS possible rewriting to a non-terminal is {X(x), M(m)} ---~CS--1 {CSl(m)}. Thus $1 = {(O, CSI(m))} and we have to show that: {X(x'), M(m), CR(c,m), CA(re, c), C(c)} -~cs {csl(m)} which is obtained in two rewrite steps. The second rule of Coocs is treated in a similar way. The only successful reduction of its left-hand side is: {CR(c,m), CA(re, c), C(c), CS,(m)} -~cls {CSI(m)}. Thus $2 = {({CSl(m)}, CSl(m))} and we obviously have {CSl(m)} -~cs {CSl(Tr~)} •</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The complete client-server application</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Semantics of the language of entities and coordination</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FFigure 3 :</head><label>3</label><figDesc>Figure 3: The hospital ward application</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was partly supported by Esprit Basic Research project 9102 Coordination. Some of the inspiration for this paper emerged from previous work on Structured Gamma in collaboration with Pascal Fradet <ref type="bibr" target="#b9">[10]</ref>. Jean-Pierre Ban£tre, Alexandra Holzbacher and Val~rie Issarny provided valuable feedback on an earlier version of this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Using style to understand descriptions of software architecture</title>
		<author>
			<persName><forename type="first">G</forename><surname>Abowd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Sigsoft&apos;93: Foundations of Software Engineering</title>
		<meeting>Sigsoft&apos;93: Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="1993-12">December 1993</date>
			<biblScope unit="volume">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Formalizing architectural connection</title>
		<author>
			<persName><forename type="first">R</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Int. Conf. Software Engineering</title>
		<meeting>16th Int. Conf. Software Engineering</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="71" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Programming by multiset transformation</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Ban~tre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Le</forename><surname>M~tayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="98" to="111" />
			<date type="published" when="1993-01">January 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Ban£tre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Le</forename><surname>M~tayer</surname></persName>
		</author>
		<title level="m">Gamma and the chemical reaction model: ten years after, Coordination programming: mechanisms, models and semantics</title>
		<imprint>
			<publisher>Imperial College Press</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The chemical abstract machine</title>
		<author>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="217" to="248" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Carriero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
		<title level="m">Linda in context, Communications of the ACM</title>
		<imprint>
			<date type="published" when="1989-04">April 1989</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="444" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Graph rewriting: an algebraic and logic approach, Handbook of Theoretical Computer Science, Chapter 5</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
		<editor>J. van Leeuwen</editor>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Elsevier Science Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A model for distributed systems based on graph rewritings</title>
		<author>
			<persName><forename type="first">P</forename><surname>Degano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="411" to="449" />
			<date type="published" when="1987-04">April 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Context-free graph grammars</title>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Della</forename><surname>Vigna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ghezzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="207" to="233" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">P</forename><surname>Fradet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Le</forename><surname>M~tayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Structured</forename><surname>Gamma</surname></persName>
		</author>
		<idno>PI-989</idno>
		<imprint>
			<date type="published" when="1996-03">March 1996</date>
		</imprint>
	</monogr>
	<note type="report_type">Irisa Research Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Exploiting style in architectural design anvironment</title>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ockerbloom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Sigsoft&apos;94, Foundations of Software Engineering</title>
		<meeting>Sigsoft&apos;94, Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="175" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Editor&apos;s Introduction</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering, Special Issue on Software Architectures</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Perry</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Communicating sequential processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="666" to="677" />
			<date type="published" when="1978-08">August 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A software environment for concurrent coordinated programming</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Holzbacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First int. Conf. on Coordination Models, Languages and Applications</title>
		<title level="s">LNCS</title>
		<meeting>First int. Conf. on Coordination Models, Languages and Applications</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1996-04">April 1996</date>
			<biblScope unit="volume">1061</biblScope>
			<biblScope unit="page" from="249" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Coordination of distributed and parallel programs in Concoord, Coordination programming: mechanisms, models and semantics</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Holzbacher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Imperial College Press</publisher>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Formal specification and analysis of software architectures using the chemical abstract machine model</title>
		<author>
			<persName><forename type="first">P</forename><surname>Inverardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="373" to="386" />
			<date type="published" when="1995-04">April 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">SAAM: A method for analysing the properties of software architectures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Abowd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Webb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Int. Conf. Software Engineering</title>
		<meeting>16th Int. Conf. Software Engineering</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Configuration programming. A framework for the development of distributable systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. COMPEURO&apos;90</title>
		<meeting>COMPEURO&apos;90</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="374" to="384" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Formal models of computer security</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Landwehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="247" to="277" />
			<date type="published" when="1981-09">September 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Specification and analysis of system architecture using Rapide</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Luckham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Kenney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Augustin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Mann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="336" to="355" />
			<date type="published" when="1995-04">April 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Modelling distributed software architectures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Magee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<idno>CMU-CS-95-151</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. First int. workshop on Architectures for Software Systems, CMU Technical Report</title>
		<meeting>First int. workshop on Architectures for Software Systems, CMU Technical Report</meeting>
		<imprint>
			<date type="published" when="1995-04">April 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Mercouroff</surname></persName>
		</author>
		<idno>24] [25] [26] [27] [28] [29</idno>
		<title level="m">An algorithm for analysing communicating processes, 7th int. Conf. on Mathematical Foundations of Programming Semantics</title>
		<imprint>
			<date type="published" when="1991-03">March 1991</date>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="312" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A calculus of mobile processes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Information and Computation</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="1" to="77" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Correct architecture refinement</title>
		<author>
			<persName><forename type="first">M</forename><surname>Moriconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Riemenschneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="356" to="372" />
			<date type="published" when="1995-04">April 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Higher-order concurrent programs with finite communication topology</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st ACM Symp. on Principles of Programming Languages</title>
		<meeting>21st ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1994-01">January 1994</date>
			<biblScope unit="page" from="84" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Regular types for active objects</title>
		<author>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA&apos;93</title>
		<meeting>OOPSLA&apos;93</meeting>
		<imprint>
			<date type="published" when="1993-10">October 1993</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Foundations for the study of software architecture</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigsoft, Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="40" to="52" />
			<date type="published" when="1992-10">October 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Set-theoretic graph rewriting</title>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Raoult</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Voisin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. int. Workshop on Graph Transformations in Computer Science</title>
		<title level="s">LNCS</title>
		<meeting>int. Workshop on Graph Transformations in Computer Science</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">776</biblScope>
			<biblScope unit="page" from="312" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Formulations and formalisms in software architecture</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science Today, Recent Trends and Developments</title>
		<imprint>
			<biblScope unit="volume">1000</biblScope>
			<biblScope unit="page" from="307" to="323" />
			<date type="published" when="1995">1995</date>
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Abstractions for software architecture and tools to support them</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">V</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zelesnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="314" to="335" />
			<date type="published" when="1995-04">April 1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
