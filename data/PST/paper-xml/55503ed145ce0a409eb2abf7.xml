<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Robust Authenticated-Encryption AEZ and the Problem That It Solves</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Viet</forename><forename type="middle">Tung</forename><surname>Hoang</surname></persName>
							<email>tvhoang@umd.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<settlement>College Park</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Georgetown University</orgName>
								<address>
									<settlement>Washington</settlement>
									<region>DC</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ted</forename><surname>Krovetz</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">California State University</orgName>
								<address>
									<settlement>Sacramento</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Phillip</forename><surname>Rogaway</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Robust Authenticated-Encryption AEZ and the Problem That It Solves</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8BB62D212673835FBC3788D19CACC4B7</idno>
					<idno type="DOI">10.1007/978-3-662-46800-5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>AEZ</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>With a scheme for robust authenticated-encryption a user can select an arbitrary value λ ≥ 0 and then encrypt a plaintext of any length into a ciphertext that's λ characters longer. The scheme must provide all the privacy and authenticity possible for the requested λ. We formalize and investigate this idea, and construct a well-optimized solution, AEZ, from the AES round function. Our scheme encrypts strings at almost the same rate as OCB-AES or CTR-AES (on Haswell, AEZ has a peak speed of about 0.7 cpb). To accomplish this we employ an approach we call prove-then-prune: prove security and then instantiate with a scaled-down primitive (e.g., reducing rounds for blockcipher calls).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>We expose the low cost and high benefit of building authenticated-encryption (AE) schemes that achieve the unprecedentedly strong goal we call robust AE (henceforth RAE). We explain why RAE is desirable, define its syntax and security, and explore its guarantees. Then we construct an RAE scheme, AEZ, from AES4 and AES10 (four-and ten-round AES). AEZ's efficiency-nearly that of AES-based OCB <ref type="bibr" target="#b32">[32]</ref> or CTR mode-flies in the face of a community's collective work <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b22">[22]</ref><ref type="bibr" target="#b23">[23]</ref><ref type="bibr" target="#b24">[24]</ref><ref type="bibr" target="#b25">[25]</ref><ref type="bibr" target="#b35">35,</ref><ref type="bibr" target="#b38">[38]</ref><ref type="bibr" target="#b39">[39]</ref><ref type="bibr" target="#b40">[40]</ref><ref type="bibr" target="#b53">[52]</ref><ref type="bibr" target="#b54">[53]</ref><ref type="bibr" target="#b55">[54]</ref><ref type="bibr" target="#b61">60]</ref> in which wide-block enciphering schemes-a special case of RAE-were always far more expensive than conventional blockciphers. Achieving this efficiency has entailed using a design paradigm, the prove-then-prune approach, with implications beyond AE.</p><p>Ciphertext expansion. One can motivate RAE from a syntactic point of view. Recall that in a nonce-based AE scheme, a plaintext M is mapped to a ciphertext C = E N,A K (M ) under the control of a key K, nonce N , and associated data (AD) A. Typically the ciphertext expansion (or stretch) λ = |C| -|M | is a constant or user-selectable parameter. For conventional AE, the stretch mustn't be too small, as customary definitions would break: a trivial adversary can get large advantage. This is because AE definitions "give up" when the first forgery occurs. The issue isn't only definitional: no prior AE scheme provides a desirable security guarantee when the ciphertext expansion is small.</p><p>Still, we know that meaningful security is possible even for zero-stretch: a strong pseudorandom permutation buys significant security, even from an AE point of view <ref type="bibr" target="#b4">[5]</ref>. What is more, it would seem to be useful to allow small stretch, as, for example, short tags can save significant energy in resource-constrained environments (as discussed, e.g., by Struik <ref type="bibr" target="#b59">[58]</ref>).</p><p>RAE takes a liberal approach towards ciphertext expansion, accommodating whatever stretch a user requests. This leads to schemes that deliver more than conventional AE even when the stretch is not small. Indeed we could have motivated RAE without considering small-λ, describing a desire to achieve noncereuse misuse-resistance <ref type="bibr" target="#b51">[51]</ref>, to automatically exploit novelty or redundancy in plaintexts <ref type="bibr" target="#b4">[5]</ref>, or to accommodate the release of unverified plaintexts <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b20">21]</ref>. But our ideas are most easily understood by asking what it means, and what it takes, to do well for any stretch.</p><p>Defining RAE. So consider an AE scheme that expands a plaintext M ∈ {0, 1} * by a user-selectable number of bits<ref type="foot" target="#foot_0">1</ref> τ ≥ 0. We ask: what's the best privacy and authenticity guarantee possible for some arbitrary, specified τ ? Robust AE formalizes an answer.</p><p>Recall the definition of a pseudorandom-injection (PRI) <ref type="bibr" target="#b51">[51]</ref>: for each nonce N and associated data A, for a fixed τ ≥ 0, the scheme's encryption algorithm should resemble a uniformly chosen injective function π N,A,τ from binary strings to τ -bit longer ones. Decryption of an invalid ciphertext (one lacking a preimage under π) should return an indication of invalidity.</p><p>PRIs were introduced as an alternative characterization of nonce-reuse misuseresistant AE (henceforth MRAE). But PRIs only approximate MRAE schemes with large stretch. We recast the PRI notion as prescriptive: the user selects τ ≥ 0 and then the scheme must look like a PRI for the chosen value. This is our basic definition for RAE.</p><p>RAE can be thought of as a bridge connecting blockciphers and AE. When τ = 0 an RAE scheme is a kind of blockcipher-a tweakable blockcipher (TBC) <ref type="bibr" target="#b34">[34]</ref> that operates on messages and tweaks of arbitrary length and is secure as strong pseudorandom permutation (PRP). The nonce and AD comprise the tweak. When τ 128 an RAE scheme amounts to an MRAE scheme. An RAE scheme encompasses both objects, and everything in between.</p><p>In defining RAE we are actually a bit more generous than what was sketched above, allowing an RAE's decryption algorithm to return information about an invalid ciphertext beyond a single-valued indication of invalidity. The information just needs to be harmless. To formalize this the reference experiment uses a simulator S to provide responses to invalid decryption queries. It must do this without benefit of the family of random injections.</p><p>Enciphering-Based AE. We can achieve RAE with enciphering-based AE. The idea, rooted in folklore, was formalized by Bellare and Rogaway <ref type="bibr" target="#b4">[5]</ref> and, in a different form, by Shrimpton and Terashima <ref type="bibr" target="#b57">[56]</ref>. In its modern incarnation, enciphering-based AE works like this:</p><p>Take the message you want to encrypt, augment it with τ bits of redundancy, and then encipher the resulting string by applying an arbitrary-input-length tweakable blockcipher. Tweak this using the nonce, AD, and an encoding of τ . On decryption, check for the presence of the anticipated redundancy and reject a ciphertext if it is not there.</p><p>We will prove that this method achieves RAE. In fact, we'll prove that this is so even if the decryption algorithm releases candidate plaintexts with incorrect redundancy.</p><p>AEZ. We construct a highly optimized RAE scheme, AEZ. We use the same name to refer to the arbitrary-input-length tweakable blockcipher from which it's built. <ref type="foot" target="#foot_1">2</ref> With the increasing ubiquity of hardware AES support, we choose to base AEZ on the AES round function.</p><p>How AEZ works depends on the length of the input; see Fig. <ref type="figure" target="#fig_5">1</ref>. To encipher a plaintext of fewer than 32 bytes we use AEZ-tiny, a balanced-Feistel scheme with a round function based on AES4, a four-round version of AES. The construction builds on FFX <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b16">17]</ref>. The more interesting case, AEZ-core, is used to encipher strings of 32 bytes or more. It builds on EME <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b24">24]</ref> and OTR <ref type="bibr" target="#b36">[36]</ref>. Look ahead to the top-left panel of Fig. <ref type="figure" target="#fig_4">7</ref>. There are two enciphering layers, with consecutive pairs of blocks processed together using a two-round Feistel network. The round function for this is again based on AES4. The mask injected as the middle layer is determined, for each pair of consecutive blocks, using another AES4 call.</p><p>Performance. AEZ-core is remarkably fast; as the description above implies, we need about five AES4 calls to encipher each consecutive pair of blocks, so ten AES rounds per block. Thus our performance approaches that of CTR-AES. An implementation of AEZ on Haswell using AES-NI has a peak speed of 0.72 cpbabout the same as OCB <ref type="bibr" target="#b32">[32]</ref>. Look ahead to Fig. <ref type="figure">8</ref>. Additionally, invalid strings can be rejected, and AD processed, in about 0.4 AES-equivalents per block, or 0.29 cpb peak (again on Haswell). Only the forward direction of AES is used, saving chip area in hardware realizations. The context size, about 128 bytes, is small, and key setup, about 1.2 AES-equivalents for a 128-bit key, is fast.</p><p>For a two-pass mode achieving MRAE, the cluster of performance characteristics described is unexpected. Part of the explanation as to how this is possible lies in the use of a design approach that benefits from both classical and provable-security design. Let us explain.</p><formula xml:id="formula_0">N, A, τ C 0•••0 M τ AEZ-core AEZ AEZ-tiny Tweak T T</formula><p>Fig. <ref type="figure" target="#fig_5">1</ref>. High-level structure of AEZ. After appending to the message a block of τ zero bits we encipher it using a tweak T comprising the nonce N , associated data A, and stretch τ . Enciphering depends on the length of the plaintext: usually we use AEZ-core, but strings shorter than 32 bytes are enciphered by AEZ-tiny. Both depend on the underlying key K, which is not shown in the diagram above.</p><p>Prove-then-prune design. We designed AEZ using an approach we call prove-then-prune. It works like this:</p><p>To achieve some complex cryptographic goal, design a scheme in the provablesecurity tradition, choosing an underlying primitive and demonstrably achieving the goal when it's instantiated by an object achieving some standard assumption. Then, to improve speed, selectively instantiate some of the applications of the primitive using a scaled-down (e.g., reduced-round) construction.</p><p>Use heuristic or cryptanalytic reasons to support the expectation that, despite scaling down, the scheme remains secure.</p><p>Specifically, AEZ is designed in terms of a tweakable blockcipher (TBC). If this TBC had been instantiated in the "usual" way, say using AES and the XE construction <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b49">49]</ref>, we would have a provably-sound design on message space {0, 1} ≥128 . The cost would be about 2.5 times the cost of AES. But to speed things up, we instantiate most TBC calls with an AES4-based construction. Heuristics reasons to suggest that security nonetheless remains. Our design was specifically chosen so as to make a scaled-down instantiation plausible. The thesis underlying prove-then-prune approach is that it can be instrumental for devising highly efficient schemes for complex aims. We believe that if the instantiation is done judiciously, then the scaled-down scheme retains some assurance benefit. Still, it is important to emphasize the limitations of prove-then-prune. Naming an approach is not license to abuse it. The method is dangerous in the same sort of way that designing a confusion/diffusion primitive is: one has no guarantees for the object that will actually be used. Additionally, the set of people with provable-security competence is nearly disjoint from those with cryptanalytic competence. The authors think it essential that cryptanalysts study AEZ. This is all the more true because pruning was aggressive.</p><p>In some way, prove-then-prune is implicit in prior work: schemes like ALRED <ref type="bibr" target="#b14">[15]</ref> typify a trend in which reduced-round AES in used in contexts where full AES would demonstrably do the job. RAE benefits. What do we hope to gain with RAE? Our definition and scheme are meant to achieve all of the following: (1) If (M, A) tuples are known a priori not to repeat, no nonce is needed to ensure semantic security. (2) If there's redundancy in plaintexts whose presence is verified on decryption, this augments authenticity. (3) Any authenticator-length can be selected, achieving best-possible authenticity for this amount of stretch. (4) Because of the last two properties, one can minimize length-expansion in many bandwidthconstrained applications. ( <ref type="formula">5</ref>) If what's supposed to be a nonce should accidentally get repeated, the privacy loss is limited to revealing repetitions in (N, A, M ) tuples, while authenticity is not damaged at all. (6) If a decrypting party leaks some or all of a putative plaintext that was supposed to be squelched because of an authenticity-check failure, this won't compromise privacy or authenticity.</p><p>The authors believe that the properties enumerated would sometimes be worth a considerable computational price. Yet the overhead we pay is low: AEZ is almost as fast as OCB.</p><p>Discussion. AEZ's name is meant to simultaneously suggest AE, AES, and EZ (easy), the last in the sense of ease of correct use. But the simplicity is for the user; we would not claim that the AEZ algorithm is simple.</p><p>Since McOE and COPA <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b19">20]</ref>, some recent AE schemes have been advertised as nonce-reuse misuse-resistant despite being online. <ref type="foot" target="#foot_2">3</ref> But online schemes are never misuse-resistant in the sense originally defined <ref type="bibr" target="#b51">[51]</ref>. <ref type="foot" target="#foot_3">4</ref> They never support automatic exploitation of novelty or verified redundancy <ref type="bibr" target="#b4">[5]</ref> and are always vulnerable to a simple message-recovery attack <ref type="bibr" target="#b47">[47]</ref>. We disagree with the presumption that two-pass AE schemes are routinely problematic; in fact, our work suggests that, on capable platforms, there isn't even a performance penalty. Finally, short messages routinely dominate networking applications, and we know of no application setting where it's important to limit latency to just a few bytes, the implicit expectation for proposed online schemes.</p><p>This paper upends some well-entrenched assumptions. Before, AE-quality was always measured with respect to an aspirational goal; now we're suggesting to employ an achievable one. Before, substantial ciphertext expansion was seen as necessary for any good AE; now we're allowing an arbitrary, user-supplied input. Before, AE schemes and blockciphers were considered fundamentally different species of primitives; now we're saying that, once the definitions are strengthened, they're pretty much the same thing. Before, one could either give a provable-security design or one that follows a more heuristic tradition; now we're doing the one and yet still finding need for the other.</p><p>AEZ is one of 57 CAESAR submissions <ref type="bibr" target="#b6">[7]</ref>. It's distinguished by being the notionally strongest submission. We expect it to help clarify the potential cost and benefit of two-pass AE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Prior AE Definitions</head><p>Fix an alphabet Σ. Typically Σ is {0, 1} or {0, 1} 8 , but other values, like Σ = {0, 1, . . . , 9}, are fine. For x ∈ Σ * let |x| denote its length. We write ε for the empty string and x X for uniformly sampling from a distribution X. If X is a finite set, it has the uniform distribution.</p><p>Syntax. We formalize a nonce-based AE scheme as a triple Π = (K, E, D). The key space K is a set of strings with an associated distribution. The encryption algorithm E is deterministic and maps a four-tuple (K, N, A, M ) ∈ (Σ * ) 4 to a value C = E N,A K (M ) that is either a string in Σ * or the distinguished symbol ⊥. Later we will allow AD to be a vector of strings, A ∈ (Σ * ) * . The distinction is insignificant insofar as we can always encode a vector of strings as a string. We require the existence of sets N, A and M (the nonce space, AD space, and message space) such that E</p><formula xml:id="formula_1">N,A K (M ) = ⊥ iff (K, N, A, M ) ∈ K × N × A × M.</formula><p>The decryption algorithm D is deterministic and takes a four-tuple (K, N, A, C) to a value D N,A K (C) ∈ Σ * ∪ {⊥}. The length of a string-valued C = E N,A K (M ) is not allowed to depend on anything beyond |N |, |A| and |M |. In fact, usually λ = |C| -|M | is a constant, in which case we call the scheme λ-expanding and refer to λ as the ciphertext expansion or stretch. We require that if</p><formula xml:id="formula_2">C = E N,A K (M ) is a string then D N,A K (C) = M . Algorithm D rejects ciphertext C if D N,A K (C) = ⊥ and accepts it otherwise.</formula><p>AE and MRAE security. Both conventional-AE and MRAE security can be defined using a compact, all-in-one formulation <ref type="bibr" target="#b51">[51]</ref>. Let Π = (K, E, D) be an AE-scheme. Consider an adversary A with access to an encryption oracle Enc and a decryption oracle Dec. We define the MRAE security of A as Adv mrae</p><formula xml:id="formula_3">Π (A) = Pr[A Real Π ⇒ 1] -Pr[A Ideal Π ⇒ 1]</formula><p>, the difference in the probability that A outputs 1 when run in the Real and Ideal games of Fig. <ref type="figure" target="#fig_0">2</ref>. Both begin by selecting K K. Game Real answers encryption queries (N, A, M ) with E N,A K (M ) and decryption queries (N, A, C) with D N,A K (C). Game Ideal answers Dec(N, A, C) queries with ⊥ and Enc(N, A, M ) queries with |C| uniformly chosen characters, where C ← E N,A K (M ). For games Real and Ideal, adversaries may not repeat an Enc or Dec query, ask an Enc query (N, A, M ) ∈ N×A×M, ask a Dec query (N, A, C) ∈ N × A × Σ * , or ask a Dec query (N, A, C) after an Enc query of (N, A, M ) returned C.</p><p>The above definition captures MRAE security because repeated nonces were allowed and were properly serviced. For the conventional AE notion, Adv ae Π (A), modify Real and Ideal by having an Enc(N, A, M ) query following an earlier Enc(N, A , M ) query return ⊥. This has the same effect as prohibiting repeated N -values to the Enc oracle. PRI security. We define security in the sense of a pseudorandom-injection (PRI) <ref type="bibr" target="#b51">[51]</ref>. Fix a λ-expanding AE scheme Π = (K, E, D); for now, λ is a constant associated to a (well-behaved) AE scheme. Let Adv pri</p><formula xml:id="formula_4">Π (A) = Pr[A RealΠ ⇒ 1] - Pr[A PRI Π ⇒ 1]</formula><p>with the oracles again defined in Fig. <ref type="figure" target="#fig_0">2</ref>. There Inj(λ) denotes the set of all one-to-one functions from Σ * to Σ * that increase the length of their inputs by λ characters. The same query restrictions apply as before.</p><formula xml:id="formula_5">initialize IdealΠ K K oracle Enc(N, A, M ) C ← EK (N, A, M ) C Σ |C | return C oracle Dec(N, A, C) return ⊥ initialize RealΠ K K oracle Enc(N, A, M ) return EK (N, A, M ) oracle Dec(N, A, C) return DK (N, A, C) initialize PRIΠ for (N, A) ∈ N × A do πN,A Inj(λ) oracle Enc(N, A, M ) return πN,A(M ) oracle Dec(N, A, C) if ∃M ∈ M s.t. πN,A(M ) = C then return M return ⊥ initialize REALΠ K K oracle Enc(N, A, λ, M ) return EK (N, A, λ, M ) oracle Dec(N, A, λ, C) return DK (N, A, λ, C) initialize RAEΠ and RAEΠ,S for (N, A, λ) ∈ Σ * ×Σ * ×N do π N,A,λ Inj(λ) θ ← ε oracle Enc(N, A, λ, M ) return π N,A,λ (M ) oracle Dec(N, A, λ, C) if ∃M ∈ M s.t. π N,A,λ (M ) = C then return M M ← ⊥ ←-for RAEΠ (M, θ) ← S(N, A, λ, C, θ) ←-for RAEΠ,S return M</formula><p>Besides defining PRI security, Rogaway and Shrimpton showed that, for large ciphertext expansion λ, the notion essentially coincides with MRAE security <ref type="bibr" target="#b51">[51]</ref>. Below we clarify the role of the ciphertext expansion by giving a sharper extended version of their result. To state our bound, define the misuse count as follows. Initially, set r = 0. Then, for each encryption query Enc(N, A, M ), if there was a prior query (N, A, M ) such that |M | = |M |, increment r by 1. The final value of r is the misuse count. Below we show that good PRI security implies good MRAE security as long as q is small compared to |Σ| λ and r is small compared to |Σ| (λ+mmin)/2 (with all variables defined below). The proof is in Appendix B.1.</p><formula xml:id="formula_6">Theorem 1. |Adv pri Π (A) -Adv mrae Π (A)| ≤ 2q/|Σ| λ + (r 2 + r)/|Σ| λ+mmin+1</formula><p>for any λ-expanding AE scheme Π and adversary A, where r is the misuse count of A's queries, q is the number of queries it asks, and m min is the length of the shortest string in the message space.</p><p>In short, the PRI definition captures best-possible security of a λ-expanding AE scheme, while the MRAE formulation captures an unreachable ideal. The gap between the realizable and the ideal is formalized by Theorem 1. It is small if the ciphertext expansion is large, and it is large if the ciphertext expansion is small. The latter is so because any actual encryption algorithm must map distinct (N, A, M ) and (N, A, M ) to distinct ciphertexts, whence real encryption can't return uniformly random characters. Similarly, for any infinite message space, some unqueried ciphertexts must be valid, whence a decryption oracle that always returns an indication of invalidity is hoping for too much. Building on the PRI notion, we will now look towards an even more precise way to capture best-possible AE security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RAE Security</head><p>Syntax. The principle difference between a PRI and an RAE scheme is that, for the latter, the ciphertext expansion λ is no longer a property of a scheme: it's an arbitrary input from the user. All values λ ∈ N should be allowed. <ref type="foot" target="#foot_4">5</ref> Corresponding to this change, we'll write E N,A,λ K (M ) and D N,A,λ K (C). The difference may look small, but its consequences are not.</p><p>Fix an alphabet Σ. Our formal definition again has an RAE scheme being a triple Π = (K, E, D), but with the signature of E and D updated. The encryption algorithm E is deterministic and maps a five-tuple (K,</p><formula xml:id="formula_7">N, A, λ, M ) ∈ (Σ * ) 3 × N × Σ * to a string C = E N,A,λ K (M ) of length |M | + λ.</formula><p>For maximal utility when realized, we are not permitting a return value of ⊥: an RAE scheme must be able to encrypt any M using any N , A, and λ. The decryption algorithm D is deterministic and takes a five-tuple</p><formula xml:id="formula_8">(K, N, A, λ, C) to a value D N,A,λ K (C) ∈ Σ * ∪ {⊥}. We require that D N,A,λ K (E N,A,λ K (M )) = M for all K, N, A, λ, M . If there's no M such that C = E N,A,λ K (M ) then D N,A,λ K (C) = ⊥.</formula><p>Later in this section we will relax this requirement as a way to model the possibility of decryption algorithms that reveal information beyond an indication of invalidity. RAE security. Let Π = (K, E, D) be an RAE scheme over alphabet Σ. Its security is defined using the games REAL Π and RAE Π at the bottom of Fig. <ref type="figure" target="#fig_0">2</ref>. (For the moment, ignore RAE Π,S .) The adversary A has two oracles, an encryption oracle Enc and a decryption oracle Dec. For game REAL, these are realized by the actual encryption and decryption algorithms, which now take in the argument λ. For game RAE Π we behave according to the family of random injections π N,A,λ chosen at the beginning of the game, responding to each encryption query (N, A, λ, M ) with C = π N,A,λ (M ) and responding to each decryption query (N, A, λ, C) with π -1 N,A,λ (C), if that inverse exists, and ⊥ if it does not. We let Adv rae</p><formula xml:id="formula_9">Π (A) = Pr[A REALΠ ⇒ 1] -Pr[A RAEΠ ⇒ 1]</formula><p>. There are no restrictions on the kinds of queries the adversary may make.</p><p>To gain some appreciation for the RAE definition, consider an adversary that asks to encrypt a message M using a single byte of stretch. Such a scheme would not be considered secure in the MRAE setting, as forging with probability 1/256 is easy. But under the RAE viewpoint, that isn't a defect per se, as the user who requests one-byte expansion would expect 1/256 of all ciphertexts to have some preimage. If a user should try to decrypt such a ciphertext C using the same K, N, A but λ = 0, a plaintext will emerge, never an indication of invalidity, but that plaintext should be unrelated to the originally encrypted one.</p><p>Decryption-call leakage. An AE scheme will fail to approximate the RAE Π abstraction if its decryption algorithm, when presented an invalid ciphertext, routinely returns anything beyond an indication of invalidity. We now explain how to relax this expectation so that it's OK to return additional material as long as it is known to be useless.</p><p>We said earlier that, for an RAE scheme Π = (K, E, D) and any</p><formula xml:id="formula_10">N, A, λ, C, if there's no M such that C = E N,A,λ K (M ) then we expect D N,A,λ K (C) to return ⊥.</formula><p>Let us relax this requirement so that D N,A,λ K (C) may instead return a string, as long as its length is not |C|λ. Any such string is trivially recognized as invalid, so, in effect, we are having D return both ⊥ and an arbitrary piece of side information Y . We are not suggesting that the "real" decryption algorithm should return anything other than ⊥ when presented an invalid ciphertext; instead, we are effectively overloading D by folding into it a "leakage function" that captures that which a decryption algorithm's realization may leak about a presented ciphertext.</p><p>Using this generalized syntax, we define a game RAE Π,S parameterized by a probabilistic algorithm S, the simulator. Again see Fig. <ref type="figure" target="#fig_0">2</ref>. Simulator S is called upon to produce imitation ciphertexts when there's no preimage under π N,A,λ . To accomplish this task S is provided nothing beyond the current oracle query and any saved state θ it wants to maintain. An RAE scheme is judged secure if there's a simulator S-preferably an efficient one-such that (E, D) is indistinguishable from the pair of oracles defined in RAE Π,S . We refine the RAE advantage by asserting that Adv rae Π,S (A) = Pr[A REALΠ ⇒ 1] -Pr[A RAEΠ,S ⇒ 1]. The "basic" RAE definition corresponds to the case where simulator S ignores its input and returns (⊥, ε).</p><p>The RAE definition effectively captures that, while it may be "nice" for decryption to reveal nothing but ⊥ on presentation of an invalid ciphertext, there are plenty of other things we could return without damaging privacy or authenticity. In fact, it really doesn't matter what is returned just so long as it's recognizably invalid and doesn't depend on the key.</p><p>Illustration. Fig. <ref type="figure">3</ref> illustrates two possibilities for how an RAE scheme might encrypt 2-bit strings with 2-bit ciphertext expansion (λ = 2). The key K, nonce N , and AD A are all fixed. For encryption, the four possible plaintexts are bijectively paired with four of the 16 possible ciphertexts. For decryption we show two possibilities. On the left is a conventional decryption algorithm: the 12 ciphertexts without a preimage decrypt to an indication of invalidity. One expects the simulator to always return (⊥, ε). On the right is a sloppy decryption algorithm. The 12 ciphertexts with no preimage decrypt to 12 distinct strings, all recognizably invalid, all of the form abcd ∈ {0, 1} 4 with cd = 00. Here the simulator S might sample without replacement from the named set of size 12. Discussion. The reader may have noticed that there is no distinction in the RAE security definition between the nonce N and associated data (AD) A.</p><p>For this reason, either could be dropped-say the nonce-leaving us a signature E A,λ K (M ) and D A,λ K (C). There's an especially good argument for doing this when the AD A is vector-valued: the user is already free to use one of its components as a nonce. Still, for greater uniformity in treatment across AE notions, and to encourage users to provide a nonce, we have retained both N and A.</p><p>We gave our definition of RAE into two stages only for pedagogical purposes: this paper offers only one definition for RAE. The simulator S may be trivial or not; that is the only distinction.</p><p>Andreeva et. al <ref type="bibr" target="#b0">[1]</ref> recently provided several security definitions also meant to capture the requirement that a decryption algorithm releases only harmless information when presented an invalid ciphertext and a repeated nonce. Our own work is radically different from theirs insofar as we provide a single definition, RAE, that rolls into it this, among many, considerations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Verified Redundancy Enhances Authenticity</head><p>If a plaintext contains redundancy, one naively expects that verifying its presence upon decryption should enhance the authenticity guarantee provided. For the case of enciphering-based encryption, which provides no authenticity guarantee on its own, this has been formally supported <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b51">51]</ref>. But even in this case the existing results are with respect to conventional notions of AE, and such notions are too blunt to capture what one expects from verified redundancy. This is because the notions "give up" as soon as a single ciphertext forgery is made.</p><p>Let Π = (K, E, D) be RAE scheme and let v : Σ * → {0, 1} be a function for indicating the "valid" strings: it determines</p><formula xml:id="formula_11">M v ⊆ Σ * by M v = {M ∈ Σ * : v(M ) = 1}. Let Π v = (K, E, D) be the AE scheme built from Π that declares messages invalid if v says so: DN,A,λ K (C) = M if |M | = |C| -λ and v(M ) = 1, or if |M | = |C| -λ, where M = D N,A,λ K (C), while DN,A,λ K (C) = 0 M otherwise, with 0 a canonical point in Σ. Let d v = max ∈N (|M v ∩ Σ |)/|Σ| be the density of M v .</formula><p>Suppose, for example, that Σ = {0, 1} and d v = 1/256: there's a byte worth of redundancy in the message space. We'd like to be able to make statements about the authenticity of Π v such as: the chance that an adversary can forge 10 successive, distinct ciphertexts is negligibly more than 2 -80 . Conventional AE definitions don't let one say such a thing; they stop at the bound q/|Σ| λ where q is the number of queries and λ is the ciphertext expansion (assumed here to be a constant). One would like to obtain a much sharper bound via d v and λ-in our example, the forgery probability should be about about q(d v /|Σ| λ ) 10 . This way, even if, say, λ = 0 and d v = 1/2, we are still able to make strong statements about the security of Π v . Intuitively, for an RAE scheme Π, the scheme Π v should have about (λ min + log(1/d v )) log(|Σ|) bits of authenticity, where λ min is the minimum ciphertext expansion of any query-even after multiple successful forgeries and even in the presence of decryption leakage, future forgeries still remain just as hard.</p><p>To capture the intuition above, in Theorem 2 we show that Π v itself is RAEsecure. The proof is in Appendix B.2. Consequently, in game RAE, for any query (N, A, λ, C) with |C| = + λ to Dec, the chance that this query is a successful forgery is about</p><formula xml:id="formula_12">|M v ∩ Σ |/|Σ| +λ ≤ d v /|Σ| λ ,</formula><p>despite any decryption leakage and past successful forgeries.</p><p>Theorem 2. Let Π and Π v be defined as above. There is an explicitly given reduction R with the following property. For any simulator S and any adversary A, there is a simulator S such that the adversary B = R(A) satisfies Adv rae Π,S (B) = Adv rae Πv,S (A). Adversary B makes the same queries as A and has essentially the same running time.</p><p>Note that for good RAE security, we want the simulator S to be efficient. This is important for privacy, but when the concern is authenticity, it's less of an issue: a computationally-unbounded simulator may give the adversary some information that it can't compute itself, but as long as the adversary can't forge, whatever the adversary learns from the simulator is irrelevant for authenticity. Still, in the proof of Theorem 2, for each query (N, A, λ, C), the simulator S either runs S or samples from Σ ∩ M v , where = |C|λ. For functions v that arise from real-world usage, sampling from Σ ∩ M v is likely to be simple and efficient, whence S will be about as fast as S itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Robust AE from an Arbitrary-Input-Length TBC</head><p>We now show how to make an AE scheme that achieves RAE security. We begin with some basic definitions. Let M ⊆ Σ * and T be sets. A blockcipher</p><formula xml:id="formula_13">E : K × T × M → M is a mapping such that E T K (•) = E(K, T, •) is a length- preserving permutation on M for any K, T . Thus | E T K (X)| = |X| and there's a unique D : K × T × {0, 1} * → M ∪ {⊥} such that E T K (M ) = C implies D T K (C) = M and D T K (C) = ⊥ when there's no M such that E T K (M ) = C.</formula><p>We call T the tweak space of E. When |T| = 1 we make the tweak implicit, writing E : K × M → M, now with inverse D. We define Perm(M) as the set of all length-preserving permutations on M, and Perm(T, M) the set of all mappings π : T × M → M where π(T, •) ∈ Perm(M) for all T ∈ T. We usually use encipher instead of encrypt when speaking of applying a blockcipher, and similarly for decipher and decrypt.</p><p>An arbitrary-input-length blockcipher is a blockcipher with message space M = Σ * . To be maximally useful, we will want a rich tweak space as well. These are versatile objects. A bit less general, a wide-block blockcipher has message space Σ ≥n for some fixed n. Again one prefers a rich tweak space. A conventional blockcipher has message space {0, 1} n for some fixed n.</p><p>The strong, tweakable, PRP advantage of an adversary A attacking a blockcipher E is defined as For any encoding function Encode there's a corresponding Decode : Σ * ×N → Σ * ∪ {⊥} such that Decode λ (X) = M if there's an M satisfying Encode λ (M ) = X, while Decode λ (X) = ⊥ if there's no such M . We expect Encode and Decode to be trivially computable, as in the example.</p><formula xml:id="formula_14">Adv ± prp E (A) = Pr[K K : A EK (•,•), DK (•,•) ⇒ 1] - Pr[ π Perm(T, M) : A π(•,•), π -1 (•,•) ⇒ 1]. We'll write Adv ±prp E (A) = Pr[K K : A EK (•), DK (•) ⇒ 1] -Pr[π Perm(M): A π(•), π -1 (•) ⇒ 1] if</formula><p>From E : K × T × Σ * → Σ * and Encode we define the encode-then-encipher construction as the RAE scheme EtE[Encode, E] = (K, E, D) where</p><formula xml:id="formula_15">E N,A,λ K (M ) = E (N,A,λ) K (Encode λ (M )), D N,A,λ K (C) = M if D (N,A,λ) K (C) = X and M satisfies Encode λ (M ) = X, D N,A,λ K (C) = X if D (N,A,λ) K (C) = X and no M satisfies Encode λ (M ) = X.</formula><p>We stress that decryption does not simply return ⊥ when called on an invalid (N, A, λ, C), as is conventionally done; instead, we define decryption to "leak" the entire improperly encoded string X. Nonetheless, Theorem 3 shows that EtE[Encode, E] is RAE-secure when E is secure as a strong, tweakable PRP. Its proof appears in the full version <ref type="bibr" target="#b28">[28]</ref>.</p><p>Theorem 3 (EtE is RAE-secure). Let Encode and E : K × T × Σ * → Σ * be defined as above. Then there's an explicitly given reduction R and an efficient simulator S with the following property. For any adversary A, the adversary B = R(A) satisfies Adv rae EtE[Encode, E],S (A) ≤ Adv ± prp E (B). It makes at most q queries whose total length is at most that of A's queries plus qλ max , where q is the number of A's queries and λ max is the largest stretch among them. The running time of B is about that of A, plus the time associated to computations of Encode and Decode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Wide-Block Enciphering: AEZ-core</head><p>Let n ≥ 1 be an integer and let {0, 1} ≥2n = {x ∈ {0, 1} * : |x| ≥ 2n}. Define the block length of a string x as |x|/n . We show how to build a strong PRP on {0, 1} ≥2n from a TBC on {0, 1} n . We'll use about 2.5 TBC calls per n-bit block. Later we'll instantiate the TBC using mostly AES4, employing the prove-thenprune paradigm to selectively scale-down. This will reduce the amortized cost to about one AES call per block. Also see the full version <ref type="bibr" target="#b28">[28]</ref> for how to tweak a wide-block blockcipher.</p><p>We begin by recalling the definition of a pseudorandom function (PRF)</p><formula xml:id="formula_16">f : K × M → {0, 1} n . For an adversary A attacking f , its PRF advantage is Adv prf f (A) = Pr[K K : A fK (•) ⇒ 1] -Pr[ρ Func(M, n): A ρ(•) ⇒ 1]</formula><p>where Func(M, n) is the set of all functions from M to {0, 1} n . AEZ-core. Let T = {a, u, uu, v, vv, x, xx, y, yy}∪({a, aa}×N) be the tweak space. Suppose we have a PRF f : K × (T × {0, 1} n ) → {0, 1} n . One can instantiate this with a TBC E on {0, 1} n by setting f K (K, (T, X)) = E T K (X). Consider the wide-block blockcipher AEZ-core[f ] defined and illustrated in Fig. <ref type="figure" target="#fig_3">6</ref>. It loosely follows EME/EME2 <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b29">29]</ref>, but avoids all doubling operations and only uses the forward direction of the underlying TBC. AEZ-core[f ] operates on M = {0, 1} ≥2n and itself takes in no tweak. Theorem 4 shows that it's a strong PRP. The proof is in the full version <ref type="bibr" target="#b28">[28]</ref>. Theorem 4. Let n ≥ 1 be an integer and let T and f be as above. There's an explicitly given reduction R with the following property. For any adversary A,</p><formula xml:id="formula_17">adversary B = R(A) satisfies Adv ±prp AEZ-core[f ] (A) ≤ Adv prf f (B) + 2σ 2 /2 n</formula><p>where σ is the total block length of A's queries. Adversary B uses the same running time as A, and makes at most 2.5σ queries.</p><p>Discussion. AEZ-core and its inverse are almost the same: the only change needed is to take the rightmost column of tweaks in reverse order. Given that one must have some asymmetry in an RAE scheme-an involution is certainly RAE-insecure-this is about as symmetric a design as one could hope for. A high degree of symmetry can help maximize efficiency of both hardware and software. Symmetry is the reason for the wire-crossing just before each C i C i .</p><p>Among the efficiency characteristics of AEZ-core is that one can selectively decrypt a chosen block about 2.5 times more quickly than decrypting everything. The method builds a strong-PRP on {0, 1} ≥2n from an n-bit-output PRF f that operates on its subscript and argument. It's key K is implicit. The PRF can be realized by a TBC.</p><formula xml:id="formula_18">M 1 M 1 C 1 C 1 f a f a,1 X 1 S f x M m M m C m C m f a f a,m X m Y 1 Y m S S ' ' ' ' f a f a f xx f yy f y X Y S f vv f v f v ... X v Y v M x M y C x C y M u C u S f uu f u f u M v C v Y u X u f aa,1 f aa,m f a,1 f a,m 10 algorithm AEZ-core(K, M ) / /AEZ-core 11 M1M 1 • • • MmM m Muv MxMy ← M 12 where |M1| = • • • = |M m | = |Mx| = |My| = n and |Muv| &lt; 2n 13 d ← |Muv|; if d &lt; n then Mu ← Muv; Mv ← ε 14 else Mu ← Muv[1..n]; Mv ← Muv[n + 1..|Muv|] fi 15 for i ← 1 to m do Wi ← Mi ⊕ fa,i(M i ); Xi ← M i ⊕ fa(Wi) od 16 if d = 0 then X ← X1 ⊕ • • • ⊕ Xm ⊕ 0 17 else if d &lt; n then X ← X1 ⊕ • • • ⊕ Xm ⊕ fu(Mu10 * ) 18 else X ← X1 ⊕ • • • ⊕ Xm ⊕ fu(Mu) ⊕ fv(Mv10 * ) fi 19 Sx ← Mx ⊕ X ⊕ fx(My); Sy ← My ⊕ fxx(Sx); S ← Sx ⊕ Sy 20 for i ← 1 to m do 21 S ← faa,i(S); Yi ← Wi ⊕ S ; Zi ← Xi ⊕ S 22 C i ← Yi ⊕ fa(Zi); Ci ← Zi ⊕ fa,i(C i ) od 23 if d = 0 then Cu ← Cv ← ε; Y ← Y1 ⊕ • • • ⊕ Ym ⊕ 0 24 else if d &lt; n then Cu ← Mu ⊕ fuu(S); Cv ← ε; Y ← Y1 ⊕ • • • ⊕ Ym ⊕ fu(Cu10 * ) 25 else Cu ← Mu ⊕ fu(S); Cv ← Mv ⊕ fvv(S) 26 Y ← Y1 ⊕ • • • ⊕ Ym ⊕ fu(Cu) ⊕ fv(Cv10 * ) fi 27 Cy ← Sx ⊕ fyy(Sy); Cx ← Sy ⊕ Y ⊕ fy(Cy) 28 return C1C 1 • • • CmC m CuCv CxCy</formula><p>When AEZ-core is turned into an RAE scheme by the EtE construction, this observation is put to good use in achieving fast rejection of ciphertexts whose final 0 τ bits is plaintext is not correct. That it is undamaging to release this timing information is guaranteed by results already show-in particular, that it is ok to release the entire speculative plaintext.</p><p>AEZ-core confines "specialized" processing to the final 2-4 blocks. This helps with efficiency and simplicity compared to having specialized processing at the beginning or at the beginning and end. In particular, the 0 τ authenticator used to make an RAE scheme will be put at the end of the message (adding a variable number of zero-bits at beginning could destroy word alignment) and, as long as τ ≤ 2n, it will be found in the final two blocks.</p><p>Numerous alternatives to AEZ-core were considered before arriving at our design. Correct alternatives we know are slower or more complex, while most simplifications are wrong. For example, consider trying to cheapen the design by using c i • f aa,1 (S) instead of f aa,i (S) where each c i is a public constant and the product is in GF (2 n ). This fails for any choice of c i . See Appendix C.</p><p>One variant of AEZ-core that does work is to eliminate the "left-hand" xor coming out of f aa,i . (One then has to define X i as the output of f a instead of that output xor'ed with M 1 , and change Y i similarly.) We have kept this xor because it's needed for symmetry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Definition of AEZ</head><p>So far we have described two key elements of AEZ: the EtE construction and the AEZ-core[f ] wide-block blockcipher. Now we give AEZ's complete description. First a bit of notation.</p><p>Notation. The bit length of a string X is written |X|. For the bitwise xor of unequal-length strings, drop the necessary number of rightmost bits from the longer (10 ⊕ 0100 = 11). For X a string, let X0 * = X0 p with p the smallest number such that 128 divides |X| + p. By X * we denote the set of all strings over the alphabet X, including ε. By (X * ) * we denote the set of all vectors over X * , including the empty vector.</p><p>If |X| = n and 1 ≤ i ≤ j ≤ n then X(i) is the ith bit of X (indexing from the left starting at 1), msb(X) = X(1), and X(i..j) = X(i) • • • X(j). Let [n] t be the t-bit string representing n mod 2 t and let [n] be shorthand for [n] 8 ; for example [0] 16 = ([0] 8 ) 16 = 0 128 and [1] 16 = (00000001) 16 . A block is 128 bits</p><formula xml:id="formula_19">. Let 0 = 0 128 . If X = a 1 • • • a 128 is a block (a i ∈ {0, 1}) then we define X 1 = a 2 • • • a 128 0. For n ∈ N and X ∈ {0, 1} 128 define n • X by asserting that 0 • X = 0 and 1 • X = X and 2 • X = (X 1) ⊕ [135 • msb(X)] 128 and 2n • X = 2 • (n • X) and (2n + 1) • X = (2n • X) ⊕ X.</formula><p>For K, X ∈ {0, 1} 128 we write aesenc(X, K) for a single round of AES: SubBytes, ShiftRows, MixColumns, then an AddRoundKey with K.</p><formula xml:id="formula_20">For K = (K 0 , K 1 , K 2 , K 3 , K 4 ) a list of five blocks, let AES4 K (X) = AES4(K, X) be aesenc(aesenc(aesenc(aesenc(X ⊕ K 0 , K 1 ), K 2 ), K 3 ), K 4 ).</formula><p>For K a list of 11 blocks, K = (K 0 , K 1 , . . . , K 10 ), define AES10 K (X) = AES10(K, X) like we defined AES4 but with ten rounds of aesenc. We do not omit the final-round MixColumns.</p><p>AEZ definition. See Figs. <ref type="figure">5</ref> and<ref type="figure" target="#fig_3">6</ref> for the definition of AEZ, and Fig. <ref type="figure" target="#fig_4">7</ref> for an illustration. Most of it is self-explanatory. We briefly explain some of the algorithm's more unusual elements.</p><p>AEZ operates on arbitrary byte strings. Not only is the plaintext M ∈ Byte * arbitrary, but so too the key Key ∈ Byte * and nonce N ∈ Byte * . The AD is even more general: an arbitrary-length vector of byte strings, A ∈ (Byte * ) * . The requested ciphertext expansion of λ ∈ N bytes is measured in τ = 8λ bits. 300 algorithm AEZ-hash(K, T ) /AXU hash. T is a vector of strings 301 (T1, . . . , Tt) ← T <ref type="figure">I,</ref><ref type="figure">L,</ref><ref type="figure">J,</ref><ref type="figure">I,</ref><ref type="figure">L,</ref><ref type="figure">J,</ref><ref type="figure">I,</ref><ref type="figure">L,</ref><ref type="figure">J,</ref><ref type="figure">I</ref>) At line 217, Encipher-AEZ-tiny may xor a bit into the ciphertext just before the algorithm's conclusion. This is done to avoid a simple random-permutation distinguishing attacks, for very short strings, based on the fact that Feistel networks only generate even permutations <ref type="bibr" target="#b30">[30]</ref>. A similar trick, conditionally swapping two fixed points, has been used before <ref type="bibr" target="#b45">[45]</ref>. Our approach has the benefit that the natural implementation is constant-time.</p><formula xml:id="formula_21">302 for i ← 1 to t do 303 m ← max(1, |Ti|/128 ); X1 • • • Xm ← Ti / /|X1| = • • • = |Xm-1| = 128 304 if |Xm| = 128 then Δi ← E 2+i,1 K (X1) ⊕ • • • ⊕ E 2+i,m K (Xm) 305 if |Xm| &lt; 128 then 306 Δi ← E 2+i,1 K (X1) ⊕ • • • ⊕ E 2+i,m-1 K (Xm-1) ⊕ E 2+i,0 K (Xm10 * ) 307 return Δ1 ⊕ • • • ⊕ Δt ⊕ 0 310 algorithm AEZ-prf(K, T, τ ) / /PRF used when M = ε 311 Δ ← AEZ-hash(K, T ) 312 return (E -1,3 K (Δ) E -1,3 K (Δ⊕[1]128) E -1,3 K (Δ⊕[2]128) • • • )[1..τ ] 400 algorithm E i,j K (X) / /Scaled-down TBC 401 I J L ← Extract(K) where |I| = |J| = |L| = 128 402 k0 ← (0, I, J, L, 0); k1 ← (0, J, L, I, 0); k2 ← (0, L, I, J, I) 403 K ← (0,</formula><formula xml:id="formula_22">404 if i = -1 and 0 ≤ j ≤ 7 then return AES10 K (X ⊕ jJ) 405 if i = 0 and 0 ≤ j ≤ 7 then return AES4 k 0 (X ⊕ jJ) 406 if 1 ≤ i ≤ 2 and j ≥ 1 then return AES4 k i (X ⊕ (j mod 8)J ⊕ 2 (j-1)/8 L) 407 if i ≥ 3 and j ≥ 1 then 408 return AES4 k 0 (X ⊕ (j mod 8)J ⊕ 2 (j-1)/8 • L ⊕ (i -2)8J) 409 if i ≥ 3 and j = 0 then return AES4 k 0 (X ⊕ (i -2)8J)</formula><p>We define Decipher(K, T, Y ) as the unique X such that Encipher(K, T, X) = Y . Logically, this is all we need say for the specification to be well-defined. Still, the additional pseudocode is easy to describe. AEZ-tiny deciphering is identical to AEZ-tiny enciphering except we must count backwards instead of forwards, and must do the even-cycles correction (line 217) at the beginning instead of the end. Specifically, Decipher-AEZ-tiny(K, T, M ) is identical to Encipher-AEZ-tiny(K, T, M ) except that line 215 is changed to count from k -1 down to 0, while line 217 has each C replaced by M before moving the line up to just after line 213. And AEZ-core deciphering is identical to AEZ-core enciphering except that we must take the xy-tweaks in reverse order. Specifically, Decipher-AEZ-core(K, T, M ) is identical to Encipher-AEZ-core(K, T, M ) except we swap tweaks (0, 1) and (0, 2), and we swap tweaks (-1, 1) and (-1, 2). These appear at lines 230 and 239.</p><p>The TBC E i,j K (X) takes a tweak (i, j) ∈ {-1, 0}×[0..7] ∪ {1, 2, 3} × N. The first component selects between AES10 (when i = -1) and AES4 (when i ≥ 0). Either way, the construction is based on XE <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b49">49]</ref>. We emphasize that E is not secure as a tweakable-PRP, since AES4 itself is completely insecure as a PRP: it is easily broken by the "Square" attack <ref type="bibr" target="#b13">[14]</ref>. Use of an AES4-based TBC despite this fact is where the scaling-down has been done in AEZ.</p><formula xml:id="formula_23">M v C v M 1 M 1 C C 1 X 1 S M x M y C x C y -1, 1 M m M m C m C m X m Y 1 S S ' ' ' ' T m -1 T 1 T m T 1 L R L R X S -1, 5 0, 5 0, 5 0, 0 0, 0 2, 1 2, m 0, 0 0, 0 0, 1 1, 1 1, m 1, m 1, 1 0, 2 i+2, 1 i+2, m -1 Y ∆ i -1, 2 ∆ ∆ ∆⊕ 1 0,<label>6 0, 6 0, 6 0, 6 0, 6 0, 6 0, 6 0, 6</label></formula><formula xml:id="formula_24">∆ ⊕ 0 ∆⊕ 3 ∆ ⊕ 2 ∆ ⊕ 6 ∆⊕ 5 ∆⊕ 7 X v Y v Y m * * ∆ ⊕ 4 ... 10* ... ... C u -1, 4 0, 4 0, 4 S X u Y u M u ∆ i T m T m -1 i+2, 1 i+2, m -1 i+2, m i+2, 0</formula><p>The key K ∈ Byte * is mapped to three 16-byte subkeys (I, J, L) using the key-derivation function (KDF) named Extract that is called at line 401. The definition of Extract is omitted from the figures and regarded as orthogonal to the rest of AEZ. See the AEZ spec <ref type="bibr" target="#b26">[26]</ref> for the current Extract : Byte * → Byte 48 . In our view, it is an unresolved matter what the security properties (and even what signature) of a good KDF should be. Work has gone off in very different directions <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b63">61]</ref>, and the area is currently the subject of a Password Hashing Competition (PHC) running concurrently with CAESAR.</p><p>Note the mod 8's at lines 406 and 408. Unlike the offset sequence used for OCB <ref type="bibr" target="#b32">[32]</ref>, we limit ourselves to eight successive J values; after that, we add in the next power-of-two times L. This allows a small table of 2 j • J values to be precomputed and used regardless of the length of the message. In this way we limit the frequency of doublings yet avoid number-of-trailing-zeros calculations.</p><p>We impose a limit that AEZ be used for at most 2 48 bytes of data (about 280 TB); by that time, the user should rekey. This usage limit stems from the existence of birthday attacks on AEZ, as well as the use of AES4 to create a universal hash function.</p><p>Cost accounting. Let us summarize the computational cost of AEZ in "AESequivalents," where 1 AES-equivalent is 10 AES rounds. Assume a message of m blocks, the last of which may be fragmentary. To encipher or decipher m ≥ 2 blocks takes at most m + 2.4 AES-equivalents (latency 3.6). This assumes K, N , τ , and A have already been processed. To encrypt or decrypt m ≥ 2 blocks: at most m+3.8 AES-equivalents (latency 3.6). This assumes that K, A, and τ have already been processed and that |N | ≤ 128 and τ = 128. To reject an ciphertext of m ≥ 2 blocks: at most 0.4m + 2.4 AES-equivalents (latency 2.8). Same assumptions. To setup an m block key: 1.2m AES-equivalents (latency 0.4). This assumes that needed constants have been precomputed. To setup a stringvalues AD: 0.4m (latency 0.4). To encipher or decipher messages of 1-15 bytes is somewhat slower: 10, 6.8, and 4.4 AES-equivalents for 1, 2, and 3 bytes.</p><p>Parameterized counterparts. For a TBC-parameterized generalization of AEZ, let AEZ[ E] be identical to AEZ except for using the TBC E : K × T aez × {0, 1} 128 → {0, 1} 128 in place of E (assume the correct tweak-space T aez ). The key space of E is then taken as the key space for the constructed RAE scheme. Note that AEZ = AEZ[E] with E the algorithm defined by lines 400-409.</p><p>Taking the above a step further, given a conventional blockcipher E : K × {0, 1} 128 → {0, 1} 128 we can define AEZ[E] as AEZ <ref type="bibr">[ E]</ref> where E i,j K (X) = E K (X ⊕ (i + 1)I ⊕ jJ) for I = E K (0) and J = E K (1). The scheme AEZ[AES] can be regarded as a natural "scaled up" version of AEZ. We emphasize that AEZ is not AEZ[AES], which is about 2.5 times as slow.</p><p>Schemes AEZ[ E] and AEZ[E] are close to AEZ, but enjoy conventional provable-security guarantees, as we now describe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Security of AEZ[ E] and AEZ[E]</head><p>We show that if E is secure as a tweakable PRP then AEZ[ E] is RAE-secure. In fact, the statement holds even if the decryption algorithm is modified so as to leak the entire improperly encoded string obtained by deciphering an invalid ciphertext. So, for the remainder of this section, assume the modification of AEZ in which the else clause of line 115 returns the deciphered message X rather than ⊥. This change only makes our results stronger, explicitly the possibility of a decryption implementation leaking some or all of X. The actual decryption algorithm returns ⊥.</p><p>Our provable-security results for AEZ need to assume that the adversary avoids enciphering or deciphering extremely short strings-at least those under 16 bytes, say, for which AEZ-tiny, a Feistel-based construction, will not enjoy a desirable bound. While provably-secure options are now available for enciphering very short strings, they still do not have competitive efficiency.</p><p>As the alphabet for AEZ is Σ = Byte, in this this section we write |x| for the byte length of x. For an encryption query (N, A, λ, M ), define the number of blocks processed as An alternative approach to justifying the security of AEZ is to speak of the security of AEZ[E], the cousin of AEZ defined from a conventional blockcipher E using the XE construction to make the needed TBC. Its security can be captured by the following result. The proof is in the full version <ref type="bibr" target="#b28">[28]</ref>. Theorem 6. Let E : K × {0, 1} 128 → {0, 1} 128 be a blockcipher and Π = AEZ <ref type="bibr">[E]</ref>. Then there are efficient, explicitly given algorithms R and S with the following property. Let A be an adversary for attacking Π. Assume it never asks a small or tiny query. Then B = R(A) satisfies Adv rae Π,S (A) ≤ 13s 2 /2 128 + Adv prp E (B), where s is the total number of processed blocks, plus 2 blocks per message. Adversary B makes at most 2.5s queries and has about the same running time as A.</p><p>If one wants to accommodate small queries then we still have a provable, albeit much inferior result. Let Feistel[r, n] denote an ideal r-round Feistel network on {0, 1} 2n . The best known provable bound for Feistel networks <ref type="bibr" target="#b43">[43,</ref><ref type="bibr">Theorem 7]</ref> states that if an adversary makes q ≤ 2 n 128n queries then Adv ±prp Feistel[6,n] (A) ≤ 8q 2 n + q 2 2 2n+1 . Translating this to our setting, one is bound to make at most q ≤ 2 64</p><p>128•64 = 2 51 small queries, and the security advantage is q/2 61 + 4s 2 /2 128 . These restrictions seem to be more of the artifacts of the analysis in <ref type="bibr" target="#b43">[43,</ref><ref type="bibr">Theorem 7]</ref> than reflecting the actual security of Feistel networks: assuming that the round functions of Feistel <ref type="bibr">[6, n]</ref> are instantiated from full AES, the fastest known attack, for n ≥ 64, is still the exhaustive key search on AES.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Estimated Security of AEZ Itself</head><p>Consider enciphering a message M , |M | ≥ 256, by AEZ[AES] (which, recall, is not AEZ, but a scaled-up version using an AES-based TBC). The design would seem excessive: each block M i would be subjected to 30 rounds of AES (ten shared with a neighboring block), not counting the additional AES rounds to produce the highly unpredictable, M -dependent value S, a value derived from which gets injected into the process while 20 rounds yet remain. It is in light of such apparent overkill that AEZ selectively prunes some of the AES calls that AEZ[AES] would perform. In particular, we prune invocations where we aim to achieve computational xor-universal hashing. We leave enough AES rounds so that each block M i is effectively processed with 12 AES rounds, eight of these subsequent to injection of the highly-unpredictable S and four of them shared with a neighboring block. The key steps in calculating S are not pruned, nor are the TBCs used to mask uand v-blocks.</p><p>To estimate the security of AEZ it seems appropriate to replace the s 2 /2 128 term of Theorem 5 by s 2 /2 113 , resulting in the bound 4s 2 /2 113 + t/2 128 , because of the higher maximal expected differential probability of AES4 <ref type="bibr" target="#b31">[31]</ref> compared to an ideal hash or cipher, where t is the time (including the description size) in which the adversary runs.</p><p>Moreover, we contend that the assumption that the adversary avoids asking tiny or small queries can be lifted. To justify this heuristically, consider a collection of independent, ideal, k-round Feistel networks on {0, 1} 2n ; the round functions are all uniformly random and independent. The best attack known, due to Patarin <ref type="bibr" target="#b41">[41]</ref>, that distinguishes them from a family of independent, truly random even permutations requires at least 2 (k-4)n plaintext/ciphertext pairs. From our choice of the number of rounds, this attack needs at least 2 72 plaintext/ciphertext pairs, and thus doesn't violate our up-to-the-birthday-bound security goal.</p><p>AEZ was specifically designed so that scaling-down most of its AES calls would seem safe. This is design-specific; one cannot indiscriminately scale a scheme's primitives. A previous design, where AEZ-core followed the NR approach <ref type="bibr" target="#b39">[39,</ref><ref type="bibr" target="#b40">40]</ref>, could not be as effectively scaled-down.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Software Performance</head><p>The development of AEZ has generally presumed an instruction set architecture (ISA) with round-level support for AES, such as Intel's AES-NI or ARM's version 8 ISA. On these systems the AES unit can be kept busy processing several AES4 computations in parallel while idle processing units handle load, store, and xor overhead. On Intel's Haswell architecture, for example, unrelated AES rounds can issue every cycle and take seven cycles to retire, so seven parallel AES4 calculations can complete in 34 CPU cycles, while idle superscalar processing units can handle other computations. This observation has led us to design AEZ to conveniently process eight blocks at a time. Fig. <ref type="figure">8</ref>. AEZ vs. OCB performance. The x-axis is message length, in bytes, and the y-axis is cycles per byte (cpb). The graph is best viewed in color: solid purple circles are for AEZ; unfilled yellow circles are for OCB3 <ref type="bibr" target="#b32">[32]</ref>. Performance of the two is close, both having peak speeds around 0.7 cpb and being similar on most shorter messages as well. The execution vehicle is an Intel Haswell processor using AES-NI.</p><p>AEZ overhead beyond AES rounds has been minimized. As an example of this, our AES4 key schedule omits the final round key, allowing aesenc's included xor operation to be used for other purposes. Such optimizations lead to AEZ peak speeds, on Haswell, of around 0.72 cpb-not far from the theoretical maximum for the number of rounds executed of 0.63 cpb.</p><p>Fig. <ref type="figure">8</ref> compares the performance of AEZ and OCB on messages of all byte lengths up to 1600 bytes. The two are not only similar for long messages but for short strings too. Only when messages are shorter than 16 bytes, where AEZ-tiny increases the number of AES4 calls used, does OCB become significantly faster.</p><p>The performance of AEZ is on par with OCB even on processors that are not superscalar or do not support AES rounds at the assembly level. On a Marvell 88F6283 embedded CPU-a single-issue, 32-bit, ARM version 5 ISA-we see an experimental version of AEZ peaking at 86 cpb while OCB's optimized reference code runs at 84 cpb. For comparison, GCM, CCM and CTR run at 124, 134 and 67 cpb, respectively. The figures use the OpenSSL libraries.</p><p>One might expect the two-pass nature of AEZ to be a performance burden because data must be dragged into cache from memory twice. We have found that modern processors, like Intel's Haswell, have such efficient hardware prefetching that bringing data into cache twice, in a sequential streaming fashion, is not expensive at all. It requires no explicit prefetching. Encrypting 1MB on Haswell is as efficient as encrypting 32KB despite 1MB exceeding the 256KB level-2 cache. Two passes may have a more significant cost on systems with poor prefetching facilities, although this might be mitigated by software prefetching.</p><p>Another benefit of AEZ's two passes is that the second pass is not needed to discover that a ciphertext is inauthentic, leading to message rejection costing as little as 0.28 cpb on Haswell. On long messages, approximately 2/5 of AES4 calls are performed during the first pass, which aligns perfectly with the peak times we've observed for encryption and fast-rejection.</p><p>All Haswell timings reported in this paper were gathered on a 2.9 GHz Intel Core i5-4570S CPU using its time-stamp counter to gather elapsed CPU cycles over encryption calls. Our implementation is written in C using "intrinsic" functions to access CPU-specific functionality. It was compiled using GCC 4.9 with options -march=native -O3. Our optimized implementation will be made publicly available and freely licensed.</p><p>The other method inspiring further wide-block blockciphers was EME <ref type="bibr" target="#b24">[24]</ref>, which involves two layers of blockcipher-based enciphering and a light layer of mixing in between. A follow-on design, EME2 <ref type="bibr" target="#b22">[22]</ref>, become the other wide-block blockcipher of IEEE 1619.2 <ref type="bibr" target="#b29">[29]</ref>, Both it and XCB are tweakable and operate on a message space of {0, 1} ≥n . EME/EME2 provides the starting point for AEZ-core.</p><p>As for extending blockciphers to short blocks, a different line of work was begun <ref type="bibr" target="#b8">[9]</ref>. Format-preserving encryption aimed to deal not only with small domains but also those defined as arbitrary finite sets, sets of numbers [0..N -1], or strings over arbitrary alphabets. Adapting Feistel designs to arbitrary alphabets, realizations of FFX <ref type="bibr" target="#b5">[6]</ref>, now a draft NIST standard <ref type="bibr" target="#b16">[17]</ref>, would form the basis of AEZ-tiny.</p><p>Meanwhile, notions of AE were appearing. Probabilistic versions came first <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b27">27]</ref>, then a nonce-based version <ref type="bibr" target="#b50">[50]</ref>, then AD finally appeared <ref type="bibr" target="#b49">[49]</ref>. Next the MRAE goal-RAE's closest definition counterpart-was defined <ref type="bibr" target="#b51">[51]</ref>. The main motivation for that work was to minimize the damage that could be done by nonce-reuse.</p><p>Other authors had the same concern but weren't willing to use two-pass schemes. Fleischmann et. al <ref type="bibr" target="#b19">[20]</ref> built on Bellare et. al <ref type="bibr" target="#b2">[3]</ref> to define a security notion for online-AE intended to confer some lower level of nonce-reuse misuseresistance. The approach has gained popularity-many CAESAR submissions follow it, especially after COPA <ref type="bibr" target="#b1">[2]</ref> made clear that one could achieve this weakened flavor of nonce-reuse misuse-resistance with a parallelizable scheme. The RAE definition goes a different direction, strengthening instead of weakening the original MRAE definition.</p><p>Following up on directions from prior work <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21]</ref>, AE security in the face of decryption-algorithm leakage was studied by Andreeva et. al <ref type="bibr" target="#b0">[1]</ref> in work concurrent with our own. A principle motivation for those authors has been to express when it is OK for an online decryption algorithm to be incrementally releasing unverified plaintext. For us, this is a direction not taken, for such leakage can never be generically harmless <ref type="bibr" target="#b47">[47]</ref>. In effect, leaking equality of message prefixes is leaking an enormous amount of information.</p><p>Ferguson made clear early on that AE algorithms could fail badly when tags are too short <ref type="bibr" target="#b17">[18]</ref>. Still, no definitions for AE security were ever offered appropriate to the short-tag setting. But the general concern for making short MACs work well goes back to Black and Cochran <ref type="bibr" target="#b7">[8]</ref> and Wang et. al <ref type="bibr" target="#b60">[59]</ref>. Some examples of using AES4 where AES itself would do include ALRED, LETTERSOUP, MARVIN, and Pelican <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b58">57]</ref>. These inspired our predilection to cut certain AES rounds even when provable security couldn't promise this was fine. The approach should not be confused with that of Minematsu and Tsunoo <ref type="bibr" target="#b37">[37]</ref>, where AES4 provably does suffice for the protocol devised <ref type="bibr" target="#b37">[37]</ref>. The approach leverages the low MEDP for AES4, a line of work culminating in the bound of Keliher and Sui <ref type="bibr" target="#b31">[31]</ref>.</p><p>Many authors have proposed ideas to eliminate use of the inverse-direction of a blockcipher in modes that previously needed this. The method we us in AEZ is inspired by Minematsu's OTR <ref type="bibr" target="#b36">[36]</ref>.</p><p>The CAESAR competition <ref type="bibr" target="#b6">[7]</ref>, organized by Dan Bernstein, was the proximal motivation to define RAE and to try to develop a nice scheme for achieving it. Without loss of generality, assume that q ≤ |Σ| λ-1 ; otherwise the claim is trivial. Consider games G 1 -G 4 in Fig. <ref type="figure">9</ref>. Game G 1 corresponds to game Ideal Π and game G 4 corresponds to game PRI Π . We explain the game chain up to the terminal one. Game G 2 is identical to game G 1 , except that in procedure Enc, it ensures that ciphertexts C are distinct. Partition the encryption queries based on the nonce, the associated data, and the size of the message. Suppose that in game G 1 we have p partitions of size s 1 , . . . , s p ≥ 1. Games G 1 and G 2 are identical-until-bad, and thus </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Deferred Proofs</head><formula xml:id="formula_25">≤ ∈L |Σ| |Σ| +λ -q = ∈L 1 |Σ| λ -(q/|Σ| ) ≤ ∈L 1 |Σ| λ -q ≤ q |Σ| λ -q ≤ 2q |Σ| λ ;</formula><p>C An Insecure Variant of AEZ-core Numerous variants of AEZ-core were considered to arrive at AEZ-core. Most simplifications of the final version do not work. As an example, consider trying to cheapen the design by using c i • f aa,1 (S) instead of f aa,i (S) to whiten the middle of each Feistel network, where each c i is a public constant, and the dot is the multiplication in GF(2 n ). For example, one might hope this works for c i = 1 or c i = i. But this modification is insecure for any choice of c i values.</p><p>For each L ⊆ {1, . . . , n + 1} let θ(L) = ⊕ i∈L c i . Let D = ∅ be a subset of {1, . . . , n + 1} such that θ(D) = 0 n . Such a set D must exists. Assume to the contrary that θ(L) = 0 n for all nonempty L ⊆ {1, . . . , n + 1}. Then for any distinct nonempty subsets L, L ⊆ {1, . . . , n + 1}, we have θ(L) = θ(L ). This means that for 2 n+1 -1 nonempty subsets L ⊆ {1, . . . , n+1} we have 2 n+1 -1 &gt; 2 n corresponding distinct elements θ(L) of GF(2 n ), which is a contradiction.</p><p>We now describe an attack to the modified AEZ-core. Our attack only uses strings of length = 2n(n + 3). Let M and M be arbitrary distinct -bit strings such that they agree everywhere except the last two blocks. Query M and M to the first oracle to get answers C and C respectively. In the real game, we'll have X i = Xi and Ỹi = Y i ⊕ (c i • (S ⊕ S)) for every 1 ≤ i ≤ n + 2. Next, let C * be the "mixed" ciphertext such that, for every 1 ≤ i ≤ n + 3, the (2i - Consequently, S * = S and thus M * and M agree at the (2n+3)th and (2n+4)th blocks. The latter event happens with probability at mos 2 -n in the random game. Hence this attack wins with advantage at least 1 -2 -n .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Games for defining security. The top three games are the usual ones for defining the AE and MRAE notions. The bottom two games are used to define RAE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>there's no tweak. If we prohibit the adversary A from querying the second oracle we drop the word "strong" and write Adv prp E (A) and Adv prp E (A) respectively. Encode-then-encipher. Fix Σ. Let E : K × T × Σ * → Σ * be an arbitraryinput-length tweakable blockcipher with tweak space T = Σ * × Σ * × N. Let D be its inverse. Let Encode : Σ * × N → Σ * be an injective function satisfying |Encode(M, λ)| = |M |+λ. We write the second argument to Encode as a subscript, Encode λ (M ) ∈ Σ |M |+λ . An example encoding function is Encode λ (M ) = M 0 λ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig.4. The AEZ-core[f ] construction. The method builds a strong-PRP on {0, 1} ≥2n from an n-bit-output PRF f that operates on its subscript and argument. It's key K is implicit. The PRF can be realized by a TBC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. AEZ's hash, PRF, and TBC. The last is the locus of prove-then-prune scaling-down. The key K is turned into 384 bits by a key-derivation function Extract.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Illustrating AEZ enciphering. Rectangles with pairs of numbers are TBCs, the pair being the tweak (the key, always K, is not shown). Top row: enciphering a message M of (32 or more bytes) with AEZ-core. The diagram shows processing a string that is (exclude the middle panel) or isn't (include the middle panel) a multiple of 16 bytes. Bottom left: AEZ-hash is an xor-universal hash built from AES4. It computes Δ = Δi from a vector-valued tweak T comprising A, N , and τ . Its i-th component T1 • • • Tm is hashed as shown. Bottom right: AEZ-tiny, when operating on a string M = L R of 16-31 bytes. More rounds are used if M has 1-15 bytes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>B. 1</head><label>1</label><figDesc>Proof of Theorem 1It suffices to show thatPr[A IdealΠ ⇒ 1] -Pr[A PRIΠ ⇒ 1] ≤ (r 2 + r)/|Σ| λ+mmin+1 + 2q/|Σ| λ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Pr[A G1 ⇒ 1] -Pr[A G2 ⇒ 1] ≤ Pr[A G1 sets bad] -1) 2 + (s i -1) |Σ| mmin+λ+1 ≤ r 2 + r |Σ| mmin+λ+1 ;the last inequality is due to the fact that (s1 -1) + • • •+ (s p -1) = r. Game G 3 is a simplified version of game G 2 ; the change is conservative. Game G 4 is identical to game G 3 ,except that in procedure Dec, it samples a λ-character string v and returns a non-⊥ answer if v = 0 λ , where 0 is a canonical point in Σ. Let L be the multiset of |C| in A's decryption queries in game G 4 , and let L be the multiset { | ≥ 0 and + λ ∈ L }. Then Pr[A G3 ⇒ 1] -Pr[A G4 ⇒ 1] ≤ Pr[A G3 sets bad]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>1)'th and 2i'th blocks of C * are the same as those of C if i ∈ D, otherwise C * would borrow the corresponding two blocks of C. Query C * to the second oracle to get an answer M * . Let D = {1, . . . , n + 2}\D. In the real game, the query C * will generate Y * i = Ỹi for every i ∈ D, and Y * i = Y i for every i ∈ D. Then Y * = i∈D Ỹi ⊕ j∈D Y j = Y ⊕ i∈D ((S ⊕ S) • c i ) = Y .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>|N |/16 + i |A i |/16 + (|M | + λ)/16 . This query is small if M = ε and 16 ≤ |M | + λ &lt; 32, and tiny if M = ε and |M | + λ &lt; 16. Likewise, for a decryption query (N, A, λ, C), the number of blocks processed is |N |/16 + i |A i | + (|C|)/16 . The query is small if 16 ≤ |C| &lt; 32 and |C| = λ, and tiny if |C| = λ and |C| &lt; 16. The proof for the following is in the full version<ref type="bibr" target="#b28">[28]</ref>. Let E : K × T aez × {0, 1} 128 → {0, 1} 128 be a TBC and Π = AEZ[ E]. Then there are efficient, explicitly given algorithms R and S with the following property. Let A be an adversary for attacking Π. Assume it never asks any small or tiny query. Then B = R(A) satisfies Adv rae Π,S (A) ≤ 3.5s 2 /2 128 + Adv prp E (B), where s is the total number of processed blocks, plus 2 blocks per message. Adversary B makes at most 2.5s queries and has about the same running time as A.</figDesc><table><row><cell>Theorem 5.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We'll later permit arbitrary alphabets. To avoid confusion, we use λ to measure ciphertext expansion in characters (bits, bytes, etc.) and τ to measure it in bits.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Since an RAE scheme trivially determines an arbitrary-input-length tweakable blockcipher (set τ = 0) it makes sense to use a single name for both objects.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>By online we mean that the encryption algorithm can be realized in O(1) memory and a single pass over M .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>If the first bit of ciphertext doesn't depend on the last bit of plaintext an adversary easily wins the MRAE game.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>It might be OK to set some reasonable upperbound λ ≤ λmax, but there shouldn't be a nonzero lowerbound.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. Many thanks to Tom Shrimpton, who provided important interaction on RAE definitions and their implications. Liden Mu and Chris Patton proofread our specification document and did implementations that helped verify our own. We received good comments and corrections Danilo Gligoroski, Tom Ristenpart, and Yusi (James) Zhang. Thanks to Dustin Boswell for an April 2013 email on the importance of making AE easier to use, Stefan Lucks for a Jan 2012 discussion on the problem unverified plaintexts, and René Struik for an August 2013 DIAC presentation on the utility of minimizing ciphertext expansion. Thanks to Terence Spies for catalyzing the idea of unifying AE and blockciphers both in definition and schemes.</p><p>Part of this work was done when Tung was a postdoc at UC San Diego and Phil was visiting ETH Zürich. Many thanks to Mihir Bellare for that postdoc, and many thanks to Ueli Maurer for hosting that sabbatical.</p><p>Hoang was supported by NSF grants CNS-0904380, CCF-0915675, CNS-1116800 and CNS-1228890; Krovetz was supported by NSF grant CNS-1314592; and Rogaway was supported by NSF grants CNS-1228828 and CNS-1314885. Many thanks to the NSF for their continuing support.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A More on Related Work</head><p>RAE and AEZ build on a large body of related work. While we have summarized much of this throughout this paper, here we give some additional context and high points.</p><p>Blockciphers accommodating truly arbitrary inputs were first realized by Schroeppel's Hasty Pudding Cipher (HPC) <ref type="bibr" target="#b56">[55]</ref>. Ahead of its time, the work not only built a blockcipher on all of {0, 1} * , but also provided it a tweak. If one were to first overcome the problem that HPC's tweak is limited in length, it could be used with the EtE construction to make an RAE scheme.</p><p>The problem of constructing from conventional blockciphers those with arbitrary or near-arbitrary domains was first identified Bellare and Rogaway <ref type="bibr" target="#b3">[4]</ref>, who wanted to construct these objects with a conventional-looking mode. But the mechanism they suggested was somewhat slow, was limited to a domain of ({0, 1} n ) + , and only achieves conventional (not strong) PRP security.</p><p>In a follow-up paper <ref type="bibr" target="#b4">[5]</ref> the same authors evidenced the utility of arbitraryinput-length blockciphers by explaining how semantic security could be achieved by enciphering messages with novelty, and they showed how authenticity could be achieved by enciphering messages with redundancy (this time using a strong PRP). These observations formed the basis for our work.</p><p>Around the same time as the last two work, Naor and Reingold (NR) constructed a blockcipher on ({0, 1} n ) + by sandwiching a layer of ECB between layers of a "blockwise-universal" hashing <ref type="bibr" target="#b39">[39,</ref><ref type="bibr" target="#b40">40]</ref>. The approach came to be used in many proposals, including XCB <ref type="bibr" target="#b35">[35]</ref>, which was standardized in the IEEE <ref type="bibr" target="#b29">[29]</ref>. <ref type="figure">9</ref>. Games used to prove Theorem 1. Here 0 is a canonical element of Σ. Games G2 and G4 contain the boxed statements, but games G1 and G3 do not.</p><p>the last inequality is due to the assumption that q ≤ |Σ| λ-1 . Summing up,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 Proof of Theorem 2</head><p>The reduction R creates from A the adversary B as follows. It runs A. When the latter makes an encryption query (N, A, λ, M ), if v(M ) = 1 then the former sends the same query to its encryption oracle and returns the answer to A; otherwise it returns ⊥. When A makes a query (N, A, λ, C), adversary B sends the same query to its decryption oracle to get M . If |M | = |C|λ and v(M ) = 1 then it returns 0 M to A, where 0 is a canonical point in Σ. Otherwise, it returns M . Finally, it outputs the same guess as A.</p><p>For any query (N, A, λ, C) that it receives, S stores (N, A, λ, |C|) in a set L λ . It also maintains, for each (N, A, λ, </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">How to securely release unverified plaintext in authenticated encryption</title>
		<author>
			<persName><forename type="first">E</forename><surname>Andreeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bogdanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Luykx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mennink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mouha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yasuda</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014-02-25">2014. February 25. 2014</date>
			<biblScope unit="volume">144</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Cryptology ePrint report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Parallelizable and authenticated online ciphers</title>
		<author>
			<persName><forename type="first">E</forename><surname>Andreeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bogdanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Luykx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mennink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tischhauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yasuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2013, Part I</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8269</biblScope>
			<biblScope unit="page" from="424" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Online ciphers and the hash-CBC construction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Namprempre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2001</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="292" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On the construction of variable-input-length ciphers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 1999</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1636</biblScope>
			<biblScope unit="page" from="231" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Encode-then-encipher encryption: how to exploit nonces or redundancy in plaintexts for efficient cryptography</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASI-ACRYPT 2000</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1976">1976. 2000</date>
			<biblScope unit="page" from="317" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The FFX mode of operation for formatpreserving encryption. Draft 1.1. Submission to NIST</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Spies</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010-02-20">February 20. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Cryptographic competitions: CAESAR call for submissions, final</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bernstein</surname></persName>
		</author>
		<ptr target="http://competitions.cr.yp.to/caesar-call.html" />
		<imprint>
			<date type="published" when="2014-01-27">January 27, 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">MAC reforgeability</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cochran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2009</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Dunkelman</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5665</biblScope>
			<biblScope unit="page" from="345" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Ciphers with arbitrary finite domains</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA 2002</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2271</biblScope>
			<biblScope unit="page" from="114" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">On symmetric encryption with distinguishable decryption failures</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Degabriele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page">433</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Cryptology ePrint Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An improved security bound for HCTR</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2008</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Nyberg</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5086</biblScope>
			<biblScope unit="page" from="289" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">HCH: A new tweakable enciphering scheme using the hash-encrypt-hash approach</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1683" to="1699" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A new mode of encryption providing a tweakable strong pseudo-random permutation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2006</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Robshaw</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4047</biblScope>
			<biblScope unit="page" from="293" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The Design of Rijndael: AES -The Advanced Encryption Standard</title>
		<author>
			<persName><forename type="first">J</forename><surname>Daemen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A new MAC construction ALRED and a specific instance ALPHA-MAC</title>
		<author>
			<persName><forename type="first">J</forename><surname>Daemen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2005</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Handschuh</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3557</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The Pelican MAC function</title>
		<author>
			<persName><forename type="first">J</forename><surname>Daemen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005. 2005</date>
			<biblScope unit="page">88</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Cryptology ePrint report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Recommendation for block cipher modes of operation: methods for format-preserving encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dworkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIST Special Publication</title>
		<imprint>
			<biblScope unit="volume">800</biblScope>
			<biblScope unit="issue">38</biblScope>
			<date type="published" when="2013-07">July 2013</date>
			<publisher>Draft</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Authentication weaknesses in GCM</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ferguson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-05-20">May 20, 2005</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Statistical tables for biological, agricultural and medical research</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yates</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1938">1938</date>
			<publisher>Oliver &amp; Boyd</publisher>
			<pubPlace>London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">McOE: a family of almost foolproof on-line authenticated encryption schemes</title>
		<author>
			<persName><forename type="first">E</forename><surname>Fleischmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Forler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lucks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2012</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Canteaut</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7549</biblScope>
			<biblScope unit="page" from="196" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Authenticated on-line encryption</title>
		<author>
			<persName><forename type="first">P</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Martinet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Valette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC 2003</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Zuccherato</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3006</biblScope>
			<biblScope unit="page" from="145" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">EME*: extending EME to handle arbitrary-length messages with associated data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INDOCRYPT 2004</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Canteaut</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Viswanathan</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3348</biblScope>
			<biblScope unit="page" from="315" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Invertible universal hashing and the TET encryption mode</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<idno>2007/014</idno>
		<imprint/>
	</monogr>
	<note type="report_type">Cryptology ePrint report</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A parallelizable enciphering mode</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA 2004</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2964</biblScope>
			<biblScope unit="page" from="292" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A tweakable enciphering mode</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2003</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="482" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">AEZ v3: authenticated encryption by enciphering</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krovetz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>CAESAR submission</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Unforgeable encryption and chosen ciphertext secure modes of operation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2000</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Schneier</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1978</biblScope>
			<biblScope unit="page" from="284" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Robust authenticated-encryption: AEZ and the problem that it solves</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krovetz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014-01">2014/793. January 2015</date>
		</imprint>
	</monogr>
	<note type="report_type">Cryptology ePrint report</note>
	<note>Full version of this paper</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">-2010 -IEEE standard for wide-block encryption for shared storage media</title>
		<idno>IEEE. 1619.2</idno>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>IEEE press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Is DES a Pure Cipher? (Results of more cycling experiments on DES)</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Kaliski</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">T</forename><surname>Sherman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1985</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Williams</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">218</biblScope>
			<biblScope unit="page" from="212" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Exact maximum expected differential and linear probability for two-round Advanced Encryption Standard</title>
		<author>
			<persName><forename type="first">L</forename><surname>Keliher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IET Information Security</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="53" to="57" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The software performance of authenticated-encryption modes</title>
		<author>
			<persName><forename type="first">T</forename><surname>Krovetz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2011</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6733</biblScope>
			<biblScope unit="page" from="306" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Cryptographic extraction and key derivation: the HKDF scheme</title>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2010</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer, Heidelberg</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="631" to="648" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Tweakable block ciphers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2002</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2442</biblScope>
			<biblScope unit="page" from="31" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The security of the extended codebook (XCB) mode of operation</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Mcgrew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Fluhrer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC 2007</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Adams</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Miri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Wiener</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4876</biblScope>
			<biblScope unit="page" from="311" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Parallelizable rate-1 authenticated encryption from pseudorandom functions</title>
		<author>
			<persName><forename type="first">K</forename><surname>Minematsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2014</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8441</biblScope>
			<biblScope unit="page" from="275" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Provably secure MACs from differentially-uniform permutations and AES-based implementations</title>
		<author>
			<persName><forename type="first">K</forename><surname>Minematsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tsunoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2006</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Robshaw</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4047</biblScope>
			<biblScope unit="page" from="226" to="241" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Improving upon HCTR and matching attacks for Hash-Counter-Hash approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nandi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008-02-90">2008/090, February 28, 2008</date>
		</imprint>
	</monogr>
	<note type="report_type">Cryptology ePrint report</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">On the construction of pseudo-random permutations: Luby-Rackoff revisited</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="66" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">The NR mode of operation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Undated manuscript realizing the mechanism of [39</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Generic attacks on feistel schemes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Patarin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2001</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Boyd</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2248</biblScope>
			<biblScope unit="page" from="222" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Efficient constructions of variable-inputlength block ciphers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ramzan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sundaram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC 2004</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Handschuh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hasan</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3357</biblScope>
			<biblScope unit="page" from="326" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Security of balanced and unbalanced Feistel schemes with linear non equalities</title>
		<author>
			<persName><forename type="first">J</forename><surname>Patarin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010-05">2010/293. May 2010</date>
		</imprint>
	</monogr>
	<note type="report_type">Cryptology ePrint report</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Security of random feistel schemes with 5 or more rounds</title>
		<author>
			<persName><forename type="first">J</forename><surname>Patarin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2004</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3152</biblScope>
			<biblScope unit="page" from="106" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Increasing block sizes using feistel networks: the example of the AES</title>
		<author>
			<persName><forename type="first">J</forename><surname>Patarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gittins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Treger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryphtography and Security: From Theory to Applications</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Naccache</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">6805</biblScope>
			<biblScope unit="page" from="67" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Stronger key derivation via sequential memory-hard functions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Percival</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The BSD Conference (BSDCan)</title>
		<imprint>
			<date type="published" when="2009-05">May 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Careful with misuse resistance of online AEAD. Unpublished manuscript distributed on the crypto-competitions mailing list</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reyhanitabar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vizár</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014-08-24">August 24. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Authenticated-encryption with associated-data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="page" from="98" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Efficient instantiations of tweakable blockciphers and refinements to modes OCB and PMAC</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2004</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Lee</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3329</biblScope>
			<biblScope unit="page" from="16" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">OCB: A block-cipher mode of operation for efficient authenticated encryption</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krovetz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>ACM CCS</publisher>
			<biblScope unit="page" from="196" to="205" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A provable-security treatment of the key-wrap problem</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2006</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4004</biblScope>
			<biblScope unit="page" from="373" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Efficient tweakable enciphering schemes from (block-wise) universal hash functions</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</author>
		<idno>2008/004</idno>
		<imprint/>
	</monogr>
	<note type="report_type">Cryptology ePrint report</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Improving upon the TET mode of operation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICISC 2007</title>
		<editor>
			<persName><forename type="first">K.-H</forename><surname>Nam</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rhee</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4817</biblScope>
			<biblScope unit="page" from="180" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Tweakable enciphering schemes using only the encryption function of a block cipher</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page">216</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Cryptology ePrint report</note>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Hasty Pudding Cipher Specification. AES candidate submitted to NIST</title>
		<author>
			<persName><forename type="first">R</forename><surname>Schroeppel</surname></persName>
		</author>
		<ptr target="http://richard.schroeppel.name/hpc/hpc-spec" />
		<imprint>
			<date type="published" when="1998-06">June 1998. May 1999</date>
		</imprint>
	</monogr>
	<note>revised</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">A modular framework for building variable-inputlength tweakable ciphers</title>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Terashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2013, Part I</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8269</biblScope>
			<biblScope unit="page" from="405" to="423" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">The MARVIN message authentication code and the LETTERSOUP authenticated encryption scheme</title>
		<author>
			<persName><forename type="first">M</forename><surname>Simplício</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barbuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barreto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Carvalho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Margi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Security and Communications Networks</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="165" to="180" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">AEAD ciphers for highly constrained networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Struik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DIAC 2013 presentation</title>
		<imprint>
			<date type="published" when="2013-08-13">August 13. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Security of truncated MACs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Inscrypt 2008</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Lin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5487</biblScope>
			<biblScope unit="page" from="96" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">HCTR: a variable-input-length enciphering mode</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CISC 2005</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Feng</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Lin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3822</biblScope>
			<biblScope unit="page" from="175" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Design and analysis of password-based key derivation functions</title>
		<author>
			<persName><forename type="first">F</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">L</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Information Theory</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="3292" to="3297" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
