<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Provably Correct Peephole Optimizations with Alive</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nuno</forename><forename type="middle">P</forename><surname>Lopes</surname></persName>
							<email>nlopes@microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Menendez</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Rutgers University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Santosh</forename><surname>Nagarakatte</surname></persName>
							<email>santosh.nagarakatte@cs.rutgers.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">Rutgers University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Regehr</surname></persName>
							<email>regehr@cs.utah.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Utah</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Provably Correct Peephole Optimizations with Alive</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E54548683A0ED6352B1E78C9ADD52AEC</idno>
					<idno type="DOI">10.1145/2737924.2737965</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Programming Languages]: Software/Program Verification</term>
					<term>D.3.4 [Programming Languages]: Processors-Compilers</term>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs Compiler Verification, Peephole Optimization, Alive</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Compilers should not miscompile. Our work addresses problems in developing peephole optimizations that perform local rewriting to improve the efficiency of LLVM code. These optimizations are individually difficult to get right, particularly in the presence of undefined behavior; taken together they represent a persistent source of bugs. This paper presents Alive, a domain-specific language for writing optimizations and for automatically either proving them correct or else generating counterexamples. Furthermore, Alive can be automatically translated into C++ code that is suitable for inclusion in an LLVM optimization pass. Alive is based on an attempt to balance usability and formal methods; for example, it capturesbut largely hides-the detailed semantics of three different kinds of undefined behavior in LLVM. We have translated more than 300 LLVM optimizations into Alive and, in the process, found that eight of them were wrong.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Compiler optimizations should be efficient, effective, and correctbut meeting all of these goals is difficult. In practice, whereas efficiency and effectiveness are relatively easy to quantify, correctness is not. Incorrect compiler optimizations can remain latent for long periods of time; the resulting problems are subtle and difficult to diagnose since the incorrectness is introduced at a level of abstraction lower than the one where software developers typically work. Although mainstream compilers use well-known algorithms, bugs arise due to misunderstandings of the semantics, incomplete reasoning about boundary conditions, and errors in the implementation of the algorithms.</p><p>Random testing <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b36">37]</ref> is one approach to improve the correctness of compilers; it has been shown to be effective, but of course testing misses bugs. A stronger form of insurance against compiler bugs can be provided by a proof that the compiler is correct Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. PLDI'15, June 13-17, 2015, Portland, OR, USA. Copyright c 2015 ACM 978-1-4503-3468-6/15/06. . . $15.00. http://dx.doi.org/10.1145/2737924.2737965 <ref type="bibr">(compiler verification)</ref> or a proof that a particular compilation was correct (translation validation). For example, CompCert <ref type="bibr" target="#b16">[17]</ref> uses a hybrid of the two approaches. Unfortunately, creating CompCert required several person-years of proof engineering and the resulting tool does not provide a good value proposition for many real-world use cases: it implements a subset of C, optimizes only lightly, and does not yet support x86-64 or the increasingly important vector extensions to x86 and ARM. In contrast, production compilers are constantly improved to support new language standards and to obtain the best possible performance on emerging architectures.</p><p>This paper presents Alive: a new language and tool for developing correct LLVM optimizations. Alive aims for a design point that is both practical and formal; it allows compiler writers to specify peephole optimizations for LLVM's intermediate representation (IR), it automatically proves them correct with the help of satisfiability modulo theory (SMT) solvers (or provides a counterexample), and it automatically generates C++ code that is similar to handwritten peephole optimizations such as those found in LLVM's instruction combiner (InstCombine) pass. InstCombine transformations perform numerous algebraic simplifications that improve efficiency, enable other optimizations, and canonicalize LLVM code.</p><p>Alive is inspired by previous research on domain specific languages for easing compiler development such as Gospel <ref type="bibr" target="#b35">[36]</ref>, Rhodium <ref type="bibr" target="#b15">[16]</ref>, PEC <ref type="bibr" target="#b12">[13]</ref>, Broadway <ref type="bibr" target="#b8">[9]</ref>, and Lola <ref type="bibr" target="#b20">[21]</ref>. Alive's main contribution to the state of the art is providing a usable formal methods tool based on the semantics of LLVM IR, with support for automated correctness proofs in the presence of LLVM's three kinds of undefined behavior, and with support for code generation.</p><p>While testing LLVM using Csmith, we found InstCombine to be the single buggiest file <ref type="bibr" target="#b36">[37]</ref>; it was subsequently split into multiple files totaling about 15,600 SLOC. A similar pass, InstSimplify, contains about 2,500 more SLOC. An example InstCombine transformation takes (x ⊕ -1) + C and turns it into (C -1) -x where x is a variable, ⊕ is exclusive or, and C is an arbitrary constant as wide as x. If C is 3333, the LLVM input to this InstCombine transformation would look like this:</p><formula xml:id="formula_0">%1 = xor i32 %x, -1 %2 = add i32 %1, 3333</formula><p>and the optimized code:</p><formula xml:id="formula_1">%2 = sub i32 3332, %x</formula><p>The LLVM code specifying this transformation 1 is 160 bytes of C++, excluding comments. In Alive it is: %1 = xor %x, -1 %2 = add %1, C =&gt; %2 = sub C-1, %x 1 http://llvm.org/viewvc/llvm-project/llvm/tags/ RELEASE_350/final/lib/Transforms/InstCombine/ InstCombineAddSub.cpp?view=markup#l1148</p><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Permissions@acm.org. The Alive specification is less than one third the size of the LLVM C++ code. Moreover, it was designed to resemble-both syntactically and semantically-the LLVM transformation that it describes. The Alive code is, we claim, much easier to understand, in addition to being verifiable by the Alive tool chain. This transformation illustrates two forms of abstraction supported by Alive: abstraction over choice of a compile-time constant and abstraction over bitwidth.</p><p>So far Alive has helped us discover eight previously unknown bugs in the LLVM InstCombine transformations. Furthermore, we have prevented dozens of bugs from getting into LLVM by monitoring the various InstCombine patches as they were committed to the LLVM subversion repository. Several LLVM developers are currently using the Alive prototype to check their InstCombine transformations. Alive is open source. <ref type="foot" target="#foot_0">2</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The Alive Language</head><p>We designed Alive to resemble the LLVM intermediate representation (IR) because our user base-the LLVM developers-is already familiar with it. Alive's most important features include its abstraction over choice of constants, over the bitwidths of operands (Sections 2.2 and 3.2), and over LLVM's instruction attributes that control undefined behavior (Sections 2.4 and 3.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Syntax</head><p>Figure <ref type="figure" target="#fig_0">1</ref> gives the syntax of Alive. An Alive transformation has the form A =⇒ B, where A is the source template and B is the target template. Additionally, a transformation may include a precondition. Since Alive's representation, like LLVM's, is based on directed graphs of instructions in SSA format <ref type="bibr" target="#b4">[5]</ref>, the ordering of nondependent instructions, and the presence of interleaved instructions not part of a template, are irrelevant.</p><p>Alive implements a subset of LLVM's integer and pointer instructions; since InstCombine does not modify control flow, Alive does not support branches. <ref type="foot" target="#foot_1">3</ref> In contrast to LLVM, Alive provides an explicit assignment instruction for copying temporaries (i.e., %tmp1 = %tmp2). Alive supports LLVM's nsw, nuw, and </p><formula xml:id="formula_2">((B ∨ V ) ∧ C1) ∨ (B ∧ C2) can be transformed to (B ∨ V ) ∧ (C1 ∨ C2</formula><p>) when C1 ∧ C2 = 0 and when the predicate M askedV alueIsZero(V, ¬C1) is true, indicating that an LLVM dataflow analysis has concluded that V ∧ ¬C1 = 0. %B and %V are input variables. C1 and C2 are constants. %t0, %t1, and %t2 are temporaries. This transformation is rooted at %R. exact instruction attributes that weaken the behavior of integer instructions by adding undefined behaviors.</p><p>Scoping. The source and target templates must have a common root variable that is the root of the respective graphs. The remaining variables are either inputs to the transformation or else temporary variables produced by instructions in the source or target template. Inputs are visible throughout the source and target templates. Temporaries defined in the source template are in scope for the precondition, the target, and the remaining part of the source from the point of definition. Temporaries declared in the target are in scope for the remainder of the target. To help catch errors, every temporary in the source template must be used in a later source instruction or be overwritten in the target, and all target instructions must be used in a later target instruction or overwrite a source instruction.</p><p>Constant expressions. To allow algebraic simplifications and constant folding, Alive includes a language for constant expressions. A constant expression may be a literal, an abstract constant (e.g., C in the example on the previous page), or a unary or binary operator applied to one or two constant expressions. The operators include signed and unsigned arithmetic operators and bitwise logical operators. Alive also supports functions on constant expressions. Built-in functions include type conversions and mathematical and bitvector utilities (e.g., abs(), umax(), width()).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Type System</head><p>Alive supports a subset of LLVM's types. The types in Alive are a union of integer types (I = {i1, i2, i3, . . .} for bitwidth 1,2,3,. . .), pointer types (P = {t * | t ∈ T }), array types (A = {[n x t] | n ∈ N ∧ t ∈ T }), and the void type. LLVM also defines the set of first-class types (FC = I ∪ P), which are the types that can be the result of an instruction. The set of all types is therefore T = FC ∪ A ∪ {void}. Alive does not yet support floating point, aggregate types such as records and vectors, and labels.</p><p>Unlike LLVM, variables in Alive can be implicitly typed and do not need to have fixed bitwidth. An Alive transformation is polymorphic for all the types that satisfy the constraints imposed by the instructions. The Alive framework automatically checks the correctness of the transformation for all feasible types. A transformation can optionally provide types for the input operands of the instructions, which then constrain the set of feasible types. The typing rules for the Alive language are shown in Figure <ref type="figure">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Built-In Predicates</head><p>Peephole optimizations frequently make use of the results of dataflow analyses. Alive makes these results available using a collection of built-in predicates such as isPowerOf2(), MaskedVal-ueIsZero(), and WillNotOverflowSignedAdd(). The analyses producing these results are trusted by Alive: verifying their correctness   is not within Alive's scope. Predicates can be combined with the usual logical connectives. Figure <ref type="figure" target="#fig_1">2</ref> shows an example transformation that includes a built-in predicate in its precondition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Well-Defined Programs and Undefined Behaviors</head><p>LLVM has three distinct kinds of undefined behavior. Together, they enable many desirable optimizations, and LLVM aggressively exploits these opportunities.</p><p>Undefined behavior in LLVM resembles undefined behavior in C/C++: anything may happen to a program that executes it. The compiler may simply assume that undefined behavior does not occur; this assumption places a corresponding obligation on the program developer (or on the compiler and language runtime, when a safe language is compiled to LLVM) to ensure that undefined operations are never executed. An instruction that executes undefined behavior can be replaced with an arbitrary sequence of instructions. When an instruction executes undefined behavior, all subsequent instructions can be considered undefined as well.</p><p>Table <ref type="table" target="#tab_1">1</ref> shows when Alive's arithmetic instructions have defined behavior, following the LLVM IR specification. For example, the shl instruction is defined only when the shift amount is less than the bitwidth of the instruction. With the exception of memory access instructions (discussed in Section 3.3), the Alive instructions not listed in Table <ref type="table" target="#tab_1">1</ref> are always defined.</p><p>The undefined value (undef in the IR) is a limited form of undefined behavior that mimics a free-floating hardware register than can return any value each time it is read. Semantically, undef stands for the set of all possible bit patterns for a particular type; the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Instruction</head><p>Constraints for Poison-free execution add nsw a, b SExt(a, 1) compiler is free to pick a convenient value for each use of undef to enable aggressive optimizations. For example, a one-bit undefined value, sign-extended to 32 bits, produces a variable containing either all zeros or all ones. Figure <ref type="figure">4</ref> illustrates the semantics of undef.</p><formula xml:id="formula_3">+ SExt(b, 1) = SExt(a + b, 1) add nuw a, b ZExt(a, 1) + ZExt(b, 1) = ZExt(a + b, 1) sub nsw a, b SExt(a, 1) -SExt(b, 1) = SExt(a -b, 1) sub nuw a, b ZExt(a, 1) -ZExt(b, 1) = ZExt(a -b, 1) mul nsw a, b SExt(a, B) × SExt(b, B) = SExt(a × b, B) mul nuw a, b ZExt(a, B) × ZExt(b, B) = ZExt(a × b, B) sdiv exact a, b (a ÷ b) × b = a udiv exact a, b (a ÷u b) × b = a shl nsw a, b<label>(</label></formula><p>Poison values, which are distinct from undefined values, are used to indicate that a side-effect-free instruction has a condition that produces undefined behavior. When the poison value gets used by an instruction with side effects, the program exhibits true undefined behavior. Hence, poison values are deferred undefined behaviors: they are intended to support speculative execution of possibly-undefined operations. Poison values cannot be represented in the IR, but rather are ephemeral effects of certain incorrect operations. Poison values taint subsequent dependent instructions; unlike undef, poison values cannot be untainted by subsequent operations.</p><p>Instruction attributes modify the behavior of some LLVM instructions. The nsw attribute ("no signed wrap") makes signed overflow undefined. For example, this Alive transformation, which is equivalent to the optimization of (x+1)&gt;x to 1 in C/C++ where x is a signed integer, is valid:</p><formula xml:id="formula_4">%1 = add nsw %x, 1 %2 = icmp sgt %1, %x =&gt; %2 = true</formula><p>An analogous nuw attribute exists to rule out unsigned wrap. If an add, subtract, multiply, or shift left operation with an nsw or nuw attribute overflows, the result is a poison value. Additionally, LLVM's shift right and divide instructions have an exact attribute that requires an operation to not be lossy. Table <ref type="table">2</ref> provides the constraints for the instructions to be poison-free. Developers writing Alive patterns can omit instruction attributes, in which case Alive infers where they can be safely placed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Memory</head><p>LLVM's alloca instruction reserves memory in the current stack frame and returns a pointer to the allocated memory block. Heap memory, in contrast, is handled indirectly: there is no instruction in the IR for heap allocations; it is handled by library functions such as calls to malloc.</p><p>The getelementptr instruction supports structured address computations: it uses a sequence of additions and multiplications to compute the address of a specific array element or structure field. For example, an array dereference in C such as val = a[b][c] can be translated to the following LLVM code: %ptr = getelementptr %a, %b, %c %val = load %ptr Unstructured memory accesses are supported by the inttoptr instruction. The load and store instructions support typed memory reads and writes. Out-of-bounds and unaligned loads and stores result in true undefined behavior, but a load from valid, uninitialized memory returns an undef.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Verifying Optimizations in Alive</head><p>The Alive checker verifies a transformation by automatically encoding the source and target, their definedness conditions, and the overall correctness criteria into SMT queries. An Alive transformation is parametric over the set of all feasible types: the concrete types satisfying the constraints of LLVM's type system. When computing feasible types, we place an upper limit on the width of each variable and constant (64 bits, by default).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Checking Correctness for a Feasible Type</head><p>In the absence of undefined behavior in the source or target of an Alive transformation, we can check correctness using a straightforward equivalence check: for each possible combination of values of input variables, the value of any variable that is present in both the source and target must be the same. However, checking equality of the values produced both in the source and target is not sufficient to prove correctness in the presence of any of the three kinds of undefined behavior described in Section 2.4. We use refinement to reason about optimizations in the presence of undefined behavior, following prior work <ref type="bibr" target="#b16">[17]</ref>. The target of an Alive transformation refines the source template if all the behaviors of the target are included in the set of behaviors of the source.</p><p>When an instruction can produce or use an undef value, we need to ensure that the value produced in the target is one of the values that the source would have produced. In other words, an undef in the source represents a set of values and the target can refine it to any particular value. Poison values are handled by ensuring that an instruction in the target template will not yield a poison value when the source instruction did not, for any specific choice of input values. In summary, we check correctness by checking (1) the target is defined when the source is defined, (2) the target is poison-free when the source is poison-free, and (3) the source and the target produce the same result when the source is defined and poison-free.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Verification Condition Generation</head><p>To automatically check correctness of an Alive transformation, we need to encode the values produced, the precondition, and the correctness conditions into SMT. The semantics of the LLVM and Alive integer instructions closely match bitvector operations provided by SMT solvers. The encoding of these instructions is therefore straightforward and we omit the details. Predicates used in preconditions are also easily encoded as predicates over bitvector expressions in SMT.</p><p>For each instruction, Alive computes three SMT expressions: (1) an expression for the result of the operation (except for instructions returning void), (2) an expression representing the cases for which the instruction has defined behavior, and (3) an expression representing the cases for which the instruction does not return a poison value. The verification condition generator (VC Gen) generates a constraint for each instruction representing the cases for which it is defined (see Table <ref type="table" target="#tab_1">1</ref>). The VC Gen aggregates definedness conditions over the def-use chains, such that the definedness condition for each instruction is the conjunction of the definedness condition of the instruction and the definedness conditions of all of its operands. In summary, definedness constraints flow through def-use chains. The same applies to poison-free constraints.</p><p>Encoding undef values in SMT. An undef value represents a set of values of a particular type. The VC Gen encodes each undef value as a fresh SMT variable and adds it to a set U. Variables in U are then appropriately quantified (see Section 3.1.2) over the correctness conditions to check refinement.</p><p>Encoding precondition predicates in SMT. The encoding of predicates depends on whether the underlying analysis is precise or is an over-or under-approximation. For example, the predicate isPower2 is implemented in LLVM with a must-analysis, i.e., when isPower2(%a) is true, we know for sure that %a is a power of two; when it is false, no inference can be made. The VC Gen encodes the result of isPower2(%a) using a fresh Boolean variable p, and a side constraint p =⇒ a = 0 ∧ a &amp; (a -1) = 0.</p><p>The encoding of may-analyses is similar. The VC Gen creates a fresh variable p to represent the result of the analysis and a side constraint of the form s =⇒ p where s is an expression summarizing the may-analysis based on the inputs. For example, a simplified encoding of mayAlias(%a,%b) is a = b =⇒ p.</p><p>Most analyses in LLVM are precise when their inputs are compile-time constants. Therefore, we encode the result of these analyses precisely when we detect such cases (done statically by the VC Gen).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Correctness Criteria</head><p>Let φ be the precondition of a transformation, δ be the definedness constraint of the source instruction, ρ be the poison-free constraint, ι the result of executing a source instruction, and δ, ρ, and ι the respective constraints for the target.</p><p>Let I be the set of input variables from the source template including constants, P be the set of all fresh variables p used to encode approximating analyses in the precondition, and U and U be the sets of variables created by the VC Gen to encode undef values of the source and target, respectively.</p><p>Let ψ ≡ φ ∧ δ ∧ ρ. A transformation specified in Alive is correct iff all of the following constraints hold for each instruction:</p><formula xml:id="formula_5">1. ∀ I,P,U ∃U : ψ =⇒ δ 2. ∀ I,P,U ∃U : ψ =⇒ ρ 3. ∀ I,P,U ∃U : ψ =⇒ ι = ι</formula><p>The first constraint states that the target operation should be defined whenever the source operation is defined. The second constraint states that the target operation can only produce poison values for the inputs that the source operation does. Finally, the third constraint states that the source and target instructions should produce the same result whenever the precondition holds and the source operation is defined and poison-free.</p><p>The correctness conditions are universally quantified over the undef values in the target and existentially quantified over the undef values from the source. If the target has an undef value, we check that the correctness conditions hold for all possible values that a particular undef can take. In contrast, if the source has an undef value, undef can be instantiated with any value that enables the validity of the correctness conditions. Hence an existential quantifier is used for undef variables in the source, which occurs after the universal quantifier for the target undef variables. In summary, for each set of input variables, and undef values in the target, we can pick any value for the undef in the source that satisfies the correctness conditions.</p><p>We now state the correctness criteria for an Alive transformation:</p><p>T H E O R E M 1 (Soundness). If conditions 1-3 hold for every instruction in an Alive transformation (without memory operations) and for any valid type assignment (as given by the type system of Figure <ref type="figure">3</ref>), then the transformation is correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Illustration of Correctness Checking</head><p>We illustrate the verification condition generation and correctness conditions with two examples.</p><p>Pre: C1 u&gt;= C2 %0 = shl nsw i8 %a, C1 %1 = ashr %0, C2 =&gt; %1 = shl nsw %a, C1-C2</p><p>The precondition for the above transformation is φ ≡ c1 ≥u c2, where c1 and c2 are bitvector variables corresponding to constants C1 and C2 in the transformation. The source instruction that produces %0 is defined when shl is defined (c1 &lt;u 8: the SMT variable c1 is unsigned less than 8, the bitwidth of the operands). Likewise, instruction %1 is defined when ashr is defined (c2 &lt;u 8) and its operands are defined. Hence, the definedness conditions for the source are δ %0 ≡ c1 &lt;u 8 and δ %1 ≡ c1 &lt;u 8 ∧ c2 &lt;u 8.</p><p>The source instruction %0 is poison-free if no signed overflow occurs in the shift operation (because of the nsw attribute). The source instruction %1 can only be poison if any of its operands is poison (since it has no nsw or nuw attributes). Hence, constraints for poison-free execution in the source are ρ %0 ≡ ρ %1 ≡ (a &lt;&lt; c1) &gt;&gt; c1 = a, where a is the SMT variable for input %a in the source.</p><p>Similarly, the definedness and poison-free constraints for the target are δ %1 ≡ c1 -c2 &lt;u 8 and ρ %1 ≡ (a &lt;&lt; (c1 -c2)) &gt;&gt; (c1 -c2) = a respectively. We trivially have δ %0 = δ %0 and ρ %0 = ρ %0 . The constraints for the values produced by the source and target are ι %0 ≡ ι %0 ≡ a &lt;&lt; c1, ι %1 = (a &lt;&lt; c1) &gt;&gt; c2, and ι %1 = a &lt;&lt; (c1 -c2). There are no undef values in this transformation.</p><p>Let ψ ≡ φ∧δ %1 ∧ρ %1 . To ensure correctness, we need to check the validity of the following formulas:</p><formula xml:id="formula_6">1. ∀a,c 1 ,c 2 : ψ =⇒ δ %1 2. ∀a,c 1 ,c 2 : ψ =⇒ ρ %1 3. ∀a,c 1 ,c 2 : ψ =⇒ ι %1 = ι %1</formula><p>Since we have that δ %0 = δ %0 , ρ %0 = ρ %0 , and ι %0 = ι %0 , the corresponding formulas for %0 are trivially valid, and therefore we do not present them.</p><p>To check validity, we check if the negation of the above formulas are unsatisfiable; that is, we check if (1) ∃a, ∃c1, ∃c2 : ψ ∧ ¬δ, (2) ∃a, ∃c1, ∃c2 : ψ ∧ ¬ρ, and (3) ∃a, ∃c1, ∃c2 : ψ ∧ ι = ι are unsat.</p><p>Example with undef. We illustrate verification condition generation and correctness checking for undef with the following example: %r = select undef, i4 -1, 0 =&gt; %r = ashr undef, 3</p><p>In this example, both the source and target are always defined and poison-free. However, there are undef values both in the source and the target. The VC Gen creates an SMT variable u1 for the undef in the source and a variable u2 for the undef in the target. Since both the source and the target are always defined and poison-free, checking refinement amounts only to checking that the values produced by the instructions are equal. The constraint for the value produced by the source is ι ≡ ite(u1 = 1, -1, 0), and for the target is ι ≡ u2 &gt;&gt; 3 (where ite is the standard ifthen-else SMT expression). We check the validity of the following formula: ∀u2∃u1 : ι = ι. Since the formula is valid, the Alive transformation is correct. Note the use of universal quantification of the target undef (u2) and existential quantification of the source undef (u1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.4">Generating Counterexamples</head><p>When Alive fails to prove the correctness of a transformation, it prints a counterexample showing values for inputs and constants, as well as for each of the preceding intermediate operations. We bias the SMT solver to produce counterexamples with bitwidths such as four or eight bits. It is obvious that large-bitwidth examples are difficult to understand; we also noticed that, perhaps counterintuitively, examples involving one-or two-bit variables are also not easy to understand, perhaps because almost every value is a corner case. Figure <ref type="figure" target="#fig_4">5</ref> shows an example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Enumerating Feasible Types</head><p>Alive transformations are parametric over types. Hence, Alive must verify a transformation for all valid type assignments. We use an SMT solver to perform type inference and to enumerate all possible type assignments (up to a bound of 64 bits for integers). We create SMT variables to represent types and create typing constraints between these variables according to the typing rules in Figure <ref type="figure">3</ref>. Given this setup, enumerating all valid typings amounts to enumerating all (non-partial) models of an SMT formula. We solve the formula to obtain a model for the typing constraints and check the correctness of the Alive transformation for the typing. We explore all valid type assignments using the standard technique of iteratively strengthening the formula with the negation of each model until the formula becomes unsatisfiable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Memory</head><p>We encode memory-handling instructions precisely in order to support arbitrary pointer arithmetic through structured (i.e., getelementptr) and unstructured (i.e., inttoptr) means. We use the SMT array theory to describe our encoding. Memory is represented by an array from the pointer length (e.g., 32 or 64 bits) to 8 bits, and is represented by m. Both the source and target start with an arbitrary, but equal, memory array m0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Verification Condition Generation</head><p>Alloca. Stack memory allocation is handled in two steps. First, a variable is created to represent the pointer resulting from an alloca instruction. This variable is constrained (1) to be different than zero, (2) to have a value that is properly aligned (e.g., a pointer to a 32-bit integer must be a multiple of 4), (3) to enforce that the allocated memory range does not overlap with other allocated regions (i.e., for two pointers p, p and allocated sizes sz, sz , we have p ≥u p+sz∨p +s ≤u p), and (4) to ensure that the allocated memory range does not wrap around the memory space (i.e., for a pointer p and allocated size sz, we have p ≤u p + sz). These constraints are added to α: a collection of constraints corresponding to stack memory allocation from alloca instructions. Second, the allocated region is marked as uninitialized because reading from an uninitialized memory location returns an undef value in LLVM. The VC Gen accomplishes this by creating a fresh bit vector with length equal to the allocation size and stores it to the memory region at the pointer value. This fresh variable is added to set U. With this encoding, different loads of the same uninitialized memory location will return the same arbitrary value.</p><p>The size of the allocated memory block is equal to the number of allocated elements multiplied by the aligned allocation size of each element type. The allocation size of a type is computed by first rounding it to the nearest byte boundary (e.g., the allocation size of i5 is 8 bits). Then, the size is rounded to the next valid ABI alignment. For example, in common x86 ABIs, the alignment for integers is usually 32 bits, and therefore the aligned allocation size of i5 would be 32 bits. Verification is done parametrically on the ABI. If the allocation size exceeds the memory size, the operation has undefined behavior.</p><p>Load. Since memory is encoded as a byte array, load instructions are encoded as a concatenation of multiple array loads (select operation with the array theory). We use concat and extract operations from the bitvector theory to concatenate multiple bits and to extract a set of bits, respectively. For example, the instruction %v = load i16 * %p is encoded as v = concat(select(m, p + 1), select(m, p)) (assuming a little-endian architecture, like x86). For loads of values whose size is not a multiple of 8 bits, an extract is added to the last loaded byte to trim its size. It is undefined behavior if a load operation is not within any known memory block, if the alignment of a load is larger than the alignment of the accessed memory block, or if the pointer is null.</p><p>Store. The encoding of store instructions is similar to that of the load instructions. Stored values are sliced into 8-bit fragments and then stored to the memory array. If undefined behavior has been observed previously, the memory is not modified. For example, the instruction store %v, %p yields the memory configuration ite(δ, m , m), with m = store(m, p, extract(v, 7, 0)) and m = store(m , p + 1, extract(v, 15, 8)).</p><p>Input memory blocks. An input variable in an Alive transformation can be a pointer. Such pointers can point to memory blocks that have been allocated without using the alloca instruction. Alive transformations can transform load and/or store instructions through these input pointer variables. Since we do not know anything about the memory regions referenced by these pointers (e.g., their size and alignment, whether they have been initialized before, whether any of the input pointers alias, etc.), none of the constraints described for the alloca instructions apply here. However, the VC Gen adds constraints that ensure that these pointers cannot alias pointers returned from alloca instructions (added to α).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definedness constraint propagation with memory operations.</head><p>Definedness constraints flow through the def-use chain. However, with the addition of memory operations, definedness constraints are also propagated by instructions with side-effects (e.g., stores and volatile loads). To propagate definedness constraints, the VC Gen has to maintain the order between instructions with side-effects. These instructions create sequence points. At each sequence point, the definedness constraints of the instructions and its operands are recorded and are also propagated to any subsequent instruction. Hence, the target can only perform limited reordering of instructions across sequence points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Correctness Criteria</head><p>Let m and m be the final memory configurations of the source and the target. Let α be the alloca constraints given in the previous section for the source, and α the respective constraints for the target. The three correctness constraints of Section 3.1.2 must be modified to include memory information (i.e., ψ ≡ φ ∧ δ ∧ ρ ∧ α ∧ α). Moreover, an additional constraint must be discharged whenever the transformation uses memory-handling instructions:</p><formula xml:id="formula_7">4. ∀ I,U ,i ∃U : φ ∧ α ∧ α =⇒ select(m, i) = select(m, i)</formula><p>This constraint does not explicitly include constraints for limiting the equality to defined behavior like the correctness constraint 3 in Section 3.1.2. These are, however, already included in m. A store instruction only updates a memory block if no undefined behavior has been observed previously. Thus, no further constraints are required.</p><p>We now state the correctness criteria for Alive transformations with memory operations:</p><p>T H E O R E M 2 (Soundness). If, for every valid type assignment in an Alive transformation, conditions 1-3 hold for every instruction and condition 4 holds for the final memory configurations, then the transformation is correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Beyond the Array Theory</head><p>Many SMT solvers do not support the theory of arrays efficiently, especially in the presence of quantifiers. Hence, we explore encoding memory operations without arrays. This is usually accomplished with Ackermann's expansion <ref type="bibr" target="#b0">[1]</ref>. In the worst case, this procedure can result in a quadratic increase in the size of the formula in terms of the number of load instructions, and requires an additional fresh SMT variable per load. SMT solvers usually perform Ackermannization lazily to avoid the quadratic blowup as much as possible.</p><p>In contrast to lazy Ackermannization as usually performed by SMT solvers, we use an eager Ackermannization encoding that is linear in the number of load and store instructions. Our encoding has the additional advantage of not requiring extra SMT variables, at the expense of potentially more complex SMT expressions.</p><p>With our eager encoding, store instructions are replaced with if-then-else expressions, such that the expression returns the stored value if pointer p is equal to the stored location, or returns the previous memory expression otherwise, i.e., store(m, q, v) becomes ite(p = q, v, m).</p><p>Load instructions take the memory expression built so far (a chain of ite expressions) and replace p with the loaded memory location, i.e., select(m, q) becomes ite(q = p1, v1, ite(q = p2, v2, . . . ite(q = pn, vn, m0))) for previously stored values v1, . . . , vn at locations p1, . . . , pn (potentially overlapping) and initial memory content m0. Since the store operations are enqueued in order (most to least recent), the expression yields the most recent store in case there were multiple stores to the same location.</p><p>In our experiments, we observed that our eager encoding results in faster SMT solving when compared to the theory of arrays. However, our encoding does not ensure consistency across different loads to the same uninitialized memory location, but this is not required by any optimization we have analyzed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Attribute Inference</head><p>By watching LLVM developers submit patches, we observed that placing the nsw, nuw, and exact attributes in LLVM optimizations is difficult enough that it often becomes a matter of trial and error, with developers frequently omitting attributes from the target side of transformations rather than determining whether they can be added safely. The result is that peephole optimizations in LLVM tend to strip away attributes, constraining the behavior of subsequent optimization passes that might have been able to exploit the attributes, had they been preserved.</p><p>Alive has support for adding the nsw, nuw, and exact attributes to the source and target of transformations when it is safe to do so. On the source side, our goal is to automatically synthesize the weakest precondition for a transformation in terms of instruction attributes. On the target side, we want to synthesize the optimal propagation of attributes: the strongest postcondition.</p><p>Our algorithm enumerates all models of a quantified SMT formula for correctness to infer attributes. As attributes only influence constraints generated for poison-free execution, we generate these poison-free constraints conditionally based on the presence or absence of the attributes. The algorithm introduces a fresh SMT Boolean variable f for each instruction and for each attribute. More concretely, we have ρ ≡ f1 =⇒ p1 ∧ . . . ∧ fn =⇒ pn, where fi are fresh Boolean variables, and pi are the conditions that state Φ := true for each type assignment do when the instruction is poison-free when the respective attribute i is enabled. Let F (F) be the set of all f variables from the source (resp. target). The disjunction of all models of the following formula is the optimal set of attributes:</p><formula xml:id="formula_8">f := ∃ F ,F : Φ ∧ c 1 ∧ c 2 ∧ c 3 ∧ c 4 µ := false while f is satisfiable with model m do b := {l | l ∈ F ∧ m(l)} ∪ {¬l | l ∈ F ∧ ¬m(l)} µ := µ ∨ b f := f ∧ ¬ b Φ := Φ ∧ µ</formula><formula xml:id="formula_9">∃ F ,F : c1 ∧ c2 ∧ c3 ∧ c4</formula><p>Constraints c1, c2, c3, c4 are the conjunction of the constraints given as the correctness criteria in Section 3.1.2 for all instructions.</p><p>The algorithm for optimal attribute inference, shown in Figure <ref type="figure" target="#fig_5">6</ref>, exploits the partial ordering between the attribute assignments. For example, if an optimization is correct without the nsw attribute in a source instruction, then the optimization is also correct with it. Similarly, if an attribute can be enabled in a target operation, then the optimization is also correct if it is turned off (although we are interested in enabling as many attributes in the target as possible).</p><p>The inner loop of the algorithm in Figure <ref type="figure" target="#fig_5">6</ref> generates all possible attribute assignments, which satisfy the correctness constraints and exploits the partial ordering of the attributes, for a given type assignment. The algorithm strengthens the set of possible attribute assignments with the disjunction of all possible attribute assignments for a given type assignment. The inner loop of the algorithm generates all possible attributes by iteratively enumerating all possible solutions by blocking each model at a time (i.e., f := f ∧¬ b). The outer loop strengthens the attribute assignments explored for each type assignment to generate the constraint (Φ), whose solution gives the optimal attribute assignment. The algorithm can be further improved to reduce the number of queries by using techniques to bias the results of the SMT solver (e.g., <ref type="bibr" target="#b18">[19]</ref>), which we leave for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Generating C++ from Alive</head><p>After a transformation has been proved correct, Alive can turn it into C++ code that uses the same instruction pattern matching library that InstCombine uses; the generated code can be linked into LLVM and used as an LLVM optimization pass. The C++ code for an optimization has two parts. First, there is an if-statement checking if the optimization should fire, which is the case when a DAG of LLVM instructions matches the Alive source template and when the precondition, if any, is met. Second, the body of the transformation creates instructions from the target template and wires them up to the source and input variables. Figure <ref type="figure" target="#fig_6">7</ref> shows an example. The generated C++ code does not attempt to clean up any instructions that might have been rendered useless by the optimization; this task is left to a subsequent dead-code elimination pass.</p><p>Translating a source template. The code generator translates the source into conditions using LLVM's pattern-matching library, and binds variables for later use. For example, match(I, m Add(m Value(b), m ConstantInt(C2))) in Figure <ref type="figure" target="#fig_6">7</ref> will return true if an LLVM instruction I is an addition of a value to a constant, and sets b and C2 to point to the arguments. Matching begins with the root instruction in the source template and recursively matches operands until all non-inputs have been bound. Although LLVM allows arbitrarily nested pattern matching, Alive currently matches each instruction in a separate clause. Alive's predicates and logical connectives directly correspond to their C++ equivalents in LLVM.</p><p>Translating a target template. A new instruction is created for each instruction that is in the target template but not the source. The root instruction from the source is replaced by its counterpart in the target.</p><p>Constants. Constant expressions translate to APInt (LLVM's arbitrary-width literal values) or Constant values, depending on the context. Arithmetic expressions and functions translate to the corresponding operations for APInt values in LLVM.</p><p>Type unification. The LLVM constructors for constant literal values and conversion instructions require explicit types. In general, this information will depend on types in the source. As Alive transformations are parametric over types, and Alive provides support for explicit and named types, such information is not readily available. The Alive code generator uses a unification-based type inference algorithm to identify appropriate types for the operands and introduces additional clauses in the if condition to ensure the operands have the appropriate type before invoking the transformation. This type system ensures that the generated code does not produce illtyped LLVM code.</p><p>The unification proceeds in three phases. First, the types of the operands in the source are unified according to the constraints in the source (e.g., the operands of a binary operator must have the same type) based on the assumption that source is a well-formed LLVM program. Second, the types of the operands in the target are similarly unified according to constraints of the target. Third, when the operands of a particular instruction in the target do not belong to the same class, then an explicit check requiring that the types are equal is inserted to the if condition in the C++ code generated. The explicit check is necessary as the target has type constraints that cannot be determined by the source alone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Implementation</head><p>We implemented Alive in Python and used the Z3 SMT solver <ref type="bibr" target="#b6">[7]</ref> to discharge both typing and refinement constraints. Alive is about 5,200 lines of open-source code. <ref type="foot" target="#foot_2">4</ref>Typing constraints are over the QF LIA (quantifier-free linear integer arithmetic) theory, and refinement constraints are either over the BV or QF BV (quantified/quantifier-free bitvector) theories. The number of possible type assignments for a transformation is usually infinite. To ensure termination we constrain integer types to have bitwidths in the range 1..64, and type nesting is limited to two levels.</p><p>Constraints c1 to c4 (Section 3.1.2) are negated before querying the SMT solver, effectively removing one quantifier alternation. Therefore, for transformations without undefined values in the source template, we obtain quantifier-free formulas, and formulas with a single quantifier otherwise. When performing attribute inference, formulas have either one or two sets of quantifiers.</p><p>Threats to validity. Alive tries to accurately reflect the semantics described in the LLVM Language Reference <ref type="bibr" target="#b17">[18]</ref>; there could be differences between our formalization and the semantics intended by the LLVM developers. Alive's bounded verification could lead it to incorrectly verify an optimization, though in our experience it is uncommon to see operands wider than 64 bits in LLVM code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Evaluation</head><p>We translated hundreds of peephole optimizations from LLVM into Alive. We verified them, we inferred optimal nsw/nuw/exact attributes for them, and we translated the Alive optimizations into C++ that we linked into LLVM and then used the resulting optimizer to build LLVM's test suite and the SPEC INT 2000 and 2006 benchmarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Translating and Verifying InstCombine</head><p>LLVM's InstCombine pass rewrites expression trees to reduce their cost, but does not change the control-flow graph. Table <ref type="table">3</ref> summarizes the 334 InstCombine transformations that we translated to Alive. Eight (2.4%) of these could not be proved correct; we reported these erroneous transformations to the LLVM developers, who confirmed and fixed them. We re-translated the fixed optimizations to Alive and proved them correct. Out of the remaining 694 transformations that we did not translate, some (such as those using vectors, call/return instructions, and floating point) cannot yet be expressed in Alive and the rest we simply have not had time to translate.</p><p>The buggiest InstCombine file that we found was MulDivRem, which implements optimizations that have multiply, divide, and remainder instructions as the root of expression trees. Out of the 44 translated optimizations, we found that six of them (14%) were incorrect.</p><p>The most common kind of bug in InstCombine was the introduction of undefined behavior, where an optimization replaces an Table <ref type="table">3</ref>. The total number of optimizations, the number of optimizations that we translated into Alive, and the number of translated optimizations that were wrong, for each file in InstCombine expression with one that is defined for a smaller range of inputs than was the original expression. There were four bugs in this category. We also found two bugs where the value of an expression was incorrect for some inputs, and two bugs where a transformation would generate a poison value for inputs that the original expression did not. Figure <ref type="figure">8</ref> provides the Alive code and the bug report numbers for the bugs that we discovered during our translation of LLVM InstCombine optimizations into Alive.</p><p>Alive usually takes a few seconds to verify the correctness of a transformation, during which time it may issue hundreds or thousands of incremental solver calls. Unfortunately, for some transformations involving multiplication and division instructions, Alive can take several hours or longer to verify the larger bitwidths. This indicates that further improvements are needed in SMT solvers to efficiently handle such formulas. In the meantime, we work around slow verifications by limiting the bitwidths of operands.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Preventing New Bugs</head><p>A few LLVM developers are already using Alive to avoid introducing wrong-code bugs. Also, we have been monitoring proposed LLVM patches and trying to catch incorrect transformations before they are committed to the tree. For example, in August 2014 a developer submitted a patch that improved the performance of one of the SPEC CPU 2000 benchmarks by 3.8%-this is obviously an interesting addition to a compiler. We used Alive to find bugs in the developer's initial and second proposed patches, and we proved that the third one was correct. This third and final patch retained the performance improvement without compromising the correctness of LLVM. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Inferring Instruction Attributes</head><p>Out of the 334 transformations we translated, Alive was able to weaken the precondition for one transformation and strengthen the postcondition for 70 (21%) transformations. The most strengthening took place for transformations in AddSub, MulDivRem, and Shifts, each with around 40% of transformations getting stronger postconditions. When a postcondition is strengthened, more instructions retain undefined behavior attributes, permitting additional optimizations to be performed. We have not yet quantified this effect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Generating C++</head><p>We removed the InstCombine optimizer from LLVM 3. Figure <ref type="figure" target="#fig_7">9</ref> reports the number of times that each optimization fired during compilation of the LLVM nightly test suite and SPEC benchmarks using LLVM+Alive at -O3. Alive optimizations fired about 87,000 times in total. Figure <ref type="figure" target="#fig_7">9</ref> also illustrates that a small number of optimizations are applied frequently. The top ten optimizations account for approximately 70% of the total invocations and there is a long tail of infrequently-used optimizations.</p><p>Compilation time. We measured the time to compile SPEC 2000 and SPEC 2006 using LLVM+Alive in comparison to LLVM 3.6 at -O3. Compilation using LLVM+Alive was on average 7% faster than LLVM because it runs only a fraction of the total InstCombine optimizations. Our C++ code generator is a proof of concept implementation and we have not yet implemented many optimizations such as reusing the results of redundant pattern-match calls.</p><p>Execution time of compiled code. We measured the execution time of the SPEC 2000 and 2006 benchmarks on their reference inputs. Code compiled with LLVM+Alive is (averaged across all SPEC benchmarks) 3% slower than code compiled with LLVM 3.6 -O3. Among these benchmarks, LLVM+Alive provides a speedup of 7% with gcc, and suffers a slowdown of 10% in the equake benchmark. The code generated with LLVM+Alive is slower with some benchmarks because we have only translated a third of the InstCombine optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head><p>Prior research on improving compiler correctness can be broadly classified into compiler testing tools, formal reasoning frameworks for compilers, and domain specific languages (DSLs). DSLs for compiler optimizations are the most closely related work to Alive. These include languages based on graph rewriting <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b26">27]</ref>, regular expressions <ref type="bibr" target="#b11">[12]</ref>, computation tree logic (CTL) <ref type="bibr" target="#b13">[14]</ref>, type systems <ref type="bibr" target="#b27">[28]</ref>, and rewrite rules <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b35">36]</ref>. While Alive is perhaps most similar to high-level rewrite patterns <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b19">20]</ref>, it differs in its extensive treatment of undefined behavior, which is heavily exploited by LLVM and other aggressive modern compilers.</p><p>Peephole optimization patterns for a particular ISA can be generated from an ISA specification <ref type="bibr" target="#b5">[6]</ref>. In contrast to compiler optimizations, optimized code sequences can be synthesized either with peephole pattern generation or through superoptimization <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b32">33]</ref>.</p><p>Optgen <ref type="bibr" target="#b3">[4]</ref> automatically generates peephole optimizations. Like Alive, Optgen operates at the IR level and uses SMT solvers to verify the proposed optimizations. While Alive focuses on verifying developer-created optimizations, Optgen generates all possible optimizations up to a specified cost and can generate a test suite to check optimizations not implemented in a given compiler. In contrast to Alive, Optgen handles only integer operations and does not handle memory operations, poison values, support any operation producing undefined behavior, or abstraction over bitwidths/types.</p><p>Random testing tools <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b36">37]</ref> have discovered numerous bugs in LLVM optimizations both for sequential programs and concurrent programs. These tools are not complete, as was shown by the bugs we found in optimizations that had previously been fuzzed.</p><p>An alternative approach to compiler correctness is translation validation <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b28">29]</ref> where, for each compilation, it is proved that the optimized code refines the unoptimized code. Many techniques and tools have been developed <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b37">38]</ref>. Translation validation appears to be a very promising approach, but it suffers from the drawback of requiring proof machinery to execute during every compilation. Our judgment was that the LLVM developers would not tolerate this, so Alive instead aims for once-and-for-all proof of correctness of a limited slice of the compiler.</p><p>The CompCert <ref type="bibr" target="#b16">[17]</ref> compiler, for a subset of C, is an end-toend verified compiler developed with the interactive proof assistant Coq. Vellvm <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b39">40]</ref> formalizes the semantics of LLVM IR, SSA properties, and optimizations in Coq. Alive's treatment of undef values mirrors the treatment in Vellvm. In contrast to Vellvm, which concretizes values in memory, Alive maintains undef values in memory, handles poison attributes, and automates reasoning with an SMT solver. Recent efforts have explored formalizing the relations of optimizations with weak memory models in Coq <ref type="bibr" target="#b34">[35]</ref>. Proving the correctness of trace optimizations (as used in, e.g., JIT compilers) has also been attempted recently <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>We have shown that an important class of optimizations in LLVMpeephole optimizations-can be formalized in Alive, a new language that makes optimizations much more concise than when they are embedded in C++ code, while also supporting automated proofs of correctness. We designed Alive to resemble LLVM's textual format while also supporting abstraction over constant values, over bitwidths of operands, and over the presence of LLVM's undefined behavior attributes that modify instruction behavior. After an Alive transformation has been proved correct, it can be automatically translated into C++ that can be included in an optimization pass. Our first goal was to create a tool that is useful for LLVM developers. We believe this goal has been accomplished. Second, we would like to see a large part of InstCombine replaced with code generated by Alive; we are still working towards that goal.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Partial Alive syntax. Types include arbitrary bitwidth integers, pointers typ * , and arrays [sz × typ] that have a staticallyknown size sz .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. An example illustrating many of Alive's features.((B ∨ V ) ∧ C1) ∨ (B ∧ C2) can be transformed to (B ∨ V ) ∧ (C1 ∨ C2) when C1 ∧ C2 = 0 and when the predicate M askedV alueIsZero(V, ¬C1) is true, indicating that an LLVM dataflow analysis has concluded that V ∧ ¬C1 = 0. %B and %V are input variables. C1 and C2 are constants. %t0, %t1, and %t2 are temporaries. This transformation is rooted at %R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Instruction Definedness Constraint sdiv a, b b = 0 ∧ (a = INT MIN ∨ b = -1) udiv a, b b = 0 srem a, b b = 0 ∧ (a = INT MIN ∨ b = -1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Table 2 .Figure 4 .</head><label>24</label><figDesc>Figure 4. Illustration of the semantics of undef. The top half of each part of the figure presents an LLVM instruction; the bottom half indicates the possible results. In (a) and (b) the compiler can choose %z to have any value in [0, 255]. In (c), %z takes an odd 8-bit value. In (d) the compiler can choose either branch.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Alive's counterexample for the incorrect transformation reported as LLVM PR21245</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Optimal attribute inference algorithm. The set b accumulates SMT variables that indicate the presence of attributes in the source (for the precondition) and absence of attributes in the target in a given model (for the postcondition). The result (Φ) is a constraint that gives all possible attribute assignments.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. An Alive transformation and its corresponding generated code. The C++ transformation is conditional on two match calls, one for each instruction in the source template, and also on the precondition. The target template has a single instruction and creates a new compile-time constant; both of these are directly reflected in the body of the C++ transformation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. The number of times each Alive optimization was invoked during compilation of the LLVM nightly suite and SPEC 2000 and 2006. The x-axis is the Alive optimization number, sorted by decreasing number of invocations. The y-axis is the number of invocations. Only 159 of these optimizations were triggered during the experiment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Figure 3. Typing rules of the Alive language. The bitwidth of a type is given by the function width(.) (e.g., width(i3) = 3 and width(i5 * ) is the pointer size, say 32 bits). A type t is smaller than a type t , written t &lt;: t , if both are integer types and the bitwidth of t is smaller than that of t (i.e., t &lt;: t iff t, t ∈ I ∧ width(t) &lt; width(t )). The extension operations are represented by extend ∈ {zext, sext}. The type dereferencing operator is denoted by @.</figDesc><table><row><cell cols="2">Γ, %x : t %x : t</cell><cell>var</cell><cell cols="3">Γ %x : t Γ binop %x, %y : t Γ %y : t</cell><cell>t ∈ I</cell><cell>binop</cell><cell>Γ %x : t Γ extend %x : t t &lt;: t</cell><cell>extend</cell><cell>Γ %x : t Γ trunc %x : t t &lt;: t trunc</cell></row><row><cell cols="5">Γ %x : t Γ inttoptr %x : t  *  t ∈ I t  *  ∈ P inttoptr</cell><cell cols="4">Γ %x : t *  Γ ptrtoint %x : t t ∈ I ptrtoint</cell><cell>Γ %x : t Γ icmp cond %x, %y : i1 Γ %y : t t ∈ I ∪ P</cell><cell>icmp</cell></row><row><cell>Γ %c : i1</cell><cell cols="4">Γ %x : t Γ select %c, %x, %y : t Γ %y : t</cell><cell>t ∈ F C</cell><cell>select</cell><cell cols="2">Γ %x : t</cell><cell>t, t ∈ F C Γ bitcast %x : t width(t) = width(t )</cell><cell>bitcast</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>n</cell><cell></cell><cell></cell></row><row><cell cols="2">t ∈ F C Γ alloca t : t *</cell><cell>alloca</cell><cell cols="2">Γ %x : t</cell><cell cols="2">@ . . . @ t : t</cell><cell cols="2">Γ %y 1...n : I gep</cell><cell>Γ %x : t *  Γ load %x : t t ∈ F C</cell><cell>load</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="6">Γ getelementptr %x, %y 1 , . . . , %y n : t  *</cell></row><row><cell cols="4">Γ %x : t Γ store %x, %y : void t ∈ F C Γ %y : t *</cell><cell>store</cell><cell cols="4">Γ unreachable : void</cell><cell>unreach</cell><cell>@t *  : t</cell><cell>pointer</cell><cell>@[n x t] : t</cell><cell>array</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>The constraints for Alive's arithmetic instructions to be defined. &lt;u is unsigned less-than. B is the bitwidth of the operands in the Alive instruction. INT MIN is the smallest signed integer value for a given bitwidth.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc><ref type="bibr" target="#b5">6</ref> and replaced it with C++ generated by Alive; we refer to the resulting compiler as LLVM+Alive. We used LLVM+Alive to build the LLVM nightly test suite and also the SPEC 2000 and 2006 benchmarks, compiling about a million lines of code overall. All experiments were performed on an Intel x86-64 machine running Ubuntu 14.04. The code compiled by LLVM+Alive did not have any unexpected test case failures: as far as we can tell, it is free of miscompilation bugs.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The latest version of Alive can be found at https://github.com/ nunoplopes/alive.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>An experimental version of Alive supports branches, but does not yet support indirect branches and loops. Pre: C1 &amp; C2 == 0 &amp;&amp; MaskedValueIsZero(%V, ∼C1) %t0 = or %B, %V %t1 = and %t0, C1 %t2 = and %B, C2 %R = or %t1, %t2 =&gt; %R = and %t0, (C1 | C2)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>The version of Alive corresponding to this paper can be found at https: //github.com/nunoplopes/alive/tree/pldi15.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors thank the LLVM developers for their continued support for the development of Alive, for discussions regarding LLVM IR's semantics, and for adopting Alive. A special thanks to David Majnemer for confirming and fixing the bugs we reported. Eric Eide and Raimondas Sasnauskas provided valuable feedback on this work. This paper is based upon work supported in part by NSF CAREER Award CCF-1453086, NSF Award CNS-1218022, and a Google Faculty Award.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Solvable Cases of the Decision Problem</title>
		<author>
			<persName><forename type="first">W</forename><surname>Ackermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Logic and the Foundations of Mathematics</title>
		<imprint>
			<date type="published" when="1954">1954</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">How to uniformly specify program analysis and transformation with graph rewrite systems</title>
		<author>
			<persName><forename type="first">U</forename><surname>Aßmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th International Conference on Compiler Construction</title>
		<meeting>of the 6th International Conference on Compiler Construction</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="121" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automatic generation of peephole superoptimizers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems (ASP-LOS)</title>
		<meeting>of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems (ASP-LOS)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="394" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Optgen: A generator for local optimizations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Buchwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 24th International Conference on Compiler Construction (CC)</title>
		<meeting>of the 24th International Conference on Compiler Construction (CC)</meeting>
		<imprint>
			<date type="published" when="2015-04">Apr. 2015</date>
			<biblScope unit="page" from="171" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficiently computing static single assignment form and the control dependence graph</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cytron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ferrante</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">K</forename><surname>Zadeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="451" to="490" />
			<date type="published" when="1991-10">Oct. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatic generation of peephole optimizations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fraser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1984 SIGPLAN Symposium on Compiler Construction</title>
		<meeting>of the 1984 SIGPLAN Symposium on Compiler Construction</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="111" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Z3: An efficient SMT solver</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">De</forename><surname>Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</title>
		<meeting>of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Tracing compilation by abstract interpretation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dissegna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Logozzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ranzato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="47" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Broadway: A compiler for exploiting the domainspecific semantics of software libraries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Guyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">93</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Will you still compile me tomorrow? Static cross-version compiler validation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hawblitzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Lahiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pawar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gokbulut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fernando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wadsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Joint Meeting on Foundations of Software Engineering (FSE)</title>
		<meeting>of the 9th Joint Meeting on Foundations of Software Engineering (FSE)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Denali: A practical algorithm for generating optimal code</title>
		<author>
			<persName><forename type="first">R</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="967" to="989" />
			<date type="published" when="2006-11">Nov. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Certification of compiler optimizations using Kleene algebra with tests</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-C</forename><surname>Patron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1st International Conference on Computational Logic</title>
		<meeting>of the 1st International Conference on Computational Logic</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="568" to="582" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Proving optimizations correct using parameterized program equivalence</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kundu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Tatlock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>of the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="327" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Compiler optimization correctness by temporal logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lacey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Van Wyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Frederiksen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Higher Order Symbol. Comput</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="173" to="206" />
			<date type="published" when="2004-09">Sept. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Compiler validation via equivalence modulo inputs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Afshari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="216" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Automated soundness proofs for dataflow analyses and transformations via local rules</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="364" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Formal verification of a realistic compiler</title>
		<author>
			<persName><forename type="first">X</forename><surname>Leroy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="107" to="115" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">LLVM Language Reference Manual</title>
		<author>
			<persName><surname>Developers</surname></persName>
		</author>
		<ptr target="http://llvm.org/docs/LangRef.html" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Weakest precondition synthesis for compiler optimizations</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Monteiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th International Conference on Verification, Model Checking, and Abstract Interpretation</title>
		<meeting>of the 15th International Conference on Verification, Model Checking, and Abstract Interpretation</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="203" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Automatic equivalence checking of programs with uninterpreted functions and integer arithmetic</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Monteiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Softw. Tools Technol. Transf</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A cross-language framework for verifying compiler optimizations</title>
		<author>
			<persName><forename type="first">W</forename><surname>Mansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gunter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th Workshop on Syntax and Semantics of Low-Level Languages</title>
		<meeting>of the 5th Workshop on Syntax and Semantics of Low-Level Languages</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Superoptimizer: A look at the smallest program</title>
		<author>
			<persName><forename type="first">H</forename><surname>Massalin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2nd International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>of the 2nd International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="122" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Differential testing for software</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Mckeeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digital Technical Journal</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="100" to="107" />
			<date type="published" when="1998-12">Dec. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Compiler testing via a theory of sound optimisations in the C11/C++11 memory model</title>
		<author>
			<persName><forename type="first">R</forename><surname>Morisset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pawan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Nardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="187" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Translation validation for an optimizing compiler</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation</title>
		<meeting>of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="83" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Translation validation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Siegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Singerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 4th International Conference on Tools and Algorithms for Construction and Analysis of Systems</title>
		<meeting>of the 4th International Conference on Tools and Algorithms for Construction and Analysis of Systems</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="151" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Hoopl: A modular, reusable library for dataflow analysis and transformation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ramsey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 3rd ACM Symposium on Haskell</title>
		<meeting>of the 3rd ACM Symposium on Haskell</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Program and proof optimizations with type systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Saabas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Uustalu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Logic and Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="131" to="154" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Proving the correctness of heuristically optimized code</title>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communications of the ACM</title>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Stochastic superoptimization</title>
		<author>
			<persName><forename type="first">E</forename><surname>Schkufza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 18th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>of the 18th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Translation validation for a verified OS kernel</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A L</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Myreen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="471" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Equality-based translation validator for LLVM</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stepp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 23rd International Conference on Computer Aided Verification</title>
		<meeting>of the 23rd International Conference on Computer Aided Verification</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="737" to="742" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Generating compiler optimizations from proofs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stepp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Evaluating value-graph translation validation for LLVM</title>
		<author>
			<persName><forename type="first">J.-B</forename><surname>Tristan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Govereau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morrisett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="295" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Common compiler optimisations are invalid in the C11 memory model and what we can do about it</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Balabonski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morisset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Nardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 42nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>of the 42nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An approach for exploring code improving transformations</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Whitfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Soffa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1053" to="1084" />
			<date type="published" when="1997-11">Nov. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Finding and understanding bugs in C compilers</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Eide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Regehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="283" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">CoVaC: Compiler validation by program analysis of the cross-product</title>
		<author>
			<persName><forename type="first">A</forename><surname>Zaks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th International Symposium on Formal Methods</title>
		<meeting>of the 15th International Symposium on Formal Methods</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="35" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Formalizing the LLVM intermediate representation for verified program transformations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nagarakatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="427" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Formal verification of SSA-based optimizations for LLVM</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nagarakatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="175" to="186" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
