<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SORTING PERMUTATIONS BY REVERSALS AND EULERIAN CYCLE DECOMPOSITIONS *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="1999-01-29">January 29, 1999</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Alberto</forename><surname>Caprara</surname></persName>
							<email>acaprara@deis.unibo.it</email>
							<affiliation key="aff0">
								<orgName type="institution">Santa Fe</orgName>
								<address>
									<postCode>1997</postCode>
									<region>NM</region>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">DEIS</orgName>
								<orgName type="institution">Università di Bologna</orgName>
								<address>
									<addrLine>Viale Risorgimento 2</addrLine>
									<postCode>I-40136</postCode>
									<settlement>Bologna</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SORTING PERMUTATIONS BY REVERSALS AND EULERIAN CYCLE DECOMPOSITIONS *</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="1999-01-29">January 29, 1999</date>
						</imprint>
					</monogr>
					<idno type="MD5">D8AB563142778A9863C0EA687A42678D</idno>
					<note type="submission">Received by the editors April 21, 1997; accepted for publication (in revised form) August 12, 1998;</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>sorting by reversals</term>
					<term>breakpoint graph</term>
					<term>Eulerian graph</term>
					<term>cycle decomposition</term>
					<term>complexity AMS subject classifications. 68Q25</term>
					<term>68R10</term>
					<term>05C45</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We analyze the strong relationship among three combinatorial problems, namely, the problem of sorting a permutation by the minimum number of reversals (MIN-SBR), the problem of finding the maximum number of edge-disjoint alternating cycles in a breakpoint graph associated with a given permutation (MAX-ACD), and the problem of partitioning the edge set of an Eulerian graph into the maximum number of cycles (MAX-ECD). We first illustrate a nice characterization of breakpoint graphs, which leads to a linear-time algorithm for their recognition. This characterization is used to prove that MAX-ECD and MAX-ACD are equivalent, showing the latter to be NP-hard. We then describe a transformation from MAX-ACD to MIN-SBR, which is therefore shown to be NP-hard as well, answering an outstanding question which has been open for some years. Finally, we derive the worst-case performance of a well-known lower bound for MIN-SBR, obtained by solving MAX-ACD, discussing its implications on approximation algorithms for MIN-SBR.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>1. Introduction. Let π = (π 1 . . . π n ) be a permutation of {1, . . . , n}, and denote by ι the identity permutation (1 2 . . . n -1 n). A reversal of the interval (i, j) is an inversion of the subsequence π i . . . π j of π, represented by the permutation ρ = (1 . . . i -1 j . . . i j + 1 . . . n). Composition of π with ρ yields πρ = (π 1 . . . π i-1 π j . . . π i π j+1 . . . π n ), where elements π i , . . . , π j have been reversed. The problem of sorting a permutation by the minimum number of reversals (MIN-SBR) is defined as follows.</p><p>MIN-SBR: Given a permutation π, find a shortest sequence of reversals ρ 1 , . . . , ρ d(π) such that πρ 1 . . . ρ d(π) = ι. The optimal solution value d(π) is called the reversal distance of π.</p><p>MIN-SBR was inspired by computational biology applications, in particular by genome rearrangements, and has been widely studied in the last years by Kececioglu and Sankoff <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b14">15]</ref>; Bafna and Pevzner <ref type="bibr" target="#b0">[1]</ref>; Hannenhalli and Pevzner <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>; Caprara, Lancia, and Ng <ref type="bibr" target="#b5">[6]</ref>; Berman and Hannenhalli <ref type="bibr" target="#b1">[2]</ref>; Irving and Christie <ref type="bibr" target="#b12">[13]</ref>; Tran <ref type="bibr" target="#b19">[20]</ref>; Kaplan, Shamir, and Tarjan <ref type="bibr" target="#b13">[14]</ref>; Christie <ref type="bibr" target="#b6">[7]</ref>; and Caprara <ref type="bibr" target="#b4">[5]</ref>, among others.</p><p>Until recently, most evolutionary studies in molecular biology were based on sequence alignment, i.e., comparison of single genes to detect local mutations in the sequence of nucleotides. However, in the last few years, we have witnessed an increasing interest in analyzing entire genomes at once, thus shifting the attention from gene level to chromosome level (Sankoff et al. <ref type="bibr" target="#b18">[19]</ref>, Sankoff <ref type="bibr" target="#b17">[18]</ref>). In fact, as it is often found 92 ALBERTO CAPRARA that the order of genes is preserved more easily than the DNA sequence (see <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b20">21]</ref>), looking at genes instead of DNA sequences allows one to construct some otherwise extremely difficult evolutionary scenarios; this is particularly true for plant mitochondrial DNA, virology, and Drosophila genetics. Rearrangement of genomes can occur in many different ways, among which we can number inversions, transpositions, deletions, insertions, and duplications of fragments.</p><p>Let the order of the genes in two single-chromosome organisms be given by two permutations π and τ of {1, . . . , n}. An inversion of the segment comprising the genes from the ith to the jth is represented by a reversal of the interval (i, j). A shortest sequence of reversals needed to transform π into τ is clearly equal to an optimal solution of MIN-SBR on τ -1 π. Therefore, the solution of MIN-SBR yields a possible scenario to explain how an organism evolved from another, under the simplifying assumptions that inversions were the only rearrangement to occur, and that evolution required the minimum number of rearrangements. Even if these assumptions lead to some approximation, both are well motivated. Indeed, on the one hand inversions are by far the most frequent type of rearrangement, and on the other hand rearrangements are very rare events.</p><p>The breakpoint graph associated with a permutation has always played a key role in the study of MIN-SBR. In particular, the problem of finding a maximum alternating-cycle decomposition (MAX-ACD) of a breakpoint graph, defined in the next section, is very closely related to MIN-SBR. This strong relationship was first pointed out by Bafna and Pevzner <ref type="bibr" target="#b0">[1]</ref> and Kececioglu and Sankoff <ref type="bibr" target="#b15">[16]</ref> and was later considered by Hannenhalli and Pevzner <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. As will be clear from its definition, MAX-ACD is very similar to the following problem, called maximum Eulerian cycle decomposition (MAX-ECD).</p><p>MAX-ECD: Given an Eulerian graph H = (W, E), find a maximum-cardinality cycle decomposition of H, i.e., partition E into the maximum number of cycles.</p><p>In this paper we further analyze the relationship between MIN-SBR, MAX-ACD, and MAX-ECD, deriving several results about the three problems.</p><p>One major open question about MIN-SBR is its complexity: although the problem was conjectured to be NP-hard back in 1993 by Kececioglu and Sankoff <ref type="bibr" target="#b15">[16]</ref>, nobody has been able to come up with a proof of this conjecture so far. In particular, the question appears as Problem 1 in the open problem list of Pevzner and Waterman <ref type="bibr" target="#b16">[17]</ref> and is mentioned in the Crescenzi-Kann list of NP-hard problems; see entry MS9 in <ref type="bibr" target="#b7">[8]</ref>. A stronger conjecture of Kececioglu and Sankoff <ref type="bibr" target="#b15">[16]</ref> claimed that the special case of MIN-SBR, where, for a given π, one wants to check whether d(π) is equal to 2. Basic definitions and previous results. In this section we give the basic definitions and previous results that we will use in what follows.</p><p>Consider a permutation π = (π 1 . . . π n ) of {1, . . . , n}. Following the description in <ref type="bibr" target="#b0">[1]</ref>, define the breakpoint graph G(π) = (V, B ∪ C) of π as follows. Add to π the elements π 0 := 0 and π n+1 := n + 1, redefining π := (0 π 1 . . . π n n + 1). Also, let the inverse permutation π -1 of π be defined by π -1 πi := i for i = 0, . . . , n + 1. Let V := {0, . . . , n + 1}, where each node v ∈ V represents an element of π. Graph G(π) is bicolored, i.e., its edge set is partitioned into two subsets, each represented by a different color. B is the set of black edges, each of the form (π i , π i+1 ), for all i ∈ {0, . . . , n} such that |π iπ i+1 | = 1, i.e., elements which are in consecutive positions in π but not in the identity permutation ι. Such a pair π i , π i+1 is called a breakpoint of π. Let b(π) := |B| be the number of breakpoints of π. C is the set of gray edges, each of the form (i, i + 1), for all i ∈ {0, . . . , n} such that |π -1 iπ -1 i+1 | = 1, i.e., elements which are in consecutive positions in ι but not in π. Note that each node i ∈ V has either degree 0, 2, or 4, and has the same number of incident gray and black edges. Therefore, |B| = |C|(= b(π)). </p><formula xml:id="formula_0">i = b j , c i = c j for 1 ≤ i &lt; j ≤ m.</formula><p>For example, edges (0, 4), <ref type="bibr" target="#b3">(4,</ref><ref type="bibr" target="#b2">3)</ref>, <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b0">1)</ref>, (1, 0) and (4, 2), (2, 3), <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b4">5)</ref>, <ref type="bibr" target="#b4">(5,</ref><ref type="bibr" target="#b3">4)</ref> form alternating cycles in the graph of Figure <ref type="figure" target="#fig_0">1</ref>. An alternating path is a subsequence of consecutive edges of some alternating cycle. It is sometimes convenient to assign each edge (π i , π i+1 ) ∈ B an orientation from π i to π i+1 , i.e., to orient the black edges of G from the endpoint which appears first in π to the endpoint which appears second. An alternating cycle of G(π) is then called unoriented with respect to π if it is possible to walk along the whole cycle traversing each black edge in the direction of its orientation, oriented with respect to π otherwise. For example, in Figure <ref type="figure" target="#fig_0">1</ref> alternating cycle (4, 2), (2, 3), <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b4">5)</ref>, <ref type="bibr" target="#b4">(5,</ref><ref type="bibr" target="#b3">4)</ref> is unoriented with respect to (4 2 1 3), whereas alternating cycle (0, 4), (4, 3), <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b0">1)</ref>, (1, 0) is oriented with respect to (4 2 1 3).</p><p>An alternating-cycle decomposition of G(π) is a collection of edge-disjoint alternating cycles, such that every edge of G is contained in exactly one cycle of the collection. It is easy to see that G(π) always admits an alternating-cycle decomposition. In the graph of Figure <ref type="figure" target="#fig_0">1</ref>, alternating cycles (0, 4), (4, 3), <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b0">1)</ref>, (1, 0) and (4, 2), (2, 3), <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b4">5)</ref>, <ref type="bibr" target="#b4">(5,</ref><ref type="bibr" target="#b3">4)</ref> form an alternating-cycle decomposition. For a given π let c(π) be the maximum cardinality of an alternating-cycle decomposition of G(π). Bafna and Pevzner <ref type="bibr" target="#b0">[1]</ref> (see also <ref type="bibr">Kececioglu and Sankoff [16]</ref>) proved the following property. Theorem 1 (See <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b15">[16]</ref>). For every permutation π, d(π) ≥ b(π)c(π). Therefore b(π)c(π) gives a valid lower bound on the optimal solution value to MIN-SBR. In practical cases this bound turns out to be very tight and is frequently equal to the optimum, as confirmed by the extensive experiments of Kececioglu and Sankoff <ref type="bibr" target="#b15">[16]</ref> and Caprara, Lancia, and Ng <ref type="bibr" target="#b5">[6]</ref>. This empirical observation was recently formalized by Caprara <ref type="bibr" target="#b4">[5]</ref>, who showed that the probability that d(π) &gt; b(π)c(π) for a random permutation π of n elements is O(1/n 5 ).</p><p>The signed version of MIN-SBR is a relevant variant of the problem, which was shown to be solvable in polynomial time by <ref type="bibr">Hannenhalli and Pevzner [10]</ref>. This variant calls for sorting a permutation by the minimum number of reversals, with a parity assigned to each element of the permutation, specifying that, in a solution, the number of reversals involving the element must be either even, in which case the element is called even, or odd, in which case it is called odd. A permutation with a parity assigned to each element is called signed and is denoted by π. Note that any sequence of reversals which sorts π corresponds to a feasible solution of MIN-SBR on π, the permutation obtained from π by neglecting the parity of the elements. Hence, letting d( π) denote the optimal solution value of signed MIN-SBR on π, one has that d( π) ≥ d(π).</p><p>The breakpoints and the breakpoint graph of a signed permutation π with n elements correspond to those associated with the unsigned permutation ν with 2n elements defined by</p><formula xml:id="formula_1">ν 2i-1 := 2 π i -1, ν 2i := 2 π i if element π i is even, ν 2i-1 := 2 π i , ν 2i := 2 π i -1 if element π i is odd, for i = 1, . . . , n.</formula><p>Accordingly, in the breakpoint graph G( π) associated with π, all nodes have degree 0 or 2; hence there is a unique alternating-cycle decomposition whose cardinality is denoted by c( π). Bafna and Pevzner showed that Theorem 1 also applies to signed permutations, i.e., d( π) ≥ b( π)c( π), where b( π) is the number of breakpoints of π, equal to b(ν). Figure <ref type="figure" target="#fig_2">2</ref> depicts the breakpoint graph associated with π = (3 1 2) where element 3 is even and elements 1 and 2 are odd, hence ν = (5 6 2 1 4 3).</p><p>The following definitions follow those of Hannenhalli and Pevzner <ref type="bibr" target="#b9">[10]</ref>. The orientation of the black edges of G( π) with respect to π is defined as their orientation with respect to ν. Two gray edges (ν i , ν h ) and (ν j , ν k ) of G( π) are called interleaving if their endpoints are such that either i &lt; j &lt; h &lt; k or i &gt; j &gt; h &gt; k. In the example of Figure <ref type="figure" target="#fig_2">2</ref>, gray edges (0, 1) and (6, 7) are interleaving, while edges (6, 7) and <ref type="bibr" target="#b1">(2,</ref><ref type="bibr" target="#b2">3)</ref> are not. Two alternating cycles A 1 and A 2 of G( π) are called interleaving if there are two interleaving edges e 1 ∈ A 1 and e 2 ∈ A 2 . The interleaving graph H( π) associated with π has one node A associated with each alternating cycle A of G( π) and one edge (A 1 , A 2 ) associated with each pair of interleaving cycles A 1 and A 2 . The interleaving graph associated with the signed permutation of Figure <ref type="figure" target="#fig_2">2</ref> has two nodes connected by an edge as edges (0, 1) and (6, 7) are interleaving.</p><p>Hannenhalli and Pevzner <ref type="bibr" target="#b9">[10]</ref> define the parameters h( π) and f ( π), both related to the structure of H( π). For the scope of this paper, we avoid giving the definition of h( π) and f ( π) but simply stress that h( π) + f ( π) is at most equal to the number of connected components of H( π) in which all nodes correspond to unoriented alternating cycles. The main result proved by Hannenhalli and Pevzner in <ref type="bibr" target="#b9">[10]</ref> is in the following.</p><p>Theorem 2 (See <ref type="bibr" target="#b9">[10]</ref>). For every signed permutation π, d( π</p><formula xml:id="formula_2">) = b( π) -c( π) + h( π) + f ( π).</formula><p>As a corollary, one gets that d( π) = b( π)c( π) if every alternating cycle of G( π) is oriented. We note that this condition is only sufficient. The above theorem leads to a polynomial time algorithm for signed MIN-SBR. At present, the most efficient algorithm is due to Kaplan, Shamir, and Tarjan <ref type="bibr" target="#b13">[14]</ref>.</p><p>Theorem 3 (See <ref type="bibr" target="#b13">[14]</ref>). The signed version of MIN-SBR can be solved in O(n 2 ) time.</p><p>Signed permutations can be used to establish an elegant connection between alternating-cycle decompositions and solutions of MIN-SBR, as illustrated next.</p><p>Given a (unsigned) permutation π and an alternating-cycle decomposition of G(π) into, say, p cycles, it is easy to assign a parity to the elements of π so that the resulting signed permutation π satisfies b( π) = b(π) and c( π) = p. The main idea is to decide whether each element of π must be even or odd so as to ensure that the unique alternating-cycle decomposition of G( π) coincides with the given alternating-cycle decomposition of G(π); see <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b5">6]</ref> for details. For our purposes, it is important to observe that every alternating cycle of G( π) is oriented with respect to π if and only if its counterpart in the decomposition of G(π) is oriented with respect to π. Therefore, assuming that p = c(π), i.e., the given alternating-cycle decomposition is optimal, and that every cycle in the decomposition is oriented with respect to π, one has</p><formula xml:id="formula_3">d(π) ≤ d( π) = b( π) -c( π) = b(π) -c(π) ≤ d(π),</formula><p>hence implying the following theorem.</p><p>Theorem 4 (See <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>). For a permutation π and a maximum decomposition of G(π) into c(π) alternating cycles, if every cycle in the decomposition is oriented with respect to π, then</p><formula xml:id="formula_4">d(π) = b(π) -c(π).</formula><p>The above discussion motivates the study of the following MAX-ACD problem. MAX-ACD: Given the breakpoint graph G(π) of a given permutation π, find a maximum-cardinality alternating-cycle decomposition of G(π).</p><p>As one can observe, MAX-ACD is somehow related to MAX-ECD, defined in the previous section. In the early 1980s Holyer <ref type="bibr" target="#b11">[12]</ref> proved that checking whether the edge set of a given graph H can be partitioned into cliques of size k is NP-complete for every k ≥ 3. In particular, for k = 3 one wants to check whether the edge set of H can be partitioned into triangles. In this case H can be assumed to be Eulerian without loss of generality, the answer clearly being no otherwise. So the problem of determining whether the edge set of an Eulerian graph can be partitioned into triangles is NP-complete. This immediately implies the following theorem.</p><p>Theorem 5 (See <ref type="bibr" target="#b11">[12]</ref>). MAX-ECD is NP-hard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A nice characterization of breakpoint graphs.</head><p>In this section we characterize the bicolored graphs which are breakpoint graphs of some permutation. In particular, we derive a linear-time algorithm which checks whether a given bicolored graph is a breakpoint graph and, if this is the case, yields an associated permutation. These results will be used in the next sections.</p><p>To simplify the notation, given a (possibly bicolored) graph G = (V, E) and any set F ⊆ {(i, j) : i, j ∈ V, i = j} (possibly F ⊆ E), we let G(F ) denote the subgraph of G induced by F , defined by node set V \ I, where I is the set of nodes not contained in any pair in F , and edge set F . Furthermore, we write ) such that G(π) = G can be constructed as follows. First of all, if G has no node of degree 0, let P := M . Otherwise, let i 1 , . . . , i k denote the nodes of degree 0 in G, arbitrarily choose (i, j) ∈ M , and let P := (M \ {(i, j)}) ∪ {(i, i 1 ), (i 1 , i 2 ), . . . , (i k-1 , i k ), (i k , j)}; i.e., P is obtained from M by replacing edge (i, j) with the edges in a path from i to j visiting all the nodes of degree 0 in G. Both G(B ∪ P ) and G(C ∪ P ) are Hamiltonian circuits visiting all the nodes of G. Then, choose any node i ∈ U and number it 0. Consider the Hamiltonian circuit G(C ∪ P ), and walk along it starting from i, first traversing the gray edge incident to i. Number the nodes 1, 2, . . . , |V | -1 according to the order in which they are visited by the walk. Now consider the Hamiltonian circuit G(B ∪ P ), and walk along it starting from node i, letting π 0 := 0, and first traversing the black edge incident to i. Let elements π 1 , π 2 , . . . , π |V |-1 correspond to the numbers assigned to the nodes which are in turn visited by the walk. It is easy to verify that G(π) = G.</p><formula xml:id="formula_5">G 1 = G 2 to indicate that two graphs G 1 and G 2 are isomorphic. Definition 1. A bicolored graph G = (V, B ∪ C) is called balanced bicolored if (i) each connected</formula><p>Conversely, for any given permutation π of {1, . . . n} such that G(π) = G, let</p><formula xml:id="formula_6">P := ({(i, i + 1) : 0 ≤ i ≤ n} \ C) ∪ {(0, n + 1)} = ({(π i , π i+1 ) : 0 ≤ i ≤ n} \ B) ∪ {(0, n + 1)}.</formula><p>It is easy to verify that G(P ) is a set of paths whose endpoints are the nodes of degree 2 in G and whose intermediate nodes are the nodes of degree 0 in G. Moreover, the set M containing all pairs (i, j) such that there is a maximal path from i to j in G(P ) is a Hamiltonian matching of G.</p><p>For example, the Hamiltonian matching of G(π) in Figure <ref type="figure" target="#fig_0">1</ref> defined by π is M = {(1, 2), (0, 5)}. Matching M is also associated with the permutation (2 4 3 1), whose breakpoint graph is isomorphic to G(π).</p><p>Note that given a breakpoint graph G and an associated Hamiltonian matching M , the Hamiltonian circuit G(B ∪ M ) uniquely determines which alternating cycles of G are unoriented or oriented with respect to every permutation associated with G and M .</p><p>We show that every balanced bicolored graph has a Hamiltonian matching by giving a procedure to find such a matching. Given a balanced bicolored graph G, construct the following auxiliary graph A = (U, D ∪ E), where nodes i, j ∈ U are connected by a black edge d ∈ D if there is a maximal path in G(B) from i to j, and, symmetrically, nodes i, j ∈ U are connected by a gray edge e ∈ E if there is a maximal path in G(C) from i to j. It is easy to verify that each node of A has exactly 2 incident edges, one in D and one in E. (Note that A is not necessarily a balanced bicolored graph, since a black edge in D and a gray edge in E might have the same endpoints.) Figure <ref type="figure">3</ref>  choose any node pair i, j ∈ U such that (i, j) ∈ D ∪ E; comment: remove i and j (see Figure <ref type="figure">4</ref>); let a and b respectively be the nodes connected to i and j by a black edge in D, and c and d respectively be the nodes connected to i and j by a gray edge in E; nodes connected by an edge in D (resp., in E), which is avoided.</p><formula xml:id="formula_7">let U := U \ {i, j}, D := (D \ {(i, a), (j, b)}) ∪ {(a, b)}, E := (E \ {(i, c), (j, d)}) ∪ {(c, d)}, A := (U, D ∪ E); call HAMILTONIAN MATCHING(A, M ); let M := M ∪ {(i, j)} end end.</formula><p>For graph G(π) in Figure <ref type="figure" target="#fig_0">1</ref>, M = {(1, 2), (0, 5)} is the only possible Hamiltonian matching; see Figure <ref type="figure">3</ref>.</p><p>From the above lemmas we get the following theorem. Theorem 6. Every balanced bicolored graph is isomorphic to the breakpoint graph of some permutation, and vice versa.</p><p>Proof. Every breakpoint graph satisfies, by definition, (i)-(iii) in Definition 1. Conversely, given a balanced bicolored graph G, by Lemma 2 it is possible to find a Hamiltonian matching of G and hence, by Lemma 1, a permutation π such that G(π) = G.</p><p>The above discussion leads to a linear-time recognition algorithm for breakpoint graphs.</p><p>Corollary 1. Given a bicolored graph G = (V, B ∪ C), it is possible to check in O(|V |) time whether G is a breakpoint graph, obtaining an associated permutation if the answer is positive.</p><p>Proof. Suppose the given bicolored graph G = (V, B ∪ C) is stored using one vector of length |V | containing the number of black and gray edges incident to each node, and two vectors of length 2|V |, one for each edge color, where entries 2i -1 and 2i contain the nodes connected to node i by gray and black edges, respectively. (If a node turns out to have a different number of incident gray and black edges, or more  Given a bicolored graph G = (V, B ∪ C), the subdivision of an edge e = (i, j) ∈ B ∪ C is obtained by adding two new nodes, say a, b, to V , and replacing e by the 3 edges (i, a), (a, b), and (b, j), where (i, a) and (b, j) have the same color as e, while (a, b) has a different color from e; see Figure <ref type="figure" target="#fig_7">6</ref>.</p><p>Remark 1. There is a one-to-one correspondence between alternating cycles (and alternating-cycle decompositions) of a bicolored graph G and any bicolored graph G ′ obtained from G by subdividing edges.</p><p>Edge subdivision and analogous operations in breakpoint graphs have been used in the literature for different purposes; see, for example, <ref type="bibr" target="#b9">[10]</ref> and <ref type="bibr" target="#b5">[6]</ref>. In this paper, edge subdivision plays an important role in the analysis of the complexity of MIN-SBR in section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The equivalence of MAX-ECD and MAX-ACD.</head><p>In this section we show that MAX-ECD and MAX-ACD can be rather easily transformed into each other. The main implications of our constructions are that MAX-ACD is NP-hard, that any approximation algorithm for MAX-ACD with a given worst-case performance can be used for solving MAX-ECD with the same worst-case performance, and that MAX-ECD is NP-hard even if restricted to Eulerian graphs with degree at most 4.</p><p>The transformation from MAX-ACD to MAX-ECD works as follows. Let G = (V, B ∪ C) be any balanced bicolored graph. Define the Eulerian graph H G from G by replacing every degree-4 node in V by the graph X(i) in Figure <ref type="figure">7</ref>. Formally, each degree-4 node i ∈ V having incident black edges (i, a) and (i, c) and incident gray edges (i, b) and (i, d) is replaced by nodes i 0 , i 1 , i 2 , i 3 , i 4 , by (uncolored) edges (i 0 , i 1 ), (i 0 , i 2 ), (i 0 , i 3 ), (i 0 , i 4 ), (i 1 , i 2 ), (i 2 , i 3 ), (i 3 , i 4 ), (i 4 , i 1 ), by black edges (i 1 , a), (i 3 , c), and by gray edges (i 2 , b), (i 4 , d). After all the original degree-4 nodes of G have been replaced, graph H G is obtained by simply forgetting about the color of the edges. Note that every node of H G has degree at most 4. Letting s be the number of degree-4 nodes in G, it would be easy to show that there is a one-to-one correspondence between alternating-cycle decompositions of G into p cycles and cycle decompositions of H G into p + 2s cycles, 2s of which are triangles internal to the X(i)'s, proving the following.</p><p>Theorem 7. Given a balanced bicolored graph G, MAX-ACD on G can be solved by solving MAX-ECD on graph H G , whose size is linear in the size of G and where every node has degree at most 4. For a detailed proof, see the original technical report <ref type="bibr" target="#b2">[3]</ref>. Unfortunately, the transformation presented does not preserve approximability, since the optimal solutions of MAX-ACD on G and MAX-ECD on H G differ by twice the number of degree-4 nodes in G.</p><formula xml:id="formula_8">b 1 b 2 b 3 b 4 b 5 b 6 b 7 b 8 p 1 p 2 p 3 p 4 q 1 q 2 q 3 q 4 q 5 r 1 r 2 r</formula><p>In order to show a polynomial transformation of MAX-ECD into MAX-ACD, we need some preliminary definitions and lemmas.</p><p>Let d be an even integer and s := d/2. The bicolored graph Y (d) is defined by node set {b 1 , . . . , b d } ∪ {p 1 , . . . , p s } ∪ {q 1 , . . . , q s+1 } ∪ {r 1 , . . . , r s } ∪ {t 1 , . . . , t d }, by black edge set {(p i , q i ), (p i , q i+1 ), i = 1, . . . , s} ∪ {(r i , t 2i-1 ), (r i , t 2i ), i = 1, . . . , s}, and by gray edge set {(b 2i-1 , p i ), (b 2i , p i ), i = 1, . . . , s} ∪ {(q i , r i ), (q i+1 , r i ), i = 1, . . . , s}. Graph Y (8) is depicted in Figure <ref type="figure">8</ref>.</p><p>Let Z(d, m) be the bicolored graph obtained by merging m copies of e e e e p 1 1 i , p j i , q j i , r j i , and t j i denote, respectively, the nodes in Z(d, m) corresponding to nodes b i , p i , q i , r i , and t i in Y j (d). In particular, for i = 1, . . . , d and j = 1, . . . , m -1, nodes t is then the following. Given an Eulerian graph H = (W, E), the bicolored graph G H is obtained from H by replacing each i ∈ W , of degree d i , by the graph Z(i) := Z(d i , m(d i )) and then, for each (i, j) ∈ F , by connecting two degree-1 nodes of Z(i) and Z(j) by a black edge. This connection is easily made so that all degree-1 nodes of Z(i), i ∈ W , have exactly one incident black edge. Note that the size of Z(i) is proportional to d 3 i . It is then clear by Lemma 4 that given a cycle decomposition of H into p cycles we can find an alternating-cycle decomposition of G H into p cycles, and vice versa. Finally, G H is clearly balanced bicolored.</p><formula xml:id="formula_9">p 1 2 p 1 3 p 1 4 q 1 1 q 1 2 q 1 3 q 1 4 q 1 5 Y 1 (8) r 1 1 r 1 2 r 1 3 r 1 4 l 1 ≡ b 1 1 l 2 ≡ b 1 2 l 3 ≡ b 1 3 l 4 ≡ b 1 4 l 5 ≡ b 1 5 l 6 ≡ b 1 6 l 7 ≡ b 1 7 l 8 ≡ b 1 8 t 1 1 ≡ b 2 1 t 1 2 ≡ b 2 2 t 1 3 ≡ b 2 3 t 1 4 ≡ b 2 4 t 1 5 ≡ b 2 5 t 1 6 ≡ b 2 6 t 1</formula><p>To summarize, we have proved the following theorem. Theorem 8. Given an Eulerian graph H, MAX-ECD on H can be solved by solving MAX-ACD on the balanced bicolored graph G H , whose size is linear in the size of H and in d 3 H , where d H is the maximum degree of a node of H. From Theorems 5, 6, and 8 we immediately get the following result. Corollary 2. MAX-ACD is NP-hard. The following remark stresses a property of the above transformation from MAX-ECD to MAX-ACD.</p><p>Remark 2. The above transformation from MAX-ECD to MAX-ACD preserves approximability, namely, to each solution of MAX-ECD on H there corresponds a solution of MAX-ACD on G H of the same value, and vice versa.</p><p>Unfortunately, we are not aware of any approximability result for MAX-ACD (and MAX-ECD); see also the next section.</p><p>We conclude this section with another NP-hardness result, which is a consequence of Theorem 7 and Corollary 2.</p><p>Corollary 3. MAX-ECD restricted to Eulerian graphs with maximum degree 4 is NP-hard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The complexity of MIN-SBR.</head><p>In this section we give a transformation from MAX-ACD to MIN-SBR, showing the latter is NP-hard. The transformation makes extensive use of the breakpoint graph characterization illustrated in section 3.</p><p>A possible way of reading Theorem 4 is the following. Given a breakpoint graph G(π) of some permutation π, it would be possible to compute c(π) by solving MIN- </p><formula xml:id="formula_10">G * G * (B * ∪ M * ) G * (C * ∪ M * ) i j i j k1 k2 k3 k4 i j a b i j k1 k4 a b k2 k3 a b a b k2 k1 k4 k3</formula><p>Fig. <ref type="figure" target="#fig_5">12</ref>. The replacement of the black edge (i, j) in procedure DOUBLE SUBDIVISION. Edges in M * are drawn as dotted lines, whereas the curved lines denote paths.</p><p>The following lemma follows directly from the definition of G * and Remark 1. Lemma 5. The size of G * is linear in the size of G(π), and there is a one-to-one correspondence between alternating cycles (and alternating-cycle decompositions) of G(π) and G * .</p><p>The key property of G * and M * is illustrated by the next lemma. Lemma 6. The set M * is a Hamiltonian matching of G * , and every alternating cycle of G * is oriented with respect to every permutation associated with G * and M * .</p><p>Proof. First of all, at the end of each execution of the for loop the updated M * is a Hamiltonian matching of the new G * . The updating formula of M * corresponds indeed to an insertion of the new degree-2 nodes k 1 , k 2 , k 3 , k 4 in the previous Hamiltonian circuits G * (B * ∪M * ) and G * (C * ∪M * ). In G * (B * ∪M * ), edges (i, j) and (a, b) are replaced by the paths (i, k 1 ), (k 1 , k 4 ), (k 4 , j) and (a, k 2 ), (k 2 , k 3 ), (k 3 , b), respectively, whereas in G * (C * ∪ M * ) edge (a, b) is replaced by the path (a, k 2 ), (k 2 , k 1 ), (k 1 , k 4 ), (k 4 , k 3 ), (k 3 , b); see Figure <ref type="figure" target="#fig_5">12</ref>.</p><p>Every permutation π * associated with G * and M * defines an orientation of the edges in B * . In particular, each edge is oriented according to the direction in which it is traversed by the Hamiltonian circuit G * (B * ∪ M * ) starting from the node corresponding to π * 0 and traversing a black edge first; see section 3. After the replacement of edge r = (i, j), to every alternating cycle of G(π) which contains this edge there corresponds an alternating cycle of G * that contains edges (i, k 1 ), (k 1 , k 2 ), (k 2 , k 3 ), (k 3 , k 4 ), (k 4 , j). Furthermore, with respect to every π * associated with G * and M * , either edge (i, k 1 ) is oriented from i to k 1 , edge (k 4 , j) from k 4 to j, and edge (k 2 , k 3 ) from k 3 to k 2 or, conversely, edge (i, k 1 ) is oriented from k 1 to i, edge (k 4 , j) from j to k 4 , and edge (k 2 , k 3 ) from k 2 to k 3 . This property is maintained throughout the procedure, since the new Hamiltonian circuits G * (B * ∪ M * ) are obtained from the previous ones by replacing edges with paths.</p><p>The above discussion shows that at the end of the procedure, when all black edges have been replaced, every alternating cycle of G * is oriented with respect to any permutation associated with G * and M * . The previous lemma leads to the main result of this section. As one might expect, it is also easy to determine the corresponding optimal alternating-cycle decomposition of G(π) from an optimal sequence of reversals needed to sort π * . In particular, for each element π * i of π * , consider the number of reversals in which it is involved in the sequence. Define a signed permutation π * from π * by letting element π * i be an even (resp., odd) element if this number is even (resp., odd). As explained in section 2, d( π * ) = d(π * ), and the unique alternating-cycle decomposition of G( π * ) corresponds to an alternating-cycle decomposition of G(π * ) of cardinality b( π * )d( π * ) = b(π * )d(π * ) and is therefore optimal. From this decomposition it is straightforward to derive an optimal alternating-cycle decomposition for G(π).</p><p>We briefly discuss how this reduction from MAX-ACD to MIN-SBR could in principle be used to derive approximation algorithms for MAX-ACD (and therefore for MAX-ECD by Remark 2 from approximation algorithms for MIN-SBR. Let Π denote the set of all permutations and Π * denote the set of permutations obtained from some π ∈ Π by applying the transformation given above. Suppose one wants to approximate c(π) for π ∈ Π and has an approximation algorithm for MIN-SBR, which applied to a permutation τ ∈ Π delivers a solution of value d A (τ ). As described above, it is possible to derive π * from π so that c(π) = c(π * ) = b(π * )d(π * ). One can then compute a solution of MIN-SBR on π * of value d A (π * ) and define a signed permutation π * such that d( π * ) = d A (π * ) and b( π * ) = b(π * ). (In fact, it may happen that d( π * ) &lt; d A (π * ), in which case the approximate solution can be improved by optimally sorting the corresponding signed permutation. We assume that the approximation algorithm includes this post-processing phase, so as to ensure</p><formula xml:id="formula_11">d( π * ) = d A (π * ).) The approximate solution of MAX-ACD is c A (π) = c A (π * ) = c( π * ) = b( π * ) -d( π * ) = b(π * ) -d A (π * ). To guarantee that inf π∈Π c A (π) c(π) ≥ α for some α &gt; 0 (α &lt; 1), one would need inf π * ∈Π * b(π * )-d A (π * ) b(π * )-d(π * ) ≥ α; i.e., sup π * ∈Π * d A (π * ) d(π * ) ≤ α + (1 -α) b(π * ) d(π * ) .</formula><p>Unfortunately, no approximation algorithm for general MIN-SBR known so far guarantees sup π∈Π</p><formula xml:id="formula_12">d A (π) d(π) ≤ α + (1 -α) b(π) d(π) .</formula><p>Observe that as b(π) ≤ 2d(π), such an algorithm should have a worst-case performance ratio of at most 2α.</p><p>As an immediate consequence of Theorem 9, the problem of sorting words by reversals (see <ref type="bibr" target="#b16">[17]</ref>) is NP-hard. This latter problem calls for a shortest sequence of reversals transforming a string w 1 . . . w n , such that w i ∈ {1, . . . , m} for i = 1, . . . , n and n ≥ m, into a sorted string y 1 . . . y n , where y i ≤ y i+1 for i = 1, . . . , n and is therefore clearly a generalization of MIN-SBR. Other relevant generalizations of MIN-SBR are mentioned in <ref type="bibr" target="#b3">[4]</ref>.</p><formula xml:id="formula_13">f f f f νi νi+1 νj νj+1 f f f f 0 • • • • • • 2n + 1 νj+2 νi-1 f f • • • νj-1<label>νi+2</label></formula><p>Fig. <ref type="figure" target="#fig_1">13</ref>. Illustration of the proof of Lemma 7.</p><p>Our construction can easily be adapted to show that the circular variant of MIN-SBR (see <ref type="bibr" target="#b14">[15]</ref>) is NP-hard as well. In this problem, reversals of intervals of the type (j, i), j &gt; i, are also allowed, which transform π = (π 1 . . . π n ) into (π i+j-1 . . . π j+1 π j π i+1 . . . π j-1 π i+n π i+n-1 . . . π i+j ), where all indexes are understood to be modulo n. Finally, the main ideas of the construction have been used in <ref type="bibr" target="#b3">[4]</ref> to prove that relevant generalizations of signed MIN-SBR are NP-hard.</p><p>6. The worst-case performance of lower bound b(π) -c(π) on d(π). In this section we show that both the absolute and asymptotic worst-case performance ratio of lower bound b(π)c(π) on d(π) are equal to 3  2 . Let Π denote the set of all permutations, and Π n the set of permutations with at least n elements. To prove our result, we make use of some notions introduced in section 2, in particular we use the interleaving graph H( π) of a signed permutation π. We first prove a technical lemma. An equivalent lemma can be found in <ref type="bibr" target="#b9">[10]</ref>; the proof is quite simple and hence is given explicitly below.</p><p>Lemma 7. Given a signed permutation π, every connected component of H( π) in which all nodes correspond to unoriented alternating cycles contains either at least two alternating cycles or one alternating cycle with at least 6 edges.</p><p>Proof. Since alternating cycles have at least 4 edges, it is sufficient to prove that there cannot exist an unoriented alternating cycle with 4 edges which is not interleaving with any other alternating cycle. Suppose such an alternating cycle A exists, and let n be the number of elements of π and ν be the unsigned permutation corresponding to π, as defined in section 2. As it is unoriented, A must be of the form (ν i , ν i+1 ), (ν i+1 , ν j ), (ν j , ν j+1 ), (ν j+1 , ν i ), where the first and third edges are black, and the second and fourth are gray; see Figure <ref type="figure" target="#fig_1">13</ref>. Also, j &gt; i + 2 as i + 1 and j are connected by a gray edge, and either i &gt; 0 or j + 1 &lt; 2n + 1 (or both), as i and j + 1 are connected by a gray edge. The fact that A is not interleaving with any other alternating cycle means that no other gray edge in G( π) is interleaving with (ν i+1 , ν j ) or (ν j+1 , ν i ); i.e., no gray edge connects an element ν k , i + 2 ≤ k ≤ j -1, to an element ν l , 0 ≤ l ≤ i -1 or j + 2 ≤ l ≤ 2n + 1. Therefore, as a gray edge connects ν i+1 to ν j , for each element ν k , i + 1 ≤ k ≤ j, elements ν k + 1 and ν k -1 are also in a position between i + 1 and j. This leads to a contradiction. Consider the minimum and maximum elements ν h and ν k , i + 1 ≤ h, k ≤ j. If i &gt; 0, element ν h -1 exists and is not in a position between i + 1 and j. Otherwise, j + 1 &lt; 2n + 1, hence element ν k + 1 exists and is not in a position between i + 1 and j.</p><p>Theorem 10. Both the absolute and asymptotic worst-case performance ratio of lower bound b(π)c(π) on d(π) are equal to 3  2 . Proof. We first prove that, for any permutation π ∈ Π, It is easy to see that π k+1 is such that b(π k+1 ) = 4(k + 1) and c(π k+1 ) = 2(k + 1). Furthermore, one may check that the results shown by Hannenhalli and Pevzner in <ref type="bibr" target="#b10">[11]</ref> guarantee that d(π k+1 ) = 3(k + 1). In particular, an optimal sorting of π k+1 is obtained by applying to each subsequence (0 + 8i) (5 + 8i) (6 + 8i) (3 + 8i) (4 + 8i) (1 + 8i) (2 + 8i) (7 + 8i) the reversals needed to sort π. This proves the asymptotic worst-case performance.</p><p>One may prove the same theorem for signed permutations in an analogous way. As a consequence of Theorem 10, by some straightforward algebraic computation one gets that the availability of an approximation algorithm for MAX-ACD with</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The breakpoint graph G(π) associated with π = (4 2 1 3). Gray edges are drawn as thin lines, black edges as thick lines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1</head><label>1</label><figDesc>depicts the breakpoint graph associated with the permutation (4 2 1 3). An alternating cycle of G(π) is a sequence of edges b 1 , c 1 , b 2 , c 2 , . . . , b m , c m , where b i ∈ B, c i ∈ C for i = 1, . . . , m; b i and c j are incident to a common node for i = j = 1, . . . , m and for i = j + 1, j = 1, . . . , m (where b m+1 := b 1 ); and b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The breakpoint graph G( π) associated with π = (3 1 2), where element 3 is even and elements 1 and 2 are odd.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>component of the subgraphs of G induced by edge set B, G(B), and by edge set C, G(C), is a simple path; (ii) each node i ∈ V has the same degree (0, 1, or 2) in G(B) and G(C); (iii) the edge sets of G(B) and G(C) are disjoint; i.e., B ∩ C = ∅. Let G = (V, B ∪ C) be a balanced bicolored graph. For convenience, in this section we do not address explicitly the trivial case B ∪ C = ∅. Consider the set U of the nodes of degree 2 in G, i.e., the set of nodes of degree 1 in G(B) and G(C). Note that |U | is even and ≥ 2. A perfect matching of the nodes in U is a set M ⊂ {(i, j) : i, j ∈ U, i = j} such that every i ∈ U is contained in exactly one pair in M . Such a perfect matching is called Hamiltonian if the graphs G(B ∪ M ) and G(C ∪ M ) are Hamiltonian circuits; note that M can be Hamiltonian only if M ∩ (B ∪ C) = ∅ and that both G(B ∪ M ) and G(C ∪ M ) visit only the nodes of degree 1 or 2 in G. The importance of Hamiltonian matchings of U is motivated by the following property. Lemma 1. Let G be a balanced bicolored graph and U be the set of degree-2 nodes of G. Every Hamiltonian matching of U defines at least one permutation π such that G(π) = G. Conversely, every π such that G(π) = G defines a Hamiltonian matching of U . Proof. Given a Hamiltonian matching M of U , a permutation π of |V | elements (including the dummy elements π 0 := 0 and π |V |-1 := |V | -1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .Fig. 4 .</head><label>34</label><figDesc>Fig. 3. The auxiliary graph A associated with the breakpoint graph of Figure 1. Edges in E are drawn as thin lines, edges in D as thick lines.e</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>2 .</head><label>2</label><figDesc>depicts the auxiliary graph associated with the breakpoint graph of Figure1. Consider procedure HAMILTONIAN MATCHING of Figure5applied to A.Lemma The set M constructed by procedure HAMILTONIAN MATCHING is a Hamiltonian matching.Proof. If |U | &gt; 2, i.e., |U | ≥ 4, there always exists a node pair i, j such that (i, j) ∈ D ∪ E, since each node of A has degree 2. The fact that M is a perfect matching of the nodes of degree 2 in G such that M ∩(B ∪C) = ∅ is immediate. To see that M is Hamiltonian, it is sufficient to show that G(B ∪ M ) and G(C ∪ M ) contain no subcircuit. Indeed, in each recursive step, there is a one-to-one correspondence between maximal paths in G(B ∪ M ) (resp., in G(C ∪ M )) and edges in D (resp., in E), and therefore the only way to introduce a subcircuit would be by matching two procedure HAMILTONIAN MATCHING(A, M ); input: the auxiliary graph A = (U, D ∪ E) associated with a balanced bicolored graph G = (V, B ∪ C); output: a Hamiltonian matching M of the nodes in U ; begin if |U | = 2 then let i and j be the two nodes in U ; let M := {i, j} else begin</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Procedure HAMILTONIAN MATCHING.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 .</head><label>6</label><figDesc>Fig.6. The subdivision of edge (i, j).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Graph Z(8, 2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>j i and b j+1 iFig. 10 .</head><label>j+110</label><figDesc>Fig. 10. Outline of the transformation from MAX-ECD to MAX-ACD. The circles inside each Z(v) represent the associated degree-1 nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Theorem 9 .</head><label>9</label><figDesc>MIN-SBR is NP-hard. Proof. Consider a breakpoint graph G(π) associated with some permutation π, and let M be the Hamiltonian matching of G(π) corresponding to π. Construct G * and M * from G(π) and M by applying procedure DOUBLE SUBDIVISION, and let π * be any permutation associated with G * and M * . By Lemmas 5 and 6 and Theorem 4, d(π * ) = b(π * )c(π * ), c(π) = c(π * ), and b(π * ) is trivially determined. So one can compute the optimal value of MAX-ACD for G(π) by solving MIN-SBR on π * , whose size is linear in the size of G(π). The claim then follows from Corollary 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>For lower bound b(π)-c(π) on d(π) we define the absolute worst-case performance ratio as sup π∈Π d(π) b(π)c(π) and the asymptotic worst-case performance ratio as lim n→∞ sup π∈Πn d(π) b(π)c(π) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>)-c(π) ≤ 3 2 . Given a permutation π, suppose an optimal decomposition of G(π) into c(π) alternating cycles is available. As described in section 2, define from π and the given decomposition a signed permutation π such that b( π) = b(π), c( π) = c(π), and d( π) ≥ d(π). The proof follows by showing thatd( π) b( π)-c( π) ≤ 3 2 . From Theorem 2, d( π) = b( π)c( π) + h( π) + f ( π); therefore all we need to show is that h( π)+f ( π) b( π)-c( π) ≤ 1 2 .As explained in section 2, h( π) + f ( π) is at most equal to the number of connected components of the interleaving graph H( π) in which all nodes correspond to unoriented alternating cycles. By Lemma 7, each such component contains either at least two alternating cycles or one alternating cycle with at least 6 edges. In both cases, the contribution to b( π)c( π) of the component is at least 2, hence h( π)+f ( π) b( π)-c( π) ≤ 1 2 follows. We conclude the proof by showing a family of permutations for which the worst case is attained. Consider first the permutation π = (0 5 6 3 4 1 2 7) (where the dummy elements π 0 = 0 and π n+1 = π 7 = 7 have been indicated explicitly). It is easy to check that b(π) = 4, c(π) = 2, and d(π) = 3, i.e., d(π) b(π)-c(π) = 3 2 , hence the absolute worst-case performance follows. Here the unique connected component of H( π) contains two unoriented alternating cycles of 4 edges. Furthermore, for any integer k ≥ 1, let π k+1 denote the permutation obtained by "duplicating" π k + 1 times, which has the form π k+1 = (0 5 6 3 4 1 2 7 (0 + 8) (5 + 8) (6 + 8) (3 + 8) (4 + 8) (1 + 8) (2 + 8) (7 + 8) . . . (0 + 8k) (5 + 8k) (6 + 8k) (3 + 8k) (4 + 8k) (1 + 8k) (2 + 8k) (7 + 8k)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>than two incident black/gray edges, G is clearly not a breakpoint graph.) It is then straightforward to check if G is balanced bicolored in O(|V |) time. Furthermore, the auxiliary graph A can easily be constructed and stored in the same way as G in O(|V |) time. With this data structure for A, it is obvious how to perform each recursive step in HAMILTONIAN MATCHING in constant time. In particular, for any node i of the auxiliary graph, by checking at most three other nodes it is possible to find a node j not connected to i. Finally, the construction of a permutation associated with G can be done in O(|V |) time if one adds to the data structure for G a vector of length |U | storing, for each node i of degree 2 in G, the node connected to i by an edge in the Hamiltonian matching.</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. A preliminary version of this paper received the "Best Paper by a Young Scientist Award" in the First Annual International Conference on Computational Molecular Biology, and I would like to thank the whole conference committee, chaired by Michael Waterman, for this award. More generally, I am really grateful to the computational biology community for the enthusiastic reaction when I proved that MIN-SBR was NP-hard. Finally, I would like to thank Sridhar Hannenhalli, Jens Lagergren, Giuseppe Lancia, and Pavel Pevzner for helpful discussions on the subject, and four anonymous referees for their valuable suggestions.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ALBERTO CAPRARA</head><p>and b m 2i in Z(d, m) is given by b m 2i-1 , p m i , q m i , r m i , t m 2i-1 , t m 2i , r m i , q m i+1 , p m i , b m 2i ;</p><p>see Figure <ref type="figure">9</ref>. The next lemma follows directly from the definition of Z(d, m). Lemma 3. Z(d, m) does not contain any alternating cycle, each node in Z(d, m) has the same number of incident gray and black edges, with the exception of l 1 , . . . , l d , and any alternating path connecting two l-nodes contains exactly 8m + 1 edges.</p><p>We are now ready to prove the key property of Z(d, m). Lemma 4. Let τ be any partition of the node set {l 1 , . . . ,</p><p>) can be decomposed into s alternating paths, each connecting a different pair in τ .</p><p>Proof. Note that every partition τ can be obtained from the partition {(l 1 , l 2 ), . . . , (l d-1 , l d )} by performing at most s(s-1)/2 exchanges between adjacent pairs. Indeed, with at most s -1 exchanges one can get the first pair in τ , with at most s -2 the second, and so on. Our proof is by induction on the number of such exchanges. We show that, for i = 1, . . . , s, it is possible to connect nodes l τ2i-1 and l τ2i by an alternating path of the form l τ2i-1 , . . . , t m 2i-1 , t m 2i , . . . , l τ2i . Clearly, if τ = {(l 1 , l 2 ), . . . , (l d-1 , l d )}, the edge set of Z(d, 1) can be decomposed as required by using, for i = 1, . . . , s, the trivial alternating path which connects l 2i-1 to l 2i .</p><p>Suppose now that τ is obtained from τ ′ by exchanging two elements in consecutive pairs, and the edge set of Z(d, j) can be decomposed into s alternating paths, the ith of the form l τ ′ 2i-1 , . . . , t j 2i-1 , t j 2i , . . . l τ ′ 2i . Then, the edge set of Z(d, j + 1) can be decomposed into s alternating paths, the ith of the form l τ2i-1 , . . . , t j+1 2i-1 , t j+1 2i , . . . l τ2i . These alternating paths are obtained by taking the alternating paths in Z(d, j) corresponding to τ ′ and replacing their gray edges (t j 2i-1 , t j 2i ), i = 1, . . . , s, by alternating paths in Z(d, j + 1) using edges of Y j+1 (d) and edges (t j+1 2i-1 , t j+1 2i ), i = 1, . . . , s. For completeness, we consider the two possible cases. In the first case, pairs</p><p>). The alternating paths corresponding to τ are obtained from those corresponding to τ ′ by replacing each edge (t j 2i-1 , t j 2i ) in Z(d, j), i = 1, . . . , h -1 and i = h + 2, . . . , s, by the trivial alternating path connecting nodes b j+1 2i-1 and b j+1 2i in Z(d, j + 1) and by replacing edges (t j 2h-1 , t j 2h ) and (t j 2h-1 , t j 2h ) in Z(d, m) by the alternating paths</p><p>, and the construction is analogous to the previous one. The proof is completed by observing that if the edge set of Z(d, j) can be decomposed as required, the edge set of Z(d, j + 1) can as well. Indeed, it is sufficient to replace edges (t   SBR on π if there existed an optimal alternating-cycle decomposition of G(π) made up of oriented (with respect to π) cycles only. Unfortunately, this is not always the case; we show how to overcome this difficulty in what follows.</p><p>Consider a breakpoint graph G(π) = (V, B ∪C) associated with some permutation π, and let M be the Hamiltonian matching of G(π) determined by π (see section 3). Construct the breakpoint graph G * and its Hamiltonian matching M * by applying to G(π) and M the procedure DOUBLE SUBDIVISION in Figure <ref type="figure">11</ref>. This procedure replaces every black edge of G by an alternating path of 5 edges, "twice" subdividing the original edge. Figure <ref type="figure">12</ref> shows the effect of the replacement of the black edge (i, j) on graphs G * (B * ∪ M * ) and G * (C * ∪ M * ). (where d A (π) is the value of the approximate solution for the MIN-SBR instance defined by π). The last inequality follows from the obvious relation b(π) ≥ 2c(π). So this scheme cannot improve on the approximation ratio of 3  2 due to Christie <ref type="bibr" target="#b6">[7]</ref>. It is also worth noting that in order to prove that an approximation algorithm for MIN-SBR has a worst-case performance ratio better than 3  2 , it is not sufficient just to compare the value of the approximate solution with the lower bound b(π)c(π).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Genome rearrangements and sorting by reversals</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bafna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Pevzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="272" to="289" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fast sorting by reversal</title>
		<author>
			<persName><forename type="first">P</forename><surname>Berman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hannenhalli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Annual Symposium on Combinatorial Pattern Matching</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>7th Annual Symposium on Combinatorial Pattern Matching<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1075</biblScope>
			<biblScope unit="page" from="168" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Sorting Permutations by Reversals and Eulerian Cycle Decompositions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Caprara</surname></persName>
		</author>
		<idno>OR/97/4 DEIS</idno>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Bologna, Italy</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Università di Bologna</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Formulations and Complexity of Multiple Sorting by Reversals</title>
		<author>
			<persName><forename type="first">A</forename><surname>Caprara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Annual international Conference on Computational Molecular Biology (RECOMB&apos;99)</title>
		<meeting>Third Annual international Conference on Computational Molecular Biology (RECOMB&apos;99)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On the Tightness of the Alternating-Cycle Lower Bound for Sorting by Reversals</title>
		<author>
			<persName><forename type="first">A</forename><surname>Caprara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comb. Optim</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">A Column-Generation Based Branch-and-Bound Algorithm for Sorting by Reversals</title>
		<author>
			<persName><forename type="first">A</forename><surname>Caprara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lancia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-K</forename><surname>Ng</surname></persName>
		</author>
		<idno>OR/95/7 DEIS</idno>
		<imprint>
			<date type="published" when="1995">1995</date>
			<pubPlace>Bologna, Italy</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Università di Bologna</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. report</note>
	<note>to appear in DIMACS Series in Discrete Mathematics and Theoretical Computer Science</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A 3/2 approximation algorithm for sorting by reversals</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Christie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. the 9th Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>the 9th Annual ACM-SIAM Symposium on Discrete Algorithms<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="244" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Compendium of NP Optimization Problems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Crescenzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kann</surname></persName>
		</author>
		<idno>SI/RR-95/02</idno>
		<ptr target="http://www.nada.kth.se/theory/problemlist.html" />
	</analytic>
	<monogr>
		<title level="m">Dipartimento di Scienze dell&apos;Informazione, Università di Roma</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Conservation of genome form but not sequence in the transcription antitermination determinants of bacteriophages λ, φ21 and P 22</title>
		<author>
			<persName><forename type="first">N</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Molecular Evolution</title>
		<imprint>
			<biblScope unit="page" from="75" to="84" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Transforming cabbage into turnip (Polynomial algorithm for sorting signed permutations by reversals</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hannenhalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Pevzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th Annual ACM Symposium on the Theory of Computing</title>
		<meeting>27th Annual ACM Symposium on the Theory of Computing<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="178" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">To cut . . . or not to cut (Applications of comparative physical maps in molecular evolution</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hannenhalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Pevzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>7th Annual ACM-SIAM Symposium on Discrete Algorithms<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="304" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The NP-completeness of some edge-partition problems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Holyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="713" to="717" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Sorting by Reversals: A Conjecture of Kececioglu and Sankoff</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Irving</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Christie</surname></persName>
		</author>
		<idno>TR-1995-12</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Science Dept</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<pubPlace>Glasgow</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Glasgow</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Faster and simpler algorithm for sorting signed permutations by reversals</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>8th Annual ACM-SIAM Symposium on Discrete Algorithms<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="344" to="351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient bounds for oriented chromosome inversion distance</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kececioglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sankoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Annual Symposium on Combinatorial Pattern Matching</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>5th Annual Symposium on Combinatorial Pattern Matching<address><addrLine>New York, Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">807</biblScope>
			<biblScope unit="page" from="307" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Exact and approximation algorithms for sorting by reversals, with application to genome rearrangement</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kececioglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sankoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="180" to="210" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Open combinatorial problems in computational molecbiology</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Pevzner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Waterman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Israel Symposium on the Theory of Computing and Systems</title>
		<meeting>3rd Israel Symposium on the Theory of Computing and Systems<address><addrLine>Piscataway, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="158" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Analytical approaches to genomic evolution</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sankoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biochimie</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="409" to="413" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Gene order comparisons for phylogenetic inference: Evolution of the mitochondrial genome</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sankoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Leduc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Antoine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Paquin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cedergren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Natl. Acad. Sci. U.S.A</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="6575" to="6579" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An Easy Case of Sorting by Reversals</title>
		<author>
			<persName><forename type="first">N</forename><surname>Tran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th Annual Symposium on Combinatorial Pattern Matching</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>8th Annual Symposium on Combinatorial Pattern Matching<address><addrLine>New York, Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1264</biblScope>
			<biblScope unit="page" from="83" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The chromosome inversion problem</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Watterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Ewens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Morgan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Theoret. Biology</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
