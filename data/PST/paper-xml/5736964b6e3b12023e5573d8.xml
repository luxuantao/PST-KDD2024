<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dynamic service migration and workload scheduling in edge-clouds</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2015-07-03">3 July 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rahul</forename><surname>Urgaonkar</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T. J. Watson Research Center</orgName>
								<address>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Shiqiang</forename><surname>Wang</surname></persName>
							<email>shiqiang.wang11@imperial.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical and Electronic Engineering</orgName>
								<orgName type="institution">Imperial College London</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ting</forename><surname>He</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T. J. Watson Research Center</orgName>
								<address>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Murtaza</forename><surname>Zafer</surname></persName>
							<email>murtaza.zafer.us@ieee.org</email>
							<affiliation key="aff2">
								<orgName type="institution">Nyansa Inc</orgName>
								<address>
									<settlement>Palo Alto</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kevin</forename><surname>Chan</surname></persName>
							<email>kevin.s.chan.civ@mail.mil</email>
							<affiliation key="aff3">
								<orgName type="laboratory">Army Research Laboratory</orgName>
								<orgName type="institution">US</orgName>
								<address>
									<settlement>Adelphi</settlement>
									<region>MD</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kin</forename><forename type="middle">K</forename><surname>Leung</surname></persName>
							<email>kin.leung@imperial.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical and Electronic Engineering</orgName>
								<orgName type="institution">Imperial College London</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Dynamic service migration and workload scheduling in edge-clouds</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2015-07-03">3 July 2015</date>
						</imprint>
					</monogr>
					<idno type="MD5">59E7830E8A45DF07822158B02496E158</idno>
					<idno type="DOI">10.1016/j.peva.2015.06.013</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Edge-clouds Service migration Stochastic optimization Markov decision processes</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Edge-clouds provide a promising new approach to significantly reduce network operational costs by moving computation closer to the edge. A key challenge in such systems is to decide where and when services should be migrated in response to user mobility and demand variation. The objective is to optimize operational costs while providing rigorous performance guarantees. In this paper, we model this as a sequential decision making Markov Decision Problem (MDP). However, departing from traditional solution methods (such as dynamic programming) that require extensive statistical knowledge and are computationally prohibitive, we develop a novel alternate methodology. First, we establish an interesting decoupling property of the MDP that reduces it to two independent MDPs on disjoint state spaces. Then, using the technique of Lyapunov optimization over renewals, we design an online control algorithm for the decoupled problem that is provably cost-optimal. This algorithm does not require any statistical knowledge of the system parameters and can be implemented efficiently. We validate the performance of our algorithm using extensive trace-driven simulations. Our overall approach is general and can be applied to other MDPs that possess a similar decoupling property.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The increasing popularity of mobile applications (such as social networking and photo sharing) running on handheld devices is putting a significant burden on the capacity of cellular and backhaul networks. These applications are generally comprised of a front-end component running on the handheld and a back-end component (that performs data processing and computation) that typically runs on the cloud. While this architecture enables applications to take advantage of the on-demand feature of cloud computing, it also introduces new challenges in the form of increased network overhead and latency. A promising approach to address these challenges is to move such computation closer to the network edge. Here, it is envisioned that entities (such as basestations in a cellular network) closer to the network edge would host smallersized cloud-like infrastructure distributed across the network. This idea has been variously termed as Cloudlets <ref type="bibr" target="#b0">[1]</ref>, Fog Computing <ref type="bibr" target="#b1">[2]</ref>, Edge Computing <ref type="bibr" target="#b2">[3]</ref>, and Follow Me Cloud <ref type="bibr" target="#b3">[4]</ref>, to name a few. The trend towards edge-clouds is expected to accelerate as more users perform a majority of their computations on handhelds and as newer mobile applications get adopted.</p><p>One of the key design issues in edge-clouds is service migration: should a service currently running in one of the edgeclouds be migrated as the user locations change, and if yes, where? This question stems from the basic tradeoff between the cost of service migration vs. the reduction in network overhead and latency for users that can be achieved after migration. While conceptually simple, it is challenging to make this decision in an optimal manner because of the uncertainty in user mobility and request patterns. Because edge-clouds are distributed at the edge of the network, their performance is closely related to user dynamics. These decisions get even more complicated when the number of users and applications is large and there is heterogeneity across edge-clouds. Note that the service migration decisions affect workload scheduling as well (and vice versa), so that in principle these decisions must be made jointly.</p><p>The overall problem of dynamic service migration and workload scheduling to optimize system cost while providing enduser performance guarantees can be formulated as a sequential decision making problem in the framework of MDPs <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>. This approach, although very general, suffers from several drawbacks. First, it requires extensive knowledge of the statistics of the user mobility and request arrival processes that can be impractical to obtain in a dynamic network. Second, even when this is known, the resulting problem can be computationally challenging to solve. Finally, any change in the statistics would make the previous solution suboptimal and require recomputing the optimal solution.</p><p>In this paper, we present a new methodology that overcomes these drawbacks. Our approach is inspired by the technique of Lyapunov optimization <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref> which is a general framework for designing optimal control algorithms for non-MDP problems without requiring any knowledge of the transition probabilities. Specifically, these are problems where the cost functions and control decisions are functionals of states that evolve independently of the control actions. However, as we will show later, this condition does not hold for the joint service migration and workload scheduling problem studied in this paper. A key contribution of this work is to develop a methodology that enables us to still apply the Lyapunov optimization technique to this MDP while preserving its attractive features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work</head><p>The general problem of resource allocation and workload scheduling in cloud computing systems using the framework of stochastic optimization has been considered in several recent works. Specifically, <ref type="bibr" target="#b8">[9]</ref> considers a stochastic model for a cloud computing cluster, where requests for virtual machines (VMs) arrive according to a stochastic process. Each VM request is specified in terms of a vector of resources (such as CPU, memory and storage space) and its duration and must be placed on physical machines (PMs) subject to a set of vector packing constraints. Ref. <ref type="bibr" target="#b8">[9]</ref> defines the notion of the capacity region of the cloud system and shows that the MaxWeight algorithm is throughput optimal. Virtual machine placement utilizing shadow routing is studied in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, where virtual queues are introduced to capture more complicated packing constraints. Ref. <ref type="bibr" target="#b11">[12]</ref> considers a joint VM placement and route selection problem where in addition to packing constraints, the traffic load between the VMs is also considered. All these works consider a traditional cloud model where the issue of user mobility and resulting dynamics is not considered. As discussed before, this issue becomes crucial in edge-clouds and introduces the need for dynamic service migration that incurs reconfiguration costs. The presence of these costs fundamentally changes the underlying resource allocation problem from a non-MDP to an MDP for which the techniques used in these works are no longer optimal.</p><p>The impact of reconfiguration or switching cost has been considered in some works recently. Specifically, <ref type="bibr" target="#b12">[13]</ref> considers the problem of dynamic ''right-sizing'' of data centers where the servers are turned ON/OFF in response to the time-varying workloads. However, such switching incurs cost in terms of the delay associated with switching as well the impact on server life. Ref. <ref type="bibr" target="#b12">[13]</ref> proposes an online algorithm that is shown to have a 3-competitive ratio while explicitly considering switching costs. A similar problem involving geographic load balancing is considered in <ref type="bibr" target="#b13">[14]</ref> using a receding horizon control framework. Ref. <ref type="bibr" target="#b14">[15]</ref> focuses on a wireless scheduling problem with reconfiguration delay while <ref type="bibr" target="#b15">[16]</ref> studies the reconfiguration problem from a queueing theory perspective and derives analytical expressions for the performance. All the approaches in <ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref> assume knowledge of the statistics of the underlying system while <ref type="bibr" target="#b12">[13]</ref> considers a single data center with homogeneous servers. Our work differs from all these because we explicitly consider the reconfiguration costs associated with service migrations while treating a very general model for a distributed edge-cloud system.</p><p>The methodology used in this paper is inspired by the framework of Lyapunov optimization over renewals proposed in <ref type="bibr" target="#b16">[17]</ref>. This framework extends the Lyapunov optimization approach of <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref> to treat constrained MDPs. The basic idea involves converting a constrained MDP into a sequence of unconstrained stochastic shortest path problems (SSPs) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> that are solved over consecutive renewal frames. However, solving the resulting SSPs typically still requires knowledge of the underlying probability distributions and can be computationally prohibitive for large state spaces.</p><p>In this work, we also make use of the framework of Lyapunov optimization over renewals. However, instead of directly applying the technique of <ref type="bibr" target="#b16">[17]</ref>, we first establish a novel decoupling property of our MDP which shows that it can be decoupled into two independent MDPs that evolve on disjoint state spaces. This crucial property enables us to apply the framework of <ref type="bibr" target="#b16">[17]</ref> in such a way that the resulting algorithms are simple deterministic optimization problems (rather than stochastic shortest path problems) that can be solved efficiently without any knowledge of the underlying probability distributions. For example, one of the components of our overall algorithm involves solving a deterministic shortest path problem instead of an SSP every renewal frame. As such, the resulting solution is markedly different from classical dynamic programming based approaches and does not suffer from the associated ''curse of dimensionality'' or convergence issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Problem formulation</head><p>We consider an edge-cloud system comprised of M distributed edge-clouds and one back-end cloud that together host K applications (see Fig. <ref type="figure" target="#fig_0">1</ref>). The system also consists of N users that generate application requests over time. The collection of edge and back-end clouds supports these applications by providing the computational resources needed to serve user requests. The users are assumed to be mobile while the edge and back-end clouds are static. We assume a time-slotted model and use the notion of ''service'' and ''application'' interchangeably in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">System model</head><p>Mobility model: Let L n (t) denote the location of user n in slot t. The collection of all user locations in slot t is denoted by vector l(t). We assume that l(t) takes values from a finite (but potentially arbitrarily large) set L. Further, l(t) is assumed to evolve according to an ergodic discrete time Markov chain (DTMC) over the states in L with transition probabilities denoted by p ll ′ for all l, l ′ ∈ L. Application request model: Denote the number of requests for application k generated by user n in slot t by A kn (t) and the collection {A kn (t)} for all k, n by vector a(t). Similar to l(t), we assume that a(t) takes values from a finite (but potentially arbitrarily large) set A. We further assume that for all k, n there exist finite constants A max kn such that A kn (t) ≤ A max kn for all t.</p><p>The process a(t) is also assumed to evolve according to an ergodic DTMC over the states in A with transition probabilities q aa ′ for all a, a ′ ∈ A. All application requests generated at each user are routed to a selected subset of the edge-clouds for servicing. These routing decisions incur transmission costs and are subject to certain constraints as discussed below.</p><p>User-to-edge-cloud request routing: Let r knm (t) denote the number of application k requests from user n that are routed to edge-cloud m in slot t and let r(t) denote the collection {r knm (t)} for all k, n, m. Routing of these requests incurs a transmission cost of r knm (t)c knm (t) where c knm (t) is the unit transmission cost that can depend on the current location of the user L n (t), the application index k, as well as the edge-cloud index m. More generally, it could also depend on other ''uncontrollable'' factors such as background backhaul traffic and wireless fading, but we do not consider these for simplicity.</p><p>Denote the sum total transmission cost incurred in slot t by C (t), i.e., C (t) =  knm r knm (t)c knm (t). For each (k, m), we denote by R km (t) the total number of application k requests received by edge-cloud m in slot t, i.e., R km (t) =  N n=1 r knm (t). We assume that the maximum number of requests for an application k that can be routed to edge-cloud m in any slot is upper bounded by R max km . Given these assumptions, the routing decisions r(t) are subject to the following constraints</p><formula xml:id="formula_0">A kn (t) = M  m=1 r knm (t) ∀k, n (1) 0 ≤ N  n=1 r knm (t) ≤ R max km ∀k, m<label>(2)</label></formula><p>where (1) captures the assumption that no request buffering happens at the users. In addition to (1) and ( <ref type="formula" target="#formula_0">2</ref>), there can be other location-based constraints that limit the set of edge-clouds where requests from user n can be routed given its location L n (t). Given l(t) = l, a(t) = a, denote the feasible request routing set by R(l, a). We assume that R(l, a) ̸ = ∅ for all l ∈ L, a ∈ A.</p><p>Application configuration of edge-clouds: For all k, m, define application placement variables H km (t) as</p><formula xml:id="formula_1">H km (t) =  1 if edge-cloud m hosts application k in slot t, 0 else.<label>(3)</label></formula><p>The collection {H km (t)} is denoted by the vector h(t). This defines the application configuration of the edge-clouds in slot t and determines the local service rates {µ km (t)} offered by them in that slot. An application's requests can only be serviced by an edge-cloud if it hosts this application in that slot. Thus, µ km (t) = 0 if H km (t) = 0. When H km (t) = 1, then µ km (t) is assumed to be a general non-negative function ϕ km (•) of the vector h(t), i.e., µ km (t) = ϕ km (h(t)). This results in a very general model that can capture correlations between the service rates of co-located applications. A special case is where µ km (t) depends only on H km (t). For simplicity, we assume that µ km (t) is a deterministic function of h(t) and use µ km (t) to mean ϕ km (h(t)). Further, we assume that there exist finite constants µ max km such that µ km (t) ≤ µ max km for all t. An edge-cloud is typically resource constrained and may not be able to host all applications. In general, hosting an application involves creating a set of virtual machines (VMs) or execution containers (e.g., Docker) and assigning them a vector of computing resources (such as CPU, memory and storage) from the physical machines (PMs) in the edge-cloud. We say that an application configuration h(t) is feasible if there exists a VM-to-PM mapping that does not violate any resource constraints. The set of all feasible application configurations is denoted by H and is assumed to be finite. We also assume that there is a system-wide controller that can observe the state of the system and change the application configuration over time by using techniques such as VM migration and replication. This enables the controller to adapt in response to the system dynamics induced by user mobility as well as demand variations. However, such reconfiguration incurs a cost that is a function of the degree of reconfiguration. Given any two configurations a, b ∈ H, the cost of switching from a to b is denoted by W ab . For simplicity, we assume that it is possible to switch between any two configurations a, b ∈ H and that W ab is upper bounded by a finite constant W max . We further assume, without loss of generality, that</p><formula xml:id="formula_2">W ab ≤ W ac + W cb ∀a, b, c ∈ H. (4)</formula><p>The last assumption is valid if W ab is the minimum cost required to switch from a to b, This is because if W ab &gt; W ac + W cb , then we could carry out the reconfiguration from a to b by switching from a to c and then to b, achieving lower cost. Denote the switching cost incurred in slot t by W (t). For simplicity, we assume that switching incurs no delay while noting that our model can be extended to consider such delays (for example, by setting the local service rates to zero during those slots when a reconfiguration is underway).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Request queues at the edge-clouds:</head><p>As illustrated in Fig. <ref type="figure" target="#fig_0">1</ref>, every edge-cloud m maintains a request queue U km (t) per application k that buffers application k requests from all users that are routed to edge-cloud m. Requests in U km (t) can get serviced locally in a slot by edge-cloud m if it hosts application k in that slot. In addition, buffered requests in U km (t) can also be routed to the back-end cloud which is assumed to host all applications at all times. However, this incurs additional back-end transmission cost as discussed later. The queueing dynamics for U km (t) is given by</p><formula xml:id="formula_3">U km (t + 1) = max[U km (t) -µ km (t) -υ km (t) + R km (t), 0] (5)</formula><p>where υ km (t) denotes the number of requests from U km (t) that are transmitted to the back-end cloud in slot t and µ km (t) is the local service rate. It is assumed that the requests in U km (t) are serviced in a FIFO manner. The collection of all queue backlogs {U km (t)} is denoted by the vector U (t). From (5), note that requests generated in a slot can get service in the same slot. It should also be noted that requests can be routed to U km (t) in a slot even if H km (t) = 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Edge-cloud to back-end cloud request routing:</head><p>The back-end cloud is assumed to host all applications at all times. However, transmitting requests to the back-end may incur very high costs and therefore it is desirable to maximize the fraction of requests that can be serviced locally by the edge-clouds. Let υ km (t) denote the number of requests from U km (t) that are transmitted to the back-end cloud in slot t and let υ(t) denote the collection {υ km (t)} for all k, m. Routing of υ km (t) incurs a transmission cost of υ km (t)e km (t) where e km (t) is the unit back-end transmission cost that can depend on the application index as well as the edge-cloud index. Similar to request routing costs c knm (t), e km (t) can also depend on other ''uncontrollable'' factors (such as background backhaul traffic), but we only consider the average impact of these for simplicity. Since both the edge-clouds and the back-end cloud are static, we have e km (t) = e km for all t. We assume that there exist finite constants υ max km such that υ km (t) ≤ υ max km for all t. Further, R max km ≤ υ max km which models the baseline scenario where all requests are serviced only by the back-end cloud. Denote the set of all υ(t) that satisfy these constraints by V and the sum total back-end transmission cost incurred in slot t by E(t), i.e., E(t) =  km υ km (t)e km . We assume that the back-end cloud has sufficient processing capacity such that it can service all requests in υ(t) with negligible delay. Thus, queueing in the back-end becomes trivial and is ignored. It should be noted that in our model any user request that is eventually serviced by the back-end cloud is transmitted first to an edge-cloud.</p><p>Performance objective: Given this model, our goal is to design a control algorithm for making request routing decisions at the users and edge-clouds as well as application reconfiguration decisions across the edge-clouds so that the time-average overall transmission and reconfiguration costs are minimized while serving all requests with finite delay. Specifically, we assume that the time-average delay for the requests in each queue U km (t) should not exceed d avg , where d avg is a finite constant. This can be formulated as a constrained Markov Decision Problem (MDP) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> as shown in Section 3.2.</p><p>Timing of events in a slot: We assume the following sequence of events in a slot. At the start of slot t, the controller observes the queue backlogs U (t), new arrivals a(t), user locations l(t), and the last configuration h(t -1). Then it makes a reconfiguration decision that transitions the configuration state to h(t) and this determines the local service rates offered in slot t. Then the controller makes user to edge-cloud and edge-cloud to back-end cloud routing decisions. The queue backlogs U (t + 1) at the start of the next slot evolve according to (5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">MDP formulation</head><p>The control problem described in Section 3.1 can be formulated as a constrained MDP over the joint state space (l(t), a(t), h(t), U (t)). It is well-known that if this problem is feasible, then an optimal control policy for this MDP can be obtained by searching over the class of stationary, randomized control algorithms that take control actions purely as a function of the system states <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>. Specifically, consider a control algorithm that operates as follows.</p><p>First, given last state φ ′ = (l(t -1) = l ′ , a(t -1) = a ′ , h(t -1) = h ′ , U (t -1) = u ′ ) and current location, arrival, and queue backlog states l(t) = l, a(t) = a and U (t) = u, the control algorithm chooses current configuration h(t) = h with probability z φ ′ φ , thereby transitioning the state to φ = (l(t) = l, a(t) = a, h(t) = h, U (t) = u). Note that the routing decisions taken in the last slot together with its configuration h ′ determine U (t) through the queueing equations in <ref type="bibr" target="#b4">(5)</ref>. Denote the resulting transition probability from</p><formula xml:id="formula_4">U (t -1) = u ′ to U (t) = u by s φ ′ u ′ u .</formula><p>Then the total expected reconfiguration cost incurred when transitioning from state φ ′ is given by</p><formula xml:id="formula_5">W φ ′ =  φ p l ′ l q a ′ a s φ ′ u ′ u z φ ′ φ W h ′ h .<label>(6)</label></formula><p>Next, given current state φ = (l(t) = l, a(t) = a, h(t) = h, U (t) = u), the control algorithm chooses routing vector r(t) = r with probability x φ (r) subject to r ∈ R(l, a). This incurs a total expected transmission cost given by</p><formula xml:id="formula_6">C φ =  r∈R(l,a)</formula><p>x φ (r)  knm r knm c knm .</p><p>Finally, given current state φ = (l(t) = l, a(t) = a, h(t) = h, U (t) = u), it chooses back-end routing vector υ(t) = υ with probability y φ (υ) subject to υ ∈ V and this incurs a total expected back-end transmission cost given by</p><formula xml:id="formula_8">E φ =  υ∈V y φ (υ)  km υ km e km .<label>(8)</label></formula><p>Let us denote the steady state probability of being in state φ under this policy by π φ . Then, the overall time-average expected transmission plus reconfiguration cost is given by</p><formula xml:id="formula_9">C + E + W =  φ π φ C φ +  φ π φ E φ +  φ π φ W φ .<label>(9)</label></formula><p>Let U km and R km denote the time-average expected values of U km (t) and R km (t) under this control algorithm. By Little's Theorem, we have that the average delay D km for the requests in queue U km (t) satisfies U km = R km D km . In order to meet the average delay constraint, we need that</p><formula xml:id="formula_10">D km = U km R km ≤ d avg ∀k, m.</formula><p>The constrained MDP optimization searches for an optimal policy that minimizes C + E + W subject to meeting the average delay constraint. Assuming that the problem is feasible, let c * , e * , and w * denote the optimal time-average user-toedge-cloud transmission cost, edge-cloud-to-back-end cloud transmission cost, and total reconfiguration cost respectively. Solving this optimization is extremely challenging and quickly becomes intractable due to the complexity of the state space under traditional solution methods (such as value iteration <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>). Further, these techniques require knowledge of the transition probabilities of the user mobility and request arrival processes that may not be known a priori. In the following, we develop an alternate methodology for tackling this problem that overcomes these challenges. Specifically, we take the following approach.</p><p>(1) We first relax this MDP by replacing the time-average delay constraints by queue stability constraints. This results in an MDP whose state space involves only (l(t), a(t), h(t)).</p><p>(2) For this relaxed MDP, we prove a novel decoupling property which shows that it can be decoupled into two independent MDPs that evolve on disjoint state spaces. (3) This decoupling property enables us to develop an online control algorithm that does not require any knowledge of the probability distributions, yet can achieve (arbitrarily) close to optimal cost while providing worst-case delay guarantees.</p><p>Before proceeding, we make the following assumption about the above (non-relaxed) MDP. under the optimal control policy. For all k, m for which R * km &gt; 0, define ϵ km = µ * km + υ * km -R * km and let ϵ = min km ϵ km . Then we assume that ϵ is strictly positive, i.e., ϵ &gt; 0. Note that, in general, in a queue with stochastic arrivals and service rates, if the average arrival rate is not smaller than the service rate, then the average delay becomes unbounded. Therefore this assumption is not very restrictive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">MDP relaxation and decoupling</head><p>Consider a relaxation of the original MDP discussed in Section 3.2 where we replace the average delay constraints by the following queue stability constraints ∀k, m.</p><formula xml:id="formula_11">µ km + υ km -R km ≥ ϵ if R km &gt; 0 (10)</formula><p>where R km , µ km and υ km respectively denote the time-average expected arrival rate, local service rate and back-end routing rate under any control algorithm. It can be shown that meeting these constraints ensures that all queues are rate stable <ref type="bibr" target="#b7">[8]</ref>.</p><p>Further, we add the constraints that C = c * , E = e * , and W = w * . That is, we enforce the time-average transmission and switching costs under the relaxed problem to match those under the optimal solution to the original MDP. It is clear that this problem is a relaxation of the original MDP since the solution to the original MDP is feasible for this problem. However, a solution to the relaxed problem will not necessarily satisfy the average delay constraints. An optimal stationary, randomized control algorithm for the relaxed problem can be defined similarly to the original MDP and is described in Appendix A. The motivation for considering this relaxation is that, unlike the original MDP, it suffices to consider the reduced state space defined by (l(t), a(t), h(t)) for this problem. This follows by noting that none of the constraints involve the queue backlogs.</p><p>Further, the relaxed problem has an interesting decoupling property (discussed next) that can be leveraged to design an online control algorithm that can achieve close to optimal cost while providing explicit worst-case delay guarantees (as shown in Section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Decoupling the relaxed MDP</head><p>We now show that a decoupled control algorithm is optimal for the relaxed MDP defined above. Specifically, under this decoupled algorithm, the control decisions for user request routing are taken purely as a function of (l(t), a(t)), those for application reconfiguration are taken purely as a function of h(t), and the back-end routing decisions are taken in i.i.d. manner every slot, independent of all states. As a result, under this algorithm, the states (l(t), a(t)) and h(t) become decoupled and evolve independently of each other. Note that, in general, when searching for the optimal policy for the relaxed MDP, one must consider the class of algorithms where the control decisions are taken as a function of the joint state</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(l(t), a(t), h(t)).</head><p>Under such algorithms, the states (l(t), a(t)) and h(t) would be coupled and their evolution would not be independent. Thus, it is noteworthy that such a decoupled policy exists.</p><p>We next specify the decoupled control algorithm and show that it achieves the same time-average cost as the relaxed MDP (and hence the original MDP). The decoupled algorithm is defined in terms of the control decision probabilities (and resulting steady-state values) of the optimal solution to the relaxed MDP. We use the superscript ''xdp'' to indicate the control actions and resulting steady state probabilities of the optimal solution to the relaxed MDP while the superscript ''dec'' is used for the decoupled control algorithm. We use the shorthand notation φ = (l(t</p><formula xml:id="formula_12">) = l, a(t) = a, h(t) = h) and φ ′ = (l(t -1) = l ′ , a(t -1) = a ′ , h(t -1) = h ′ ). Let π xdp</formula><p>φ denote the steady-state probability of state φ under the optimal solution to the relaxed MDP and  la π xdp φ sums this over all states φ for a given configuration h. Define H ′ as the set of all configuration states h for which</p><formula xml:id="formula_13"> la π xdp φ &gt; 0.</formula><p>The decoupled algorithm has the following components: Reconfiguration policy: The reconfiguration policy is defined by probabilities θ dec h ′ h which denote the probability of switching to configuration h given that the configuration in the last slot was h ′ . These probabilities are given by</p><formula xml:id="formula_14">θ dec h ′ h =             l ′ a ′ π xdp φ ′   la p l ′ l q a ′ a z xdp φ ′ φ   l ′ a ′ π xdp φ ′ if h, h ′ ∈ H ′ , 0 else. (<label>11</label></formula><formula xml:id="formula_15">)</formula><p>Routing policy: Given l(t) = l, a(t) = a, choose a routing vector r ∈ R(l, a) with probability ζ dec la (r) given by</p><formula xml:id="formula_16">ζ dec la (r) =           h π xdp φ x xdp φ (r)  h π xdp φ if  h π xdp φ &gt; 0, 0 else<label>(12)</label></formula><p>where  h π xdp φ sums π xdp φ over all states φ for which l(t) = l and a(t) = a. Back-end routing policy: In each slot t, choose a back-end routing vector υ ∈ V with probability ϑ dec (υ) given by</p><formula xml:id="formula_17">ϑ dec (υ) =  φ π xdp φ y xdp φ (υ).<label>(13)</label></formula><p>Let us denote the time-average arrival and service rates for queue U km (t) under the decoupled algorithm by R dec km , µ dec km and υ dec km respectively. Then we have the following.</p><p>Theorem 1. For the decoupled control algorithm defined by <ref type="bibr" target="#b10">(11)</ref>, <ref type="bibr" target="#b11">(12)</ref>, and (13), the following hold:</p><p>(1) The time-average reconfiguration cost is equal to w * .</p><p>(2) The time-average transmission cost is equal to c * .</p><p>(3) The time-average back-end routing cost is equal to e * .</p><p>(4) For each queue U km (t), the time-average arrival and service rates R dec km , µ dec km and υ dec km are equal to those under the relaxed MDP and satisfy <ref type="bibr" target="#b9">(10)</ref>, i.e., µ</p><formula xml:id="formula_18">dec km + υ dec km -R dec km ≥ ϵ if R dec km &gt; 0.</formula><p>Proof. See Appendix B.</p><p>We emphasize that the time-average arrival and service rates R dec km , µ dec km , and υ dec km need not be equal to the corresponding values for the original MDP, i.e., R * km , µ * km and υ * km . Theorem 1 can be intuitively explained by noting that the probability θ dec h ′ h is chosen to be equal to the fraction of time that the relaxed MDP chooses to switch to configuration h ′ given that the last configuration was h, in steady state. Similarly, ζ dec la (r) is chosen to be equal to the fraction of time the relaxed MDP chooses routing vector r ∈ R(l, a) given that the current user location and request arrival states are (l, a), in steady state, and the same applies to the back-end routing decisions. Thus, it can be seen that the decoupled control algorithm tries to match the time-average costs of the relaxed policy while meeting the queue stability constraints. Note that under the decoupled control algorithm, the reconfiguration and local servicing decisions are a function only of the configuration state h while the routing is only a function of the user location and arrival states (l, a). It should also be noted that in our model, the latter states (l, a) evolve on their own, independent of the control actions of this algorithm. On the other hand, the evolution of the configuration state is completely governed by this control algorithm. Finally, we note that the decoupled control algorithm is expressed in terms of the steady state probabilities and control actions of the optimal solution of the relaxed MDP which is itself hard to calculate and requires knowledge of the statistics of the mobility or arrival processes that may not be available. However, our objective is not to calculate this control algorithm explicitly. Rather, we will use its existence to obtain an alternate online control algorithm that will track the performance of this control algorithm. The online algorithm does not require any knowledge of the statistics of the mobility or arrival processes and can be implemented efficiently.</p><p>Further, the online algorithm stabilizes all queues and provides worst-case delay bounds for all requests. Recall that H ′ is the set of all configuration states h ′ for which denote the time spent in other configurations before returning to h (recurrence time). Then, by basic renewal theory <ref type="bibr" target="#b17">[18]</ref>, the following holds for all t.</p><formula xml:id="formula_19"> l ′ a ′ π xdp φ ′ &gt; 0. It</formula><formula xml:id="formula_20">E  t+T dec h -1  τ =t µ dec km (τ )  E  T dec h  = µ dec km , E  t+T dec h -1  τ =t W dec (τ )  E  T dec h  = w * .<label>(14)</label></formula><p>Further, the first and second moments of the recurrence times, i.e., E</p><formula xml:id="formula_21"> T dec h  and E  (T dec h ) 2 </formula><p>are bounded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Online control algorithm</head><p>We now present an online control algorithm that makes joint request routing and application configuration decisions as a function of the system state (l(t), a(t), h(t), U (t)). However, unlike traditional MDP solution approaches such as dynamic programming <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>, this algorithm does not require any knowledge of the transition probabilities that govern the system dynamics. In addition to the request queues U km (t), for each (k, m) this algorithm maintains the following ''delay-aware'' queues that are used to provide worst-case delay guarantees for user requests (as shown later in Theorem 3) and are similar to the delay-aware queues used in <ref type="bibr" target="#b7">[8]</ref>.</p><formula xml:id="formula_22">Z km (t + 1) =  max[Z km (t) -µ km (t) -υ km (t) + σ km , 0] if U km (t) &gt; µ km (t) + υ km (t), 0 if U km (t) ≤ µ km (t) + υ km (t)<label>(15)</label></formula><p>where 0 ≤ σ km ≤ υ max km are control parameters that affect the delay guarantees offered by this algorithm. Our algorithm also uses a control parameter V &gt; 0 that affects a cost-delay tradeoff made precise in Theorem 3. Denote the collection {Z km (t)} by Z (t) and the collection {σ km } by σ. We assume that all request queues U km (t) and delay-aware queues Z km (t) are initialized to 0 at t = 0. As shown in the following, our online algorithm is designed to ensure that all request and delayaware queues remain bounded for all t and this guarantees a deterministic worst-case delay bound for each request. Similar to the decoupled control algorithm defined by ( <ref type="formula" target="#formula_14">11</ref>)-( <ref type="formula" target="#formula_17">13</ref>), this algorithm consists of decoupled components for routing and reconfiguration decisions. The control decisions in each component are made independently but they are weakly coupled through the queue backlogs U (t) and Z (t). In the following, we describe each of these components in detail. The performance guarantees provided by our algorithm are presented in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">User-to-edge-cloud request routing</head><p>We first describe the user-to-edge-cloud routing component of the algorithm. In each slot t, the routing decisions {r knm (t)} are obtained by solving the following optimization problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Minimize</head><formula xml:id="formula_23"> k,m  n  U km (t) + Vc knm (t)  r knm (t) subject to {r knm (t)} ∈ R(l, a)<label>(16)</label></formula><p>where R(l, a) is defined by constraints ( <ref type="formula">1</ref> In contrast, here a weighted sum of queue length and transmission cost is used to determine the ''shortest'' queue. More generally, ( <ref type="formula" target="#formula_23">16</ref>) can be mapped to variants of matching problems on bipartite graphs. For example, consider the case where A max kn = 1 for all k, n, R max km = 1 for all k, m, and N ≤ M. Then ( <ref type="formula" target="#formula_23">16</ref>) becomes an instance of the minimum weight matching problem on a bipartite graph formed between the N users and M edge-clouds. This can be solved in polynomial time using well-known methods (such as in <ref type="bibr" target="#b18">[19]</ref>). For more general cases, ( <ref type="formula" target="#formula_23">16</ref>) becomes a generalized assignment problem that is NP-hard. However, efficient constant factor approximation algorithms are known for such problems <ref type="bibr" target="#b19">[20]</ref>. As we show in Theorem 3, using any such approximation algorithm instead of the optimal solution to ( <ref type="formula" target="#formula_23">16</ref>) ensures that the overall cost of the online algorithm is within the same approximation factor of the optimal cost. It should be noted that the routing component of the control algorithm considers only the current user location, request arrival, and queue backlog states to make decisions and is therefore myopic. Further, it does not require any knowledge of the mobility/arrival model. We also note that it does not depend on the application configuration state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Edge-cloud to back-end cloud request routing</head><p>The back-end routing decisions {υ km (t)} are obtained by solving the following optimization problem every slot.</p><p>Minimize</p><formula xml:id="formula_24"> km  Ve km -U km (t) -Z km (t)  υ km (t) subject to 0 ≤ υ km (t) ≤ min[U km (t), υ max km ] ∀k, m. (<label>17</label></formula><formula xml:id="formula_25">)</formula><p>This problem is separable across (k, m) and has a simple solution given by υ km (t) = min[U km (t), υ max km ] when U km (t) + Z km (t) &gt; Ve km and υ km (t) = 0 else. Similar to request routing, the back-end routing algorithm considers only current queue backlogs (as e km is a constant) and does not require any knowledge of the user mobility or request arrival model. Further, it does not depend on the application configuration state. The structure of the back-end routing decisions results in the following bounds on U km (t) and Z km (t).</p><formula xml:id="formula_26">Lemma 1. Suppose υ max km ≥ R max</formula><p>km for all k, m. Then, under the back-end routing decisions resulting from <ref type="bibr" target="#b16">(17)</ref>, the following hold for all t.</p><formula xml:id="formula_27">U km (t) ≤ U max km = Ve km + R max km (18) Z km (t) ≤ Z max km = Ve km + σ km .<label>(19)</label></formula><p>Proof. We show that (18) holds using induction. First, <ref type="bibr" target="#b17">(18)</ref>  </p><formula xml:id="formula_28">U km (t + 1) ≤ U km (t) ≤ U max km .</formula><p>The bound <ref type="bibr" target="#b18">(19)</ref> follows similarly and its proof is omitted for brevity.</p><p>In Theorem 3, we show that for any σ km &gt; 0, the above bounds result in deterministic worst case delay bounds for any request that gets routed to U km (t).</p><p>Fig. <ref type="figure">2</ref>. Illustration of the directed acyclic graph on the application configuration states over a renewal frame. Frame f starts at slot t f with the configuration changing from h 0 to one of h 1 , h 2 , h 3 and ends at slot t f + 4 when the configuration becomes h 0 again.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Application reconfiguration</head><p>The third component of the online algorithm performs application reconfigurations over time. We first define the notion of a renewal state under this reconfiguration algorithm. Consider any specific state h 0 ∈ H ′ and designate it as the renewal state. The application reconfiguration algorithm presented in this section is designed to operate over variable length renewal frames where each frame starts with the initial configuration h 0 (excluded from the current frame) and ends when it returns to the state h 0 (included in the current frame). All application configuration decisions for a frame are made at the start of the frame and are recalculated for each new frame as a function of the queue backlogs at the start of the frame. Note that the system configuration in the last slot of each frame is h 0 . Each visit to h 0 defines a renewal event and initiates a new frame that starts from the next slot and lasts until (and including) the slot when the next renewal event happens as illustrated by an example in Fig. <ref type="figure">2</ref>. The renewal event and the resulting frame length are fully determined by the configuration decisions of the reconfiguration algorithm, i.e., they are deterministic functions of the configuration decisions. In the following, we denote the length of the f th renewal frame by T f and the starting slot of the f th renewal frame by t f . Note that T f = t f +1 -t f . For simplicity, we assume t 0 = 0.</p><p>Recall that H ′ is the set of all configuration states h ′ for which</p><formula xml:id="formula_29"> l ′ a ′ π xdp φ ′ &gt; 0.</formula><p>In principle, any state in H ′ can be chosen to be the renewal state h 0 . However, H ′ itself may not be known a priori. Further, in practice, h 0 should be chosen as the configuration that is likely to be used frequently by the optimal policy for the relaxed MDP presented in Section 4. Here, we assume that the reconfiguration algorithm can select a renewal state h 0 ∈ H ′ and leave the determination of optimal selection of h 0 for future work.</p><p>Let the collection of queue backlogs at the start of renewal frame f be denoted by {U km (t f )} and {Z km (t f )}. Then the reconfiguration algorithm makes decisions on the frame length T f and the application configurations [h(t f ), h(t f + 1), . . . , h(t f + T f -1)] by solving the following optimization at t f . Minimize 1</p><formula xml:id="formula_30">T f T f -1  τ =0  Jτ + VW (t f + τ ) -  km G km (t f , τ )  subject to h(t f + T f -1) = h 0 h(t f + τ ) ∈ H \ h 0 ∀τ ∈ {0, . . . , T f -2} T f ≥ 1 (<label>20</label></formula><formula xml:id="formula_31">)</formula><p>where</p><formula xml:id="formula_32">G km (τ , t f ) =  U km (t f ) + Z km (t f )  µ km (t f + τ )</formula><p>denotes the queue-length weighted service rate, W (t f + τ ) denotes the reconfiguration cost incurred in slot (t f + τ ), and J =  km J km where J km is a constant defined as J km 2(µ max</p><formula xml:id="formula_33">km + υ max km ) 2 + σ 2 km + (R max km ) 2 .</formula><p>Note that the constraint h(t f + T f -1) = h 0 enforces the renewal condition. Note also that when the frame starts (τ = 0), the configuration in the previous slot t f -1 was h 0 . The problem above minimizes the ratio of the sum total ''penalty'' earned in the frame (given by the summation multiplying 1/T f above) to the length of the frame. The penalty term is a sum of V times the reconfiguration costs (VW (t f + τ )) and the Jτ terms minus the queue-length weighted service rates</p><formula xml:id="formula_34">(  km G km (t f , τ )).</formula><p>Since the sum of the Jτ terms grows quadratically with frame size, this discourages the use of longer frames. Note also that since the overall objective only uses the queue backlog values at the start of the frame and since all the other terms are deterministic functions of the sequence of configurations [h(t f ), . . . , h(t f + T f -1)], the optimization problem (20) can be mapped to a deterministic shortest path problem involving T f stages. Specifically, as illustrated in Fig. <ref type="figure">2</ref>, consider a directed acyclic graph with T f +1 stages, one node each in the first and the last stage (corresponding to configuration h 0 ), and |H|-1 nodes per stage in all other stages. For a fixed T f , the objective in <ref type="bibr" target="#b19">(20)</ref> corresponds to finding the minimum cost path from the first to the last node, where the weight of each directed edge (h i , h j ) that is τ + 1 hops away from the first node is equal to the terms Jτ + VW (t f + τ ) - km G km (t f , τ ). Here, W (t f + τ ) is the switching cost between the configurations h i and h j while  km G km (t f , τ ) corresponds to the queue-length weighted service rate achieved using configuration h j . Given a T f , this has a complexity O(|H | 2 T f ) and optimally solving <ref type="bibr" target="#b19">(20)</ref> would require searching over all T f ≥ 1 since T f itself is an optimization variable in this problem. We next characterize an important property of the optimal solution to (20) that results in a significantly lower complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1.">Complexity reduction</head><p>Consider any solution to <ref type="bibr" target="#b19">(20)</ref> that results in a frame length of T f and a configuration sequence given by [h(t f ), . . . , h(t f + T f -2), h 0 ]. Then we have the following. Theorem 2. An optimal solution to (20) can be obtained by restricting to the class of policies that perform either two or no reconfigurations per frame. Further, the reconfigurations (if any) happen only in the first slot and the last slot of the frame.</p><p>Proof. First consider the case 1 ≤ T f ≤ 2. By definition the last configuration in the frame must be h 0 . Similarly, the configuration in the previous slot before the start of the frame is h 0 . There can be at most one more configuration between these. Thus, there can be at most two reconfigurations in the frame.</p><p>Next, consider the case T f &gt; 2. Let the queue backlogs at the start of frame be U (t f ), Z (t f ) and suppose the optimal configuration sequence is given by [h(t f ), . . . , h(t f + T f -2), h 0 ]. Denote the set of configurations in this sequence by Ω(U (t f ), Z (t f )) and define h opt (U (t f ), Z (t f )) as the configuration from this sequence that minimizes the following:</p><formula xml:id="formula_35">h opt (U (t f ), Z (t f )) = arg min h∈Ω(U (t f ),Z(t f ))  km  U km (t f ) + Z km (t f )  µ km (t f + τ ).<label>(21)</label></formula><p>Now consider an alternate configuration sequence given by [h opt (u f ), . . . , by property (4). The theorem follows by noting that at most two reconfigurations are needed in the alternate sequence, one at the beginning and one at the end of the frame.</p><formula xml:id="formula_36">h opt (u f ), h 0 ].</formula><p>For a given frame length T f , Theorem 2 reduces the complexity of solving <ref type="bibr" target="#b19">(20)</ref> from</p><formula xml:id="formula_37">O(|H | 2 T f ) to O(|H |) since we only</formula><p>need to search for one configuration per frame. In Section 5.3.2, we show that the reconfiguration algorithm can be further simplified by finding a closed-form expression for the optimal frame length given a configuration h. This frame length is</p><formula xml:id="formula_38">O   km U km (t f ) + Z km (t f )</formula><p> which shows that the frame length is always bounded, given that {U km (t f )} and {Z km (t f )} are bounded (see Lemma 1). We also discuss special cases where <ref type="bibr" target="#b19">(20)</ref> can be mapped to bipartite graph matching problems.</p><p>We will show that similar to the routing component, using any approximation algorithm instead of the optimal solution to (20) still ensures that the overall cost of the reconfiguration algorithm is within the same constant factor of the optimal cost (Theorem 3, part 3). We analyze the performance of the overall control algorithm, including the components for request routing (Sections 5.1 and 5.2) and the component for application reconfiguration in Section 6. Before proceeding, we note that similar to the routing components, the reconfiguration algorithm does not require any statistical knowledge of the request arrival or user mobility processes. Further, it depends only on the queue backlog at the start of the frame, thereby decoupling it from the routing decisions in that frame. However, unlike the routing components that make decisions on a per slot basis (using current system states), the reconfiguration algorithm computes the sequence of configurations once per frame (at the start of the frame) and implements it over the course of the frame.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2.">Calculating the optimal frame length</head><p>Given that a configuration state h is used in a frame, we show that the optimal frame length T opt (h) can be easily calculated, thereby further reducing complexity. Specifically, let us denote the values of various terms in the objective of <ref type="bibr" target="#b19">(20)</ref> when configuration h 0 or h is used as follows:</p><formula xml:id="formula_39">Θ(h 0 ) = -  km G h 0 km (t f , τ ) = -  km (U km (t f ) + Z km (t f ))µ h 0 km , Θ(h) = -  km G h km (t f , τ ) = -  km (U km (t f )+Z km (t f ))µ h km , W sum = W h 0 h +W hh 0 , where µ h 0</formula><p>km , µ h km denote the service rate µ km when configurations h 0 and h are used. Also, let B =  km J km /2. Then, in order to calculate the optimal frame length, we have two cases. If no reconfiguration is done, then frame length is 1 and the objective of (20) becomes Θ(h 0 ). Else, if a reconfiguration is done, the frame length is at least 2 and the objective of (20) can rewritten as min</p><formula xml:id="formula_40">T f ≥2 Θ(h 0 ) + Θ(h)(T f -1) + BT f (T f -1) + VW sum T f .</formula><p>Ignoring the constant terms, the above can be simplified to min</p><formula xml:id="formula_41">T f ≥2 BT f + VW sum + Θ(h 0 ) -Θ(h) T f</formula><p>.</p><p>If VW sum + Θ(h 0 ) -Θ(h) ≤ 0, then the optimal frame length is T f = 2. Else, by taking derivative, we get that the optimal T f is one of the two integers closest to</p><formula xml:id="formula_42"> VW sum +Θ(h 0 )-Θ(h) B</formula><p>. Define T * f (h) as the optimal frame length given that a switching to configuration h is done. Then, to calculate the overall optimal frame length T opt (h), we compare the value of the objective of (20) under T * f (h) with that under frame length one (i.e., Θ(h 0 )) and select the one that results in a smaller objective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3.">Bipartite matching</head><p>Note that a complexity of O(|H |) can still be high if there are a large number of possible configurations. For example, consider the case where at most one application can be hosted by any edge-cloud and where exactly one instance of each application is allowed per slot across the edge-clouds. Assume M ≥ K . In this case, |H| = M! (M-K )! which is exponential in M, K . Now assume that the total reconfiguration cost is separable across applications, the service rate of each edge-cloud is independent of configurations at the other edge-clouds, and the other settings are the same as in the above example. Then <ref type="bibr" target="#b19">(20)</ref> can be reduced to a maximum weight matching problem on a bipartite graph formed between K applications and M edge-clouds. Let m ′ k denote the edge-cloud hosting application k in the renewal state h 0 . Then in the bipartite graph, the weight for any edge (k, m) (when m ̸ = m ′ k ) for a given frame length</p><formula xml:id="formula_43">T f becomes (U km ′ k (t f ) + Z km ′ k (t f ))µ km ′ k + (T f - 1)(U km (t f ) + Z km (t f ))µ km -V (W k,m ′ k ,m + W k,m,m ′ k ) - J km T f (T f -1) 2 where W k,m ′ k ,m (W k,m,m ′ k ) denotes the reconfiguration cost associated with moving application k from edge-cloud m ′ k (m) to edge-cloud m (m ′ k ). When m = m ′ k , the weight for the edge (k, m) is simply (U km ′ k (t f ) + Z km ′ k (t f ))µ km ′ k .</formula><p>For a given T f , the optimal configuration that solves (20) can be obtained by finding the maximum weight matching on this bipartite graph and this is polynomial in M, K <ref type="bibr" target="#b18">[19]</ref>. This is in contrast to simply searching over all H that is exponential in M, K . For more general cases where each application can have multiple instances and multiple application instances are allowed on each edge-cloud, the problem becomes a generalized assignment problem and constant factor approximation algorithms exist <ref type="bibr" target="#b19">[20]</ref>, as long as different application instances can be considered separately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Performance analysis</head><p>We now analyze the performance of the online control algorithm presented in Section 5. This is based on the technique of Lyapunov optimization over renewal periods <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17]</ref> where we compare the ratio of a weighted combination of the Lyapunov drift and costs over a renewal period and the length of the period under the online algorithm with the same ratio under a stationary algorithm that is queue backlog independent. This stationary algorithm is defined similarly to the decoupled control algorithm given by ( <ref type="formula" target="#formula_14">11</ref>)-( <ref type="formula" target="#formula_17">13</ref>) and we use the subscript ''stat'' to denote its control actions and the resulting service rates and costs. Then the reconfiguration and routing decisions are defined by probabilities θ stat hh ′ , ζ stat la (r), and ϑ stat (υ) that are chosen to be equal to θ dec hh ′ , ζ dec la (r), and ϑ dec (υ) respectively. If the resulting expected total service rate of any delayaware queue Z km (t) is less than σ km , then its back-end request routing is augmented by choosing additional υ km (t) in an i.i.d. manner such that the expected total service rate becomes σ km . It can be shown that the resulting time-average backend routing cost under this algorithm is at most e * + φ(σ) where φ(σ) =  km max[σ km -µ dec km -υ dec km , 0]e km . By comparing the Lyapunov drift plus cost of the online control algorithm over renewal frames with this stationary algorithm, we have the following.</p><p>Theorem 3. Suppose the online control algorithm defined by ( <ref type="formula" target="#formula_23">16</ref>), <ref type="bibr" target="#b16">(17)</ref>, and (20) is implemented with a renewal state h 0 ∈ H ′ using control parameters V &gt; 0 and 0 ≤ σ km ≤ υ max km for all k, m. Denote the resulting sequence of renewal times by t f where f ∈ {0, 1, 2, . . .} and let T f = t f +1 -t f denote the length of frame f . Assume t 0 = 0 and that U km (t 0 ) = 0, Z km (t 0 ) = 0 for all k, m. Then the following bounds hold.</p><p>(1) The time-average expected transmission plus reconfiguration costs satisfy lim</p><formula xml:id="formula_44">F →∞ F -1  f =0 E  t f +1 -1  τ =t f C (τ ) + W (τ ) + E(τ )  F -1  f =0 E  T f  ≤ c * + w * + e * + φ(σ) + 1 +  km B km V (<label>22</label></formula><formula xml:id="formula_45">)</formula><p>where</p><formula xml:id="formula_46">B km = (1 + Υ dec h 0 )J km /2 + δ(R max km ) 2 , Υ dec h 0 = E  T dec h 0 (T dec h 0 -1)  E  T dec h 0  , φ(σ) =  km max[σ km -µ dec km -υ dec km , 0]e km</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and δ is an O(log V ) parameter that is a function of the mixing time of the Markov chain defined by the user location and request arrival processes while all other terms are constants (independent of V ).</head><p>(2) For all k, m, the worst-case delay d max km for any request routed to queue U km (t) is upper bounded by</p><formula xml:id="formula_47">d max km ≤ U max km + Z max km σ km = 2Ve km + R max km + σ km σ km .<label>(23)</label></formula><p>(3) Suppose we implement an algorithm that approximately solves <ref type="bibr" target="#b15">(16)</ref> and (20) resulting in the following bound for all slots for some ρ ≥ 1</p><formula xml:id="formula_48"> km  n  U km (t) + Vc knm (t)  r apx knm (t) ≤ ρ  km  n  U km (t) + Vc knm (t)  r opt knm (t) (24)</formula><p>and the following bound for every renewal frame</p><formula xml:id="formula_49">1 T apx f T apx f -1  τ =0   km ρJ km τ -  U km (t f ) + Z km (t f )  µ apx km (t f + τ )  + VW apx (t f + τ ) ≤ B ′ + ρ T opt f T opt f -1  τ =0   km J km τ -  U km (t f ) + Z km (t f )  µ opt km (t f + τ )  + VW opt (t f + τ ) (25)</formula><p>for some constant B ′ where the subscripts ''apx'' and ''opt'' denote the control decisions and resulting costs under the approximate algorithm and the optimal solution to ( <ref type="formula" target="#formula_23">16</ref>) and (20) respectively. Then the time-average expected transmission plus reconfiguration costs under this approximation algorithm is at most</p><formula xml:id="formula_50">ρ  c * + w * + e * + φ(σ) + 1 +  km B km + (R max km + σ km )υ max km V  + B ′ -  km (R max km + σ km )υ max km V (<label>26</label></formula><formula xml:id="formula_51">)</formula><p>while the delay bounds remain the same as (23).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. See Appendix C.</head><p>Discussion on performance tradeoffs: Our control algorithm offers tradeoffs between cost and delay performance guarantees through the control parameters V and σ. For a given V and σ, the bound in <ref type="bibr" target="#b21">(22)</ref> implies that the time-average expected transmission plus reconfiguration costs are within an additive term φ(σ) + O(log V /V ) term of the optimal cost while (23) bounds the worst case delay by O(V /σ km ). This shows that by increasing V and decreasing σ, the time-average cost can be pushed arbitrarily close to optimal at the cost of an increase in delay. This cost-delay tradeoff is similar to the results in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref> for non-MDP problems. Thus, it is noteworthy that we can achieve similar tradeoff in an MDP setting. Note that if there exists σ km &gt; 0 ∀k, m such that σ km ≤ µ dec km + υ dec km , then φ(σ) = 0 and the tradeoff can be expressed purely in terms of V . Also note that since the average delay is upper bounded by the worst case delay, our algorithm provides an additive approximation with respect to the cost c * +w * +e * and a multiplicative approximation with respect to the average delay d avg of the optimal solution to the original MDP defined in Section 3.2.</p><p>In practice, setting σ km = 0 ∀k, m should yield good delay performance even though (23) becomes unbounded. This is because our control algorithm ensures that all queues remain bounded even when σ km = 0 (see Lemma 1). This hypothesis is confirmed by the simulation results in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Evaluations</head><p>We evaluate the performance of our control algorithm using simulations. To show both the theoretical and real-world behaviors of the algorithm, we consider two types of user mobility traces. The first is a set of synthetic traces obtained from a random-walk user mobility model while the second is a set of real-world traces of San Francisco taxis <ref type="bibr" target="#b20">[21]</ref>. We assume that the edge-clouds are co-located with a subset of the basestations of a cellular network. A hexagonal symmetric cellular structure is assumed with 91 cells in total as shown in Fig. <ref type="figure" target="#fig_1">3</ref>. Out of the 91 basestations, 10 host edge-clouds and there are 5 applications in total. For simplicity, each edge-cloud can host at most one application in any slot in the simulation. Further, there can be only one active instance of any application in a slot.</p><p>The transmission and reconfiguration costs are defined as a function of the distance (measured by the smallest number of hops) between different cells. When a user n in cell l routes its request to the edge-cloud in cell l ′ , we define its transmission cost as</p><formula xml:id="formula_52">trans n (l, l ′ ) =  1 + 0.1 • dist(l, l ′ ), if l ̸ = l ′ 0, if l = l ′ (27)</formula><p>where dist(l, l ′ ) is the number of hops between cells l and l ′ . The reconfiguration cost of different applications is assumed to be independent. For any application k that is moved from the edge-cloud in cell l to the edge-cloud in cell l ′ , the reconfiguration cost for this specific application is defined as</p><formula xml:id="formula_53">recon k (l, l ′ ) =  κ(1 + 0.1 • dist(l, l ′ )), if l ̸ = l ′ 0, if l = l ′ (<label>28</label></formula><formula xml:id="formula_54">)</formula><p>where κ is a weighting factor to compare the reconfiguration cost to the transmission cost. The total reconfiguration cost is the sum of reconfiguration costs across all k. In the simulations, we consider two cases in which κ takes the values 0.5 and 1.5 respectively, to represent cases where the reconfiguration cost is smaller/larger than the transmission cost. Both cases can occur in practice depending on the amount of state information the application has to transfer during reconfiguration.</p><p>The back-end routing cost is fixed as a constant 2 for each request.</p><p>Each user generates requests for an application according to a fixed probability λ per slot. However, the number of active users in the system can change over time. Thus, the aggregate request arrival rate across all users for an application varies as a function of the number of active users in a slot. In our study of synthetic mobility traces, we assume that the number of users is fixed to 10 and all of them are active. However, the real-world mobility trace has a time-varying number of active users. In both cases, λ is the time-average (over the simulation duration) aggregate arrival rate per application per slot, while the edge cloud service rate for an active application instance is 1 per slot, and the back-end cloud service rate for each application is 2 per slot. The request arrivals are assumed to be independent and identically distributed among different users, and they are also independent of the past arrivals and user locations. We note that optimally solving the original or even relaxed MDP for this network is highly challenging. Therefore, we compare the performance of our algorithm with three alternate approaches that include never/always migrate policies and a myopic policy. In the never migrate policy, each application is initially placed at one particular edge-cloud and reconfiguration never happens. User requests are always routed to the edge-cloud that hosts the corresponding application. In the always migrate policy, user requests are always routed to the edge-cloud that is closest to the user and reconfiguration is performed in such a way that the queues with the largest backlogs are served first (subject to the constraint that each edge-cloud can only host one application). We also assume that the request arrival rate λ is known in the never and always migrate policies. If λ &gt; 1, the arrival rate exceeds the edge-cloud capacity, and the requests that are queued in edge-clouds are probabilistically routed to the back-end cloud, where the probability is chosen such that the average arrival rate to edgeclouds does not exceed the service rate at edge clouds. Finally, the myopic policy considers the transmission, reconfiguration, and back-end routing costs jointly in every slot. Specifically, in each slot, it calculates a routing and configuration option that minimizes the sum of these three types of costs in a single slot, where it is assumed that a user routes its request either to the back-end cloud or to the edge-cloud that hosts the application after possible reconfiguration.</p><p>The online algorithm itself is implemented by making use of the structure of the optimal solution as discussed in Section 5. Specifically, we implement the request routing part ( <ref type="formula" target="#formula_23">16</ref>) by solving the bipartite max-weight matching problem as discussed in Section 5.1 while the application reconfiguration part <ref type="bibr" target="#b19">(20)</ref> uses the techniques in Sections 5.3.3 and 5.3.2. Because the proposed online algorithm is obtained using a (loose) upper bound on the drift-plus-penalty terms, the actual drift-pluspenalty value can be much smaller than the upper bound. We take into account this fact by adjusting the constant terms J km in <ref type="bibr" target="#b19">(20)</ref>. We set J km = 0.2 in the simulation which is a reasonably good number that we found experimentally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Synthetic traces</head><p>We first evaluate the performance of our algorithm along with the three alternate approaches on synthetic mobility traces. The synthetic traces are obtained assuming random-walk user mobility. Specifically, at the beginning of each slot, a user moves to one of its neighboring cells with probability 1/7 for each cell, and it stays in the same cell with probability 1/7. When the number of neighboring cells is less than six, the corresponding probability is added to the probability of staying in the same cell. Such a mobility model can be described as a Markov chain and therefore our theoretical analysis applies.</p><p>There are 10 users in this simulation, and we simulate the system for 100,000 slots. The average queue length and the average transmission plus reconfiguration plus back-end routing costs over the entire simulation duration are first studied for different values of the control parameters V as well as {σ km }. Specifically, we set all σ km to the same value σ which is chosen from σ ∈ {0, 0.1, 0.5}. The performance results for all four algorithms under these scenarios are shown in Fig. <ref type="figure">4</ref> for both values of κ, where we set λ = 0.95.</p><p>We can see from the results that, for each fixed σ , the queue lengths and cost values under the Lyapunov algorithm follow the O(V , log V /V ) trend as suggested by the bounds ( <ref type="formula" target="#formula_44">22</ref>) and ( <ref type="formula" target="#formula_47">23</ref>). The impact of the value of σ is also as predicted by these bounds. Namely, a smaller value of σ yields larger queue lengths and lower costs, while a larger value of σ yields smaller queue lengths and higher costs. When comparing all four algorithms in Fig. <ref type="figure">4</ref> while the never/always migrate policies have smaller queue backlogs, they incur more cost than the Lyapunov algorithm. Note that, unlike the Lyapunov algorithm, none of the alternate approaches offer a mechanism to trade off queue backlog (and hence average delay) performance for a reduction in cost. For the case κ = 1.5, similar behavior is seen as illustrated by Fig.</p><p>We next study the queue lengths and costs under different values of the arrival rate λ, where we fix V = 100 and σ = 0.</p><p>Results are shown in Fig. <ref type="figure">5</ref>. We can see that with the myopic policy, the queue lengths are very large and in fact become unbounded. This is because the myopic policy does not try to match the edge-cloud arrival rate with its service rate, and it is also independent of the queue backlog. Because the one-slot cost of routing to an edge-cloud is usually lower than routing to the back-end cloud, an excessive amount of requests is routed to edge-clouds exceeding their service capacity. The never and always migrate policies have low queue backlogs because we matched the request routing with the service rate of edge-clouds, as explained earlier. However, they incur higher costs as shown in Fig. <ref type="figure">5</ref>(b), (d). More importantly, they require prior knowledge on the arrival rate, which it is usually difficult to obtain in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Real-world mobility</head><p>To study the performance under more realistic user mobility, we use real-world traces of San Francisco taxis <ref type="bibr" target="#b20">[21]</ref> that is a collection of GPS coordinates of approximately 500 taxis collected over 24 days in the San Francisco Bay Area. In our simulation, we select a subset of this data that corresponds to a period of 5 consecutive days. We set the distance between basestations (center of cell) to 1000 m, and the hexagon structure is placed onto the geographical location. User locations are then mapped to the cell location by considering which cell the user lies in. In this dataset, there are 536 unique users in total, and not all of them are active at a given time. The number of active users at any time ranges from 0 to 409, and 278 users are active on average. We assume that only active users generate requests such that the average arrival rate over the entire duration is λ = 0.95 for each application. With this model, when the number of active users is large (small), the instantaneous arrival rate can be higher (lower) than the edge-cloud service rate. The underlying mobility pattern in this scenario can be quite different from a stationary Markov model and exhibits non-stationary behavior.</p><p>We set the timeslot length as 1 s and fix V = 100, σ = 0 for the Lyapunov algorithm. The purpose of this simulation is to study the temporal behavior of queue lengths and cost values under our algorithm and compare with the alternate approaches. We find that while the queue lengths change relatively slowly, the per slot costs fluctuate rapidly. Therefore, we measure the moving average of the costs over an interval of size 6000 s for all algorithms. Figs. <ref type="figure">6</ref> and<ref type="figure" target="#fig_4">7</ref> show the results respectively for the case κ = 0.5 and κ = 1.5, and the average values across the entire time duration are given in Table <ref type="table" target="#tab_5">1</ref>.</p><p>There are several noteworthy observations. From Table <ref type="table" target="#tab_5">1</ref>, we can see that even though σ = 0, the average queue length under the Lyapunov approach is significantly lower than all other approaches, while the cost of the Lyapunov approach is lower than all other approaches when κ = 0.5 and only slightly higher than the never migrate and myopic policies when κ = 1.5. This confirms that the proposed Lyapunov algorithm has promising performance with real-world user traces. As shown in Figs. <ref type="figure">6</ref> and<ref type="figure" target="#fig_4">7</ref>, the cost results show a noticeable diurnal behavior with 5 peaks and valleys that match with the  5 day simulation period. The cost of the Lyapunov algorithm becomes higher than some other approaches at peaks, which is mainly due to the presence of back-end routing. At the same time, however, the difference between the queue length of the Lyapunov algorithm and the other approaches is also larger at such peaks. We see that the Lyapunov approach has the lowest variation in its queue length, which is a consequence of our design goal of bounding the worst-case delay. The queue lengths of the other approaches fluctuate more, and the always migrate policy appears to be unstable as the queue backlogs grow unbounded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions</head><p>In this paper, we have developed a new approach for solving a class of constrained MDPs that possess a decoupling property. When this property holds, our approach enables the design of simple online control algorithms that do not require any knowledge of the underlying statistics of the MDPs, yet are provably optimal. The resulting solution is markedly different from classical dynamic programming based approaches and does not suffer from the associated ''curse of dimensionality'' or convergence issues. We applied this technique to the problem of dynamic service migration and workload scheduling in the emerging area of edge-clouds and showed how it results in an efficient control algorithm for this problem. Our overall approach is promising and could be useful in a variety of other contexts. those of the author(s) and should not be interpreted as representing the official policies, either expressed or implied, of the US Army Research Laboratory, the US Government, the UK Ministry of Defence or the UK Government. The US and UK Governments are authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation hereon.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Relaxed MDP formulation</head><p>An optimal stationary, randomized control algorithm for the relaxed MDP can be defined as follows. First, given last state</p><formula xml:id="formula_56">φ ′ = (l(t -1) = l ′ , a(t -1) = a ′ , h(t -1) = h ′</formula><p>) and current states l(t) = l, a(t) = a, it chooses configuration h(t) = h with probability z φ ′ φ where φ = (l(t) = l, a(t) = a, h(t) = h). The total expected reconfiguration cost incurred when transitioning from state φ ′ is given by</p><formula xml:id="formula_57">W φ ′ =  φ p l ′ l q a ′ a z φ ′ φ W h ′ h .<label>(29)</label></formula><p>Next, given current state φ = (l(t) = l, a(t) = a, h(t) = h), it chooses a routing vector r(t) = r with probability x φ (r) subject to the constraint that r ∈ R(l, a) and incurs a total expected transmission cost of</p><formula xml:id="formula_58">C φ =  r∈R(l,a)</formula><p>x φ (r)  knm r knm c knm .</p><p>Finally, given current state φ = (l(t) = l, a(t) = a, h(t) = h), it chooses a back-end routing vector υ(t) = υ with probability y φ (υ) subject to υ ∈ V and this incurs a total expected back-end transmission cost given by</p><formula xml:id="formula_60">E φ =  υ∈V y φ (υ)  km υ km e km .<label>(31)</label></formula><p>Let us denote the steady state probability of being in state φ under this policy by π φ . Then, the overall time-average expected transmission plus reconfiguration cost satisfies</p><formula xml:id="formula_61">C + E + W =  φ π φ C φ +  φ π φ E φ +  φ π φ W φ = c * + e * + w * .<label>(32)</label></formula><p>Note that the relaxed MDP still has a high-dimensional state space making it impractical to solve using standard techniques. Further, we still need knowledge of all transition probabilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Cost optimality of decoupled MDP</head><p>Here we prove Theorem 1 through a series of lemmas. For notational convenience, we use φ and lah interchangeably throughout this section. Recall that H ′ is the set of all configuration states h ′ for which</p><formula xml:id="formula_62"> l ′ a ′ π xdp φ ′ &gt; 0.</formula><p>Then for all h ′ , h ∈ H ′ , we define matrix F = (θ dec h ′ h ) where θ dec h ′ h is given by <ref type="bibr" target="#b10">(11)</ref>.</p><p>Lemma 2. F is a stochastic matrix.</p><p>Proof. In order for F = (θ dec h ′ h ) to be a stochastic matrix, we need</p><formula xml:id="formula_63"> h∈H ′ θ dec h ′ h = 1 for all h ′ ∈ H ′ . Fix an h ′ ∈ H ′ . Using (11),</formula><p>we have</p><formula xml:id="formula_64"> h∈H ′ θ dec h ′ h =  h∈H θ dec h ′ h =  h∈H  l ′ a ′ π xdp φ ′   la p l ′ l q a ′ a z xdp φ ′ φ   l ′ a ′ π xdp φ ′ =  l ′ a ′ π xdp φ ′   φ p l ′ l q a ′ a z xdp φ ′ φ   l ′ a ′ π xdp φ ′ =  la π xdp φ  la π xdp φ = 1.</formula><p>Since this holds for all h ′ ∈ H ′ , the lemma follows.</p><p>From Lemma 2, it follows that F can be thought of as the transition probability matrix the Markov chain over the set H ′ of configuration states that results from the reconfiguration policy (11) of the decoupled control algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.</head><p>For all h ∈ H, the fraction of time spent in configuration h under the reconfiguration policy <ref type="bibr" target="#b10">(11)</ref> of the decoupled control algorithm is equal to the fraction of time in configuration h under the relaxed MDP.</p><p>Proof. First, consider any state h ∈ H ′ . Let π F h denote the steady state probability for state h in the Markov chain defined by transition probability matrix F . This is well-defined and exists according to Lemma 2. It is well known that these steady state probabilities can be obtained as the unique solution to the system of equations π</p><formula xml:id="formula_65">F h =  h ′ ∈H ′ π F h ′ θ dec h ′ h for all h. We now show that choosing π F h ′ =  l ′ a ′ π xdp l ′ a ′ h ′ for all h ′ ∈ H ′ satisfies this system of equations. Upon substituting π F h ′ =  l ′ a ′ π xdp l ′ a ′ h ′ , the RHS  h ′ ∈H ′ π F h ′ θ dec h ′ h becomes  h ′ ∈H ′ π F h ′ θ dec h ′ h =  h ′ ∈H ′   l ′ a ′ π xdp l ′ a ′ h ′  θ dec h ′ h =  h ′ ∈H ′   l ′ a ′ π xdp l ′ a ′ h ′   l ′ a ′ π xdp l ′ a ′ h ′   la p l ′ l q a ′ a z xdp l ′ a ′ h ′ ,lah   l ′ a ′ π xdp l ′ a ′ h ′ =  h ′ ∈H ′  l ′ a ′ π xdp l ′ a ′ h ′   la p l ′ l q a ′ a z xdp l ′ a ′ h ′ ,lah  =  la  l ′ a ′  h ′ ∈H ′ π xdp l ′ a ′ h ′ p l ′ l q a ′ a z xdp l ′ a ′ h ′ ,lah =  la π xdp lah</formula><p>where we used <ref type="bibr" target="#b10">(11)</ref> in the second step. Similarly, upon substituting π</p><formula xml:id="formula_66">F h ′ =  l ′ a ′ π xdp l ′ a ′ h ′ , the LHS π F h ′ becomes: π F h ′ =  l ′ a ′ π xdp l ′ a ′ h ′ =  π xdp lah .</formula><p>This implies that π F h =  la π xdp lah for all h ∈ H ′ . This shows that the fraction of time spent in configuration h under the reconfiguration policy <ref type="bibr" target="#b10">(11)</ref>  </p><formula xml:id="formula_67"> h∈H π F h  h ′ ∈H θ dec hh ′ W hh ′ . Substituting π F h =  la π xdp</formula><p>lah (from Lemma 3) and using <ref type="bibr" target="#b10">(11)</ref>, we have:</p><formula xml:id="formula_68"> h∈H π F h  h ′ ∈H θ dec hh ′ W hh ′ =  h∈H   la π xdp lah   h ′ ∈H  la π xdp lah   l ′ a ′ p ll ′ q aa ′ z xdp lah,l ′ a ′ h ′   la π xdp lah W hh ′ =  h∈H  h ′ ∈H  la π xdp lah   l ′ a ′ p ll ′ q aa ′ z xdp lah,l ′ a ′ h ′  W hh ′ =  lah π xdp lah   l ′ a ′ h ′ p ll ′ q aa ′ z xdp lah,l ′ a ′ h ′ W hh ′  =  lah π xdp lah W xdp φ = w *</formula><p>where the last step follows from (29) and (32).</p><p>Theorem 1 part 1 follows from Lemma 4.</p><p>Lemma 5. Under the routing policy defined by <ref type="bibr" target="#b11">(12)</ref>, the time-average transmission cost of the decoupled algorithm is equal to that under the relaxed MDP, i.e., c * .</p><p>Proof. Let π la denote the fraction of time the decoupled MDP is in state (l(t) = l, a(t) = a). The time-average transmission cost under the routing policy defined by the probabilities in ( <ref type="formula" target="#formula_16">12</ref>) is given by</p><formula xml:id="formula_69"> la π la  r∈R(l,a)</formula><p>ζ dec la (r)</p><formula xml:id="formula_70"> knm r knm c knm =  la π la  r∈R(l,a)  h π xdp φ x xdp φ (r)   knm r knm c knm   h π xdp φ =  la π la  h π xdp φ  r∈R(l,a) x xdp φ (r)   knm r knm c knm   h π xdp φ =  la π la  h π xdp φ C xdp φ  h π xdp φ =  la  h π xdp φ C xdp φ = c *</formula><p>where in the second step we sum over only those (l, a) for which π la &gt; 0. In the second last step above, we used the fact that π la =  h∈H π xdp φ , i.e., the fraction of time the relaxed MDP is in state (l(t) = l, a(t) = a) is equal to π la . This is because these states evolve independent of the control actions of either control algorithms.</p><p>This shows Theorem 1 part 2.</p><p>Lemma 6. Under the back-end routing policy defined by <ref type="bibr" target="#b12">(13)</ref>, the time-average back-end transmission cost of the decoupled algorithm is equal to that under the relaxed MDP, i.e., e * .</p><p>Proof. The time-average transmission cost under the back-end routing policy defined by ( <ref type="formula" target="#formula_17">13</ref>) is given by </p><formula xml:id="formula_71">π la ζ dec la (r) = π la ×  h π xdp φ x xdp φ (r)  h π xdp φ =  h π xdp φ x xdp φ (r).</formula><p>This shows that the time-average arrival rate to any queue is the same under both algorithms. A similar result holds for average local service rates since these are only a function of the fraction of time spent in any configuration h which is the same under both MDPs. Finally, the fraction of time a back-end routing vector υ ∈ V is chosen under the relaxed MDP is given by Theorem 1 part 4 follows by noting that the time-average arrival and service rates to each queue U km (t) under the decoupled MDP satisfy <ref type="bibr" target="#b9">(10)</ref>.</p><formula xml:id="formula_72"> φ π xdp</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C. Proof of Theorem 3</head><p>Let Q (t) = (U (t), Z (t)) denote the collection of queue backlogs in slot t. Define L(Q (t)) </p><formula xml:id="formula_73">(t + 1)) -L(Q (t)) as L(Q (t + 1)) -L(Q (t)) ≤  km  B u km + B z km -U km (t)  µ km (t) + υ km (t) -R km (t)  -Z km (t)  µ km (t) + υ km (t) -σ km   where B u km = ((µ max km + υ max km ) 2 + (R max km ) 2 )/2 and B z km = ((µ max km + υ max km ) 2 + σ 2 km )/2</formula><p>. Note that at any renewal time t f , the application configuration h(t f ) = h 0 . For ease of notation, we denote the collection of all queue backlogs, user locations, and arrival vectors at the start of renewal frame f by (t f ). Define the frame-based conditional Lyapunov drift ∆(t f ) as the expected change in the value of L(Q (t)) over the f th frame given initial state (t f ), i.e., ∆(t f )</p><formula xml:id="formula_74">E  L(Q (t f +1 )) -L(Q (t f ))| (t f )  .</formula><p>In the following, we use the shorthand notation</p><formula xml:id="formula_75">E c {.} to represent the conditional expectation E  .| (t f ) </formula><p>. Following the methodology in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17]</ref> and using the one-slot difference bound along with delayed queueing equations, we can obtain the following upper bound on the frame-based conditional Lyapunov drift plus V times the conditional expected transmission plus reconfiguration cost, i.e., ∆(t f )</p><formula xml:id="formula_76">+ V E c   t f +1 -1 τ =t f C (τ ) + W (τ ) + E(τ ) </formula><p>in terms of the control decisions under any algorithm (see Appendix D).</p><p></p><formula xml:id="formula_77">km E c  X km (T f )  -  km  U km (t f ) + Z km (t f )  E c  t f +1 -1  τ =t f µ km (τ )  -  km E c  t f +1 -1  τ =t f  U km (τ ) + Z km (τ )  υ km (τ )  +  km E c  t f +1 -1  τ =t f Z km (τ )σ km  +  km E c  t f +1 -1  τ =t f U km (τ )R km (τ )  + V E c  t f +1 -1  τ =t f C (τ ) + W (τ ) + E(τ ) <label>(33)</label></formula><p>where </p><formula xml:id="formula_78">X km (T f ) (B u km + B z km )T f + T f (T f -</formula><formula xml:id="formula_79">∆(t f ) + V E c   t f +1 -1 τ =t f C (τ ) + W (τ ) + E(τ )  under the online control algorithm by  km E c  X km (T f )  -  km  U km (t f ) + Z km (t f )  E c  t f +1 -1  τ =t f µ km (τ )  -  km E c  t f +1 -1  τ =t f  U km (τ ) + Z km (τ )  υ stat km (τ )  +  km E c  t f +1 -1  τ =t f Z km (τ )σ km  +  km E c  t f +1 -1  τ =t f U km (τ )R stat km (τ )  + V E c  t f +1 -1  τ =t f C stat (τ ) + W (τ ) + E stat (τ )  .<label>(34)</label></formula><p>Next, we use the following bounds obtained using delayed queue equations (details in Appendix E):</p><p>-</p><formula xml:id="formula_80"> km E c  t f +1 -1  τ =t f U km (τ )υ stat km (τ )  ≤ -  km U km (t f )υ stat km E c  T f  +  km E c  T f (T f -1) 2 (µ max km + υ max km )υ max km  (35) -  km E c  t f +1 -1  τ =t f Z km (τ )υ stat km (τ )  ≤ -  km Z km (t f )υ stat km E c  T f  +  km E c  T f (T f -1) 2 (µ max km + υ max km )υ max km  (36)  km E c  t f +1 -1  τ =t f Z km (τ )σ km  ≤  km Z km (t f )σ km E c  T f  +  km E c  T f (T f -1) 2 σ 2 km  (37)  km E c  t f +1 -1  τ =t f U km (τ )R stat km (τ )  ≤  km U km (t f )(R stat km + αγ δ )E c  T f  +  km E c  δT f (R max km ) 2 + T f (T f -1) 2 (R max km ) 2  +  km E c  x km (t f , t f +1 )  (38) E c  t f +1 -1  τ =t f C stat (τ )  ≤ (c * + βγ δ )E c  T f  + E c  y(t f , t f +1 )  (39) E c  t f +1 -1  τ =t f E stat (τ )  ≤ (e * + φ(σ))E c  T f <label>(40)</label></formula><p>where x km (t f , t f +1 ) and y(t f , t f +1 ) are defined as</p><formula xml:id="formula_81">x km (t f , t f +1 ) = t f +δ-1  τ =t f U km (τ )R stat km (τ ) - t f +1 +δ-1  τ =t f +1 U km (τ )R stat km (τ ), y(t f , t f +1 ) = t f +δ-1  τ =t f C stat (τ ) - t f +1 +δ-1  τ =t f +1 C stat (τ )</formula><p>and α ≥ 0, β ≥ 0, 0 &lt; γ &lt; 1 are constants that characterize how fast the Markov chain defined by the user location and request arrival processes mixes to its steady-state distribution and δ ≥ 0 is an integer whose value will be specified in the following. Substituting these, we get</p><formula xml:id="formula_82">∆(t f ) + V E c  t f +1 -1  τ =t f C (τ ) + W (τ ) + E(τ )  ≤  km E c  X ′ km (T f )  -  km  U km (t f ) + Z km (t f )  E c  t f +1 -1  τ =t f µ km (τ )  -  km  U km (t f ) + Z km (t f )  υ stat km E c  T f  +  km Z km (t f )σ km E c  T f  +  km U km (t f )(R stat km + αγ δ )E c  T f  + V (c * + e * + βγ δ + φ(σ))E c  T f  + V E c  t f +1 -1  τ =t f W (τ )  +  km E c  x km (t f , t f +1 )  + V E c  y(t f , t f +1 )  (41) where X ′ km (T f ) =  T f + T f (T f -1)  J km /2 + δT f (R max km ) 2 .</formula><p>Next, note that under the application reconfiguration and servicing decisions of the online control algorithm <ref type="bibr" target="#b19">(20)</ref>, the following holds for any (t f ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head></head><formula xml:id="formula_83">km E c  X ′ km (T f )  -  km  U km (t f ) + Z km (t f )  E c  t f +1 -1  τ =t f µ km (τ )  + V E c  t f +1 -1  τ =t f W (τ )  ≤ η  km E c  X ′ km (T stat f )  -η  km  U km (t f ) + Z km (t f )  E c    t f +T stat f -1  τ =t f µ stat km (τ )    + ηV E c    t f +T stat f -1  τ =t f W stat (τ )    (42) where η = E c {Tf } E c  T stat f  .</formula><p>Here, µ stat km (τ ), W stat (τ ), T stat f represent the control decisions and the resulting reconfiguration cost and frame length under the backlog independent stationary algorithm defined earlier. This follows by noting that the online control algorithm is designed to minimize the ratio of the left hand side to the frame length over all possible algorithms. Next, note that the reconfiguration policy of the stationary algorithm is dependent only on the configuration state and is independent of all states in (t f ). Thus, the conditional expectation can be replaced by regular expectation and the relationships in ( <ref type="formula" target="#formula_20">14</ref>) can be used since the reconfiguration policies of the decoupled control algorithm and the stationary algorithm are identical. Plugging these, the above can be rewritten as</p><formula xml:id="formula_84"> km E c  X ′ km (T f )  -  km  U km (t f ) + Z km (t f )  E c  t f +1 -1  τ =t f µ km (τ )  + V E c  t f +1 -1  τ =t f W (τ )  ≤ η  km E c  X ′ km (T stat f )  -  km  U km (t f ) + Z km (t f )  µ stat km E c  T f  + V w * E c  T f  .<label>(43)</label></formula><p>Using this, the right hand side of (41) can be bounded as</p><formula xml:id="formula_85">η  km E c  X ′ km (T stat f )  -  km U km (t f )(µ stat km + υ stat km -R stat km -αγ δ )E c  T f  -  km Z km (t f )(µ stat km + υ stat km -σ km )E c  T f  + V (c * + e * + w * + βγ δ + φ(σ))E c  T f  +  km E c  x km (t f , t f +1 )  + V E c  y(t f , t f +1 )  .<label>(44)</label></formula><p>Note that the frame length T stat f under the stationary algorithm is independent of the initial state (t f ). Further, the reconfiguration policy for the stationary algorithm and the decoupled algorithm is identical. Thus, the conditional expectation can been removed and the first term can be rewritten as if R stat km &gt; 0. For those k, m for which µ stat km = R stat km = 0, the α can be set to 0. Also, the stationary algorithm is designed such that µ stat km + υ stat km ≥ σ km . Thus, we have</p><formula xml:id="formula_86">η  km E c  X ′ km (T stat f )  =  km E  X ′ km (T stat f )  E  T stat f  E c  T f  =  km E  X ′ km (T dec h 0 )  E  T dec h 0  E c  T f  =  km  (1 + Υ dec h 0 )J km /2 + δ(R max km ) 2  E c  T f <label>(</label></formula><formula xml:id="formula_87">∆(t f ) + V E c  t f +1 -1  τ =t f C (τ ) + W (τ ) + E(τ )  ≤  km B km E c  T f  + V (c * + e * + w * + βγ δ + φ(σ))E c  T f  +  km E c  x km (t f , t f +1 )  + V E c  y(t f , t f +1 )  . (<label>47</label></formula><formula xml:id="formula_88">)</formula><p>Taking the expectation of both sides and summing over f ∈ {0, 1, 2, . . . , F -1} yields</p><formula xml:id="formula_89">E {Φ(U (t F ))} + V F -1  f =0 E  t f +1 -1  τ =t f C (τ ) + W (τ ) + E(τ )  ≤  km F -1  f =0 B km E  T f  + V (c * + e * + w * + βγ δ + φ(σ)) F -1  f =0 E  T f  +  km F -1  f =0 E  x km (t f , t f +1 )  + V F -1  f =0 E  y(t f , t f +1 )  . (<label>48</label></formula><formula xml:id="formula_90">)</formula><p>This can be rearranged to get</p><formula xml:id="formula_91">F -1  f =0 E  t f +1 -1  τ =t f C (τ ) + W (τ ) + E(τ )  ≤ (c * + e * + w * + βγ δ + φ(σ)) F -1  f =0 E  T f  +  km B km V F -1  f =0 E  T f  +  km F -1  f =0 E  x km (t f , t f +1 )  V + F -1  f =0 E  y(t f , t f +1 )  .</formula><p>The last two terms vanish when we divide both sides by</p><formula xml:id="formula_92"> F -1 f =0 E  T f</formula><p> and take limit F → ∞. The bound in Theorem 3 part 1 follows by choosing δ ≥ log V β log 1/γ . It can be seen that this term is O(log V ).</p><p>Part 2 of Theorem 3 follows by a direct application of Lemma 5.5 from <ref type="bibr" target="#b7">[8]</ref>. Finally, part 3 of Theorem 3 is obtained by performing a frame-based conditional Lyapunov drift analysis for the approximate algorithm similar to the analysis above while using the relations (24), (25) and is omitted for brevity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix D. Frame-based Lyapunov drift bound</head><p>The one-slot difference L(Q (τ + Summing over t ∈ {t f , . . . , t f +1 -1} yields the following bound on the frame-level difference L(Q (t f +1 )) -L(Q (t f )):</p><formula xml:id="formula_93"> km  (B u km + B z km )T f - t f +1 -1  τ =t f (U km (τ ) + Z km (τ ))µ km (τ ) + t f +1 -1  τ =t f U km (τ )R km (τ ) - t f +1 -1  τ =t f (U km (τ ) + Z km (τ ))υ km (τ ) + t f +1 -1  τ =t f Z km (τ )σ km  .<label>(49)</label></formula><p>From <ref type="bibr" target="#b4">(5)</ref>, it follows that U km (τ ) ≥ U km (t f ) -(τt f )(µ max km + υ max km ) for all τ ≥ t f . Similarly from <ref type="bibr" target="#b14">(15)</ref>, it follows that Z km (τ ) ≥ Z km (t f ) -(τt f )(µ max km + υ max km ) for all τ ≥ t f . Using this, the second term above can be lower bounded as</p><formula xml:id="formula_94">t f +1 -1  τ =t f (U km (τ ) + Z km (τ ))µ km (τ ) ≥ t f +1 -1  τ =t f (U km (t f ) + Z km (t f ))µ km (τ ) - t f +1 -1  τ =t f (τ -t f )(µ max km + υ max km )µ km (τ ) ≥ t f +1 -1  τ =t f</formula><p>(U km (t f ) + Z km (t f ))µ km (τ ) -T f (T f -1)(µ max km + υ max km )µ max km (33) follows by using the above in (49), adding the V  t f +1 -1 τ =t f (C(τ )+W (τ )+E(τ )) term to both sides, and taking conditional expectation given (t f ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix E. Delayed backlog bounds</head><p>We first show (35). From <ref type="bibr" target="#b4">(5)</ref>, it follows that U km (τ ) ≥ U km (t f ) -(τt f )(µ max km + υ max km ) for all τ ≥ t f . Using this, -</p><formula xml:id="formula_95">t f +1 -1  τ =t f U km (τ )υ stat km (τ ) ≤ - t f +1 -1  τ =t f U km (t f )υ stat km (τ ) + t f +1 -1  τ =t f (τ -t f )(µ max km + υ max km )υ stat km (τ ) ≤ - t f +1 -1  τ =t f U km (t f )υ stat km (τ ) + T f (T f -1)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>(µ max km + υ max km )υ max km .</p><p>(50)</p><p>The bound in (35) is obtained by summing (50) over all k, m, taking the conditional expectation of both sides and using the fact that the back-end routing decisions under the stationary algorithm are i.i.d. every slot. The bounds (36) and (37) can be shown using a similar procedure and we omit the details for brevity.</p><p>Next, we show (38). For any integer δ ≥ 0, we can express  t f +1 -1 τ =t f U km (τ )R stat km (τ ) in terms of δ-shifted terms as</p><formula xml:id="formula_96">t f +1 -1  τ =t f U km (τ )R stat km (τ ) = t f +δ-1  τ =t f U km (τ )R stat km (τ ) + t f +1 +δ-1  τ =t f +δ U km (τ )R stat km (τ ) - t f +1 +δ-1  τ =t f +1</formula><p>U km (τ )R stat km (τ )</p><formula xml:id="formula_97">= x km (t f , t f +1 ) + t f +1 +δ-1  τ =t f +δ</formula><p>U km (τ )R stat km (τ ).</p><p>(51)</p><p>From ( <ref type="formula">5</ref>), it follows that U km (τ ) ≤ U km (t f ) + (τt f )R max km for all τ ≥ t f . Using this, the second term above can be upper bounded as</p><formula xml:id="formula_98">t f +1 +δ-1  τ =t f +δ U km (t f )R stat km (τ ) + t f +1 +δ-1  τ =t f +δ (τ -t f )R max km R stat km (τ ) ≤ t f +1 +δ-1  τ =t f +δ U km (t f )R stat km (τ ) +  δT f + T f (T f -1) 2  (R max km ) 2 .</formula><p>Now consider the conditional expectation of the first term on the RHS above, i.e.,  t f +1 +δ-1 τ =t f +δ U km (t f )R stat km (τ ). We have for any integer δ ≥ 0</p><formula xml:id="formula_99">E c    t f +1 +δ-1  τ =t f +δ U km (t f )R stat km (τ )    = U km (t f )E c    t f +1 +δ-1  τ =t f +δ R stat km (τ )    ≤ U km (t f )(R stat km + αγ δ )E c  T f  (<label>52</label></formula><formula xml:id="formula_100">)</formula><p>where the last step follows from the application of Lemma 8 and using the fact that the control decisions R stat km (τ ) under the routing policy of the stationary algorithm are functions purely of the Markov chain defined by the user location and request arrival processes. (38) is obtained by summing (51) over all k, m, taking the conditional expectation, and applying the bound in (52). A similar approach can be used to show (39). Finally, (40) follows by noting that the back-end routing decisions under the stationary algorithm are taken in an i.i.d. manner every slot and the resulting time-average back-end routing cost is at most e * + φ(σ).</p><p>Lemma 8 (Markov Chain Convergence <ref type="bibr" target="#b21">[22]</ref>). Let Z (t) be a finite state, discrete time ergodic Markov chain. Let S denote its state space and let {π s } s∈S be the steady state probability distribution. Let f (Z(t)) be a positive random function of Z (t). Define f =  j∈S π j m j where m j E {f (Z(t))|Z(t) = j}. Then there exist constants α, γ such that for all integers d ≥ 0, we have E {f (Z(t))|Z(td) = i} ≤ f + sm max αγ d where m max max j∈S m j and s = card{S}.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Illustration of our edge-cloud model showing the collection of edge-clouds, back-end cloud, and mobile users.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Illustration of the hexagonal cellular structure showing distance between 2 cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .Fig. 5 .</head><label>45</label><figDesc>Fig. 4. Average queue lengths and costs for synthetic user mobility with different V and σ values. Subfigures (a) and (b) are results for κ = 0.5, and subfigures (c) and (d) are results for κ = 1.5. a b c d</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .Fig. 7 .</head><label>67</label><figDesc>Fig. 6. Instantaneous queue lengths and moving average of costs for trace-driven simulation with κ = 0.5. a b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>φLemma 7 .</head><label>7</label><figDesc>= e * where we used (31) in the second last step. This shows Theorem 1 part 3. Finally, we show that time-average arrival and service rates are equal to those under the relaxed MDP. The time-average arrival and service rates for each queue U km (t) under the decoupled MDP are equal to those under the relaxed MDP. Proof. The fraction of time a routing vector r ∈ R(l, a) is chosen under the relaxed MDP is given by  h π xdp φ x xdp φ (r). Under the decoupled MDP, this becomes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Under the decoupled MDP, this is equal to ϑ dec (υ) =  φ π xdp φ y xdp φ (υ) by definition (13).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>),<ref type="bibr" target="#b1">(2)</ref>, r knm (t) ∈ Z ≥0 ∀k, n, m, and other location-based constraints as discussed in Section 3.1. The resulting problem is an integer linear program (ILP) in the variables r knm (t). Further, the problem is separable across k, i.e., it is optimal to solve K such problems separately, one per application k. When R max the above optimization has a particularly simple solution that can be obtained independently for each user n and can be calculated in closed-form as follows. For each (k, n), set r knm * (t) = A kn (t) for the particular edge-cloud m * that user n can route to (given its current location L n (t)) and that minimizes U km (t) + Vc knm (t). Set r knm (t) = 0 for all m ̸ = m * . Note that c knm (t) depends on the current user location (L n (t)) as well as the indices of the application (k) and the edge-cloud (m). This algorithm can be viewed as a more general version of the ''Join the Shortest Queue'' policy which uses only queue lengths.</figDesc><table><row><cell>km ≥</cell><cell> N n=1 A kn (t) for all k, m,</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>holds for t = 0 since all queues are initialized to 0. Now suppose U km (t) ≤ U max km for some t &gt; 0. Then, we show that U km (t + 1) ≤ U max</figDesc><table /><note><p><p><p><p><p>km . We have two cases. First, suppose U km (t) ≤ Ve km . Then, from queueing equation</p><ref type="bibr" target="#b4">(5)</ref></p>, it follows that the maximum value that U km (t + 1) can have is</p>U km (t) + R max km ≤ Ve km + R max km = U max km . Next,</p>suppose Ve km &lt; U km (t) ≤ U max km . Then, we have that U km (t) + Z km (t) &gt; Ve km and the solution to (17) chooses υ km (t) = min[U km (t), υ max km ]. Since υ max km ≥ R max km , from queueing equation (5) it follows that</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>The value of the summation in the objective of<ref type="bibr" target="#b19">(20)</ref> under this sequence cannot be larger than that under the sequence [h(t f ), . . . ,h(t f + T f -2), h 0 ]. This is because h opt (U (t f ), Z (t f ))minimizes the terms - km G km (t f , τ ) by (21) while the total reconfiguration cost  T f -1 τ =0 VW (t f +τ ) in the alternate sequence cannot exceed the total reconfiguration cost under [h(t f ), . . . , h(t f +T f -2), h 0 ]</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1</head><label>1</label><figDesc>Average values for trace-driven simulation.</figDesc><table><row><cell>Policy</cell><cell>Queue lengths (κ = 0.5)</cell><cell>Costs (κ = 0.5)</cell><cell>Queue lengths (κ = 1.5)</cell><cell>Costs (κ = 1.5)</cell></row><row><cell>Lyapunov</cell><cell>106.5</cell><cell>5.954</cell><cell>160.2</cell><cell>6.446</cell></row><row><cell>Never migrate</cell><cell>268.7</cell><cell>6.414</cell><cell>268.7</cell><cell>6.414</cell></row><row><cell>Always migrate</cell><cell>3117</cell><cell>7.983</cell><cell>3117</cell><cell>14.15</cell></row><row><cell>Myopic</cell><cell>437.4</cell><cell>6.228</cell><cell>851</cell><cell>6.268</cell></row><row><cell>a</cell><cell></cell><cell>b</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>of the decoupled control algorithm, i.e., π F of time in configuration h under the relaxed MDP. For the case when h ∈ H \ H ′ , Lemma 3 follows by noting that the fraction of time spent in configuration h in both cases is 0. The time-average expected reconfiguration cost under the decoupled control algorithm is equal to the time-average expected reconfiguration cost of the relaxed MDP, i.e., w * .</figDesc><table><row><cell>h is equal to</cell><cell></cell><cell>la π xdp lah which</cell></row><row><cell>is the fraction Lemma 4. Proof. The time-average expected reconfiguration cost under policy (11) is</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>1)(µ max km + υ max km )µ max km . Given any location and arrival states and queue backlogs, the routing decisions under the online control algorithm minimize VC (t) +  km U km (t)R km (t) in every slot over all other algorithms, including the backlog independent stationary algorithm. Similarly, the back-end routing decisions under the online control algorithm minimize VE(t) - km (U km (t) + Z km (t))υ km (t) in every slot over all other algorithms, including the stationary algorithm. Denoting these decisions under the stationary algorithm by R stat km (t) and υ stat km (t) and the resulting costs by C stat (t) and E stat (t), it follows that we can upper bound the value of</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>Note that under the stationary algorithm, ifR stat km &gt; 0, then µ stat km + υ stat km -R stat km ≥ µ dec km + υ dec km -R dec km ≥ ϵ &gt; 0.This follows from Theorem 1 part 4 and the fact that υ stat km ≥ υ dec km . Thus, by choosing δ ≥ log 2α/ϵ 1/γ , we have that µ stat km -R stat km -αγ δ ≥ ϵ/2</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>45)</cell></row><row><cell cols="2">where Υ dec h 0 =</cell><cell cols="2">E </cell><cell cols="4">T dec h 0 E  (T dec h 0 T dec h 0  -1) </cell><cell>. Denoting B km = (1 + Υ dec h 0 )J km /2 + δ(R max km ) 2 , (44) can be rewritten as</cell></row><row><cell></cell><cell cols="2">B km E c</cell><cell cols="2"></cell><cell>T f</cell><cell></cell><cell>-</cell><cell></cell></row><row><cell>km</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p><p>km U km (t f )(µ stat km + υ stat km -R stat km -αγ δ )E c  T f  - km Z km (t f )(µ stat km + υ stat km -σ km )E c  T f  + V (c * + e * + w * + βγ δ + φ(σ))E c  T f  +  km E c  x km (t f , t f +1 )  + V E c  y(t f , t f +1 )  .</p>(46)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>1)) -L(Q (τ )) is upper bounded by</figDesc><table><row><cell> </cell><cell>B u km + B z km -U</cell></row><row><cell>km</cell><cell></cell></row></table><note><p>km (t)  µ km (t) + υ km (t) -R km (t)  -Z km (t)  µ km (t) + υ km (t) -σ km   .</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This research was sponsored in part by the US Army Research Laboratory and the UK Ministry of Defence and was accomplished under Agreement Number W911NF-06-3-0001. The views and conclusions contained in this document are</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Cloudlets: At the leading edge of cloud-mobile convergence</title>
		<author>
			<persName><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International ACM Sigsoft Conference on Quality of Software Architectures</title>
		<meeting>the 9th International ACM Sigsoft Conference on Quality of Software Architectures<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1" to="2" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fog computing and its role in the Internet of things</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bonomi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Milito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Addepalli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Edition of the MCC Workshop on Mobile Cloud Computing</title>
		<meeting>the First Edition of the MCC Workshop on Mobile Cloud Computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="13" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Challenges to support edge-as-a-service</title>
		<author>
			<persName><forename type="first">S</forename><surname>Davy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Famaey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Serrat-Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gorricho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dramitinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Neves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Latre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Goshen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun. Mag</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="132" to="139" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Follow me cloud: interworking federated clouds and distributed mobile networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Taleb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ksentini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Netw</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="12" to="19" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Dynamic Programming and Optimal Control</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Bertsekas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<pubPlace>Athena Scientific</pubPlace>
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Puterman</surname></persName>
		</author>
		<title level="m">Markov Decision Processes: Discrete Stochastic Dynamic Programming</title>
		<imprint>
			<publisher>John Wiley &amp; Sons, Inc</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
	<note>first ed.</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Resource allocation and cross-layer control in wireless networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Georgiadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Neely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tassiulas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Found. Trends Netw</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="144" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Stochastic Network Optimization with Application to Communication and Queueing Systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Neely</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Morgan and Claypool Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Stochastic models of load balancing and scheduling in cloud computing clusters</title>
		<author>
			<persName><forename type="first">S</forename><surname>Maguluri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ying</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2012-03">2012. March 2012</date>
			<biblScope unit="page" from="702" to="710" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Shadow-routing based dynamic algorithms for virtual machine placement in a network cloud</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stolyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Walid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2013-04">2013. April 2013</date>
			<biblScope unit="page" from="620" to="628" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Online algorithms for joint application-VM-physical-machine auto-scaling in a cloud</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Stolyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Walid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 2014 ACM International Conference on Measurement and Modeling of Computer Systems, Ser. SIGMETRICS&apos;14</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="589" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chiang</surname></persName>
		</author>
		<title level="m">Joint VM placement and routing for data center traffic engineering</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="2876" to="2880" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dynamic right-sizing for power-proportional data centers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wierman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L H</forename><surname>Andrew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Thereska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1378" to="1391" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Online algorithms for geographical load balancing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wierman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L H</forename><surname>Andrew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 International Green Computing Conference</title>
		<meeting>the 2012 International Green Computing Conference<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scheduling in networks with time-varying channels and reconfiguration delay</title>
		<author>
			<persName><forename type="first">G</forename><surname>Celik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Modiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="99" to="113" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Exact analysis of the M/M/K/setup class of Markov chains via recursive renewal reward, SIGMETRICS Perform</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gandhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Doroudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harchol-Balter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scheller-Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eval. Rev</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="153" to="166" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Dynamic optimization and learning for renewal systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Neely</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Automat. Control</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="32" to="46" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Ross</surname></persName>
		</author>
		<title level="m">Introduction to Probability Models</title>
		<meeting><address><addrLine>Orlando, FL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press, Inc</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>ninth ed.</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<title level="m">Introduction to Algorithms</title>
		<imprint>
			<publisher>McGraw-Hill Higher Education</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An approximation algorithm for the generalized assignment problem</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Shmoys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tardos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Program</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="461" to="474" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A parsimonious model of mobile partitioned networks with clustering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Piorkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sarafijanovic-Djukic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grossglauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communication Systems and Networks and Workshops</title>
		<imprint>
			<date type="published" when="2009-01">2009. Jan 2009</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
	<note>COMSNETS 2009. First International</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">He is currently a task lead on the US Army Research Laboratory (ARL) sponsored Network Science Collaborative Technology Alliance (NS CTA) program. He is also a Primary Researcher in the US/UK International Technology Alliance (ITA) research programs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Urgaonkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Neely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Ibm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Watson Research</surname></persName>
		</author>
		<author>
			<persName><surname>Center</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">He obtained his Masters and Ph.D. degrees from the University of Southern California in 2005 and 2011 respectively and his Bachelor&apos;s degree (all in Electrical Engineering) from the Indian Institute of Technology Bombay in 2002. Shiqiang Wang received the B.Eng. and M.Eng. degrees from Northeastern University, China, respectively in 2009 and 2011. He is currently working toward the Ph.D. degree at the Department of Electrical and Electronic Engineering</title>
		<title level="s">IEEE Trans. Mob. Comput.</title>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Ibm</surname></persName>
		</editor>
		<editor>
			<persName><surname>Watson Research</surname></persName>
		</editor>
		<editor>
			<persName><surname>Center</surname></persName>
		</editor>
		<meeting><address><addrLine>Imperial College London; Yorktown Heights, NY, United States; Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009. 2014. 2013. 2012</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="766" to="777" />
		</imprint>
		<respStmt>
			<orgName>NEC Laboratories Europe</orgName>
		</respStmt>
	</monogr>
	<note>His research interests include dynamic control mechanisms, optimization algorithms, protocol design and prototyping. with applications to mobile cloud computing, hybrid and heterogeneous networks, ad-hoc networks, and cooperative communications. He has over 20 scholarly publications, and has served as a technical program committee (TPC) member or reviewer for a number of international journals and conferences</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">where his research focused on computer and communication networks, data-analytics and cloud computing. He was a technical lead on several research projects in the US-UK funded multi-institutional International Technology Alliance program with emphasis on fundamental research in mobile wireless networks. He has previously worked at the Corporate R&amp;D center of Qualcomm Inc. and at Bell Laboratories, Alcatel-Lucent Inc., during the summers of</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Ibm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Research</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Center</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ieee/Acm</forename><surname>Secon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ieee</forename><surname>Iwqos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ieee</forename><surname>Milcom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ifip</forename><surname>Icnc</surname></persName>
		</author>
		<author>
			<persName><surname>Networking</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">She received the Best Paper Award at the 2013 International Conference on Distributed Computing Systems (ICDCS), a Best Paper Nomination at the 2013 Internet Measurement Conference (IMC), and the Best Student Paper Award at the 2005 International Conference on Acoustic, Speech and Signal Processing (ICASSP)</title>
		<meeting><address><addrLine>China; Ithaca, NY; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Watson Research Center</publisher>
			<date type="published" when="2003">2007. 2007. 2009. 2013. 2003. 2004</date>
		</imprint>
		<respStmt>
			<orgName>Ting He received the B.S. degree in computer science from Peking University ; Cornell University ; Network Analytics Research Group</orgName>
		</respStmt>
	</monogr>
	<note>International Symposium on Modeling and Optimization in Mobile, Ad Hoc, and Wireless Networks. WiOpt) in 2005, a recipient of the Siemens and Philips Award in 2001 and a recipient of several invention achievement awards at IBM Research</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
