<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scalable Reliable Multicast Using Multiple Multicast Groups*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sneha</forename><forename type="middle">K</forename><surname>Kasera</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jim</forename><surname>Kurose</surname></persName>
							<email>kurose@cs.umass.edu</email>
						</author>
						<author>
							<persName><forename type="first">Don</forename><surname>Towsley</surname></persName>
							<email>towsley@cs.umass.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Massachusetts</orgName>
								<address>
									<postCode>01003</postCode>
									<settlement>Amherst</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Seattle</settlement>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scalable Reliable Multicast Using Multiple Multicast Groups*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">50D2E1AFA144355DC143665F4B643BD7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We examine an approach for providing reliable, scalable multicast communication, using multiple multicast groups for reducing receiver processing costs in a multicast session. In this approach a single multicast group is used for the original transmission of packets. Fletransmissions of packets are done to separate multicast groups, which receivers dynamically join or leave. We first show that by using an infinite number of multicast groups, processing overhead at the receivers are substantially reduced. Next, we show that, for a specific negative acknowledgment (NAK)-based protocol, most of this reduction can be obtained by using only a small number of multicast groups for a wide range of system parameters. Finally, we present a local filtering scheme for minimizing join/leave signaling when multiple multicast groups are used.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Many applications such as shared whiteboards, distributed interactive simulation and distributed computing, require reliable multicast, where sender(s) transmit data to a group of receivers in a reliable manner. Designing a reliable multicast protocol for an application that can have several thousand receivers, (e.g., wb [s] which has been used with more than one thousand users) is a challenging task.</p><p>In this paper we examine an approach for providing reliable, scalable multicast communication. This approach (first discussed in <ref type="bibr" target="#b2">[3]</ref> and (51) involves the use of multiple multicast groups for reducing receiver processing costs in a multicast session. To illustrate the problem in using a single multicast group, consider an ARQ-based reliable multicast scenario In our work we first show that protocols using an infinite number of multicast groups incur much less processing overhead at the receivers compared to protocols that use only a single multicast group. Next, through simple analyses, we derive the number of unwanted packets at a receiver due to using only a finite number of multicast groups, for a specific negative acknowledgment (NAK)-based protocol. We then explore the minimum number of multicast groups required to keep the cost of processing unwanted packets to a sufficiently low value (i.e., to achieve most of the benefit of using an infinite number of multicast groups). For an application consisting of a single sender transmitting &amp;ably to many receivers (referred to as a one-many application <ref type="bibr" target="#b16">[17]</ref>) we find that only a small number of multicast groups are required for a wide range of system parameters. In the case of an application where all participants simultaneously act as both senders and receivers (referred to as a many-many application <ref type="bibr" target="#b16">[17]</ref>) a moderate number of multicast groups is needed.</p><p>One potential concern with using multiple multicast groups is the processing of '&amp;joins" and "leaves," as receivers dynamically add and delete themselves from these groups.</p><p>In order to avoid shifting the burden from the receivers to the underlying network and at the same time maintaining the reduced processing benefits, we propose a simple receiver filtering mechanism that results in the same amount of network traffic as in the case of a single multicast group, but does not require joins and leaves to be processed inside the network once the multicast session begins.</p><p>The remainder of the paper is organized as follows. In the next section WC examine the existing work on the subject. In section 3 we present several protocols that use multiple multicast groups. In section 4, we analyze the processing cost performance of these protocols. In section 5, we present numerical results to show that use of multiple multicast groups leads to reduction of processing overhead at the receivers. In section 6 we derive the number of multicast groups required to keep the processing overhead due to unwanted packets at a receiver to a sulficiently low value for a specific NAK based protocol. In section 7 we present our 6ltering scheme for handling multiple multicast groups without incurrin g any significant overhead in the underlying network. Our conclusions and suggestions for future work are contained in Section 8.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Protocol Description</head><p>The protocols we describe below are modified versions of the generic protocols, Nl and N2, proposed in <ref type="bibr">[16, 171.</ref> In [16, 171, the authors have considered only one multicast group for both transmissions and retransmissions. The reliable multicast protocols we will consider wilI be denoted Pl, P2 and P3. We initially make the assumption that we have an infinite number of multicast groups at our disposal so that each packet can be recovered on a separate channel, i.e., G = 00. Later, we will see that we can easily reure a small number of multicast groups to achieve almost the same effect that can be obtained by using large number of multicast groups.</p><p>The protocol Pl exhibits the following behavior Protocol P3 exhibits the same behavior as P2 except that a receiver sends a NAK for packet i on the original multicast address A,, instead of Ai as in P2. The important similarity between P2 and P3, which distinguishes them from PI, is that both have the capability to suppress NAKs <ref type="bibr">[8]</ref> to the sender. They attempt to ensure that at most one NAK is sent out to the sender per packet by delaying the generation of the NAKs and multicasting them to all the participating receivers. The suppression of NAKs to the sender does not come for free, however. The price is paid in terms of extra NAK processing at the receivers as the NAKs are now multicast instead of being unicast to the sender. P2 reduces the NAK processing cost at the receivers by sending NAKs for packet i on A;. Only those receivers, that have not received packet i, subscribe to Ai. Hence NAKs are processed at a few receivers. In comparison, in P3, NAKs are retransmitted on A m,, and are received by all the receivers that have subscribed to A,,.</p><p>It should be noted that the sender has to be a member of all the retransmission groups in P2 and only a member of the group corresponding to A org in P3. A sender does not have to be a member of any retransmission group in Pl .</p><p>Before quantitatively evaluating the performance of Pl, P2 and P3 , let us first qualitatively examine their behavior. Recall that in P2, NAKs are received by only those receivers that themselves have not received the packet i. This means that a lost packet can only be recovered from the sender and not from a localreceiver. Additional mechanisms would have to be provided for local recovery. In contrast, in P3, NAKs are received by all the receivers participating in the multicast session. Some of these receivers might have received packet i correctly and can then retransmit the NAKed packet locally. Thus P3 has a provision for local recovery built into itself. Another shortcoming of P2 is that its performance is sensitive to the latency associated with detecting packet loss. If two receivers incur very different latencies in detecting the loss of the same packet, it is possible for one to return a NAK prior to the other joining the appropriate group. Consequently the second receiver will miss that NAK and may transmit its own redundant NAK. For P3, since all NAKs are sent to Amp, and since all receivers belong to Amg, such a situation does not arise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">System Model</head><p>When examining the performance of Pl, P2 and P3, we will study two different system models, corresponding roughly to two broad classes of applications that use reliable multicast.</p><p>In the first model, corresponding to the one-many application (e.g., telelecturing), we assume that one sender transmits a continuous stream of packets to R identical receivers.</p><p>In the second model, corresponding to the many-mony application (e.g., distributed interactive simulations [ll]), we assume that there are R + 1 identical nodes in the system.</p><p>All nodes can function as both a sender and receiver. In this model we assume that a node is a sender with a probability l/(R + 1) and a receiver with probability R/(R + 1) <ref type="bibr" target="#b16">[17]</ref>.</p><p>That is, for each packet there is a single sender and each node is equally likely to be the sender. For both models we assume that all loss events at all receivers for all transmissions are mutually independent and that the probability of packet loss, p, is independent of receiver. We further assume that NAKs are never lost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Processing Cost Analysis</head><p>In this section we develop simple models for estimating the processing costs of protocols Pl, P2 and P3. The receive processing cost(time) is determined by computing the processing involved in correctly receiving a randomly chosen packet at a randomly chosen receiver. This includes the time required to receive those copies of this packet (i.e., the original copy plus any retransmissions) that arrive at the receiver, the time required to send/receive any NAKs associated with this packet and the time needed to handle any timer interrupts associated with this packet. The send processing cost is determined by the processing involved in correctly transmitting a packet to all the receivers. This includes the cost required to process the original transmission of the packet, process any received NAKs, and process retransmissions that are sent out in response to these NAKs.</p><p>We now derive expressions for the receiver processing requirements for the protocols Pl, P2 and P3. Table <ref type="table">1</ref> dcscribes the notation used in the analysis. Most of the notation has been reintroduced from <ref type="bibr" target="#b16">[17]</ref> for the sake of consistency. We assume that the processing times have general distributions and that they are independent of each other. Table <ref type="table">1</ref>: Notation Following an approach similar to the one in <ref type="bibr" target="#b16">[17]</ref>, the mean per packet processing time for a randomly chosen packet at a receiver for the Pl protocol can be expressed as,</p><formula xml:id="formula_0">E[Yp'] = W-p] + (E[%] + E[K])I, + (E[Mv] -l)E[K] + E[(M, -z)+]E[Y,]<label>(1)</label></formula><p>where (I)+ = max{O, z}. The f%st term corresponds to the processing required to correctly receive a packet. A receiver will only receive one copy of the packet (either on Aerg, or on A; for packet i), The next term represents the processing required for joining and leaving a multicast group. Note that the join and leave processing times have been multiplied by the loss probability because this cost is incurred only when a packet is lost and a NAK is transmitted. Although several NAKs might be sent from a receiver to recover a lost packet, a receiver needs to join and leave the corresponding multicast group only at most once per packet. The third term represents the processing required to prepare and return NAKs. The last term corresponds to the processing of the timer when it expires. From <ref type="bibr" target="#b11">[12]</ref> we have,</p><formula xml:id="formula_1">EPfrl = l/(1 -PI, (<label>2</label></formula><formula xml:id="formula_2">)</formula><formula xml:id="formula_3">E[(M, -2)+] = p'/(l -p). (<label>3</label></formula><formula xml:id="formula_4">)</formula><p>Substitution of ( <ref type="formula" target="#formula_1">2</ref>) and ( <ref type="formula" target="#formula_3">3</ref>) into ( <ref type="formula" target="#formula_0">1</ref>) yields</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E[YP'] = E[Y,] + (E[Yj] + E[X])p + pE[Yn]/(l -P)</head><p>+ P'EWII~~ -P) ( <ref type="formula">4</ref>For P2 the mean per packet processing time can be expressed as,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E[Yp'] = E[Yp] + (E[%] + E[X])p + (E[(M,] -</head><formula xml:id="formula_5">l)(E[Yn]/R + (R -l)E[Y,,]/R)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>+ E[(M, -Z)+]E[rt] (5)</head><p>Here, the Srst two terms are the same as in case of Pl. The third term is comprised of two terms. The Srst one results from the generation of NAKs and the second results from the reception of NAKs at the receiver. A receiver generates a NAK with a probability 1/R and receives a NAK with a probability of (R -1)/R. The last term is the same as that for Pl. Substitution of ( <ref type="formula" target="#formula_1">2</ref>) and ( <ref type="formula" target="#formula_3">3</ref>) into ( <ref type="formula">5</ref>) yields</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E[YPa] = E[Y,] + (E[c] + E[Yi])p</head><p>+pl(l -P)(WWR + CR -l)E[YnrIIR)</p><formula xml:id="formula_6">+ P' EPWP -P) (6)</formula><p>Using similar cuguments, the mean per packet processing time at a receiver for the P3 protocol can be expressed as:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E[YPS] = E[Y,] + @[Xl + E[K])p</head><formula xml:id="formula_7">+ (E[M] -l)(E[L]/R + (R -l)E[Y=r]/R) + P%YII/P -P) (7)</formula><p>The only difference between the expressions for P2 and P3 is the replacement of</p><formula xml:id="formula_8">E[M,] in P2 by E[M] in P3.</formula><p>Recall that in P2 a receiver sends a NAK for a packet i to address Ai.</p><p>A receiver P, that is trying to recover packet i, will subscribe to Ai for only the time until it receives i. Since all NAKs are sent to address Ai, the number of NAKs it will receive during this time is M,. On the other hand, in protocol P3, a NAK is sent to the original transmission address A,, and all the NAKB sent for packet i are received by all receivers. E[M] can be expressed in terms of R and p as follows[l2].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E[M] = 1 + g(l-(I-Pm)")</head><p>The sender processing costs of Pl and P2, P3 are the same as that for Nl and N2 respectively. This is because the use of multiple multicast groups only reduces the processing of redundant packets at the receivers. There is no change in the number of NAKs received by the sender, and hence there is no change in the number of packets sent out by the sender. There is no per-packet join/leave processing cost at the sender as explained in <ref type="bibr" target="#b11">[12]</ref>. We can thus use the expressions of sender processing costs from <ref type="bibr" target="#b16">[17]</ref>. The mean sender processing time needed to successfully transmit a packet to all the receivers, for protocols Pl, P2 and P3 is given by the following expressions.</p><formula xml:id="formula_9">E[XP'] = E[XN'] = E[M]E[X,] + RpE[X,]/(l -p) (8) EIXP1] = E[XPS] = E[XN'] = E[M]E[Xp] + (E[Mj -l)E[L] (9)</formula><p>The overall protocol throughput, for the one-manycase, for the family of protocols Pl, P2 and P3 is given by At = min{A:, A:} where we{Pl,P2,P3}, A: = l/E[X'] and A: = l/E[Y"]. The overall protocol throughput is the minimum of the two processing rates at the sender and receiver.</p><p>Recall that under the muny-many scenario, each of the R + 1 end system nodes are equally likely to be the sender of the randomly chosen packet. Hence the mean packet processing time is E[X"]/(R + 1) + RE[Y']/(R + 1) and the overall protocol throughput, which is the inverse of the mean packet processing time, is expressed as</p><formula xml:id="formula_10">R+l AX = E[XY] + RE[Y"]</formula><p>where we(P1, P2,P3}.  Observe that the relative performance of P2 over N2 is better than that of Pl over Nl. This is becauae the receiver processing time of N2 is higher than that of Nl (171. On the other hand the receiver processing times of Pl Bnd P2 are almost same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mean ] Standard Deviation</head><p>Figure <ref type="figure">3</ref> shows the receiver processing performance of P3 over N2. Although P3 does not perform 8s well 8s P2 it still substantially outperforms N2. Figure <ref type="figure">4</ref> shows the receiver processing times of P2 and P3. We see that P3 We now examine the overah protocol throughput of the protocoks Pl, P2 and P3. If the send processing rate is the bottleneck then the overall protocol throughput, for the one-many scenario, defined as the minimum of the send and receive processing rates, does not change even with the improvement in receiver processing cost(rate).</p><formula xml:id="formula_11">'*u, , ,<label>, , , , , , , , Sm. 00</label></formula><p>In <ref type="bibr" target="#b16">[17]</ref> it has been shown that the send processing rate is indeed the bottleneck for protocols Nl and N2. This means that the send processing rate is also the bottleneck for protocols Pl, P2 and P3. Thus, whiIe we see a marked performance advantage in receiver processing rates, the overall protocol throughput for the one-many model does not improve with the use of multiple multicast groups. However, this should not minimize the importance of reducing receiver processing cost. Most receivers are likely to be systems with multi-tasking operating environments so that the reduction of unnecessary processing is highly desirable. Also, one should not let a receiver pay by processing redundant packets requested by other receivers.</p><p>We next examine the many-many model, using equation ( <ref type="formula">10</ref>  the many-many throughput ratio of the P and the N protocols varies with the number of receivers for different loss probabilities. We see in Figure <ref type="figure" target="#fig_5">5</ref> that Pl outperforms Nl and in Figures <ref type="figure">6</ref> and<ref type="figure">7</ref> that P2 and P3 outperform N2. This foilows from the fact that a participant in a many-many application is much more likely (with probability R/(R+ 1)) to perform receive processing on a packet than send processing. Consequently the throughput ratios exhibited in Figures <ref type="figure" target="#fig_5">5,</ref><ref type="figure">6</ref>, and 7 exhibit behavior nearly identical to the mean per packet receive processing ratios for those protocols in Figures 1, 2, and 3. Among the P protocols, the overall protocol throughput of P2 is only slightly higher than that of Pl. This is because the receiver throughput is the same for Pl and P2 and the sender throughput, even though higher for P2 due to NAK suppression, infiuences the throughput only slightly as R increases. Both Pl and P2 have higher overah protocol throughput than P3 as they have higher receiver throughput.</p><p>In summary, we see a significant reduction of receiver processing costs by using multiple multicast groups. For the many-many application, we also see a substantial improvement in overah protocol throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Number of Retransmission Multicast Groups</head><p>In the previous section we made the assumption that the number of available multicast groups was infinite. This is unrealistic and even if a very large number of multicast groups was available, practical considerations such as the size of routing tables within the network would argue in favor of a smaller number of multicast groups. Recall that the main purpose for choosing a multicast group per packet was to avoid receiving any unwanted redundant packets. In this section we demonstrate through analysis that with only a finite and small number of multicast groups we can keep the overhead of processing redundant packets extremely low approaching that achievable with an infinite number of groups.</p><p>Our system model is the same as the one-many model in the previous section and we consider protocol Pl. The retransmission of packet i is now done on the multicast address AimodG where G is the number of retransmission multicast groups. That is, instead of subscribing to A;, as in the previous section, a receiver trying to recover packet i subscribes to Aimoda. Unlike the case of G = 00, retransmission of a lost packet on a multicast group can now be interspersed with the retransmissions of another packet corresponding to the same group. This interspersion depends upon the rate of retransmission of lost packets with respect to the rate of transmission of new (first time) packets. For this reason, we must model the manner in which retransmissions are sent in relation to the new packets. We consider that the sender multicasts new packets periodically with a fixed time interval AI and retransmits packets periodically with a fixed interval A if there is a pending NAK for that packet (equivalently, that the receivers retransmit NAKs with a time interval of A'). We define A' = maxrrr , r = 1,2,3, . . . . R where T, is a measure of the round trip time from the sender to the receiver r. We will observe that A/A' is a key parameter in our protocol performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Analysis</head><p>Our goal in this section is to determine the number of unwanted redundant packets received by a receiver due to the use of only a finite number(G) of multicast groups into protocol Pl.</p><p>In order to illustrate the considerations that will impact performance, let us consider an infinite stream of packets. Let us pick one packet randomly and label it 0. Suppose that receiver ri does not receive the original transmission of packet 0. On detecting that it has not received this packet, it joins the retransmission group corresponding to address Ao. It sends a NAK to the sender and sets its NAK retransmission timer to A'. The sender retransmits packet 0 on Ao. If this packet is lost again then receiver PI'S NAK retransmission timer expires and it retransmits the NAK. During the time until packet 0 is correctly received at ri . . . If ri has already received these packets, then any retransmissions of these packets are received, but are unwanted for ri.</p><p>We wish to calculate the number of these unwanted packets at rl. For this purpose we need to consider the overlap between the retransmissions of packets . . . , -3G, -2G, -G, G, 2G, 3G,. . . and retransmissions of packet 0 during the period of time when ri is using A0 to receive packet 0. Figure <ref type="figure" target="#fig_8">8</ref> shows the overlap between retransmissions of packets -G and 0. For simplicity of Figure <ref type="figure" target="#fig_8">8</ref> we have shown GA to be an integral multiple of A', although this is not a requirement in our analysis. We introduce the random variable U to denote the number of unwanted packets at ri while it is attempting to receive packet 0, given that it requires at least one retransmission. Its expectation, E[U], can be expressed . denote the number of retransmisaions of packet k due to ri that overlap with the retransmissions of packet 0 to rl. In the remainder of this section we derive expressions for E[Z(k)] and E[Z'(k)], k = fl,f2,.</p><p>. . .</p><p>For k = -1, -2, -3,. . ., i.e., for packets transmitted before packet 0, Z(k) is determined by considering the minimum of the number of retransmissions of packet 0 and any retransmisaions of packet k, over all the receivers, after rl starts using A0 for recovering packet 0. The quantity [-kA/A'J determines the number of possible retransmissions of k before rr starts using A0 to recover 0. Therefore, <ref type="bibr">2,3,. . ., i.e</ref>., for packets transmitted after packet 0, Z(k) is determined by considering the maximum number of retransmissions of packet k, over all receivers, until ri finishes recovering packet 0.</p><formula xml:id="formula_12">Z(k) = min(N,max(O, i7ra$Nr -[%I))) (12) -- For k = 1,</formula><formula xml:id="formula_13">Z(k) = min(m=(O, N -l$J), l~vyR K) (<label>13</label></formula><formula xml:id="formula_14">)</formula><p>Based on equations ( <ref type="formula">12</ref>) and ( <ref type="formula" target="#formula_13">13</ref>), it is easy to derive', for k = -1, -2,. . ., By setting R = 1 in ( <ref type="formula">14</ref>) and ( <ref type="formula">15</ref>) we obtain l$A+1</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E[Z(k)</head><p>W"Wl = ' 1 -p2 f k = fl, f2,. . . ( <ref type="formula">14</ref>(15) <ref type="bibr" target="#b15">(16)</ref> The expressions in ( <ref type="formula">14</ref>)-( <ref type="formula">16</ref>) can be substituted into (11) to yield E[U].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Numerical Results</head><p>We now examine the number of retransmission groups required to achieve a receiver throughput that is "close" to the receiver throughput obtained by using an infinite number of retransmission groups. We also see how this number changes with bss probability p, the ratio A/A' and the number of receivers R. For this purpose, we define a performance metric 7, which is the ratio of receiver throughput with G = g to receiver throughput with G = 00, where g 2 0. For Pl, 7 is defined as</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EIYP1 ] ' = EIYP1j + pE[U]E[Y,]</head><p>RecaII that E[U] depends on the values of G, p, R and A/A' and thus 7 depends on these variables too.</p><p>Figure <ref type="figure">9</ref> shows how 7 varies with number of retransmission groups,g for several loss probabilities. In this figure A/A' = 1 and R = 1000. We found that as g increases the mean number of unwanted packets, E[U] fahs very sharply to zcro(not shown in the figure :). This is because the larger the number of multicast groups, the larger wilI the separation (in time) between recovery of packets mapped to the same retransmission group. As a result y in Figure <ref type="figure">9</ref> approaches 1 very fast. Let us define G' be the minimum number of retransmission groups required to make 7 &gt; 0.99. We found that G' = 3 for p = 0.10 and G' = 5 for p = 0.20. A as the number of receivers decrease to a smah value, the minimum number of retransmission groups does not drop considerably. For p = 0.20, even for 50 receivers we need at least 4 retransmission groups to keep 7 &gt; 0.99. Thus we see that even for a very large number of receivers and relatively high loss probabilities the minimum number of retransmission groups required to achieve a receiver throughput that is close to the the receiver throughput with G = oo is very small. In the above numerical results we have considered the ratio A/A' to be 1. Next we see how this ratio affects G'.</p><p>Figure <ref type="figure">11</ref> shows the behavior of G' with A/A', for R = 1000, for several loss probabilities. We see that G' is very sensitive to smah velues of A/A'. This is because the likelihood of overlap between retransmissions corresponding to the same retransmission group increases as A/A' decreases. This behavior diminishes as A/A' increases. In fact beyond a certain value G' becomes insensitive to A/A', as seen in Figure <ref type="figure">11</ref>. Figure <ref type="figure">11</ref> aIso shows that for a given A/A', G' is higher for higher loss probabilities. This increase can be attributed to the fact that there arc more packets being recovered and hence an increasing chance of overlap between recovery of packets belonging to the same retransmission groups. Interestingly, with increase in A/A', In summ8ry, we see that for 8 wide r8nge of system parameters we need a very small number of multicast groups to get a receiver throughput that is within 1% of the maximum achievable receiver throughput. If we choose 8 less stringent requirement 8nd can tolerate unwanted processing slightly greater than 1% of the ideal cs8e then we need even fewer multicast groups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.S The Many-many Case</head><p>We now extend the analysis of section 6.1 to the many-many scenario where each node is a receiver a5 web 8s a sender.  </p><formula xml:id="formula_15">E[U] = (1 -&amp;(~W~k)l+ WY-k)l) kL=l OD -c Wbl + %+)I)))<label>(17)</label></formula><p>k=l Using equations ( <ref type="formula">14</ref>)-( <ref type="formula">16</ref>) we can compute the value of E[q for different vrrlues of G, p, R and A/A'. We compute 7, as defined in section 6.2, for different w&amp;es of g. Figure <ref type="figure" target="#fig_14">12</ref> shows how 7 varies with g for A/A' = 1 and R = 1000.</p><p>We see that -y increeries very fast for smah values of g, but then the rate of increase decreases 8s g increases. Still even for p = 9.29 we can get y &gt; 0.90 with just 5 retransmission groups. This me8n5 that with 5 retransmission groups we could get 90% of the benefit when using an infinite number of retransmission groups. We now define G' to be the minimum number of retransmission groups required to keep 7 &gt; 0.90. Our second observation is that if the senders in the BYBtern send packets in batches then with the increase in batch size the separation between packets belonging to the same retransmission group would increase leading to a lesser degree of overlap between recovery of packets belonging to the same group. This would decrease the number of unwanted packets at the receivers and hence reduce the number of multicast groups needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">A Scheme for Local Filtering</head><p>Even though the number of multicazt groups required for achieving reliable multicast is not large, their use imposes demands on the network in the form of join and leave op uations. In the current networks supporting IP multicast routing, a join or leave from a receiver is detected by the nearest multicast router, the one attached to the subnet of the receiver, through the IGMP protocol [7]. This information is then propagated to the nearest branching point of the multicast tree, rooted at the sender [6], or at a suitable core, in the case of core hazed trees <ref type="bibr" target="#b1">[2]</ref>. Each join and leave message, nsuks in processing overhead at all the intermediate routers thereby potentially reducing the router throughput.</p><p>The significance of this processing burden is highly topology dependent. In order to minimize this signaling overhead we have designed a scheme that does local Pteting at a receivers network interface. This introduces no additional signaling ( i.e. join/leave packets to be sent to/from routers) in the network. Instead, all packets belonging to both the original transmission and all retransmission groups are always allowed to reach the local network to which the receiver is attached and then all unwanted packets are filtered out by the network interface hardware of the receiver. Note that our local filtering scheme does not require any changes at the network routers. There is, however, a need to modify the networking code at the receiver. This change appears not to be excessive. It is clear that for this scheme to work, the network interface hardware at a receiver must provide support for filtering. The Ethernet interface provides multicast filtering in the hardware. Finally, it should be noted that even with local filtering it is still necessary for the routers to include entries in the multicast routing table</p><p>for each of the multicast groups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>In this paper we have examined an approach for providing reliable, s&amp;able multicast communication by using multiple multicast groups for recovery of lost packets. In this approach, rather than having alI receivers receive alI retransmitted packets (regardless of whether a given receiver had already received a given packet correctly), the multiple multicast groups are used to allow only those receivers that actu-aIly want a particular packet to actually receive that packet.</p><p>We considered the idealized case of an infinite number of multicast channels as well as the more realistic scenario of using a small, tied number of multicast channels. We also considered two different models of sender behavior: the onemany scenario and the many-to-many scenario. Our analytic models have demonstrated that significant performance gains (in terms of reduced receiver overhead, and an over-alI increased protocol throughput in the case of many-many communication) can be realized in such environments, and over a range of system parameters. We also presented a local filtering scheme for minimizing join/leave signaling when multiple multicast groups are used.</p><p>Our work can proceed in severel directions. There is a need to study the affect of using fmite number of groups in the context of protocols P2 and P3. We have considered a round-robin approach in reusing the multiple retransmission groups; other approaches are also possible. Also, we have assumed that losses are spatially and temporally independent. In <ref type="bibr" target="#b19">[19]</ref>, Yajnik et al. have observed some long bursts of losses on the MBone. They have dso observed some spatial correlation in loss. We have grouped packets in such a way that packets belonging to a group are recovered on a separate multicast channel. It would be interesting to combine our approach with the previously studied approach of destination set grouping <ref type="bibr">[l]</ref> in which receivers are grouped based on their capabilities. Our local filtering reduces the processing overhead at the receivers but does not help in reducing the used network bandwidth. Hence there is also a need to study better mechanisms for filtering to be able to save on both receiver and router processing overheads and network bandwidth.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Much</head><label></label><figDesc>of the existing work on reliable multicast concerns the design and implementation of ACK-based and/or NAKbased error recovery using only a single multicast group, to which all receivers belong@, 16, 17, 181). Chcung et al. [4] and later McCanne [14] have proposed the use of multiple multicast groups for flow and congestion control, but not for error recovery. In [9] the possibility of using separate multicast groups for defining "local groups" for local recovery has been suggested. Cheriton [3) and Crowcroft [5] suggested the use of multiple multicast groups, for error recovery in reliable multicast, in a discussion on the end-end mailing list. Holbrook [lo] identified the use of separate retransmission channels for error recovery as future work. Even earlier, Ammar and Wu [l] proposed the idea of destination set splitting for improving the throughput of some specific positive acknowledgment based point-tomultipoint protocols. They suggested that receivers could be divided into groups based on their capabilities and the sender carries out as many simultaneous independent conversations as the number of groups. Our work, inspired by Cheriton and Crowcroft's suggestion, differs from Ammar's work in three ways. First, we do not group receivers based on their capabilities. Bather we group packets such that the retransmission of packets belonging to each group is done on a separate multicast channel. Second, we have considered generic NAK-based protocols instead of specific ACK-based protocols. Third, in addition to point-to-multipoint scenario, we have also considered the multipoint-to-multipoint scenario.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>three NAK-based protocols for using multiple multicast channels for reliable multicast from a sender to several receivers. Based on arguments presented in [8] and [16, 171 it is clear that for many applications receiverbased reliability is a better scheme (in terms of performance) for reliable multicast then sender-based reliability. Hence in our work we focus only on receiver-based recovery, or negative acknowledgment (NAK)-based schemes. The section ends with a description of the applications and the network model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>l</head><label></label><figDesc>the sender sends all original transmissions on a multicast address A,, and when required, it retransmits a packet with sequence number i on multicast address Ai where i = 0, 1,2,. . ., l whenever a receiver detects a lost packet i, it transmits a NAK to the sender over a point-to-point channel and subscribes to the multicast address Ai and starts a timer. l the expiration of a timer without prior reception of the corresponding packet serves as the detection of a lost NAK packet, a NAK is retransmitted for the associated packet and a timer again started. l on receiving packet i on Ai a receiver unsubscribes to of a NAK for a packet which a receiver has not received, but for which it initiated the random delay prior to sending a NAK, the recdver sets a timer and behaves as if it had sent that NAK, o the expiration of a timer without prior reception of the corresponding packet serves as the detection of a lost NAK packet.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>the transmission of a packet time to process a NAK time to process a newly received packet time to process a timeout time to process and trsnrmit a NAK time to receive and process a NAK at a receiver time to process a join</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 1 :Figure 3 :</head><label>13</label><figDesc>Figure 1: Receiver Processing Time Ratio(Nl/Pl)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 4: Receiver Processing Times of P2 and P3 Figure 6: Many-many Throughput Hatio(P2/N2)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>) to compute the overall protocol throughput for protocols Pl, P2 and P3 and Nl and N2. Figures 5-7 show how</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Figure 7: Many-many Throughput Hatio(P3lNP)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Sender timeline</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Z(k), k = fl,f2,. . . denote the number of retransmissions of packet k due to all the R receivers that overlap with the retransmissions of packet 0 to ri and random variables Z'(k), k = fl,f2,..</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 10 Figure 10</head><label>1010</label><figDesc>Figure 10 shows how G" varies with the number of receivers for different loss probabilities, with A/A = 1. We see that G' increases very slowly with increasing number of receivers. For p = 0.20, G' = 5 for R = 1000, G' = 6 for R = 5000 and G' = 7 for R = 10000. On the other hand,'Details of the analysis can be found in<ref type="bibr" target="#b11">[12]</ref> </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure</head><label></label><figDesc>Figure 11: G' v5 3 for R = 1000, 7 &gt; 0.99</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Hence, instead of a single sender, we now have multiple senders. The protocol we consider is still Pl. As before, there are G retransmission groups in addition to the group for original transmissions. A receiver on losing a packet i from sender j joins the multicast group Aimodo and sends a NAK to sender j. The sender j retransmits the packet on A imodo. After correctly recovering packet i from sender j the receiver leaves Aimode+ For the convenience of analysis we model the multiple sender5 by a single global sender. That is, we assume that d the transmissions and retransmissions are originating from the global sender. Let the time between original transmitsions be A and let the time between retransmissions be A' (note that the A and A' for a global sender could be different from those for individual sendem). A stream of original transmissions of packets from the global sender would look like(rl,nl),(ss,n5),(r5,ns),...whercsiisthesourceofthe ith packet and n; is the sequence number of that packet with respect to sender 5i.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Many-Many Scenario, $ = 1 and R = 1000</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 13</head><label>13</label><figDesc>Figure 13: Many-Many Scenario, G' VB 5 for R = 1000, -y &gt; 0.90</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>In our scheme we distinguish between two kinds of join/leave operations. The first kind, which we call nonlocal join and non-local leave, is the regular join and leave as described above. The second kind, which we call local join and local leave, has to do only with the local network interface at a receiver. A local join or leave message travels only to the receiver's network interface hardware. No IGMP messages are sent to the nearest IP multicast router. A local join or leave is simply an indication to the hosts network interface to filter packets locally. We now describe the scheme for local filtering. AB a fmt step a receiver joins, non-locally, both the original transmission and all of the retransmission multicast groups. This nsuits in the transmission of IGMP messages to the nearest IP multicast router and transfer of subsequent graft messages towards the branching point. Subsequently, the receiver locally leaves all of the retransmission gcoupe. From this point on, whenever the receiver needs to recover a packet it does a local join to the appropriate multicast group. Once the packet has been received correctly, the receiver does a local leave. Hence, as far as the network routing tables are concerned the receiver is always a member of all the groups and all packets to these groups are duly forwarded to the local interface of the receiver. It is left to the local interface to filter out the unwanted packets, based on the information provided by the local join and leave operations, to save the receiver from processing these packets. When a receiver wants to drop out of the multicast session it non-locally leaves all of the multicast groups. Since the filtering is done locally at a receiver, this scheme does not reduce the data traffic in the network, and hence does not prevent wastage of network bandwidth. At the same time it does not add any extra traffic in comparison to the scenarios that use a single multicast group. The closer we move the filtering point to the sender the more we are able to save in terms of extra traffic towards a receiver, but then the cost of join and leave on the network would increase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 2 :</head><label>2</label><figDesc>Processing Time(in microseconds)</figDesc><table /></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>'This work was supported in part by the Defeme Advanced Rc rearcb Projects Agency under contract F19628-95-C-0146, and the National Science Foundation under grant NCR-9508174 and equipment grant NSF CDA-9503639.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Improving the Throughput of Point-to-Mu&amp;point ARQ Protocols Through Destination Set Splitting</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Ammar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="1992-06">June 1992</date>
			<biblScope unit="page" from="262" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Core Baaed ser</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Baiiardie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">On the Use of Deatination Set Grouping to Improve Fairness in Multicast Video Distribution</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cheriton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Y</forename><surname>Pi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ammar</surname></persName>
		</author>
		<author>
			<persName><surname>Li</surname></persName>
		</author>
		<idno>: GIT-CC-95-25</idno>
		<imprint>
			<date type="published" when="1994-09">September 1994. July 1995</date>
		</imprint>
		<respStmt>
			<orgName>Georgia Institute of Technology, Atlanta</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech Report</note>
	<note>End-to-End mailing list</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">End-to-End mailing list</title>
		<author>
			<persName><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994-09">September 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Multicast Routing in Datagram Internetwork</title>
		<author>
			<persName><forename type="first">S</forename><surname>Deering</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University. December</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Deering Host &amp;tensions for IP Multicasting. RFC 1112</title>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1989-08">August 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Reliable Multicart Framework for Light-weight Sessions and Application Level timing</title>
		<author>
			<persName><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1995-08">August 1995</date>
			<biblScope unit="page" from="342" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<title level="m">A Reliable Multieast I+amework for Light-weight Sessionr and Application Level Framing. A later version of the ACM SIGCOMM paper</title>
		<imprint>
			<date type="published" when="1995-11">November 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Log-Baaed Receiver Reliable Multicast for Dirrtributed Interactive Simulation</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Holbrook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Singhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Cheriton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1995-08">August 1995</date>
			<biblScope unit="page" from="328" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Institute for Simulation and aaining, Standard for Distributed Interactive Simulation -Application Protocols</title>
		<idno>IST-CR-9450</idno>
		<imprint>
			<date type="published" when="1994">1994</date>
			<pubPlace>Orlando, FIa</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Central Florida</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">TechnicaI Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scalable Reliable Multicart Using Multiple Multicart Groupr</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Kasera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kurose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsiey</surname></persName>
		</author>
		<idno>No. 96-73</idno>
	</analytic>
	<monogr>
		<title level="j">CMP-SC</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1996-10">October 1996</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The Importance of Non-Data Touching Processing Overheads in TCP/IP</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pasquale</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Receiuerdriven Layered Multicast</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vetterli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIG-COMM</title>
		<meeting>ACM SIG-COMM</meeting>
		<imprint>
			<date type="published" when="1996-08">August 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">C</forename><surname>Partridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Udp</forename><surname>Farter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions in Networking</title>
		<imprint>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="429" to="439" />
			<date type="published" when="1993-08">August 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Compariron of Sender-Initiated and Receiver-Initiated Reliable Multicast Protocolr</title>
		<author>
			<persName><forename type="first">S</forename><surname>Pingaii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kurose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM S&amp;metrics</title>
		<meeting>ACM S&amp;metrics</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Towsiey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kurose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pingali</surname></persName>
		</author>
		<author>
			<persName><surname>Compar</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Initiated Reliable</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Multicast Protocols</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communication</title>
		<imprint>
			<date type="published" when="1997-04">April 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Reliable Dirsemination Protocol for Interactive Collaborative Applicationr</title>
		<author>
			<persName><forename type="first">R</forename><surname>Yavatkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Griffioen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of ACM Multimedia</title>
		<meeting>eeding of ACM Multimedia</meeting>
		<imprint>
			<date type="published" when="1995-11">November 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Packet Lorr Correlation in the MBone Multicart Network</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yajnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kurose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Global Internet Conference</title>
		<meeting>IEEE Global Internet Conference</meeting>
		<imprint>
			<date type="published" when="1996-11">November 1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
