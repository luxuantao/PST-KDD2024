<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">From Invariant Checking to Invariant Inference Using Randomized Search</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rahul</forename><surname>Sharma</surname></persName>
							<email>sharmar@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alex</forename><surname>Aiken</surname></persName>
							<email>aiken@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">From Invariant Checking to Invariant Inference Using Randomized Search</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">913A185F1BD26D718D2AB3B030393A0B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:12+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe a general framework c2i for generating an invariant inference procedure from an invariant checking procedure. Given a checker and a language of possible invariants, c2i generates an inference procedure that iteratively invokes two phases. The search phase uses randomized search to discover candidate invariants and the validate phase uses the checker to either prove or refute that the candidate is an actual invariant. To demonstrate the applicability of c2i, we use it to generate inference procedures that prove safety properties of numerical programs, prove non-termination of numerical programs, prove functional specifications of array manipulating programs, prove safety properties of string manipulating programs, and prove functional specifications of heap manipulating programs that use linked list data structures.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In traditional program verification, a human annotates the loops of a given program with invariants and a decision procedure checks these invariants by proving some verification conditions (VCs). We explore whether decision procedures can also be used to infer the loop invariants; doing so helps automate one of the core problems in verification (discovering appropriate invariants) and relieves programmers from a significant annotation burden.</p><p>The idea of using decision procedures for invariant inference is not new <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b15">16]</ref>. However, this approach has been applied previously only in domains with some special structure, e.g., when the VCs belong to theories that admit quantifier elimination, such as linear rational arithmetic (Farkas' lemma) or linear integer arithmetic (Cooper's method). For general inference tasks, such theory-specific techniques do not apply, and the use of decision procedures for such tasks has been restricted to invariant checking: to prove or refute a given manually provided candidate invariant.</p><p>We describe a general framework c2i that, given a procedure for checking invariants, uses that checker to produce an invariant inference engine for a given language of possible invariants. We apply c2i to various classes of invariants; we use it to generate inference procedures that prove safety properties of numerical programs, prove non-termination of numerical programs, prove functional specifications of array manipulating programs, prove safety properties of string manipulating programs, and prove functional specifications of heap manipulating programs that use linked list data structures. The two main characteristics of c2i are -The decision procedure is only used to check a program annotated with candidate invariants (in contrast to approaches that use the decision procedure directly to infer an invariant). -c2i uses a randomized search algorithm to search for candidate invariants.</p><p>Empirically, the search technique is effective for generating good candidates for various classes of invariants.</p><p>The use of a decision procedure as a checker for candidate invariants is also not novel <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b18">19]</ref>. The main contribution of this paper is a general and effective search procedure that makes a framework like c2i feasible. The use of randomized search is motivated by its recent success in program synthesis <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b1">2]</ref> and recognizing that invariant inference is also a synthesis task. More specifically, our contributions are:</p><p>-We describe a framework c2i that iteratively invokes randomized search and a decision procedure to perform invariant inference. The randomized search combines random walks with hill climbing and is an instantiation of the well-known Metropolis Hastings MCMC sampler <ref type="bibr" target="#b10">[11]</ref>. -We empirically demonstrate the generality of our search algorithm. We use randomized search for finding numerical invariants, recurrent sets <ref type="bibr" target="#b26">[27]</ref>, universally quantified invariants over arrays, invariants over string operators, and invariants involving reachability predicates for linked list manipulating programs. These studies show that invariant inference is amenable to randomized search. -Even though we expect the general inference engines based on randomized search to be significantly inferior in performance to the domain-specific invariant inference approaches, our experiments show that randomized search has competitive performance with the more specialized techniques. -Randomized search is effective only when done efficiently. We describe optimizations that allow us to obtain practical randomized search algorithms for invariant inference.</p><p>The rest of the paper is organized as follows. We describe our search algorithm in Section 2. Next, we describe inference of numerical invariants in Section 3, universally quantified invariants over arrays in Section 4, string invariants in Section 5, and invariants over linked lists in Section 6. Finally, we discuss related work in Section 7 and conclude in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>An imperative program annotated with invariants can be verified by checking some verification conditions (VCs), which must be discharged by a decision procedure. As an example, consider the following program:</p><p>assume P ; while B do S od; assert Q</p><p>The loop has a pre-condition P . The entry to the loop is guarded by the predicate B and S is the loop body (which, for the moment, we assume to be loop-free).</p><p>We assert that the states obtained after execution of the loop satisfy Q. Given a loop invariant I, we can prove that the assertion holds if the following three VCs are valid:</p><formula xml:id="formula_0">P ⇒ I; {I ∧ B}S{I}; I ∧ ¬B ⇒ Q (1)</formula><p>In this paper, we explore finding such an invariant I by randomized search. Given a candidate invariant, a decision procedure checks the conditions of Eqn. 1. Since there are three conditions for a predicate to be an invariant, there are three queries that need to be discharged to check a candidate. Each query, if it fails, generates a different kind of counterexample; we discuss these next.</p><p>Let C be a candidate invariant. The first condition states that for any invariant I, any state that satisfies P also satisfies I. However, if P ∧ ¬C has a satisfying assignment g, then P (g) is true and C(g) is false and hence g proves C is not an invariant. We call any state that must be satisfied by an actual invariant, such as g, a good state. Now consider the second condition of Eqn. 1. A pair (s, t) satisfies the property that s satisfies B and if the execution of S is started in state s then S can terminate in state t. Since an actual invariant I is inductive, it should satisfy I(s) ⇒ I(t). Hence, a pair (s, t) satisfying C(s) ∧ ¬C(t) proves C is not an invariant. Finally, consider the third condition. A satisfying assignment b of C ∧ ¬B ∧ ¬Q proves C is inadequate to discharge the post-condition. For an adequate invariant I, I(b) should be false. We call a state that must not be satisfied by an adequate invariant, such as b, a bad state. Hence, given an incorrect candidate invariant and a decision procedure that can produce counterexamples, the decision procedure can produce either a good state, a pair, or a bad state as a counterexample to refute the candidate.</p><p>Problems other than invariant inference can also be reduced to finding some unknown predicates to satisfy some VCs <ref type="bibr" target="#b20">[21]</ref>. Consider the following problem: prove that the loop while B do S od fails to terminate if executed with input i. One can obtain such a proof by demonstrating a recurrent set <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b26">27]</ref> I which makes the following VCs valid.</p><formula xml:id="formula_1">I(i); {I ∧ B}S{I}; I ⇒ B (2)</formula><p>Our inference algorithm consumes VCs with some unknown predicates. We use the term invariant for any such unknown predicate that we want to infer. In the rest of this section, we focus on the case when we need to infer a single predicate.</p><p>The development here generalizes easily to inferring multiple predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Metropolis Hastings</head><p>We denote the verification conditions by V , the unknown invariant by I, a candidate invariant by C, the set of predicates that satisfy V by I (more than one predicate can satisfy V ), and the set of all possible candidate invariants by S.</p><p>We view inference as a cost minimization problem. For each predicate P ∈ S we assign a non-negative cost c V (P ) where the subscript indicates that the cost depends on the VCs. Suppose the cost function is designed to obey C ∈ I ⇔ c V (C) = 0. Then by minimizing c V we can find an invariant. In general, c V is highly irregular and not amenable to exact optimization techniques. In this paper, we use a MCMC sampler to minimize c V .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Search(J: Initial candidate)</head><formula xml:id="formula_2">Returns: A candidate C with cV (C) = 0. 1. C := J 2. while cV (C) = 0 do 3. m := SampleMove(rand()) 4. C := m(C) 5. co := cV (C), cn := cV (C ) 6.</formula><p>if cn &lt; co or e -γ(cn-c 0 ) &gt; rand () RANDMAX then 7.</p><p>C := C 8.</p><p>end if 9. end while 10. return C</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 1. Metropolis Hastings for cost minimization</head><p>The basic idea of a Metropolis Hastings sampler is given in Figure <ref type="figure">1</ref>. The algorithm maintains a current candidate C. It also has a set of moves. A move, m : S → S, mutates a candidate to a different candidate. The goal of the search is to sample candidates with low cost. By applying a randomly chosen move, the search transitions from a candidate C to a new candidate C . If C has lower cost than C we keep it and C becomes the current candidate. If C has higher cost than C, then with some probability we still keep C . Otherwise, we undo this move and apply another randomly selected move to C. Using these random mutations, combined with the use of the cost function, the search moves towards low cost candidates. We continue proposing moves until the search converges: the cost reduces to zero.</p><p>The algorithm in Figure <ref type="figure">1</ref>, when instantiated with a suitable proposal mechanism (SampleMove) and a cost function (c V ), can be used for a variety of optimization tasks. If the proposal mechanism is designed to be symmetric and ergodic then Figure <ref type="figure">1</ref> has interesting theoretical guarantees.</p><p>A proposal mechanism is symmetric if the probability of proposing a transition from C 1 to C 2 is equal to the probability of proposing a transition from C 2 to C 1 . Note that the cost is not involved here: whether the proposal is accepted or rejected is a different matter. Symmetry just talks about the probability that a particular transition is proposed from the available transitions.</p><p>A proposal mechanism is ergodic if there is a non-zero probability of reaching every possible candidate C 2 starting from any arbitrary candidate C 1 . That is, there is a sequence of moves, m 1 , m 2 , . . . , m k , such that the probability of sampling each m i is non-zero and C 2 = m k (. . . (m 1 (C 1 ) . . .). This property is desirable because it says that it is not impossible to reach I starting from a bad initial guess. If the proposal mechanism is symmetric and ergodic then the following theorem holds <ref type="bibr" target="#b3">[4]</ref>: Theorem 1. In the limit, the algorithm in Figure <ref type="figure">1</ref> samples candidates in inverse proportion to their cost.</p><p>Intuitively, this theorem says that the candidates with lower cost are sampled more frequently. A corollary of this theorem is that the search always converges. The proof of this theorem relies on the fact that the search space S should be finite dimensional. Note that MCMC sampling has been shown to be effective in practice for extremely large search spaces and, with good cost functions, is empirically known to converge well before the limit is reached <ref type="bibr" target="#b3">[4]</ref>. Hence, we design our search space of invariants to be a large but finite dimensional space that contains most useful invariants by using templates. For example, our search space of disjunctive numerical invariants restricts the boolean structure of the invariants to be a DNF formula with ten disjuncts where each disjunct is a conjunction of ten linear inequalities. This very large search space is more than sufficient to express all the invariants in our numerical benchmarks.</p><p>Theorem 1 has limitations. The guarantee is only asymptotic and convergence could require more than the remaining lifetime of the universe. However, if the cost function is arbitrary then it is unlikely that any better guarantee can be made. In practice, for a wide range of cost functions with domains ranging from protein alignment <ref type="bibr" target="#b39">[40]</ref> to superoptimization <ref type="bibr" target="#b43">[44]</ref>, MCMC sampling has been demonstrated to converge in reasonable time. Empirically, cost functions that provide feedback to the search have been found to be useful <ref type="bibr" target="#b43">[44]</ref>. If the search makes a move that takes it closer to the answer then it should be rewarded with a decrease in cost. Similarly, if the search transitions to something worse then the cost should increase. We next present our cost function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Cost Function</head><p>Consider the VCs of Eqn. 1. One natural choice for the cost function is</p><formula xml:id="formula_3">c V (C) = 1 -Validate(V [C/I])</formula><p>where Validate(X ) is 1 if predicate X is valid and 0 otherwise. We substitute the candidate C for the unknown predicate I in the VCs and if the VCs are valid then the cost is zero and otherwise the cost is one. This cost function has the advantage that a candidate with cost zero is an invariant. However, this cost function is a poor choice for two reasons:</p><p>1. Validation is slow. A decision procedure takes several milliseconds in the best case to discharge a query. For a random search to be effective we need to be able to explore a large number of proposals quickly. 2. This cost function does not give any incremental feedback. The cost of all incorrect candidates is one, although some candidates are clearly closer to the correct invariant than others.</p><p>Empirically, search based on this cost function times out on even the simplest of our benchmarks. Instead of using a decision procedure in the inner loop of the search, we use a set of concrete program states that allows us to quickly identify incorrect candidates. As we shall see, concrete states also give us a straightforward way to measure how close a candidate is to a true invariant.</p><p>Recall from the discussion of Eqn. 1 that there are three different kinds of interesting concrete states. Assume we have a set of good states G, a set of bad states B, and a set of pairs Z. The data elements encode constraints that a true invariant must satisfy. A good candidate C is should satisfy the following constraints:</p><p>1. It should separate all the good states from all the bad states:</p><formula xml:id="formula_4">∀g ∈ G.∀b ∈ B.¬(C(g) ⇔ C(b)). 2.</formula><p>It should contain all good states: ∀g ∈ G.C(g).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">It should exclude all bad states: ∀b ∈ B.¬C(b).</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">It should satisfy all pairs: ∀(s, t) ∈ Z.C(s) ⇒ C(t).</head><p>For most classes of predicates it is easy to check whether a candidate satisfies these constraints for given sets G, B, and Z without using decision procedures. For every violated constraint, we assign a penalty cost. In general, we can assign different weights to different constraints, but for simplicity, we weight them equally. The reader may notice that the first constraint is subsumed by constraints 2 and 3. However, we keep it as a separate constraint as it encodes the amount of data that justifies a candidate. If a move causes a candidate to satisfy a bad state (which it did not satisfy before) then intuitively the increase in cost should be higher if the initial candidate satisfied many good states than if it satisfied only one good state. The third constraint penalizes equally in both scenarios (the cost increases by 1) and in such situations the first constraint is useful. The result is a cost function that does not require decision procedure calls, is fast to evaluate, and can give incremental credit to the search: the candidates that violate more constraints are assigned a higher cost than those that violate only a few constraints.</p><formula xml:id="formula_5">c V (C) = g∈G b∈B ¬C(g) * ¬C(b) + C(g) * C(b) + g∈G ¬C(g) + b∈B C(b) + (s,t)∈Z C(s) * ¬C(t) (3)</formula><p>In evaluating this expression, we interpret false as zero and true as one.</p><p>This cost function has one serious limitation: Even if a candidate has zero cost, still the candidate might not be an invariant. Once a zero cost candidate C is found, we check whether C is an invariant using a decision procedure; note this decision procedure call is made only if C satisfies all the constraints and therefore has at least some chance of actually being an invariant. If C is not an invariant one of the three parts of Eqn. 1 will fail and if the decision procedure can produce counterexamples then the counterexample will also be one of three possible kinds. If the candidate violates the first condition of Eqn. 1 then the counterexample is a good state and we add it to G. If the candidate violates the second condition then the counter example is a pair that we add to Z, and finally if the candidate violates the third condition then we get a bad state that we add to B. We then search again for a candidate with zero cost according to the updated data. Thus our inference procedure can be thought of as a counterexample guided inductive synthesis (CEGIS) procedure <ref type="bibr" target="#b48">[49]</ref>, in particular, as an ICE learner <ref type="bibr" target="#b19">[20]</ref>. Note that a pair (s, t) can also contribute to G or B. If s ∈ G then t can be added to G. Similarly, if t ∈ B then s can be added to B. If a state is in both G and B then we abort the search. Such a state is both a certificate of the invalidity of the VCs and of a bug in the program.</p><p>Not all decision procedures can produce counterexamples; in fact, in many more expressive domains of interest (e.g., the theory of arrays) generating counterexamples is impossible in general. In such situations the data we need can also be obtained by running the program. Consider the program point η where the invariant is supposed to hold. Good states are generated by running the program with inputs that satisfy the pre-conditions and collecting the states that reach η. Next, we start the execution of the program from η with an arbitrary state σ; i.e., we start the execution of the program "in the middle". If an assertion violation happens during the execution then all the states reaching η, including σ, during this execution are bad states. Otherwise, including the case when the program does not terminate (the loop is halted after a user-specified number of iterations), the successive states reaching η can be added as pairs. Note that successive states reaching the loop head are always pairs and may also be pairs of good states, bad states, or even neither.</p><p>The cost function of Eqn. 3 easily generalizes to the case when we have multiple unknown predicates. Suppose there are n unknown predicates I 1 , I 2 , . . . I n in the VCs. We associate a set of good states G i and bad states B i with every predicate I i . For pairs, we observe that VCs in our benchmarks have at most one unknown predicate symbol to the right of the implication and one unknown predicate symbol to the left (both occurring positively), implying that commonly n 2 sets of pairs suffices: a set of pairs Z i,j is associated with every pair of unknown predicates I i and I j . A candidate C 1 , . . . , C n satisfies the set of pairs Z i,j if ∀(s, t) ∈ Z i,j .C i (s) ⇒ C j (t). For the pair (s, t) ∈ Z i,j , if s ∈ G i then we add t to G j and if t ∈ B j then we add s to B i . Each of G i , B i , and Z i,j induces constraints and a candidate is penalized by each constraint it fails to satisfy.</p><p>In subsequent sections we use the cost function in Eqn. 3 and the search algorithm in Figure <ref type="figure">1</ref>, irrespective of the type of program (numeric, array, string, or list) under consideration. What differs is the instantiation of c2i with different decision procedures and search spaces of invariants. Since a proposal mechanism dictates how a search space is traversed, different search spaces require different proposal mechanisms. In general, when c2i is instantiated with a search space, the user must provide a proposal mechanism and a function eval that evaluates a predicate in the search space on a concrete state, returning true or false. The function eval is used to evaluate the cost function; for the search spaces discussed in this paper, the implementation of eval is straightforward and we omit it. We discuss the proposal mechanisms for each of the search spaces in some detail in the subsequent sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Numerical Invariants</head><p>We describe the proposal mechanism for inferring numerical invariants. Suppose x 1 , x 2 , . . . , x n are the variables of the program, all of type Z. A program state σ is a valuation of these variables: σ ∈ Z n . For each unknown predicate of the given VCs, the search space S is formulas of the following form:</p><formula xml:id="formula_6">α i=1 β j=1 n k=1 w (i,j) k x k ≤ d (i,j)</formula><p>Hence, predicates in S are boolean combinations of linear inequalities. We refer to w's as coefficients and d's as constants. The possible values that w's and d's can take are restricted to a finite bag of coefficients W = {w 1 , w 2 , . . . , w |W | } and a finite bag of constants D = {d 1 , d 2 , . . . , d |D| } respectively. These bags contain all of the statically occurring constants in the program as well as their sums and differences, which has sufficed in our experience. If needed, heuristics to mine relevant constants from concrete states, as described in <ref type="bibr" target="#b45">[46]</ref>, can be used.</p><p>For our experiments, for the benchmarks that require conjunctive invariants we set α = 1 and β = 10 and for those that require disjunctive invariants we set α = β = 10. This search space, S, is sufficiently large to contain invariants for all of our benchmarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Proposal Mechanism</head><p>We use y ∼ Y to denote that y is selected uniformly at random from the set Y and These moves are motivated by the fact that prior empirical studies of MCMC have found that a proposal mechanism that has a bias towards simple solutions and a good mixture of moves that make minor and major changes to a candidate leads to good results <ref type="bibr" target="#b43">[44]</ref>. This proposal mechanism is symmetric and ergodic. Combining this proposal mechanism with the cost function in Eqn. 3 and the procedure in Figure <ref type="figure">1</ref> provides us a search procedure for numerical invariants. We call this procedure MCMC in the empirical evaluation of Section 3.3. The user can also restrict the constituent inequalities of the candidate invariants to a given abstract domain. This variation is called Templ in the evaluation in Section 3.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1. Inference of numerical invariants for proving safety properties</head><p>Program Z3-H ICE <ref type="bibr" target="#b45">[46]</ref> [28] MCMC Templ cgr1 <ref type="bibr" target="#b24">[25]</ref> 0.0 0.0 0.2 0.1 0.0 0.0 cgr2 <ref type="bibr" target="#b24">[25]</ref> 0.0 7.3 ? ? 1.5 1.2 fig1 [25] 0.0 0.1 ? ? 0.9 1.4 w1 <ref type="bibr" target="#b24">[25]</ref> 0.0 0.0 0.2 0.1 0.0 0.0 fig3 <ref type="bibr" target="#b21">[22]</ref> 0.0 0.0 0.1 0.1 0.0 0.0 fig9 <ref type="bibr" target="#b21">[22]</ref> 0.0 0.0 0.2 0.1 0.0 0.0 tacas <ref type="bibr" target="#b32">[33]</ref> TO 1.4 0.5 0.1 0.5 0.0 ex23 <ref type="bibr" target="#b31">[32]</ref> ? 14.2 ? ? 0.1 0.1</p><p>Program Z3-H ICE <ref type="bibr" target="#b45">[46]</ref> [28] MCMC Templ ex7 <ref type="bibr" target="#b31">[32]</ref> 0.0 0.0 0.4 ? 0.0 0.0 ex14 <ref type="bibr" target="#b31">[32]</ref> 0.0 0.0 0.2 ? 0.0 0.0 array <ref type="bibr" target="#b4">[5]</ref> 0.0 0.3 0.2 ? 0.2 0.3 fil1 <ref type="bibr" target="#b4">[5]</ref> 0.0 0.0 0.4 0.1 0.0 0.0 ex11 <ref type="bibr" target="#b4">[5]</ref> 0.0 0.6 0.2 0.1 0.0 0.0 trex01 [5] 0.0 0.0 0.4 0.1 0.0 0.0 monniaux 5.14 0.0 1.0 0.2 0.0 0.0 nested 0.0 ? 1.0 0.0 0.3 2.1</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Example</head><p>We now give a simple example to illustrate the moves. Suppose we have two variables x 1 and x 2 , α = β = 1, the initial candidate is C ≡ 0 * x 1 + 0 * x 2 ≤ 0, W = {0, 1}, and D = {0, 1}. Then a coefficient move leaves C unchanged with probability 0.5 and mutates it to 1 * x 1 + 0 * x 2 ≤ 0 or 0 * x 1 + 1 * x 2 ≤ 0 with probability 0.25 each. A constant move leaves C unchanged with probability 0.5 and mutates it to 0 * x 1 + 0 * x 2 ≤ 1 with probability 0.5. A predicate move (for ρ = 0) leaves C unchanged with probability 0.125 and mutates it to</p><formula xml:id="formula_7">x 1 ≤ 0, x 2 ≤ 0, 0 ≤ 1, x 1 ≤ 1, x 2 ≤ 1, x 1 + x 2 ≤ 0, or x 1 + x 2 ≤</formula><p>1 with probability 0.125 each.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Evaluation</head><p>We start with no data: G = B = Z = ∅. The initial candidate invariant J is the predicate in S that has all the coefficients and the constants set to zero: ∀i, j, k.w (i,j) k = 0 ∧ d (i,j) = 0. The cost is evaluated using Eqn. 3 and when a candidate with cost zero is found then the decision procedure Z3 <ref type="bibr" target="#b37">[38]</ref> is called. If Z3 proves that the candidate is indeed an invariant then we are done. Otherwise, Z3 provides a counterexample that is incorporated in the data and the search is restarted with J as the initial candidate. A round consists of one search-and-validate iteration: finding a predicate with zero cost and asking Z3 to prove/refute it.</p><p>For each benchmark in Table <ref type="table">1</ref>, the problem is to find an invariant strong enough to discharge assertions in the program. The Z3-H column shows the time taken by Z3-Horn <ref type="bibr" target="#b29">[30]</ref>. Z3-Horn is a decision procedure inside Z3 for solving VCs with unknown predicates. ICE shows the search-and-validate approach of <ref type="bibr" target="#b19">[20]</ref>. The next column evaluates a geometric machine learning algorithm <ref type="bibr" target="#b45">[46]</ref> to search for candidate invariants and the next column is InvGen <ref type="bibr" target="#b27">[28]</ref> a symbolic invariant inference engine that uses concrete data for constraint simplification. Columns ICE, <ref type="bibr" target="#b45">[46]</ref>, and <ref type="bibr" target="#b27">[28]</ref> have been copied verbatim from <ref type="bibr" target="#b19">[20]</ref> and the reader is referred to <ref type="bibr" target="#b19">[20]</ref> for details. The MCMC column shows for MCMC search the total time of all the rounds including the time for both search and validation.The Templ column shows the time when we manually provide abstract domains (octagons/octahedra) to the search. All of our experiments were performed on a We consider the benchmarks for proving non-termination from TnT <ref type="bibr" target="#b26">[27]</ref> and Looper in Table <ref type="table" target="#tab_0">2</ref>. Since these papers do not include performance results, we compare randomized search with Z3-Horn. In Table <ref type="table" target="#tab_0">2</ref>, Z3-Horn is fast on half of the benchmarks and times out after thirty minutes on the other half. This observation suggests the sensitivity of symbolic inference engines to the search heuristics and the usefulness of Theorem 1. Randomized search, with an asymptotic convergence guarantee, successfully handles all the benchmarks in less than a second.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Arrays</head><p>We consider the inference of universally quantified invariants over arrays. A program state for an array manipulating program contains the values of all the numerical variables and the arrays in scope. Given an invariant, existing decision procedures are robust enough to check that it indeed is an actual invariant, but generally fail to find concrete counterexamples to refute incorrect candidates. This situation is a real concern, because if our technique is to be generally applicable then it must deal with the possibility that the decision procedures might not always be able to produce counterexamples to drive the search. As outlined in Section 2.2, the good states, the bad states, and the pairs required for search can also be obtained from program executions.</p><p>We use an approach similar to <ref type="bibr" target="#b45">[46,</ref><ref type="bibr" target="#b18">19]</ref> to generate data. Let Σ k denote all states in which all numerical variables are assigned values ≤ k, all arrays have sizes ≤ k, and all elements of these arrays are also ≤ k. We generate all states in Σ 0 , then Σ 1 , and so on. To generate data, we run the loop with these states (see Section 2.2). To refute a candidate invariant, states from these runs are returned to the search. For our benchmarks, we did not need to enumerate beyond Σ 4 (at most 150 states) before an invariant was discovered. Note that <ref type="bibr" target="#b45">[46,</ref><ref type="bibr" target="#b18">19]</ref> test only on reachable states. We additionally test on unreachable states to obtain bad states and pairs. Better testing approaches are certainly possible <ref type="bibr" target="#b28">[29]</ref>. We now define a search space of invariants to simulate the fluid updates abstraction for reasoning about arrays <ref type="bibr" target="#b14">[15]</ref>. If x 1 , . . . , x n are the numerical variables of the program and f and g are array variables, then we are interested in array invariants of the following form:</p><formula xml:id="formula_8">∀u, v.T (x 1 , x 2 , . . . , x n , u, v) ⇒ f [u] = g[v]<label>( 4 )</label></formula><p>The variables u and v are universally quantified variables and T is a numerical predicate in the quantified variables and the variables of the program. Using this template, we reduce the search for array invariants to numerical predicates T (x 1 , x 2 , . . . , x n , u, v). The search for T proceeds as described in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Evaluation</head><p>We evaluate the randomized search algorithms on the benchmarks of <ref type="bibr" target="#b14">[15]</ref> in Table <ref type="table" target="#tab_1">3</ref>. The VCs for these benchmarks were obtained from the repository of the competition on software verification. 1 We have omitted benchmarks with bugs from the original benchmark set; these bugs are triggered during data generation. The second column shows the time taken to analyze these benchmarks using the fluid updates abstraction in <ref type="bibr" target="#b14">[15]</ref>. Using a specialized abstract domain leads to a very efficient analysis, but the scope of the analysis is limited to array manipulating programs that have invariants given by Eqn. <ref type="bibr" target="#b3">4</ref>.</p><p>In <ref type="bibr" target="#b7">[8]</ref>, the authors use templates to reduce the task of inferring universally quantified invariants for array manipulating programs to numerical invariants and show results using three different back-ends: Z3-Horn <ref type="bibr" target="#b29">[30]</ref>, Armc <ref type="bibr" target="#b20">[21]</ref>, and Duality <ref type="bibr" target="#b36">[37]</ref>. These are reproduced verbatim as columns Z3-H, ARMC, and Dual of Table <ref type="table" target="#tab_1">3</ref>. Details about these columns can be found in the original text <ref type="bibr" target="#b7">[8]</ref>. Note that the benchmark init-e requires a divisibility constraint that none of these back-ends or our search algorithms currently support.</p><p>Columns MCMC and Templ describe our randomized searches: the total time to search (with sufficient data) and validate an invariant. Again the results are 1 https://svn.sosy-lab.org/software/sv-benchmarks/trunk/clauses/QALIA/ i := 0; x := "a"; while(non_det()){ i++; x := "(" + x + ")"; } assert( x.length == 2*i+1 ); if(i&gt;0) assert( x.contains( "(a)" ) );</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 2. A string manipulating program</head><p>competitive with previous domain-specific approaches. Also, a comparison of MCMC and Templ shows that convergence depends crucially on the proposal mechanism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Strings</head><p>Consider the string manipulating program in Figure <ref type="figure">2</ref>. To validate its assertions, the invariants must express facts about the contents of strings, integers, and lengths of strings; we are unaware of any previous inference technique that can infer such invariants. The string operations such as length (compute the length of a string), indexof (find the position of a string in another string), substr (extract a substring between given indices), etc., intermix integers and strings and pose a challenge for invariant inference. However, the decision procedure Z3str <ref type="bibr" target="#b50">[51]</ref> can decide formulas over strings and integers. We use c2i to construct an invariant inference procedure from Z3-str.</p><p>A program state contains the values of all the numerical and the string variables. The search space S consists of boolean combinations of predicates that belong to a given bag P of predicates: α j=1 β k=1 P j k where P j k ∈ P. The bag P is constructed using the constants and the predicates occurring in the program. We set α = 5, β = 10, and for Figure <ref type="figure">2</ref>, P has predicates x.contains(y), y 1 = y 2 , w 1 i + w 2 x.length + w 3 ≤ 0 where y ∈ {x, "a", "(", ")", "(a)"} and w ∈ [-2 <ref type="bibr">: 2]</ref>. A move replaces a randomly selected P j k with a randomly selected predicate from P. The current counterexample generation capabilities of Z3-str are unreliable and we generate data using the process explained in Section 4. (At most 25 data elements are sufficient to obtain an invariant.) For the program in Figure <ref type="figure">2</ref>, randomized search discovers the following invariant:</p><p>x = "a" ∧ i = 0 ∨ x.contains("(a)") ∧ x.length = 2i + 1</p><p>We consider some additional examples in Table <ref type="table" target="#tab_2">4</ref> and the name indicates the string operations they use. Due to the absence of an existing benchmark suite for string-manipulating programs, our evaluation is limited to a few handwritten examples.</p><p>One alternative to c2i for proving these examples involves designing a new abstract interpretation <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b12">13]</ref>, which requires designing an abstract domain that incorporates both strings and integers, an abstraction function, a widening operator, and abstract transfer functions that are precise enough to find disjunctive invariants like the one shown above. Such an alternative requires significantly greater effort than instantiating c2i. In our implementation, both the proposal mechanism and the eval function required to instantiate c2i are under 50 lines of C++ each.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Relations</head><p>In this section we define a proposal mechanism to find invariants over relations. We are given a program with variables x 1 , x 2 , . . . , x n and some relations R 1 , R 2 , . . . , R m . A program state is an evaluation of these variables and these relations. The search space consists of predicates F given by the following grammar:</p><p>Predicate</p><formula xml:id="formula_9">F ::= θ i=1 F i Formula F i ::= δ j=1 G i j Subformula G i ::= ∀u 1 , u 2 , . . . , u i .T QF Predicate T ::= α k=1 β l=1 L k l Literal L ::= A | ¬A Atom A ::= R(V 1 , . . . , V a ) a = arity(R) Argument V ::= x | u | κ (5)</formula><p>A predicate in the search space is a conjunction of formulas. The superscript of F i denotes the number of quantified variables in its subformulas. A subformula G i is a quantified predicate with its quantifier free part T expressed in DNF. Each atomic proposition of this DNF formula is a relation whose arguments can be a variable of the program (x), a quantified variable (u), or some constant (κ) like null. The variables in scope of a relation in a predicate are the program variables and the quantified variables in the associated subformula.</p><p>Next we define the moves of our proposal mechanism. We select a move uniformly at random from the list below and apply it to the current candidate C. As usual, we write "at random" to mean "uniformly at random".</p><p>1. Variable move: Select an atom of C at random. Next, select one of the arguments and replace it with an argument selected at random from the variables in scope and the constants. 2. Relation move: Select an atom of C at random and replace its relation with a relation selected at random from the set of relations of the same arity. The arguments are unaffected. 3. Atom move: Select an atom of C at random and replace its relation with a relation selected at random from all available relations. Perform variable moves to fill the arguments of the new relation. 4. Flip polarity: Negate a literal selected at random from the literals of C. 5. Literal move: Perform an atom move and flip polarity. These moves are symmetric and ergodic. Next, we evaluate the MCMC algorithm in Figure <ref type="figure">1</ref> with this proposal mechanism and the cost function of Eqn. 3.</p><p>We instantiate the relational proposal mechanism with reachability relations: The reachability relation n * (i, j) holds if the cell pointed to by j can be reached from i using zero or more pointer dereferences. A recently published decision procedure is complete for such candidates via a reduction of such formulas to boolean satisfiability <ref type="bibr" target="#b30">[31]</ref>. We use this decision procedure as our validator and randomized search to find invariants for some standard singly linked list manipulating programs (described in <ref type="bibr" target="#b30">[31]</ref>) in Table <ref type="table" target="#tab_3">5</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Evaluation</head><p>For defining the search space using Eqn. 5 we set α = β = δ = 5 and θ = 2, which is sufficient to express the invariants for benchmarks in Table <ref type="table" target="#tab_3">5</ref>. We run our benchmarks on lists of length up to five to generate an initial set of good states, the size of which is shown in the column #G. Starting from a non-empty set of good states results in faster convergence than starting from an empty set. Next, we start our search with zero bad states and zero pairs and generate candidate invariants. The number of rounds for the search to converge to an invariant is shown in the column #R. Later rounds take more time than the initial rounds.</p><p>Columns Search and Valid describe the time to search (with sufficient data) and to validate an invariant respectively. During our evaluation of various verification tasks, we observe that the decision procedures for advanced logics are not able to accept all formulas in their input language. Hence, sometimes we must perform some equality-preserving simplifications on the candidate invariants our search discovers. Currently we perform this step manually when necessary, but the simplifications could be automated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>The goal of this paper is a framework to obtain inference engines from decision procedures. c2i is parametrized by the language of possible invariants. This characteristic is similar to TVLA <ref type="bibr" target="#b42">[43]</ref>. TVLA requires specialized heuristics (focus, coerce, etc.) to maintain precision. We do not require these heuristics and this generality aids us in obtaining inference procedures for verification tasks beyond shape analysis. c2i is a template-based analysis that does not use decision procedures to instantiate the templates and limits their use to checking an annotated program. We do not rely on decision procedures to compute a predicate cover <ref type="bibr" target="#b25">[26]</ref>, or for fixpoint iterations <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b49">50]</ref>, or on Farkas' lemma <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b6">7]</ref>. Hence, c2i is applicable to various decision procedures, including incomplete procedures (Section 4 and Section 5).</p><p>The literature on invariant inference is huge. Most techniques for invariant inference are symbolic analyses that trade generality for effective techniques in specific domains <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b0">1]</ref>. We are not aware of any symbolic inference technique that has been successfully demonstrated to infer invariants for the various types of programs that we consider (numeric, array, string, and list). Daikon <ref type="bibr" target="#b16">[17]</ref> and Houdini <ref type="bibr" target="#b17">[18]</ref> use conjunctive learning, <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b40">41]</ref> use equation solving, and <ref type="bibr" target="#b46">[47]</ref> uses SVMs: these fail to infer disjunctive invariants over inequalities. The underlying machine learning algorithm of <ref type="bibr" target="#b45">[46]</ref> uses geometry and hence is applicable to numerical predicates only.</p><p>Algorithmic learning <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b33">34]</ref> approaches also iteratively invoke search and validate phases. They use a CDNF learning algorithm that requires membership queries, "is a conjunction of atomic predicates contained in the invariant?", that are resolved heuristically. We do not require membership queries. Other techniques that use concrete data to guide verification include <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b38">39]</ref>.</p><p>We are unaware of the any previous work that uses Metropolis Hastings for invariant inference. In a related work, <ref type="bibr" target="#b22">[23]</ref> uses Gibbs sampling for inference of numerical invariants. However, the inference does not use concrete states and the resulting cost function is expensive to evaluate. Handling programs with pointers and arrays is left as an open problem by <ref type="bibr" target="#b22">[23]</ref>.</p><p>We use efficiency to guide the choice of parameters for randomized search. E.g., in our evaluations, we set γ in Figure <ref type="figure">1</ref> to log e 2. Systematic approaches described in <ref type="bibr" target="#b47">[48]</ref> can also be used for setting such parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We have demonstrated a general procedure for generating an inference procedure from a checking procedure and applied it to a variety of programs. The inference procedure uses randomized search for generating candidate invariants that are proven or refuted by the checker. While c2i is general and can handle many classes of useful invariants, its performance is still competitive with state of the art tools that are specialized for specific domains.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>3 :-</head><label>3</label><figDesc>[a : b] to denote the set of integers in the range {a, a + 1, . . . , b -1, b}. Unless stated otherwise, all random choices are derived from uniform distributions. Before a move we make the following random selections: i ∼ [1 : α], j ∼ [1 : β], and k ∼ [1 : n] .We have the following three moves, each of which is selected with probability 1 Coefficient move: select l ∼ [1 : |W |] and update w (i,j) k to W l . -Constant move: select m ∼ [1 : |D|] and update d (i,j) to D m . -Inequality move: With probability 1ρ, apply constant move to d (i,j) and coefficient move to w (i,j) h for all h ∈ [1 : n]. Otherwise (with probability ρ) remove the inequality by replacing it with true.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 2 .</head><label>2</label><figDesc>Results on non-termination benchmarks GHz Intel i7 with 4GB of memory. The experiments we compare to in Table 1 and in the rest of the paper were performed on a variety of machines. Our goal in reporting performance numbers is not to make precise comparisons, but only to show that c2i has competitive performance with other techniques. Indeed, we observe that the time measurements of the c2i searches in Table1are competitive with previous techniques.</figDesc><table><row><cell cols="2">Program Z3-H MCMC Templ</cell></row><row><cell cols="2">term1 0.01 0.02 0.01</cell></row><row><cell>term2</cell><cell>TO 0.04 0.05</cell></row><row><cell>term3</cell><cell>TO 0.04 0.06</cell></row><row><cell cols="2">term4 0.01 0.04 0.06</cell></row><row><cell cols="2">term5 0.01 0.01 0.02</cell></row><row><cell>term6</cell><cell>TO 0.12 0.07</cell></row><row><cell>2.2</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 3 .</head><label>3</label><figDesc>Results on array manipulating programs</figDesc><table><row><cell cols="3">Program [15] Z3-H ARMC Dual MCMC Templ</cell><cell cols="2">Program [15] Z3-H ARMC Dual MCMC Templ</cell></row><row><cell>init</cell><cell cols="2">0.01 0.06 0.15 0.72 0.02 0.01</cell><cell cols="2">d-swap 0.16 1.37 4.4 TO TO 0.51</cell></row><row><cell cols="3">init-nc 0.02 0.08 0.48 6.60 0.15 0.02</cell><cell cols="2">strcpy 0.07 0.05 0.15 0.62 0.02 0.01</cell></row><row><cell cols="3">init-p 0.01 0.03 0.14 2.60 0.01 0.01</cell><cell cols="2">strlen 0.02 0.07 0.02 0.20 0.01 0.01</cell></row><row><cell cols="3">init-e 0.04 TO TO TO TO TO</cell><cell cols="2">memcpy 0.04 0.20 16.30 0.20 0.03 0.01</cell></row><row><cell cols="2">2darray 0.04 0.18 ?</cell><cell>TO 0.41 0.02</cell><cell>find</cell><cell>0.02 0.01 0.08 0.38 0.30 0.02</cell></row><row><cell>copy</cell><cell cols="2">0.01 0.04 0.20 1.40 0.80 0.02</cell><cell cols="2">find-n 0.02 0.01 0.08 0.39 0.95 0.01</cell></row><row><cell cols="3">copy-p 0.01 0.04 0.21 1.80 0.13 0.01</cell><cell cols="2">append 0.02 0.04 1.76 1.50 TO 0.12</cell></row><row><cell cols="3">copy-o 0.04 TO ? 4.50 TO 0.50</cell><cell>merge</cell><cell>0.09 0.04 ? 1.50 TO 0.41</cell></row><row><cell cols="3">reverse 0.03 0.12 2.28 8.50 3.48 0.03</cell><cell cols="2">alloc-f 0.02 0.02 0.09 0.69 0.10 0.01</cell></row><row><cell>swap</cell><cell cols="2">0.12 0.41 3.0 40.60 TO 0.21</cell><cell cols="2">alloc-nf 0.03 0.03 0.13 0.42 0.14 0.07</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 4 .</head><label>4</label><figDesc>Results on string manipulating programs. The time taken (in seconds) by MCMC search and by Z3-str (for proving the correctness of the invariants) are shown.</figDesc><table><row><cell></cell><cell cols="4">Figure 2 replace index substring</cell></row><row><cell>Search</cell><cell>0.8</cell><cell>0.02</cell><cell>0.06</cell><cell>0.05</cell></row><row><cell cols="2">Z3-str 0.03</cell><cell>TO</cell><cell>114.6</cell><cell>0.01</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 5 .</head><label>5</label><figDesc>Results for list manipulating programs</figDesc><table><row><cell>Program</cell><cell>#G #R Search Valid</cell></row><row><cell>delete</cell><cell>50 2 0.20 0.04</cell></row><row><cell cols="2">delete-all 20 7 1.03 0.13</cell></row><row><cell>find</cell><cell>50 9 0.42 0.04</cell></row><row><cell>filter</cell><cell>50 26 10.41 0.11</cell></row><row><cell>last</cell><cell>50 3 0.90 0.04</cell></row><row><cell>reverse</cell><cell>20 54 55.11 0.08</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We thank Eric Schkufza, Manolis Papadakis, and the anonymous reviewers for their comments. This work was supported by NSF grant CCF-1160904, a Microsoft fellowship, and the Air Force Research Laboratory under agreement number FA8750-12-2-0020. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">SAFARI: SMT-based abstraction for arrays with interpolants</title>
		<author>
			<persName><forename type="first">F</forename><surname>Alberti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bruttomesso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghilardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ranise</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2012</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7358</biblScope>
			<biblScope unit="page" from="679" to="685" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Syntax-guided synthesis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Juniwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raghothaman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Torlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Udupa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>FMCAD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Discovering invariants via simple component analysis</title>
		<author>
			<persName><forename type="first">G</forename><surname>Amato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Parton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Scozzari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symb. Comput</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">12</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An Introduction to MCMC for Machine Learning</title>
		<author>
			<persName><forename type="first">C</forename><surname>Andrieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>De Freitas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Doucet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<ptr target="https://svn.sosy-lab.org/software/svbenchmarks/tags/svcomp13/loops/" />
		<title level="m">Competition on Software Verification (SV-COMP) benchmarks</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The software model checker Blast</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Invariant synthesis for combined theories</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI 2007</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4349</biblScope>
			<biblScope unit="page" from="378" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On solving universally quantified horn clauses</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS 2013</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Logozzo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7935</biblScope>
			<biblScope unit="page" from="105" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Looper: Lightweight detection of infinite loops at runtime</title>
		<author>
			<persName><forename type="first">J</forename><surname>Burnim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jalbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stergiou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>ASE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Compositional shape analysis by means of bi-abduction</title>
		<author>
			<persName><forename type="first">C</forename><surname>Calcagno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Distefano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>O'hearn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>POPL</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Understanding the Metropolis-Hastings Algorithm</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chib</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Greenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The American Statistician</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Linear invariant generation using non-linear constraint solving</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Colón</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sankaranarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Sipma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2003</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Hunt</surname><genName>Jr</genName></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2725</biblScope>
			<biblScope unit="page" from="420" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Static analysis of string values</title>
		<author>
			<persName><forename type="first">G</forename><surname>Costantini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ferrara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cortesi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFEM 2011</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Qin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Z</forename><surname>Qiu</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6991</biblScope>
			<biblScope unit="page" from="505" to="521" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Fluid updates: Beyond strong vs. Weak updates</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP 2010</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6012</biblScope>
			<biblScope unit="page" from="246" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Inductive invariant generation via abductive inference</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OOPSLA</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Daikon system for dynamic detection of likely invariants</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pacheco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Tschantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Houdini, an annotation assistant for ESC/Java</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FME 2001</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Oliveira</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Zave</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2021</biblScope>
			<biblScope unit="page" from="500" to="517" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Learning universally quantified invariants of linear data structures</title>
		<author>
			<persName><forename type="first">P</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Löding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Neider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2013</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8044</biblScope>
			<biblScope unit="page" from="813" to="829" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">ICE: A Robust Framework for Learning Invariants</title>
		<author>
			<persName><forename type="first">P</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Löding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Neider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2014</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8559</biblScope>
			<biblScope unit="page" from="69" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Synthesizing software verifiers from proof rules</title>
		<author>
			<persName><forename type="first">S</forename><surname>Grebenshchikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Popeea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Synergy: a new algorithm for property checking</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Gulavani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>FSE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Program verification as probabilistic inference</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jojic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>POPL</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Discovering affine equalities using random interpretation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Program analysis as constraint solving</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Constraint-based invariant inference over predicate abstraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI 2009</title>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Müller-Olm</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5403</biblScope>
			<biblScope unit="page" from="120" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Proving non-termination</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R.-G</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">From tests to proofs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2009</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Kowalewski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Philippou</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5505</biblScope>
			<biblScope unit="page" from="262" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Improving test suites via operational abstraction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mellen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICSE</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Generalized property directed reachability</title>
		<author>
			<persName><forename type="first">K</forename><surname>Hoder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT 2012</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7317</biblScope>
			<biblScope unit="page" from="157" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Effectivelypropositional reasoning about reachability in linked data structures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Itzhaky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nanevski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2013</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8044</biblScope>
			<biblScope unit="page" from="756" to="772" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Ivancic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sankaranarayanan</surname></persName>
		</author>
		<ptr target="http://www.neclabs.com/research/system/systemsSAV-website/smallstaticbench-v1.1.tar.gz" />
		<title level="m">NECLA Static Analysis Benchmarks</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A practical and complete approach to predicate refinement</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2006</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Palsberg</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3920</biblScope>
			<biblScope unit="page" from="459" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Deriving invariants by algorithmic learning, decision procedures, and predicate abstraction</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI 2010</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Hermenegildo</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">5944</biblScope>
			<biblScope unit="page" from="180" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Universal symbolic execution and its application to likely data structure invariant generation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISSTA</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Automatically inferring quantified loop invariants by algorithmic learning from simple templates</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APLAS 2010</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Ueda</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6461</biblScope>
			<biblScope unit="page" from="328" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Combinatorial approach to some sparse-matrix problems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. rep</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Z3: An efficient SMT solver</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2008</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Ramakrishnan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Rehof</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4963</biblScope>
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Abstractions from tests</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Castelnuovo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Extracting protein alignment models from the sequence database</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Neuwald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Lipman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Lawrence</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Research</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Using dynamic analysis to discover polynomial and array invariants</title>
		<author>
			<persName><forename type="first">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kapur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICSE</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Termination proofs from tests</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/SIGSOFT FSE</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Parametric shape analysis via 3-valued logic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Stochastic superoptimization</title>
		<author>
			<persName><forename type="first">E</forename><surname>Schkufza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>ASPLOS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A data driven approach for algebraic loop invariants</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hariharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP 2013</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Gardner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7792</biblScope>
			<biblScope unit="page" from="574" to="592" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Program verification as learning geometric concepts</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hariharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SAS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Interpolants as classifiers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2012</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7358</biblScope>
			<biblScope unit="page" from="71" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Bias-variance tradeoffs in program analysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">The sketching approach to program synthesis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APLAS 2009</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Hu</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5904</biblScope>
			<biblScope unit="page" from="4" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Program verification using templates over predicate abstraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Z3-str: a Z3-based string solver for web application analysis</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/SIGSOFT FSE</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
