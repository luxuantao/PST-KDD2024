<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dependent Types for JavaScript</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ravi</forename><surname>Chugh</surname></persName>
							<email>rchugh@cs.ucsd.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Herman</surname></persName>
							<email>dherman@mozilla.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Mozilla Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ranjit</forename><surname>Jhala</surname></persName>
							<email>jhala@cs.ucsd.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Dependent Types for JavaScript</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E711D5B364DBA088ACD0464A4B61862A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features -Inheritance</term>
					<term>Polymorphism; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs -Logics of Programs Refinement Types</term>
					<term>JavaScript</term>
					<term>Strong Updates</term>
					<term>Prototype Inheritance</term>
					<term>Arrays</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present Dependent JavaScript (DJS), a statically typed dialect of the imperative, object-oriented, dynamic language. DJS supports the particularly challenging features such as run-time type-tests, higher-order functions, extensible objects, prototype inheritance, and arrays through a combination of nested refinement types, strong updates to the heap, and heap unrolling to precisely track prototype hierarchies. With our implementation of DJS, we demonstrate that the type system is expressive enough to reason about a variety of tricky idioms found in small examples drawn from several sources, including the popular book JavaScript: The Good Parts and the SunSpider benchmark suite.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Dynamic languages like JavaScript, Python, and Ruby are widely popular for building both client and server applications, in large part because they provide powerful sets of features -run-time type tests, mutable variables, extensible objects, and higher-order functions. But as applications grow, the lack of static typing makes it difficult to achieve reliability, security, maintainability, and performance. In response, several authors have proposed type systems which provide static checking for various subsets of dynamic languages <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b35">36]</ref>.</p><p>Recently, we developed System D <ref type="bibr" target="#b8">[9]</ref>, a core calculus for dynamic languages that supports the above dynamic id-Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA <ref type="bibr">'12, October 19-26, 2012</ref>, Tucson, Arizona, USA. Copyright Â© 2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 ioms but in a purely functional setting. The main insight in System D is to dependently type all values with formulas drawn from an SMT-decidable refinement logic. We use an SMT solver to reason about the properties it tracks well, namely, control-flow invariants and dictionaries with dynamic keys that bind scalar values. But to describe dynamic keys that bind rich values like functions, System D encodes function types as logical terms and nests the typing relation as an uninterpreted predicate within the logic. By dividing work between syntactic subtyping and SMT-based validity checking, the calculus supports fully automatic checking of dynamic features like run-time type tests, value-indexed dictionaries, higher-order functions, and polymorphism.</p><p>In this paper, we scale up the System D calculus to Dependent JavaScript (abbreviated to DJS), an explicitly typed dialect of a real-world, imperative, object-oriented, dynamic language. We bridge the vast gap between System D and JavaScript in three steps.</p><p>Step 1: Imperative Updates. The types of variables in JavaScript are routinely "changed" either by assignment or by incrementally adding or removing fields to objects bound to variables. The presence of mutation makes it challenging to assign precise types to variables, and the standard method of assigning a single "invariant" reference type that overapproximates all values held by the variable is useless in the JavaScript setting. We overcome this challenge by extending our calculus with flow-sensitive heap types (in the style of <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b31">32]</ref>) which allow the system to precisely track the heap location each variable refers to as well as aliasing relationships, thereby enabling strong updates through mutable variables. Our formulation of flow-sensitive heaps combined with higher-order functions and refinement types is novel, and allows DJS to express precise pre-and postconditions of heaps, as in separation logic <ref type="bibr" target="#b16">[17]</ref>.</p><p>Step 2: Prototype Inheritance. Each JavaScript object maintains an implicit link to the "prototype" object from which it derives. To resolve a key lookup from an object at run-time, JavaScript transitively follows its prototype links until either the key is found or the root is reached without success. Thus, unlike in class-based languages, inheritance relationships are computed at run-time rather than provided as declarative specifications. The semantics of prototypes is challenging for static typing, because to track the type of a key binding, the system must statically reason about a potentially unbounded number of prototype links! In DJS, we solve this problem with a novel decomposition of the heap into a "shallow" part, for which we precisely track a finite number of prototype links, and a "deep" part, for which we do not have precise information, represented abstractly via a logical heap variable. We unroll prototype hierarchies in shallow heaps to precisely model the semantics of object operations, and we use uninterpreted heap predicates to reason abstractly about deep parts. In this way, we reduce the reasoning about unbounded, imperative, prototype hierarchies to the underlying decidable, first-order, refinement logic.</p><p>Step 3: Arrays. JavaScript arrays are simply objects whose keys are string representations of integers. Arrays are commonly used both as heterogeneous tuples (that have a fixed number of elements of different types) as well as homogeneous collections (that have an unbounded number of elements of the same type). The overloaded use of arrays, together with the fact that arrays are otherwise syntactically indistinguishable and have the same prototype-based semantics as non-array objects, makes it hard to statically reason about the very different ways in which they are used. In DJS, we use nested refinements to address the problem neatly by uniformly encoding tuples and collections with refinement predicates, and by using intersection types that simultaneous encode the semantics of tuples, collections, and objects.</p><p>Expressiveness. We have implemented DJS (available at ravichugh.com/djs) and demonstrated its expressiveness by checking a variety of properties found in small but subtle examples drawn from a variety of sources, including the popular book JavaScript: The Good Parts <ref type="bibr" target="#b9">[10]</ref> and the Sun-Spider benchmark suite <ref type="bibr" target="#b33">[34]</ref>. Our experiments show that several examples simultaneously require the gamut of features in DJS, but that many examples conform to recurring patterns that rely on particular aspects of the type system. We identify several ways in which future work can handle these patterns more specifically in order to reduce the annotation burden and performance for common cases, while falling back to the full expressiveness of DJS in general. Thus, we believe that DJS provides a significant step towards truly retrofitting JavaScript with a practical type system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Overview</head><p>Let us begin with an informal overview of the semantics of JavaScript. We will emphasize the aspects that are the most distinctive and challenging from the perspective of type system design, and describe the key insights in our work that overcome these challenges.</p><p>JavaScript Semantics by Desugaring. Many corner cases of JavaScript are clarified by Î» JS <ref type="bibr" target="#b20">[21]</ref>, a syntax-directed translation, or desugaring, of JavaScript programs to a mostly-standard lambda-calculus with explicit references. As Î» JS is a core language with well-understood semantics and proof techniques, the translation paves a path to a typed dialect of JavaScript: define a type system for the core language and then type check desugared JavaScript programs.</p><p>We take this path by developing System !D (pronounced "D-ref"), a new calculus based on Î» JS . Although the operational semantics of System !D is straightforward, the dynamic features of the language ensure that building a type system expressive enough to support desugared JavaScript idioms is not. We solve this problem by scaling the purely functional technique of nested refinement types up to the imperative, object-oriented, setting of real-world JavaScript.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> depicts the architecture of our approach: we desugar a Dependent JavaScript (DJS) file program.js to the System !D file program.dref, which is analyzed by the type checker along with a standard prelude comprising three files (basics.dref, objects.dref, and prelude.dref) that model JavaScript semantics.</p><p>Terminology. JavaScript has a long history and an evolving specification. In this paper, we say "JavaScript" to roughly mean ECMAScript Edition 3, the standard version of the language for more than a decade <ref type="bibr" target="#b23">[24]</ref>. We say "ES5" to refer to Edition 5 of the language, recently released by the JavaScript standards committee <ref type="bibr" target="#b12">[13]</ref>; Edition 4 was never standardized. We say "ES6" to refer to features proposed for the next version of the language, scheduled to be finalized within the next one or two years. DJS includes a large set of core features common to all editions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Base Types, Operators, and Control Flow</head><p>Consider the following function adapted from <ref type="bibr" target="#b8">[9]</ref> and annotated in DJS. A function type annotation is written just above the definition inside a JavaScript comment demarcated by an additional : character. We typeset annotations in math mode for clarity, but the ASCII versions parsed by our type checker are quite similar.</p><formula xml:id="formula_0">/*: x â¶ Top â {Î½ ite Num(x) Num(Î½) Bool (Î½)} */ function negate(x) { if (typeof x == "number") { return 0 -x; } else { return !x; } }</formula><p>The typeof operator is a facility used pervasively to direct control flow based on the run-time "tag" of a value. If the input to negate is a number, so is the return value. If not, the function uses an interesting feature of JavaScript, namely, The negate function demonstrates that even simple JavaScript programs depend heavily on sophisticated controlflow based reasoning. Syntactic type systems are capable of tracking control flow to a limited degree <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b35">36]</ref>, but none can handle complex invariants like the relationship between the input and output of negate. To have any chance of capturing such invariants, types must be able to depend on other program values. Powerful dependent type systems like Coq can express extremely rich invariants, but are too heavyweight for our goals since they require the programmer to discharge type checking obligations interactively.</p><formula xml:id="formula_1">val typeof :: (* x â¶ Top â {Î½ = tag(x)} *) val ! :: (* x â¶ Top â {Î½ iff falsy(x)} *) val (||) :: (* x â¶ Top â y â¶ Top â {ite falsy(x) (Î½ = y) (Î½ = x)} *) val (&amp;&amp;) :: (* x â¶ Top â y â¶ Top â {ite truthy(x) (Î½ = y) (Î½ = x)} *) val (===) :: (* x â¶ Top â y â¶ {tag(Î½) = tag(x)} â {Î½ iff (x = y â§ x â  NaN)} *) val (==) :: (* x â¶ Top â y â¶ Top â {Bool (Î½) â§ (tag(x) = tag(y) â Î½ iff (x = y â§ x â  NaN))} *) val (+) :: (* x â¶ Str â y â¶ Str â Str *) val (+) :: (* x â¶ Num â y â¶ Num â {Num(Î½) â§ ((Int(x) â§ Int(y)) â (Int(Î½) â§ Î½ = x + y))} *) val fix :: (* âA. (A â A) â A *)</formula><p>Refinement Types. We adopt a more lightweight mechanism called refinement types that has been previously applied to purely functional dynamic languages <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9]</ref>. We demonstrate that refinement types afford us the expressiveness needed to precisely track control-flow invariants in the JavaScript setting and, unlike more powerful dependent systems, without sacrificing decidable type checking. In particular, once the programmer has written type annotations for function definitions, type checking is carried out automatically via a combination of syntactic subtyping and SMTbased <ref type="bibr" target="#b10">[11]</ref> logical validity checking.</p><p>In System !D, every value is described by a refinement type of the form {Î½ p}, read "Î½ such that p", where p is a formula that can mention Î½. For example, 3 can be given the type {Î½ tag(Î½) = "number"} and true the type {Î½ tag(Î½) = "boolean"}, where tag is an uninterpreted function symbol in the refinement logic, not a function in the programming language. We define abbreviations in Figure <ref type="figure">3</ref> to make the refinement binder implicit and the types concise.</p><p>Primitives. We use refinements to assign precise, and sometimes exact, types to System !D primitive functions,</p><formula xml:id="formula_2">{p} â = {Î½ p} Num(x) â = tag(x) = "number" Top(x) â = true Bool (x) â = tag(x) = "boolean" T â = {T (Î½)} Str (x) â = tag(x) = "string" if p then q1 else q2 â = ite p q1 q2 â = (p â q1) â§ (Â¬p â q2) x iff p â = ite p (x = true) (x = false) falsy(x) â = x â {false â¨ null â¨ undefined â¨ "" â¨ 0 â¨ NaN} truthy(x) â = Â¬falsy(x)</formula><p>Figure <ref type="figure">3</ref>. Abbreviations for common types defined in the file basics.dref (Figure <ref type="figure">2</ref>). Notice that typeof returns the tag of its input. Some examples beyond ones we have already seen include tag(null) = "object" and tag(undefined) = "undefined". The type of the negation operator ! inverts "truthiness." The types of the operators &amp;&amp; and || are interesting, because as in JavaScript, they do not necessarily return booleans. The "guard" operator &amp;&amp; returns its second operand if the first is truthy, which enables the idiom if (x &amp;&amp; x.f) { ... } that checks whether the object x and its "f" field are non-null. Dually, the "default" operator || returns its second operand if the first is falsy, which enables the idiom x = x || default to specify a default value. The + operator is specified as an intersection of function types and captures the fact that it performs both string concatenation and numerical addition, but does not type check expressions like 3 + "hi" that rely on the implicit coercion in JavaScript. We choose types for System !D primitives that prohibit implicit coercions since they often lead to subtle programming errors.</p><p>Equality. JavaScript provides two equality operators: == implicitly coerces the second operand if its tag differs from the first, and strict equality === does not perform any coercion. To avoid reasoning about implicit coercions, we give a relatively weaker type to ==, where the boolean result relates its operands only if they have the same tag.</p><p>Integers. JavaScript provides a single number type that has no minimum or maximum value. However, programmers and optimizing JIT compilers <ref type="bibr" target="#b37">[38]</ref> often distinguish integers from arbitrary numbers. In System !D, we describe integers with the abbreviation Int(x) â = Num(x) â§ integer (x). We introduce the uninterpreted predicate integer (x) in the types of integer literals, and functions like + propagate "integerness" where possible. Furthermore, numeric functions use the (decidable) theory of linear arithmetic to precisely reason about integers, which is important for dealing with arrays.</p><formula xml:id="formula_3">function also_negate(x) { if (typeof x == "number") x = 0 -x; else x = !x; return x; } ï± let also_negate = fun x -&gt; (* Î1 = â; Î£1 = â *) ï² let _x = ref x in (* Î2 = x â¶ Top; Î£2 = ( x â¦ x) *) ï³ if typeof (deref _x) == "number" then (* Î3 = Î2, x â¶ Ref x; Î£3 = Î£2 *) ï´ _x := 0 -(deref _x) (* Î4 = Î3, Num(x); Î£4 = âx4 â¶ Num. ( x â¦ x4) *) ïµ else ï¶ _x := !(deref _x) (* Î6 = Î3, Â¬Num(x); Î£6 = âx6 â¶ {Î½ iff falsy(x)}. ( x â¦ x6) *) ï· ; (* Î7 = Î3; Î£7 = âx â² â¶ {ite Num(x) Num(Î½) Bool (Î½)}. ( x â¦ x â² ) *) ï¸ deref _x in (* Î8 = Î3; Î£8 = Î£7 *) ï¹ let _also_negate = ref {"__code__": also_negate}</formula><p>Tracking Control Flow. System !D tracks control flow precisely by recording that the guard of an if-expression is truthy (resp. falsy) along the then-branch (resp. else-branch), enabling System !D to verify the annotation for negate as follows. Because of the call to typeof, System !D tracks that Num(x) holds along the then-branch, so x can be safely passed to the subtraction operator which produces a number as required. For the else-branch, System !D records that Â¬Num(x). The negation operator, which can be applied to any value, produces a value of type {Î½ iff Â¬falsy(x)} which is a subtype of Bool . Thus, both branches satisfy the specification provided by the programmer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Imperative Updates</head><p>JavaScript is an imperative language where variables can be reassigned arbitrary values. Consider the DJS function also_negate in Figure <ref type="figure" target="#fig_1">4</ref> that is like negate but first assigns the eventual result in the variable x, and its translation to System !D on the right (ignore the comments for now).</p><p>Several aspects of the translation warrant attention. First, since the formal parameter x, like all JavaScript variables, is mutable, the translation of the function body begins with an explicit reference cell _x initialized with x, and each read of x is desugared to a dereference of _x. Presentations of imperative languages often model assignable variables directly rather than with explicit references. Both approaches are equivalent; we choose the latter to make the presentation more similar to Î» JS <ref type="bibr" target="#b20">[21]</ref> and System D <ref type="bibr" target="#b8">[9]</ref>. Second, notice that scalar constants like 0 and true and operators like typeof and == are translated directly to corresponding ones in System !D. Third, notice that each assignment to the variable x translates to a set reference (i.e., assignment) operation to update the contents of the heap cell. Finally, since every JavaScript function is actually an object, the translation stores the function value in a distinguished " code " field, which we assume is inaccessible to source programs. Instead of this assumption, we could treat each function as a pair of a function value and an associated object, but we follow the Î» JS encoding for simplicity. For System !D to verify that also_negate satisfies the specification, it must precisely reason about heap updates in addition to controlflow as before.</p><p>Reference Types. The traditional way to handle references in the Î»-calculus <ref type="bibr" target="#b27">[28]</ref> is to (a) assign a reference cell some type Ref T , (b) require that only values of type T be stored in it, and then (c) conclude that dereferences produce values of type T . This approach supports so-called weak updates, because even if a stored value satisfies a stronger type S than T (i.e., if S is a subtype of T ), subsequent dereferences produce values of the original, weaker type T . Put another way, this approach requires that the type assigned to a reference cell be a supertype of all the values written to the cell. Unfortunately, weak updates would preclude System !D from verifying also_negate. The initialization of _x on line 2 stores the parameter x which has type Top, so _x would be assigned type Ref Top. The assignments on lines 4 and 6 type check because the updated values satisfy the trivial type Top, but the dereference on line 8 produces a value with type Top, which does not satisfy the specified return type. Thus, we need a way to reason more precisely about heap updates.</p><p>Strong Updates. Allowing assignment to change the type of a reference is called strong update, which is sound only when a reference is guaranteed to point to a single heap cell and when there are no accesses through other aliases that refer to the same cell. The Alias Types approach <ref type="bibr" target="#b31">[32]</ref> provides a means of managing these concerns. Rather than Ref T , a reference type is written Ref , where is the (compile-time) name of a location in the heap, and a separate (compiletime) heap maps locations to types, for example, ( â¦ T ). Strong updates are realized by allowing heaps to change flow-sensitively, and the aliasing problem is mitigated by maintaining the invariant that distinct location names and â² do not alias. System !D employs this approach by using a type environment Î that grows and shrinks as usual during type checking but remains flow-insensitive, and a heap environment Î£ that can be strongly updated per program point.</p><p>Figure <ref type="figure" target="#fig_1">4</ref> shows how System !D checks the desugared version of also_negate. The figure shows, at each line i, the type environment Î i used to check the expression on the line, and the heap environment Î£ i that exists after checking the expression. After starting with the empty heap Î£ 1 = â, the allocation on line 2 creates a fresh location x in the new heap Î£ 2 â = Î£ 1 â ( x â¦ x) and adds xâ¶Ref x to the type environment. We use the symbol â to construct unordered sets of heap bindings. To exploit the precision of dependent types, we map locations to values rather than types (i.e., ( â¦ x) rather than ( â¦ Top)).</p><p>When checking the if-expression guard on line 3, the deference retrieves the initial value x from the heap Î£ 2 , so as a result of the tag-test, System !D adds Num(x) to the type environment Î 4 along the true-branch and Â¬Num(x) to Î 6 along the false-branch. In the true-branch, the subtraction on line 4 is well-typed because Num(x), and produces a number x 4 that is stored in the heap Î£ 4 at location x . In the false-branch, x is negated on line 6, producing a boolean x 6 that is stored in the heap Î£ 6 at location x . System !D combines the branches by joining the heaps Î£ 4 and Î£ 6 , producing Î£ 7 that describes the heap no matter which branch is taken. The dereference on line 8 retrieves x â² , a value of type {ite Num(x) Num(Î½) Bool (Î½)}, as required by the return type annotation.</p><p>In this way, System !D syntactically tracks strong updates to the heap, while reducing subtyping obligations to implication queries in an ordinary, pure refinement logic <ref type="bibr" target="#b8">[9]</ref> that does not model imperative updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Simple Objects</head><p>JavaScript's objects exhibit several interesting semantic properties. Consider the following object initialized with a single key (also known as field or property). We assume that assert is a pre-defined function that aborts when its argument is falsy; JavaScript does not provide such a function as built-in, but it is trivial to define. var x = {"f": 1}; assert (x.f == 1 &amp;&amp; x.g == undefined); x.g = 2; delete x.f; assert (x.g == 2 &amp;&amp; x.f == undefined); x.f.g; // raises exception var k = "h"; x[k] = 3; assert (x[k] == 3);</p><p>Notice that when retrieving the non-existent "g" key from x, JavaScript returns undefined as opposed to raising an exception. Attempting to retrieve a key from undefined, or null, however, does raise an exception. Keys can be added or removed to objects, and can even be arbitrary dynamically-computed values, not just string literals, that are converted to strings if necessary. Dynamic keys are pervasive -objects are commonly used as hash tables with unknown sets of keys -but they are quite challenging to track inside a static type system. Nested Refinements. To support dynamic keys, we adopt the System D primitives <ref type="bibr" target="#b8">[9]</ref> for (functional) dictionary operations, shown in the first four lines of the file objects.dref (Figure <ref type="figure">5</ref>). The primitive function application get d k re-trieves the key k from dictionary d, where sel (d, k) describes the exact binding as a value in the refinement logic; set d k y produces a new dictionary that extends d with a binding for k, shadowing previous bindings, if any, where upd (d, k, y) describes the new dictionary; del d k produces a new dictionary with a binding removed, using the logical symbol bot (distinct from all source-level values) to denote its absence; and mem d k indicates the presence or absence of a binding, where we write the abbreviation has(d, k)</p><formula xml:id="formula_4">â = sel (d, k) â  bot.</formula><p>The key innovation of nested refinements in System D allows syntactic type terms U (like function types) to be written within refinement formulas using an uninterpreted "has-type" predicate x â¶â¶ U , while staying within the decidable McCarthy theory of arrays <ref type="bibr" target="#b26">[27]</ref>. The has-type predicate allows System D to describe dictionaries that map dynamic keys to arbitrary values. For example, we write {Dict(Î½) â§ sel (Î½, k) â¶â¶ Bool â Bool } to describe a dictionary d with key k that binds a boolean-to-boolean function, and {Î½ = upd (d, "g", 4)} to describe a dictionary d â² that is just like d but with an additional binding. Prior approaches such as <ref type="bibr" target="#b4">[5]</ref> were limited to dynamic keys that store first-order (non-function) values. We refer the reader to <ref type="bibr" target="#b8">[9]</ref> for the technical development of nested refinements.</p><p>Mutability and Dynamic Keys. The combination of nested refinements and strong updates allows us to precisely track objects with dynamic keys despite the presence of imperative updates. Consider the desugaring of our example above; we omit the assertions for clarity.</p><p>ï± let _x = ref (ref {"f": 1}) in ï² _x := set (deref (deref _x)) "g" 2;</p><p>ï³ _x := del (deref (deref _x)) "f"; ï´ let _k = "h" in ïµ _x := set (deref (deref _x)) ï¶ (coerceToStr (deref _k)) 3;</p><p>The allocation on line 1 adds three bindings to the type environment -dâ¶{Î½ = upd (empty, "f", 1)}, ptr â¶Ref , and objâ¶Ref â² , where and â² are fresh locationsand produces the heap</p><formula xml:id="formula_5">Î£ 1 â = ( â² â¦ ptr ) â ( â¦ d).</formula><p>Notice that the dictionary is stored via an additional level of indirection to facilitate the encoding of side-effecting JavaScript object operations. The object extension on line 2 adds d â² â¶{Î½ = upd (d, "g", 2)} to the type environment and strongly updates the heap to</p><formula xml:id="formula_6">Î£ 2 â = ( â² â¦ ptr ) â ( â¦ d â² ).</formula><p>The deletion on line 3 and the extension on line 5 (through a dynamic key) have similar effects on the static heap, thereby statically verifying the assertions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Function Types</head><p>In order to fully understand the challenges of JavaScript objects, we must pause to take a closer look at function types. The function types we have seen so far -for negate and the primitives in basics.dref -have not mentioned</p><formula xml:id="formula_7">val set :: (* d â¶ Dict â k â¶ Str â y â¶ Top â {Î½ = upd (d, k, y)} *) val del :: (* d â¶ Dict â k â¶ Str â {Î½ = upd (d, k, bot)} *) val has :: (* d â¶ Dict â k â¶ Str â {Î½ iff has(d, k)} *) val get :: (* d â¶ Dict â k â¶ Str â {ite has(d, k) (Î½ = sel (d, k)) (Î½ = undefined)} *) val setPropObj :: (* (x â¶ Ref , k â¶ Str , y â¶ Top) (x â¦ â¨d â¶ Dict, áºâ©) â {Î½ = y} (x â¦ â¨d â² â¶ {Î½ = upd (d, k, y)}, áºâ©) *) val delPropObj :: (* (x â¶ Ref , k â¶ Str ) (x â¦ â¨d â¶ Dict, áºâ©) â Bool (x â¦ â¨d â² â¶ {Î½ = upd (d, k, bot)}, áºâ©) *) val hasPropObj :: (* (x â¶ Ref , k â¶ Str ) (x â¦ â¨d â¶ Dict, áºâ©) â {Î½ iff ObjHas(d, k, cur , áº)} same *) val getPropObj :: (* (x â¶ Ref , k â¶ Str ) (x â¦ â¨d â¶ Dict, áºâ©) â {ite ObjHas(d, k, cur , áº) (Î½ = ObjSel (d, k, cur , áº)) (Î½ = undefined)} same *)</formula><p>val getIdxArr ::</p><formula xml:id="formula_8">(* âA. (x â¶ Ref , i â¶ Int) (x â¦ â¨a â¶ Arr (A), áºâ©) â {ite Â¬packed (a) (Î½ â¶â¶ A â¨ Undef (Î½)) (ite (0 â¤ i &lt; len(a)) (Î½ â¶â¶ A) (Undef (Î½)))} same *) val getLenArr :: (* âA. (x â¶ Ref , k â¶ {Î½ = "length"}) (x â¦ â¨a â¶ Arr (A), áºâ©) â {ite packed (a) (Î½ = len(a)) Int(Î½)} same *) val getPropArr :: (* âA. (x â¶ Ref , k â¶ {Str (Î½) â§ Î½ â  "length"}) (x â¦ â¨a â¶ Arr (A), áºâ©) â {ite HeapHas(H, áº, k) (Î½ = HeapSel (H, áº, k)) (Î½ = undefined)} same *)</formula><p>val getElem :: (and (type getPropObj) (type getIdxArr) (type getLenArr) (type getPropArr))</p><p>val setIdxArr ::</p><formula xml:id="formula_9">(* âA. (x â¶ Ref , i â¶ Int, y â¶ A) (x â¦ â¨a â¶ Arr (A), áºâ©) â {Î½ = y} (x â¦ â¨a â² â¶ {Î½ â¶â¶ Arr (A) â§ arrSet(Î½, a, i)}, áºâ©) *)</formula><p>Figure <ref type="figure">5</ref>. Excerpt from objects.dref heaps, because their inputs and outputs are scalar values. However, JavaScript objects are reference values, and are passed to and returned from functions through the heap. Thus, to account for heaps and side-effects, a System !D function type has the following form.</p><formula xml:id="formula_10">â[A; L; H] x1 â¶ T1 Î£1 â x2 â¶ T2 Î£2</formula><p>This type describes a function that, given an argument x 1 of type T 1 in a calling context that satisfies the input heap type Î£1 , produces an output value x 2 of type T 2 and a modified heap type Î£2 . A function type can be parameterized by sequences of type variables A, location variables L, and heap variables H. A heap type Î£ is like a heap environment Î£ but maps locations to binder-type pairs rather than values (e.g., ( â¦ y â¶T ) rather than ( â¦ v)); the binders name the values stored in the heap before and after a function call. The binder x 1 and all of the binders in the input heap Î£1 are in scope in the output world x 2 â¶T 2 Î£2 . Intuitively, a world describes a tuple where every component except the first resides in a heap. We often omit binders when they are not referred to. To match the structure of function types, function applications must instantiate type, location, and heap variables. However, our implementation infers instantiations in almost all cases using standard local type inference techniques ( Â§ 6). When we write DJS examples in the sequel, we omit instantiations at applications wherever our current implementation infers them. We sweeten function type syntax with some sugar:</p><p>â¢ When used as an output heap, the token same refers to the sequence of locations in the corresponding input heap, where each binding records that the final value is exactly equal to the initial value.</p><p>â¢ In an input world, a reference binding xâ¶Ref without a location introduces a location variable L that is quantified by the type, and x (a value of type Ref L) can be used as a location in heaps to refer to this variable L. Further, the dotted variable áº introduces a location parameter, corresponding to the prototype of x.</p><p>â¢ A heap variable H is implicitly added to a function type when it contains none, and H is added to both the input and output heaps; this variable corresponds to the "frame" from separation logic <ref type="bibr" target="#b16">[17]</ref>. In this case, the token cur refers to H.</p><p>For example, compare the type for hasPropObj (Figure <ref type="figure">5</ref>) followed by its expansion.</p><formula xml:id="formula_11">(x â¶ Ref , k â¶ Str ) (x â¦ â¨d â¶ Dict, áºâ©) â {Î½ iff ObjHas(d, k, cur , áº)} same âL, L â² , H. (x â¶ Ref L, k â¶ Str ) H â (L â¦ â¨d â¶ Dict, L â² â©) â {Î½ iff ObjHas(d, k, H, L â² )} H â (L â¦ â¨d â² â¶ {Î½ = d}, L â² â©)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Prototype-Based Objects</head><p>JavaScript sports a special form of inheritance, where each base object is equipped with a link to its prototype object. This link is set when the base object is created and cannot be changed or accessed by the program. When trying to retrieve a key k not stored in an object x itself, JavaScript transitively searches the prototype chain of x until it either finds k or it reaches the root of the object hierarchy without finding k.</p><p>The prototype chain does not play a role in the semantics of key update, addition, or deletion. <ref type="foot" target="#foot_0">1</ref>For example, consider the initially empty object child created by the function beget (described in the sequel) with prototype object parent. The prototype of object literals, like parent, is the object stored in Object.prototype (note that the "prototype" key of Object is not the same as its prototype object). Thus, all keys in parent and Object.prototype are transitively accessible via child.</p><p>var parent = {"last": " Doe"}; var child = beget(parent); child.first = "John"; assert (child.first + child.last == "John Doe"); assert ("last" in child == true); assert (child.hasOwnProperty("last") == false);</p><p>The JavaScript operator k in x tests for the presence of k anywhere along the prototype chain of x, whereas the native function Object.prototype.hasOwnProperty tests only the "own" object itself. Keys routinely resolve through prototypes, so a static type system must precisely track them. Unfortunately, we cannot encode prototypes directly within the framework of refinement types and strong update, as the semantics of transitively traversing mutable and unbounded prototype hierarchies is beyond the reach of decidable, firstorder reasoning.</p><p>Shallow and Deep Heaps. We solve this problem by syntactically reducing reasoning about prototype-based objects to the refinement logic. Our key insight is to decompose the heap into a "shallow" part, the bounded portion of the heap for which we have explicit locations, and a "deep" part, which is the potentially unbounded portion which we can represent by uninterpreted heap variables H. We explicitly track prototype links in the "shallow" heap by using bindings of the form ( â¦ â¨d, â² â©), where the prototype of the object at is stored at â² . We cannot track prototype links explicitly in the "deep" heap, so instead we summarize information about deep prototype chains by using the abstract (uninterpreted) heap predicate HeapHas(H, , k) to encode the proposition that the object stored at location in H transitively has the key k, and the abstract (uninterpreted) heap function HeapSel (H, , k) to represent the corresponding value retrieved by lookup.</p><p>As an example, recall the child object and its prototype parent. Suppose that the prototype of parent is an unknown object grandpa, rather than Object.prototype as written. If child, parent, and grandpa are stored at locations 1 , 2 , and 3 with underlying "own" dictionary values d 1 , d 2 , and d 3 , then we write the heap</p><formula xml:id="formula_12">{ 1 â¦ â¨d 1 , 2 â©, 2 â¦ â¨d 2 , 3 â©, 3 â¦ â¨d 3 , 4 â©</formula><p>, H} -we use set notation to abbreviate the concatenation of heap bindings with â. Despite not knowing what value is the prototype of grandpa, we name its location 4 that is somewhere in the deep part of the heap H. Key Membership and Lookup. When describing simple objects, we used the original System D primitives (mem and get) to desugar key membership and lookup operations. But in fact, to account for the transitive semantics of key membership and lookup facilitated by prototype links, System !D uses new primitives hasPropObj and getPropObj defined in objects.dref (Figure <ref type="figure">5</ref>). These primitives differ from their purely functional System D counterparts in two ways: each operation goes through a reference to a dictionary on the heap, and the abstract predicates ObjHas and ObjSel are used in place of has and sel . These abstract predicates are defined over the disjoint union of the shallow and deep heaps as follows and, intuitively, summarize whether an object transitively has a key and, if so, the value it binds.</p><formula xml:id="formula_13">ObjHas(d, k, H, áº) â = has(d, k) â¨ HeapHas(H, áº, k) Î½ = ObjSel (d, k, H, áº) â = if has(d, k) then Î½ = sel (d, k) else Î½ = HeapSel (H, áº, k)</formula><p>Transitive Semantics via Unrolling. Let us return to the example of the child, parent and grandpa prototype chain to understand how unrolling captures the semantics of transitive lookup. The DJS key membership test on the left desugars to System !D on the right as follows.</p><p>k in child hasPropObj (deref _child, deref _k)</p><p>The result of the function call has the following type.</p><formula xml:id="formula_14">{Î½ iff ObjHas(d1, k, {( 2 â¦ â¨d2, 3â©), ( 3 â¦ â¨d3, 4â©), H}, 2)}</formula><p>We expand this type by unrolling ObjHas to the following.</p><formula xml:id="formula_15">{Î½ iff has(d1, k) â¨ has(d2, k) â¨ has(d3, k) â¨ HeapHas(H, 4, k)}</formula><p>The first three disjuncts correspond to looking for k in the shallow heap, and the last is the uninterpreted predicate that summarizes whether k exists in the deep heap. Similarly, key lookup in DJS on the left is desugared as follows.</p><formula xml:id="formula_16">child[k] getPropObj (deref _child, deref _k)</formula><p>We unroll the type of the System !D expression as follows.</p><formula xml:id="formula_17">{if has(d1, k) then Î½ = sel (d1, k) else if has(d2, k) then Î½ = sel (d2, k) else if has(d3, k) then Î½ = sel (d3, k) else ite HeapHas(H, 4, k) (Î½ = HeapSel (H, 4, k)) Undef (Î½)}</formula><p>Thus, our technique of decomposing the heap into shallow and deep parts, followed by heap unrolling, captures the exact semantics of prototype-based object operations modulo the unknown portion of the heap. Thus, System !D precisely tracks objects in the presence of mutation and prototypes.</p><formula xml:id="formula_18">var __hasOwn = /*: (this â¶ Ref , k â¶ Str ) (this â¦ â¨d â¶ Dict, á¹«hisâ©) â {Î½ iff has(d, k)} same â§ âA. (this â¶ Ref , i â¶ Int) (this â¦ â¨a â¶ Arr (A), á¹«hisâ©) â {ite packed (a) (Î½ iff 0 â¤ i &lt; len(a)) Bool (Î½)} same â§ âA. (this â¶ Ref , k â¶ Str ) (this â¦ â¨a â¶ Arr (A), á¹«hisâ©) â {Î½ iff k = "length"} same */ "#extern";</formula><p>function Object() { ... }; Object.prototype = {"hasOwnProperty": __hasOwn, "constructor": Object, ... };</p><formula xml:id="formula_19">var __push = /*: âA. (this â¶ Ref , x â¶ A) (this â¦ â¨a â¶ Arr (A), á¹«hisâ©) â Int (this â¦ â¨a â² â¶ {Î½ â¶â¶ Arr (A) â§ arrSize(Î½, a, 1)}, á¹«hisâ©) */ "#extern"; var __pop = /*: âA. (this â¶ Ref , x â¶ A) (this â¦ â¨a â¶ Arr (A), á¹«hisâ©) â {ite packed (a) (Î½ â¶â¶ A) (Î½ â¶â¶ A â¨ Undef (Î½))} (this â¦ â¨a â² â¶ {Î½ â¶â¶ Arr (A) â§ arrSize(Î½, a, -1)}, á¹«hisâ©) */ "#extern";</formula><p>function Array() { ... }; Array.prototype = {"push": __push, "pop": __pop, "constructor": Array, ... };</p><p>Figure <ref type="figure">6</ref>. Excerpt from prelude.js, which desugars to the prelude.dref file in the standard prelude Additional Primitives. The new update and deletion primitives setPropObj and delPropObj (Figure <ref type="figure">5</ref>) affect only the "own" object, since the prototype chain does not participate in the semantics. We model native JavaScript functions like Object.prototype.hasOwnProperty with type annotations in the file prelude.js (Figure <ref type="figure">6</ref>). Notice that the function type for objects (the first in the intersection) checks only the "own" object for the given key.</p><p>Constructors. JavaScript provides the expression form new Foo(args) as a second way of constructing objects, in addition to object literals whose prototypes are set to Object.prototype. The semantics are straightforward, but quite different than the traditional new syntax suggests.</p><p>Here, if Foo is any function (object), then a fresh, empty object is created with prototype object Foo.prototype, and Foo is called with the new object bound to this (along with the remaining arguments) to finish its initialization. We desugar constructors and new with standard objects and functions (following Î» JS <ref type="bibr" target="#b20">[21]</ref>) without adding any special System !D constructs or primitive functions.</p><p>Inheritance. Several inheritance relationships, including ones that simulate traditional classes, can be encoded with the construction mechanism, as shown in the popular book JavaScript: The Good Parts <ref type="bibr" target="#b9">[10]</ref>. Here, we examine the prototypal pattern, a minimal abstraction which wraps construction to avoid the unusual syntax and semantics that leads to common errors; we discuss the rest in Â§ 6. The function beget (the basis for Object.create in ES5) returns a fresh empty object with prototype o.</p><formula xml:id="formula_20">ï± /*: âL. o â¶ Ref (o â¦ â¨d â¶ Dict, È¯â©) ï² â Ref L (L â¦ â¨{Î½ = empty}, oâ©) â (o â¦ same) */ ï³ function beget(o) { ï´ /*: #ctor this â¶ Ref â {Î½ = this} */ ïµ function F() { return this; }; ï¶ F.prototype = o; ï· return new /*:L*/ F(); }</formula><p>The #ctor on line 4 instructs desugaring to: initialize the function object with a "prototype" key that stores an empty object literal (since it will be called as a constructor); and expand the type annotation as follows to require that this initially be empty, as is common for all constructors.</p><formula xml:id="formula_21">this â¶ Ref (this â¦ â¨{Î½ = empty}, á¹«hisâ©) â {Î½ = this} same</formula><p>The assignment on line 6 strongly updates Foo.prototype (overwriting its initial empty object) with the argument o. Thus, the object constructed (at location L) on line 7 has prototype o, so beget has the ascribed type. In most cases, new can be used without a location annotation and a fresh one is chosen. In this case, we annotate line 7 with L (from the type of beget), which our implementation does not infer because there is no input corresponding to L.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Arrays</head><p>The other workhorse data structure of JavaScript is the array, which is really just an object with integer "indices" converted to ordinary string keys. However, arrays pose several tricky challenges as they are commonly used both as finite tuples as well as unbounded collections. As for any object, retrieving a non-existent key returns undefined rather than raising an "out-of-bounds" exception. Like other objects, arrays are extensible simply by writing "past the end." Array literal objects have prototype Array.prototype, which includes a push (resp. pop) function for adding an element to (resp. removing an element from) the end of an array. Loops are used to iterate over arrays of unknown size. But since lookups may return undefined, it is important to track when an access is "in-bounds." JavaScript bestows upon arrays an unusual "length" property, rather than a method, to help. Reading it returns the largest integer key of the array, which is not necessarily its "size" because it may contain "holes" or even non-integer keys. Furthermore, assigning a number n to the "length" of an array either truncates it if n is less than its current length, or extends it (by padding with holes) if it is greater. Despite the unusual semantics, programmers commonly use arrays as if they are traditional "packed" arrays with integer "indices" zero to "size" minus one. The type system must reconcile this discrepancy.</p><p>Array Types. We introduce a new syntactic type term Arr (T ) and maintain the following four properties for every value a that satisfies the has-type predicate a â¶â¶ Arr (T ). We refer to strings that do not coerce to integers as "safe," and we use an uninterpreted predicate safe to describe such strings (e.g., safe("foo") whereas Â¬safe("17")).</p><p>(A1) a contains the special "length" key. (A2) All other "own" keys of a are (strings that coerce to) integers.</p><p>(A3) For all integers i, either a maps the key i to a value of type T , or it has no binding for i.</p><p>(A4) All inherited keys of a are safe (i.e., non-integer) strings.</p><p>An array can have arbitrary objects in its prototype chain, so to ensure (A4), we require that all non-array objects bind only safe strings. This sharp distinction between between array objects (that bind integer keys) and non-array objects (that bind safe string keys) allows System !D to avoid reasoning about string coercions, and does not significantly limit expressiveness because, in our experience, programs typically conform to this division anyway. To enforce this restriction, the type for keys manipulated by primitives in objects.dref and prelude.js is actually SafeStr , rather than Str as shown in Figure <ref type="figure">5</ref> and Figure <ref type="figure">6</ref>, where SafeStr â = {Str (Î½) â§ safe(Î½)}. We discuss an alternative approach in Â§7 that allows non-array objects to bind unsafe strings.</p><p>Packed Arrays. Arrays a that additionally satisfy the uninterpreted predicate packed (a) enjoy the following property, where len(a) is an uninterpreted function symbol.</p><p>(A5) For all integers i, if i is between zero and len(a) minus one, then a maps i to a value of type T . Otherwise, a has no binding for i.</p><p>Tuple Arrays. Using additional predicates, System !D gives precise types to array literals, which are often used as finite tuples in idiomatic code. For example, we can describe pairs as follows:</p><formula xml:id="formula_22">(Int, Int) â = {Î½ â¶â¶ Arr (Int) â§ packed (Î½) â§ len(Î½) = 2} (Bool , Str ) â = {Î½ â¶â¶ Arr (Top) â§ packed (Î½) â§ len(Î½) = 2 â§ Str (sel (Î½, 0)) â§ Bool (sel (Î½, 1))}</formula><p>Thus, the technique of nested refinements allows us to smoothly reason about arrays both as packed homogeneous collections as well as heterogeneous tuples.</p><p>Array Primitives. We define several array-manipulating primitives in objects.dref (some of which we show in Figure <ref type="figure">5</ref>) that maintain and use the array invariants above. For key lookup on arrays, we define three primitives: getIdxArr looks for the integer key i on the own object a and ignores the prototype chain of a because (A4) guarantees that a will not inherit i, and returns a value subject to the properties (A3) and (A5) that govern its integer key bindings; getLenArr handles the special case when the string key k is "length", which (A1) guarantees is bound by a, and returns the the true length of the array only if it is packed; and getPropArr deals with all other (safe) string keys k by reading from the prototype chain of the array (re-using the heap unrolling mechanism) ignoring its own bindings because of (A2).</p><p>For array updates, we define setIdxArr that uses the following macros to preserve packedness (A5) when possible.</p><formula xml:id="formula_23">arrSet(a â² , a, i) â = if 0 â¤ i &lt; len(a) then arrSize(a â² , a, 0) else if i = len(a) then arrSize(a â² , a, 1) else true arrSize(a â² , a, n) â = packed (a) â (packed (a â² ) â§ len(a â² ) = len(a) + n)</formula><p>In particular, the updated array a â² is packed if: (1) the original array a is packed; and (2) the updated index i is either within the bounds of a (in which case, the length of a â² is the same as a) or just past the end (so the length of a â² is one greater than a). In similar fashion, we specify the remaining primitives for update and deletion to maintain the array invariants, and the ones for key membership to use them, but we do not show them in Figure <ref type="figure">5</ref>.</p><p>In prelude.js (Figure <ref type="figure">6</ref>), we use precise types to model the native push and pop methods of Array.prototype (which maintain packedness, as above), as well as the behavior of Object.prototype.hasOwnProperty on arrays (the last two cases of the intersection type). Thus, the precise dependent types we ascribe to array-manipulating operations maintain invariants (A1) through (A5) and allow DJS to precisely track array operations.</p><p>Desugaring. It may seem that we need to use separate primitive functions for array and non-array object operations, even though they are syntactically indistinguishable in JavaScript. Nevertheless, we are able to desugar DJS based purely on expression syntax (and not type information) by unifying key lookup within a single primitive getElem and giving it a type that is the intersection of the (three) array lookup primitives and the (one) non-array lookup primitive getPropObj. We define getElem in Figure <ref type="figure">5</ref>, where we specify the intersection type using and and type as syntactic sugar to refer to the previous type annotations. We define similar unified primitives for setElem, hasElem, and delElem (not shown in Figure <ref type="figure">5</ref>). Desugaring uniformly translates object operations to these unified general primitives, and type checking of function calls ensures that the appropriate cases of the intersection type apply.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Collections</head><p>As discussed in Â§2.2, strong updates are sound only for references that point to exactly one object, which is far too restrictive as real programs manipulate collections of objects. In this section, we describe weak references in DJS to refer to multiple objects, a facility that enables programming with arrays of mutable objects as well as recursive types.</p><p>Weak References. In the following example, we iterate over an array of passenger objects and compute the sum of their weights; we use a default value max_weight when a passenger does not list his weight (ignore the unfamiliar annotations for now). We could describe the array passengers with the type Ref for a location . However, this type is not very useful as it denotes an array of references to a single object.</p><p>Weak Locations. To refer to an arbitrary number (zero or more) objects of the same type, we adopt the Alias Types <ref type="bibr" target="#b31">[32]</ref> solution, which categorizes some locations as weak to describe an arbitrary number of locations that satisfy the same type, and syntactically ensures that weak locations are weakly updated.</p><p>We introduce a new kind of heap binding ( Ë â¦ â¨T, â² â©), where Ë is a weak location, all objects that might reside there satisfy T , and â² is the strong location of the prototype of all objects that reside at location Ë . There is no heap binder for weak locations since there is not a single value to describe.</p><p>In our example, we can use ( Ë pass â¦ â¨T pass , op â©) to describe passenger objects, where op is the location of Object.prototype and T pass is the dictionary type {Dict(Î½)â§has(Î½, "weight") â Num(sel (Î½, "weight"))}. If we assign the type {Î½ â¶â¶ Arr (Ref Ë pass ) â§ packed (Î½)}, to passengers, then p has type Ref Ë pass , and thus each (desugared) use of p is a dictionary of type T pass . This type is quite unsatisfying, however, because the conditional establishes that along the then-branch, p does possess the key and therefore should be assigned the more precise type {Num(sel (d, "weight"))}. Thaw and Freeze. To solve this problem, we adopt a mechanism found in derivatives of Alias Types (e.g., <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b30">31]</ref>) that allows a weak location to be temporarily treated as strong. A weak location Ë is said to be frozen if all references Ref Ë use the location only at its weak (invariant) type. The type system can thaw a location, producing a strong reference Ref k (with a fresh name) that can be used to strongly update the type of the cell. While a location is thawed, the type system prohibits the use of weak references to the location, and does not allow further thaw operations. When the thawed (strong) reference is no longer needed, the type system checks that the original type has been restored, re-freezes the location, and discards the thawed location. Soundness of the approach depends on the invariant that each weak location has at most one corresponding thawed location at a time.</p><p>In our example, we do not need to temporarily violate the type of p, but the thaw/freeze mechanism does help us relate the two accesses to p. The thaw state annotation above the loop declares that before each iteration of the loop (including the first one), the location Ë pass must be frozen. The thaw annotation on line 4 changes the type of p to a strong reference to a fresh thawed location 1 , which stores a particular dictionary on the heap (named with a binder) that is retrieved by both subsequent uses of p. Thus, we can relate the key membership test to the lookup, and track that p.weight produces a number. The freeze annotation on line 7 restores the invariant required before the next iteration. We describe this technique further in Â§4.</p><p>Recursive Types. We reuse the weak location mechanism to describe recursive data structures. Consider the following adapted from the SunSpider <ref type="bibr" target="#b33">[34]</ref> benchmark access-binary-trees.js, annotated in DJS. The source-level macro on line 1 introduces T tn to abbreviate the type of TreeNodes, using traditional record type syntax instead of the underlying McCarthy operators. Line 2 defines the weak location for TreeNodes, using the predictable location tnp created by desugaring for the object TreeNode.prototype. The constructor annotation itself declares that the return type is a reference to one of these recursive objects, which System !D verifies by checking that on line 6 the appropriate fields are added to the strong, initially-empty object this before it is frozen and returned.</p><p>Recursive Traversal. There are two differences in the itemCheck function above compared to the original version, which cannot be type checked in DJS. First, we name the function being defined (notice the f on line 11), a JavaScript facility for recursive definitions. Second, we write f.apply(this.r) instead of this.r.itemCheck() as in the original, where the native JavaScript function apply allows a caller to explicitly supply a receiver argument. The trouble with the original call is that it goes through the heap (in particular, the prototype chain of this) to resolve the recursive function being defined. This function will be stored in a strong object, and we have no facility (e.g., mu-types) for strong objects with recursive types; our only mechanism is for weak objects. If we write f.apply(this.r), however, the recursive function f is syntactically manifest, and we can translate the definition with a call to the standard fix primitive (Figure <ref type="figure">2</ref>). In Â§5, we describe how we handle a limited form of apply that is sufficient for our idiomatic recursive definitions in DJS. We expect that we can add a more powerful mechanism for recursive types that supports the original code as written, but we leave this to future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.8">Rest of the Paper</head><p>We have now completed our tour of Dependent JavaScript. Next, we formally define the syntax of System !D in Â§ 3 and the type system in Â§ 4. In, Â§ 5, we present the syntax of DJS and its desugaring to System !D. We discuss our implementation and results in Â§6, directions for future work in Â§ 7, and related work in Â§ 8. Additional details may be found in an accompanying technical report <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Syntax and Semantics of System !D</head><p>We now introduce the formal syntax of values, expressions, and types of System !D, defined in Figure <ref type="figure">7</ref>.</p><p>Values. Values v include variables x, constants c, lambdas Î»x. (functional) dictionaries v 1 ++ v 2 â¦ v 3 , and run-time heap locations r. The set of constants c includes base values (numbers, booleans, strings, the empty dictionary {}, null, undefined, NaN, etc.) and the primitive functions from basics.dref and objects.dref (typeof, get, getElem, etc.). We use tuple syntax (v 0 , . . ., v n ) as sugar for the dictionary with fields "0" through "n" bound to the component values. Logical values w are all values and applications of primitive function symbols F , such as addition + and dictionary selection sel , to logical values.</p><p>Expressions. We use an A-normal expression syntax so that we need only define substitution of values (not arbitrary expressions) into types. We use a more general syntax for examples throughout this paper, and our implementation desugars expressions into A-normal form. Expressions e include values, function application, if-expressions, and letbindings. The ascription form e as T allows source-level type annotations. Since function types will be parameterized by type, location, and heap variables, the syntax of function application requires that these be instantiated. Reference operations include reference allocation, dereference, and update, and the run-time semantics maintains a separate heap that maps locations to values. The expression newobj v v â² stores the value v at a fresh location r -where the name is a compile-time abstraction of a set of run-time location names that includes r -with its prototype link set to v â² , which should be a location. The thaw v operation converts a weak reference to a strong strong one; freeze Ë Î¸ v converts a strong reference to a weak one, where thaw state Î¸ is used by the type system for bookkeeping.</p><p>The operational semantics is standard, based on Î» JS with minor differences. For example, we make prototype links manifest in the syntax of heaps (to facilitate heap unrolling in the type system), whereas Î» JS stores them inside objects in a distinguished " proto " field. We refer the reader to <ref type="bibr" target="#b20">[21]</ref> for the full details.</p><p>Types and Formulas. Values in System !D are described by refinement types of the form {x p} where x may appear free in the formula p and existential types âxâ¶T . S where x may appear free in S. Rather than introduce additional syntactic categories, we assume, by convention, that existential types do not appear in source programs; they are created only during type checking in a controlled fashion that does not preclude algorithmic type checking <ref type="bibr" target="#b24">[25]</ref>. When the choice of refinement binder does not matter, we write {p} as shorthand for {Î½ p}.</p><p>The language of refinement formulas includes predicates P , such as equality and the dictionary predicate has, and the usual logical connectives. Similar to the syntax for expression tuples, we use (T 1 , . . ., T n ) as sugar for the dictionary type with fields "0" through "n" with the corresponding types. As in System D, we use an uninterpreted hastype predicate w â¶â¶ U in formulas to describe values that have complex types, represented by type terms U , which includes function types, type variables, null, reference, and array types. A reference type names a strong or weak location in the heap, where a strong location is either a constant a or a variable L and a weak location Ë is a constant Ã£. We discussed function types in Â§ 2.4; now we use the metavariable W to range over worlds. A world xâ¶T Î£ describes the binders and types of a tuple of values, where every component except the first (x of type T ) resides in the heap Î£.</p><p>Heap Types. A heap type Î£ is an unordered set of heap variables H and heap bindings Ä¥ concatenated with the â operator. To simplify the presentation, we syntactically require that each heap has exactly one heap variable, so we write a heap type as the pair (H, Ä¥), where H is the "deep" part for which we have no information and Ä¥ is the "shallow" part for which have precise location information. The heap binding ( â¦ xâ¶T ) represents the fact that the value at location has type T ; the binder x refers to this value in the types of other heap bindings. The binding ( â¦ â¨xâ¶T , â² â©) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Type Checking</head><p>In this section, we discuss the well-formedness, typing, and subtyping relations of System !D. The type system reuses the System D <ref type="bibr" target="#b8">[9]</ref> subtyping algorithm to factor subtyping obligations between a first-order SMT solver and syntactic subtyping rules. The novel technical developments here are: the formulation of flow-sensitive heap types in a dependent setting; the use of uninterpreted heap symbols to regain precision in the presence of imperative, prototype-based objects; the encoding of array primitives to support idiomatic use of JavaScript arrays; and the use of refinement types to assign precise types to JavaScript operators.</p><p>Environments. The type checking relations make use of type environments Î and heap environments Î£.</p><formula xml:id="formula_24">Î â¶â¶= â Î, x â¶ T Î, p Î, A Î, L Î, H Î, ( Ë â¦ â¨T, â©) Î£ â¶â¶= (H, h) h â¶â¶= â h1 â h2 ( â¦ v) ( â¦ â¨v, â² â©) ( Ë â¦ Î¸)</formula><p>A type environment binding records either: the derived type for a variable; a formula p to track control flow along a conditional branch; a polymorphic variable introduced by a function type; or the description of a weak location (which does not change flow-sensitively), namely, that every object stored at Ë satisfies type T and has prototype link . A heap environment is just like a heap type, except a strong location binds the value v it stores (as opposed to the type of v).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Well-Formedness</head><p>As usual in a refinement type system, we define wellformedness relations (see <ref type="bibr" target="#b6">[7]</ref>) that govern how values may be used inside formulas. The key intuition is that formulas are boolean propositions and mention only variables that are currently in scope. Locations in a heap type Î£ must either be location constants or location variables bound by the type environment, and may not be bound multiple times. All heap binders may refer to each other. Thus, the values in a heap can be regarded as a dependent tuple. For the input world x 1 â¶T 1 Î£1 of a function type, the binder x 1 and the binders in Î£1 may appear in the output world W 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Subtyping</head><p>Several relations (see Figure <ref type="figure">8</ref> and <ref type="bibr" target="#b6">[7]</ref>) comprise subtyping.</p><p>Subtyping and Implication. As in System D, subtyping on refinement types reduces to implication of refinement formulas, which is discharged by a combination of uninterpreted, first-order reasoning and syntactic subtyping. Our treatment of existential types follows the algorithmic (decidable) approach in <ref type="bibr" target="#b24">[25]</ref>. In particular, when on the left side of an obligation, the S-EXISTS rule adds the existential binding to the environment; there is no support for existentials on References and Arrays. As in Alias Types <ref type="bibr" target="#b31">[32]</ref>, we enforce the invariant that distinct strong locations do not alias, so references to them are never related by subtyping. In contrast, weak locations describe zero or more locations, and it is safe to treat null as a subtype of any weak location (U-NULL). That is, weak references are nullable but strong ones are not. Arrays are invariant in their type parameter (U-ARRAY), as usual, but can be related with additional predicates. For example, {Î½ â¶â¶ Arr (Int)â§len(Î½) = 2} is a subtype of {Î½ â¶â¶ Arr (Int)}.</p><formula xml:id="formula_25">Subtyping Î â¢ T1 â T2 [S-REFINE] y fresh Î, p[y x] â q[y x] Î â¢ {x p} â {x q} [S-EXISTS] Î, x â¶ T â¢ S1 â S2 Î â¢ âx â¶ T . S1 â S2 Syntactic Subtyping (selected rules) Î â¢ U1 &lt;â¶ U2 [U-ARRAY] Î â¢ Arr (T ) &lt;â¶ Arr (T ) [U-VAR] Î â¢ A &lt;â¶ A [U-STRONGREF] Î â¢ Ref &lt;â¶ Ref [U-NULL] Î â¢ Null &lt;â¶ Ref Ë [U-WEAKREF] Î â¢ Ref Ë &lt;â¶ Ref Ë Figure 8. Subtyping for System !D Value Typing (selected rules) Î; Î£ â¢ v â¶â¶ T [T-CONST] Î; Î£ â¢ c â¶â¶ ty(c) Î(x) = S Î; Î£ â¢ x â¶â¶ {y y = x} [T-VAR] [T-FUN] U = â[A; L; H] x â¶ T1 Î£1 â W2 Î â¢ U HeapEnv( Î£1) = (z â¶ S, Î£1) Î1 = Î, A, L, H, x â¶ T1, z â¶ S Î1; Î£1 â¢ e â¶â¶ T2 Î£2 Î1 â¢ T2 Î£2 â§ W2 Î; Î£ â¢ Î»x. e â¶â¶ {y y â¶â¶ U }</formula><p>Heaps. The heap subtyping judgement (defined in <ref type="bibr" target="#b6">[7]</ref>) relates two heap types (H 1 , Ä¥1 ) and (H 2 , Ä¥2 ) if: (1) the heaps agree on the "deep" part, that is, if</p><formula xml:id="formula_26">H 1 = H 2 ;</formula><p>(2) the structure of the "shallow" parts Ä¥1 and Ä¥2 match modulo permutation; and (3) the heap bindings in Ä¥1 and Ä¥2 , which can be thought of as dependent tuples, are related by subtyping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Value Typing</head><p>The value typing judgement Î; Î£ â¢ v â¶â¶ T (defined in Figure <ref type="figure" target="#fig_5">9</ref> and <ref type="bibr" target="#b6">[7]</ref>) verifies that the value v has type T in the given environments. Since values do not produce any effects, this judgement does not produce an output heap environment. Each primitive constant c has a type, denoted by ty(c), that is used by T-CONST. In our implementation, ty(c) is defined in the standard prelude files (basics.dref, objects.dref, and prelude.dref). The standard T-VAR rule assigns singleton types to variables. The rule T-FUN uses the procedure HeapEnv that takes a "snapshot" of the input heap type Î£1 by collecting all of its binders z â¶S to add to the type environment and producing a heap environment Î£ 1 for type checking the body. Dually, the world satisfaction judgement Î 1 â¢ T 2 Î£ 2 â§ W 2 (defined in <ref type="bibr" target="#b6">[7]</ref>) checks that the resulting type and heap environment T 2 Î£ 2 satisfies W 2 , modulo permutation of heap bindings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Expression Typing</head><p>The expression typing judgement Î; Î£ â¢ e â¶â¶ T Î£ â² (in Figure <ref type="figure" target="#fig_6">10</ref> and <ref type="bibr" target="#b6">[7]</ref>) verifies that the evaluation of expression e produces a value of type T and a new heap environment Î£ â² . We write U as shorthand for the type {Î½ â¶â¶ U }, and Î£ â¡ Î£ â² for heap equality modulo permutation of bindings.</p><p>Prenex Quantified Types. The T-LET rule uses an existential to describe the type T 1 of the variable x that goes out of scope after the body expression is checked. Alternatively, the more traditional approach (e.g., <ref type="bibr" target="#b8">[9]</ref>) requires that the variable be eliminated (e.g., via subsumption), but we use existentials because it simplifies several other typing rules.</p><p>So that existentials appear only on the left side of subtyping obligations, we ensure that the typing rules derive prenex quantified types of the form âxâ¶T . S, where all the types T and S are refinement types, not existential types. In particular, to combine the worlds of two branches, the Join operator (defined in <ref type="bibr" target="#b6">[7]</ref>), rearranges existentials to ensure that the resulting world is in prenex form. For example, for a conditional with guard b, the join of (âx 1 â¶T 1 . Top ( â¦ x 1 )) and (âx 2 â¶T 2 . Top ( â¦ x 2 )) is (ây â¶T 12 . Top ( â¦ y)) where</p><formula xml:id="formula_27">T 12 â = {if b then T 1 (Î½) else T 2 (Î½)}.</formula><p>Imperative Operations. We use two kinds of reference cells in System !D: simple references that store base values and functions without prototype links, and object references that store dictionaries paired with prototype links. We require that all imperative operations go through strong locations. We do not need weak, simple locations since they cannot appear in DJS programs and they are not needed for desugaring; and we do not need weak, object locations because we can use our thawing mechanism instead.</p><p>Three rules manipulate simple references. To check the reference allocation ref v, the rule T-REF ensures that is not already bound in the heap, and then adds a binding that records exactly the value being stored. The rule T-DEREF checks that the given value is a reference to a simple location, and then retrieves the stored value; this is the imperative analog to the "selfifying" T-VAR rule. The rule T-SETREF strongly updates a simple location.</p><p>The rule T-NEWOBJ stores the dictionary v 1 in the heap at location 1 along with a prototype link to the location 2 that v 2 refers to. Although no typing rules manipulate object locations, several primitives (getElem, setElem, etc.) do.</p><p>Expression Typing (selected rules) Unroll(HeapHas((H, Ä¥), , k)) = UnrollHas(H, Ä¥, ,</p><formula xml:id="formula_28">Î; Î£ â¢ e â¶â¶ T Î£ â² [T-VAL] Î; Î£ â¢ v â¶â¶ T Î; Î£ â¢ v â¶â¶ T Î£ Î; Î£ â¢ e1 â¶â¶ T1 Î£1 Î, x â¶ T1; Î£1 â¢ e2 â¶â¶ T2 Î£2 Î; Î£ â¢ let x = e1 in e2 â¶â¶ âx â¶ T1. T2 Î£2 [T-LET] Î; Î£ â¢ v â¶â¶ S Î, truthy(v); Î£ â¢ e1 â¶â¶ T1 Î£1 Î, falsy(v); Î£ â¢ e2 â¶â¶ T2 Î£2 T Î£ â² = Join(v, T1 Î£1, T2 Î£2) Î; Î£ â¢ if v then e1 else e2 â¶â¶ T Î£ â² [T-IF] [T-REF] â dom(Î£) Î; Î£ â¢ v â¶â¶ T Î£ â² = Î£ â ( â¦ v) Î; Î£ â¢ ref v â¶â¶ Ref Î£ â² Î; Î£ â¢ v â¶â¶ Ref Î£ â¡ Î£0 â ( â¦ v â² ) Î; Î£ â¢ deref v â¶â¶ {y y = v â² } Î£ [T-DEREF] [T-SETREF] Î; Î£ â¢ (v1, v2) â¶â¶ (Ref , T ) Î£ â¡ Î£0 â ( â¦ v) Î£ â² = Î£0 â ( â¦ v2) Î; Î£ â¢ v1 â¶= v2 â¶â¶ {x x = v2} Î£ â² 1 â dom(Î£) Î; Î£ â¢ (v1, v2) â¶â¶ (Dict, Ref 2) Î£ â¡ Î£0 â ( 2 â¦ â¨v â² , 3â©) Î£ â² = Î£ â ( 1 â¦ â¨v1, 2â©) Î; Î£ â¢ newobj 1 v1 v2 â¶â¶ Ref 1 Î£ â² [T-NEWOBJ] Î; Î£ â¢ v1 â¶â¶ â[A; L; H] W1 â W2 Î; Î£ â¢ v2 â¶â¶ T2 Î â¢ [T A] Î â¢ [m M ] Î â¢ [ Î£ H] W â² 2 = Freshen(W2) (W â² 1 , W â²â² 2 ) = Unroll(HInst(LInst(TInst((W1, W â² 2 ), A, T ), L, ), H, Î£)) Î â¢ T2 Î£ â§ W â² 1 ; Ï W â² 1 = x â¶ T11 Î£11 Ï â² = Ï[v2 x] Ï â² W â²â² 2 = x â² â¶ T12 Î£12 HeapEnv( Î£12) = (y â¶ S, Î£12) Î; Î£ â¢ [T ; ; Î£] v1 v2 â¶â¶ âx â² â¶ T12. ây â¶ S. {z z = x â² } Î£12 [T-APP]</formula><formula xml:id="formula_29">= â§ âª âª âª â¨ âª âª âª â© has(d, k) â¨ UnrollHas(H, Ä¥, â² , k) if ( â¦ â¨d â¶ T , â² â©) â Ä¥ HeapHas(H, , k) else if â  â false else (i.e., = â)<label>k) UnrollHas(H, Ä¥, , k)</label></formula><p>Unroll(Ï(HeapSel ((H, Ä¥), , k))) = UnrollSel(Ï, H, Ä¥, , k)</p><formula xml:id="formula_30">UnrollSel(Ï, H, Ä¥, , k) = â§ âª âª âª âª âª âª â¨ âª âª âª âª âª âª â© ite has(d, k) Ï(sel (d, k)) (UnrollSel(Ï, H, Ä¥, â² , k)) if ( â¦ â¨d â¶ T , â² â©) â Ä¥ Ï(HeapSel (H, , k)) else if â  â Ï(undefined)</formula><p>else (i.e., = â)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 11. Heap unrolling</head><p>Function Application. To type check [T ; m; Î£] v 1 v 2 , the T-APP rule must perform some heavy lifting. Three wellformedness checks ensure that the number of type, location, and heap parameters must match the number of type, location, and heap variables of the function type, and that the sequence of locations contains no duplicates to ensure the soundness of strong updates <ref type="bibr" target="#b31">[32]</ref>. The procedure Freshen generates fresh binders for the output world so that bindings at different call sites do not collide. The substitution of parameters for polymorphic variables proceeds in three steps. First, the type variables A inside hastype predicates are instantiated with the type parameters T using the procedure TInst. Second, the location variables L are replaced with the parameters by ordinary substitution. Third, the heap variables H are instantiated with heap parameters using a procedure HInst that substitutes heap bind-ings for heap variables. As a result, HeapHas and HeapSel may refer to arbitrary heaps rather than just heap variables, as required. These pre-types (and pre-formulas, pre-heaps, etc.) are expanded using the procedure Unroll, defined in Figure <ref type="figure" target="#fig_0">11</ref>, that transitively follows prototype links in heap bindings, precisely matching the semantics of object key membership and lookup. We write the location â for the root of the prototype hierarchy. We use the notation Ï(p) to refer to a formula context Ï, a formula with a hole, filled with p.</p><p>At this point, the polymorphic variables have been fully instantiated. Next, the argument type T 2 and current heap Î£ are checked to satisfy the input world xâ¶T 11 Î£11 . If so, the substitution Ï maps binders from the input heap Î£11 to the corresponding ones in the current heap Î£. The substitution is extended with a binding from x to the argument v 2 and applied to the output world. Then, like in the T-FUN rule, we use HeapEnv to collect the bindings y â¶S in Î£12 and convert it to a heap environment Î£ 12 . Finally, the derived type uses existentials to describe the values in the output world.</p><p>Thaw and Freeze. To safely allow a weak, object location Ë to be treated temporarily as strong, System !D ensures that Ë has at most one corresponding thawed location at a time (if there is none, we say Ë is frozen) by recording its thaw state -either thwd or frzn. One interesting aspect of our formulation is that, to facilitate idiomatic programming, we choose to allow the use of possibly-null references. Instead, to require that all references be provably non-null before use, we can simply update the type signatures for object primitives. We omit the typing rules for thawing and freezing from Figure <ref type="figure" target="#fig_6">10</ref>; we refer the reader to <ref type="bibr" target="#b6">[7]</ref> for more details.</p><p>Location Polymorphism. To simplify the presentation of System !D in this paper, we have limited location polymor-phism in two ways. First, we allow location variables L to refer only to strong locations. In <ref type="bibr" target="#b6">[7]</ref>, we describe how to add weak location polymorphism to function types and update the typing rules appropriately. Second, we offer only a single mechanism -namely, universal quantificationto abstract over simple locations as well as object locations. As a result, functions must be quantified over all simple locations inserted by desugaring (to model imperative JavaScript variables), which clutters function types and, worse, requires explicit declaration and instantiation of locations that are "internal" to the desugaring translation and not accessible in the original DJS program. Instead, in <ref type="bibr" target="#b6">[7]</ref>, we show how to use existential quantification in the output types of functions to describe simple locations, and use universal quantification in the input types of functions only to describe object locations, which are visible in DJS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Type Soundness</head><p>Many standard stuck states are not stuck in JavaScript: a function can be applied with any number of arguments; an operator can be used with any values because of implicit coercion; and, all property lookups succeed (possibly producing undefined). Nonetheless, several (non-exceptional) stuck states remain: applying a non-function value; and retrieving a property for a non-object value. System !D is designed to ensure that well-typed programs do not get stuck and can only fail with exceptions due to retrieving a property from undefined or null. We can also provide the stronger guarantees that only bound keys are retrieved and only nonnull objects are accessed (thus ruling out the possibility of null dereference exceptions) simply by changing the types of object primitives appropriately.</p><p>We expect that System !D satisfies progress and preservation theorems, but we have not yet proven them. The process will likely be tedious but not require new proof techniques. Unlike System D, which introduced the problematic nesting of syntactic types inside uninterpreted formulas, System !D does not introduce any new mechanisms in the refinement logic. Furthermore, several variations of Alias Types <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b36">37]</ref>, even in a dependent setting <ref type="bibr" target="#b30">[31]</ref>, have been proven sound, and we expect to re-use their techniques to prove the soundness of System !D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Desugaring DJS to System !D</head><p>In Figure <ref type="figure" target="#fig_7">12</ref>, we present a selection of the explicitly typed abstract syntax of DJS along with desugaring rules âª e â« = e that translate DJS expressions e to System !D expressions e. Most of the desugaring rules follow Î» JS <ref type="bibr" target="#b20">[21]</ref> closely, so we limit our discussion to the aspects most relevant to DJS; we refer the reader to <ref type="bibr" target="#b6">[7]</ref> and their work for more details. We use the metavariable I â = [T ; m; Î£] to range over instantiation parameters for function application. Instantiation parameters are usually inferred by the type checker ( Â§6). Object Literals. In the rules DS-OBJLIT and DS-ARRLIT, we write pro(e) â = getProp (âªeâ«, "prototype") to set the prototypes of fresh object and array literals, translated to newobj which creates values with prototype links. Our implementation inserts a fresh location if none is provided.</p><p>Function Application. The last four rules in Figure <ref type="figure" target="#fig_7">12</ref> handle different kinds function calls in JavaScript. The rules DS-FUNCCALL and DS-METHCALL desugar "direct calls" and "method calls", where e â = getElem (e, " code "). Notice that non-receiver arguments are packed into a single "arguments" tuple. In DS-FUNCCALL, we write window for the "global object" supplied as the receiver for direct calls. The DS-NEW rule handles object construction by creating a fresh object with newobj whose prototype is set to the object in the constructor object's "prototype" field, and calls the function in the " code " field to finish the initialization. JavaScript provides two native functions apply and call in Function.prototype that allow the caller to explicitly supply the receiver argument. We do not provide general support apply and call in DJS, because they require mechanisms beyond the scope of our (already-large) type system; for example, the latter accepts arbitrary number of arguments. The primary benefit of (non-constructor) functions as objects in JavaScript is that they inherit apply and call from Function.prototype, but since we do not support them, we sacrifice little expressiveness if the type system treats every non-constructor function as a scalar function value, rather than an object with the function stored in " code ". Furthermore, we can then support the limited use of apply required for our recursive function idioms in Â§ 2.7 using the rule DS-APPLY that syntactically looks for "apply" and explicitly sets the receiver. Because the type systems prohibits (non-constructor) functions from being used as objects, there is no danger that the apply be "hijacked" by overwriting the "apply" property.</p><p>Control Operators. Throughout the paper, we wrote only JavaScript functions that have either a single return statement or a return statement along every control flow path. In general, however, return statements -as well as looping constructs and other control operators -can appear in arbitrary positions. In System !D, we handle the general case using break and label expressions, following Î» JS <ref type="bibr" target="#b20">[21]</ref>. We omitted the formulation from our presentation for ease of exposition; see <ref type="bibr" target="#b6">[7]</ref> for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Evaluation</head><p>In this section, we describe our implementation, the benchmarks we have annotated and type checked so far that demonstrate the expressiveness of DJS, and identify several ways for future work to improve the tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Implementation</head><p>We have implemented a type checker for DJS, available at ravichugh.com/djs, that is currently approximately 6,600 (non-whitespace, non-comment) lines of OCaml code. We borrow the Î» JS <ref type="bibr" target="#b20">[21]</ref> JavaScript parser, use their desugaring as a starting point for our own, and use the Z3 SMT solver <ref type="bibr" target="#b10">[11]</ref> to discharge logical validity queries. We specify the System !D primitive functions in the files basics.dref and objects.dref, and JavaScript built-in functions like Object.prototype.hasOwnProperty in prelude.js (desugared to prelude.dref). These three files comprise a standard prelude included with every desugared DJS program for type checking.</p><p>Local Inference. Function definitions require explicit type annotations, and we employ bidirectional type checking <ref type="bibr" target="#b28">[29]</ref> techniques to infer types for local expressions. At a function application, we infer missing type and location parameters by "greedily" matching the types of arguments against any Arr (T ) and Ref L type terms in the the declared input type and input heap. Because these type terms are invariant in their parameters (recall the U-ARRAY and U-STRONGREF rules from Figure <ref type="figure">8</ref>), the greedy choice is always the right one. For a function type with exactly one heap variable H (like all the ones we have encountered) and input heap type (H, Ä¥), we infer the corresponding heap argument by simply collecting all locations in the current heap environment that do not match the explicit location bindings in Ä¥. In our benchmarks, we are able to omit most type and location arguments and all heap arguments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Benchmarks</head><p>To demonstrate the expressiveness of DJS, we have annotated and checked several small examples -inspired by JavaScript: The Good Parts <ref type="bibr" target="#b9">[10]</ref>, the Google Closure Library <ref type="bibr" target="#b18">[19]</ref>, and the SunSpider <ref type="bibr" target="#b33">[34]</ref> and V8 <ref type="bibr" target="#b19">[20]</ref> benchmarks -that exercise a variety of invariants, besides those demonstrated by previous examples (e.g., negate, passengers, etc.). We also ported the counter and dispatch examples from System D <ref type="bibr" target="#b8">[9]</ref> to DJS to demonstrate the nesting of function types inside objects with dynamic keys. Figure <ref type="figure" target="#fig_0">13</ref> summarizes our results, where for each example: "Un" is the number of (non-whitespace, non-comment) lines of code in the unannotated benchmark; "Ann" is the lines of code in the annotated DJS version (including comments because they contain annotations); "Time" is the running time rounded to the nearest second, tested on a 2.66GHz machine with 4GB of RAM running Ubuntu; and "Queries" is the number of validity queries issued to Z3 during type checking.</p><p>Expressiveness. We highlight some of the features of DJS that our benchmarks leverage. Besides the prototypal pattern discussed in Â§ 2.5, Crockford <ref type="bibr" target="#b9">[10]</ref> presents three additional inheritance patterns using JavaScript's construction mechanism. Each of these examples relies on the support for imperative, prototype-based objects in DJS.</p><p>The behavior of the typeOf function is like the typeof operator except that it returns the more informative result "null" for null and "array" for arrays; the operator returns in both cases. The type specification for typeOf depends on the ability to express intersections of function types in DJS, and verifying it requires control-flow tracking in the presence of mutation as well as a precise specification for the native (ES5) function Array.isArray, which we model in prelude.js.</p><p>The makeCumulative function in string-fasta.js iterates over an object with an unknown number of keys that all store integers, and sums them in place within the object. While iterating over the keys of the object, the function uses a variable to store the key from the previous iteration, a subtle invariant that DJS is able to express by describing the heap before and after each iteration. Compared to the original version, we allow the bindings to store arbitrary values and use a tag-test to sum only the integer bindings. To specify the original version requires universally quantified formulas, which DJS avoids to retain decidable type checking.</p><p>The splay benchmark defines the following interesting tree node constructor. Rather than initializing each "own" object with null left and right subtrees, the constructor's prototype object stores the defaults. After construction, however, Nodes are often extended with explicit subtrees. Using the flexibility of refinements, we assign each Node a type with the predicate has(Î½, "left") â sel (Î½, "left") â¶â¶ Ref Ë , where Ë is the weak location that describes Nodes, to ensure that retrieving the "left" key produces another Node regardless of whether it is stored on the object or not (and similarly for "right").</p><p>Our largest example is access-nbody, which defines a constructor function NBodySystem that creates a container object to store an array of Body objects. The prototypes of both constructors are augmented with methods, and the thaw/freeze mechanism is heavily used while iterating over the array of Body objects to read and write their fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Annotation Burden</head><p>As Figure <ref type="figure" target="#fig_0">13</ref> shows, our annotated benchmarks are approximately 1.7 times as large (70% overhead) as their unannotated versions on average. In our experience, a significant majority of the annotation burden is boilerplate -unrelated to the interesting typing invariants -that fall into the following five patterns. Our implementation includes preliminary support for automatically inserting several common patterns of annotations by tracking a limited amount of type information during desugaring (that require no changes to type checking). This effort has already significantly reduced the annotation overhead, but there is plenty of room for further improvements in future work.</p><p>Closures. If a function refers to a variable from an outer scope, its heap type must explicitly list its location and type. In the following example, the desugarer uses the predictable locations a pi and a e when desugaring pi and e, and the function type must contain the binding for a pi . To ease this burden, we collect the free variables in each function definition and automatically add the corresponding heap bindings that are missing. In situations where we cannot insert a suitably precise type for a location, we allow the programmer to annotate a variable declaration var i = * â¶ T * e and we propagate T to functions that refer to i.</p><p>Loops. Because loops desugar to functions, they require a heap type annotation (like for arbitrary closures) to describe invariants that hold before and after every iteration. We infer heap types for basic patterns like the following.</p><formula xml:id="formula_31">/*: (ai â¦ {Int(Î½) â§ i â¥ 0}) â (asum â¦ Num) â (ans â¦ Ref ) â ( â¦ â¨{Î½ â¶â¶ Arr (Num) â§ packed (Î½)}, â²<label>â©</label></formula><p>) */ for (i=0; i &lt; ns.length; i++) { sum += ns[i]; } Thaw and Freeze. Every weak reference must first be thawed before access, which quickly becomes burdensome. As a simple aid, we surround an access to a weak reference with thaw and freeze operations, which is sufficient for simple cases involving reads and weak updates. For more complex invariants, like the relationship between accesses to a weak reference (as in the passengers example from Â§ 2.7), a single thaw and freeze pair must surround both accesses. In the future, we plan to insert these operations at basic block and function boundaries in the style of <ref type="bibr" target="#b30">[31]</ref> so that objects are tracked with strong references as long as possible.</p><p>Untampered Natives. Functions that use JavaScript primitive functions like Object.prototype.hasOwnProperty and Array.prototype.push and expect them not to be overwritten, must explicitly constrain their input heaps as such. In most cases, programmers expect natives to remain "untampered," so desugaring could augment all function types with these constraints.</p><p>Constructor Prototypes. The purpose of a constructor C is to allow its instances to inherit properties of C.prototype (stored at location a Cpro ), but functions like useC that use such an instance must then explicitly list the type of C.prototype. This is a predictable pattern that should be easy to incorporate into desugaring, though we have not yet done so.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Performance</head><p>The running time of our type checker is acceptable for small examples, but less so as the number of queries to the SMT solver increases. We have not yet spent much effort to improve performance, but we have implemented a few optimizations that have already reduced the number of SMT queries. First, even though desugaring works perfectly well without any type information, we use DJS type annotations to translate object and array operations to specific primitives, where possible, rather than the more general ones (e.g., getPropObj and getIdxArr rather than getElem) so that type checking has fewer cases to try, and we insert type and location parameters so that they need not be inferred. Second, we modify the T-VAR rule, which normally assigns the "selfified" type {Î½ = x} to variable x that is already bound in Î. Although this precision is crucial, the variable x often has a simple syntactic type (e.g., Ref ) that is "hidden" behind the equality. Instead, if Î(x) is of the form {Î½ â¶â¶ U â§ p}, we assign {Î½ â¶â¶ U â§ p â§ Î½ = x} so that subsequent typing rules can syntactically look for U rather than going through additional SMT queries as in the general case <ref type="bibr" target="#b8">[9]</ref>.</p><p>We expect that syntactically handling more common cases will further improve performance. For example, even though the dynamic keys are crucial in certain situations, many examples use objects with finite and fixed key names, which we should be able to handle with far fewer queries to the SMT solver than in the current implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion and Future Work</head><p>In this paper, we have shown how to scale up prior work on System D -a type system for dynamic languages in a functional setting -to the real-world JavaScript settingwith imperative updates, prototype-based objects, and arrays -through a combination of strong updates and prototype chain unrolling. We have demonstrated that our new system, System !D, is expressive enough to support the invariants from a series of small but varied examples drawn from existing JavaScript benchmarks. We have found that the full range of features in DJS are indeed required, but that many examples fall into patterns that do not simultaneous exercise all features. Therefore, we believe that future work on desugaring and on type checking can treat common cases specially in order to reduce the annotation burden and running time, and fall back to the full expressiveness of the system when necessary. We believe that Dependent JavaScript is the most promising approach, to date, for supporting real-world dynamic languages like JavaScript.</p><p>Features for Future Work. DJS already supports a large subset of JavaScript that can be used for projects where all the code is controlled (e.g., server-side applications), and future work on integrating with run-time environments could allow DJS code to run alongside full untyped JavaScript. Next, we describe several features that we currently do not support, in addition to general use of apply and call as discussed in Â§5.</p><p>To allow mutation of prototype links via the non-standard " proto " property, we could add a setproto expression to the language and detect cycles during heap unrolling.</p><p>The eval statement allows a string to be parsed and executed, which is useful but dangerous if misused. Since DJS is flow-sensitive, we can constraint eval with heap invariants before and after the statement, and then perform staged type checking in the style of <ref type="bibr" target="#b7">[8]</ref> at run-time.</p><p>ES5 introduces optional per-object and per-property attributes (for example, to prevent modifications or deletions) that can likely be incorporated into our encoding of dictionaries. One benefit of such an extension is that the type system could reason more precisely about which objects are in a prototype chain. For example, we could then allow non-array objects to bind unsafe strings as long as we prevent them from appearing in the prototype chain of arrays, thus weakening the distinction we impose between array and non-array objects ( Â§ 2.6). A second benefit is that native objects could be marked as unmodifiable, statically enforcing the pattern they are usually "untampered" as discussed in Â§6.</p><p>ES5 getters and setters interpose on object reads and writes. Since this is a deep change to the semantics of object operations (invoking arbitrary functions), adding general support for these will likely be heavyweight. Interestingly, one can think of our treatment of the special array "length" property ( Â§2.6) as a built-in getter/setter.</p><p>Each function has an implicit arguments array that binds all parameters supplied by the caller, regardless of how many formals the function defines. Current ES6 proposals include a modified version, where an explicit parameter can bind a variable number of arguments beyond those named by formals, similar in style to Python.</p><p>The x instanceof Foo operator checks whether or not Foo.prototype is somewhere along the prototype chain of x. We could add a primitive to match these semantics.</p><p>Scalar values can be explicitly coerced by wrapper functions, such as Boolean, in addition to the implicit coercion we have discussed.</p><p>Undesirable Features. The last three features we discuss regularly compete for the title of worst among several "warts" in the language (e.g., <ref type="bibr" target="#b9">[10]</ref>) that lead to confusing code and hard-to-detect bugs. Incidentally, the Î» JS translations of all three are straightforward and can be supported in DJS, but we see no reason to given their demerits.</p><p>with statement adds the fields of an object to the current scope of a block, allowing them to be accessed without qualification. There is hardly a good reason to use this feature, and it is banned in ES5 "strict" mode.</p><p>All var declarations are implicitly lifted to the top of the enclosing function, resulting in "function scope" rather than lexical scope. Although simple to detect when varlifting kicks in, we opt for the latter. ES6 will likely add an explicit let binding form that is not subject to lifting. In DJS, var is essentially the new let form, but we stick with the traditional syntax for familiarity.</p><p>For a "method call" x.f(y), the receiver x is supplied for the this argument to the function, but for a "direct call" x(y), JavaScript implicitly supplies the global object for this, masking common errors. We choose to statically reject direct calls to functions that require a this parameter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Related Work</head><p>In this section, we discuss topics related to types for imperative dynamic languages, and hence strong updates and inheritance. The reader may refer to <ref type="bibr" target="#b8">[9]</ref> for background on the challenging idioms of even functional dynamic languages and the solution that nested refinements provide.</p><p>Location Sensitive Types. The way we handle reference types draws from the approach of Alias Types <ref type="bibr" target="#b31">[32]</ref>, in which strong updates are enabled by describing reference types with abstract location names and by factoring reasoning into a flow-insensitive tying environment and a flow-sensitive heap. Low-level liquid types <ref type="bibr" target="#b30">[31]</ref> employs their approach in the setting of a first-order language with dependent types. In contrast, our setting includes higher-order functions, and our formulation of heap types gives variable names to unknown heaps to reason about prototypes and gives names to all heap values, which enables the specification of precise relationships between values of different heaps; the heap binders of <ref type="bibr" target="#b30">[31]</ref> allow only relationships between values in a single heap to be described.</p><p>The original Alias Types work also includes support for weak references that point to zero or more values, for which strong updates are not sound. Several subsequent proposals <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b32">33]</ref> allow strong updates to weak references under certain circumstances to support temporary invariant violations. We adapt the thaw/freeze mechanism from <ref type="bibr" target="#b1">[2]</ref> and <ref type="bibr" target="#b30">[31]</ref> with mostly cosmetic changes.</p><p>Prototype Inheritance. Unlike early class-based languages, such as Smalltalk and C++, the (untyped) language Self allows objects to be extended after creation and feature prototype, or delegation, inheritance. Static typing disciplines for class-based languages (e.g., <ref type="bibr" target="#b0">[1]</ref>) explicitly preclude object extension to retain soundness in the presence of width subtyping, the ability to forget fields of an object. To mitigate the tension between object extension and subtyping, several proposals <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b17">18]</ref> feature quite a different flavor: the fields of an object are split into a "reservation" part, which may be added to an object but cannot be forgotten, and a "sealed part" that can be manipulated with ordinary subtyping. Our approach provides additional precision in two important respects. First, we precisely track prototype hierarchies, whereas the above approaches flatten them into a single collection of fields. Second, we avoid the separation of reservation and sealed fields but still allow subtyping, since "width subtyping" in System !D is simply logical implication over refinement formulas; forgetting a field -discarding a has(d, k) predicate -does not imply that Â¬has(d, k), which guards the traversal of the prototype chain.</p><p>Typed Subsets of JavaScript. Several (syntactic) type systems for various JavaScript subsets have been proposed. Among the earliest is <ref type="bibr" target="#b34">[35]</ref>, which identifies silent errors that result from implicit type coercion and the fact that JavaScript returns undefined when trying to look up a non-existent key from an object. The approach in <ref type="bibr" target="#b3">[4]</ref> distinguishes between potential and definite keys, similar to the reservation and sealed discussed above; this general approach has been extended with flow-sensitivity and polymorphism <ref type="bibr" target="#b38">[39]</ref>. The notion of recency types, similar to Alias Types, was applied to JavaScript in <ref type="bibr" target="#b22">[23]</ref>, in which typing environments, in addition to heap types, are flow-sensitive. Prototype support in <ref type="bibr" target="#b22">[23]</ref> is limited to the finite number of prototype links tracked by the type system, whereas the heap symbols in System !D enable reasoning about entire prototype hierarchies. Unlike System !D, all of the above systems provide global type inference; our system does not have principal types, so we can only provide local type inference <ref type="bibr" target="#b28">[29]</ref>. ADsafety <ref type="bibr" target="#b29">[30]</ref> is a type system for ADsafe, a JavaScript sandbox, that restricts access to some fields. Although expressive enough to check ADsafe, which heavily uses large object literals, they do not support strong update and so cannot reason about object extension. Unlike System !D, none of the above systems include dependent types, which are required to express truly dynamic object keys and precise controlflow based invariants.</p><p>Recent work on JavaScript verification uses separation logic <ref type="bibr" target="#b16">[17]</ref> to track precise flow-sensitive invariants. They support only first-order programs, and the expressiveness of their logic takes them beyond automatic verification, thus requiring properties to be manually proved. JavaScript Semantics. We chose the JavaScript "semanticsby-translation" of Î» JS <ref type="bibr" target="#b20">[21]</ref> since it targets a conventional core language that has been convenient for our study. An alternate semantics <ref type="bibr" target="#b25">[26]</ref> inherits unconventional aspects of the language specification <ref type="bibr" target="#b23">[24]</ref> (e.g., "scope objects"), which complicates the formulation of static reasoning.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Architecture of DJS</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. DJS function also negate; Desugared to System !D; Verifying xâ¶Top â {ite Num(x) Num(Î½) Bool (Î½)}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>var arr = [17, "hi", true]; arr[3] = 3; arr.push(4); assert (arr.length == 5 &amp;&amp; arr<ref type="bibr" target="#b4">[5]</ref> == undefined);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>ï±</head><label></label><figDesc>/*: ( Ë pass â¦ frzn) â same */ ï² for (i=0; i &lt; passengers.length; i++) { ï³ var p = passengers[i]; ï´ /*: #thaw p */ ïµ if (p.weight) { sum += p.weight; } ï¶ else { sum += max_weight; } ï· /*: #freeze p */ ï¸ }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>ï±</head><label></label><figDesc>/*: #define Ttn {"i" â¶ Num, "l", "r" â¶ Ref Ë tn} */ ï² /*: #weak ( Ë tn â¦ â¨Ttn, tnpâ©) */ ï³ /*: #ctor (this â¶ Ref , left, right â¶ Ref Ë tn, item â¶ Num) ï´ ( Ë tn â¦ frzn) â Ref Ë tn same */ ïµ function TreeNode(left, right, item) { ï¶ this.l = left; this.r = right; this.i = item; ï· /*: #freeze this */ ï¸ return this; ï¹ } ï±ï° /*: this â¶ Ref Ë tn â Num */ ï±ï± TreeNode.prototype.itemCheck = function f() { ï±ï² // thaw/freeze annotations inferred ï±ï³ if (this.l == null) return this.item; ï±ï´ else { return this.i ï±ïµ + f.apply(this.l) ï±ï¶ -f.apply(this.r); } ï±ï· }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Value type checking for System !D</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Expression type checking for System !D</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>DesugaringFigure 12 .</head><label>12</label><figDesc>Figure 12. Desugaring DJS to System !D</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>function</head><label></label><figDesc>Node(k,v) { this.k = k; this.v = v; } Node.prototype.left = null; Node.prototype.right = null;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>var pi = 3.14, e = 2.718; /*: Top (api â¦ n â¶ Num) â Num same */ function getPi() { return pi; }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>/</head><label></label><figDesc>*: #define T C {Dict(Î½) â§ â¯ } */ /*: #ctor this â¶ Ref (this â¦ â¨Emp, aCproâ©) â {Î½ = this} (this â¦ â¨T C , aCproâ©) */ function C() { ...; return this; } C.prototype.f = /*: T f */ ...; C.prototype.g = /*: Tg */ ...; /*: â¶ Ref (x â¦ â¨T C , aCproâ©) â (aCpro â¦ â¨T f (sel (Î½, "f")) â§ Tg(sel (Î½, "g")), op â©) â Top same */ function useC(x) { ... x.f ... }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Figure 2. Excerpt from basics.dref that all values have a boolean interpretation. The values false, null, undefined, the empty string "", 0, and the "not-a-number" value NaN are considered falsy, and evaluate to false when used in a boolean context; all other values are</figDesc><table /><note><p>truthy. The operator ! inverts "truthiness," so the else branch returns a boolean no matter what the type of x is. The ability to treat arbitrary values as booleans is commonly used, for example, to guard against null values.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Many implementations expose the prototype of an object x with a nonstandard x. proto property, and prototypes do affect key update in ES5. We discuss these issues further in Â§7.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported by NSF Grants CCF-0644361, CNS-0964702, and gifts from Microsoft Research. Part of this work was done while the first author was at Mozilla.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>References</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A Theory of Objects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">L 3 : A Linear Language with Locations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fluet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morrisett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Informaticae</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007-06">June 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Checking and Inferring Local Non-Aliasing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kodumal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Terauchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Towards Type Inference for JavaScript</title>
		<author>
			<persName><forename type="first">C</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Giannini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Langworthy. Semantic Subtyping with an SMT Solver</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Bierman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hritcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An Imperative, First-Order Calculus with Object Extension</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fisher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Dependent Types for JavaScript -Appendix</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Herman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<idno>arxiv.org/abs/1112.4106</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Staged Information Flow for JavaScript</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Meister</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Nested Refinements: A Logic for Duck Typing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Rondon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">JavaScript: The Good Parts</title>
		<author>
			<persName><forename type="first">D</forename><surname>Crockford</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Yahoo! Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Z3: An Efficient SMT solver</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>BjÃ¸rner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Enforcing High-level Protocols in Low-level Software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>FÃ¤hndrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">TC-39 Committee</title>
		<author>
			<persName><surname>Ecma</surname></persName>
		</author>
		<ptr target="www.ecmascript.org/community.php" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Adoption and Focus: Practical Linear Types for Imperative Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fahndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Flow-sensitive Type Qualifiers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Terauchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Static type inference for ruby</title>
		<author>
			<persName><forename type="first">M</forename><surname>Furr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David) An</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Towards a Program Logic for JavaScript</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gardner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Maffeis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Lambda Calculus of Objects with Self-Inflicted Extension</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Gianantonio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Honsell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liquori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title/>
		<ptr target="https://developers.google.com/closure/library" />
	</analytic>
	<monogr>
		<title level="j">Google. Closure library</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><surname>Google</surname></persName>
		</author>
		<ptr target="http://v8.googlecode.com/svn/data/benchmarks/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The Essence of JavaScript</title>
		<author>
			<persName><forename type="first">A</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Saftoiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamurthi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Typing Local Control and State Using Flow Analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Softoiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamurthi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Recency Types for Analyzing Scripting Languages</title>
		<author>
			<persName><forename type="first">P</forename><surname>Heidegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Thiemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">ECMAScript Language Specification, ECMA-262</title>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
	<note>rd ed.</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Compositional Reasoning and Decidable Checking for Dependent Contract Types</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Knowles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLPV</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An operational semantics for JavaScript</title>
		<author>
			<persName><forename type="first">S</forename><surname>Maffeis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Taly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">APLAS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Towards a Mathematical Science of Computation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IFIP</title>
		<imprint>
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Types and Programming Languages</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Local Type Inference</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Adsafety: Type-based Verification of JavaScript Sandboxing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Politz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Eliopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamurthi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Low-Level Liquid Types</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rondon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kawaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Alias Types</title>
		<author>
			<persName><forename type="first">F</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morrisett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">First-class State Change in Plaid</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sunshine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Naden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Stork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tanter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Javascript benchmark</title>
		<author>
			<persName><surname>Sunspider</surname></persName>
		</author>
		<ptr target="http://www.webkit.org/perf/sunspider/sunspider.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Towards a Type System for Analyzing JavaScript Programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Thiemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Logical Types for Untyped Languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tobin-Hochstadt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Alias Types for Recursive Data Structures</title>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morrisett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TIC</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Fast and Precise Hybrid Type Inference for JavaScript</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yu Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hackett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Polymorphic Type Inference for Scripting Languages with Object Extensions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DLS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
