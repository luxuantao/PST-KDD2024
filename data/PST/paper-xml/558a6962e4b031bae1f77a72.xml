<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Satisfiability Coding Lemma</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ramamohan</forename><surname>Paturi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Mathematical Institute CSAV</orgName>
								<address>
									<addrLine>Zitna 25</addrLine>
									<settlement>Praha 1</settlement>
									<country key="CZ">Czech Republic</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pavel</forename><surname>Pudlák¡</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Mathematical Institute CSAV</orgName>
								<address>
									<addrLine>Zitna 25</addrLine>
									<settlement>Praha 1</settlement>
									<country key="CZ">Czech Republic</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Francis</forename><surname>Zane</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Mathematical Institute CSAV</orgName>
								<address>
									<addrLine>Zitna 25</addrLine>
									<settlement>Praha 1</settlement>
									<country key="CZ">Czech Republic</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Satisfiability Coding Lemma</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">66BBE7466A59B8B9FBC846BE96F9FC3D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:10+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present and analyze two simple algorithms for finding satisfying assignments of ¢ -CNFs (Boolean formu- lae in conjunctive normal form with at most ¢ liter- als per clause). The first is a randomized algorithm which, with probability approaching 1, finds a satisfying assignment of a satisfiable ¢ -CNF formula £ in time ¤ ¦¥ ¨ § © £ "! . The second algorithm is deterministic, and its running time approaches # $ %© for large § and ¢ . The randomized algorithm is the best known al- gorithm for ¢ '&amp; )( ; the deterministic algorithm is the best known deterministic algorithm for ¢ 0&amp; 21 . We also show an 3 ¥ ¨ § 54 6 67 8 @9 A! lower bound on the size of depth 3 circuits of AND and OR gates computing the parity function. This bound is tight up to a constant factor. The key idea used in these upper and lower bounds is what we call the Satisfiability Coding Lemma. This basic lemma shows how to encode satisfying solutions of a ¢ -CNF succinctly.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The problem of finding a satisfying assignment of a Boolean formula in ¢ -CNF (conjunctive normal form with at most ¢ literals per clause) has been long studied, and the corresponding decision problem for ¢ CB D( was one of the first problems shown to be NP-complete <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">5]</ref>. The problem of proving lower bounds on the size of constant depth (in particular, depth 3) circuits of unbounded fan-in AND and OR gates has also received considerable attention <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b6">7]</ref>. In this paper, we present a structural F Department of Computer Science and Engineering, University of California, San Diego, La Jolla, CA 92093 property, the Satisfiability Coding Lemma, of the set of satisfying assignments of ¢ -CNF and apply this property to provide some solutions to both these problems.</p><p>There has been considerable progress in the study of the computational limitations of polynomial size and bounded depth circuits of unbounded fan-in AND and OR gates (G IH QP ). The techniques <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b11">12]</ref> used for show- ing lower bounds on the size of bounded depth circuits establish that functions computed by such small size circuits have some useful (for lower bounds) property. For example, it has been shown that such functions are constant on a sufficiently large dimensional subcube and also can be well approximated by low degree polynomials either over the reals or an appropriately chosen finite field. Thus, any function which does not have these properties cannot be computed by an G IH RP circuit. Frequently, the function considered is parity (that is, the output is one if the number of true input variables is, say, even) because it is extremal with respect to the properties mentioned above; the parity function is not constant even on any onedimensional subcube and a good approximation of parity in the field of reals or in any field except GF(2) requires almost linear degree. However, such useful techniques still have not resulted in the determination of the exact complexity of computing the parity function. More specifically, in the case of depth-3 circuits, the best known general technique (the Switching Lemma <ref type="bibr" target="#b2">[3]</ref>) yields a lower bound of 3 ¥ S #T U9 ! for V XW `Y 8a "b . Håstad, Jukna and Pudlák <ref type="bibr" target="#b3">[4]</ref> improved this lower bound to 3 ¥ c P ed f 4 hg 9 A! by using a top-down argument. On the other hand, the best known upper bound for computing parity is ¤ ¦¥ i § p4 6 67 8 9 A! which is obtained by partitioning the variables into groups of size q § 'r <ref type="bibr" target="#b3">4</ref> 7 ts vu #w §</p><p>, computing the parity of each group of variables, and then computing the parity of those results. In this paper, using the Satisfiability Coding Lemma, we show that computing parity using depth 3 circuits requires 3 ¥ ¨ § 54 6 h7 " 9 A! gates matching the upper bound.</p><p>As for the problem of finding a satisfying assignment of a ¢ -CNF, there have been a variety of algorithms and analyses. We focus our attention on those algorithms which have a provable worst-case running time better than the steps required for exhaustive search, where § is the number of variables. A straightforward improvement is obtained by selecting a smallest length clause and branching on all but one of the assignments to the variables in that clause, omitting the one assignment that makes the clause false. Monien and Speckenmeyer <ref type="bibr" target="#b5">[6]</ref> analyzed this algorithm carefully by arguing that such assignments either produce a clause of shorter length or are autark. An assignment to a set of variables is autark if all the clauses that contain the variables are satisfied by the assignment. Their analysis gives a worst-case running time ¤ ¦¥ 6 £ ¡ £¢ ¥¤ §¦ © ! where £ is a ¢ -CNF and is the largest real root of the equation r 8 4 Y . For example, this gives a bound of ¤ ¦¥ c P ed f 7 ! 6 ! for 3-CNF and an ¤ ¦¥ S P d g £" !</p><p>bound for 4-CNF. For the case ¢ # D( , better algorithms have been established: Schier- meyer <ref type="bibr" target="#b9">[10]</ref> employs more involved heuristics to obtain an algorithm with ¤ ¦¥ c P ed f $ £ A! worst-case running time for finding a satisfying assignment for 3-CNF. This was improved to ¤ ¦¥ S P ed f $ © % A! by Zhang <ref type="bibr" target="#b13">[14]</ref>. More recently, Schiermeyer <ref type="bibr" target="#b10">[11]</ref> claimed an improved algorithm with worst-case running time ¤ ¦¥ c P ed $ g %© % ! for 3-CNF. In this paper, we present some obvious and simple algorithms for finding a satisfying solution of a ¢ -CNF and analyze their worst-case running time using Satisfiability Coding Lemma. The first of these algorithms is probabilistic and, with high probability, finds a satisfying assignment of a satisfiable ¢ -CNF in time ¤ ¦¥ % £ # ¤ 4 4 h ! . We also present a deterministic algorithm whose worst-case running time approaches ¤ ¦¥ 6 £ # ¤ 4 4 6 %© % ! for large values of § and ¢ . Our randomized algorithm is the best known algorithm for ¢ B 1 . Our deterministic algorithm is better than the known deterministic algorithms for ¢ B &amp;% .</p><p>Our main technique, the Satisfiability Coding Lemma, is motivated by a simple question: How many isolated solutions can a ¢ -CNF have? An isolated solution is a sat- isfying assignment whose distance one neighbors in the Boolean cube (assignments which differ in exactly one variable) are not satisfying assignments. In other words, if any bit of an isolated solution is flipped, the formula is no longer satisfied. We also say that an input accepted by a circuit is isolated if any input at distance one from it is not accepted by the circuit. It is straightforward to see that a good upper bound on the number of isolated solutions would be helpful in proving tight lower bounds for computing parity using depth-3 circuits. If parity is computed by a small size depth-3 circuit with an OR gate at the top, then one of its depth-2 subcircuits (a CNF) must have a large number of isolated solutions. Håstad's Switching Lemma implies an ¤ ¦¥ S ¤ 4 T A! bound (with V W Y ) on the number of isolated solutions of a ¢ -CNF. In fact, our Satisfiability Coding Lemma is inspired by Razborov's proof <ref type="bibr" target="#b8">[9]</ref> of a variant of Håstad's Switching Lemma. Using the Satisfiability Coding Lemma, we prove that a ¢ - CNF can have at most ¤ 4 4 h isolated solutions, which is in fact the best possible bound. In addition, by carefully counting the contributions of bottom level gates with larger fan-ins, we prove that computing parity by depth-3 circuits requires 3 ¥ i § 4 6 h7 " 9 A! gates, obtaining a lower bound that matches the upper bound extremely closely.</p><p>The Satisfiability Coding Lemma essentially says that isolated solutions of ¢ -CNFs have short descriptions.</p><p>More precisely, we prove that the set of isolated satisfying assignments of a ¢ -CNF can be encoded with an average message length of ¥ i § 0r § a ¢ ! bits. This lemma is useful not only in obtaining upper bounds on the number of isolated satisfying assignments of a ¢ -CNF but in efficiently finding an isolated satisfying assignment if one exists. If an isolated satisfying assignment exists, then it is sufficient to search the smaller space of short descriptions for one which encodes a satisfying assignment. To handle the general case, we generalize the concept of isolated satisfying assignment to include nearly isolated satisfying assignments, and show that such solutions have short descriptions as well. From this, we can show that any satisfiable ¢ -CNF has either a nearly isolated solution or many satisfying assignments, and thus in each case we can find a satisfying solution quickly either by searching through the space of short descriptions or by randomly guessing a solution.</p><p>The remainder of the paper is organized as follows:</p><p>In section 2, we prove the Satisfiability Coding Lemma and its corollaries. In section 3, we prove the tight lower bound for computing parity using depth-3 circuits of AND and OR gates. In section 4, we present our algorithms for finding a satisfying assignment of a ¢ -CNF and analyze their running time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Satisfiability Coding Lemma</head><p>We introduce some notation. A boolean formula £ ¢¡ £ ¥¤ 4 H £ is a ¢ -CNF if each clause H £ is a disjunction of at most ¢ literals. For ¦ in § © Y , we say that ¦ is an isolated point of § in the direction if flipping the bit of ¦ produces a point not in § . We say that ¦ is a ! -isolated point of § if it has exactly ¥ ¨ § 0r ! ! neighbors in § . We will sometimes use the alternative notation " ¥ ¦ ! to denote the number of neighbors of ¦ $# % § which are not in § . If ¦ is § -isolated, we will simply call it an isolated point of § . We say that ¦ is an isolated solution of a formula £ in the direction if ¦ satisfies the formula and is an isolated point of the set of all satisfying assignments of £ in the direction . Other notions of isolation are extended similarly to general formulas and circuits.</p><p>Let £ be a ¢ -CNF. The key observation is that if ¦ is an isolated solution of £ in the direction , then there exists a clause H ¤ ¥&amp; (' £ such that exactly one of its literals is true under the assignment ¦ and that true literal corresponds to the variable . Otherwise, flipping the ) bit of ¦ would produce an assignment which still satisfies all the clauses of £ . Such a clause is called critical for the variable at the solution ¦ . Since a critical clause has only one true literal, a clause cannot be critical for two different variables at the same solution. If ¦ is an isolated solution of £ , then there exist § distinct critical clauses at ¦ , one for each direction.</p><p>We make use of the existence of critical clauses for ! - isolated solutions in obtaining short descriptions. Let 0 be a permutation of the set @Y 21 31 21 4 § of variables. We define an encoding function 5 76 to encode the satisfying assignments of the ¢ -CNF £ . Let ¦ 8# 9 ¥ @ Y ( be a satisfying solution of £ . Permute the bits of ¦ according to 0 . For each , delete the A bit of the permuted string if there is a critical clause H ¤ ¥&amp; ' 6 ¤ £ for the variable 0 ¥ ! at ¦ such that the variable 0 ¥ ! occurs after all the other variables in the critical clause H ¤ B&amp; (' 6 ¤ £ according to the ordering 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">C6 ¥ ¦ !</head><p>is the resulting string. Observe that the sequence</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">C6 ¥ ¦ !</head><p>of bits corresponds to the sequence of values of a subset of variables under the satisfying assignment ¦ presented according to the ordering 0 .</p><p>Given D E5 6 ¥ ¦ ! , we uncover the bits of ¦ one at a time in the order given by 0 using the following decoding algorithm: .</p><p>We first show the correctness of the algorithm.</p><p>Lemma 1 If ¦ is a satisfying assignment of the formula £ and D $5 6 ¥ ¦ ! is given as input to the decoding algorithm, then, Q R S Y UT V WT § , the A bit uncovered by the algorithm is the value of variable 0 ¥ ! in the satisfying assignment ¦ . Proof: For ! B `Y , assume that for Y XT Y `T ! , the a bit uncovered by the decoding algorithm is the value of the variable 0 ¥ ! in the assignment ¦ . Also assume that at the beginning of the A iteration of the algorithm, the unused bits of D correspond to variables whose ranks according to 0 are greater than or equal to . We prove that the ¥ ! Y ! Sb bit uncovered by the algorithm is indeed the value of the variable 0 ¥ ! Y ! in the assignment ¦ . We also prove that at the end of the ¥ ! Y ! b iteration the unused bits of D corresponds to variables whose ranks according to 0 are higher than ¥ ! Y !</p><p>. Assume that the condition in the if clause is true. Then the value of the variable 0 ¥ ! Y ! is forced, since £ dc P 4 has a length one clause in the variable 0 ¥ ! Y !</p><p>. By induction hypothesis, the partial assignment to the variables 0 ¥ ! for Y eT f gT ! can be extended to the satisfying assignment ¦ . Thus the bit assigned by the algorithm must coincide with the value of the variable 0 ¥ ! Y ! in the assignment ¦ .</p><p>Furthermore, it must be the case that the bit corresponding to the variable 0 ¥ ! Y ! is deleted from the assignment ¦ by the encoding algorithm in producing D . This is due to the fact that the clause in the original formula £ that gave rise to the length one clause in the variable 0 ¥ ! Y ! in the formula £ hc P 4 is a critical clause for the variable 0 ¥ ! Y ! and that all other variables in that clause occur before the variable 0 ¥ ! Y ! in the ordering 0 . Therefore, from induction hypothesis, we can conclude that all the unused bits of D must correspond to variables whose ranks are higher than ¥ ! Y ! in the ordering 0 . If, on the other hand, £ hc P 4 has no length one clause in the variable 0 ¥ ! Y !</p><p>, then there is no critical clause for the variable 0 ¥ ! Y ! at ¦ such that the variable 0 ¥ ! Y ! has the highest rank with respect to 0 among the variables that appear in the critical clause. This implies that the bit corresponding to the variable 0 ¥ ! Y !</p><p>is not deleted from the assignment ¦ to produce the string D by 5 6 . Since all the unused bits of D at the beginning of the ¥ ! Y ! b it- eration of the decoding algorithm correspond to variables whose ranks are greater than or equal to ¥ ! Y !</p><p>, and since the bits of D correspond to the values of the variables or- dered by 0 , the next unused bit in D must correspond to the variable 0 ¥ ! Y !</p><p>. Since this bit is assigned to the vari-</p><formula xml:id="formula_0">able 0 ¥ ! Y !</formula><p>, all the remaining unused bits correspond to variables whose rank according to 0 is higher than ¥ ! Y ! . This completes the proof of the lemma.</p><p>We next prove the Satisfiability Coding Lemma and its corollaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Satisfiability Coding Lemma:</head><p>If ¦ is a ! -isolated sat- isfying assignment of a ¢ -CNF £ , then then its average (over all permutations 0 ) description length under the en- coding 5 6 is at most § r ! a ¢ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>Since ¦ is ! -isolated, it has ! variables with critical clauses. Let 0 be a random permutation of the variables. For each variable with a critical clause at ¦ , the probability that the variable appears as the last variable among all the variables in its critical clause is at least Y 8a ¢ since no clause of £ has more than ¢ literals. Hence the corresponding bit in ¦ will be deleted in the encoding 5 6 with probability at least Y "a ¢ . Hence, the expected number of bits deleted in the encoding of ¦ is at least ! a ¢ which yields a description for ¦ of length at most § 'r ! a ¢ . We now prove an upper bound on the number of isolated solutions of a ¢ -CNF. We need the following fact regarding the average length of an encoding.</p><formula xml:id="formula_1">Fact 1 If 5 F § ¥ @ Y ¡</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>is a prefix free encoding (oneto-one function) with average code length ¢</head><p>, then § T ¤£ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>Let</p><formula xml:id="formula_2">¢ &amp; denote the length of 5 ¥ ¦ ! for ¦ ©# V § . Then ¢ ¦¥ &amp; ¨ § © ¢ &amp; a §</formula><p>. Since 5 is one-to-one and prefix free, we have that</p><formula xml:id="formula_3">¥ &amp; § © £ T Y . Thus, ¢ r s u w § &amp; ¨ § © Y § ¥ ¢ &amp; r s u w § ! r &amp; ¨ § © Y § ¥ s u w £ s u w § ! r &amp; ¨ § © Y § s vu #w ¥ 6 § £ ! B r s vu #w ¥ &amp; § © £ ! B 1</formula><p>The penultimate inequality follows from the concavity of the logarithm function. Hence, § T £ .</p><p>Lemma 2 Any ¢ -CNF £ can accept at most # $ isolated solutions.</p><p>Proof: By the Satisfiability Coding Lemma, the average description length (under the encoding 5 ) of an iso- lated solution (that is, an § -isolated solution) of £ is at most § r § a ¢ . This is also true when the average is taken over all isolated solutions and all permutations. Hence, there exists a permutation 0 such that the average descrip- tion length under the coding 5 6 is at most § r § a ¢ . Ob- serve that the proof of Lemma 1 shows that the set encodings produced by 5 6 is prefix free. Hence, from Fact 1, the number of isolated solutions cannot exceed @ $ . This bound is indeed the best possible. Let § be a multiple of ¢ . Group the variables into § a ¢ disjoint groups of ¢ variables each. Let £ £ be the ¢ -CNF accepting the parity function of the ¢ variables in group . Consider the ¢ -CNF obtained by taking the conjunction of the £ £</p><p>. All the satisfying assignments of this ¢ -CNF have the same parity and thus are isolated. Moreover, the ¢ -CNF has exactly satisfying assignments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Lower Bound for Depth-Circuits</head><p>In this section, we prove a tight lower bound on the number of gates required by a depth-3 circuit to compute parity. We introduce some additional notation:</p><p>Let ¦ be an isolated solution of a CNF £ . For each , fix a shortest critical clause H ¤ ¥&amp; ' £ for the variable at ¦ . Note that all these clauses are distinct. We define the length of a clause as the number of literals it contains. Let £ ¥ ¦ ! be the number of critical clauses at ¦ of length ¢ . Observe that ¥ £ ¤ 4 £ ¥ ¦ ! §</p><p>. To account for the contribution of clauses of various lengths, we define the weight, ¡ ¥ ¦ !</p><formula xml:id="formula_4">, of ¦ as ¡ ¥ ¦ ! ¥ £ ¥¤ 4 Y 8a H ¤ ¥&amp; ' £ ¥ £ ¤ 4 £ ¥ ¦ ! a ¢</formula><p>. We show that as a consequence of the Satisfiability Coding Lemma that the number of isolated solutions of £ with weight greater than or equal to ¢ is at most @ ¤£ . Lemma 3 If £ is a CNF, then the number of its isolated solutions with weight greater or equal to ¢ is at most $ ¤£ . Proof: We show that the average description length of an isolated solution of weight ¢ or greater is at most § Xr ¢ under the encoding 5 . Let ¦ be an isolated solution of weight ¡ ¥ ¦ ! B ¥¢ . Since the bit in ¦ corresponding to variable is deleted with probability at least Y 8a H ¤ ¥&amp; ' £ in computing the encoding 5 76 for a random 0 , the expected number of bits deleted is at least ¥ £ B¤ 4 Y "a H ¤ ¥&amp; (' £ B ¦¢ .</p><p>Hence, there exists a permutation 0 such that the average (over all isolated solutions of weight greater or equal to ¢ ) of the description lengths under the encoding 5 6 is at most § r ¢ . Therefore, the number of isolated solutions is at most §£ . We are now ready to prove our lower bound.</p><p>Theorem 1 3 ¥ ¨ § 54 6 67 8 9 A! gates are required for any depth-3 circuit computing parity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>We will only consider ¨ circuits, circuits which can be expressed as an OR of CNFs. Since the complement of a parity function is also a parity function, the proof applies to © circuits as well. Let § be the set of inputs accepted by the circuit. By definition, § is the set of inputs with an even number of 1's and § @ 4</p><p>. Since the top gate is an OR, for each ¦ # § , there exists a CNF (a depth-2 subcircuit), say £ &amp; , which accepts ¦ . More- over ¦ is an isolated solution of £ &amp; . We define the weight of ¦ with respect to the CNF £ &amp; . We will classify the in- puts in § based on their weight. Let ¢ q § ¥ s vu #w § ! a "1 . Let § 4 be the set of inputs in § whose weight is greater than or equal to ¢ . Let § © be the set of inputs in § whose weight is less than ¢ . Observe that § 4 § © 4</p><p>.</p><p>Since no CNF can accept more than # §£ isolated solutions whose weight is at least ¢ , we get that the number of CNFs in the circuit is at least § 4 £ @ . We will now argue that many clauses are needed to accept low weight isolated solutions. Since a clause of length ¢ can only be critical for at most ¢ @ £ pairs ¥ ¦ d ) ! of solution ¦ and direction , there must be at least  </p><formula xml:id="formula_5">£ ¤ 4 &amp; § © £ ¥ ¦ ! a ¥ ¢ $ £ ! &amp; ¨ § © £ ¤ 4 £ ¥ ¦ ! a ¥ ¢ $ £ ! &amp; ¨ § © § £ ¤ 4 £ ¥ ¦ ! § ¤£ ¢ clauses (</formula><formula xml:id="formula_6">¤ 4 £ ¥ ¦ ! § . From the constraint ¥ £ ¤ 4 £ ¥ ¦ ! a ¢ ¡ ¥ ¦ ! W ¢ , we obtain § &amp; ¥ £ ¤ 4 ¢ £ ¥ ¦ ! B § © a ¢</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>&amp; B ¥¢ !£ a §</head><p>for sufficiently large §</p><p>. Thus, the the number of level one OR gates must be at least § © ¢ P !£ . Thus the total number of gates is at least § 4 £ @ § © ¢ P !£ . Minimizing this expression subject to the constraint § 4 § © 4</p><p>, we get the desired lower bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">k-SAT Algorithm</head><p>The Satisfiability Coding Lemma can also be used to find satisfying assignments of ¢ -CNF formulae in less than steps. Suppose the ¢ -CNF formula £ has some so- lution which is isolated or nearly-isolated. By the Satisfiability Coding Lemma, with respect to many permutations 0 , such a solution has an encoding of short length.</p><p>By searching this space of encodings for one which encodes a satisfying assignment, we would be assured of finding a satisfying assignment if one exists. If no solution is isolated or nearly-isolated, we may not be able to guarantee the existence of such short encodings. However, in such a case, if there is any satisfying solution, there must be many of them thus the chance of the randomly guessing one of them is higher. In this section, we present a randomized algorithm which (with probability approaching 1) finds a satisfying assignment of a ¢ -CNF in ¤ ¦¥ ¨ § © @ £ # % ! steps, as well as a somewhat less efficient deterministic algorithm which uses similar techniques. These results are summarized in the following table : 

Previous New New (det.) (random.) (det.)</p><p>¢ ( P d $ g 6© % <ref type="bibr" target="#b10">[11]</ref> P ed f 6f " 6 P d g %f ¢ 1 P d g £" <ref type="bibr" target="#b5">[6]</ref> P ed " $ 6P P d 4 " 6 ¢ % P d 7 £" % <ref type="bibr" target="#b5">[6]</ref> P ed g P %P P d 4 U ¢ P d " $ <ref type="bibr" target="#b5">[6]</ref> P ed g £ 6 P d 7 4 U</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Randomized Algorithm</head><p>The randomized algorithm we analyze here is extremely simple:</p><p>Algorithm A repeat § © e # % times while there exists an unassigned variable select an unassigned variable D at random if there is a clause of length one involving D or ¡D then set D to make that clause true else set D to true or false at random if the formula is satisfied, then output the assignment</p><p>Before we analyze the probability that this algorithm succeeds in finding a satisfying assignment, we first establish a lemma which we will need in the analysis. This lemma relates the density of a set and the isolation of the members of the set. Lemma 4 Let § $ ¥ @ Y ( , § nonempty, and for ¦ # § , define " ¥ ¦ ! as the number of distance one neighbors of</p><formula xml:id="formula_7">¦ that are not in § . Define value ¥ ¦ ! £¢ ¤ B&amp; . Then ¥ &amp; ¨ § © value ¥ ¦ ! B Y .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The proof is by induction on §</p><p>. With this lemma, we now show that the algorithm described above finds satisfying assignments of ¢ -CNFs quickly.</p><p>Theorem 2 Algorithm A runs in time ¤ ¦¥ ¨ § 5© £ "! and finds a satisfying assignment of a satisfiable ¢ -CNF £ with probability approaching 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>Suppose that £ is satisfiable, and that ¦ is a ! -isolated solution of £ for some ! # @Y 21 31 21 I § . For each of the ! directions in which ¦ is isolated, fix a critical clause. We obtain a lower bound for the probability that ¦ is output by Algorithm A during an iteration of the repeat loop.</p><p>Consider one iteration of the repeat loop. Let 0 be the random permutation determined by the order in which variables are assigned in the while loop. Let ¨4 be the event that for at least ! a ¢ critical clauses, the critical vari- ables occur last among the variables in the critical clause with respect to the random permutation 0 . Let ¨© be the event that the values assigned to the variables in while loop agree with the assignment ¦ . We use the probability of the event ¨4 © ¨© as a lower bound on the probability that the algorithm outputs ¦ .</p><p>Since ¦ is a ! -isolated solution, the average number (over all permutations) of critical variables which appear last among the variables in their critical clauses is at least ! a ¢ . Since the maximum number of critical variables is § , it follows that for at least a Y "a § -fraction of permutations, the number of such critical variables is at least ! a ¢ . Thus the probability of ¨4 is at least Y "a §</p><p>.</p><p>Assuming ¨4 , we lower bound the probability for ¨© . It is clear that if the random assignments made in the else branch agree with the satisfying assignment ¦ , then the assignments made in the then branch must agree as well.</p><p>Since ¨4 holds, the else branch is taken at most § r ! a ¢ times. Thus the probability that ¨© holds given ¨4 is at least $ P c</p><p>, and the probability that the ! -isolated sat- isfying assignment ¦ is output by the algorithm is at least P c a § . The probability that the algorithm generates some satisfying solution can then be obtained by summing over all satisfying assignments. Let § be the set of satisfying assignments of £ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>&amp; § ©</head><p>¢¡ ¤£ ¦ is output by the algorithm¥</p><formula xml:id="formula_8">B &amp; § © Y § P ¢ ¤ B&amp; Y § P &amp; § © ¤ P ¢ ¤ ¥&amp; B Y § P &amp; § © P ¢ ¤ B&amp; B Y § P</formula><p>where the last inequality follows from lemma 4. By repeating the while loop § © times, we find a satisfying assignment with probability approaching 1.</p><p>There is a simple ¢ -CNF on which the expected num- ber of times the algorithm executes this loop is @ . Experiments suggest, however, that on random ¢ -CNF the algorithm runs much faster.</p><p>In order to obtain a deterministic algorithm, we first observe that the problem of finding a good ordering of variables requires only limited independence. Specifically, to conclude that the average number of bits saved in the encoding of a ! -isolated solution of a ¢ -CNF is at least ! a ¢ , it is sufficient that each of the ¢ variables in a clause is equally likely to occur last with respect to a random ordering. However, it is not clear how to come up with an efficient algorithm for selecting a satisfying assignment deterministically when there are a large number of satisfying assignments none of which are sufficiently isolated.</p><p>We now present a somewhat less efficient deterministic algorithm for finding a satisfying assignment.</p><p>We will construct a small space § of permutations of #Y 31 21 21 4 § with the following property: for any set ¦ of up to ¢ variables, any variable D in ¦ , and for a randomly chosen permutation from § , the probability that D appears last among the variables in ¦ is at least Y 8a ¦ r Y 8a § . The following construction of such a family was suggested to us by Russell Impagliazzo.</p><p>Let § #Y H 31 21 31 4 ©¨ , where ¨is a prime power larger than §</p><p>. Let § be a probability space over which § ¢ -wise independent random variables each taking val- ues in § are defined. Using known techniques, such a probability space § ¢ can be constructed such that § ¢ T ¤ ¦¥ ¨ § !</p><p>. Let ¦ be a set of at most ¢ variables. If all the values assigned to the variables in ¦ are distinct, then the assignment induces an ordering of the variables in ¦ . As- suming the variables in ¦ take distinct values, ¢ -wise in- dependence guarantees that all orderings of the variables in ¦ have the same probability. In particular, each vari- able in ¦ occurs last among the variables in ¦ with probability Y 8a ¦ .</p><p>Let § ¨ § correspond to the event that all the § variables take distinct values. Each element of § can be inter- preted as a permutation of #Y H ¤ ¤ 4 § which is given by the ordering of the variables by their values. Since ¢ B , it follows that the probability of § is at least Y r Y 8a § .</p><p>It also follows that over the space § , for any set ¦ of at most ¢ variables and a variable in ¦ , the probability that the variable occurs last is at least Y "a ¦ r Y 8a § . Thus § has the desired property.</p><p>Our deterministic algorithm will make use of two ideas. First, observe that either there is a satisfying assignment which has few ones, or any minimal solution has many ones, where minimality is defined with respect to the number of ones in the assignment. This dichotomy is useful because a minimal solution must be isolated in all the directions where a variable has the value one. The second observation is that by using permutations from the family § rather than truly random permutations to order the variables, a ! -isolated solution can still be encoded using at most § r ! a ¢ Y bits. The following deterministic al- gorithm incorporates these ideas. Let the parameter be such that T 8T Y "a and satisfies ¥ Y r ! ¥ !</p><p>, where ¥ ¦ ! is the binary entropy function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm B</head><p>for all inputs ¦ with at most § ones if the formula is satisfied by ¦ , then output ¦ for all permutations 0 in § , and for all strings of § ¥ Y r #a ¢ ! Y bits /* apply the decoding algorithm 5  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The first for loop of the algorithm checks whether any input with at most § ones is a satisfying assignment of £ .</p><p>If there is such a satisfying assignment, then the algorithm succeeds. Otherwise, any minimal satisfying assignment of £ must be at least § -isolated, since a minimal solution must be isolated in any direction where the value of a variable is one.</p><p>Fix such a nearly-isolated solution ¦ , and fix § critical clauses for ¦ . If 0 is chosen randomly from § , then for each of the § critical clauses at ¦ , the probability that the critical variable occurs last among the variables of the clause is at least Y "a ¢ r Y 8a §</p><p>. Thus the expected number of times this event occurs is at least § a ¢ r #a §</p><p>, and there is some 0 in § which achieves at least the expectation. With respect to that 0 , there is an encoding of ¦ using at most § ¥ Y r #a ¢ ! Y bits. As runs over all strings of that length, this encoding will be encountered and decoded to produce ¦ . The time taken to check all solutions with at most § ones is £ ¢¡ ¤ . If no solution is found, then at most ¤ ¦¥ ¨ § ! different permutations are examined, and each permutation requires at most ¤ ¦¥ 6 £ @ ¤ 4 P 4 ! steps for a total of ¤ ¦¥ % £ § % # ¤ 4 % P 4 e! . To optimize the algorithm, choose to minimize the sum of these terms.</p><p>The approximate values in the exponent of this running time for small ¢ were given earlier in the table. For large values of both § and ¢ , the running time approaches $ %© .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>An obvious open problem is to find a deterministic algorithm for ¢ -Sat that runs in time ¤ ¦¥ poly ¥ ¨ § ! 6 @ # % !</p><p>. It seems that additional insight into the structure of large sets accepted by ¢ -CNFs is necessary.</p><p>Our Satisfiability Coding Lemma gives information only about the number of length § minterms of a ¢ -CNF, while the Switching Lemma gives information about the lengths of minterms after a restriction is applied. It seems likely that one can prove a stronger version of the Switching Lemma if one has good bounds on the number of other minterms.</p><p>In an insightful remark, Valiant <ref type="bibr" target="#b12">[13]</ref> commented that the pursuit to understand the reasons for the inherent computational difficulty of problems has two complementary facets, the positive one of finding fast algorithms and the negative one of proving lower bounds on the inherent complexity. In fact, our question regarding the number of isolated points of a ¢ -CNF led us to the discovery of the Satisfiability Coding Lemma which not only gives precise lower bounds on parity but yields somewhat unexpected insight into the satisfiability problem. It seems that progress can be made in both directions if one can further relate the syntactic properties of the formula to the structure of its solution space.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>£ 4</head><label>4</label><figDesc>GF £ for 2Y H 21 21 31 I § if £ £ has a clause of length one consisting of the variable 0 ¥ ! , then we set the variable 0 ¥ ! to make the clause true. else we set the variable 0 ¥ ! to be the next unused bit of D . Let £ £ BP 4 be the formula obtained by substituting the value of the variable 0 ¥ ! in £ £</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>that is, level one OR gates) to account for all</figDesc><table><row><cell>the  § © isolated solutions of weight less than ¢ . Let &amp; ¥ £ ¤ 4 ¤ B&amp; © £ denote the inner summation, and de-fine &amp; ¥ £ ¤ 4 £ ¤ B&amp; . Now, &amp; B a &amp; by the con-vexity of the function £ a ¢ and the fact ¥ £</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>If §</figDesc><table><row><cell>, it is trivially true. If  § &amp; , consider the two subcubes ¤ 4 £ ( &amp; eY ) generated by fixing the value of the last coordinate. Let  § £  § ¦¥  §¤ $ 4 £ £ are nonempty, the induction hy-. If the  § pothesis guarantees that the sum of the values of elements in each  § £ is at least 1 when  § £ are considered as subsets of the ¥ i § r Y ! -dimensional cube. If one of the  § £ is empty,</cell></row><row><cell>then the other one is nonempty and moreover when it is viewed as a subset of the  § -dimensional cube the value of increases by one for each of its elements. Thus the " ¥ ¦ ! sum of the values remains greater than or equal to one. If both  § £ are nonempty, then the sum of the values of the elements in each  § £ is at least Y "a when  § £ are consid-ered as subsets of the  § -dimensional cube. Thus the total</cell></row><row><cell>value is at least one as desired.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>D be the th variable according to 0 if there is a clause of length one involving D or ¡D then set D to make that clause true else set D equal to the next unused bit from if the formula is satisfied, then output the assignment</figDesc><table><row><cell>4 6 to */</cell></row><row><cell>for i=1 to n</cell></row><row><cell>Theorem 3 Algorithm B finds a satisfying assignment of</cell></row></table><note><p>let a satisfiable ¢ -CNF £ in ¤ ¦¥ % £ § % ! time.</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments:</head><p>The authors would like to thank Russell Impagliazzo, Sam Buss, and Vojtech Rödl for helpful discussions.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported by grant no. A1019602 of the Academy of Sciences of the Czech Republic, and grant INT-9600919/ME 103(1997) under the cooperation of MSMT, Czech Republic and NSF, USA</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Complexity of Finite Functions</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Boppana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sipser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Handbook of Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="page" from="759" to="804" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Complexity of Theorem-Proving Procedures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 3rd Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1971">1971</date>
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Almost Optimal Lower Bounds for Small Depth Circuits</title>
		<author>
			<persName><forename type="first">J</forename><surname>Håstad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Symposium on Theory of Computing</title>
		<meeting>the 18th ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="6" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Top-Down Lower Bounds for Depth 3 Circuits</title>
		<author>
			<persName><forename type="first">J</forename><surname>Håstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jukna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pudlák</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual IEEE Symposium on Foundations of Computer Science</title>
		<meeting>the 34th Annual IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="124" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Universal Sorting Problems</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">English translation in Problems of Information Transmission 9</title>
		<title level="s">Problemy Peredaci Informacii</title>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="265" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<author>
			<persName><forename type="first">B</forename><surname>Monien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Speckenmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Solving Satisfiability In Less Than @ Steps</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="287" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Exponential Lower Bounds on Depth 3 Boolean Circuits</title>
		<author>
			<persName><forename type="first">R</forename><surname>Paturi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Saks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zane</forename><forename type="middle">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 29th Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="86" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Lower Bounds on the Size of Bounded Depth Networks over a Complete Basis with Logical Addition</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Razborov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">English Translation inMathematical Notes of the Academy of Sciences of the USSR</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="333" to="338" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
	<note>in Russian</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Razborov</surname></persName>
		</author>
		<title level="m">Bounded Arithmetic and Lower Bounds in Boolean Complexity, Feasible Mathematics II</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="344" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Solving 3-Satisfiability in less than Y H1 % ¢¡ Steps</title>
		<author>
			<persName><forename type="first">I</forename><surname>Schiermeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Selected papers from CSL &apos;92</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">702</biblScope>
			<biblScope unit="page" from="379" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Pure Literal Look Ahead: An ¤ ¦¥ Y 1 1 ¡ £ $! 3-Satisfiability Algorithm</title>
		<author>
			<persName><forename type="first">I</forename><surname>Schiermeyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note>Preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Algebraic Methods in the Theory of Lower Bounds for Boolean Circuit Complexity in</title>
		<author>
			<persName><forename type="first">R</forename><surname>Smolensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM symposium on Theory of Computing</title>
		<meeting>the 19th ACM symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="77" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Graph-theoretic arguments in low-level complexity</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Symposium on Mathematical Foundations of Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 6th Symposium on Mathematical Foundations of Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="162" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Number of models and satisfiability of sets of clauses</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="page" from="277" to="288" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
