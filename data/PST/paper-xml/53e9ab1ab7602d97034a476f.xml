<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Asymptotically Tight Bounds on Time-Space Trade-offs in a Pebble Game</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Lengauer</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Stanford Umverstty</orgName>
								<address>
									<settlement>Stanford</settlement>
									<region>Cahforma</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Stanford Umverstty</orgName>
								<address>
									<settlement>Stanford</settlement>
									<region>Cahforma</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Asymptotically Tight Bounds on Time-Space Trade-offs in a Pebble Game</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">59CCC9585D907241E9E36E94A49773DB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Asymptotically Ught tune-space trade-offs for pebblmg three d~fferent classes of directed aeychc graphs are derived Let N be the size of the graph, S the number of avadable pebbles, and T the time necessary for pebbling the graph A time-space trade-off of the form</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(ii) If all immediate predecessors of an unpebbled vertex v are pebbled, a pebble may be placed on v. (iii) If all immediate predecessors of an unpebbled vertex v are pebbled, a pebble may be moved from a predecessor of v to v.</p><p>A move is the application of one of the above rules. The object of the game is to pebble each vertex in the graph at least once. (For a comparison of slightly differing defmitions of the pebble game see <ref type="bibr" target="#b35">[34]</ref>.)</p><p>The pebble game has been used to model register allocation <ref type="bibr" target="#b30">[29]</ref>, study flowcharts and recursive schemata <ref type="bibr" target="#b9">[8]</ref>, and analyze the relative power of time and space as Turing-machine resources <ref type="bibr" target="#b3">[2,</ref><ref type="bibr" target="#b10">9]</ref>. Furthermore, it has been used to derive time-space trade-offs for several important algorithmic concepts, such as linear recursion <ref type="bibr" target="#b2">[1,</ref><ref type="bibr" target="#b27">26]</ref>, fast Fourier transform <ref type="bibr" target="#b28">[27,</ref><ref type="bibr" target="#b31">30]</ref>, matrix multiplication <ref type="bibr" target="#b31">[30]</ref>, and integer multiplication <ref type="bibr" target="#b29">[28]</ref>. We are interested in the relative power of time and space as resources in the pebble game.</p><p>The space S required by the pebbling is the maximum number of pebbles ever on the graph simultaneously; the time T required is the number of applications of rules (ii) and (iii), that is, the number of pebble placements. (One could also count both placements and removals. The results would then change by at most a factor of 2.) The size N of the graph is the number of its vertices.</p><p>In <ref type="bibr" target="#b10">[9]</ref> it is shown that any graph of size N can be pebbled using only O(N/log N) 1 pebbles, and in <ref type="bibr" target="#b20">[19]</ref> a proof is given that for a certain graph family, ~(N/logN) pebbles are necessary to pebble all vertices.</p><p>Recently interest has arisen in the study of precise time-space trade-offs in the pebble game. The rationale is that space savings are only feasible if the corresponding sacrifice in computing time is reasonable. It is of interest to know how much the time increases as the amount of available space, that is, pebbles, is decreased.</p><p>The results given in <ref type="bibr" target="#b10">[9]</ref> and <ref type="bibr" target="#b20">[ 19]</ref> limit the range of interest for S to t2(N/log N) = S -N. Two trivial observations about the pebbling time impose a corresponding limitation on the range of interest for T.</p><p>(l) Any graph of size N can be pebbled with N pebbles in time N (in topological order). (2) If a graph G of size N can be pebbled with S pebbles at all, then it can be pebbled with S pebbles in time (For the proof of (2) observe that the sum in (2) equals the number of different configurations of at most S pebbles on G, and therefore any strategy for pebbling G whose length is greater has to repeat some configuration and can thus be shortened.)</p><p>The range of interest for T is thus 2 ~r ~ T ~_ N.</p><p>Clearly T has to increase if S is decreased. The main open question in this area is how much T increases as S is decreased from N toward f~(N/log N). It is reasonable to make the following conjecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TRADE-OFF CONJECTURE. There are graphs of size N that can be pebbled with O(N/log N) pebbles only in a time that grows superpolynomially in N.</head><p>Theoretical computer science often assumes that polynomial-time algorithms are feasible, whereas algorithms whose time complexity exceeds every polynomial are not. In this sense the conjecture asserts that there are graphs for which space savings of S = O(N/log N), though possible, are infeasible.</p><p>If the Trade-off Conjecture is true, it makes sense to look for a function Sj(N) such that ~2(N/log N) &lt;_ Sa(N) &lt;_ N and Sa(N) has the following two properties: (a) If S &gt; clSj(N), then each graph of size N can be pebbled with S pebbles in time T, where T grows only polynomially in N. (b) If S &lt;_ c2Sj(N), then there are graphs of size N that can only be pebbled with S pebbles in superpolynomial time.</p><p>(Here cl, c2 &gt; 0 are suitable constants.) The threshold function Sj(N) locates the asymptotic range for S where the "jump" from polynomial to superpolynomial time occurs in the pebble game. Space savings of S &gt;--ClSj(N) are always feasible, whereas there are graphs for which space savings of S &lt;_ c2Sj(N) are infeasible. (Note that because of the asymptotic nature of the analysis, Sj(N) is not uniquely defined. With any function Sj(N) that fulfills properties (a) and (b) above, any function that is O(Sj(N)) also fulfills the properties. That is, the location of the "jump" from polynomial time to superpolynomial time can only be defined to within a constant factor.) Not much progress has been made heretofore toward proving the Trade-off Conjecture. Time-space trade-offs for natural and constructible graph families are discussed in <ref type="bibr" target="#b2">[1,</ref><ref type="bibr" target="#b25">24,</ref><ref type="bibr" target="#b27">26]</ref>. However, all these families can be pebbled with S = O(N/log N) pebbles in linear time.</p><p>Graph families whose pebbling time increases explosively from linear to superpolynomial at a certain point, as the number of available pebbles is decreased, are discussed in <ref type="bibr" target="#b7">[6,</ref><ref type="bibr" target="#b13">12,</ref><ref type="bibr" target="#b19">18,</ref><ref type="bibr" target="#b35">34]</ref>. However, this point lies in the range S = o(N/logN), and for S = O(N/log N) these graphs can be pebbled in linear time.</p><p>In <ref type="bibr" target="#b23">[22]</ref> Pippenger proves the most dramatic time-space trade-off known heretofore for a family of graphs that is straightforward and can easily be constructed. It has the form</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N 1 N T = ~-og~-~ + O(N).</head><p>For S = O(N/logN) we have T = ~(NloglogN).</p><p>Tompa <ref type="bibr" target="#b31">[30]</ref> and Reischuk <ref type="bibr" target="#b25">[24]</ref> discuss families of graphs that are much harder to construct but have more dramatic time-space trade-offs for S --~(N/log N). However, none of the lower bounds they prove reach</p><formula xml:id="formula_0">T = ~(Nl+C),</formula><p>for any c &gt; 0, if S = O(N/log N). They are thus far from exhibiting a supernomial blowup in time in the relevant range of S. Independently from the work presented here Reischuk <ref type="bibr" target="#b25">[24]</ref> proves an upper bound on Sj. He shows that any graph of size N can be pebbled with S = f~(N/logrN) pebbles (r E N) in time T, where 20((N/S) log (N/S))</p><formula xml:id="formula_1">T = N2 (l)</formula><p>Therefore we cannot expect to find a graph of size N whose pebbling with S &gt;_ cN/log k)g log N pebbles takes superpolynomial time (c &gt; 0 is any positive constant). Thus,</p><formula xml:id="formula_2">So = o(N/loglog logN).</formula><p>(It is possible that the tighter upper bound</p><formula xml:id="formula_3">S~ = O(NlogloglogN/loglogN)</formula><p>is implied by Reischuk's algorithm. However, this bound, which would follow directly from an analysis of eq. ( <ref type="formula">1</ref>), cannot be immediately inferred from Reischuk's result, because he proves eq. ( <ref type="formula">1</ref>) only for the values S ~-logan for r E N.) This paper proves the Trade-Off Conjecture, locates Sj, and analyzes a new, easily constructed graph family with a rather dramatic time-space trade-off.</p><p>Section 2 discusses an easily constructible graph family whose time-space tradeoff is more dramatic than that discussed in <ref type="bibr" target="#b23">[22]</ref>. The trade-off has the form</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ST = O(N2).</head><p>For S = O(N/logN) we have T--~2(NlogN).</p><p>Section 3 contains upper and lower bounds on the time-space trade-off for certain graphs called superconcentrators.</p><p>Section 4 analyzes the time-space trade-off for superconcentrators stacked in series. Such graphs give a two-parameter graph family with the time-space trade-off T is thus superpolynomial in N whenever S --o(NloglogN/logN). For S = O(N/logN) we have T = N a~l°gl°gN~.</p><p>Section 5 locates S~ by proving a time-space trade-off for pebbling general graphs of the form</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2o(N/s) T= S2</head><p>Thus Sj ---O(N/loglogN). For S = O(N/logN) we have T---2 m'l', that is, T is exponential.</p><p>The results in Section 5 dominate those in Section 4, Nevertheless, the results in Section 4 are interesting in their own right. Stacks of superconcentrators occur often in complexity theory (see <ref type="bibr" target="#b11">[ 10]</ref> and <ref type="bibr">[3 l]</ref>). The proof method used in Section 4 is more powerful than the one used in <ref type="bibr" target="#b19">[18]</ref>, and this additional power is necessary to prove the superpolynomial time-space trade-off.</p><p>There is a variation of the pebble game that has been studied in <ref type="bibr" target="#b4">[3,</ref><ref type="bibr" target="#b8">7,</ref><ref type="bibr" target="#b16">15]</ref>. In this variation, pebbles of two colors, black and white, are available. Three additional rules govern the use of white pebbles:</p><p>(iv) A white pebble can be placed on an empty vertex at any time. (v) A white pebble can be removed from a vertex v if all its immediate predecessors are pebbled. (vi) If all but one of the immediate predecessors of a vertex v having a white pebble are pebbled, then the white pebble can be moved from v to its unpebbled immediate predecessor.</p><p>The object of the game is to finish with no pebbles on the graph, starting with no pebbles on the graph and pebbling each vertex at least once. The space S required by the pebbling is the maximum number of pebbles ever on the graph simultaneously, and the time T required is the number of applications of rules (ii)-(iv) and (vi), that is, the number of pebble placements. Again the size N of the graph is the number of its vertices. We call this game the black and white pebble game. The white pebbles represent nondeterministic guesses during a computation. They are easy to place, since guesses can easily be made, but hard to remove, since guesses have to be checked. In this sense the black and white pebble game is the nondeterministic version of the usual (black) pebble game. Cook and Sethi <ref type="bibr" target="#b4">[3]</ref> introduce the black and white pebble game and prove a lower bound on the number of black and white pebbles necessary to pebble a certain graph family called pyramid graphs. Meyer auf der Heide <ref type="bibr" target="#b16">[15]</ref> extends this lower bound to all directed acyclic graphs: If a graph can be pebbled with k black and white pebbles, then it can be pebbled with (k 2 -k)/2 + 1 black pebbles. Gilbert and Tarjan <ref type="bibr" target="#b8">[7]</ref> show that the ~(N/logN) space lower bound from <ref type="bibr" target="#b20">[19]</ref> carries over to the black and white pebble game (with different constant factors). The main open questions in this area are the following.</p><p>(1) Are there graphs for which black and white pebbles save more than a constant factor of space over black pebbles? (2) If so, what is the maximum savings possible? (It is shown in <ref type="bibr" target="#b16">[15]</ref> that it has to be of the order of the square root.)</p><p>In addition to these questions, the study of time-space trade-offs in the black and white pebble game is of interest.</p><p>Although we are primarily interested in the black pebble game, it turns out that for the three graph families we consider in this paper the time-space trade-offs in the black and white pebble game are straightforward extensions of the time-space tradeoffs in the black pebble game. We therefore include proofs of the following results.</p><p>In Section 2 a time-space trade-off of the form \sv is derived for pebbling bit-reversal graphs with black and white pebbles.</p><p>In Section 4 it is shown that the time-space trade-off for pebbling stacks of superconcentrators with black and white pebbles is asymptotically identical to the one for usmg only black pebbles, that is, it has the form In Section 5 it is shown that the time-space trade-off for pebbling general directed acyclic graphs with black and white pebbles is asymptotically identical to the one for using only black pebbles, that is, has the form</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2O(N/S) T= S2</head><p>A summary of the research results presented here has been published in <ref type="bibr" target="#b12">[11]</ref>. -t-~ r z q "r 4 q q "r r r s q "r~'r, "~z "q3 rt4x't5 "qs ~12345678910 tt1215141516~ N=16, 7r= 101851527391012166 41114,' FXG. 1 A typical permutation graph. A permutation graph on N elements has 2N vertices and a maximum indegree of 2. One class of permutation graphs has already been studied in <ref type="bibr" target="#b2">[1,</ref><ref type="bibr" target="#b9">8,</ref><ref type="bibr" target="#b27">26]</ref>. Sometimes called ladder graphs, they correspond to the permutation ~r defined by ~r(k) = N + 1 -k and represent the memory allocation scheme in linear recursive programs. One can pebble ladder graphs fairly quickly: We have T --~0(N) only if S = N °~1}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Permutation Graphs</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">THE UPPER BOUND IN THE BLACK PEBBLE GAME.</head><p>It is straightforward to derive an upper bound on the time-space trade-off for pebbling permutation graphs. FACT 2.2.1. Each permutation graph can be pebbled with two pebbles.</p><p>Indeed, this fact is a special case of the following more general result. LEMMA 2.2.2. For each permutation graph on N elements an upper bound on the time-space trade-off in the black pebble game is given by N 2 T &lt; _ +N. S-1 PROOF. Assume that S pebbles are available. Reserve one pebble for the output path. In at most N steps, pebble the vertices {I~-1~1) ..... o~-~(s-1} on the input path. Then in S -1 steps, pebble *s-1 with the pebble reserved for the output path. Move the pebbles on the input path in N -S + 1 more steps as necessary to pebble the vertices {i~-~(s} ..... O'¢r-1(2S-2) on the input path.</p><p>This can be done as follows. The S -1 pebbles on the input path divide it into S intervals of vertices. All intervals but the first are such that the first vertex in the interval is pebbled and all other vertices in the interval are not pebbled. The first (perhaps empty) interval is entirely free of pebbles. Let C be the set of the S -1 vertices on the input path to be pebbled next. We will pebble C in order from smallest to largest vertex. For each vertex v E C that is in the first interval there is another interval that does not contain any vertex in C. The pebble at the low end of this interval can be used to pebble v. When there is no vertex left to be pebbled in the first interval, we can use the pebble on the next higher interval to pebble the first vertex in C that is in this interval. If there is more than one vertex to be pebbled in this interval, then we can again use pebbles from other intervals that do not contain 0' 1 0" 5 0" 5 0" 7 0" 9 0~1 0'~3 0~5 0"17 0"19 0"2t 0"25 0"25 0"27 0"29 ¢T.5~ TO r2 14 ~6 ~a zo z2 z4 z6 za 3o T4 T6 Te %0 "l]12 T, T, T, T, "l;, T, "C T, T-. rl r3 T 5 T 7 T 9 T1 t T13 TI5 Tt7 TI9 2"21 T23 T25 T27 2"29 "l"31 1093 elements of C. Continuing in this fashion, we can pebble C by placing pebbles on successively larger vertices on the input path. In this process, only vertices that started out unpebbled are pebbled, and each vertex is pebbled at most once. Since S -1 vertices start out pebbled, at most N -S + 1 placements are made.</p><p>Use S -1 more steps to pebble the vertex ~'2s-2 on the output path. Continue in an analogous fashion.</p><p>This strategy pebbles eN in [N/(S -1)] phases, where each phase uses at most N -S + 1 placements of pebbles on the input path, except that the first phase may use N placements. Furthermore, exactly N placements are made on the output path. Thus For ladder graphs this upper bound is not at all tight. The question arises whether there is a family of permutation graphs for which this bound is tight up to a constant factor. Such a family would be interesting because it would in some sense represent the permutations that are most difficult to realize in serial computation schemes with restricted storage capacity. Section 2.3 shows that the bit-reversal permutation is such a permutation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T&lt;_(N-S+I</head><p>2.3 THE BIT-REVERSAL PERMUTATION. Let 0 __ N --2 n, and for convenience let the set to be permuted be the set I = {i[0 __ i &lt; N}. Let bn be the bijective mapping bn: I ~ {0, 1 }" where bn(j) is the binary string of length n representing the number j. Definition 2.3.1. Let b~(j) = an-1 ... ao, where each a, is either 0 or 1. The bit reversal ofj (denoted by rev~(j)) is defined to be the number j' such that b,(j') = a0 ... an-1. Figure <ref type="figure" target="#fig_2">2</ref> shows the bit-reversal graph on N = 32 elements.</p><p>The bit-reversal permutation has the property that it scatters adjacent numbers approximately evenly over the interval I. This property is the key to the following lower-bound proof. PROOF. The proof is trivial for S &gt; N/4. Thus assume that S &lt;--N/4. Choose the integer s such that 2S _&lt; 2 * &lt; 4S. Let the output path be divided into 2 n-s intervals of length 2 ~. The jth interval Ij (0 &lt;__ j &lt; 2 "-8) consists of the vertices "i'j2s , . . . , "r(j+l)'2*--l.</p><p>Let zj be the first time (i.e., the number of the first move) that a pebble is placed on ~'(~+1)~-1, that is, on the highest vertex in Ij. Let z-1 -0. Then zj &gt; zj_~ for 0 _ j &lt; 2 ~-'. In order to fred a lower bound on z~ -zj-1 we observe that at time z~_l the interval Ij is pebble-free and thus all 2" vertices in 1j have to be pebbled between zj-1 and zj. By definition of the bit-reversal permutation the immediate predecessors on the input path of the vertices in 1j divide the input path naturally into 2" -1 intervals of length 2 ~-~. (The immediate predecessor of a vertex in 1j defines the high end of an interval. The intervals at the ends of the input path are disregarded.) At time zj-~ at most S -1 pebbles are on the input path. Thus at least 2 s -1 -(S -1) _&gt; S intervals are pebble-free at Zj-x. All of them have to be pebbled completely before zj. This takes at least S. 2 n-" &gt; N/4 placements. Therefore zj -zj_~ &gt; N/4 for 0 &lt;_ j &lt; 2 ~-', and thus before time z2n-i at least 2"-'N/4 &gt; N~/16S placements have to occur. [] The above method for obtaining lower bounds on time-space trade-offs can also be used to prove the lower bound in <ref type="bibr" target="#b23">[22]</ref>, eliminating the somewhat complicated balance-of-payments argument used there.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">PEBBLING THE BIT-REVERSAL GRAPH WITH BLACK AND WHITE PEBBLES. If</head><p>we are allowed to use black and white pebbles to pebble the bit-reversal graph, then the vertices on the output path do not have to be pebbled in sequence. Rather we can place a certain number of white pebbles on the output path at the beginning and then pebble the intervals thus created on the output path independently of each other. If we use this idea, we can exploit a regularity of the bit-reversal permutation to speed up the pebbling so that T=O -~ +O(N). PROOF. Let k be such that 3.2 k _&lt; S &lt; 3.2 k+'. Put 2 k white pebbles on the outputs ¢o, ¢2,-k, ~'2.2~-k, ~3 2 --k ..... ¢(2*-1) 2~-*. This partitions the output path into 2 k intervals of length 2 "-k. The jth interval is the interval [~2n-,, "r(j+m--k-,] for 0 __ j _&lt; 2 k. Each of these intervals we consider to be broken up into 2 "-2k chunks of length 2 k. The ith chunk of the jth interval consists of the vertices [1"jz~-,+,zk, ~'~-k+(,+~)~-X] for 0 __ i all intervals. We use 2 k more black pebbles on the input path to be able to pebble each chunk in one sweep.</p><p>Formally, we assume inductively on i that the output vertices just before the beginning of the ith chunks in all intervals, that is, the vertices Tj2n-k+,2k-1 for all j such that 0 _ j &lt; 2 k, have black pebbles on them. (In the initial case i = 0r the first vertex on each 0th chunk has a white pebble on it, and the argument proceeds in the same fashion.) We rearrange the 2 k pebbles on the input path in N -2 k steps (N steps in the 0th phase) so that they are on the vertices</p><formula xml:id="formula_4">Orevn(revk(O)2n-k + t2k), arevn(revk(O)2n-k + t2 k + 1), • • • , arevn(revk(O)2n-k + (~ + 1)2 k --1).</formula><p>This enables us to sweep the black pebble on the revk(0)th interval across the ith chunk. Then, by advancing each pebble on the input path one vertex we pebble the vertices</p><formula xml:id="formula_5">~reVn(revk(1)2n-k + ~2k), OreVn(revk(1)2n-k + ~2 k + 1)~ • • • ~ areVn(revk(1)2n-k + (g+ 1)2 k --1)</formula><p>and can now sweep the black pebble on the revh(1)st interval across the ith chunk. Advancing pebbles on the input path in a suitable manner allows us to pebble the ith chunks of all j intervals in the order j = rev~(0), revk(l), revk(2) ..... revk(2 k --1). It is easy to see that pebbling the ith chunks of all j intervals takes 2" -2 k + (2 k -1)2 k placements on the input path if i # 0 and 2" + (2 k -1)2 k placements on the input path if i = 0.</p><p>After all chunks are pebbled in this way the pebbles end up in a configuration that allows the white pebbles to be taken off the graph. The whole pebbling takes time The upper bound given in Corollary 2.4.2 can be matched asymptotically with a lower bound whose proof uses the characteristic property of the bit-reversal permutation mentioned in Section 2.3.</p><formula xml:id="formula_6">N 2 2 n + (2 n + (2 k -1)2k)2 n-2k --2k(2 n-2k --1) __ 36 -~ + 3N. [] COROLLARY 2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THEOREM 2.4.3. Pebbling the bit-reversal graph on N elements with S &gt;-2 black and white pebbles takes time N 2 T&gt; 3--~+ N.</head><p>PROOF. For S &gt; N/6, the theorem holds trivially. Thus let S &lt;-N/6. Let s be the integer such that 3S _&lt; 28 &lt; 6S. As in Theorem 2.3.2, the output path is considered as divided into 2 n-8 &gt; N/6S intervals I s (0 _&lt; j &lt; 2 n-s) of length 28. The argument given in the proof of Theorem 2.3.2 now has to be modified, however, since the intervals do not have to be pebbled in sequence.</p><p>Define zo = 0. Let the set Y~0 be the empty set of intervals. For I &lt;_ i &lt;_ [N/6S2], inductively define z, to be the first time after z,-1 at which any interval that is not in X,-1 has been pebbled and unpebbled completely. Denote this interval by/s,. At zl a pebble is removed from I~,, and at most S -1 other intervals have pebbles on them. Add these intervals and Ij, to X,-A to define the set X~. Note that X, has at most iS elements, and thus for i &lt;_ [N/ <ref type="bibr">6S 2]</ref> the interval Ij, exists.</p><p>Analogously to the proof of Theorem 2.3.2, we will now argue that between z,-1 and z, more than N/6 placements have to occur. We start by observing that at time z~-i the interval Ij, is pebble-free, and thus all of/j, has to be pebbled and unpebbled between z,-1 and z,. The immediate predecessors of the 2 ~ vertices inI~, on the input path divide the input path into 2 * -1 intervals of length 2 n-~. All but S -1 of these intervals are pebble-free at time z,-1, and all but S -1 (different) intervals are pebble-free at time z~. Thus at least 2" -(2S -2) &gt; S intervals on the input path are pebble-free at both z,-1 and z,. All these intervals have to be pebbled and unpebbled completely between z,-1 and z,. This takes at least S. 2 n-~ &gt; N/6 placements on the input path. Thus, before zrmos21, more than 6-~ 6 --36S 2 placements on the input path have to occur. At least N more placements occur on the output path. [] Bit-reversal graphs are among the few known examples that show a difference between the black pebble game and the black and white pebble game. The improvement due to using black and white pebbles relies on a regularity of the bit-reversal permutation that allows us to pebble certain chunks on the output path with only a little repebbling on the input path. It is our conjecture that there are permutations that do not exhibit any regularity of this kind and for which the time-space trade-off for black and white pebbles has the same form as for black pebbles, namely,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ST--O(N2).</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Superconcentrators</head><p>3.1 INTRODUCTION. Proving the Trade-Off Conjecture means finding graphs of arbitrarily large size that are very hard to pebble. As pointed out in Section l, people have been looking for such graphs for quite some time. Even though nobody was able to approach superpolynomial lower bounds, some graph families have been studied that are fairly hard to pebble (see <ref type="bibr" target="#b25">[24]</ref>, <ref type="bibr" target="#b31">[30]</ref>, and Section 2 of this paper). A natural way of constructing graphs with even more dramatic time-space trade-offs is to select one of these graph families and use its graphs as basic building blocks in a construction scheme that connects them in a way that amplifies their bad properties. For reasons that will become apparent later on, superconcentrators are a suitable graph family for this purpose. Definition 3. I. 1. A directed acyclic graph C with bounded indegree, N inputs, and N outputs is called an N-superconcentrator ff for every k such that 1 &lt;_ k ___ N and every pair of subsets V1 of k inputs and V2 of k outputs there are k vertexdisjoint paths connecting the vertices in V1 to the vertices in V2.</p><p>Note that we do not assume the ability to specify which input is connected to which output. Definition 3.1.1 shows that superconcentrators have to be fairly dense graphs in order to be able to achieve the routing necessary to join inputs to outputs in all required ways. It is therefore interesting to fred out how many edges are necessary to build N-superconcentrators. It is relatively easy to construct N-superconcentrators with a maximum indegree of 2, a depth (i.e., length of the longest path) of O(log N) and O(NlogN) edges (and vertices). Figure <ref type="figure" target="#fig_6">3</ref> shows such an N-superconcentrator for N = 16. It is constructed by putting two FFT-graphs back to back and fulfills the even stronger property that we are able to specify which input is to be connected to which output. (Such graphs are called connectors.)</p><p>Valiant <ref type="bibr" target="#b33">[32]</ref> shows that N-superconcentrators exist that have only O(N) edges. We call such superconcentrators linear. Valiant bases his result on a paper by Pinsker <ref type="bibr" target="#b21">[20]</ref>. Pippenger <ref type="bibr" target="#b22">[21]</ref> gives an improved construction of linear superconcentrators. His N-superconcentrators have a maximum indegree of 9, a depth of O(logN), and at most 40N edges (and vertices). However, his construction involves a step that is based on a probabilistic counting argument. Recently Gabber and Galil <ref type="bibr" target="#b6">[5]</ref> explicitly constructed linear superconcentrators.</p><p>As mentioned in Section 1, we include a treatment of the black and white pebble game in our results, since it is a straightforward generalization of the black pebble game. Specifically, we show all lower bounds using black and white pebbles and all upper bounds using black pebbles. Since the bounds match each other asymptotically, this proves asymptotically equal time-space trade-offs for both the black and the black and white pebble game. Section 3.2 discusses a lower bound and Section 3.3 discusses an upper bound on the time-space trade-off for pebbling superconcentrators. <ref type="bibr" target="#b31">[30]</ref> Tompa gives a lemma that he uses to prove lower bounds on pebbling superconcentrators. We generalize his lemma to the black and white pebble game. Let us say that we pebble r outputs of an N-superconcentrator in a time interval Z if either Z contains r moves that pebble different outputs of the superconcentrator or r __-N and at the end of Z all outputs of the superconcentrator are pebbled. LEMMA 3.2.1 (BASIC LOWER BOUND ARGUMENT, BLBA). In order to pebble Sb 4r Se dr-1 outputs of an N-superconcentrator, starting with a configuration of at most Sb black and white pebbles on the graph and finishing with a configuration of at most Se black and white pebbles on the graph, at least N -Sb --Se different inputs of the graph have to be pebbled and unpebbled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">THE LOWER BOUND IN THE BLACK AND WHITE PEBBLE GAME. In</head><p>PROOF. The proof is indirect. Assume that there are Sb + Se + I outputs that can be pebbled starting with Sb pebbles and finishing with Se pebbles without both pebbling and unpebbling any of Sb + Se + I inputs. Since the graph is a superconcentrator, there are Sb + Se + 1 vertex-disjoint paths connecting these inputs to the outputs to be pebbled. At least one of these paths starts out and ends up pebble-free. Its output has to be pebbled. Since the path ends up pebble-free, its input has to be pebbled and unpebbled. This is a contradiction. [] COROLLARY 3.2.2. Pebbling an N-superconcentrator with S black and white pebbles takes at least ft(N2 / S) pebblings of the inputs.</p><p>PROOF. Iterate the BLBA LN/(2S + l)J times. [] By Corollary 3.2.2 it is asymptotically at least as hard to pebble superconcentrators as it is to pebble bit-reversal graphs. Thus superconcentrators are a graph family with a rather dramatic time-space trade-off. However, this fact alone does not make superconcentrators good building blocks for constructing bad graphs. Bit-reversal graphs, for instance, are not suited for this purpose. The reason why superconcentrators are an appropriate family to use in the construction of bad graphs lies in the existence of the Basic Lower Bound Argument. Such an argument does not hoM for bit-reversal graphs. The BLBA holds for superconcentrators because their inputs (respectively, outputs) are indistinguishable. It is this symmetry and in particular its formulation through the BLBA that we apparently have to exploit if we want to achieve superpolynomial lower bounds on pebbling times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">THE UPPER BOUND IN THE BLACK PEBBLE GAME. In this section we consider special classes of superconcentrators that can be pebbled efficiently.</head><p>There are classes of superconcentrators for which the lower bound proved in the last section is tight up to a constant factor. An example of such a class is the class of superconcentrators constructed by putting two FFT-graphs back to back (see Figure <ref type="figure" target="#fig_6">3</ref>), as can be proved by an argument similar to the one given in <ref type="bibr" target="#b27">[26]</ref>. However, as of now a similarly efficient pebbling strategy for linear superconcentrators is not known.</p><p>In <ref type="bibr" target="#b22">[21]</ref> Pippenger gives a recursive construction that he uses to prove the existence of linear superconcentrators. Recently Gabber and Galil combined Pippenger's construction with ideas of Margulis <ref type="bibr" target="#b15">[14]</ref> to construct linear superconcentrators explicitly. Before giving Pippenger's construction we have to introduce another graph concept.   A schematic representation of this construction is given in Figure <ref type="figure">4</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF. The proof is a straightforward induction on N. []</head><p>In <ref type="bibr" target="#b22">[21]</ref> Pippenger proves the existence of (n, 6, 4, 6)-linear concentrators and thus, by the above definition, also the existence of (N, 6, 4, 6)-linear superconcentrators. He shows that these superconcentrators have 39N + O(logN) and edges and never more than 40N edges.</p><p>Recently Gabber and Galil <ref type="bibr" target="#b6">[5]</ref> extended ideas of Margulis <ref type="bibr" target="#b15">[14]</ref> to construct (n, 112, 16, 17)-linear concentrators explicitly. Their construction involves additional technical constraints (In~02] has to be a perfect square) and leads to linear N-superconcentrators with 3825N + O(q"N) edges.</p><p>We will give a pebbling strategy that pebbles (N, x, 0], 02)-linear superconcentrators using S = ~2(log N)   Let i _&gt; 0, and if i &gt; 0, then let i be such that h'-l(N) &gt; 01. (This ensures that the recursion in DefiniUon 3.3.2 can be applied ~ times to C(N, r, 01, 02).) Let C,(N, x, 01, 02) be the graph which is created from C(N, x, 01, 02) by deleting all the edges in the graph C(X'(N), x. 01, 02) that occurs in the middle of C(N, r, 01, 82). Note that if/= 0, then C,(N, x, 01, 02) is the empty bipartite graph with N left and N right vertices, and if i &gt; 0, then C,(N, x, 01, 02) follows the same recursion as in Definition 3.3.2, except that the graph cO~(N), r, 01, 02) is replaced by the graph C,-I(;~(N), x, 0a, 02). Figure <ref type="figure" target="#fig_13">6</ref> illustrates the graph C,(N, ~, 0a, 02) for i = 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IDENTIFICATION OF VERTICES</head><p>Because permanent pebbles are kept on the output vertices of C(~J(N), x, 81, 82)</p><p>in phase 3, it takes at most as long as it takes to pebble r outputs of the graph C,(N, x, 8j, 82).</p><p>We will find upper bounds for the time needed for phases 1 and 3 by a relatively crude argument that applies to general directed acyclic graphs G with depth d. Then we will apply this result to Gj,~ and Cj(N, x, 81, 82), both of which have a depth d = O(log N).</p><p>Let G be an acyclic graph with depth d. We can pebble G by successively pebbling all its outputs. Let ~" be an output of G. Pebbling ~" means pebbling the graph G(z) induced by all vertices from which ¢ is reachable. We can pebble G(0-) with O(d) pebbles using the procedure DEPTH-FIRST-PEBBLE given in <ref type="bibr" target="#b20">[19]</ref>. In order to find an upper bound for the time needed to pebble G(~-) we investigate the following trees. FACT 3.3.5. Each strategy for pebbling the root of U~ in time T induces a strategy for pebbling the output • in G in a time which does not exceed T. The strategy for pebbling G pebbles a vertex v whenever the strategy for pebbling U6 pebbles an image of v and at the same time no other image of v in UG is pebbled. A pebble is taken off of v in G when apebble is taken off an image v' ofv in U6, andno other image ofv in UG is pebbled. Therefore a vertex v in G has a pebble exactly when one of its images in Uo has a pebble. FACT 3.3.6. DEPTH-FIRST-PEBBLE pebbles any tree of depth d in linear time using O(d) pebbles (see <ref type="bibr" target="#b20">[19]</ref>).</p><p>From the above facts we can infer that the size of U6 gives an upper bound on the time necessary for pebbling G with O(d) pebbles. Let us first bound the size of the unfoldings of the graphs Gja(z) for each output T of G~,I. </p><formula xml:id="formula_7">L(i) &lt;_ 1 + mc'L(i -1), V(i) &lt;--V(i -1) + icK'L(i --1) + 2.</formula><p>PROOF. The case i = 0 is trivial. Assume t &gt; 0. In order to bound the size of the unfolding of C,(N, K, 01, 02)(~') we have to trace all possible paths backward from in C,(N, ~, 01, 02) and bound the multiplicities introduced by the indegrees of vertices on the different levels.</p><p>For L(i) one leaf is contributed by the input of C,(N, ~, 01, 02) which corresponds to ~. The other leaves result from the three maximum multiplicities introduced by (;2 (at most ~ leaves), C,-I(h(N), ~¢, 01, 02) (at most L(i -1) leaves), and G1 (at most ~' leaves).</p><p>For 1I(0 two vertices are contributed by ,r and its corresponding input of C,(N, ~, 01, 02). Since G2 has an indegree of at most ~, • is connected to at most ~ outputs of C,-~(A(N), K, 01, 02). Each of these outputs contributes a tree with at most V(i -1) vertices and at most L(i -1) leaves. Since the maximum indegree of G1 is ~', each leaf of C,-I(A(N), ~, 02, 02) is connected to at most ~' inputs of Q(N, K, 0~, 02). Therefore there are at most K(V(i-1) + ~'L(i-1)) + 2 vertices in the unfolding of C~(N, t¢, O1, 02)(~), which proves the lemma. []</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Time-Space Trade-offs in a Pebble Game</head><p>In order to solve these recurrences we give the following general theorem. </p><formula xml:id="formula_8">T(i) &lt;_ aT(i -l)+cb ~ if i &gt; O, T(O = O(b') if a &lt; b T(i) = O(ib') if a = b T(i) = O(a') if a &gt; b.</formula><p>PROOF. It can easily be proved inductively that</p><formula xml:id="formula_9">T(i)=a'T(O)+cb'~.o_&lt;v_&lt;,_l (b) ~"<label>(4)</label></formula><p>Ifa &gt; b, then both terms in (4) exhibit equal growth and T(0 ---O(ai). Ifa = b, then the second term in (4) dominates T(i), and T(i) = O(ib'). If a &lt; b, then the second term in (4) dominates T</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(i), and T(i) = O(b'). []</head><p>The recurrences in Lemma 3.3.9 are now easily solved.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Stacks of Superconcentrators</head><p>4.1 INTRODUCTION. In order to obtain more dramatic time-space trade-offs, we shall consider graphs composed of several superconcentrators connected in some way. The most straightforward way to build such graphs is to stack several suporconcentrators in series..This approach is motivated by results in <ref type="bibr" target="#b19">[18]</ref> and <ref type="bibr" target="#b25">[24]</ref>, and it yields graphs for which we can prove the Trade-off Conjecture. The proof is, however, substantially more involved than the construction itself. We are here--as often in the theory of computation--confronted with an easy construction whose properties are hard to prove.</p><p>The graph family we consider in this section has two parameters and is defined as follows.</p><p>Definition 4.1.1. Let n ~_ 6. For i such that 1 _ i __ k, let Ci be a copy of Pippenger's (n, K, 01, 82)-linear superconcentrator. Let C(n, k) be the graph created by joining the outputs of C, to the corresponding inputs of C~+I with directed edges (1 __ i &lt; k). The graph C(n, k) has at least 2nk and at most 40nk and thus O(nk) vertices. Figure <ref type="figure">7</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>schematically shows C(n, k).</head><p>As we prove in Section 4.  <ref type="bibr" target="#b7">(6)</ref> This shows that for both the black and the black and white pebble game, the family of graphs C(n, k) has a time-space trade-off of the form</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[ N\ O(N/s)</head><p>Analysis of this formula shows that if S = O(N/logN), then T = N a°°gi°gN).</p><p>Furthermore, T is superpolynomial as long as S = o(Nloglog N/log N). The Trade-off Conjecture is thus proved. Furthermore, this time-space trade-off implies a lower bound on So (see Section 1) of the form</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sj = f~( N log log N/log N).</head><p>This lower bound does not match the upper bound on Sj that follows from Reischuk's studies <ref type="bibr" target="#b25">[24]</ref> and has the form</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sa ---o( N/log log log N).</head><p>In Section 5 we close the gap between these two bounds.</p><p>Note that the asymptotic lower bound (5), discussed in Section 4.2, can (with different constants) also be obtained for stacks of any linear superconcentrators. The asymptotic upper bound <ref type="bibr" target="#b7">(6)</ref>, discussed in Section 4.3, holds (with different constants) for all (n, K, 01, 02)-linear superconcentrators. This in particular implies that there are constructible graph families that realize the time-space trade-offs discussed in Section 4.  O(N/log N), then we would have proved the Trade-off conjecture using a simpleminded connection scheme (stacking) and a simple-minded proof (iteration of the BLBA). This cannot be expected and indeed is not the case. But the argument given in the proof of Theorem 4.2.1 can be improved considerably. This is because we did not take into account at all how the pebbles are distributed over C(n, k). Let us call a pebbling strategy fair if it distributes the S pebbles evenly over C(n, k) and only assigns IS/kJ pebbles to the superconcentrator C, (1 _&lt; i _&lt; k). In this case the argument given in Theorem 4.2.1 should go through, even if we substitute for S the quantity [S/kJ. We would then get a lower bound of the form Of course there may be many strategies that are not fair in this sense but concentrate great numbers of pebbles on different levels at different times. However, this means that on other levels of C(n, k) there will be fewer pebbles available at those times. If we analyze these interdependencies accurately enough, we will be able to tighten the bound given in Theorem 4.2.1 by substituting tighter estimates for the number of (locally available) pebbles in the individual applications of the BLBA in the proof of Theorem 4.2.1.</p><p>Let us start by considering the outputs of Ck as numbered in the order in which they are (first) pebbled. Let a be the time at which output i is pebbled (1 _~ i ~ n, z0 --0, zn÷l ffi number of the last move of the strategy). Let [z', z"] be the interval starting with move z' and ending with move z", inclusively. Let p, be the minimum number of pebbles on Ck after any of the moves in [z,-1, z,] (1 &lt;__ i _&lt; n, p,,+l = 0).</p><p>Observe thatp, -S for 1 _&lt; i _ n + 1. We will consider disjoint intervals of numbers [i, j] C <ref type="bibr">[1, n]</ref> which will represent disjoint time intervals [z{, zj'], where z" and z]' (z,-~ _ z~'-~ &lt; z{ &lt;_ z~) for 0 &lt; i _&lt; n are times that will be specified later. If convenient, we will not explicitly distinguish between <ref type="bibr">[i,j]</ref> and <ref type="bibr">[z{, zf]</ref>.</p><p>The disjoint intervals [i, j] will be chosen such that the BLBA can be applied on Ck to each of them. They will generally be of different lengths depending on the maximum number of pebbles on Ck during an interval. The objective is to fred a large number of intervals to which we can apply the BLBA with very tight space estimates.</p><p>The applications of the BLBA to the intervals will yield information about how many outputs of Ck-~ have to be pebbled and how many pebbles are available to do this. Thus we will be able to give a recursive relationship between the time necessary to pebble the outputs of C~ and the time necessary to pebble the outputs of Ck-1. Solving this recurrence completes the proof.</p><p>For this plan to be realizable the intervals [i,j] have to be "'good" according to the following definition. Definition 4.2.2. three requirements:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An interval [i,j]</head><formula xml:id="formula_10">j-i p, &lt;- 2 ' j-i pj+l ~ -- 2 ' j-i pk &gt; 8 C [ 1, n] is called good if it fulfills the following (7)<label>(8)</label></formula><p>for i &lt; k &lt;_j. <ref type="bibr" target="#b10">(9)</ref> Note that the length of each good interval is j -i + 1 _&lt; 8S. Good intervals are important because of the following lemma. PROOF. Assume that the interval [i, j] is good in the above sense. Then because of <ref type="bibr" target="#b8">(7)</ref> there is a latest time z' (z,-1 -&lt; z' &lt; z~) such that at most (j -0/2 pebbles are on Ck at z'. (Observe that move z, places a pebble on Ck, and therefore at time z~ -I there are fewer pebbles on Ck than at time z,.) Let x{ be the number of pebbles t ~_.Z ! on Ck at z'. Define z~ + 1. Furthermore, because of (8) there is an earliest time zj" (zj _ z 7 &lt; zj+0 such that at most (j -0/2 pebbles are on Ck at the time z;' (z" --z,,÷l). Let x 7 be the number of pebbles on Ck at z 7. (Observe that for 1 &lt; i _&lt; n we have z"a &lt; z', and thus ! H t?</p><p>[z~ 1, z jl ] and [z~, z~2 ] are disjoint if [il, jl] and [ie.fi] are disjoint.) During [z', zj ] exactly j -i + 1 outputs of Ck are pebbled starting with a configuration of x" and ending with a configuration of x;' pebbles on Ck. Because of ( <ref type="formula">7</ref>) and ( <ref type="formula" target="#formula_10">8</ref>) the BLBA can be applied. The application yields that at least n -x" -x~' inputs of Ck have to Furthermore, because of ( <ref type="formula">9</ref>), at all times during [z{, zf] more than (j -0/8 pebbles stay on Ch, and therefore at most S -1 -[(j -i)/8J pebbles are available for pebbling C1, ..., Ck-1. Since move z{ places a pebble on Ck, during [z { + 1, z;'] at least n -2S outputs of Ck-~ have to be pebbled using at most S -1 -/(j -/)/8J pebbles. [] Lemma 4.2.3 shows how we can apply the BLBA to a good interval and proceed inductively on k. The following purely combinatorial lemma provides us with the necessary statement about the abundance of good intervals. Let i be maximum such that pi -&lt; (r + 1 -0/4. (Such an i exists because i -= 1 is a candidate.) For k such that i &lt; k &lt;_ i + [(r + 1 -0/2J we have</p><formula xml:id="formula_11">r+ l-k r+ l-i-[(r+ 1-i)/21 r+ l-i pk &gt; 4 -- 4 -<label>8</label></formula><p>Also, since p, is integer,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>,[r+,_,j 2</head><p>We can inductively assume that the number of elements in [1, i -1] that can be covered by disjoint good intervals is at least</p><formula xml:id="formula_12">i--1 i--I 1Lr+l--i] 4 S -pt&gt;_ -- S - --- 4 "2</formula><p>We have to make a case distinction.</p><p>Case 1. Assume there is aj</p><formula xml:id="formula_13">~ [i + L(r + 1 -i)/2J, r] such thatps+~ -[(j -i)/2J.</formula><p>Let j be chosen to be the smallest such point. Then [i, j] is a good interval whose length is at least [(r + 1 -/)/2J + 1 and thus at least ,_, ,  we have m good intervals with lengths x, (1 _&lt; i &lt; m) and minimize over all possible choices of the intervals, we get the formula given in the theorem, l"l All that is left in order to fred a lower bound on the time-space trade-off for pebbling C(n, k) is to solve the above recurrence. This can be done using standard methods of calculus.</p><p>Our motivating discussion leads us to guess that T(n, k, S) &gt;_f(n, k, S), where</p><formula xml:id="formula_15">['nk~ k f(n, k, S) = n~-~) (12)</formula><p>and c -&gt; l0 is an appropriate constant, which turns out to be 64. This guess can be verified inductively. TrmOREM 4.2.6. If S &lt;-n/20, then (nk</p><formula xml:id="formula_16">T(n, k, S) &gt;-n~-~-S} . (<label>13</label></formula><formula xml:id="formula_17">)</formula><p>PROOF. The theorem is obviously true if k = 1. Thus assume that k &gt; 1. By the inductive hypothesis we have, after eliminating the floor function and substituting real variables y, = x,/8 (note thatf(n, k, S) is decreasing in S for S &gt; 0), is indeed asymptotically tight. This is the case, and a matching upper hound is proved in this section. The pebbling strategy that we use to estabfish the upper bound is derived from the strategy C-PEBBLE for pebbling (n, K, 01, 02)-linear superconeentrators (see Section 3.3).</p><formula xml:id="formula_18">T(n, k, S) &gt;_ rain ~ f(n, k -l, S -y,),<label>(14)</label></formula><p>Assume that S ~ ca klog n pebbles are given, where cl &gt; 0 is a sufficiently large constant. We define the following fair strategy STACK-PEBBLE that pebbles r outputs of C(n, k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>STACK-PEBBLE(r, k, S):</head><p>Permanently assign tS/kJ pebbles to C~ and the rest of the pebbles to C~ ..... Ck-~. Apply C-PEBBLE(r, [S/kJ) to Ck to pebble r outputs of Ck with its [S/kJ pebbles. Thts requires pebbling a certain number r' of inputs of Ck and thus pebbling (at most) the same number of outputs of C~-1. These outputs are pebbled by recurstvely applying STACK-PEBBLE(/, k -1, S -[S/kJ) to C~ ..... Ck-l. THEOREM 4.3.1. STACK-PEBBLE pebbles any r outputs of C(n, k) with S pebbles in time i'c2nk\ "'+a</p><formula xml:id="formula_19">"~ @ n o&lt;,&lt;~ k---1 (k 1" _ ~ -) ~----ff-) , (<label>16</label></formula><formula xml:id="formula_20">)</formula><p>where a = 1 + 2log~/~r, fl = logol/~x, and c2 &gt; 0 is a sufficiently large constant.</p><p>PROOF. In Section 3.3 it is shown that the pebbling strategy C-PEBBLE pebbles any r outputs of an (n, x, 01, 0z)-linear superconcentrator with [S/kJ pebbles in time Substituting ( <ref type="formula">19</ref>) into <ref type="bibr" target="#b19">(18)</ref> and adding the number of placements on Ck yields "t-r) Jr' '</p><formula xml:id="formula_21">I i\ ai.+,8 ag &lt;_r E +n ~ E l_~z-~k O~:~k--1 i ~\a~+fl + n ~ (k --1 ..Ic2mc~ _ ~ f [C2 nk~"'+/s &lt;r ~ c k + n Y. (k-)~---~) . l&lt;~:k O~k--1<label>(18) (19)</label></formula><p>[]</p><formula xml:id="formula_22">/ II13 FIG. 8. The decomposition of G in FAST-PEBBLE.</formula><p>Here is an informal statement of the recursive algorithm FAST-PEBBLE.</p><p>FAST-PEBBLE(G, S): I f m &lt; S, then pebble G in topological order. If m &gt; S, then parmion G into two disjoint parts, G1 (of size m 0 and OZ (of size m2), such that no edges run from G2 to G1 and</p><formula xml:id="formula_23">m c2S d + 2 m d + 2 -2 - -" T -&lt;-ml &lt;-T -c~S + 2 "</formula><p>(This partition can be found by starting with G1 -0 and successively adding vertices to GI in topological order until G1 has the desired size ) Figure <ref type="figure">8</ref> dlustrates the partition of G into OZ and Oz. Let E be the set of edges from G~ into G2. Case 1 (Small cut). If [ E I &lt;_ cl S, then partition the S pebbles into a set $1 of size [(1 -Cl)S] and a set $2 of size [clSJ. Do FAST-PEBBLE(G1, [(1 -cl)S]), using the pebbles in 31; while doing this, use the pebbles m $2 to permanently pebble all sources of edges in E. Then take the pebbles in Sl off GI and do FAST-PEBBLE(OZ, [(1 -cOS]) using the pebbles in Sv Case 2 (Big cut). If IEI &gt; c~3, then partition the S pebbles into two sets 31 (for use on G1 only) and $2 (for use on Oz only), each of size I(S -dp)/2J, and a pool P of special pebbles, of size dp (see Definition 5.2.1). Start doing FAST-PEBBLE(OZ, [(S -dp)/2J), and a pool e of special pebbles, of size dp (see Definition 5 2 1) Start doing FAST-PEBBLE(G2, [(S -dp)/2J), using the pebbles in Se. When a situation occurs where the output of an edge in E has to be pebbled whose inputs in GI are not all pebbled, then temporarily suspend the pebbling of C~. Do FAST-PEBBLE(G1, [(3 -dp)/2J), using the pebbles in 31, and leave the pebbles in P on all of the (at most dp) inputs of E that immediately precede the p outputs of E that have to be pebbled next. Then continue pebbling OZ.</p><p>Reischuk <ref type="bibr" target="#b25">[24]</ref> independently used essentially the same algorithm to prove his upper bound results. His parameters (especially the number of special pebbles) are different, however, and as a consequence his bound is not tight enough to match the lower bound proved in the next section.</p><p>We begin the analysis of FAST-PEBBLE by making some remarks about notation. Let FAST-PEBBLE be cared with arguments (G, S), where G has size m. We say that FAST-PEBBLE is cared on a problem of size (m, S). In the course of its execution, FAST-PEBBLE caRs itself recursively on the graphs G1 and G2. We denote the corresponding problem sizes by (m', S'), so that m' is either ml or m2 and Given a sufficient number of pebbles, FAST-PEBBLE will pebble any graph of size mo or less with no recursive calls. Thus mo defines the graph size threshold below which FAST-PEBBLE becomes trivial.</p><p>The following lemma estimates the size m' of the graphs in which FAST-PEBBLE calls itself recursively. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>by (A1). &gt;0</head><p>If m' = m2 and the cut is small, m d+2</p><formula xml:id="formula_24">m' &gt;---~ + c2S -ClS ---~ &gt;_ m + c2 -c~ - _&gt;m ~-c2- by(A2)</formula><p>&gt; 0 by (A1). D Lemma 5.2.3 implies that the algorithm terminates, assuming that the initial number of pebbles is large enough. It also implies that the algorithm can always split G into G1 and G2 satisfying the constraints on ml, since moving one vertex from G2 to G1 increases the size of G~ by between 1 and d + 1, and the allowed interval for m~, being of length d + 2, contains at least d + 1 nonnegative integers.</p><p>The number of pebbles necessary for FAST-PEBBLE to work properly is rain(m, cs(log(d + 2))m/logm). The following lemmas assume that at least this number of pebbles is available. [] Lemma 5.2.4 establishes the correctness of FAST-PEBBLE, assuming that each recursive subproblem has a sufficient number of pebbles. In order to prove this, and to derive a time bound on the algorithm, we need the following lemma. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S'-S</head><p>PROOF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Small cut:</head><p>We treat small and large cuts separately.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Suppose FAST-PEBBLE is applied to a problem of size (m, S) with S &gt;-min(m, cs(log(d + 2))m/logm). If FAST-PEBBLE calls itself recursively on a subproblem of size (m', S'), then S' &gt;-min(m', c~(log(d + 2))m'/logm').</head><p>Paoov. We must distinguish two cases.</p><p>Case 1 (m' --ml or the cut is small). By Lemma 5.   Thus the theorem can be applied inductively on all recursive calls. We have to make a case distinction corresponding to case 1 (small cut) and case 2 (big cut).</p><p>Case 1 (small cut). There is only one recursive call of FAST-PEBBLE on each of G1 and (72, both times with [(1 -cOS] pebbles. Thus</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T(G, S) &lt;_</head><formula xml:id="formula_25">T(Gx['(1 -c~)S'l) + T(G2, [(1 -ca)S]) &lt;_ 2d2m/'c3s)-~-lSc~g '/s-'~ --2m/(caS)-l~ c~/S-ca &lt;_ a ~'c7 o since d__ 2,</formula><p>~ j'2mlcaS--ltw ¢_~/S a ~c7 since micaS ~--1.</p><p>Case 2 (big cut). By the definition of FAST-PEBBLE, in the case of a big cut G2 is pebbled once with (S -@)/2 pebbles and G1 is pebbled at most IT(G2, [(S -dp)/2J)/p] times, namely, at most once for each p (consecutive) placements on G2. Thus, Applying the theorem inductively to the recursive calls and using Lemma 5. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I c6S</head><p>Eliminating the ceiling function, multiplying out, and collecting terms, we get</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>/1 T(G, S) --&lt; 2d 2~/~s~ ~Sc~ ~'/s °' + ~) ou \--~lcT]</head><p>.</p><p>Since m/S __ 1 and c7 and c8 fulfill constraint (A8), we get</p><formula xml:id="formula_26">T(G,S)&lt;_d~"°"-'S 1 +col/S]--/\/--c7 • (<label>25</label></formula><formula xml:id="formula_27">)</formula><p>The inequality <ref type="bibr" target="#b26">(25)</ref> differs from the desired formula <ref type="bibr" target="#b25">(24)</ref> only by an additional factor of (1 + l/c6)(m/S) on the baseline, the factor of 2 in the exponent of c7, and the subtraction of ca in the exponent of ca. The crucial step in the argument (and the step which requires T to grow as a double exponential in (m/S)) is to show that adding ca to the exponent of ca outweighs the cancellation of both the factor of (1 + l/c6)(m/S) on the base line and the factor of 2 in the exponent of c7. Formally, this is stated in the following fact, whose proof is again technical. </p><p>x considered as a function of x, has the following first derivative:</p><formula xml:id="formula_29">a bx ((lna)Onb)xb x -1).</formula><p>If this derivative is greater than 0 for all x _ 1, then a minimum of the function ( <ref type="formula" target="#formula_28">27</ref>) for x _ 1 is given by its value at x -1. If we substitute m Constraints (A8)-(A 10) assert that its derivative is positive for all m/S _~ I. Thus the minimum of ( <ref type="formula">28</ref>) is given by its value at m/S = I. By constraint (A7) this value is greater than (l + l/cr), which proves <ref type="bibr" target="#b27">(26)</ref>. [] We now continue the proof of Theorem 5.2.7. Using Fact 5.2.8 it follows that</p><p>(1)(m)</p><formula xml:id="formula_30">T(G, S) &lt;-d2m/c3S-lSc~ g'/s-~ 1 + &lt;_ d2"~mS-a Sc~"/s-~(c~-2) c~/s-~) &lt;_ d2mmS-lSc~/s.</formula><p>This completes the proof of the theorem. [] It should be mentioned that at the expense of the simplicity of the argument the constants in the upper bound given in Theorem 5.2.6 can be improved. However, we are mainly interested in the asymptotic behavior of the bound as described by the following corollary. In effect, Definition 5.3.2 numbers the superconcentrators from top to bottom in the bar graph of G(n, k). Figure <ref type="figure" target="#fig_42">10</ref> shows the bar graph of G(n, k) for k --4.</p><p>From now on we will denote the superconcentrator at level i by C,. We will say that C, follows Cj or that C: precedes C~ if C, is located below Cj in the bar graph of G(n, k), that is, if i &gt; j.</p><p>Even though we were able to motivate the definition of G(n, k) with observations about the graphs C(n, k), no parts of the lower bound proof for C(n, k) can be carried over to G(n, k). We have to arrange the iterations of the BLBA in a different fashion. The following definitions introduce the essential concepts for the lower bound proof for G(n, k). (a) The parent of C, is the highest level superconcentrator preceding (7, that is larger than C, (if such a superconcentrator exists, otherwise of the same size as C,). The transitive closure of the parent relation is called the ancestor relation. (b) The neighborhood of the superconcentrator C is the set of superconcentrators including C,, its parent, and all superconcentrators preceding C, and following its parent.</p><p>Definition 5.3.3 gives each level except the first one a parent and a neighborhood. The parent of C~ is larger than C,, unless C, is an n-superconcentrator, that is, of the largest size possible in G(n, k). (For example, in Figure <ref type="figure" target="#fig_42">10</ref>, C~7, (719, and C21 have the same parent C~e. The neighborhoods of C17, C19, and C2~ are the sets (C16, C17}, {Cae, C17, Cls, Ca9}, and {C16, C17, Cls, C]9, C20, C21}, respectively. The parent of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C29 is C15.)</head><p>Assume that S &lt;_ csn. In the lower bound proof we will again analyze the distribution of pebbles on the graph. Focusing our attention on level i of G(n, k), we will consider time intervals during which many outputs of some superconcentrator Cj (j &lt; i) preceding C, have to be pebbled while a lot of pebbles are bound on levels following i and thus not available for pebbling Cj. Again we will use the BLBA to ensure that many outputs of C~ have to be pebbled during the time interval considered.</p><p>The appropriate definitions for carrying out the program outlined above are the following. By constraints (B5) and (B6), C2k+1-3 is useful in the interval Z~n covering the whole pebbling strategy. We will show in the following that if C, is useful in Z, we can identify two disjoint subintervals of Z during each of which either C,-I is useful or the parent of C, is right for C,. This allows us to iterate the argument through the levels from C2,+La toward C~ and at each step double the number of necessary placements. We have to pay for making a large jump (from C, to its parent) by "losing" a proportional number of pebbles that are bound on the neighborhood of C, during the interval considered. The number of available pebbles then implies an upper bound on the number of large jumps we can make and thus gives a lower bound on the number of times the argument can be iterated. Each iteration doubles the number of necessary placements. The number of possible iterations will ultimately lead to the desired lower bound on the time-space trade-off for pebbling G(n, k).</p><p>In order to pursue this argument formally we have to prove a series of lemmas. The first lemma puts the BLBA into a context that is suitable for the discussion of a(n, k ).</p><p>LV, MMA 5.3.5. Let i &gt; 1. Assume that in the interval Z, [c2m] outputs of the m-superconcentrator C, have to be pebbled starting and ending with a configuration of fewer than 2cam pebbles on the neighborhood of C,. Then during Z, at least clm' outputs of the m'-superconcentrator that is the parent of Ci have to be pebbled. PROOF. By constraint (B3) we can apply the BLBA to Z and get that at least (l -4ca)m inputs of C, have to be pebbled and unpebbled during Z. We have to make a ease distinction. Case 1. C, is a Ca,. Thus C,-1 is the parent of C,, and because of the edges between C,-1 and C,, during Z at least (1 -5c3)2m &gt;_ 2clm (see constraint (B4)) outputs of C,-~ have to be pebbled. Case 2. C, is a Cmod (respectively, a Clo). In this case let C' be the corresponding Chi (respectively, Creed); that is, C' ffi C,-2'm/n-2. Because of the direct connections between C' and C,, at least (1 -6c3)m &gt;_ c~m (see constraint (B4)) outputs of C' have to be pebbled during Z. If C' is the parent of C,, then the lemma is proved. Otherwise, because of constraint (B2), we can apply the BLBA to Z again to show that at least (1 -4c3)m inputs of C' are pebbled in Z. Repeated application of the case distinction to C' then proves the lemma. [] We will now prove the lemma that provides us with a lower bound argument that can be iterated on G(n, k). generality we can assume that at time z~ a pebble is placed on the neighborhood of Ci. Let z9 be the last time before (and not including) z7 at which there are fewer than c3m pebbles on the neighborhood of C~. Let ZlO be the first time after (and including) zs at which there are fewer than c3m pebbles on the neighborhood of C~. Let Z" ffi [Z9 "~" 1, zlo] and Z~ ffi [z9 + 1, zn] where zn ffi Z~o if Zxo ffi zs and zn ffi Z~o -1 otherwise. We have Z~ C Z" C Z'. (Furthermore, note that ifzn ffi Z~o -1, then at Z~o a pebble is removed from the neighborhood of C.) During Z", [c2m] outputs of the parent of C,-~ are pebbled starting and ending with a configuration of fewer than c3m pebbles on the neighborhood of C, (i.e., also on the neighborhood of Ci-x). Applying Lemma 5.3.5 to Z" yields that at least 2clm outputs of the grandparent of C-~ (i.e., the parent of C) are pebbled during Z", that is, also during Zi. Furthermore, at all times during Zi at least c4m pebbles stay on the neighborhood of C, Thus the parent of C is right for C, in Zi. Case 2.2.2 (The parent of C-~ is good in Z'). Otherwise, any time in Z' that [c2m] outputs of the parent of C,-~ are pebbled, the number of pebbles on the neighborhood of C, drops below c4m. Thus the parent of C,-1 is good in Z', and thus C,-~ and all its ancestors are good in Z'. As in Case 2.1, we can infer that C~_~ is useful in Zi ffi Z'. [] We are now able to associate with the strategy for pebbling G(n, k) a rooted binary tree according to the following definition. Thus all leaves of R are vertices v, = (1, Z,), where the Z, are pairwise disjoint subintervals of Z~ during which C~ is useful. By constraint (B2), at least 6[c2n] outputs of (71 are pebbled in each of the Z~. The BLBA can be applied twice (see Lemma 5.3.5), and we get that at least 2(1 -c3)n inputs of C1 are pebbled in each of the Z,. Thus ifb is a lower bound on the number of leaves in R, then 2(1 -c3)nb is a lower bound on the number of placements of pebbles on inputs of C1, and therefore also a lower bound on the time necessary to pebble G(n, k).</p><p>We can therefore prove the following theorem.</p><p>THEORV.M 5.3.8. In order to pebble G(n, k) with S &lt;_ csn pebbles, a time T is necessary such that ,.</p><p>PROOF. We will prove in the following lemma that R has at least 2 ~1-2~/~)2'÷~-3 leaves, r-l LEMMA 5.3.9. The number of leaves in R is bounded from below by 2 ~-2~/~')z*÷~-3.</p><p>PROOF. Each nonleaf in R has two children. Thus, if we prove that each path in R has a length of at least b, then we can infer that there are at least 2 b leaves in R. Therefore the lemma follows from the following lemma. []</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2. 1</head><label>1</label><figDesc>INTRODUCTION. Let us define a particularly simple family of graphs, which are induced by permutations on N elements. Definition 2.1.1. Let ~r be a permutation on N dements. The permutation graph G(~r) on N elements is the graph G = (V, E) such that V = {o~, o~ ..... ON, ~1, ~'2 ..... zN), E = ((o,, o,+,), (r,, ~,+1)11 _&lt; i&lt; N -1) U {(o,, r=,~)l 1 _&lt; i~ N}. For 1 _&lt; i _&lt; N, o, is called the ith input vertex, ~-, is called the ith output vertex; ol is called the source, zN is called the sink. The path consisting of the edges (~x, o2),</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc>a2, 03) ..... ({IN-l, {I~v) is called the input path. The path consisting of the edges (*1, T2), (*2, *~) .....(,z-x, ,N) is called the output path. Figure1shows a typical permutation graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIG 2</head><label>2</label><figDesc>FIG 2  The bit reversal graph on N = 32 elements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>THEOREM 2 .</head><label>2</label><figDesc>3.2. S pebbles takes time T. LENGAUER AND R. E. TARJAN If S &gt;--2, then pebbling the bit-reversal graph on N elements with</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>THEOREM 2 . 4 . 1 .</head><label>241</label><figDesc>The bit-reversal graph on N ffi 2 ~ elements can be pebbled with S pebbles (3 &lt;_ S &lt;_ 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>4 . 2 .</head><label>42</label><figDesc>The bit-reversal graph on N elements can be pebbled with S black and white pebbles (2 _&lt; S _&lt; N + 1) in time N 2 T_&lt; 36-~ + 5N. PROOF. For S = 2, see Lemma 2.2.2. If 3 _ S --3 ~/-N, Theorem 2.4.1 applies. If S &gt; 3,¢r~, the strategy given in Theorem 2.4.1 takes time at most 5N. []</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FIG. 3 .</head><label>3</label><figDesc>FIG. 3. An N superconcentrator with O(NlogN) edges, N = 16 (all edges are directed toward the right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Definition 3 . 3 . 1 .</head><label>331</label><figDesc>Let n, x, 01, and 02 be positive integers such that 01 &lt; 02, and let 01102x. Let x' = 02K/01. An (n, x, 01, 02)-linear concentrator is a bipartite graph with n left and 01[n/02] right vertices such that each left vertex has a degree of at most x, each fight vertex has a degree of at most r', and each subset X of left vertices with I XI ---n/2 is connected to at least I XI fight vertices. (An (n, x, 01, 02)-linear concentrator has at most xn edges.) Pippenger uses concentrators in the following way to construct linear superconcentrators: Definition 3.3.2. Let ~(N) ---OLIN/02]. An (N, x, 01, 02)-linear superconcentrator is a linear N-superconcentrator that is recursively defined as follows: (a) If N &lt; 01, then the (N, K, 01, 02)-linear superconcentrator is the complete bipartite graph K[N, N]. (b) If N &gt; 01, then the (N, x, 0~, 02)-linear superconcentrator has N inputs and N outputs such that the following hold:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>FIG 4  Plppenger's recurs]on scheme for the superconcentrator C(N, K, 01, 02).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(i) Directed edges join the inputs with their corresponding outputs. (ii) The inputs are also the left vertices of an (N, r, 81, 0D-linear concentrator G1. Edges in G1 are directed from the left toward the right vertices. (iii) The outputs are also the left vertices of an (N, x, 91, 02)-linear concentrator G2. Edges in G2 are directed from the right toward the left vertices. (iv) The right vertices of G] are also the inputs of a (~(N), x, 81, 0D-linear superconcentrator whose outputs are the right vertices of (32.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>LEMMA 3 . 3 . 3 .</head><label>333</label><figDesc>An (N, ~, 01, 02)-linear superconcentrator has at most 1 = ~/Oz] + O(logN) edges. Its depth ts O(log N).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>pebbles in time O(N. (N/S)~), where a = 1 + 21og02/0~ K. Thus it pebbles Pippenger's ((N, 6, 4, 6)-linear) superconcentrators in time O(N. (N/S) TM) and Gabber and Galirs ((N, 112, 16, 17)-linear) superconcentrators in time O(N. (N/S) TM 67).Let us denote the (N, x, 01, 02)-linear superconcentrator by C(N, i¢, 01, 02). Imagine C(N, x, 01, 02) to be unfolded i times by applying the recursion in Definition 3.3.2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>2 ) 3 )2 3 .</head><label>233</label><figDesc>FIG<ref type="bibr" target="#b6">5</ref> </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>F1G 6</head><label>6</label><figDesc>The graph C,(N, r, 01, 02) for z = 4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Definition 3 . 3 . 4 .</head><label>334</label><figDesc>Let G be a directed acyclic graph with depth d and a unique output vertex 0-. The unfolding of G is a tree UG of depth d. Each vertex v' in UG is the image of a vertex v in G. The tree UG is the unique tree with the following properties:(a) There is exactly one image of the output vertex ~-in UG, and it is the root of UG. (b) If the vertex w' in UG is the image of the vertex w in G, then w' has exactly one child v' in UG for each vertex v in G such that (v, w) is an edge in G. The vertex v' is an image of the vertex v.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>LEMMA 3 . 3 . 7 .</head><label>337</label><figDesc>For each output T of Gj,1 the unfolding of G~,t(z) has O((N/S) ~+1) vertices, where fl = loga2/ol x. PROOF. By eq. (3) the graph Gj,1 has a depth of j = log02/01 N/S + O(1). Furthermore, it has a maximum indegree of x' = O2x/Ol. Thus for each output ~" of Gja the unfolding of Gja(~') has O((x') J) = O((N/S) a+l) vertices. [] COROLLARY 3.3.8. Phase 1 of C-PEBBLE takes time O(N.(N/S)B).PROOF. By the choice ofj the graph G~,I has at most S/2 output vertices. Since S _ clogN for a sufficiently large constant c &gt; 0, Fact 3.3.5, Fact 3.3.6, and Lemma 3.3.7 imply that Gja(z) can be pebbled with ,7/2 pebbles in time O((N/S) ~+1) for all outputs ~-of Gj,1. Thus pebbles can be put on all outputs of Gj,1 in timeO(S.(N/S)# +1) --O(N.(N/S)a). []Corollary3.3.8  gives us an upper bound on the time for phase 1. As we already mentioned, phase 2 takes time O(S). We will now find an upper bound on the time for phase 3. LEMMA 3.3.9. Let L(i) (respectively, V(i)) be the maximum number of leaves (respectively, vertices) in the unfolding of C,(N, K, 01, Oz)(*) for any output ~ of C~(N, r, O1, 02). Then L(O) = V(O) = 1. For i &gt; 0 the following recurrences hold:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>THEOREM 3 . 3 . 10 .</head><label>3310</label><figDesc>has the solution 1103 Let a, b, and c be nonnegative real constants. The recurrence 7"(0) = o(1),</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>THEOREM 3 . 3 . 11 .THEOREM 3 . 3 . 13 .</head><label>33113313</label><figDesc>Both L(i) and V(i) exhibit an asymptotic growth of O((~:tc')~).PROOF. Substituting a = ~:x', b = 1, and c = 1 in Theorem 3.3.10 yields L(i) = o((~:~')'). Substituting a ---~, b = ~', and a large enough constant c &gt; 0 in Theorem 3.3.10 then yields V(/) = O((xx')'). [] THEOREM 3.3.12. Any r outputs of the graph Cs(N, x, 01, 02) can bepebbled in time O(r.(N/S)~). PROOF. By definition of V(i), the estimate (3) for j, and Theorem 3.3.11, the size of the unfolding of Cs(N, ~:, 01, 02)(,) for any output .r of Cs(N, x, 01, 02) is O((KKt) J) -~ O((KKt) I°g'2/s'(N/S)) = 0 --~ * For pebbling each Cs(N, x, 01, 02)0") we have S/2 pebbles available. Since S _&gt; clogN for a sufficiently large constant c &gt; 0, Facts 3.3.5 and 3.3.6 imply that we can pebble each output of Cj(N, x, 01, 02) in time O((N/S)"). In total, r outputs have to be pebbled. [] The strategy C-PEBBLE pebbles any r outputs of Cs(N, r, 01, 02) in time T &lt;_ O(N. (N/S)I°~2 ~) + O(r. (N/S)l+~l°g'l~).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>FIG. 7. The graph C(n, k).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>4 . 2</head><label>42</label><figDesc>THE LOWER BOUND IN THE BLACK AND WHITE PEBBLE GAME. We can iterate the Basic Lower Bound Argument (Lemma 3.2.1) to find a lower bound on the time-space trade-off for pebbling C(n, k).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>THEOREM 4 . 2 . 1 .</head><label>421</label><figDesc>In order to pebble all outputs of C(n, k) using S black and white pebbles, 2 &lt;_ S &lt;-(n -1)/4 (starting with any configuration of pebbles on the graph), we need Tplacements such that PROOF. The subgraph Ck together with the outputs of Ck-~ and the edges joining Ck-~ with Ck is an n-superconcentrator. Thus we can apply the BLBA ln/(2S + 1)] times to prove that (n -2S)Ln/(2S + 1)J placements of pebbles on outputs of Ck-x are necessary to pebble all outputs of Ck. Iterating this argument through Ck-~ ..... Ca, we t'md that ,, &lt;ninputs of C1 have to be pebbled. (Observe that n -2S _&gt; 2S + 1 since S _&lt; (n-1)/4.) [] If the above theorem would already yield a superpolynomial growth of T for S =</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>LEMMA 4 . 2 . 3 .</head><label>423</label><figDesc>During the good interval [i, j] at least n -2S different outputs ofCk-1 are pebbled. Only S -1 -[(j -1)/81 pebbles are avilable for doing this.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>H</head><label></label><figDesc>be pebbled and unpebbled during [z{, zj ]. Furthermore, at z" there are at most S -x{ pebbles on C~, ..., Ck-1, and at time z 7 there are at most S -xf pebbles on C1 .... , Ck-~. Therefore, at least " -(S-x{) -(S-x;') ffi n -2S n --xt~ --xj outputs of C~-1 have to be pebbled during [z{, zf].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>LEMMA 4 . 2 . 4 .</head><label>424</label><figDesc>Let r &lt;_ n. We can find a set of disjoint good intervals in [1, r] that covers at least r/4 -S -p~+a elements of[l, r]. PROOF. By induction on r. If r &lt; 4S, then the statement of the lemma is trivial. Thus let r ~ 4S.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head></head><label></label><figDesc>elements in[1, r]  are covered with disjoint good intervals. Case 2. Otherwise we havep,+l &gt; [(r -/)/2J, and thuspr+l &gt;_ (r + 1 -0/2. and the lemma holds again. [] We will now use Lemmas 4.2.3 and 4.2.4 to construct a recursive relationship for the time to pebble C(n, k).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>THEOREM 4 . 2 . 5 . 12 T{X 1 ,</head><label>425121</label><figDesc>Let T(n, k, S) be the time necessary to pebble [9n/10] outputs of C(n, k) with S &lt;_ n/20 pebbles. Then !,xm)eD _ where D is an index set that contains all the ways in which we can select a large number of good intervals. Specifically, ... x• m&gt;-~--~,l&lt;_x,&lt;_8S-6forl&lt;_i&lt;__m, and ~ x,&gt;_ . PROOF. By induction on k. k ffi 1. Follows trivially as in Theorem 4.2.1. k &gt; 1. Assume any strategy for pebbling C(n, k). Let r = [9n/lO] and S ffi n/20. By Lemma 4.2.3, during a good interval of length x at least n -2S _ r outputs of Ck-1 have to be pebbled using at most S -1 -[(x -l)/SJ pebbles. (Unless x _ 8S -6, no pebbles are left for pebbling the outputs of C~1.) Iadugtively this takes at least T(n, k -1, S -1 -[(x -l)/SJ) steps. By Lemma 4.2.4 the total length of the disjoint good intervals we can fred is at least r/4 -2S &gt;_ n/8. Thus if we assume that</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>(</head><label></label><figDesc>YI,,,.,Ym)~D' l&lt;t&lt;.m where D' is the set D'= (yl ..... y,~) m&gt;~--~,O&lt;y,&lt;Sforl~_i~m, and ~. yi~-~ • Let us first assume that m is fixed. The expressionf(n, k -1, S -y) is a convex function in y for 0 &lt; y &lt; S (its second derivative is normegative). Thus we have ~, f(n,k-l,S y,)&gt;mf(n,k-l,S 1 ~ 1.&lt;r.e.m m l_l.~ra ] Sincef(n, k -l, S -y) is also increasing in the range 0 &lt; y &lt; S, we have m y, &gt;_mf n,kthe right-hand side of (15) can now be minimized with respect to m by differentiation. The minimum for m &gt; n/64S occurs at m ---nk/64S and amounts to n(nk/64S) k. This proves the theorem. [] 4.3 THE UPPER BOUND IN THE BLACK PEBBLE GAME. The question arises whether after the refinement of the argument used in the proof of Theorem 4.2.1 the lower bound (13) that has been obtained on the time-space trade-off for pebbling C(n, k)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head></head><label></label><figDesc>0 is a suitably large constant. The proof of the theorem is by induction on k. k = 1. See Theorem 3.3.13. k&gt;l. Wehave Thus STACK-PEBBLE(f, k -1, S -[S/kJ) has at most r'l&lt;~&lt;kl(C2-~k) a' (C2~k) °a+B +n .~Y~ (k-l-i) _ _ --O_/_&lt;k--2 moves. By (17) we have r'&lt;--r • +n. ~ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head></head><label></label><figDesc>S ' is either [(1c O S ] or [(Sd p ) / 2 J . D e f i n i t i o n 5.2.2. Define mo --c4(d + 2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>LEMMA 5 . 2 . 3 .</head><label>523</label><figDesc>Suppose FAST-PEBBLE is called on a problem of size (m, S) with m &gt;_ 1. If FAST-PEBBLE calls itselfrecursively on a subproblem of size (m', S'), then (a) m' _ re(l/2 + c2 + 1/2c4) &lt; m; (b) if re' = ml, or m' = m2 and the cut is small, then PROOF (a) In all cases, (b) Ifm' = ml,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>LEMMA 5 . 2 . 4 .( 1 +</head><label>5241</label><figDesc>Suppose FAST-PEBBLE is called on a problem of size (m, S) satisfying S &gt; rain(m, cs(log(d + 2))m/logm). (a) If m &lt; too, then S &gt;-m, that is, FAST-PEBBLE does not call itself recursively. (b) If FAST-PEBBLE calls itself recursively on a subproblem of size (m', S'), then dp &lt; S (there are enough pebbles for the pool). PROOF (a) If m &lt;_ mo, we have logc4)log(d + 2) &gt;-log c4 + log(d + 2) by (A3) &gt;_1. (b) Since x/logx is an increasing function for x &gt; 2 and m &gt;mo = c4(d + 2) __&gt; 2 (by (A1), c4 &gt; 1), we have S &gt; mo ---c4(d + 2) by (a). Thus, dp-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>LEMMA 5 . 2 . 5 .</head><label>525</label><figDesc>Suppose FAST-PEBBLE is called on a problem of size (m, S) satisfying S &gt;-min(m, cs(log(d + 2))m/logm). lf this call produces a recursive call on a subproblem of size (m', S')</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_33"><head>1 &gt;</head><label>1</label><figDesc>_&gt;m (1/2 -3c--z --Cl1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_34"><head></head><label></label><figDesc>us to prove that recursive subproblems inherit the lower bound on pebbles. The next lemma furnishes this result.LEMMA 5.2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_35"><head>2 _</head><label>2</label><figDesc>logm)/cslog(d + 2) -ca &gt; cslog(d + 2)m' --logm -cscslog(d + 2)" We begin by deriving an upper bound on S2/m(d + 2). S 2 c~(log(d + 2))2m 2 m(d + 2) --m(d + 2)(log t91) (log x) 2 is increasing for x &gt; 8 and m _&gt; d + 2 _&gt; 8. Now we have m d+2 m' &lt;-~-c2S +---~ Thus it suffices to show or log m' &gt;_ log m -ca cslog(d + 2), m log ~-; -ca cslog(d + 2(d + 2).Case 2 (m' = m2 and the cut is large). We have d+2 m By the proof of Lemma 5.2.5 (large cut) and the argument in ease 1 above we can exchange x for m'. This yields S' _ cslog(d + 2)x logx Since x/log x is an increasing function for x &gt; 2, m' &lt;_ x implies S' ---cslog(d + 2)m' log m' unless m' _ 1, in which case S' &gt;_ rain(m0, x) _&gt; m'. 17</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_36"><head>Lemmas 5 . 2 .</head><label>52</label><figDesc>4 and 5.2.6 establish the correctness of FAST-PEBBLE. From Lemma 5.2.5 we obtain the following bound on the running time of FAST-PEBBLE. Trn~Oe, EM 5.2.7. Suppose FAST-PEBBLE is applied to a graph G of size m using S &gt;_ rain(m, cs(log(d + 2))(m/logm))pebbles. The pebbling time T(G, S) satisfies T(G, S) &lt;--d~'/°~S-lSc7 ~/s.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_37"><head></head><label></label><figDesc>proof is by induction on the quantity J= / ca " j &lt;__ 0. In this ease we have m _ S, the problem is terminal, and the theorem follows trivially. j _ 0. In this case we have m &gt; S. FAST-PEBBLE calls itself reeursively with arguments, say (m', S'). By Lemma 5.2.4(a) we have m _&gt; mo. By Lcmma 5.2.6 the problem size (m', S') also fulfills the premise of the theorem. By Lemma 5.2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_38"><head></head><label></label><figDesc>2.5, we getT( G, S) ~-d2m/~s~-~-l Sc~ ~'/s-~ 4" d2m/'c3s)-'-lSc~/s-~r d~mo2 (d2"*/'~s)-'-lSc~ ~'s-~) ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_40"><head></head><label></label><figDesc>right-hand side of (26)"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_41"><head>COROLLARY 5 . 2 . 9 .FACT 5 . 2 . 8 .FIGDefinition 5 . 3 . 2 .</head><label>529528532</label><figDesc>FIG. 9. c,(n, k).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_42"><head>FIG. 10 .</head><label>10</label><figDesc>FIG. 10. A schematic representation ofCKn, k) for k ffi 4 wtth level numbers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_43"><head>Definition 5 . 3 . 4 .</head><label>534</label><figDesc>Let Z ffi [Zl, Z2] be a time interval.(a) An m-superconcentrator Ci is called good in Z if in each subinterval of Z in which at least [c2m] outputs of C, are pebbled, the number of pebbles on the neighborhood of C, drops below csm. (b) An m-superconcentrator C, is called useful in Z if C, and all its ancestors are good in Z and at least c~m outputs of (7, are pebbled in Z. (c) Let C' be the parent of C,. Assume that C' is not Ci-1. C' is right for C, in Z if C' is useful in Z and at all times during Z at least c4m pebbles stay on the neighborhood of C,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_44"><head>LEMMA 5 . 3 . 6 .</head><label>536</label><figDesc>Let i &gt; 1. Let the m-superconcentrator C, be useful in Z. Then there are two disjoint subintervals Z'~ and Z'2 of Z such that in Zj (j E (1, 2}), either C~-1 is useful or the parent of C, is right for C~.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_45"><head>Definition 5 . 3 . 7 .</head><label>537</label><figDesc>Let R be the rooted binary tree such that each vertex in R is an ordered pair (i, Z), where 1 _&lt; i _&lt; 2 k÷l -3, Z C Z~u is a time interval, and C, is useful in Z. Furthermore, (a) The root of R is the vertex (2 k÷~ -3, Z~). (b) Each vertex v --(i, Z) in R such that i &gt; 1 has two children (i~, Z]), j E { l, 2), where Zj is defined as in Lemma 5.3.6 and C,~ --C,-1 if C,-1 is useful in Z], otherwise C,~ is the parent of C~ (and C~ is right for C, in Z] by Lemma 5.3.6). (c) Each vertex v --(l, Z) in R is a leaf.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>It is important to notice that the graph C(n, k) satisfying this lower bound depends on S. There is apparently no single graph that is bad for every S. Many graphs contribute single data points to the enveloping lower bound curve.)</figDesc><table><row><cell cols="2">[ nk ~ 9"~k</cell><cell></cell></row><row><cell>nO -e)</cell><cell>,</cell><cell></cell></row><row><cell>and even in linear time if S &gt; 40n.</cell><cell></cell><cell></cell></row><row><cell cols="3">Now let S = ~(N/logN). Choosing n = 20S and k = [N[SI, we get a graph</cell></row><row><cell cols="3">C(n, k) of size O(N) such that pebbling C(n, k) with S black and white pebbles takes</cell></row><row><cell>time</cell><cell></cell><cell></cell></row><row><cell cols="2">[ N\ a(N/s)</cell><cell></cell></row><row><cell cols="3">Moreover each graph C(n, k) of size N (2nk &lt; N &lt;_ 40nk) can be pebbled using</cell></row><row><cell>only black pebbles in time</cell><cell></cell><cell></cell></row><row><cell>"N (N) °(k)..S o</cell><cell>__[N\ °(')</cell><cell>,</cell></row></table><note><p>2, as long as S ~-n/20, the task of pebbling C(n, k) with S black and white pebbles takes time [' nk ,~k Time-Space Trade-offs in a Pebble Game 1105 Furthermore in Section 4.3 we pebble a stack of Pippcnger's supcreonccntrators using only black pebbles in time (and even in linear time if k &gt; 20N/S. Thus each C(n, k) of size N can be pebbled in time [ N\ O(N/s) T= so(-s)</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ACKNOWLEDGMENTS. We thank Don Knuth and Nick Pippenger for providing many useful suggestions. Nick Pippenger had a particular influence on Section 2. First, he suggested the investigation of bit-reversal graphs, and second, he contributed simplifications in the proof of Theorem 2.3.2 that greatly reduced the size of Section 2.3 and improved the constant factors involved. Furthermore, he made us aware of a convexity argument that avoids the use of multidimensional calculus in the proof of Theorem 4.2.6. Some of the proofs have been verified using the formula manipulator of the MACSYMA-Consortium.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(</p><p>Reischuk's pebbling algorithm (see <ref type="bibr" target="#b25">[24]</ref>) implies an upper bound on Sa of the form Sa -~ o(N/logloglogN). <ref type="bibr" target="#b22">(21)</ref> In this section we show that Sa ffi O(N/loglog N). <ref type="bibr" target="#b23">(22)</ref> Thus neither bound <ref type="bibr" target="#b21">(20)</ref> nor bound <ref type="bibr" target="#b22">(21)</ref> is tight. Equation ( <ref type="formula">22</ref>) can be inferred from the following time-space trade-off for pebbling general directed acy¢lic graphs with black or with black and white pebbles:</p><p>(Equation <ref type="bibr" target="#b24">(23)</ref> says that all directed acyclic graphs with bounded indegree can be pebbled with a sufficiently large number S of pebbles in time T = $22°(N/s)</p><p>and that there are graphs for which a time T = $22"(N/s) is necessary to pebble them with S pebbles.)</p><p>N~ <ref type="bibr" target="#b2">(1)</ref> Moreover, <ref type="bibr" target="#b24">(23)</ref> implies that if S = O(N/logN), then T =--2 , that is, T is exponential in some positive power of N.</p><p>In the following sections we prove <ref type="bibr" target="#b24">(23)</ref>. Section 5.2 proves the upper bound for the black pebble game. Section 5.3 proves the lower bound for the black and white pebble game. <ref type="bibr" target="#b20">[19]</ref> Paul et al. give a recursive algorithm BEST-PEBBLE for pebbling any directed aeyclic graph with a maximum indegree d (d &gt;_ 2) using S &gt;--c~(dlogd)(N/logN) pebbles (c5 &gt; 0 is a sufficiently large constant). They do not analyze the time efficiency of their algorithm, and in fact it may be quite inefficient. However, it is possible to modify their algorithm so that it makes efficient use of all S pebbles that are available. We call the modified algorithm FAST-PEBBLE. It is stated below, and its time analysis leads to an upper bound of the form Z ~ S(c7d) %(d+l)N/s (c7, c8 &gt; 1 are suitably large constants).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">THE UPPER BOUND IN THE BLACK PEBBLE GAME. Ill</head><p>(Reischuk <ref type="bibr" target="#b25">[24]</ref> independently uses similar ideas to prove his result that</p><p>for S = f~(N/log~N), where r E N, The functionf(d) is not further specWied.)</p><p>Throughout this section we use the sum of the number of vertices and the number of edges as a measure of the graph size.</p><p>Let G be an graph of size m with a maximum indegree d. For technical reasons we assume d _&gt; 6; since d is an upper bound on the indegree, making d larger only increases the class of graphs allowed. The algorithm FAST-PEBBLE(G, S) presented below pebbles G with $ pebbles, if S is sufficiently large. The definition and analysis of the algorithm require a set of constants Cl ..... cs &gt; 0 that must satisfy some rather arbitrary-looking constraints. An explanation of the constants and a list of the constraints appear below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Explanation of the constants:</head><p>c1: constant factor in the critical size of the cutset E Ce: constant factor in the displacement of cut from the middle of G ca: minimal decrease of m/S per recursion level c4: constant factor in the threshold on the graph size for which FAST-PEBBLE becomes nontrivial c5: constant factor in the lower bound on the size of S c6: constant factor bounding the size of P cT: first exponential in upper time bound c,: second exponential in upper time bound. Loui <ref type="bibr" target="#b14">[13]</ref> has recently found an elegant way to prove the same result without having to be explicit about the constants involved. However, his algorithm is different from the one given here and involves a nonconstructive step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table of constraints:</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">THE LOWER BOUND IN THE BLACK AND WHITE PEBBLE GAME.</head><p>In order to prove the lower bounds stated in Section 5.1 we have to fred graph families that have even more dramatic time-space trade-offs than C(n, k). The essential idea in the construction and analysis of C(n, k) was to arrange as many superconcentrators as possible in levels one below the other, such that the BLBA can be iterated through the levels. Intuitively, the more levels the graph has, the more frequently the BLBA can be iterated, and the better the lower bound on the pebbling time should be. In Section 4 we chose k = O(N/S) and n --O(S), as this maximized the time. However, since S = ~(N/logN), we always have k = O(logN); thus the worst graphs among the C(n, k) do not have many levels. This suggests that we should find some way of increasing the number of levels without increasing the graph size. Obviously the only way in which this is possible is to use superconcentrators of different sizes. They have to be arranged and interconnected in such a fashion as to retain the ability to iterate the BLBA through practically all levels (or at least some constant fraction of them). This means that long edges have to be introduced that connect nonadjacent levels.</p><p>These ideas lead to the following det'mition of a suitable graph family G(n, k) (again in two parameters), which is similar to the graph family used in <ref type="bibr" target="#b20">[19]</ref> to prove the space lower bound.</p><p>As in Section 5.2, we have to use a number of constants Cl,..., Clo &gt; 0 satisfying certain constraints. Explanations of the significance of the constants and a list of the constraints appear below. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Explanation of the constants</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table of constraints el&lt; 1, 9c2 &lt;--cl, c2</head><p>C3 &lt;--~, An illustration of this construction is given in Figure <ref type="figure">9</ref>. By Det'mition 5.3.4(c), if C, is an n/2k-~-superconcentrator, then its neighborhood contains at least c4n/2 k-~ pebbles during Z1. But it also has at most 2 J+~ -2 levels. All of these levels except h and h+l are in B.</p><p>Thus, including these 2 J+l -2 contiguous levels in B is by Lemma 5.3.6 accompanied by 'Tixing" c4n/2 k-J pebbles permanently on these levels during Zr C Z1. We will express this fact by "charging" a proportional amount (namely, c4n/2 k÷~) of all pebbles bound on the neighborhood of C, t to each level in B that is in the neighborhood of C, r With this procedure we will sometimes charge a pebble used for pebbling G(n, k) to two levels. This happens if there are two levels v and v' such that h-~ &gt; v &gt; h &gt; v' &gt; h+~, and the pebble stays on C~ during Zr. In this case the pebble gets charged to both v and v', since C,t belongs both to the neighborhood ofC, z_ ~ and to the neighborhood of C~ r However, no pebble can be charged to more than two different levels. (Some pebbles, which are not fixed on one of the neighborhoods considered, will not be charged to any level.) Since this charging process assigns c4n/2 k÷l pebbles to each level in B, at least I BIc4n/2 k+2 pebbles have to stay on G(n, k) during Zr. Since only S _ csn pebbles are available, we get C5 2k+2 '</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IBl_&lt;-</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C4</head><p>and thus, c,]</p><p>We will now adjust k and n so that we can infer a lower bound from Theorem 5.3.8 that asymptotically matches the upper bound given in Section 5.2.</p><p>Let S be a function of N, and let N/log N _ S &lt;_ N. Choose k = Ice, N/S] where c6 fulfdls constraint (B7), and choose n to be the unique number in the interval  An analogous remark as in Section 4.2 applies here: G'(N, S) has to be chosen to depend on S. There is no single graph G(n, k) that has a dramatic time-space tradeoff for all S. The lower bound curve given in Theorem 5.3.12 is an envelope of the lower bound curves for the G'(N, S) for all S. We conjecture that there is no single graph whose time-space trade-off has a lower bound as given in Theorem 5.3.12 for aU S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Remarks</head><p>The results in Section 5 answer the basic open question in the area of graph pebbling--the question of how much space can be saved before the corresponding blowup in time becomes superpolynomial. In a certain sense this closes the area of general research concerned with graph pebbling. However, there are a number of generalizations, extensions, and related problems that may be worth studying.</p><p>The upper and lower bounds proved in Section 5 are asymptotically tight, but the constants are very far apart. With our constraints the bounds are only of theoretical interest. However, we believe that the constants (especially in the upper time bound) can be improved significantly.</p><p>Furthermore, the hard-to-pebble graph families we have described are specially constructed and somewhat obscure. It would be interesting either to extend our results to graph families that actually occur in practical computations or to derive less dramatic time-space trade-offs for specific practical graph families. In particular, part of the motivation for studying graph pebbling arises from connections between the pebble game and Turing-machine complexity (see <ref type="bibr" target="#b10">[9,</ref><ref type="bibr" target="#b17">16]</ref>).</p><p>Upper bounds for Turing-machine complexity can be derived by first representing Turing-machine computations by directed acyclic graphs called computation graphs and then constructing Turing machines to simulate pebble games on these computation graphs. Computation graphs form a natural family on which to study pebbling problems.</p><p>The black and white pebble game is largely unexplored and several open questions have been posed in <ref type="bibr" target="#b4">[3]</ref> and <ref type="bibr" target="#b16">[15]</ref>. The most interesting is whether on any graph at all the addition of white pebbles can save more than a constant fraction in space. Although no such graph is known, the addition of white pebbles in some but not all cases improves the time-space trade-off. Ladder graphs, for instance, can be pebbled with two black and white pebbles in linear time, and Section 2 shows that white pebbles improve the time-space trade-off for bit-reversal graphs.</p><p>Another interesting research area is to make graph pebbling more applicable by modifying the pebble game to model specific features of machine architecture (like two-address instructions or stacks). Pippenger <ref type="bibr" target="#b24">[23]</ref> presents some interesting results in this direction.</p><p>Finally, our results bear on certain graph-theoretic questions that arise in the study of computational complexity. (See <ref type="bibr" target="#b5">[4,</ref><ref type="bibr" target="#b18">17,</ref><ref type="bibr" target="#b26">25,</ref><ref type="bibr" target="#b34">33]</ref>.) For instance, consider the family of directed acyclic graphs of maximum indegree two. If G is such a graph, a</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">2m &lt;_ clm (using constraint (B2)); that is, at least 6[c2m&apos;[ outputs of C, are pebbled in Z. Let Z1 = [z1,1, z2,1] be the interval in which the first 3[c2m] outputs of Ci are pebbled, and let Z2 = [zl,2, z2,2] be the interval in which the last 3[c2m] outputs of C, are pebbled. The following argument can be applied equally to both Zj ( j ~ { 1, 2}), and we will without loss of generality consider only Zx. Let Zo be the first time and z~ be the last time in Z~ at which fewer than c3m pebbles are on the neighborhood of C~. Because C, is good in Z</title>
		<author>
			<persName><surname>&gt;_</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>see Definition 5.3.0, we have cam. at least [c2m] outputs of C, are pebbled in Z = [z0 + 1, zl</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Applying Lemma 5.3.5 to Z &quot; yields that at least c~m outputs of the parent of C,-~ are pebbled during Z&quot;. If (7, is an n-superconcentrator, then the parent of C,-1 is also the parent of Ci. Otherwise, applying Lemma 5.3.5 again (using constraint (B2)) yields that at least 2c~m outputs of the grandparent of C,-~, that is, the parent of C, are pebbled in Z&quot;, that is, also in ZL Furthermore, at all times during Zi at least c4m pebbles stay on the neighborhood of C~. Thus the parent of C~ is right for (7, in Zi. Case 2 (C~-1 is good in Z&apos;). Otherwise, any time in Z&apos; that [c2m/2] outputs of C~-~ are pebbled, the number of pebbles on the neighborhood drops below c4m. Because of constraint (B5) this means that C,-1 is good in Z&apos;. We make another case distinction. Case 2.1 (G is large). The parent of C, has the same size as C,. In this case the parent of C~ is also the parent of C,-~. Thus C,_~ and all its ancestors are good in Z&apos;. But in Z we have to pebble [c2m] outputs of C~, starting and ending with configurations of fewer than cam pebbles on the neighborhood of C,. By the BLBA we have to pebble in Z&apos; at least (1 -2c3)m inputs of C, and because of the edges between C,-~ and C~, at least (1 -4ca)m~2 outputs of C,-~. Because of constraint (B4), C~-1 is useful in Z~ = Z&apos;. Case 2.2 (C, is small). The parent of C, is larger than C,. We have to make a third case distinction. Case 2.2.1 (The parent of C,-a is not good in Z&apos;). Assume that there is a subinterval [z7, zs] C Z&apos; in which [c2m] outputs of the parent of Ci-~ are pebbled while always at least c4m pebbles stay on the neighborhood of C,. Without loss of Pr-separator of G is a set of vertices S whose removal leaves no vertex v of G such that one can reach v from I S I distinct vertices. Let Pr(n) be the minimum value of k such that every graph on n vertices has a Pr-separator of size k</title>
		<idno>171) conjecture that Pr</idno>
		<imprint>
			<publisher>Paul and Reischuk</publisher>
		</imprint>
	</monogr>
	<note>Let zs be the first time after (and including) z3 at which there are fewer than cam pebbles on the neighborhood of C,. Let Z &quot; ffi [z4 + 1, zs], and let Z i = [z4 + 1, z6], where z6 = z5 if z5 = za and z6 = z5 -1 otherwise. We have Z i C Z &quot; C Z&apos;. (Furthermore, note that if z6 = z5 -1, then at z5 a pebble is removed from the neighborhood of C,.) During Z. One can pebble any n-vertex graph with 2Pr(n) vertices in O(n 2) time by using Pr(n) pebbles to permanently pebble the vertices of a Pr(n) separator. (See [19, Sec. 3].) The lower bound in Section 5 gives us the following result. Tm~O~M 6.1. Pr(n) ffi ~(n/loglogn. Tighter bounds on Pr(n) and related functions remain to be discovered. REFERENCES</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient compilation of linear recurswe programs. 14th Ann</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Ch^ndra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Syrup. on Switching and Automata Theory</title>
		<imprint>
			<biblScope unit="page" from="16" to="25" />
			<date type="published" when="1973">1973</date>
			<pubPlace>Ames, Iowa</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An observation on time-storage trade-off</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="308" to="316" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Storage requirements for determinisUc polynomial finite recognizable languages</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Coot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>^no Setm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput Syst. $ct</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="25" to="37" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On sparse graphs with dense long paths</title>
		<author>
			<persName><forename type="first">P</forename><surname>Erdos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Graham</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Sze~di</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comp. Math. Appl</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="365" to="369" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Explicit construcuon of linear s~ze concentrators and superconcentrators. 20th Ann</title>
		<author>
			<persName><forename type="first">O</forename><surname>G^bber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Galil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Syrup on Foundations of Computer Science</title>
		<imprint>
			<biblScope unit="page" from="364" to="370" />
			<date type="published" when="1979">1979</date>
			<pubPlace>San Juan, Puerto Rico</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The pebblmg problem is complete in polynomial space</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Gilrert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leng^tmr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>^r~o T~^~q</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="513" to="524" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">AND TA1UAN, R.E Variations of a pebble game on graphs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Gilbert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
			<pubPlace>Stanford, Calff</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science Dep., Stanford Univ</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep No. 661</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Hewlrr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>P^trrson</surname></persName>
		</author>
		<title level="m">Comparative schematology Project MAC Conf. on Concurrent Systems and Parallel Computation</title>
		<meeting><address><addrLine>Woods Hole, Mass</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1970">1970</date>
			<biblScope unit="page" from="119" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><surname>V^u^nt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">L On tune versus space, d ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="332" to="337" />
			<date type="published" when="1977-04">Apr. 1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Tune-space trade-offs for some algebraic problems</title>
		<author>
			<persName><forename type="first">Ja'ja'</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">12th Ann. ACM Syrup. on Theory of Computing</title>
		<imprint>
			<biblScope unit="page" from="339" to="350" />
			<date type="published" when="1980">1980</date>
			<pubPlace>Los Angeles, Calif</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Upper and lower bounds on time-space trade-offs. 1 lth</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lengatmr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ta~an</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann ACM Syrup. on Theory of Computing</title>
		<imprint>
			<biblScope unit="page" from="262" to="277" />
			<date type="published" when="1979">1979</date>
			<pubPlace>Atlanta, Ga</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A P-space complete problem related to a pebble game In F~h Int</title>
		<author>
			<persName><forename type="first">A</forename><surname>Linoas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Colloq. on Automata, Languages and Programming, Lecture Notes m Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Auslello</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Bohm</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="300" to="321" />
			<date type="published" when="1978">1978</date>
			<publisher>Sprmger-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A note on the pebble game Inf</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Loui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc Lett</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="24" to="26" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Explicit constructions of concentrators</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>M^roulis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Problemy Peredachi Informatsii</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="71" to="80" />
			<date type="published" when="1973">1973. 1975</date>
			<publisher>Plenum</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>English trans</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">comparison between two vanations of a pebble game on graphs In 6th Int</title>
		<author>
			<persName><forename type="first">Meyer ^uv Der</forename><surname>Heide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Colloq. on Automata, Languages and Programming, Lecture Notes m Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Maurer</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="page" from="411" to="421" />
			<date type="published" when="1979">1979</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On time h~erarch~es</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>P^~</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann ACM Syrup. on Theory of Computing</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="218" to="222" />
			<date type="published" when="1976">1976</date>
			<pubPlace>Hershey, Pa</pubPlace>
		</imprint>
	</monogr>
	<note>th</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On alternation II. A graph theoreuc approach to determinism versus nondeterunmsm</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Reiscm~k</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="391" to="403" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Tune-space trade-offs in a pebble game Acta</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Tap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="111" to="115" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tapjan</surname></persName>
		</author>
		<author>
			<persName><surname>Andcelom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.R Space bounds for a game on graphs. Math. Syst. Theory</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="239" to="251" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On the complexity of a concentrator</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>I)insrmr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int. Teletraffic Congress</title>
		<meeting>7th Int. Teletraffic Congress<address><addrLine>Stockholm; Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="318" to="319" />
		</imprint>
	</monogr>
	<note>/4 (available from Secretariat. Televerket S-12386, F arsta</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">N</forename><surname>Pippenger</surname></persName>
		</author>
		<author>
			<persName><surname>Superconcentrators</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="298" to="304" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A time-space trade-off</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pippenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J ACM</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="509" to="515" />
			<date type="published" when="1978-07">July 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Comparative schematology and pebbling with auxiliary pushdowns 12th</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pippenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann ACM Symp. on Theory of Computing</title>
		<imprint>
			<biblScope unit="page" from="351" to="356" />
			<date type="published" when="1980">1980</date>
			<pubPlace>Los Angeles, Calif</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Improved bounds on the problem of time-space trade-off in the pebble game</title>
		<author>
			<persName><forename type="first">R</forename><surname>Posiscrruk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. A CM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="839" to="850" />
			<date type="published" when="1980-10">Oct. 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">A famdy of graphs with expensive depth-reducuon</title>
		<author>
			<persName><forename type="first">G</forename><surname>Schnitger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<pubPlace>Bielefeld, W. Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Fakultat fur Mathemauk, Universltat Btelefeld</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Space-time trade-offs on the FFT-algonthm</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Swamy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
		<respStmt>
			<orgName>Brown Univ., Providence, R.I.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. CS-31</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Space-tune trade-offs for mteger multiplication, 6th Int</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Swamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Colloq. on Automata, Languages and Programming</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Maurer</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="page" from="498" to="504" />
			<date type="published" when="1979">1979</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">AND SWAMY, S Space-tune trade-offs for linear recurston. 6th ACM Symp on Principles of Programmmg Languages</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Savage</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="135" to="142" />
			<pubPlace>San Antonio, Texas</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Complete register allocation problems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Setm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Cornput</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="226" to="248" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Time-space trade-offs for computing functions, using connectivity properties of their circuits. 10th Ann</title>
		<author>
			<persName><forename type="first">M</forename><surname>Totcn'a</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symp. on Theory of Computing</title>
		<meeting><address><addrLine>San Diego, Cahf</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="196" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Two familiar transitive closure algorithms which admit no polynomial-time, sublinear space implementations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tomra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">12th Ann. ACM Syrup on Theory of Computing</title>
		<imprint>
			<biblScope unit="page" from="333" to="338" />
			<date type="published" when="1980">1980</date>
			<pubPlace>Los Angeles, Cahf</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Graph-theoretic properties m computational complexity</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sct</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="278" to="285" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Graph-theoretic arguments m low level complexity</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syrup. on Mathemat,cal Foundations of Computer Science</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="162" to="176" />
			<date type="published" when="1977">1977</date>
			<publisher>Sprmger-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Move rules and trade-offs in the pebble game 4th GI Conf. on Theoretical Computer Science</title>
		<author>
			<persName><forename type="first">P</forename><surname>Van Emde-Boas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Goos</surname></persName>
		</editor>
		<editor>
			<persName><surname>Hartmanis</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="page" from="101" to="112" />
			<date type="published" when="1979">1979</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">REVISED MAY 1981; ACCEPTED JUNE</title>
		<author>
			<persName><surname>Received September</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the AssoclaUon for Compuung Machinery</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1979">1979. 1981. October 1982</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
