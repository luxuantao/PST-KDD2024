<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Configurable Software-based Approach for Detecting CFEs Caused by Transient Faults</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2021-05-31">May 31, 2021</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Wei</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Linlin</forename><surname>Ci</surname></persName>
							<email>cilinlin_bit@126.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Liping</forename><surname>Liu</surname></persName>
							<email>liuliping_bit@163.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Configurable Software-based Approach for Detecting CFEs Caused by Transient Faults</title>
					</analytic>
					<monogr>
						<idno type="ISSN">1976-7277</idno>
						<imprint>
							<date type="published" when="2021-05-31">May 31, 2021</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.3837/tiis.2021.05.014</idno>
					<note type="submission">Received July 12, 2019; revised March 4, 2021; accepted May 10, 2021;</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Fault tolerance</term>
					<term>Reliability</term>
					<term>Control flow errors</term>
					<term>Configurability</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Transient faults occur in computation units of a processor, which can cause control flow errors (CFEs) and compromise system reliability. The software-based methods perform illegal control flow detection by inserting redundant instructions and monitoring signature. However, the existing methods not only have drawbacks in terms of performance overhead, but also lack of configurability. We propose a configurable approach CCFCA for detecting CFEs. The configurability of CCFCA is implemented by analyzing the criticality of each region and tuning the detecting granularity. For critical regions, program blocks are divided according to space-time overhead and reliability constraints, so that protection intensity can be configured flexibly. For other regions, signature detection algorithms are only used in the first basic block and last basic block. This helps to improve the fault-tolerant efficiency of the CCFCA. At the same time, CCFCA also has the function of solving confusion and instruction self-detection. Our experimental results show that CCFCA incurs only 10.61% performance overhead on average for several C benchmark program and the average undetected error rate is only 9.29%. CCFCA has high error coverage and low overhead compared with similar algorithms. This helps to meet different cost requirements and reliability requirements.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Transient faults are increasing due to improving circuit integration, reducing voltage levels, increasing transistor counts and reducing noise margins <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref>. Although it does not destroy the internal structure of the integrated circuit, it can affect the operation of the program by changing the state of the processor or the memory cell, thus endangering the reliability of the system.</p><p>The CFEs are caused by instruction address errors, opcode corruption or transforms between non-jump instruction and jump instruction that occurred at program counter, bus, and address calculation unit. The CFEs account for about 30% to 70% of the total errors <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>.</p><p>The CFEs detection technology can be divided into hardware-based methods <ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref>, mixed software-hardware methods <ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref>, and software-based control flow detection technology. The former requires additional hardware components to detect CFEs.</p><p>The research methods of control flow errors caused by transient faults can be divided into hardware methods, mixed software-hardware methods and software methods.</p><p>By code redundancy, the latter assigns different static signature to each basic block and provides signature operation instructions and comparison instructions. When the program is running, a dynamic signature is calculated according to the current control flow and static signature stored in precursor basic block. Finally, the control flow is judged to be normal or not according to comparison results between dynamically generated signature and pre-stored signature. The latter has some advantages over the former, that is, software-based methods do not require auxiliary hardware, have no special requirements of the operating system, have good expansibility and are conducive to the continuous exploration and repeated experiments of the subject.</p><p>The control flow errors of inner-block is a class of errors, i.e., instructions in the basic block are not executed from beginning to end, and some of them are skipped. The error occurrence of inner-block has a low probability than inter-block.</p><p>The probability of CFEs occurring within block is proportional to the instruction number. The smaller basic block contains fewer instructions, and the larger basic block contains more instructions. In addition, the algorithm for detection also increases the number of instructions. This increases the probability that CFEs will occur within a block. Checking for errors within basic blocks is essential.</p><p>Although software methods require no additional auxiliary devices, have no special requirements on the operating system, have good expansibility, and are conducive to the continuous exploration and repeated experiments of the subject. But those bring a large amount of time and space overhead due to the large number of redundant instructions which still have a huge impact on the program performance.</p><p>Our algorithm includes the basic part and the optimization part. The basic part of the algorithm is designed to be more favorable to probe the CFEs of inner-block. For improving fault tolerance efficiency, the optimization part is designed to reduce checkpoints and reconfigure detection regions by criticality analysis and configurability of block size. Our contributions are as following:</p><p>• The algorithm overcomes the problems of high cost and low detection rate of existing detection methods in the detection of inner-block CFEs, by extracting time invariants, assigning unique signature and updates signatures at virtual edges of the control flow graph. • Our algorithm solves the confusion problem with virtual edges.</p><p>• The algorithm implemented configurability of algorithm by analyzing the criticality of each region and tuning the detecting granularity. Configurability ensures that the number of redundant instructions decreases and tolerance efficiency increases when the application requirements are met. The remainder is arranged as following. Section 2 gives the related works on software-based methods. Section 3 gives our methods. Section 4 analyzed the detection capabilities of CFEs. The effectiveness of the proposed method is verified by experiments in section 5 and finally conclusions is given in section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Previous Work</head><p>The control-flow checking technology implemented in software has no special requirements on hardware and operating system but inserts some extra instructions into the normal instructions of the program. Compared to hardware or hybrid implementation technologies, software implementation technologies are low cost and flexible, requiring only software modification to meet changes in demand, and can be used directly on commercial finished devices with low cost, low power consumption and high performance.</p><p>With the goal of detecting CFEs, software-based approaches are implemented by inserting signatures. Clearly, these methods differ from each other lies in the representation of signatures and the design of detection instructions. The detection overhead and detection performance also depend on these two factors.</p><p>CFCSS <ref type="bibr" target="#b13">[14]</ref> method assign signature based on relationship of predecessor. This algorithm gives a signature s i to a basic block. For each basic block, signatures and XOR value D between the current basic block and predecessor are inserted in advance. The XOR value between dynamic signature and D is calculated when the program is executed into a destination block. If the result is the same as the signature of current basic block, the control flow is correct. Vice versa indicates that the control flow is wrong. These methods <ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref> and CFCSS work in the same way.</p><p>Relationship signatures for control flow checking (RSCFC) <ref type="bibr" target="#b18">[19]</ref> encodes basic blocks in binary. These bits contain information of successors blocks. When the program runs into a basic block, the algorithm checks whether the bit corresponding to the current basic block is zero. When the representative number is zero, it means that the program has an illegal jump, and the control flow jump error is detected. Otherwise, it means that the program control flow jumps normally. This encoding can represent a limited blocks number. These methods <ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref> and RSCFC work in the same way.</p><p>ECCA <ref type="bibr" target="#b22">[23]</ref> inserts assertions into each basic block for comparing and updating. Because of the multiplication and division operations used in assertions, this comes at the expense of increased performance overhead. DSM <ref type="bibr" target="#b23">[24]</ref> inserts detection instructions to overcome the detection vulnerability of existing algorithms, but the cost is very high, resulting in a three-fold decrease in program performance and a four-fold increase in storage consumption. CEDA <ref type="bibr" target="#b24">[25]</ref> has the highest fault tolerance efficiency among all known algorithms. Although the algorithm can detect all control flow errors between basic blocks with low performance overhead, it fails to solve the problem of control flow error detection within basic blocks and between processes. In addition, like other existing control flow detection algorithms, CEDA does not have configurability and self-protection ability of fault tolerance mechanism. Control flow checking at virtual edges (CFCVE) <ref type="bibr" target="#b25">[26]</ref> inserts a virtual vertex into each edge at compile time. This together with insertion of signature updating instructions and checking instructions into corresponding vertexes and virtual vertexes. CFCVE has some improvements in performance and overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Methodology</head><p>Existing signature monitoring based inter-block control flow error detection algorithm not only has expensive overhead, but also lack the mechanism of self-protection. To overcome these problems, CCFCA algorithm is proposed, which is an inter-block control flow detection algorithm. The proposed algorithm assigns a unique integer as a signature for each basic block. To generate virtual edge, CCFCA inserts a virtual basic block into the jump branch according to the mapping relationship between the edge of the control flow graph and the program branch. The signature updating operation is transferred to the virtual edge by inserting signature update instructions into the virtual basic block. In order to improve fault tolerance efficiency, CCFCA divides the target program into regions and analyzes their importance. The detection instructions are inserted into nodes in important region. The detection instructions are inserted into entry and exit basic blocks in unimportant region, and the signature generation instructions are inserted into the remaining basic blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Preliminaries</head><p>Here are the definitions that are relevant to our article. Definition 1 (Basic block) Let B represent the basic block. B is an instruction set which executed sequentially, consisting of a unique entry instruction and a unique exit instruction. Definition 2 (Control flow graph) Let CFG = &lt;B, E&gt; denote the ordinal pair which is composed of the basic block set B and the directed edge set E. Definition 3 (Vertex/Node) Each basic block is a vertex or Node. Definition 4 (Virtual Vertex/Node) Virtual Vertex is essentially edge that exist between two vertices/Nodes. Definition 5 (Internode CFEs) All CFEs occur inside the basic block. Definition 6 (Intranode CFEs) All CFEs occur between the basic blocks. Definition 7 (Region of code) Code region is represented by R, which is essentially a collection of basic blocks. Definition 8 (Vulnerability of code) Let V( R i ) denote the vulnerability, then it can be expressed by the formula as:</p><formula xml:id="formula_0">V(R i )= T(R i ) T MT (R) × F(R i ) (1)</formula><p>where R i is a region of code, T(R i ) is the time it takes to execute all the code in R i , F(R i ) is the execution frequency of code in region, T MT (R) is the average running time. The above information can be obtained from the program profile information. Definition 9 (Importance of code) Let I(R i ) be the importance of code, that is, the transient faults occur in R i , which can cause control flow errors. It can be expressed by the formula as:</p><formula xml:id="formula_1">I(R i ) = V(R i ) × P SDC (R i )<label>(2</label></formula><p>) where V(R i ) is the vulnerability of code in region R i , P SDC (R i ) is the probability of silent data corruption. Those can be obtained through error injection experiments. Definition 10 (Relative Importance of code) Let RI(R i ) be the relative importance of code in R i , where I(R i ) is the importance of code in R i , I(R) is numerically the sum importance of all code regions. It can be expressed by the formula as:</p><formula xml:id="formula_2">RI(R i ) = I(R i ) I(R) (3)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Signature generation</head><p>In the previous section, the CFEs detection methods based on software lie in the representation of signatures and the design of detection instructions.</p><p>A well-designed signature approach can reduce unnecessary memory overhead and performance overhead. For example, in RSCFC algorithm, a basic block needs to occupy one bit of signature. When the number of basic blocks exceeds the machine word length, multiple registers must be used to store the same signature data, which increases the complexity of signature allocation and signature operation overhead. The signature of CCFCA algorithm consists of three parts, which are signature field, entry/exit field, and checking field respectively. The signature field is a unique binary number. Entry/exit field contains two bits to indicate that the control flow has entered or left the basic block. The entry/exit signature bit is set to 11 when the program executes inside the basic blocks and to 00 when the program executes outside the basic blocks. Its benefit for detecting instruction itself. The signature checking bit represents the parity of hamming weight in the parity checking field. If the hamming weight is odd, the checking bit is 1; otherwise, it is 0. If the machine word length is N, the maximum effective length of the signature is N-3. For example, the maximum value is 2 61 for a 64-bit machine. This representation enhances the presentation of the signature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Detection principle</head><p>Detection techniques based on software rely on inserting redundant instructions. CCFCA uses the global signature register (GSR) to hold the runtime signature G associated with the current node. Assume that G i is the value of GSR when the control flow enters V i . Then the signature function f (G, d i ) = G ⊕ d i is responsible for updating the value of G at run time. If G i = s i , then the control flow is normal. If G i ≠ s i , then the control flow is abnormal. Suppose there is an edge br sd between V s and V d . That is, there is a jump between V s and V d , where s stands for source and d for destination. Let d d = s s ⊕ s d be the difference of signature and is pre-stored in V d . The value in the general signature register G was G s = s s before the edge br sd appeared. After edge br sd appears then the value of the register changes to</p><formula xml:id="formula_3">G d = f ( G s , d d ). If G d = s d , then the control flow is normal. If G d ≠ s d ,</formula><p>then the control flow is abnormal. As shown in the Fig. <ref type="figure">1</ref>, CCFCA can detect abnormal jump between V 1 and V 4 based on the above principle. However, there may be confusion between the predecessor basic block and successor basic block. As shown in the Fig. <ref type="figure">2</ref></p><formula xml:id="formula_4">, both V 1 and V 3 can reach V 5 . If the signature XOR difference is set to d 5 = s 1 ⊕ s 5 , then the value of G is G 5 = f ( G 1 , d 5 ) = G 1 ⊕ d 5 = s 5 when br 15 appears. If br 35 appears, s 3 ≠ s 1 in V 5 . So the value of G becomes G 5 = f ( G 3 , d 5 ) ≠ s 5 . Given s 3 = s 1 ,</formula><p>then the illegal jump from node 1 to node 4 and illegal jump from node 3 to node 2 are not detected. Adjustment signature D is introduced to solve this problem. But the confusion in Fig. <ref type="figure">3</ref> cannot be solved by adjustment signature. This situation can be summed as pred</p><formula xml:id="formula_5">V 1 V 2 V 3 V 4 V 3 B 3 3 1 3 error G G d br G s D s s = ⊕ ≠ = ⊕ 1 1 error 0000 G G d br G s D = ⊕ ≠ = 1 B 2 2 error G G d br G s = ⊕ ≠ 2 B 5 5 error G G d G G D br G s = ⊕ = ⊕ ≠ 5 B 4 4 error G G d br G s = ⊕ ≠ 4 B 3 3 2 3 3 G G G d br s error D s s B = ⊕ ≠ = ⊕ 2 2 2 G 0000 G G d br s error D B = ⊕ ≠ = 1 1 1 2 1 G G G d br s error D s s B = ⊕ ≠ = ⊕ 6 6 6 G G G d G G D br s error B = ⊕ = ⊕ ≠ 5 5 5 G G G d G G D br s error B = ⊕ = ⊕ ≠ 4 4 4 G G G d br s error B = ⊕ ≠ 4 V 6 V 1 V 2 V 3 V 5 V</formula><formula xml:id="formula_6">(V i ) ≠ pred (V j ) and pred (V i ) -pred (V j ) ≠ ∅. If deg -(V i ) &gt; 1 for all pred (V i ), choose V i as the base block and set D=0, then d 5 = s 1 ⊕ s 5 , D 1 = s 1 ⊕ s 1 , D 2 = s 1 ⊕ s 2 , D 3 = s 1 ⊕ s 3 , d 6 = s 3 ⊕ s 6 , G = G 6 ≠ s 6 .</formula><p>Legal control flow from V 3 to V 6 is misjudged as illegal control flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 3. Confusion can't be resolved by adding D</head><p>In the control flow error detection algorithm based on signature analysis, a legitimate branch corresponds to an edge in the edge set E. The essence of algorithm is to determine whether the edge corresponding to the current branch belongs to the legitimate edge set E. CCFCA embedded a virtual basic block in each edge of the CFG. Since the control flow of the original edge and the virtual edge are equivalent and the virtual basic block does not change the semantics of the program, the edge after inserting the virtual basic block can still be considered as an edge logically. The mechanism of updating signature with virtual base blocks more accurately expresses the relationship between the predecessor node and successor node.</p><p>CCFCA updates signature in virtual basic block by inserting signature updating instructions and detects CFEs by inserting comparison instruction in basic block. A signature comparison instruction br (G ≠ Entry (s i )), updating instructions G=G ⊕ Exit (s i ) and G = G ⊕ Entry (s j ) are inserted in the virtual basic block, where and indicate that the entry/exit bits of signature were 0 or 1. CCFCA uses a dedicated register to store G. The value of G is s i before V j flows to the virtual basic block V ij and the entry/exit bits of signature were 1. The first</p><formula xml:id="formula_7">updating instruction G= G ⊕ Exit (s i ) is executed. The value of G is updated G = G ⊕ Entry (s i ) = Entry (s i ) ⊕ Entry (s i ) = 0.</formula><p>Then the second updating instruction G = G ⊕ Entry (s j ) is executed. The value of G becomes s j and the Entry/Exit bits were 1. Next the jump instruction is executed and program is transferred to the header of basic block V j . The</p><formula xml:id="formula_8">) ( i s Entry ) ( i s Exit</formula><p>comparison instruction br (G ≠ Entry (s j )) error is executed. In the absence of control-flow error, the signature value in G is equal to s j , and if the value in G is not equal to s j , then the control flow is transferred to an exception program after CFEs occurs. As shown in Fig. <ref type="figure" target="#fig_1">4</ref>, V 13 is inserted between V 1 and V 3 . If V 1 jumps to V 3 along a legitimate branch then the value of G is updated to Entry (s 3 ). G = Entry (s 3 ) when the checking instruction in node V 3 is executed. At this point, you can verify that the program control flow is normal. Given V 1 jumps to V 4 , the value of G in V 4 is not equals to Entry (s 4 ). At this point, checking instruction can detect the control flow error.</p><p>( ) CFEs may bypass the detection mechanism by directly skipping the signature comparison instruction. Therefore, the detection mechanism should be able to detect the abnormal behavior that bypasses the detection mechanism. The Entry/Exit bits were set to 0 and 1 respectively according to the location of control flow. The status of the Entry/Exit bits is only updated within the block by inserting two instructions located in header and tail respectively. The first Entry/Exit bits instruction precedes the detection instruction. The second Entry/Exit bits instruction precedes the jump instruction. Errors skipped the first and second instructions are detected. The process of changing the status of Entry/Exit bits from 0 to 1 is driven by EntryFactor (s i ) and ExitFactor (s i ). Transit (s i ) indicates that the first and second bits are 1 and 0, respectively.</p><formula xml:id="formula_9">1 ( ) error br G Entry s ≠ 1 V 13 V 1 ( ) G G Exit s = ⊕ 3 ( ) G G Entry s = ⊕ ( ) 3 ( ) error br G Entry s ≠ 3 V ( ) 2 ( ) error br G Entry s ≠ 2 V 24 V 2 ( ) G G Exit s = ⊕ 4 ( ) G G Entry s = ⊕ 25 V 2 ( ) G G Exit s = ⊕ 5 ( ) G G Entry s = ⊕ ( ) 4 ( ) error br G Entry s ≠ 4 V ( )<label>3</label></formula><p>As shown in Table <ref type="table" target="#tab_0">1</ref>, the following conditions should be met by EntryFactor (s i ) and ExitFactor (s i ) respectively. Condition 1 ensure that the update operation only updates the target data bit in the Entry/Exit bits; Condition 2 ensure that all data bits in the signature field are unaffected; Condition 3 ensure the correctness of parity check bit. </p><formula xml:id="formula_10">i ) (1)</formula><p>The first bit and the second bit are 1 and 0 respectively.</p><p>(2) All the bits are 0 in signature field (3) Parity checking is 1 ExitFactor (s i ) (1) The first bit and the second bit are 0 and 1 respectively.</p><p>(2) All the bits are 0 in signature field (3) Parity checking is 1</p><p>When detecting control flow errors by redundant instructions, control flow errors may occur in redundant instructions themselves. The parity of hamming weight is consistent with checking bit in G without SEU. There are two signature updating instructions and two signature updating instructions inside per virtual node and node respectively. The result is that these signature updating instructions may not execute in the expected order. The parity of hamming weight is consistent with checking bit due to XOR operation.</p><p>CCFCA realizes control flow error detection by redundant instruction. Suppose the number is n. The more redundant instructions, the lower the detection efficiency. Therefore, it is necessary to find a balance between efficiency and redundant instruction. CCFCA adds control flow detection instructions (including signature generation instructions, signature comparison instructions, and signature preparation instructions) to each basic block and virtual basic block in the important regions. For the relatively unimportant region, only the unique entrance and exit basic blocks of this area are configured with signature detection instructions, while the remaining basic blocks are only equipped with signature generation instructions. For relatively unimportant areas, this only increases the error detection delay of the control flow appropriately, saves time and space overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Detection capabilities of CCFCA</head><p>The CFEs may occurs between or within basic blocks. The illegal CFEs are grouped into six types.</p><p>Type 1 Illegal branch jumps from nodes or virtual nodes to the second instruction of a node head.</p><p>Type 2 Illegal branch jumps from nodes or virtual nodes to any middle instruction of a node. Type 3 Illegal branch jumps from node or virtual nodes to the tail instruction of a node. Type 4 Illegal branch leaves the node from any instruction of a node head. Type 5 Illegal branch leaves the node from any middle instruction of a node. Type 6 Illegal branch leaves the node from any end instruction of a node. Case 1-1 If the illegal branch jumps from the first instruction of virtual node V i where V i ∈ 𝑝𝑝𝑝𝑝𝑝𝑝𝑝𝑝(V j ), then the value in signature register is 0 before the illegal branch jump. The signature comparison instruction br (G ≠ Transit (s j )) error in V j is executed after the illegal branch jump. since the value is not equal to Transit (s j ) at run time. The illegal jump is detected and program running into a handling mechanism. Given illegal branch jumps from the second instruction of virtual node V i , then signature register value is Entry (s j ) before the illegal branch. The signature comparison instruction br (G ≠ Transit (s j )) error in V j is executed after the illegal branch jump. Since the signature value is not equal to Transit (s j ) at run time. The illegal branch is detected and program runs into a handling mechanism.</p><p>Case 1-2 If the illegal branch jumps from the arbitrary instruction of node V i where V i ∉𝑝𝑝𝑝𝑝𝑝𝑝𝑝𝑝(V j ), then the register values can only be one of Entry (s i ), Transit (s i ) and Exit (s i ). Because none of the run-time signatue values are equal to Transit (s j ) . The detection mechanism transfers the control flow to error handling routines. If V i is a virtual basic block and V k ∈ 𝑝𝑝𝑝𝑝𝑝𝑝𝑝𝑝(V i ), then the run-time signature in the signature register before an illegal branch jump may have a value of 0 and Entry (s k ). The register value does not equal is Transit (s j ). So the llegal jump starts from the arbitrary instruction of basic block V i can be detected. Based on the above analysis, the type 1 can be detected.</p><p>Case 2-1 If there is an illegal jump from virtual basic block (or basic block) V i to basic block V j , and V i ∈ 𝑝𝑝𝑝𝑝𝑝𝑝𝑝𝑝(V j ). The case is similar to 1-1. The difference is that the illegal branch skips the detection instruction at the head of the node and the illegal jump is detected by the detection instruction.</p><p>Case 2-2 If there is an error from virtual node (or node) V i to V j where V i ∉𝑝𝑝𝑝𝑝𝑝𝑝𝑝𝑝(V j ). The case is similar to 1-2. The difference is that the illegal branch skips the detection instruction at the head of the node and the illegal jump is detected by the detection instruction at the end of the node. Case 2 can be detected.</p><p>Case 3-1 The proof is the same as type 2.</p><p>Case 4-1 If there is an illegal branch from virtual node (or node) V i to node V j where V j ∈ 𝑠𝑠𝑠𝑠𝑠𝑠(V i ), then the value of register is Transit (s i ). If the illegal branch jumps to the initiation of V j , then the G=G ⊕ Exit (s i ) and G=G ⊕ Entry (s j ) are executed. The control flow is then sequentially executed to the head of V k which is the successor of V j . When the second instruction of V k is executed, the dynamic signature will be compared with Transit (s k ). Illegal jumps are detected when the comparison results are not equal. The scenario where an illegal branch jumps to the other two instructions is similar to the detection scenario where it jumps the first instruction.</p><p>Case 4-2 If there is an illegal branch jumps from virtual node V i to node V j where V j ∉𝑠𝑠𝑠𝑠𝑠𝑠(V i ), then the value of register is Transit (s i ). The instruction br (G ≠ Transit (s j )) error is executed when the illegal branch jumps to the head of V j . The value of register G updated to G=Transit (s i ) ⊕ Transit (s j ). At this point, the detection mechanism detects the control flow error. The instruction br (G ≠ Exit (s j )) error is executed when the illegal branch jumps to the middle or end of V j . The value of register G is not equal to Exit(s j ). At this point, the detection mechanism detects the illegal control flow. If V j is a virtual basic block and its successor is V k , then the instruction G=G ⊕ Exit (s i ) and the instruction G = G ⊕ Entry (s j ) are executed after the illegal branch jump to the first instruction of V j . And the run-time signature will compared with signature Transit (s k ). The CFE is detected. The illegal branch jumps to the second or the third instruction is similar to the first instruction. Based on the above analysis, the type 4 can be detected.</p><p>Case 5-1 The proof is the same as type 4.</p><p>Case 6-1 If there is an illegal jump from virtual basic block (or basic block) V i to basic block V j , V j ∈ 𝑠𝑠𝑠𝑠𝑠𝑠(V i ) , V k ∈ 𝑠𝑠𝑠𝑠𝑠𝑠(V j ) and the value of register is Exit (s i ) , then G=G ⊕ Exit (s i ) and G = G ⊕ Entry (s j ) are executed and the value of G is updated to Entry (s i ). The control flow enters the V k and the value of G equals to Entry (s j ). Therefore, the branch is considered legal. If the illegal branch jumps to the second instruction of V j , then the instruction G = G ⊕ Entry (s j ) is executed. And then the control flow goes into V k .</p><p>The value of G becomes G=Exit (s i ) ⊕ Entry (s k ) ⊕ EntryFactor (s k ). The illegal branch is detected because of the instruction br (G ≠ Transit (s k )) error. The illegal branch jumps to the third instruction is similar to the second instruction.</p><p>Case 6-2 If V j is a basic block and V j ∉𝑠𝑠𝑠𝑠𝑠𝑠(V i ) , then the value of G equals to G=Exit (s i ) ⊕ Transit (s k ) after the instruction br (G ≠ Transit (s j )) error. At this point, the illegal branch is detected. If V j is a virtual basic block and V k ∈ 𝑠𝑠𝑠𝑠𝑠𝑠(V j ), then G=G ⊕ Exit (s i ) and G = G ⊕ Entry (s j ) are executed after the illegal branch jumps to the first instruction of V i . The G will compare with Transit (s k ) after the second instruction of V k is executed. At this point, the illegal branch is detected. The rest is similar to those described above. Based on the above analysis, the type 6 can be detected. CCFCA can detect all CFEs between basic blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experimental evaluation 5.1 The experiment method</head><p>The experiments used in this section are reinforcement experiment, contrast experiment and fault tolerance efficiency experiment commonly used in this research field. The experimental environment, tools and benchmark programs used in our experiments are common in such studies. The algorithms CFCSS, RSCFC, CEDA, CFCVE and BGCFC used for comparison are also representative algorithms in the latest findings.</p><p>The validation of fault-tolerant technology usually uses some benchmark programs for fault injection. This paper uses five benchmark programs including Matrix Multiplication (MM), Traveling Saleman Problem(TSP), Quick Sort(QS), Shuffle and Hanoi which are widely used in other similar algorithms.</p><p>The main technical steps in our experiments include source code compilation into assembly language, redundant code insertion, compilation and simulation. In our experiment, the evaluation is using the SimpleScalar simulator 3.0 <ref type="bibr" target="#b26">[27]</ref> developed by Todd Austin. The SimpleScalar emulator is deployed on target machines with an ARM920T processor, 16G of SDRAM and operation system of Linux kernel 2.6.32. All experiments in this section use open source software SDCC <ref type="bibr" target="#b27">[28]</ref> to compile programs into assembly code. The preprocessor is written by Flex++ lexical analyzer <ref type="bibr" target="#b28">[29]</ref>. The simulator tests the program after interpreter and connector generate the code. PINFI <ref type="bibr" target="#b29">[30]</ref> is used for error injection at the assembly level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance evaluation</head><p>The core of the reinforcement experiment is the selective instruction redundancy technology, signature analysis and control flow detection technology. Without reinforcement mechanism, we test the system detection, running time, detection of mechanism, result correctness. Then with CCFCA, we test the system detection, running time, detection of mechanism, result correctness again. By comparing the change of system detection, running time, detection of mechanism, result correctness, we can see the effectiveness of CCFCA.</p><p>Firstly, a certain number of benchmark programs are selected, and the selected benchmark programs are copied into two copies. The original programs and the reinforced programs are compiled and the set of target instructions and operands for fault injection is selected. PINFI is used to implement fault injection in assembly language layer. Like other literatures, the experiment in this section is based on SEU. 5000 injections were performed. According to the detection result of CFEs, the injection results are divided into five types including SD, T, D, IR and CR.  The program is hung or exceeded the running time D (Detected)</p><p>The fault is detected by detection mechanism IR (Incorrect Result)</p><p>The fault is not detected but the output is wrong CR (Correct Result)</p><p>The fault is not detected but the output is correct</p><p>As shown in Table <ref type="table" target="#tab_3">3</ref>, timeout failures accounted for 5.0%, 3.37%, 1.54%, 5.2%, and 7.5% of the total number of tests in each benchmark program, respectively. In the third row of the table. Faults with incorrect results accounted for 14.0%, 37.8%, 35.6%, 52.5% and 19.5% of the total number of tests in each benchmark program, respectively. The fourth row in the table shows that despite the failure, the program still runs to the end and produces the correct results. The benign failure accounted for 26.0%, 33.63%, 31.43%, 19.0% and 60.0% of the total experiments of various benchmark programs, respectively. The fifth line in the table refers to the system faults detected by the operating system, accounting for 55.0%, 46.0%, 37.0%, 43.5% and 39.0% of the total experiments of various benchmark programs, respectively. As shown in the last row of the table, the proportion of unsafe failures generated by the failure injection experiment is 19.0%, 41.17%, 37.14%, 57.7% and 27.0%, respectively, whose value is equal to the sum of the timeout faults and the result error faults. The original program did not add an additional detection mechanism during the failure injection experiment. Therefore, the D of each original program in line 6 is 0.</p><p>In addition to these, the difference between the result of the benchmark programs are determined by the type of the programs. For example, jumping intensive algorithms have small basic blocks and a lot of redundant instructions. The calculation intensive algorithms have bigger basic blocks and smaller redundant instructions than jumping intensive algorithms. The benchmark program has a high probability of producing correct results without detection mechanism. The reason is that some faults are shielded by the program itself. After analysis, it can be seen that the fault can be shielded by the program itself for two reasons :(1) when the fault is injected to the target address of the condition branch, if the jump operation does not occur, the injected fault will not affect the program results;(2) the injection failure may cause some instructions of the program to be repeated or skipped. If the instructions are repeated or skipped without changing the program semantics, the results of the program will not be affected.</p><p>After CCFCA reinforcement, timeout failures accounted for 1.0%, 2.2%, 12.0%, 1.70% and 1.75% of the total number of tests in each benchmark program, respectively. In the third row of the table. Faults with incorrect results accounted for 2.0%, 7.94%, 1.1%, 5.7% and 5.2% respectively. The fourth line adopts the algorithm in this chapter as a detection mechanism, and the faults detected account for 29.4%, 36.6%, 34.3%, 37.8% and 39.9% of the total number of experiments in each benchmark program, respectively. The correct result failures in the fifth row of the table accounted for 47.0%, 31.2%, 42.0%, 33.2% and 30.2% respectively. The failures detected by the operating system in the sixth row accounted for 20.6%, 20.6%, 19.3%, 19.7% and 21.0% respectively. The faults not secured accounts for 3.0%, 9.94%, 13.1%, 7.4% and 6.95% respectively. Its value is equal to the sum of incorrect result fault and timeout fault percentage. The average undetectable error was 8.078%.</p><p>CCFCA significantly increases the fault coverage value and enhances the fault coverage ability. CCFCA based on the mapping relation uses the virtual node to generate virtual edge, transfers the signature updating operations to a virtual edge, so accurately expresses the relationship between precursor node and successor node, simplifies the control graph algorithm and reduces the test cost. In addition, the algorithm further carries on the key area analysis. These can further reinforce the benchmark programs without a huge number of instructions. Coverage of faults is the sum of D, T, CR, and SD. In Fig. <ref type="figure">5</ref>, S and R2 represent the coverage of fault of benchmark program without and with reinforced by CCFCA respectively. The CF of MM, TSP, QS, Shuffle and Hanoi was 86%, 62.92%, 64.4%, 47.5% and 80.5% respectively before reinforcement. After the reinforcement, the CF becomes 98%, 92.6%, 98.9%, 94.3% and 94.8% respectively. Some injection errors were not detected resulting in FNS. As show in Fig. <ref type="figure">6</ref>, IR is equal to the sum of T and IR. The FNS of MM, TSP, QS, Shuffle and Hanoi was 19.0%, 41.7%, 37.14%, 57.7% and 27.0% respectively. These benchmarks have been reinforced so that FNS becomes 3.0%, 9.94%, 13.1%, 7.4% and 6.95% respectively.   The T of original program, BGCFC, CFCSS, CEDA, CFEVE, RSCFC and CCFCA is 4.522%, 2.834%, 5.3%, 5.32%, 2.734%, 2.76% and 3.052% respectively. The SD of original program, BGCFC, CFCSS, CEDA, CFEVE, RSCFC and CCFCA is 29.73%, 20.714%, 24.2%, 23.02%, 20.412%, 18.808% and 20.24% respectively. The CR of original program, BGCFC, CFCSS, CEDA, CFEVE, RSCFC and CCFCA is 34.012%, 28.022%, 33.74%, 33.08%, 28.4%, 29.494% and 36.72% respectively. The D of original program, BGCFC, CFCSS, CEDA, CFEVE, RSCFC and CCFCA is 0, 40.51%, 23.82%, 25.52%, 48.148%, 40.616% and 35.6% respectively. Even without detection algorithms, the failure coverage of the original program averaged 68.2%. The reason is that part of the fault is shielded by the program itself, the jump does not occur, instructions are repeated or skipped without changing the program semantics.</p><p>CFCVE algorithm adopts virtual node to represent branch jump relation instead of writing branch jump relation into signature and effectively solves the non-detection zone and performance overhead problem. However, the self-protection mechanism of CFCVE results in additional instruction overhead. Each basic block of CEDA is assigned an entry signature and an exist signature. In order to overcome the conflict of the sector nodes, CEDA designs the same exit signature for each precursor node. But it greatly increases the complexity of signature allocation. CEDA algorithm overcomes the detection vulnerability of CFCSS algorithm, it does not have the ability to detect control flow within blocks and between processes. When the benchmark program contains a basic block with a large instruction size, the IR and FNS will increase. RSCFC algorithm does not have the ability to detect control flow errors in blocks. RSCFC encodes the jump relation between the basic blocks into the signatures and assigns the position information signature to each basic block. At runtime, RSCFC performs logic operation on dynamic signature and position information signature to detection. RSCFC solves the sector conflict well with high error coverage. However, coding the jumping relation between the basic blocks into the signature makes the signature length exceed the machine byte length. To solve this problem, block coding is required for basic blocks, which increases the algorithm complexity and detection cost. The node is divided into two sub-nodes to convert the equivalence, so that the control flow error between the sub-blocks, to achieve the purpose of reducing the error type of the control flow. BGCFC has time complexity O(N!). When the number of nodes is large and the jump is complex. The BGCFC algorithm overcomes the problem of excessive overhead of RSCFC but inherits the advantage of high CF. The basic principle of CCFCA algorithm combines the advantages of CFCSS and CFCVE by region importance analysis and overcomes the confusion by virtual basic block. Since the condition branch does not occur, the IR of CFCSS and CCFCA have been significantly reduced.</p><p>The number of redundant instructions is related to the program type. Branch jump intensive program has small basic block and jumps frequently. Operation intensive program has large node. The instructions inserted in each node is basically the same, the more basic blocks obtained, the more instruction inserted.</p><p>As show in Fig. <ref type="figure">8</ref>, BGCFC divides each node into two sub-nodes. This avoids the case where the starting node of a legitimate jump branch is the same basic block as the destination node. BGCFC algorithm assigns consecutive integer signature for predecessor of each basic block. When the number of predecessor nodes is 1, two detection instructions are inserted into the basic block; when the number of predecessor nodes is greater than 1, up to 8 detection instructions are inserted into the basic block. RSCFC assigns jump relation and location information to each node of the benchmark programs. When the node number is larger than the machine expression number, multiple registers are introduced to store the same signature data. Therefore, RSCFC assigns at least three special registers and seven detection instructions to each basic block. RSCFC algorithm and BGCFC algorithm have the same performance overhead when the node number is less than the machine expression number. RSCFC algorithm has a slightly lower performance overhead than BGCFC algorithm when the node number is larger than the machine expression number. For example, the additional overhead of BGCFC algorithm in QS, TSP and Hanoi programs are 22.3%, 21.5% and 43.7% respectively, which are lower than the 32.7%, 33.2% and 42.31% of RSCFC algorithm. CFCVE algorithm expresses branch jump relation through virtual edge and inserts 4 instructions in each basic block and 3 instructions in each virtual basic block to complete the detection. On average, the algorithm needs to insert 5.5 instructions on average to complete the detection task. CFCVE has less performance overhead than BGCFC in computationally intensive programs. For example, the BGCFC algorithm in the MM program has an additional 17.4% performance overhead, and the CFCVE algorithm has an additional 16.0% performance overhead. BGCFC algorithm in Shuffle program added an additional 43.21% of the performance overhead, CFCVE algorithm added an additional 33.14% of the performance overhead. CCFCA algorithm divides the importance of the code area and inserts 3-5 instructions on average. CEDA algorithm inserts 4 instructions in each node. However, the insertion number of CCFCA algorithm is still less than CFCSS algorithm. Therefore, the performance overhead of CCFCA algorithm is lower than that of CFCSS algorithm and CEDA algorithm. For example, CFCSS, CEDA, and CCFCA algorithms have an additional performance overhead of 13.7%, 14.0%, and 10.5%, respectively, in the program MM and Shuffle. Additional performance overhead in the Shuffle was 23.0%, 24.1%, and 20.5% respectively. </p><p>Here Ta and Tb respectively represent the time executed the after reinforcement and the time taken to execute the program before reinforcement. In MM, TSP, QS, Shuffle and Hanoi, the average performance overhead of BGCFC, CFCSS, CEDA, CFCVE, RSCFC and CCFCA was 29.624%, 26.38%, 27.04%, 34.398%, 35.0212 and 22.8%, respectively. Therefore, as shown in Fig. <ref type="figure">9</ref>, the fault tolerance efficiency of the six detection algorithms BGCFC, CFCSS, CEDA, CFCVE, RSCFC and CCFCA is 42.6217%, 29.2948%, 28.3171%, 34.9752%, 34.3116% and 100.02% respectively. Obviously, CCFCA algorithm proposed in this paper has the largest value of fault tolerance efficiency and the best comprehensive detection performance, which is higher than other control flow detection algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and Future Research</head><p>This paper presents CCFCA algorithm. The algorithm is configurable by an assessment of the importance of code. For critical regions, program blocks are divided according to space-time overhead and reliability constraints, so that protection intensity can be configured flexibly. For other regions, signature detection algorithms are used only in the first and last nodes of the region. It is benefit for improving the fault-tolerant efficiency of the CCFCA. At the same time, CCFCA also has the function of solving confusion and instruction self-detection. Our experimental results show that CCFCA has high fault tolerance and low overhead. This helps to meet different cost requirements and reliability requirements.</p><p>Further work is to eliminate the inaccessible path and generate the control flow graph accurately. It helps optimize CCFCA to reduce redundancy.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 . 2 .</head><label>12</label><figDesc>Fig. 1. Control flow detection Fig. 2. Confusion can be resolved by adding D</figDesc><graphic url="image-1.png" coords="6,89.34,142.90,193.14,105.97" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. An example of CCFCA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>If the running time of basic block B i is T B i i=1,⋯,n. If the running time of redundant instruction C i added to each basic block is T C i i=1,⋯,n. Then total running time of the program is 𝑇𝑇 = ∑ (𝑇𝑇 𝐵𝐵 𝑖𝑖 + 𝑇𝑇 𝐶𝐶 𝑖𝑖 ) 𝑛𝑛 𝑖𝑖=1. Suppose the average current and voltage are I and V respectively. Then the power consumption of the program is E = P × T, where P = I × V. The execution time and performance cost of the control flow detection algorithm are proportional to the size of the program itself and the size of redundant instruction added. A program running on a computer typically consumes most of its execution time in partial code which is relatively important code. Then the definition 7-10 related to configurability of CCFCA are given in section 3.1. Different parts of the program have different SDC error probability. If RI(R i ) ≥ ε, the region R i is taken as relative importance region for importance threshold ε. The remaining region is unimportant region.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 . 6 .</head><label>56</label><figDesc>Fig. 5. The comparison of CF Fig. 6. The comparison of IR</figDesc><graphic url="image-2.png" coords="12,86.80,457.36,210.35,148.77" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Detection performance comparison of five algorithms</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8 . 9 .</head><label>89</label><figDesc>Fig. 8. Overhead comparison of five algorithms Fig. 9. Comparison of EFT</figDesc><graphic url="image-5.png" coords="15,82.95,142.50,228.95,161.93" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Condition table of EntryFactor (s i ) and ExitFactor (s i )</figDesc><table><row><cell>Concept</cell><cell>Condition</cell></row><row><cell>EntryFactor (s</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc>lists these types.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>Detection result of injection</figDesc><table><row><cell>Type</cell><cell>Annotation</cell></row><row><cell cols="2">SD (System Detection) The fault is detected by system</cell></row><row><cell>T (Timeout)</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 .</head><label>3</label><figDesc>Original programs without reinforcement</figDesc><table><row><cell></cell><cell>MM</cell><cell>TSP</cell><cell>QS</cell><cell>Shuffle</cell><cell>Hanoi</cell></row><row><cell>T (%)</cell><cell>5.0/1.0</cell><cell>3.37/2.2</cell><cell>1.54/12.0</cell><cell>5.2/1.70</cell><cell>7.5/1.75</cell></row><row><cell>IR (%)</cell><cell>14.0/2.0</cell><cell>37.8/7.94</cell><cell>35.6/1.1</cell><cell>52.5/5.7</cell><cell>19.5/5.2</cell></row><row><cell>CR (%)</cell><cell>26.0/47.0</cell><cell>33.63/31.2</cell><cell>31.43/42.0</cell><cell cols="2">19.0/33.2 60.0/30.2</cell></row><row><cell>SD (%)</cell><cell>55.0/20.6</cell><cell>46.0/20.6</cell><cell>37.0/19.3</cell><cell cols="2">43.5/19.7 39.0/21.0</cell></row><row><cell>D (%)</cell><cell>0/29.4</cell><cell>0/36.6</cell><cell>0/34.3</cell><cell>0/37.8</cell><cell>0/39.9</cell></row><row><cell>Total (%)</cell><cell>100</cell><cell>100</cell><cell>100</cell><cell>100</cell><cell>100</cell></row><row><cell>Fault not secured (%)</cell><cell>19.0/3.0</cell><cell>41.17/10.14</cell><cell>37.14/13.1</cell><cell>57.7/7.4</cell><cell>27.0/6.95</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>Our article receives the National Natural Science Foundation of China under grant No. 61370134, the National High Technology Research and Development Program of China (863 Program) under grant No. 2013AA013901.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">X-ray and proton radiation effects on 40 nm CMOS physically unclonable function devices</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.1109/TNS.2017.2789160</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Nuclear Science</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1519" to="1524" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The limits of space radiation magnetic shielding: an updated analysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Musenich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Calvelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Giraudo</surname></persName>
		</author>
		<idno type="DOI">10.1109/TASC.2017.2785805</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Applied Superconductivity</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="5" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Impact of VCO topology on SET induced frequency response</title>
		<author>
			<persName><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Varanasi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pouget</surname></persName>
		</author>
		<idno type="DOI">10.1109/tns.2007.911422</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Nuclear Science</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="2500" to="2505" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An estimate of error rates in integrated circuits at aircraft altitudes and at sea level</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Dicello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paciotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Schillaci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nuclear Instruments and Methods in Physics Research Section B: Beam Interactions with Materials and Atoms</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1295" to="1299" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Evaluation of SEU performance of 28-nm FDSOI flip-flop designs</title>
		<author>
			<persName><forename type="first">H B</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Kauppila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lilja</surname></persName>
		</author>
		<idno type="DOI">10.1109/TNS.2016.2630022</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Nuclear Science</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="367" to="373" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A study of the effects of transient fault injection into a 32-bit RISC with built-in watchdog</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ohlsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rimen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Gunneflo</surname></persName>
		</author>
		<idno type="DOI">10.1109/FTCS.1992.243569</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE International Symposium on Fault-Tolerant Computing</title>
				<meeting>of IEEE International Symposium on Fault-Tolerant Computing</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="316" to="325" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Processor Control Flow Monitoring Using Signatured Instruction Streams</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schuette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<idno type="DOI">10.1109/tc.1987.1676899</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers, C</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="264" to="276" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient mitigation of data and control flow errors in microprocessors</title>
		<author>
			<persName><forename type="first">L</forename><surname>Parra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lindoso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Portela</surname></persName>
		</author>
		<idno type="DOI">10.1109/RADECS.2013.6937381</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of European Conference on Radiation &amp; Its Effects on Components &amp; Systems</title>
				<meeting>of European Conference on Radiation &amp; Its Effects on Components &amp; Systems</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Watchdog processors and capability checking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Namjoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Mccluskey</surname></persName>
		</author>
		<idno type="DOI">10.1109/FTCSH.1995.532618</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of Twenty-Fifth International Symposium on Fault-Tolerant Computing</title>
				<meeting>of Twenty-Fifth International Symposium on Fault-Tolerant Computing</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">HETA: hybrid error-detection technique using assertions</title>
		<author>
			<persName><forename type="first">Altieri</forename><forename type="middle">M</forename><surname>Azambuja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Becker</surname></persName>
		</author>
		<idno type="DOI">10.1109/TNS.2013.2246798</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Nuclear Science</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="2805" to="2812" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automotive internal-combustion-engine fault detection and classification using artificial neural network techniques</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">El</forename><surname>Sayed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gadsden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename></persName>
		</author>
		<idno type="DOI">10.1109/tvt.2014.2317736</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Vehicular Technology</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="33" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Analysis and optimization of soft error tolerance strategies for real-time systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhu</surname></persName>
		</author>
		<idno type="DOI">10.1109/CODESISSS.2015.7331368</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of International Conference on Hardware/software Codesign and System Synthesis</title>
				<meeting>of International Conference on Hardware/software Codesign and System Synthesis</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
	<note>CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On-line error detection in digital microfluidic biochips</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghoshal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Rahaman</surname></persName>
		</author>
		<idno type="DOI">10.1109/ATS.2012.56</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21th Test Symposium</title>
				<meeting>of the 21th Test Symposium</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="332" to="337" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Control-flow checking by software signatures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Oh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Shirvani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Mccluskey</surname></persName>
		</author>
		<idno type="DOI">10.1109/24.994926</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Reliability</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="111" to="122" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An efficient control-flow checking technique for the detection of soft-errors in embedded software</title>
		<author>
			<persName><forename type="first">T</forename><surname>Boroomandnezhad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Azgomi</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.compeleceng.2013.03.015</idno>
	</analytic>
	<monogr>
		<title level="j">Computers and Electrical Engineering</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1320" to="1332" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Bipartite graph-based control flow checking for COTS-based small satellites</title>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jin</forename><forename type="middle">Z</forename></persName>
		</author>
		<idno type="DOI">10.1016/j.cja.2015.04.010</idno>
	</analytic>
	<monogr>
		<title level="j">Chinese Journal of Aeronautics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="883" to="893" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A control flow representation for component-based software reliability analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mohamed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zulkernine</surname></persName>
		</author>
		<idno type="DOI">10.1109/SERE.2012.33</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th IEEE International Conference on Software Security and Reliability</title>
				<meeting>of the 6th IEEE International Conference on Software Security and Reliability</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">software-based error detection technique for monitoring the program execution of RTUs in SCADA</title>
		<author>
			<persName><forename type="first">N</forename><surname>Rajabpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sedaghat</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-24255-2_33</idno>
	</analytic>
	<monogr>
		<title level="m">Computer Safety, Reliability, and Security</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On-line control flow error detection using relationship signatures among basic blocks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hong</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.compeleceng.2008.08.010</idno>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Electrical Engineering</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="132" to="141" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">SEDSR: Soft Error Detection Using Software Redundancy</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Asghari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Abdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Taheri</surname></persName>
		</author>
		<idno type="DOI">10.4236/jsea.2012.59078</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Software Engineering &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="664" to="670" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Software-based control flow checking against transient faults in industrial environments</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Asghari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Taheri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pedram</surname></persName>
		</author>
		<idno type="DOI">10.1109/TII.2013.2248373</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Industrial Informatics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="481" to="490" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An efficient software defect prediction model using optimized tabu search branch and bound procedure</title>
		<author>
			<persName><forename type="first">G</forename><surname>Pandiyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Krishnakumari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Metropolitan Museum of Art Bulletin</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="79" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Design and evaluation of system-level checks for on-line control flow error detection</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Alkhalifa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S S</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel &amp; Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="627" to="641" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Software detection mechanisms providing full coverage against single bit-flip faults</title>
		<author>
			<persName><forename type="first">B</forename><surname>Nicolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Savaria</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Velazco</surname></persName>
		</author>
		<idno type="DOI">10.1109/tns.2004.839110</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Nuclear Science</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="3510" to="3518" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">CEDA: Control-Flow Error Detection Using Assertions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Vemu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Abraham</surname></persName>
		</author>
		<idno type="DOI">10.1109/tc.2011.101</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1233" to="1245" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>Article (CrossRefLink</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Control Flow Checking at Virtual Edges</title>
		<author>
			<persName><forename type="first">Liu</forename><surname>Liping</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">I</forename><surname>Linlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liu</forename><surname>Wei</surname></persName>
		</author>
		<idno type="DOI">10.1109/iThings-GreenCom-CPSCom-SmartData.2016.174</idno>
	</analytic>
	<monogr>
		<title level="j">KSII Transactions on Internet and Information Systems</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="396" to="413" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>Article (CrossRefLink</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">SimpleScalar: an infrastructure for computer system modeling</title>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ernst</surname></persName>
		</author>
		<idno type="DOI">10.1109/2.982917</idno>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="59" to="67" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Article (CrossRefLink</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An open-source binary utility generator</title>
		<author>
			<persName><forename type="first">A</forename><surname>Baldassin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Centoducatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rigo</surname></persName>
		</author>
		<idno type="DOI">10.1145/1344418.1344423</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Design Automation of Electronic Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>Article (CrossRefLink</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Building High-Performance Application Protocol Parsers on Multi-core Architectures</title>
		<author>
			<persName><forename type="first">Kai</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junchang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bei</forename><surname>Hua</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICPADS.2011.37</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of 2011 IEEE 17th International Conference on Parallel and Distributed Systems</title>
				<meeting>of 2011 IEEE 17th International Conference on Parallel and Distributed Systems</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Article (CrossRefLink</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<idno type="DOI">10.1145/1064978.1065034</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Sigplan Notices</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="190" to="200" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Article (CrossRefLink</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
