<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Delegatable Pseudorandom Functions and Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Aggelos</forename><surname>Kiayias</surname></persName>
							<email>aggelos@di.uoa.gr</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Informatics &amp;</orgName>
								<orgName type="institution">Telecommunications National and Kapodistrian U. of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Stavros</forename><surname>Papadopoulos</surname></persName>
							<email>stavrosp@cse.ust.hk</email>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science &amp; Engineering HKUST</orgName>
								<address>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nikos</forename><surname>Triandopoulos</surname></persName>
							<email>nikolaos.triandopoulos@rsa.com</email>
							<affiliation key="aff2">
								<orgName type="institution">RSA Laboratories Cambridge MA</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Zacharias</surname></persName>
							<email>thzacharias@di.uoa.gr</email>
							<affiliation key="aff3">
								<orgName type="department">Dept. of Informatics &amp;</orgName>
								<orgName type="institution">Telecommunications National and Kapodistrian U. of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Delegatable Pseudorandom Functions and Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B20E637197FCD7015AA6DF4B2E050204</idno>
					<idno type="DOI">10.1145/2508859.2516668</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.4 [Communication Networks]: Distributed Systemsclient/server, distributed applications</term>
					<term>E.3 [Data Encryption]</term>
					<term>G.3 [Probability and Statistics]: random number generation</term>
					<term>K.6.5 [Management of Computing and Information Systems]: Security and Protection-authentication Algorithms, Security, Theory delegation of computation</term>
					<term>pseudorandom functions</term>
					<term>RFIDs</term>
					<term>searchable encryption</term>
					<term>broadcast encryption</term>
					<term>authentication</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We put forth the problem of delegating the evaluation of a pseudorandom function (PRF) to an untrusted proxy and introduce a novel cryptographic primitive called delegatable pseudorandom functions, or DPRFs for short: A DPRF enables a proxy to evaluate a pseudorandom function on a strict subset of its domain using a trapdoor derived from the DPRF secret key. The trapdoor is constructed with respect to a certain policy predicate that determines the subset of input values on which the proxy is allowed to compute. The main challenge in constructing DPRFs is to achieve bandwidth efficiency (which mandates that the trapdoor is smaller than the precomputed sequence of the PRF values conforming to the predicate), while maintaining the pseudorandomness of unknown values against an attacker that adaptively controls the proxy. A DPRF may be optionally equipped with an additional property we call policy privacy, where any two delegation predicates remain indistinguishable in the view of a DPRF-querying proxy: achieving this raises new design challenges as policy privacy and bandwidth efficiency are seemingly conflicting goals.</p><p>For the important class of policy predicates described as (1-dimensional) ranges, we devise two DPRF constructions and rigorously prove their security. Built upon the wellknown tree-based GGM PRF family [17], our constructions are generic and feature only logarithmic delegation size in the number of values conforming to the policy predicate. At only a constant-factor efficiency reduction, we show that our second construction is also policy private. Finally, we describe that their new security and efficiency properties render our DPRF schemes particularly useful in numerous security applications, including RFID, symmetric searchable encryption, and broadcast encryption.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Due to its practical importance, the problem of securely delegating computational tasks to untrusted third parties comprises a particularly active research area. Generally speaking, secure delegation involves the design of protocols that allow the controlled authorization for an-otherwise untrusted-party to compute a given function while achieving some target security property (e.g., the verifiability of results or privacy of inputs/outputs) and also preserving the efficiency of the protocols so that the delegation itself remains meaningful. Beyond protocols for the delegation of general functionalities (e.g., <ref type="bibr">[18,</ref><ref type="bibr" target="#b33">33]</ref>) a variety of specific cryptographic primitives have been considered in this context (see related work in Section 2).</p><p>Surprisingly enough, pseudorandom functions (PRFs), a fundamental primitive for emulating perfect randomness via keyed functions, thus, finding numerous applications in information security, have not been explicitly studied in the context of delegation of computations (of PRF values). We, hereby, initiate a study on this matter.</p><p>A new PRF concept. We introduce delegatable pseudorandom functions, or DPRFs for short, a novel cryptographic primitive which enables the delegation of the evaluation of a PRF to an untrusted proxy according to a given predicate that defines the inputs on which the proxy will evaluate the PRF.</p><p>Specifically, let F be a PRF family, and P a set of predicates, called the delegation policy, defined over the domain of F. A DPRF is a triplet (F, T, C) constructed with respect to P, which provides the elementary functionality shown in Figure <ref type="figure" target="#fig_0">1</ref>: For any secret key k and a predicate P ∈ P, the delegator computes a trapdoor τ via algorithm T , and τ is transmitted to the proxy. The latter then runs algorithm C on τ to derive exactly the set of PRF values BP = {f k (x)|P (x)}, where f k ∈ F, i.e., the PRF value on every input x satisfying predicate P , overall correctly enabling the evaluation of PRF f k subject to predicate P without explicit knowledge of secret key k, or even the input values AP = {x|P (x)}. What motivates the above scheme is bandwidth efficiency: As long as the trapdoor τ is sublinear in the size |BP | of delegated PRF values, the delegation is meaningful as the delegator conserves resources (otherwise, the proxy could be provided directly with all the PRF values in BP ).</p><p>At the same time, the DPRF must retain the security properties of the underlying PRF, namely, (i) pseudorandomness for any value x conforming to the delegation predicate P , i.e., P (x), and (ii) unpredictability for any nonconforming value x such that ¬P (x). In addition, a DPRF can optionally satisfy a policy-privacy property which prevents the proxy from inferring information about P or the delegated (input) set AP from the trapdoor τ .</p><p>Our definitional framework. We introduce a formal definitional framework for the new primitive of DPRFs, carefully capturing all the above technical requirements. We first rigorously define the correctness and security requirements that any DPRF should meet. Correctness captures the ability of the proxy to successfully evaluate the PRF on exactly those inputs (set AP ) specified by predicate P . Security captures the requirement that the delegation capabilities of the PRF do not compromise its core pseudorandomness property. But this condition goes beyond the standard security definition of PRFs, since the pseudorandomness attacker, in addition to the PRF oracle, may now adaptively query also a trapdoor oracle for delegation on predicates of its choice.</p><p>Equally important is also the policy-privacy property that a DPRF may optionally satisfy, intuitively capturing the inability of a malicious proxy to learn any (non-trivial) property about the delegated set AP (that is not implied by BP ). Our security notion postulates that for any two predicates P, P the corresponding trapdoors are indistinguishable, provided that |AP | = |A P | and the adversary issues no delegation queries that trivially separate BP and B P .</p><p>GGM-based realization for range predicates. We devise two bandwidth-efficient and provably secure DPRF constructions for the case where the delegation policy contains predicates described by 1-dimensional ranges. Range-based policies is an interesting use case, as many applications maintain an ordering over the PRF inputs, and delegation rights are defined with respect to ranges of such inputs.</p><p>Our first DPRF scheme is called best range cover, or BRC for short, and relies on the well-known GGM PRF family <ref type="bibr" target="#b17">[17]</ref>. This family defines a PRF based on the hierarchical application of any length-doubling pseudorandom generator (PRG) according to the structure induced by a tree, where input values are uniquely mapped to root-to-leaf paths. By exploiting the above characteristics, our BRC scheme features logarithmic delegation size in the number |AP | of values conforming to the policy predicate, by having the trapdoor τ comprise a subset IP of internal (or partial ) PRF values that optimally cover the target range BP of PRF values. We provide a formal security proof for the above scheme which, interestingly, does not trivially follow from the GGM security proof. The reason is that the adversary can now employ delegation queries to learn any internal PRF value in the tree, and not simply leaf PRF values as in the original security game in <ref type="bibr" target="#b17">[17]</ref>. We note that, although similar "rangecovering" GGM-based constructions appear in the literature, e.g., in <ref type="bibr" target="#b30">[30]</ref>, no formal security analysis has been given. However, our BRC scheme does not satisfy policy privacy, as the structure of the PRF values in IP leaks information about predicate P . This motivates our second construction, called uniform range cover, or URC for short. This scheme augments BRC in a way that renders all trapdoors corresponding to ranges of the same size indistinguishable. This is achieved by carefully having τ comprising a subset I P of PRF values that cover the target range BP of PRF values less optimally: I P contains PRF values that are descendants of those values in IP at a tree height that depends solely on |BP | (which by definition leaks to the adversary). More interestingly, by adopting the above change, URC retains both the asymptotic logarithmic bandwidth complexity of BRC and its DPRF security, but it crucially achieves a policyprivacy notion appropriately relaxed to our setting of range predicates. Inherently, as we argue, no efficient tree-based DPRF scheme can satisfy policy privacy, so we have to resort to a sufficient relaxation which we call union policy privacy.</p><p>Main applications. Finally, our DPRF schemes, equipped with bandwidth efficiency, security and policy privacy (URC only), lend themselves to new schemes that provide scalable solutions to a wide range of information security and applied cryptography settings that involve the controlled authorization of PRF-based computations. Generally, DPRFs are particularly useful in applications that rely on the evaluation of (secret) key-based cryptographic primitives on specific inputs (according to an underlying policy): Using a DPRF scheme then allows a cost-efficient, yet secure and private, key management for an untrusted proxy who is otherwise capable in executing a particular computational task.</p><p>We outline several such applications in which DPRFs are useful, including authentication and access control in RFIDs, efficient batch querying in searchable encryption, as well as broadcast encryption. Due to the underlying GGM building component, our DPRFs are extremely lightweight, as their practical implementation entails a few repeated applications of any efficient candidate instantiation of a PRG that is length doubling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of contributions. Our main contributions are:</head><p>• We initiate the study of policy-based delegation of the task of evaluating a pseudorandom function (PRF) on specific input values, and introduce the concept of delegatable PRFs (DPRFs).</p><p>• We develop a general and rigorous definitional framework for the new DPRF primitive, capturing properties such as bandwidth efficiency, correctness, security and policy privacy, and also offering a relaxed union policy privacy that is arguably necessary for tree-wise DPRF constructions.</p><p>• We present a framework for building DPRF schemes for the important case where the delegation policy is governed by range predicates over inputs; our framework augments the generic GGM construction framework of <ref type="bibr" target="#b17">[17]</ref> to provide two concrete DPRF schemes, namely BRC and URC.</p><p>• We prove the security of our constructions in a modular way, thus also yielding the first security analysis of similar GGM-based key-delegation schemes, and the union-policy privacy of URC.</p><p>• We describe several key applications of DPRFs in the context of efficient key-delegation protocols for authentication, access control and encryption purposes.</p><p>Paper organization. Section 2 reviews related work. Section 3 formulates the DPRF primitive, Section 4 presents our two DPRF constructions for the case of range policies. Section 5 elaborates on the applicability of DPRFs. Finally, Section 6 concludes our paper with directions for future work. Selected proofs appear in the Appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Secure delegation of computations. The notion of delegation of cryptographic operations is already mature: Starting from early work on proxy signatures <ref type="bibr" target="#b28">[28]</ref> and proxy cryptography <ref type="bibr" target="#b5">[5]</ref>, basic primitives such as signatures (e.g., <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b28">28]</ref>) and encryption (e.g., <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b22">22]</ref>) have been studied in the context of an untrusted proxy who is authorized to operate on signatures or ciphertexts. Recently, there has also been an increased interest in verifiability and privacy of general outsourced computations (e.g., <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr">18,</ref><ref type="bibr" target="#b33">33]</ref>) or specific crypto-related operations (e.g., <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b20">20]</ref>). To the best of our knowledge, however, no prior work explicitly and formally examines the delegation of PRFs. 1 PRF extensions. Closer to our new DPRF primitive are the known extensions of PRFs, namely the verifiable PRFs (VPRFs) (e.g., <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b29">29]</ref>) and the oblivious PRFs (OPRFs) (e.g., <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b23">23]</ref>). A VPRF provides a PRF value along with a non-interactive proof, which enables anyone to verify the correctness of the PRF value. Although such proofs can be useful in third-party settings, they are not related to the delegation of the PRF evaluation without the secret key.</p><p>Similarly, an OPRF is a two-party protocol that securely implements functionality (k, x) → (⊥, f k (x))-that is, a party evaluates a PRF value without knowledge of the secret key. Yet, although the party that provides the key can be viewed to preserve resources, this setting does not match ours because there is no (i) input privacy (it is the second party who provides the input x), and (ii) bandwidth efficiency when applied over many values. Other related work includes algebraic PRFs, employed in <ref type="bibr" target="#b4">[4]</ref> to achieve optimal private verification of outsourced computation. 1 Delegating PRF evaluation in a similar vein as we consider here, was considered in <ref type="bibr">[7,</ref><ref type="bibr" target="#b8">8]</ref> after our work was submitted for publication.</p><p>GGM framework. This refers to the seminal work by Goldreich et al. <ref type="bibr" target="#b17">[17]</ref>, which shows how to generically construct a PRF given black-box access to a length-doubling PRG.</p><p>The approach is based on a tree structure, over which hierarchical invocations of the PRG produce the PRF values at the leaves. Our constructions extend this framework in non-trivial ways: First, we support delegation of PRF evaluations; second, our security is proved in a much stronger adversarial setting where the adversary gets to adaptively learn also internal PRF values. The GGM framework, along with its tree-based key-derivation structure, have been widely used in the literature; also for special/limited delegation purposes in the context of access control <ref type="bibr" target="#b30">[30]</ref>, broadcast encryption <ref type="bibr" target="#b31">[31]</ref> and forward security <ref type="bibr" target="#b21">[21]</ref>. Yet, to the best of our knowledge, no such known key-derivation method has been analyzed fully in a security model like ours, which allows for adaptive PRF/delegation queries and addresses policyprivacy issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DEFINITIONS</head><p>A pseudorandom function (PRF) family F is a family of functions {f k : A → B | k ∈ K} so that K is efficiently samplable and all F, K, A, B are indexed by a security parameter λ. The security property of a PRF is as follows: For any probabilistic polynomial-time (PPT) algorithm A running in time polynomial in λ it holds that</p><formula xml:id="formula_0">| Pr[A f k (•) = 1] -Pr[A R(•) = 1]| = negl(λ) ,</formula><p>where negl denotes a negligible function and the probability above is taken over the coins of A and the random variables k and R which are uniformly distributed over the domains K and (A → B) respectively. Delegatable PRFs. The notion of delegation for a PRF family F as above is defined with respect to a delegation policy P, i.e., P is a set of predicates defined over A, also indexed by λ, where each predicate P has an efficient encoding. The set of elements in A that satisfy P is denoted as AP = {x ∈ A | P (x)}.</p><p>Definition 1 (Delegatable PRF) A triple (F, T, C) is a delegatable PRF, or DPRF scheme, for family F = {f k : A → B | k ∈ K} with respect to policy P of predicates over A, provided it satisfies two properties, correctness and security, that are defined individually below.</p><p>Correctness. We define T to be a PPT algorithm such that, given a description of P ∈ P and a key k ∈ K, it outputs a "trapdoor" τ . The latter is intended to be used along with the deterministic PPT algorithm C for the PRF computation over every element of A that satisfies the predicate P . For fixed P, k, algorithm C can be viewed as a function</p><formula xml:id="formula_1">C : St P,k -→ B × St P,k ,</formula><p>where St P,k is a set of states, and for any s ∈ St P,k the output C(s) is a pair that consists of a PRF value and a (new) state. We denote C(s) = CL(s), CR(s) and define recursively the set of reachable states from a subset S of St P,k as R(S) S ∪ R(CR(S)) .</p><p>The elements of the DPRF that are produced given an initial state s will be defined using the complete set of reachable states given s. For a singleton S = {s}, we will write R(s) instead of R({s}), and we will denote by R(s) the closure of s under R, i.e., the fixpoint of the recursive equation for R that also contains s.</p><p>Definition 2 (Correctness) The DPRF scheme (F, T, C) is correct for a policy P if for every P ∈ P:</p><formula xml:id="formula_2">1. {τ | τ ← T (P, k)} ∪ {⊥} ⊆ St P,k , for any k ∈ K (initialization).</formula><p>2. CR(⊥) = ⊥ (termination condition).</p><p>3. There is a polynomial q such that for every k ∈ K and τ ← T (P, k):</p><formula xml:id="formula_3">(i) ⊥ ∈ R(τ ) (termination guarantee). (ii) |R(τ )| ≤ q(λ) (feasibility). (iii) {f k (x) | P (x)} = BP = {CL(s) | s ∈ R(τ )} (completeness).</formula><p>According to the above conditions, all possible trapdoors corresponding to a certain policy predicate P are valid initial inputs for C. Moreover, starting from an arbitrary trapdoor for P as initial input, the proxy can execute a number of steps of algorithm C, during which it successively computes the DPRF image of every argument x that satisfies P , and eventually terminate when it reaches the final state ⊥, where no further useful information can be derived.</p><p>We note that condition 3.(ii) implies the restriction that the size of every policy predicate is polynomial. This stems from the fact that we consider the setting where the proxy wishes to eventually compute all the delegated PRF values. If this is not necessary (or desirable) for the DPRF application, the condition can be relaxed to any size of AP (including super-polynomial sizes). In this case, the completeness condition (item 3.(iii) above) would be infeasible to meet, since the proxy cannot hope to be able to compute all the delegated PRF values. There are a number of ways to capture this by suitably modifying the way C works; for instance: (i) C may sample the uniform distribution over BP , (ii) C may be given the value x as input, and return f k (x) if x ∈ AP and ⊥ otherwise, (iii) C may be given the lexicographic rank of an element x within AP and return f k (x) or ⊥ otherwise.</p><p>Security. We consider the case where the proxy is malicious, and accordingly model DPRF security as an oracle indistinguishability game G A SEC carried out between an attacker A and a challenger C indexed by parameter λ. The game proceeds as shown in Figure <ref type="figure" target="#fig_1">2</ref>. Note that due to the delegation capabilities of DPRFs, the security game G A SEC is more elaborate than the security game of a plain PRF: Indeed, in addition to issuing standard PRF queries, the pseudorandomness attacker may now adaptively query also a trapdoor oracle for delegation on predicates of its choice. Definition 3 (Security) A DPRF scheme (F, T, C) is secure for a policy P if for any PPT A, it holds that</p><formula xml:id="formula_4">Pr[G A SEC (1 λ ) = 1] ≤ 1 2 + negl(λ) .</formula><p>DPRF Security Game G A SEC (1 λ ) 1. The challenger C randomly selects k from K.  We make the following observations about the definition. First, it is easy to see that a delegatable PRF is indeed a PRF. Specifically, any PRF attacker A against f k can be turned into an attacker A that wins the DPRF game G A SEC (1 λ ). We provide only a simple sketch of this which follows by a standard "walking" argument (the reader familiar with such arguments may skip to the next paragraph). Fix some PPT A and let α be its non-negligible distinguishing advantage. There will be some polynomial q so that, for any λ, q(λ) is an upper bound on the number of queries submitted to A's oracle by A. Given such q and for fixed λ, we define the hybrid oracle (f k /R)j for any j ∈ {0, . . . , q(λ)} that operates as follows: (f k /R)j responds as f k (•) in the first j queries and as R(•) in the last q(λ) -j queries. Taking such sequence of oracles into account, by triangular inequality, it follows that there exists some value j ∈ {0, . . . , q(λ) -1} for which the distinguishing probability will be at least α/q(λ) for A to distinguish between two successive hybrid oracles (f k /R)j and (f k /R)j+1 when R is a random function. This follows from the fact that A distinguishes the "extreme" hybrids R(•) and f k (•) with probability α. We now construct A as follows out of A: A plays the DPRF game and queries the DPRF function for the first j queries of A. Then it submits the (j + 1)-th query of A as the challenge. Finally, it completes the simulation of A by answering any remaining queries of A with random values drawn from B (w.l.o.g. the queries to the oracle are all distinct), and outputs what A does. It is easy to see that the distinguishing advantage of A is α/2q(λ), i.e., non-negligible in λ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The adversary</head><formula xml:id="formula_5">(b = b) ∧ (x * ∈ Lque) ∧ ∀P ∈ L pol : ¬P (x * ) .</formula><p>Second, we observe that there is a trivial construction of a delegatable PRF from any PRF: Consider an ordering ≤ over A, e.g., the lexicographical order. For fixed P, k set</p><formula xml:id="formula_6">T (P, k) = f k (x1), . . . , f k (x |A P | ) = τ ,</formula><p>where xi is the i-th element of AP according to ≤. Given τ , the set of states can be St P,k = {τ, (2, τ ), . . . , (|AP |, τ ), ⊥}, and the reconstruction function C can be simply defined to be a table-lookup in τ . It is straightforward to show that (F, T, C) is a DPRF as long as the underlying family F is a PRF, since any delegation query can be interpreted as a series of polynomially many PRF queries.</p><p>The existence of a trivial DPRF construction with respect to arbitrary policies from any given PRF motivates our primitive: Interesting DPRF constructions will be those that are bandwidth efficient, i.e., they provide trapdoors with size that is sublinear in the number of elements that satisfy the corresponding policy predicate. Policy privacy. We next introduce an additional privacy property that a DPRF scheme may optionally satisfy. This property goes beyond the standard (D)PRF security and is relevant in the context of PRF delegation for protecting the associated policy predicates over which the delegation is defined. We accordingly model this new privacy condition as a predicate indistinguishability game G A PP carried out between an attacker A and a challenger C indexed by a security parameter λ. The game proceeds as shown in Figure <ref type="figure">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DPRF Policy Privacy Game</head><formula xml:id="formula_7">G A PP (1 λ ) 1. The challenger C randomly selects k from K.</formula><p>2. The adversary A is allowed to interact with C and ask delegation queries on policy predicates P ∈ P; to those queries C responds with τ ← T (P, k) and adds P to a set L pol .</p><p>3. The adversary A submits two policy predicates P 0 , P 1 to C. The challenger flips a bit b and computes τ * ← T (P b , k). It returns τ * to the adversary.</p><p>4. The adversary A continues as in step 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The adversary A terminates by returning a single bit b.</head><p>Subsequently the game returns a bit that is 1 if and only if the following holds true:</p><formula xml:id="formula_8">(b = b) ∧ (|A P 0 | = |A P 1 |) ∧ (A P 0 = A P 1 )∧ ∧∀S ⊆ L pol : ˛( \ P ∈S A P ) ∩ A P 0 ˛= ˛( \ P ∈S A P ) ∩ A P 1 ˛.</formula><p>Figure <ref type="figure">3</ref>: The DPRF policy privacy game.</p><p>Definition 4 (Policy privacy) A DPRF scheme (F, T, C) is policy private for a policy P if for any PPT A, it holds that</p><formula xml:id="formula_9">Pr[G A PP (1 λ ) = 1] ≤ 1 2 + negl(λ) .</formula><p>The above definition suggests that the trapdoor that corresponds to a certain policy predicate hides the predicate itself (i) at least among all (distinct) policy predicates that enable evaluations of the PRF on the same number of elements in its domain, and (ii) when the adversary does not make queries whose responses leak unequal parts of the PRF image of the two challenge predicates. Observe that all the restrictions stated are necessary: If |AP 0 | = |AP 1 |, then the adversary can distinguish P0 from P1 by counting the number |{CL(s) | s ∈ R(τ * )}| of new PRF values it computes starting from state τ * and ending in ⊥. In addition, if the number of elements that satisfy simultaneously any set S of delegation queries and P0 is different than the number of elements that satisfy S and P1, then the adversary can distinguish the two predicates by counting the size of {CL(s) | s ∈ R(τ * )} ∩ ( T P ∈S BP ). We note that while the above formulation can capture a wide set of attacks against privacy, it can be strengthened further by allowing multiple challenge pairs of policy predicates. In this case, the policy-privacy game allows a multiple number of adversarial actions submitting pairs of policies (as in step 3 of the game) to be interleaved with delegation queries. The challenger always responds based on the same coin flip b. Interestingly, this multiple-challenge policy privacy formulation can be shown to be strictly stronger than the one corresponding to Definition 4.</p><p>On efficiently achieving policy privacy. We next argue that even though desirable, the above formulations of privacy conflict with our efficiency considerations (sublinearsize trapdoors) for a wide class of schemes. This will motivate relaxing the policy-privacy property as we will see in the end of the section; the reader unwilling to go over the details of the lower bound type of argument we sketch below may skip directly to the policy-privacy relaxation in the end of the section.</p><p>Assume that the policy predicates are ranges [a, b] that lie in an interval [0, 2 n -1], where n is a positive integer. Then, no efficient and policy-private DPRF scheme exists, if the trapdoor-generation algorithm T is deterministic, and the delegated-computation algorithm C is tree-wise. This means that for each range, the trapdoor consists of a data structure of initial keys and meta-data that enable (by definition in a deterministic way) the calculation of the final set of PRF values through a tree-like derivation process, where the final underlying tree structure of this process depends only on the meta-data (and not on any of the initial keys). Indeed, if policy privacy is satisfied, then for every 0 &lt; j ≤ b -a, the delegated computation of the PRF values in the intersection The above argument suggests that, if policy privacy is to be attained, then we need trapdoors at least as long as the values we delegate. Note that the trivial construction for ranges mentioned above, i.e., when the trapdoor of [a, b] is the sequence f k (a), f k (a + 1), . . . , f k (b) , does not satisfy policy privacy. For instance, when delegating <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b3">3]</ref> and <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b5">5]</ref> the attacker can easily distinguish them by obtaining the value f k (3) (it belongs in the intersection hence the attacker is allowed to have it) and checking its location within the trapdoor vector. To achieve policy privacy for the trivial construction one needs to additionally permute the PRF values in the trapdoor in some fashion: It can be easily shown that a lexicographic ordering of these values suffices.</p><p>In our upcoming constructions, we obtain efficient DPRFs that use tree-wise derivations where the PRF values computed are at the leaves of a full binary tree, and the policy predicates are ranges of the form [a, b], covered by one or more proper subtrees. In this case, even allowing a probabilistic trapdoor generator does not suffice to provide policy privacy for a very efficient scheme. To see this, let [a, b] be a range of size r and τ be a trapdoor for [a, b] of size g(r) = O(log c r), i.e., g(r) is polylogarithmic in r, hence also in λ. By the Pigeonhole principle, there exists a delegation key y in τ that computes all the values corresponding to a set T ⊆ [a, b] of size at least r/g(r), that is, a subtree T of depth at least d ≥ log(r) -log(g(r)) = ω(1). The latter implies that there exists a value x ∈ [a, b] with an all-one suffix of length d that is computed by this key y. (Here, a tree node contributes a 0 or 1 to root-to-leaves path labelings if it is a left or right child respectively). Since there are no more than g(r) such possible values x ∈ [a, b], an adversary has significant probability greater than 1/g(r) of guessing x. Then it can make a query x, receive f k (x) and submit as the challenge the two policies P0 = [a, b] and P1 = [x, b+(x-a)]. After it receives the challenge trapdoor τ * , it can locate all keys that correspond to subtrees of size ≥ d and check if there is a minimum leaf value (an all-zero path) in some of these subtrees that equals to f k (x). Then, the adversary can distinguish effectively P0, P1 since x cannot be covered by any subtree of size d in a trapdoor for [x, b+(x-a)] (it must be covered by a leaf while d &gt; 1). This argument can be extended to more general tree-like delegation schemes and for the case g(r) = o(r), but we omit further details as it already demonstrates that efficient tree-like constructions require a somewhat more relaxed definition of policy privacy-which we introduce next.</p><p>Union policy privacy. We finally introduce the notion of union policy privacy, where the adversary is restricted from making queries in the union of the challenge policy predicates (but is allowed to query at arbitrary locations outside the targeted policy set). This privacy condition is a strict relaxation of the one corresponding to Definition 4, and we model it by a game G A UPP (1 λ ) that proceeds identically as G A PP (1 λ ), but terminates with 1 provided that the following (weaker set of) conditions are all met: (i) b = b, (ii) |AP 0 | = |AP 1 |, (iii) AP 0 = AP 1 and (iv) ∀P ∈ L pol : AP ∩ (AP 0 ∪ AP 1 ) = ∅. To see the connection with Definition 4 observe that the latter condition is equivalent to</p><formula xml:id="formula_10">∀S ⊆ L pol : ˛( \ P ∈S AP ) ∩ AP 0 ˛= ˛( \ P ∈S AP ) ∩ AP 1 ˛= 0 .</formula><p>Note that for policies P consisting of disjoint predicates, the games G A PP (1 λ ) and G A UPP (1 λ ) are equivalent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">CONSTRUCTIONS</head><p>In this section we present DPRF schemes for range policy predicates. In Section 4.1 we describe a first construction, called best range cover (BRC), which satisfies the correctness and security properties of DPRFs, achieving trapdoors of logarithmic size in the range size. However, BRC lacks the policy-privacy property. In Section 4.2 we build upon BRC to obtain a DPRF scheme, called uniform range cover (URC), that is additionally (union) policy private, while retaining the trapdoor size complexity of BRC. In Section 4.3 we include the security proofs of the two schemes. In Section 4.4 we prove the union policy-privacy property of URC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The BRC Construction</head><p>Let G : {0, 1} λ → {0, 1} 2λ be a pseudorandom generator and G0(k), G1(k) be the first and second half of the string G(k), where the specification of G is public and k is a secret random seed (of bit length λ). The GGM pseudorandom function family <ref type="bibr" target="#b17">[17]</ref> is defined as</p><formula xml:id="formula_11">F = {f k : {0, 1} n → {0, 1} λ } k∈{0,1} λ , such that f k (xn-1 • • • x0) = Gx 0 (• • • (Gx n-1 (k))) ,</formula><p>where n is polynomial in λ and xn-1 • • • x0 is the input bitstring of size n.</p><p>The GGM construction defines a binary tree over the PRF domain. We illustrate this using Figure <ref type="figure" target="#fig_3">4</ref>, which depicts a binary tree with 5 levels. The leaves are labeled with a decimal number from 0 to 15, sorted in ascending order. Every edge is labeled with 0 (resp. 1) if it connects a left (resp. right) child. We label every internal node with the binary string determined by the labels of the edges along the path from the root to this node. Suppose that the PRF domain is {0, 1} 4 . Then, the PRF value of 0010 is f k (0010) = G0(G1(G0(G0(k)))). Observe that the composition of G is performed according to the edge labels in the path from the root to leaf 2 = (0010)2, selecting the first (second) half of the output of G when the label of the visited edge is 0 (resp. 1) and using this half as the seed for the next application of G. Based on the above, the n-long binary representation of the leaf labels constitute the PRF domain, and every leaf is associated with the PRF value of its label-these values constitute the PRF range. Note that we can also associate every internal node of the GGM tree with a partial PRF value, by performing the composition of G as determined by the path from the root to that node. For example, node 00 in Figure <ref type="figure" target="#fig_3">4</ref> is associated with partial PRF G0(G0(k)). Henceforth, for simplicity, we denote by </p><formula xml:id="formula_12">f k (xn-1 • • • xj) the partial PRF Gx j (• • • (Gx n-1 (k))). Observe that if a party has the partial PRF f k (xn-1 • • • xj),</formula><formula xml:id="formula_13">(0000) = G0(G0(f k (00))), f k (0001) = G1(G0(f k (00))), f k (0010) = G0(G1(f k (00))), and f k (0011) = G1(G1(f k (00))).</formula><p>For any range [a, b] of leaf labels, there is a (non-unique) set of subtrees in the GGM tree that cover exactly the corresponding leaves. For instance, <ref type="bibr" target="#b2">[2,</ref><ref type="bibr">7]</ref> is covered by the subtrees rooted at nodes 001 and 01 (colored in grey). According to our discussion above, a party having the partial PRF values of these subtree roots and the subtree depths, it can derive all the PRF values of the leaves with labels in [a, b]. In our example, having k (001), 1) and (f k (01), 2), it can derive the PRF values of the leaves with labels in <ref type="bibr" target="#b2">[2,</ref><ref type="bibr">7]</ref>. Our first construction is based on the above observations. In particular, given a range policy predicate [a, b] ∈ P with size r = b -a + 1 = |AP |, 2 it finds the minimum number of subtrees that cover <ref type="bibr">[a, b]</ref>. As such, we call this scheme as best range cover (BRC). A formal description follows.</p><p>The BRC DPRF construction is a triplet (F, T, C), where F is the GGM PRF family described above with tree depth n. The delegation policy is</p><formula xml:id="formula_14">P = {[a, b] | 0 ≤ a ≤ b ≤ a + λ γ &lt; 2 n },</formula><p>where γ is a constant integer. Note that when a = b the trapdoor sent to the proxy is (essentially) simply the PRF value f k (a). In the rest of the section, we focus on the non-trivial case where the range is not a singleton. When a &lt; b, the trapdoor generation algorithm T of BRC, henceforth denoted by T BRC , is given below.</p><formula xml:id="formula_15">The Trapdoor Generation Algorithm T BRC Input: a, b : 0 ≤ a &lt; b ≤ a + λ γ ≤ 2 n -1 and k ∈ {0, 1} λ Output: Trapdoor τ for computing {f k (x)|x ∈ [a, b]} 1. τ ← 2. t ← max{i | a i = b i } 3. if (∀i ≤ t : a i = 0) then 4. if (∀i ≤ t : b i = 1) then 5. return (f k (a n-1 • • • a t+1 ), t + 1) 6. else 7. Append (f k (a n-1 • • • at), t) to τ 8. else 9. µ ← min{i | i &lt; t ∧ a i = 1} 10.</formula><p>for i = t -1 to µ + 1 11.</p><p>if</p><formula xml:id="formula_16">a i = 0 then 12. Append (f k (a n-1 • • • a i+1 1), i) to τ 13. Append (f k (a n-1 • • • aµ), µ) to τ 14. if (∀i ≤ t : b i = 1) then 15. Append (f k (b ν-1 • • • bt), t) to τ 16. else 17. ν ← min{i | i &lt; t ∧ b i = 0} 18. for i = t -1 to ν + 1 19. if b i = 1 then 20. Append (f k (b n-1 • • • b i+1 0), i) to τ 21. Append (f k (b n-1 • • • bν ), ν) to τ 22. return τ</formula><p>This algorithm takes as input a secret key k and a range predicate [a, b] ∈ P. It outputs a delegation trapdoor τ that enables the computation of f k (x) for every x whose decimal representation is in [a, b] (i.e., the PRF values of the leaves in the GGM tree with labels in [a, b]). Initially, T BRC finds the first bit in which a and b differ (Line 2), which determines the common path from the root to leaves a and b. Suppose that this common path ends at node u. If [a, b] is the set of labels that belong to the subtree with root u, then T BRC outputs a single pair consisting of the partial PRF value that corresponds to u along with the depth of the subtree (Lines 3-5). Otherwise, T BRC traverses the left and right subtree of u separately (Lines 7-13 and 14-21, respectively). We will describe only the left traversal (the right one is performed symmetrically). T BRC considers the path pv→a starting from the left child of u, denoted by v, to a. It checks whether a is the leftmost leaf of v's subtree. In this case the PRF value of v is included in τ along with the depth of v's subtree, and the traversal terminates (Lines 3,7). Otherwise, if pv→a proceeds to the left child of v, it includes in the trapdoor the PRF value of the right child of v together with the depth of 2 In the sequel, we use symbols r and |AP | interchangeably.</p><p>the subtree rooted at that child. In any case, it continues the traversal in the same fashion with the next node of pv→a (Lines 8-13).</p><p>In the example of Figure <ref type="figure" target="#fig_3">4</ref>, for input <ref type="bibr" target="#b2">[2,</ref><ref type="bibr">7]</ref>, algorithm T BRC outputs trapdoor τ = (f k (001), 1), (f k (01), 2) . By construction, it is easy to see that T BRC covers the input range with maximal subtrees, thus using a minimum number of them.</p><p>We next describe the reconstruction algorithm C of BRC. For fixed P = [a, b] of size r and key k, we define the set of states as St P,k = {τ, (1, τ ), . . . , (r -1, τ ), ⊥}, where τ = (y1, d1), . . . , (ym, dm) is the trapdoor produced by algorithm T BRC . Note that, every yi, i = 1, . . . , m corresponds to a partial PRF value associated with the root of a GGM subtree. Therefore, there is a natural ordering of PRF values for a given τ , starting from the leftmost leaf of the subtree of y1 to the rightmost leaf of the subtree of ym. This order is not necessarily the same as the order of the leaves in the GGM tree. <ref type="foot" target="#foot_0">3</ref> Starting from the PRF value of the leftmost leaf of the y1 subtree, C computes in every next step the PRF value of the next leaf in the ordering discussed above. Specifically, C starts with state τ and computes C(τ ) = G0(• • • (G0(y1))), (1, τ ) , where the G0 composition is performed d1 times. Then, generally, given state (i, τ ), C locates the unique subtree that covers the (i + 1)-th leaf x in the ordering of τ . In particular, it finds the pair (yt, dt) in τ , where t is such that P t-1 ρ=1 2 dρ ≤ i &lt; P t ρ=1 2 dρ . Then, the suffix</p><formula xml:id="formula_17">x d t -1 • • • x0 is the binary repre- sentation of i - P t-1 ρ=1 2 dρ ∈ [0, 2 d t -1]. Given this suffix, C can compute f k (x) = Gx 0 (• • • (Gx d t -1 (yt))) and output C((i, τ )) = Gx 0 (• • • (Gx d t -1 (yt))), (i + 1, τ ) .</formula><p>For the case where dt = 0, C simply returns f k (x) = yt. Finally, for input state (r -1, τ ), C outputs G1(• • • (G1(ym))), ⊥ , where the G1 composition is performed dm times.</p><p>In the example of Figure <ref type="figure" target="#fig_3">4</ref>, the trapdoor for range <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b14">14]</ref> is (f k (01), 2), (f k (001), 1), (f k (10), 2), (f k (110), 1), (f k (1110), 0) . Algorithm C computes the PRF values for leaves 4, 5, 6, 7, 2, 3, 8, 9, 10, 11, 12, 13, 14 in this order, i.e.,</p><formula xml:id="formula_18">C(τ ) = G0(G0(f k (01))), (1, τ ) = f k (0100), (1, τ ) → C((1, τ )) = G1(G0(f k (01))), (2, τ ) = f k (0101), (2, τ ) → . . . C((12, τ )) = f k (1110), ⊥ .</formula><p>As described above, during the execution of C some partial PRF values in the GGM tree are computed multiple times; e.g., partial PRF value f k (011) is computed twice to derive f k (0110) and f k (0111). However, this can be easily avoided by employing a cache of size O(r): Every PRF value is computed once, stored in the cache, and retrieved in a next step if necessary. In this manner, the computational cost of C can become O(r), since we compute one PRF value for every node in the subtrees covering the range (of size r).</p><p>The correctness of BRC is stated in the following theorem.</p><p>Theorem 1 The BRC DPRF construction (F, T, C) w.r.t.</p><formula xml:id="formula_19">policy P = {[a, b] | 0 ≤ a ≤ b ≤ a + λ γ ≤ 2 n -1},</formula><p>where n is the depth of the underlying GGM tree, γ is a constant integer, and λ γ is the maximum range size, is correct.</p><p>We show that all conditions of Definition 2 hold. Condition 1 can be easily seen to hold by the definition of the set of states St P,k . Moreover, since R(τ ) = St P,k , conditions 2, 3.(i) and 3.(ii) are directly satisfied by the construction of algorithm C, and because the size of range r (which determines the number of values conforming to the range policy predicate) is upper bounded by λ γ which is a polynomial.</p><p>Therefore, it remains to show that condition 3.(iii) holds. Note that, by construction, algorithm C computes exactly the PRF values of the leaves covered by the subtrees corresponding to the partial PRF values included in τ by algorithm T BRC . Hence, it suffices to show that the labels of these leaves comprise exactly the set of values in <ref type="bibr">[a, b]</ref>.</p><p>Let t = max{i | ai = bi} and V1, V2 be the sets of arguments of the PRF values that are computed in Lines 3-13 and 14-21 of T BRC , respectively. If V2 = ∅, then the input range is exactly covered by a single subtree (checks in lines 3 and 4 are true) and V1 = [a, b]. Otherwise, it holds that</p><formula xml:id="formula_20">V1 = {x ∈ [0, 2 n -1] | xn-1 • • • xt = an-1 • • • at∧ ∧ (∃i &lt; t : [xi = 1 ∧ ai = 0] ∨ x = a)} = {x ∈ [0, 2 n -1] | a ≤ x ≤ an-1 • • • at1 • • • 1} = [a, an-1 • • • at1 • • • 1] . Similarly, we get that V2 = [bn-1 • • • bt0 • • • 0, b].</formula><p>Observe that, by the definition of t, at = 0 and bt = 1. Thus, it holds that an-1</p><formula xml:id="formula_21">• • • at1 • • • 1 + 1 = bn-1 • • • bt0 • • • 0. This means that [a, b] = V1 ∪ V2, which concludes our proof.</formula><p>We next discuss the trapdoor size complexity in BRC. Let V1, V2 be defined as in the proof of Theorem 1. Then, |V1| + |V2| = r. We will analyze |V1| (the analysis for V2 is similar). Observe that, in every step in Lines 3-13, the algorithm covers more than |V1|/2 values of V1 with a maximal subtree of the sub-range defined by V1. Iteratively, this means that the algorithm needs no more than log(r) maximal subtrees to cover the entire sub-range of V1. Consequently, the total number of elements in τ is O(log(r)).</p><p>We have explained the correctness of BRC and its efficient trapdoor size. We will also prove its security in Section 4.3. Nevertheless, BRC does not satisfy policy privacy, even for non-intersecting policy predicates. We illustrate this with an example using the tree of Figure <ref type="figure" target="#fig_3">4</ref>. Consider the ranges <ref type="bibr" target="#b2">[2,</ref><ref type="bibr">7]</ref> and <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b14">14]</ref>, both with size 6, which generate trapdoors ((f k (001), 1), (f k (01), 2) and (f k (101), 1), (f k (1001), 0), (f k (110), 1), (f k (1110), 0) , respectively; these are trivially distinguishable due to their different sizes. This motivates our second DPRF construction presented next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The URC Construction</head><p>Consider again the ranges <ref type="bibr" target="#b2">[2,</ref><ref type="bibr">7]</ref> and <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b14">14]</ref> in the tree of Figure <ref type="figure" target="#fig_3">4</ref>, for which BRC produces two distinguishable trapdoors, namely trapdoor (f k (001), 1), (f k (01), 2) and trapdoor (f k (101), 1), (f k (1001), 0), (f k (110), 1), (f k (1110), 0) . Now, instead of computing the trapdoor of <ref type="bibr" target="#b2">[2,</ref><ref type="bibr">7]</ref> as above, assume that we generate an alternative trapdoor equal to (f k (010), 1), (f k (0010), 0), (f k (011), 1), (f k (0011), 0) . Observe that this trapdoor appears to be indistinguishable to that of <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b14">14]</ref>: Indeed, the two trapdoors have the same number of elements, the first parts of their elements are all partial PRFs, whereas their second parts (i.e., the depths) are pairwise equal. This suggests that, we could achieve policy privacy, if we could devise a trapdoor algorithm T such that, for any range predicate of a fixed size r it always generates a trapdoor with a fixed number of elements and a fixed sequence of depths. More simply stated, the algorithm should produce uniform trapdoors for ranges of the same size. The challenge is to design such an algorithm retaining the logarithmic trapdoor size of BRC. Next, we present our second DPRF construction, called uniform range cover (URC), which enjoys the efficiency of BRC and the union policy-privacy property.</p><p>URC builds upon BRC. In particular, it starts by producing a trapdoor as in BRC, and then modifies it to generate a uniform trapdoor for the given range r. Before embarking on its detailed description, we must investigate some interesting properties of the trapdoors of BRC, and provide some important definitions. Recall that a trapdoor in BRC is a sequence of elements, where the first part is a (full or partial) PRF value, and the second is a depth value.</p><p>Definition 5 For an integer r &gt; 1, a pair of non-negative integral sequences D = ((k1, . . . , kc), (l1, . . . , l d )) is called a decomposition of r, if the following hold:</p><formula xml:id="formula_22">(i) P c i=1 2 k i + P d j=1 2 l j = r,<label>and</label></formula><formula xml:id="formula_23">(ii) k1 &gt; • • • &gt; kc and l1 &gt; • • • &gt; l d .</formula><p>A decomposition of r D = ((k1, . . . , kc), (l1, . . . , l d )) is a worst-case decomposition (w.c.d.) of r if it is of maximum size, i.e., for every decomposition of r D = ((k 1 , . . . , k c ), (l 1 , . . . , l d )), we have that c + d ≤ c + d. We define MD max{k1, l1} as the maximum integer that appears in D.</p><p>By the description of algorithm T BRC in BRC for fixed range size r, the depths in the trapdoor can be separated into two sequences that form a decomposition of r, unless the input range is exactly covered by a single subtree. Each sequence corresponds to a set of full binary subtrees of decreasing size that cover leaves in the range predicate. The usage of the worst case decomposition will become clear soon.</p><p>The next lemma shows that the maximum integer that appears in any decomposition of r (hence, the maximum depth of a subtree in a cover of a range of size r), can only take on one of two consecutive values that depend only on r.</p><p>Lemma 1 Let D = ((k1, . . . , kc), (l1, . . . , l d )) be a decomposition of r. Define B(r) log(r + 2) -2. Then MD ∈ {B(r), B(r) + 1}. In addition, if MD = B(r) + 1 then the second largest value is less than MD.</p><p>Proof. By the two properties of D, we have that</p><formula xml:id="formula_24">r = c X i=1 2 k i + d X j=1 2 l j ≤ 2 k 1 +1 + 2 l 1 +1 -2 ≤ ≤ 2 M D +2 -2 ⇔ 2 M D +2 ≥ r + 2 ⇒ MD ≥ B(r) .</formula><p>Since 2 B(r)+2 ≥ 2 log(r+2) &gt; r ≥ 2 k 1 + 2 l 1 , we have that the maximum value MD ∈ {k1, l1} is less than B(r) + 2 and k1, l1 cannot be both equal to B(r) + 1.</p><p>By Lemma 1, the trapdoor that is generated by BRC for a range P = [a, b] of size |AP | = r, even if this trapdoor corresponds to a w.c.d. of r, consists of at most |{0, . . . , B(r)}| + |{0, . . . , B(r) + 1}| = 2B(r) + 3 pairs. Hence, the trapdoor size is O(log(r)), which complies with the bound we described in Section 4.1. Moreover, since | ≤ λ γ , every trapdoor has no more than 2 log(λ γ + 2) -1 pairs.</p><p>Observe that two trapdoors with depths that form the same decomposition appear indistinguishable. Moreover, we have proven that a trapdoor following a w.c.d. retains the logarithmic size in r. Therefore, our goal for the trapdoor algorithm T in URC, hereafter referred to as T URC , is to construct a converter that takes as input a BRC trapdoor, and produces an alternative trapdoor that complies with a fixed worst-case decomposition. Before proceeding to the details of T URC , we must prove the following vital theorem.</p><p>Theorem 2 Let D = ((k1, . . . , kc), (l1, . . . , l d )) be a decomposition of r. Then all the elements in {0, . . . , MD} appear in D iff D is a w.c.d. of r.</p><p>Proof. Assume that the implication does not hold and let x be the maximum integer in {0, . . . , MD} that does not appear in D. Since x &lt; MD, x+1 is in {0, . . . , MD}. Assume w.l.o.g. that lj = x+1. If x &gt; k1, then the decomposition of r, ((x, k1, . . . , kc), (l1, . . . , lj-1, x, lj+1, . . . , l d )), is of greater size than that of D. Similarly, if i = min{i | x &lt; ki}, then the decomposition of r, ((k1, . . . , ki, x, ki+1, . . . , kc), (l1, . . . , lj-1, x, lj+1, . . . , l d )), is of greater size than that of D. Both cases contradict the hypothesis, hence, x must appear in D.</p><p>For the converse, let D = ((k 1 , . . . , k c ), (l 1 , . . . , l d )) be a w.c.d. of r. Then, the integers 0, . . . , M D appear in D . By Lemma 1, all integers 0, . . . , B(r) appear in D and D . By removing the integers 0, . . . , B(r) from D and D , the remaining integers are y1 ≥ . . . ≥ ys and z1 ≥ . . . ≥ zt, respectively. Since an integer cannot appear more than twice in a decomposition of r and, by Lemma 1, the maximum possible value B(r) + 1 cannot appear more than once, we have that y1, . . . , ys and z1, . . . , zt are sequences of distinct integers such that P s i=1 2 y i = P t j=1 2 z j . Assume that there exists a minimum index ρ ≤ s such that yρ = zρ and that w.l.o.g. yρ &gt; zρ. Then we have the contradiction</p><formula xml:id="formula_25">s X i=1 2 y i ≥ X i&lt;ρ 2 y i + 2 yρ &gt; X i&lt;ρ 2 y i + 2 zρ+1 -1 ≥ ≥ X i&lt;ρ 2 z i + X i≥ρ 2 z i = t X j=1 2 z j = s X i=1 2 y i .</formula><p>Thus, {y1, . . . , ys} and {z1, . . . , zt} are equal, and therefore D is a w.c.d. of r.</p><p>A consequence of Theorem 2 and Lemma 1 is that, for every integer r &gt; 1, a w.c.d. of r is a proper re-arrangement of the integers that appear in the w.c.d. of r where the first sequence is (B(r), . . . , 0) and the second sequence is the remaining integers in the decomposition in decreasing order. We term this unique w.c.d. as the uniform decomposition of r. The main idea in URC is to always generate a trapdoor that complies with the uniform decomposition of r.</p><p>We are ready to describe algorithm T URC in URC, whose pseudocode is provided below. The process starts with invoking the T BRC algorithm of BRC to get an initial trapdoor τ (Line 1). If the input range is covered by a single subtree, then τ is reformed into two pairs that correspond to the child subtrees, so that the dephs in τ always form a decomposition (Lines 2-3). Let D be the decomposition implied by τ (Line 4). The loop in Lines 5-7 utilizes Theorem 2 and works as follows. It finds the highest depth x that does not exist in D, and "splits" the partial PRF value yi in the rightmost pair in τ with depth x+1, producing two new partial PRF values with depth x, i.e., y 0 i = G0(yi) and y 1 i = G1(yi) (Line 6). Note that these values correspond to the two children of the subtree of yi. Thus, if we substitute element (yi, x + 1) by (y 0 i , x), (y 1 i , x) in τ , then the trapdoor can still produce the same leaf PRF values as before. However, at all times we wish the sequence of depths in τ to form a decomposition. Hence, after removing (yi, x + 1), we appropriately insert (y 0 i , x) in the left pair sequence and (y 1 i , x) in the right pair sequence of τ (Line 7). Upon termination of the loop, all the values in {0, . . . , MD} appear in D and, thus, we have reached a w.c.d. according to Theorem 2. The process terminates, after properly re-arranging the elements of τ , such that they comply with the unique uniform decomposition of r (Lines 8-9). This is done deterministically, by simply filling the missing depths from {0, . . . , B(r)} in the left sequence with the unique appropriate pair that exists (by Theorem 2) in the right sequence.</p><formula xml:id="formula_26">The Trapdoor Generation Algorithm T URC Input: a, b : 0 ≤ a &lt; b ≤ a + λ γ ≤ 2 n -1 and k ∈ {0, 1} λ Output: Trapdoor τ for computing {f k (x)|x ∈ [a, b]} 1.</formula><p>Invoke T BRC (a, b, k) and receive the output τ 2. if τ consists only of pair (y, d) then 3.</p><p>τ ← (G 0 (y), d -1), (G 1 (y), d -1) 4. Let τ = (y 1 , d 1 ), . . . , (yn, dm) and D = ((d 1 , . . . , dc), (d c+1 , . . . , dm)) be the corresponding decomposition of r = b -a + 1 5. while there is a maximum integer x in {0, . . . , M D } that does not appear in D: 6.</p><p>Find the rightmost pair (y i , x + 1) and compute values</p><formula xml:id="formula_27">y 0 i = G 0 (y i ), y 1 i = G 1 (y i ) 7.</formula><p>Remove (y i , x + 1) from τ , insert the pairs (y 0 i , x) and (y 1 i , x) in τ respecting the strictly decreasing order, and update D accordingly 8. if the leftmost sequence of D is not (B(r), . . . , 0) then 9.</p><p>Fill leftmost sequence with values from rightmost sequence until it complies with the uniform decomposition of r 10. return τ</p><p>In our running example, for the range <ref type="bibr" target="#b2">[2,</ref><ref type="bibr">7]</ref>, the T URC algorithm in URC converts the original token retrieved by the trapdoor algorithm of BRC, τ = (f k (001), 1), (f k (01), 2) , as follows (we underline a newly inserted element to the left sequence, and depict as bold a newly inserted element to the right sequence):</p><formula xml:id="formula_28">(f k (001), 1), (f k (01), 2) ↓ (f k (0010), 0), (f k (01), 2), (f k (0011), 0) ↓ (f k (010), 1), (f k (0010), 0), (f k (011), 1), (f k (0011), 0) .</formula><p>The C algorithm of URC is identical to that of BRC, because the trapdoor in URC has exactly the format expected by this algorithm, i.e., pairs of PRF values corresponding to GGM subtrees along with their depths. Moreover, during the evolution of the initial BRC trapdoor into one of uniform decomposition in the T algorithm of URC, a partial PRF value y is substituted by two new PRF values that can generate the same leaf PRF values as y. As such, the correctness of the BRC scheme is inherited in URC. Finally, due to Lemma 1, the size of a w.c.d. (and, hence, also a uniform decomposition) of r is O(log(r)), which means that the trapdoor size in URC is also O(log(r)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Security</head><p>In this section we prove the security of BRC and URC. Both proofs rely on the security of the pseudorandom generator of the underlying GGM construction. Note that the security proof does not follow straightforwardly from the GGM proof because contrary to the case of GGM where the adversary obtains only leaf PRFs, the adversary in a DPRF can obtain also partial PRF values in the GGM tree (via delegation queries). Note that the tree structure of a trapdoor (which is independent of k) for a range predicate P of size r is deterministic and public in both BRC and URC. Thus, when querying the oracle in the security game, the adversary can map the partial or full PRF values appearing in τ for a selected P to subtrees in the GGM tree. Based on this observation, we prove first the security of BRC against adversaries that query only subtrees, or equivalently prefixes for strings in {0, 1} n , where n is the depth of the GGM tree. We call this type of security subtree security. We conclude our proofs by showing that the subtree security of BRC implies the security of both schemes.</p><p>In order to prove the subtree security property of BRC, we insure and exploit the subtree security for two special cases. First, we consider the case that the adversary is nonadaptive, i.e., it poses all its queries in advance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2</head><p>The BRC scheme with depth n and range size at most λ γ is subtree secure against PPT adversaries that make all their queries, even the challenge query, non-adaptively.</p><p>Proof. Let A be a non-adaptive prefix-only PPT adversary against a BRC scheme with depth n and maximum range size λ γ . Without loss of generality we assume that A always advances to step 3 (submits a challenge to the challenger).</p><p>We define recursively two sequences of PPT algorithms A = An, . . . , A1 and Sn, . . . , S1 as follows.</p><p>For i = n -1, . . . , 1, Ai on input 1 λ , initially invokes Ai+1 receiving all of its non-adaptive queries, and chooses a random value k in {0, 1} λ . If a query xi • • • xt has the same most significant bit (MSB) as the challenge query, Ai makes the query xi-1 • • • xt, and responds with the received value y. Otherwise, it responds with the value Gx t (• • • (Gx i-1 (k ))). It returns Ai+1's output.</p><p>For i = n, . . . , 1, on input (z0, z1) ∈ {0, 1} 2λ , Si invokes Ai and receives all of its queries. For every query xi-1</p><formula xml:id="formula_29">• • • xt, it responds with Gx t (• • • (Gx i-2 (zx i-1 )</formula><p>)) (or zx 0 for i = 1). On the challenge phase, it flips a coin b and acts as the challenger in a DPRF security game with Ai. It returns 1 iff Ai returns b.</p><p>Let qi and pi be the probabilities that Si outputs 1 when it receives its input from the uniform distribution U 2λ in {0, 1} 2λ and the pseudorandom distribution G(U λ ), respectively. By the definition of Si, pn = Pr[G A SEC (1 λ ) = 1] while q1 ≤ 1/2, since it corresponds to a totally random game.</p><p>We next observe that An-1, . . . , A1 behave like attackers against the subtree security of BRC schemes with respective depths n -1, . . . , 1. The behavior of Ai as an attacker is the same as Ai+1's, when the latter interacts with a modified challenger that replaces the two possible partial PRF values for the MSB of a prefix, with two random values. Thus, following the previous notation, we have that pi = qi+1. Since G(U λ ) and U 2λ are indistinguishable, it holds that |pi -qi| ≤ i(λ), where i(•) is a negligible function. Finally:</p><formula xml:id="formula_30">|pn -q1| = | n X i=1 (pi -qi)| ≤ n X i=1 |pi -qi| ≤ n X i=1 i(λ) , hence Pr[G A SEC (1 λ ) = 1] = pn ≤ q1 + n • (λ) ≤ 1/2 + n • (λ), where (λ) = max i { i(λ)}.</formula><p>We use the above lemma to prove the security of a special category of BRC schemes, where the maximum range size is at least half of A = [0, 2 n -1], which represents the biggest interval where range predicates are defined. This will serve as a stepping stone for designing our final security proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3</head><p>The BRC scheme with depth n and maximum range size λ γ is subtree secure if 2 n-1 ≤ λ γ &lt; 2 n .</p><p>Proof. Let A be a prefix-only adversary. We construct a non-adaptive prefix-only adversary B for the subtree security game that on input 1 λ chooses randomly a challenge x * in [0, 2 n -1] and makes the n queries that cover all the possible values except from x * . Namely, B makes queries (x * n-1 ⊕ 1), . . . ,</p><formula xml:id="formula_31">(x * n-1 • • • x * i ⊕ 1), . . . , (x * n-1 • • • x * 0 ⊕ 1)</formula><p>and submits challenge x * . It receives responses yn-1, . . . , y0 respectively, along with y * which is the response to x * . Then, it invokes A and plays the security game with A, as a challenger that can respond appropriately for every value that is not x * or a range that does not contain x * . If A sets x * as a challenge, then B responds with y * , and returns A's guess. Otherwise, A has either made a query which is a prefix of x * , or it has submitted a challenge different than x * , so B terminates the game it plays with A and returns a random bit, as its guess to its challenge.</p><p>Let E be the event that B guesses A's challenge, i.e. A's challenge is x * . By the description of B we have that</p><formula xml:id="formula_32">Pr[G B SEC (1 λ ) = 1 ∧ ¬E] = 1/2 • (1 -1/2 n ) and Pr[G B SEC (1 λ ) = 1 ∧ E] = 1/2 n • Pr[G A SEC (1 λ ) = 1]</formula><p>. Since B is non-adaptive, by Lemma 2 we get that for some negligible function (•), Pr[G B SEC (1 λ ) = 1] ≤ 1/2 + (λ). By adding the above equations we have that</p><formula xml:id="formula_33">1/2 n • (Pr[G A SEC (1 λ ) = 1] -1/2) + 1/2 ≤ 1/2 + (λ) , so, Pr[G A SEC (1 λ ) = 1] ≤ 1/2 + 2 n • (λ) ≤ 1/2 + 2λ γ • (λ).</formula><p>We apply Lemma 3 to prove the subtree security of BRC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4</head><p>The BRC scheme with depth n and maximum range size λ γ is subtree secure.</p><p>Proof. See Appendix.</p><p>Finally, we prove that the subtree security of BRC implies the security of BRC and URC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3</head><p>The BRC and URC schemes with depth n and maximum range size λ γ are secure.</p><p>Proof. Let A be a PPT adversary that wins the DPRF security game of either BRC or URC with non-negligible advantage α(•). As noted in the beginning of this section, any query A makes, can be represented as a sequence of O(log(λ γ )) subtrees, or equivalently of O(log(λ γ )) prefixes. Thus, we can construct a prefix-only adversary A that invokes A and when it receives a query sequence</p><formula xml:id="formula_34">x 1 n-1 • • • x 1 t 1 , . . . , x m • • • x m t m from A</formula><p>, it makes all prefix queries separately, receives y1, . . . , ym and answers by y1, . . . , ym . A also transfers A's challenge and outputs its guess. Therefore, it wins the DPRF security game with advantage α(•), which contradicts Lemma 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Policy Privacy</head><p>This section analyzes the policy privacy of URC. According to the lower bound argument we gave in Section 3, URC cannot be expected to satisfy the general policy-privacy property, because it is efficient. We illustrate this explicitly with a toy example. For challenge ranges <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b5">5]</ref> and <ref type="bibr" target="#b4">[4,</ref><ref type="bibr">7]</ref>, the trapdoors will contain PRF values corresponding to subtrees covering the ranges as <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b3">3]</ref>, {4}, {5} and <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5]</ref>, {6}, {7}, respectively. Therefore, the adversary can issue query for leaf 4 and receive a PRF value y. Having (y1, 1), (y2, 0), (y3, 0) as challenge trapdoor, it can check whether y2 = y, which happens only when <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b5">5]</ref> was chosen by the challenger.</p><p>Nevertheless, in the theorem below we prove that URC achieves union policy privacy. The above attack is circumvented as in the union policy-privacy game, the adversary cannot obtain a PRF value for a leaf in the intersection of the challenge ranges, i.e., for 4 and 5.</p><p>Theorem 4 The URC scheme with depth n and maximum range size λ γ is a DPRF with union policy privacy.</p><p>Proof. See Appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">APPLICATIONS</head><p>In this section we discuss interesting applications of the general DPRF primitive and our specialized constructions for range-based policies. We stress, though, that their applicability is not limited to these scenarios; we are confident that they can capture a much wider set of applications. Authentication and access control in RFID. Radio Frequency Identification (RFID) is a popular technology that is expected to become ubiquitous in the near future. An RFID tag is a small chip with an antenna. It typically stores a unique ID along with other data, which can be transmitted to a reading device lying within a certain range from the tag. Suppose that a trusted center (TC) possesses a set of RFID tags (attached to books, clothes, etc.), and distributes RFID readers to specified locations (e.g., libraries, restaurants, etc.). Whenever a person or object carrying a tag lies in proximity with a reader, it transmits its data (e.g., the title of a book, the brand of a jacket, etc.). The TC can then retrieve these data from the RFID readers, and mine useful information (e.g., hotlist books and clothes, etc.).</p><p>Despite its merits, RFID technology is challenged by security and privacy issues. For example, due to the availability and low cost of the RFID tags, one can easily create tags with arbitrary information. As such, an adversary may impersonate other tags, and provide falsified data to legitimate readers. On the other hand, a reader can receive data from any tag in its vicinity. Therefore, sensitive information may be leaked to a reader controlled by an adversary. For example, the adversary may learn the ID and the title of a book stored in a tag, match it with public library records, and discover the identity and reading habits of an individual. Motivated by the above, authentication and access control in RFID-based systems has been studied in the literature. A notable paradigm was introduced in <ref type="bibr" target="#b30">[30]</ref>, which can be directly benefited by DPRFs. At a high level, every tag is associated with a key, and the TC delegates to a reader a set of these keys (i.e., the reader is authorized to authenticate and access data from only a subset of the tags). The goal is for the TC to reduce certain costs, e.g., the size of the delegation information required to derive the tag keys while maintaining a high number of distinct keys in order to ensure that attacks can be compartmentalized.</p><p>Observe that a DPRF (F, T, C) is directly applicable to the above setting. F is defined on the domain of the tag IDs, and its range is the tag keys. Given a delegation predicate on the tag IDs, the TC generates a trapdoor via algorithm T , and sends it to the reader. The latter runs C on the trapdoor to retrieve the tag keys. In fact, for the special case where the access policy is a range of IDs, the delegation protocol suggested in <ref type="bibr" target="#b30">[30]</ref> is identical to the non-private BRC scheme (we should stress though that <ref type="bibr" target="#b30">[30]</ref> lacks rigorous definitions and proofs). Range-based policies are meaningful, since tag IDs may be sequenced according to some common theme (e.g., books on the same topic are assigned consecutive tag IDs). In this case, a range policy concisely describes a set of tags (e.g., books about a certain religion) and, hence, the system can enjoy the logarithmic delegation size of BRC. However, as explained in Section 4, BRC leaks the position of the IDs in the tree, which may further leak information about the tags. Although <ref type="bibr" target="#b30">[30]</ref> addresses tag privacy, it provides no privacy formulation, and overlooks the above structural leakage. This can be mitigated by directly applying our policy-private URC construction for delegating tag keys to the readers. To sum up, DPRFs find excellent application in authentication and access control in RFIDs, enabling bandwidth-efficient tag key delegation from the TC to the reader. Moreover, policy-private DPRFs provide stronger protection for the tag IDs against the readers. Batch queries in searchable symmetric encryption. Searchable symmetric encryption (SSE) (e.g., <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b24">24]</ref>) enables processing queries directly on ciphertexts generated with symmetric encryption. Although SSE corresponds to a general paradigm, various works primarily support the special case of keyword queries. Here, we focus on the definitions and schemes of <ref type="bibr" target="#b11">[11]</ref> that provide an acceptable level of provable security. The general framework underlying <ref type="bibr" target="#b11">[11]</ref> is as follows. In an offline stage, a client encrypts his data with his secret key k, and uploads the ciphertexts c to an untrusted server. He also creates and sends a secure index I on the data for efficient keyword search, which is essentially an encrypted lookup table or inverted index. Given a keyword w, the client generates a query token τw using k, and forwards it to the server. It is important to stress that this "trapdoor" is merely comprised of one or more PRF values computed on w with k, which were used as keys to encrypt I. For simplicity and w.l.o.g., we assume that τw is a single PRF value. The server uses τw on I and retrieves the IDs of the ciphertexts associated with w. The results c1, . . . , cm are retrieved and transmitted back to the client, who eventually decrypts them with his key. The security goal is to protect both the data and the keyword from the server.</p><p>Suppose that the client wishes to search for a batch of N keywords w1, . . . , wN . For instance, the client may ask for documents that contain multiple keywords of his choice (instead of just a single one). As another example, assume that the client's data are employee records, and each record contains a salary attribute that takes as values intervals of form [iK, (i + 1)K] (i.e., instead of exact salaries). These intervals can serve as keywords in SSE search. Suppose that the client wishes to retrieve records with salaries in a range of intervals, e.g., [1K, 10K]. Observe that this cannot be processed with a single keyword query (no record is associated with [1K, 10K]). To overcome this while utilizing the SSE functionality, the client can ask 9 distinct queries with keywords "[1K, 2K]", "[2K, 3K]", . . ., "[9K, 10K]", which cover the query range [1K, 10K]. Such scenarios are handled with "traditional" SSE as shown in Figure <ref type="figure" target="#fig_6">5</ref>(a). Given a predicate P that describes the keywords w1, . . . , wN in the batch query, the client generates N trapdoors τw 1 , . . . , τw N using the standard SSE trapdoor algorithm. These trapdoors are sent to the server, which then searches I with every τw i following the SSE protocol. Obviously, for large N , the client's computational and communication cost is greatly impacted.  We can augment the discussed SSE framework with DPRF functionality, in order to support batch queries with sublinear (in N ) processing and communication cost at the client, while providing provable security along the lines of <ref type="bibr" target="#b11">[11]</ref>. Figure <ref type="figure" target="#fig_6">5</ref>(b) illustrates our enhanced SSE architecture. Recall that τw i is practically a PRF value, computed on wi with key k. Therefore, instead of computing a PRF value for every wi itself, the client delegates the computation of these PRF values to the server by employing a DPRF scheme (F, T, C), where F is defined over the domain of the keywords. Given predicate P and k, the client runs T and generates trapdoor τ , which is sent to the server. The latter executes C on τ to produce τw 1 , . . . , τw N . Execution then proceeds in the same manner as in "traditional" SSE. Observe that, for the special case of ranges, if URC is used as the DPRF, the computational and communication cost at the client decreases from O(N ) to O(log(N )). This transformation would work "out of the box" in combination to any SSE scheme that uses a PRF for creating tokens.</p><p>The above framework can be proven secure against adaptive adversaries along the lines of <ref type="bibr" target="#b11">[11]</ref>. The most important alteration in the security game and proof is the formulation of the information leakage of the C algorithm of the DPRF. In particular, the level of keyword privacy that is provided by the construction is dictated by the level of policy privacy that is attained by the underlying DPRF. Specifically, given a DPRF with multi-instance policy privacy, it is easy to show that the same level of keyword privacy as in <ref type="bibr" target="#b11">[11]</ref> can be achieved. Weaker notions of policy privacy (such as singleinstance or union) result in correspondingly weaker notions of keyword privacy. For instance, recall that union policy privacy ensures indistinguishability of delegation queries not intersecting with previously asked queries. Thus, combining PRF-based SSE with our URC construction will provide this level of keyword privacy. Given the lower bound arguments for tree-wise constructions we sketched in Section 3, the privacy loss incurred by this tree-based design is the unavoidable cost for the exponential efficiency improvement in client-to-server communication. Efficient constructions attaining higher level of policy privacy might be feasible, but they will have to follow a non tree-base design paradigm.</p><p>Broadcast encryption. In a broadcast encryption scheme (e.g., <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b32">32]</ref>) a sender wishes to transmit data to a set of receivers so that at each transmission the set of receivers excluded from the recipient set can be chosen on the fly by the sender. In particular, this means that the sender has to be able to make an initial key assignment to the recipients, and then suitably use the key material so that only the specific set of users of its choosing can receive the message. In such schemes, it was early on observed that there is a natural tradeoff between receiver memory storage and ciphertext length (e.g., see lower bounds in <ref type="bibr" target="#b26">[26]</ref>). The intuition behind this is that if the receivers have more keys, this gives to the sender more flexibility in the way it can encrypt a message to be transmitted.</p><p>In the above sense one can think of the key assignment step of a broadcast encryption scheme as a PRF defined over the set Φ which contains all distinct subsets that the broadcast encryption scheme assigns a distinct key. Given this configuration, the user u will have to obtain all the keys corresponding to subsets S ∈ Φ for which it holds that u ∈ S (we denote those subsets by Su ⊆ Φ). In DPRF language this would correspond to a delegation policy for a PRF: users will need to store the trapdoor that enables the evaluation of any value in the delegated key set Su.</p><p>Seen in this way, any DPRF is a key assignment mechanism for a broadcast encryption scheme that saves space on receiver storage. For example, our constructions for rangebased policies give rise to the following broadcast encryption scheme: Receivers [n] = {1, . . . , n} are placed in sequence; each receiver u ∈ [n] is initialized with the trapdoor for a range [u -t, u + t] for some predetermined parameter t ∈ Z. In this broadcast encryption scheme the sender can very efficiently enable any range of receivers that is positioned at distance at most t from a fixed location v ∈ [n]. This is done with a single ciphertext (encrypted with the key of location v). Any receiver of sufficient proximity t to location v can derive the corresponding decryption key from its trapdoor. Furthermore, given the efficiency of our construction, storage on receivers is only logarithmic on t. While the semantics of this scheme are more restricted than a full-fledged broadcast encryption scheme (which enables the sender to exclude any subset of users on demand), it succinctly illustrates the relation between broadcast encryption and DPRF; further investigation in the relation between the two primitives from a construction point of view will be motivated by our notion. Specifically, an efficient DPRF with domain Φ over a policy set P = {Su | u ∈ [n]} will provide an efficient key assignment for a broadcast encryption scheme operating over Φ. Interestingly, the reverse is true and a (suitably structured) broadcast encryption scheme will provide a DPRF with domain Φ and the policy set {Su | u ∈ [n]}.</p><p>Regarding policy privacy, it is interesting to point out that this security property is yet unstudied in the domain of broadcast encryption. A different privacy notion has been considered in <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b25">25]</ref> that deals with the structure of ciphertexts in such schemes. Our policy privacy on the other hand deals with the privacy of memory contents from the receiver's point of view. Maintaining the indistinguishability of the storage contents is a useful security measure in broadcast encryption schemes, and our DPRF primitive will motivate the study of this security property in the context of broadcast encryption-note that none of the tree-like keydelegation methods used in broadcast encryption schemes prior to our work satisfies policy privacy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>We have introduced the concept of delegatable pseudorandom functions (DPRFs), a new cryptographic primitive that allows for policy-based computation at an untrusted proxy of PRF values, without knowledge of a secret or even the input values. We provided formal definitions of the core properties of DPRFs for (1) correctness, the ability of the proxy to compute PRF values only for inputs that satisfy a given predicate, (2) security, the standard pseudorandomness guarantee, but against a stronger adversary that also issues delegation queries, and (3) policy privacy, which prevents leakage of the secret preimages of the computed PRF values. Moreover, we presented two DPRF constructions for PRF delegation controlled by range-based policies, along with a comprehensive analysis in terms of their security and privacy guarantees and some inherent trade-offs with efficiency. Our proposed DPRF schemes are generic, yet practical, based on the well-understood and widely-adopted GGM design framework for PRFs and, as we showed, they find direct application in many key-delegation or key-derivation settings providing interesting new results.</p><p>Further exploration of DPRFs holds promise for many directions of interest. Open problems include: Designing DPRFs for other classes of predicates, establishing upper and lower bounds on the connection between efficiency and policy privacy, and studying applications in other settings.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>ProxyFigure 1 :</head><label>1</label><figDesc>Figure 1: The DPRF functionality.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The DPRF security game.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>[a + j, b] must be indistinguishable for [a, b] and [a + j, b + j]. Otherwise, an adversary can make queries for all the PRF values in [a + j, b] and, since it knows the way that each unique trapdoor of [a, b] and [a + j, b + j] computes the PRF values of the range [a + j, b], can thus distinguish the two range predicates by making the corresponding equality tests. By induction, this implies that for any j ∈ {0, . . . , b -a}, in the trapdoor of [a, b] there exist distinct keys d0, . . . , dj that allow the computation of f k (a), . . . , f k (a + j), respectively. Thus, the size of the trapdoor of the range [a, b] consists of at least r = b -a + 1 = #[a, b] keys which means that the DPRF cannot be efficient (i.e., enabling the delegation of the range with a trapdoor size less than the set of values being delegated).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A GGM tree example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>then it can compute the PRF values of all 2 j inputs that have prefix xn-1 • • • xj, simply by following a DFS traversal in the subtree rooted at (the node labelled by) xn-1 • • • xj and composing with seed f k (xn-1 • • • xj). In our running example, using the partial PRF value at node 00, we can derive the PRF values of the inputs in (decimal) range [0, 3] as f k</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Clientk, P τ w1 , . . . , τ wN c 1 , . . . , c m</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Batch keyword query processing in SSE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>A is allowed to interact with C and ask two types of queries: (a) PRF queries for a value x ∈ A; to those queries C responds with f k (x) and adds the value x to a set Lque.</figDesc><table><row><cell>(b) Delegation queries for a policy predicate P ∈ P; to</cell></row><row><cell>those queries C responds with τ ← T (P, k) and adds P</cell></row><row><cell>to a set L pol .</cell></row><row><cell>3. The adversary A submits a challenge query x  *  to which</cell></row><row><cell>the challenger C responds as follows: It flips a coin b</cell></row><row><cell>and if b = 1 it responds with y  *  = f k (x  *  ), otherwise, it responds with a random value y  *  from B.</cell></row><row><cell>4. The adversary A continues as in step 2.</cell></row><row><cell>5. The adversary A terminates by returning a single bit b.</cell></row><row><cell>Subsequently the game returns a bit which is 1 if and</cell></row><row><cell>only if the following holds true:</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>This by-design feature of algorithm C comes at no efficiency cost in BRC, but it is crucial for policy privacy in URC.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank all anonymous reviewers for providing detailed comments and suggestions. The first and fourth authors were supported by projects CODAMODA of the European Research Council, Marie Curie RECUP, and respectively FINER of GSRT.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX Proof of Lemma 4</head><p>By Lemma 3, it suffices to focus on the case that λ γ &lt; 2 n-1 . This is definitely the interesting case, since 2 n is normally superpolynomial in λ. Let A be a prefix-only adversary against BRC that makes at most q(λ) queries (including the challenge) and d be the minimum integer that λ γ &lt; 2 d . We construct a PPT PRF distinguisher B that makes oracle queries of fixed size n = n -d ≥ 1. On input 1 λ , B flips a coin b, invokes A and initializes a security game, itself being the challenger. By the bound on the size of the ranges, all queries of A have length greater than n . Thus, for every query xn-1 • • • xt, we have that t &lt; d and B responds by making a query xn-1 • • • x d , which is of length n , receiving a value y and answering to A as Gx t (• • • (Gx d-1 (y))). When A submits a challenge, B acts as a normal challenger according to the coin flip b utilizing its oracle to determine the value up to level d as above. Finally, B returns 1 iff A returns b.</p><p>Consequently, we can construct a prefix-only adversary Ã against a BRC with depth d and maximum range size λ γ as follows: Ã invokes A and chooses a random index j ∈ [q(λ)] and q(λ) -1 random values k1, . . . , kj-1, kj+1, . . . , k q(λ) ∈ {0, 1} λ . Index j reflects Ã's attempt to guess which of all of possible different prefixes of length n that will appear in A's queries will be the one that a prospective challenge query will have. Then Ã keeps count of the different prefixes of length n that gradually appear and reacts to a query xn-1 • • • xt according to the following checks:   </p><p>By the description of Ã, the between A and B in the case that B's oracle is random is fully simulated by Ã when the latter's guess for the prefix of A's challenge is correct. Formally, let E be the event that Ã guesses A's challenge. Then it holds that</p><p>By the description of Ã and (3), we have that</p><p>, where we used that Pr[E] = 1/q(λ). Therefore,</p><p>Finally, by ( <ref type="formula">1</ref>) and ( <ref type="formula">4</ref>) we conclude that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 4</head><p>Let A be a PPT adversary that wins the union policy privacy game with non-negligible distinguishing advantage α(•). </p><p>Let Er be the event that the size of the challenge ranges</p><p>(</p><p>We will show that for these fixed b, r, i, we can construct an adversary Ai for the security game of a BRC construction that has non-negligible winning advantage. The main idea is that Ai invokes A and simulates either Gi or Gi-1 on selected challenge P b of size r depending on the value of the challenge bit bi for the security game G A i SEC (1 λ ). On input 1 λ , Ai computes the uniform decomposition of r, Ur, and arranges its elements according to &lt;U r . Let ui be the integer that appears in the i-th element of Ur (trivially, when r = 1 then ui = u1 = 0). The BRC that Ai attacks has depth n-ui. Specifically, Ai invokes A and answers all of its pre-challenge queries as follows: for each query xn-1 • • • xt, if t ≥ ui, it just transfers the query, receives value y, and responds with y. Otherwise, it makes query xn-1 • • • xu i , receives value y, and responds with Gx t (• • • (Gx u i -1 (y))). In the challenge phase, if |AP b | = r, then Ai terminates the game with A, chooses a valid random challenge, and returns a random bit. Otherwise, it makes i-1 queries and computes the &lt;U r -first i-1 partial delegation keys y1, . . . , yi-1 of τ b as in the pre-challenge phase, and sets the string</p><p>that corresponds to the i-th partial key as its challenge, receiving y * . Note that since A is restricted from making queries within AP 0 ∪ AP 1 , it makes no queries with prefix</p><p>Ai's challenge is valid. It arranges the values y1, . . . , yi-1, y * according to the order that τ b imposes and "fills" the |Ur| -i remaining positions of an array like trapdoor τ b with |Ur| -i pairs consisting of random values from {0, 1} λ along with the corresponding depths. It returns τ b to A and answers to A's post-challenge queries as in the pre-challenge phase. If A returns b, then Ai returns 1, or else it returns a random bit.</p><p>The probability that Ai wins the security game is</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>It holds that Pr[G</head><p>). For the other two terms in the right part of (6), we observe that when bi = 1, Ai simulates Gi when b and Er occur, whereas when bi = 0, Ai simulates Gi-1 when b and Er occur. Therefore, by the description of Ai we have that Therefore by <ref type="bibr" target="#b5">(5)</ref>, Pr[G A i SEC (1 λ ) = 1] ≥ 1/2 + α(λ)/4N λ γ , which contradicts Theorem 3.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Securely outsourcing linear algebra computations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Atallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">B</forename><surname>Frikken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th Symposium on Information, Computer and Comm. Security (ASIACCS)</title>
		<meeting>of the 5th Symposium on Information, Computer and Comm. Security (ASIACCS)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="48" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Improved proxy re-encryption schemes with applications to secure distributed storage</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ateniese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hohenberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inf. Syst. Secur</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="30" />
			<date type="published" when="2006-02">Feb. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Privacy in encrypted content distribution using private broadcast encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Barth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 10th Int. Conf. on Financial Cryptography and Data Security</title>
		<meeting>of the 10th Int. Conf. on Financial Cryptography and Data Security</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="52" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Verifiable delegation of computation over large datasets</title>
		<author>
			<persName><forename type="first">S</forename><surname>Benabbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Vahlis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 31st Annual Conf. on Advances in Cryptology (CRYPTO)</title>
		<meeting>of the 31st Annual Conf. on Advances in Cryptology (CRYPTO)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="111" to="131" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Divertible protocols and atomic proxy cryptography</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blaze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bleumer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 17th Int. Conf. on the Theory and Application of Cryptographic Techniques (EUROCRYPT)</title>
		<meeting>of the 17th Int. Conf. on the Theory and Application of Cryptographic Techniques (EUROCRYPT)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="127" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Secure proxy signature schemes for delegation of signing rights</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Palacio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Warinschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="57" to="115" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Constrained pseudorandom functions and their applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 19th Int. Conf. on the Theory and Application of Cryptology and Information Security (ASIACRYPT)</title>
		<meeting>of the 19th Int. Conf. on the Theory and Application of Cryptology and Information Security (ASIACRYPT)</meeting>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page">352</biblScope>
		</imprint>
	</monogr>
	<note>To appear; full version in Cryptology ePrint Archive</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Functional signatures and pseudorandom functions</title>
		<author>
			<persName><forename type="first">E</forename><surname>Boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">401</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Practical delegation of computation using multiple servers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Riva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 18th Conf. on Computer and Comm. Security (CCS)</title>
		<meeting>of the 18th Conf. on Computer and Comm. Security (CCS)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="445" to="454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Improved delegation of computation using fully homomorphic encryption</title>
		<author>
			<persName><forename type="first">K.-M</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 30th Annual Conf. on Advances in Cryptology (CRYPTO)</title>
		<meeting>of the 30th Annual Conf. on Advances in Cryptology (CRYPTO)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="483" to="501" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Searchable symmetric encryption: Improved definitions and efficient constructions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th Conf. on Computer and Comm. Security (CCS)</title>
		<meeting>of the 13th Conf. on Computer and Comm. Security (CCS)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A verifiable random function with short proofs and keys</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yampolskiy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th Int. Workshop on Public Key Cryptography (PKC)</title>
		<meeting>of the 8th Int. Workshop on Public Key Cryptography (PKC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="416" to="431" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Outsider-anonymous broadcast encryption with sublinear ciphertexts</title>
		<author>
			<persName><forename type="first">N</forename><surname>Fazio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Perera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th Int. Conf. on Public Key Cryptography (PKC)</title>
		<meeting>of the 15th Int. Conf. on Public Key Cryptography (PKC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="225" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Broadcast encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13st Annual Conf. on Advances in Cryptology (CRYPTO)</title>
		<meeting>of the 13st Annual Conf. on Advances in Cryptology (CRYPTO)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="480" to="491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Publicly verifiable delegation of large polynomials and matrix computations, with applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 19th Conf. on Computer and Comm. Security (CCS)</title>
		<meeting>of the 19th Conf. on Computer and Comm. Security (CCS)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="501" to="512" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Keyword search and oblivious pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2nd Theory of Cryptography Conference (TCC)</title>
		<meeting>of the 2nd Theory of Cryptography Conference (TCC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="303" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">How to construct random functions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="792" to="807" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Delegating computation: interactive proofs for muggles</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 40th Annual Symposium on Theory of Computing (STOC)</title>
		<meeting>of the 40th Annual Symposium on Theory of Computing (STOC)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="113" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Identity-based proxy re-encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ateniese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th Int. Conf. on Applied Cryptography and Network Security (ACNS)</title>
		<meeting>of the 5th Int. Conf. on Applied Cryptography and Network Security (ACNS)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="288" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">How to securely outsource cryptographic computations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hohenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lysyanskaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2nd Theory of Cryptography Conference (TCC)</title>
		<meeting>of the 2nd Theory of Cryptography Conference (TCC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="264" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Itkis</surname></persName>
		</author>
		<title level="m">Handbook of Information Security, chapter Forward Security: Adaptive Cryptography-Time Evolution</title>
		<imprint>
			<publisher>John Wiley and Sons</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Proxy cryptography revisited</title>
		<author>
			<persName><forename type="first">A.-A</forename><surname>Ivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 10th Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>of the 10th Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<publisher>The Internet Society</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient oblivious pseudorandom function with applications to adaptive ot and secure computation of set intersection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th Theory of Cryptography Conference (TCC)</title>
		<meeting>of the 6th Theory of Cryptography Conference (TCC)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="577" to="594" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Dynamic searchable symmetric encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 19th Conf. on Computer and Comm. Security (CCS)</title>
		<meeting>of the 19th Conf. on Computer and Comm. Security (CCS)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="965" to="976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Anonymous broadcast encryption: Adaptive security and efficient constructions in the standard model</title>
		<author>
			<persName><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Quaglia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th Int. Conf. on Public Key Cryptography (PKC)</title>
		<meeting>of the 15th Int. Conf. on Public Key Cryptography (PKC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="206" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Combinatorial bounds for broadcast encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Staddon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 17th Int. Conf. on the Theory and Application of Cryptographic Techniques (EUROCRYPT)</title>
		<meeting>of the 17th Int. Conf. on the Theory and Application of Cryptographic Techniques (EUROCRYPT)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="512" to="526" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Unique signatures and verifiable random functions from the DH-DDH separation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lysyanskaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 22nd Annual Conf. on Advances in Cryptology (CRYPTO)</title>
		<meeting>of the 22nd Annual Conf. on Advances in Cryptology (CRYPTO)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="597" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Proxy signatures for delegating signing operation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mambo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Usuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Okamoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 3rd Conf. on Computer and Comm. Security (CCS)</title>
		<meeting>of the 3rd Conf. on Computer and Comm. Security (CCS)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="48" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Verifiable random functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 40th Annual Symposium on Foundations of Computer Science (FOCS)</title>
		<meeting>of the 40th Annual Symposium on Foundations of Computer Science (FOCS)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="120" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A scalable, delegatable pseudonym protocol enabling ownership transfer of RFID tags</title>
		<author>
			<persName><forename type="first">D</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Soppera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 12th Int. Workshop on Selected Areas in Cryptography (SAC)</title>
		<meeting>of the 12th Int. Workshop on Selected Areas in Cryptography (SAC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="276" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Revocation and tracing schemes for stateless receivers</title>
		<author>
			<persName><forename type="first">D</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lotspiech</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21st Annual Conf. on Advances in Cryptology (CRYPTO)</title>
		<meeting>of the 21st Annual Conf. on Advances in Cryptology (CRYPTO)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="41" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Efficient trace and revoke schemes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Inf. Sec</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="411" to="424" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">How to delegate and verify in public: verifiable computation from attribute-based encryption</title>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Theory of Cryptography Conference (TCC)</title>
		<meeting>of the 9th Theory of Cryptography Conference (TCC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="422" to="439" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
