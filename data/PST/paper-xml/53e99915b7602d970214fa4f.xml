<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Verification of K-Step Opacity and Analysis of its Complexity</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Anooshiravan</forename><surname>Saboori</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Christoforos</forename><forename type="middle">N</forename><surname>Hadjicostis</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Electrical and Computer Engineering</orgName>
								<orgName type="department" key="dep2">Coordi-nated Science Laboratory</orgName>
								<orgName type="department" key="dep3">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">University of Cyprus</orgName>
								<orgName type="institution" key="instit2">University of Illinois at Urbana-Champaign. Corresponding</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<addrLine>75 Kallipoleos Avenue</addrLine>
									<postBox>P.O. Box 20537</postBox>
									<postCode>1678</postCode>
									<settlement>Nicosia</settlement>
									<country key="CY">Cyprus</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Verification of K-Step Opacity and Analysis of its Complexity</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B2D9A76BA0F4EB7B104A158EE3D9F2BD</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:12+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we analyze the verification of K-step opacity in discrete event systems that are modeled as (possibly non-deterministic) finite automata with partial observation on their transitions. A system is K-step opaque if the entrance of the system state within the last K observations to a set of secret states remains opaque to an intruder who has complete knowledge of the system model and observes system activity through some projection map. We establish that the verification of K-step opacity is NP-hard. We also investigate the role of delay K in K-step opacity and show that there exists a delay K * such that K-step opacity and K ′ -step opacity become equivalent for K ′ &gt; K ≥ K * .</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Motivated by the increased reliance of many applications on shared cyber-infrastructures (ranging from defense and banking to health care and power distribution systems), various notions of security and privacy have received considerable attention from researchers. The notion of opacity focuses on characterizing the information flow from the system to the intruder <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref> and aims at determining whether a given system's secret behavior (i.e., a subset of the behavior of the system that is considered critical and is usually represented by a predicate) is kept opaque to outsiders <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>. More specifically, this requires that the intruder (modeled as a passive observer of the system's behavior) never be able to establish the truth of the predicate.</p><p>In our work in <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, we consider a scenario where we are given a discrete event system (DES) that can be modeled as a (possibly non-deterministic) finite automaton with partial observation on its transitions; assuming that the initial state of the system is (partially) unknown, we define the secret behavior of the system as the evolution of the system's state to a subset of secret states S. The intruder is assumed to have full knowledge of the system model and be able to track the observable transitions in the system via the observation of the associated labels. In <ref type="bibr" target="#b3">[4]</ref>, we extend this notion of opacity to K-step opacity (for K ≥ 0) by requiring that the entrance of the system state to the set of secret states S at any time during the past K observations remains opaque to the intruder. Examples to motivate the study of state-based notions of opacity are provided in <ref type="bibr" target="#b5">[6]</ref>.</p><p>In this paper, we establish that the verification of Kstep opacity is an NP-hard problem. We also investigate the impact of delay on the amount of information that can flow to the intruder and show that there exists a delay K * (which we characterize exactly) after which K-step opacity and K ′step opacity become equivalent (for</p><formula xml:id="formula_0">K ′ &gt; K ≥ K * ).</formula><p>Apart from our own work in <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, the work in this paper is also related to some of the existing security work in the area of DESs. In particular, <ref type="bibr" target="#b6">[7]</ref> focuses on finite state Petri nets and defines opacity with respect to state-based predicates; our work in <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref> and in this paper essentially studies and solves this problem for the case of finite automata and introduces the notion of K-step opacity (not present in either <ref type="bibr" target="#b2">[3]</ref> or <ref type="bibr" target="#b6">[7]</ref>). The authors of <ref type="bibr" target="#b7">[8]</ref> follow a language-based approach with multiple observers of varying observation capabilities (modeled through different observable transitions) and require that no observer be able to establish with certainty that the actual trajectory of the system belongs to the secret language that is assigned to it. Assuming that all events are observable, sufficient conditions for the existence of a finite state controller that can enforce opacity are then obtained. In contrast to <ref type="bibr" target="#b7">[8]</ref>, opacity in our framework assumes that the states of the system can be partitioned into secret and non-secret ones; this statebased formulation is what enables us to use various state estimators to verify opacity. Related to our work here is also the work in <ref type="bibr" target="#b8">[9]</ref> where the authors partition the event set into public level and private level events, and consider the verification of intransitive non-interference, a property that captures the allowed information flow (e.g., the occurrence of certain events) from private level events to public level events through a downgrading process. Our model of the intruder's capability (in terms of observability power) is different from <ref type="bibr" target="#b8">[9]</ref> which makes the two frameworks hard to compare. However, in the sequel, we show that for the case when there is no downgrading process, the notion of noninterference can be translated to an instance of 0-step opacity. Note that, in general, one cannot formulate the notion of Kstep opacity for K &gt; 0 in the framework of <ref type="bibr" target="#b8">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PRELIMINARIES AND BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Non-Deterministic Finite Automata</head><p>Let Σ be an alphabet and denote by Σ * the set of all finitelength strings of elements of Σ, including the empty string ǫ. For any string t, |t| denotes the length of t. A language L ⊆ Σ * is a subset of finite-length strings from Σ * . A language is finite if it contains only a finite number of strings. We say a language L is finite of length K if the length of the strings in L is at most K. For a string ω, ω denotes the prefix-closure of ω and is defined as ω = {t ∈ Σ * | ∃s ∈ Σ * : ts = ω}. The prefix closure L of language L is the set of all prefix closures of all strings in L. A language is prefix-closed if L = L. The post-string ω/s of ω after s ∈ ω is defined as ω/s = {t ∈ Σ * | st = ω} <ref type="bibr" target="#b9">[10]</ref>.</p><p>A DES is modeled as a (possibly non-deterministic) finite automaton G = (X, Σ, δ, X 0 , X m ), where X = {0, 1, . . . , N -1} is the set of states, Σ is the set of events, X 0 ⊆ X is the set of possible initial states, δ : X × Σ → 2 X (where 2 X is the power set of X) is the possibly nondeterministic state transition function, and X m ⊆ X is the set of marked states. The function δ can be extended from the domain X × Σ to the domain X × Σ * in the routine recursive manner: δ(i, ts) := j∈δ(i,t) δ(j, s), for t ∈ Σ and s ∈ Σ * with δ(i, ǫ) := i. The behavior of DES G is captured by L(G) := {s ∈ Σ * | ∃i ∈ X 0 , δ(i, s) is defined}. We use L(G, i) to denote the set of all traces that originate from state i of G (so that</p><formula xml:id="formula_1">L(G) = i∈X0 L(G, i)). The marked language of DES G is captured by L m (G) := {s ∈ L(G)|∃x 0 ∈ X 0 , δ(x 0 , s) ∩ X m = ∅}. In general, L m (G) is not prefix-closed and L m (G) ⊆ L(G). If X m = X, then L m (G) = L(G). We omit X m from the 5-tuple description of G when X m = X.</formula><p>In general, only a subset Σ obs of the events can be observed. Typically, one assumes that Σ can be partitioned into two sets, the set of observable events Σ obs and the set of unobservable events Σ uo (so that Σ obs ∩ Σ uo = ∅ and Σ obs ∪ Σ uo = Σ). The natural projection P : Σ * → Σ * obs can be used to map any trace executed in the system to the sequence of observations associated with it. This projection is defined recursively as P (ts) = P (t)P (s), t ∈ Σ, s ∈ Σ * , with P (t) = t if t ∈ Σ obs and P (t) = ǫ if t ∈ Σ uo ∪ {ǫ} <ref type="bibr" target="#b9">[10]</ref>.</p><p>Upon observing some string (sequence of observations) s ∈ Σ * obs , the state of the system might not be identifiable uniquely due to the lack of knowledge of the initial state and the partial observation of events. We denote the set of states that the system might reside in given that s was observed as the (current) state estimate.</p><p>Given a (possibly non-deterministic) finite automaton G = (X, Σ, δ, X 0 ), we define X K (K ≥ 2) as the set of K-tuples of states of DES G, i.e.,</p><formula xml:id="formula_2">X K := X × X × . . . × X = {(i 1 , . . . , i K )|i k ∈ X, 1 ≤ k ≤ K}.We call m ∈ 2 X K a K- dimensional state mapping.</formula><p>Note that a 2-dimensional state mapping is simply a state mapping as introduced in <ref type="bibr" target="#b5">[6]</ref>. The set of states included as the first (last) component in a Kdimensional state mapping m is called the set of starting (ending) states of m. We index the set of starting states for K-dimensional state mapping m by m(K -1) and the set of ending states by m(0). We also denote by m(k), 0 &lt; k &lt; K -1, the set of intermediate states in the K-tuple. We define the shift operator : 2</p><formula xml:id="formula_3">X K × 2 X 2 → 2 X K for K-dimensional state mapping m 1 ∈ 2 X K and state mapping m 2 ∈ 2 X 2 as m 1 m 2 := {(i 2 , . . . , i K , i K+1 )|(i 1 , i 2 , . . . , i K ) ∈ m 1 , (i K , i K+1 ) ∈ m 2 }. We also define the composition oper- ator • : 2 X 2 ×2 X 2 → 2 X 2 for state mappings m 1 , m 2 ∈ 2 X 2 as m 1 • m 2 := {(i 1 , i 3 )|∃i 2 ∈ X, (i 1 , i 2 ) ∈ m 1 , (i 2 , i 3 ) ∈ m 2 }.</formula><p>We can map any observation of finite but arbitrary length in DES G to a state mapping by using the mapping M : Σ * obs → 2 X 2 , M (s) = {(i, j)|i, j ∈ X, ∃t ∈ Σ * , P (t) = s, j ∈ δ(i, t)}, which we call the s-induced state mapping. The 2-tuple (i, j) ∈ M (s), implies that there exists a sequence of events that starts from i and ends in j, and produces observation s. Finally, for any Z ⊆ X and K ≥ 2, we define the operator</p><formula xml:id="formula_4">⊙ K : 2 X → 2 X K as Z ⊙ K Z = {(i, i, . . . , i)|i ∈ Z}</formula><p>where the tuples involve K identical elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Brief Review of Complexity Theory</head><p>We now briefly review necessary results and definitions from complexity theory (see <ref type="bibr" target="#b10">[11]</ref> for further details). A problem is a parameterized question to be answered. An instance of a problem is obtained by specifying particular values for all the problem parameters. A decision problem is one whose answer, depending on the instance, is either "yes" or "no". An algorithm solves a problem if it produces a correct answer when applied to any instance of the problem. In the sequel, we only consider decision problems.</p><p>The class of decision problems that can be solved by a polynomial-time algorithm is called P. NP stands for the class of decision problems that are "verifiable" by a polynomialtime algorithm <ref type="bibr" target="#b10">[11]</ref>. A decision problem is NP-hard if any other decision problem in NP can be reduced to this problem using a polynomial-time algorithm. If a decision problem is NP-hard and is in NP, then it is called NP-complete.</p><p>One of the first problems proved to be NP-complete is the non-tautology (NT) problem introduced in <ref type="bibr" target="#b11">[12]</ref>. In order to describe this problem formally, we introduce some notation. Let U = {u 1 , u 2 , . . . , u M } be a set of Boolean variables (i.e., variables that take value in {0, 1}). A truth assignment for U is a function T : U → {0, 1}. If T (u) = 1 we say that u is true under T . If u is a variable in U , u and ¬u (negated u) are literals over U . A Boolean expression is built from a set of Boolean variables U , conjunction (logical AND) ∧, disjunction (logical OR) ∨, logical negation ¬, and parentheses for grouping. A phrase p is a conjunction of literals. A Boolean expression E is considered to be in (L, P )-disjunctive normal form ((L, P )-DNF) if it is a disjunction of P phrases {p 1 , . . . , p P } each with at most L literals. E can also be represented as {p 1 , . . . , p P }. We assume that for each variable u, at most one of the literals u or ¬u appears in every phrase.</p><p>Definition 1 (Non-Tautology (NT) Problem): Given a set of variables U = {u 1 , . . . , u M } and a Boolean expression E = {p 1 , . . . , p P } in (L, P )-DNF, for L, P &gt; 0, does there exist a truth assignment T for U that makes E false? The authors of <ref type="bibr" target="#b11">[12]</ref> prove that this problem is NP-complete for M &gt; 1 and P &gt; 2. After this, many authors used this result to prove NP-hardness of many problems by reducing WeA06.5</p><p>the NT problem to an instance of the problem of interest via a polynomial-time algorithm. One of these problems is the problem of language equivalence for non-deterministic automata with finite languages (EQ).</p><p>Definition 2 (Language Equivalence (EQ) Problem):</p><formula xml:id="formula_5">Given two non-deterministic automata G 1 = (X 1 , Σ, δ 1 , X 1,0 , X m,1 ) and G 2 = (X 2 , Σ, δ 2 , X 2,0 , X m,2 ) with finite languages L m (G 1 ) and L m (G 2 ), is L m (G 1 ) = L m (G 2 )?</formula><p>The authors of <ref type="bibr" target="#b12">[13]</ref> prove that the EQ problem is NPcomplete for |Σ| &gt; 1. In Section IV-B, we define the EQ-CLOSED problem as a special case of the EQ problem when X m = X and show that EQ-CLOSED is also NP-complete for |Σ| &gt; 1.</p><p>III. PROBLEM FORMULATION The notion of K-step opacity <ref type="bibr" target="#b3">[4]</ref> is suitable for cases where there is a bounded delay, after which one does not care if the outside observer can infer information about behavior that was previously considered secret (e.g., because the secret transaction has completed or because the intrusion will be detected).</p><p>Definition 3 (K-Step Opacity): Given a (possibly nondeterministic) finite automaton G = (X, Σ, δ, X 0 ), a projection map P with respect to the set of observable events Σ obs (Σ obs ⊆ Σ), and a set of secret states S ⊆ X, automaton G is K-step opaque (for some K ≥ 0) with respect to S and P (or (S, P, K)-opaque), if for all t ∈ Σ * , t ′ ∈ t, and i ∈ X 0 , δ(i, t) is nonempty,</p><formula xml:id="formula_6">|P (t)/P (t ′ )| ≤ K, δ(i, t ′ ) ⊆ S ⇒ ∃s ∈ Σ * , ∃s ′ ∈ s, ∃i ′ ∈ X 0 , P (s) = P (t), P (s ′ ) = P (t ′ ), δ(i ′ , s) is nonempty, δ(i ′ , s ′ ) S.</formula><p>Remark 1: The notion of non-interference is defined assuming that the set of events Σ can be partitioned into a finite number of security levels <ref type="bibr" target="#b8">[9]</ref>. When there are only two levels of security, i.e., public events Σ P u and private events Σ P r (so that Σ = Σ P u ∪ Σ P r and Σ P u ∩ Σ P r = ∅), noninterference requires that a user who only observes public events cannot determine the occurrence of private events <ref type="bibr" target="#b8">[9]</ref>. More specifically, in a non-interferent system G, for every string in L(G) containing private events, there exists another string in L(G) with the same substring of public events and without private events. The notion of non-interference for this scenario can be translated to an instance of 0-step opacity as follows. We first obtain the product [10] Ĝ = G × H where the deterministic automaton H is depicted in Figure <ref type="figure" target="#fig_0">1</ref>a. This product essentially splits and annotates the states of G with label P r if they are reachable via a sequence of events that contains at least one private event, and with label P u, otherwise. If we define the set of secret states S to be the set of states in Ĝ with label P r, i.e., S = {(x, P r)|x ∈ X}, then it is not hard to show that G is non-interferent if and only if Ĝ is (S, P, 0)-opaque where the projection map P is with respect to the set of observable events Σ obs = Σ P u .</p><p>Remark 2: In the framework considered in <ref type="bibr" target="#b7">[8]</ref>, the set of strings L(G) in the system is partitioned into secret strings E and non-secret strings L(G) -E, and the system is opaque if P (E) ⊆ P (L(G) -E). The notion of K-step opacity cannot be translated to a version of language-based opacity as studied in <ref type="bibr" target="#b7">[8]</ref> because in the framework we consider here, each string in the system can be treated both as secret (when it visited secret states during the past K observations) and non-secret (when it did not visit any secret state during the past K observations). To clarify this issue consider the DES G in Figure <ref type="figure" target="#fig_0">1</ref>-b and assume that X 0 = {0}, S = {1, 6}, and Σ obs = {α}. In order to characterize 2-step opacity using the framework of <ref type="bibr" target="#b7">[8]</ref>, one might be tempted to define this language as the set of all strings that can be generated by the system and visit a secret state within the past 2 observations. Hence, E = {α, αδ uo , αδ uo α, δ uo αα} which implies that L(G)-E = {ǫ, δ uo , δ uo α}. It is not hard to see that P (E) P (L(G) -E) although the system is 2-step opaque.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. VERIFICATION OF K -STEP OPACITY</head><p>A. Verification of K-Step Opacity using State Estimators K-step opacity is a predicate defined for states which have been visited a fixed number of observations in the past. Existing state estimation techniques cannot verify these properties since they are not tracking the trajectory of the states. For this reason, our work in <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref> introduces K-delay state estimators which are capable of capturing the estimate of the states the system was possibly in when it generated the K th to last output (i.e., the state of the system K observations ago) following a sequence of observations s = α 0 α 1 . . . α n (n ≥ K).</p><p>Definition 4 (K-Delayed State Estimate): Given a (possibly non-deterministic) finite automaton G = (X, Σ, δ, X 0 ) and a projection map P with respect to the set of observable events Σ obs (Σ obs ⊆ Σ), the K-delayed state estimate after observing string s = α 0 α 1 . . . α n (n ≥ K) is defined as</p><formula xml:id="formula_7">X|s|-K (s) := {i|i ∈ X, ∃s ′ , s ′′ ∈ Σ * , ∃j ∈ X 0 : δ(j, s ′ ) = i, δ(i, s ′′ ) is nonempty, P (s ′ ) = α 0 α 1 . . . α n-K , P (s ′′ ) = α n-K+1 . . . α n }. Note that Definition 4 implies that if s ∈ Σ *</formula><p>obs is not a valid sequence of observations in G then X|s|-K (s) = ∅. Also, by convention X|s|-K (s) is taken to be X0 (s) for |s| &lt; K. A K-delay state estimator is a (deterministic) finite automaton which reconstructs the k-delayed state estimates (0 ≤ k ≤ K) associated with a given sequence of observations s. In our earlier work in <ref type="bibr" target="#b3">[4]</ref>, we construct a K-delay state estimator (which we call observation-based KDE) that captures the k-delayed state estimates (0 ≤ k ≤ K) by remembering the sequence of the last K observations. In this paper, we introduce a novel K-delay state estimator which captures the k-delayed state estimates (0 ≤ k ≤ K) by storing the possible sequences of the last (K +1)-visited states via (K + 1)-dimensional state mappings associated with its states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>WeA06.5</head><p>The KDE utilizes (K + 1)-dimensional state mappings to capture the K-delayed state estimates as follows: each state of the KDE is associated with a unique (K + 1)dimensional state mapping, with the initial state of the KDE m 0 associated with the (K + 1)-dimensional state mapping X 0 ⊙ K+1 X 0 . When observation α ∈ Σ obs is made, this initial (K + 1)-dimensional state mapping m 0 is shifted with the induced state mapping M (α) corresponding to the observation α, resulting in a (K + 1)-dimensional state mapping m 1 corresponding to the next state of the state estimator, i.e., m 1 = m 0 M (α). For subsequent observations, the current state of the KDE transitions into the state associated with the (K + 1)-dimensional state mapping m ′ that can be obtained by shifting of the previous (K + 1)-dimensional state mapping m with the state mapping M (β) induced by the new observation β, i.e., m ′ = m M (β). Using the structure of (K + 1)-dimensional state mappings and the shift operator, we can see that a sequence of observations corresponds to a sequence of (K + 1)-dimensional state mappings; at a given time step, the set of starting states m(K) of the associated (K + 1)-dimensional state mapping m corresponds to K-delayed state estimates, the set of ending states m(0) represents zero-delayed state estimates, and the set of intermediate states m(k), 1 &lt; k &lt; K, represents k-delayed state estimates. In this manner, we can build a structure which at any time, following a given sequence of observations, maintains information about the 0-delayed, 1-delayed, . . ., and K-delayed state estimates through the (K + 1)-dimensional state mappings associated with each of its states.</p><p>Definition 5: [K-Delay State Estimator (KDE)] Given a (possibly non-deterministic) finite automaton G = (X, Σ, δ, X 0 ) and a projection map P with respect to the set of observable events Σ obs (Σ obs ⊆ Σ), we define the K-delay state estimator as the deterministic automaton G K,obs = AC(2 X (K+1) , Σ obs , δ K,obs , X K,0 ) with state set 2 X (K+1) , event set Σ obs , initial state X K,0 = X 0 ⊙ K+1 X 0 , and state transition function δ K,obs : 2</p><formula xml:id="formula_8">X (K+1) × Σ obs → 2 X (K+1) defined for α ∈ Σ obs as m ′ = δ K,obs (m, α) := m M (α),</formula><p>where m, m ′ ∈ 2 X (K+1) . If we let X K,obs ⊆ 2 X (K+1) be the set of states reachable from the initial state X K,0 under δ K,obs , then G K,obs = (X K,obs , Σ obs , δ K,obs , X K,0 ). The above KDE can be shown to indeed capture the kdelayed state estimates correctly <ref type="bibr" target="#b3">[4]</ref> and to have no more states than the observation-based KDE in <ref type="bibr" target="#b3">[4]</ref>. This latter property is established in <ref type="bibr" target="#b4">[5]</ref> and implies that in order to construct k-delayed state estimates (0 ≤ k ≤ K), it is more space-efficient to store the set of sequences of the last K visited states (that are generated by the last K observations) instead of storing the sequence of the last K observations.</p><p>In <ref type="bibr" target="#b3">[4]</ref>, we showed that a DES system is K-step opaque if and only if all k-delayed state estimates (0 ≤ k ≤ K) contain at least one element outside the set of secret states S. Thus, DES G is K-step opaque if and only if for all m ∈ X K,obs : Example 1: Consider the DES G in Figure <ref type="figure" target="#fig_0">1</ref>-c with Σ obs = {α, β}. For this system, the 2-delay state estimator is represented in Figure <ref type="figure">2</ref> along with the 3-dimensional state mappings m 0 , m 1 , . . . , m 10 needed in the construction <ref type="foot" target="#foot_0">1</ref> . The initial state of the system is X 0 = X and the 2-delay state estimator initial state captures this in m 0 via a 3-dimensional state mapping that maps each system state to itself as X ⊙ 3 X = {(0, 0, 0), (1, 1, 1), (2, 2, 2), <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b2">3)</ref>, <ref type="bibr" target="#b3">(4,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b3">4</ref>)}≡ m 0 . Starting from the initial state, assume that we observe α. The state mapping M (α) induced by observing α is {(0, 2), (0, 3), (2, 2), (4, 4)} which implies that α can be observed only from states 0, 2, and 4; moreover, if the initial state was 0, the current state can be any of the states in {2, 3}; if the initial state was 2, the current state could only be 2; similarly, if the initial state was 4, the current state would be 4. Following observation α, the next state in the 2-delay state estimator m ′ can be constructed as m ′ = δ K,obs (m 0 , α) = m 0 M (α)= {(0, 0, 2), (0, 0, 3), (2, 2, 2), (4, 4, 4)} ≡ m 1 .</p><formula xml:id="formula_9">m(k) ∩ 2 S = ∅ or m(k) = ∅, 0 ≤ k ≤ K.<label>(1)</label></formula><p>Next, assume that we observe β which results in M (β) = {(0, 1), <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b3">4)</ref>, <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b3">4)</ref>}. We have m ′ = δ K,obs (m 1 , β) = m 1 M (β)= {(0, 3, 4)} ≡ m 4 . This implies that αβ can only be observed if the system follows the state trajectory 0 → 3 → 4.</p><p>Using the above approach for all possible observations (from each state), the 2-delay state estimator construction can be completed as shown in Figure <ref type="figure">2</ref>. Note that we have not included the state that corresponds to the all empty state mapping (and any transitions from/to it) to avoid cluttering the diagram. Using the K-delay state estimator we can verify K-step opacity: for example, we can easily establish that DES G in Figure <ref type="figure" target="#fig_0">1</ref>-c is not ({0}, P, 2)-opaque due to the existence of state m 4 (or m 6 ) in the 2-delay state estimator depicted in Figure <ref type="figure">2</ref>. If the system generates the sequence of observations αβ (or ββ), then (since the only state from which αβ or ββ can be observed is state 0) we can conclude with certainty that the system was in state 0 two steps ago. This violates the 2-step opacity requirement since state 0 is a secret state.</p><p>Remark 3: The system in Figure <ref type="figure" target="#fig_0">1</ref>-b is 2-step opaque with respect to S = {1, 6}, however, upon observing αα, the intruder is certain that, regardless of the state sequence that has occurred, the system has visited a secret state within the last 2 observations (although one cannot determine exactly when this happened). This system can be considered as with m 0 = X 0 ⊙ 2 X 0 , and we constructed an initial-state estimator (ISE), each state of which can be associated with a state mapping (its initial state is associated with the state mapping m 0 = X 0 ⊙ 2 X 0 ). We showed that the set of starting states in the state mapping associated with the ISE state reached via string s is the set of states from which the observation s could have originated. Since the ISE has at most 2 N 2 states (because there are that many different state mappings), we are guaranteed that each ISE state is reachable via a string that generates at most K observations as long as K ≥ 2 N 2 -1.</p><p>Theorem 3: Assume that G K,obs and G K * ,obs with K &gt; K * = 2 N 2 -1 are delayed state estimators for a finite automaton G = (X, Σ, δ, X 0 ) and are constructed as described in Definition 5. Then, for any (K + 1)-dimensional state mapping m associated with the KDE state reached in G K,obs via s = α 0 α 1 . . . α n with |s| &gt; 2 N 2 -1 and for each m(k), 2 N 2 ≤ k ≤ K, there exists a (K * + 1)-dimensional state mapping m ′ associated with a state reached in G K * ,obs via some s</p><formula xml:id="formula_10">′ = α 0 α 1 . . . α n-k α ′ n-k+1 . . . α ′ n ′ for some n ′ ≤ n + 2 N 2 -1 -k and with α ′ n-p ∈ Σ obs , k -1 ≤ p ≤ n -n ′ , such that m(k) = m ′ (k + n ′ -n).</formula><p>The above result (whose proof is omitted in the interest of space) can be used to show that K ′ -step opacity is equivalent to K-step opacity for</p><formula xml:id="formula_11">K ′ &gt; K ≥ 2 N 2 -1. We prove this by showing that for K ≥ 2 N 2 , K-step opacity is equivalent to K * -step opacity with K * = 2 N 2 -1.</formula><p>Theorem 4: For a (possibly non-deterministic) finite automaton G = (X, Σ, δ, X 0 ), K-step opacity is equivalent to K * -step opacity for K &gt; K * = 2 N 2 -1 where N = |X|.</p><p>Proof: (K-step opacity ⇒ K * -step opacity) Recall that DES is K-step opaque if and only if for all m ∈ X K,obs , (1) holds. Consider the (K + 1)-dimensional state mapping m and the (K * + 1)-dimensional state mapping m ′ associated with the states reached in G K,obs and G K * ,obs via s. Observe that m(k) = m ′ (k), 0 ≤ k ≤ 2 N 2 -1; since both m(k) and m ′ (k) denote the k-delayed state estimate due to observation s, they are identical sets of states. Therefore, (1) implies that ∀m ∈ X K * ,obs : m(k) ∩ 2 S = ∅ or m(k) = ∅, 0 ≤ k ≤ K * , which implies that K * -step opacity holds. (K * -step opacity ⇒ K-step opacity) We need to show <ref type="bibr" target="#b0">(1)</ref>. From Theorem 3 we have: for any (K +1)-dimensional state mapping m associated with states of G K,obs reached via a string s with |s| ≥ 2 N 2 -1 and 2 N 2 ≤ k ≤ K, there exists a (K * + 1)-dimensional state mapping m ′ associated with states of G K * ,obs and some l satisfying 0 ≤ l ≤ 2 N 2 -1 such that m(k) = m ′ (l). Now if DES G is K * -step opaque, then all sets of intermediate states m ′ (l) of all (K * + 1)dimensional state mappings m ′ associated with states in G K * ,obs contain states outside the set of secret states or empty; following the previous discussion, for 2 N 2 ≤ k ≤ K, all sets of intermediate states m ′ (k) of all (K * + 1)dimensional state mappings m ′ associated with states of G K,obs contain states outside the set of secret states. This implies (1) for 2 N 2 ≤ k ≤ K. Moreover, the discussion in part (i) implies (1) for 0 ≤ k ≤ 2 N 2 -1. Therefore (1) holds if m is reached in G K,obs via a string s with |s| ≥ 2 N 2 -1. If m is reached via a shorter string t with |t| &lt; 2 N 2 -1, then the discussion in part (i) still implies (1) for 0 ≤ k &lt; 2 N 2 -1; moreover for 2 N 2 -1 ≤ k ≤ K, we have m(k) ≡ X 0 (since we have yet to make enough observations) which trivially satisfies (1).</p><p>V. CONCLUSION In this paper, we analyze the computational complexity of the K-step opacity verification problem for a given (possibly non-deterministic) automaton and establish that it is an NPhard problem. We also show that for any K ′ &gt; K ≥ 2 N 2 -1 (where N is the number of states of the given automaton), K-step opacity and K ′ -step opacity become equivalent. In our future work, we are interested in studying the complexity required in order for an intruder to compute an attack that violates opacity in a given system (assuming that the intruder has partial control of the system). We are also interested in studying scenarios under which a tighter bound K * exists (such that K-step opacity and K ′ -step opacity for K ′ &gt; K ≥ K * become equivalent). Finally, another direction for future research is to obtain simplifying assumptions under which the K-step opacity verification becomes easier (e.g. belongs in P).</p><p>ACKNOWLEDGEMENT Remarks 1 and 3 are due to comments of an anonymous reviewer for which the authors are grateful.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. (a) DES H in Remark 1; (b) DES G in Remark 2; (c) DES G in Example 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 . 2 -</head><label>22</label><figDesc>Fig. 2. 2-delay state estimator corresponding to DES G in Figure 1-c.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In Figure</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>2, we use 3-dimensional trellis diagrams to capture 3dimensional state mappings; it can be shown that this can be done without loss of generality for the class of state mapping we are interested in.WeA06.5</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This material is based upon work supported in part by the National Science Foundation, under NSF ITR Award 0426831 and NSF CNS Award 0834409. The research leading to these results has also received funding from the European Community Seventh Framework Programme (FP7/2007-2013) under grant agreements INFSO-ICT-223844 and PIRG02-GA-2007-224877. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the views of NSF or EC. A. Saboori is with the Coordinated Science Laboratory, and the Department of Electrical and Computer Engineering, University of Illinois at Urbana-Champaign. C. N. Hadjicostis</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>insecure if the attacker is only interested in determining whether the system has reached secret states at any point during the last K observations. This type of violation does not occur if and only if in the K-delay state estimator associated with the system, for all non-empty m ∈ X K,obs , there exists a (i 0 , i 1 , . . . , i K ) ∈ m such that i 0 , i 1 , . . . , i K ∈ X -S. Clearly, the number of states of the KDE is bounded by 2 N K+1 . In <ref type="bibr" target="#b3">[4]</ref>, we showed that the state complexity of the corresponding observation-based KDE is O((|Σ obs | + 1) K × 2 N ) and since the number of states of the KDE introduced in this paper is upper bounded by the number of the states of the observation-based KDE <ref type="bibr" target="#b4">[5]</ref>, the state complexity of the KDE studied in this paper is also O((</p><p>This, in turn, implies that the space and time complexity of verifying K-step opacity using the KDE introduced in this paper is also O((|Σ obs | + 1) K × 2 N ). This exponential complexity is not desirable for implementation purposes; as we show in the following section, however, it is unlikely that any algorithm can verify this property in polynomial time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Verification of K-Step Opacity is NP-Hard for |Σ obs | &gt; 1</head><p>In order to characterize the complexity class of the K-step opacity verification (KSTEP) problem, we first prove that the EQ-CLOSED problem is NP-complete for |Σ| &gt; 1.</p><p>Theorem 1: The EQ-CLOSED problem is NP-complete for |Σ| &gt; 1.</p><p>Proof: In order to show that the EQ-CLOSED problem is NP-hard, we use an approach similar to the one used in <ref type="bibr" target="#b12">[13]</ref> and reduce the NT problem with M &gt; 1 and P &gt; 2 (where M is the number of Boolean variables and P is the number of phrases) to an instance of the EQ-CLOSED problem with |Σ| &gt; 1 via a polynomial-time algorithm. Note that in the construction introduced in <ref type="bibr" target="#b12">[13]</ref>, the languages of the obtained automata are not necessarily prefix-closed; here, we extend this construction to guarantee that the resulting languages are all prefix-closed.</p><p>Given the Boolean expression E = {p 1 , . . . , p P } in (L, P )-DNF (i.e., an expression which consists of the disjunction of P phrases with maximum number L of literals in each phrase) defined over the set of variables U = {u 1 , . . . , u M }, we construct the non-deterministic finite automaton G = (X, Σ, δ, X 0 ) with state set X = (U ∪ {u f }) × {1, . . . , P }, event set Σ = {0, 1}, set of initial states X 0 = {u 1 } × {1, . . . , P }, and state transition function δ : X × Σ → X defined as follows: For (u i , j) ∈ X,</p><p>∈ p j and ¬u i / ∈ p j ); otherwise δ((u i , j), 1) is undefined. For (u M , j) ∈ X, 1 ≤ j ≤ P , we have δ((u M , j), 0) = (u f , j), if (¬u M ∈ p j ) or (u M / ∈ p j and ¬u M / ∈ p j ); otherwise δ((u M , j), 0) is undefined. Finally, for (u M , j) ∈ X, 1 ≤ j ≤ P , we have δ((u M , j), 1) = (u f , j), if (u M ∈ p j ) or (u M / ∈ p j and ¬u M / ∈ p j ); otherwise δ((u M , j), 1) is undefined.</p><p>It is not hard to see that for E to be a tautology, it is necessary and sufficient that L(G) = {ǫ} M k=1 Σ k where M is the number of Boolean variables. Therefore, checking whether E is a tautology with M = |U | &gt; 1 reduces to an instance of EQ-CLOSED with |Σ| &gt; 1. Also, note that this reduction can be done in polynomial time in the size of E (i.e., in the total number of literals summed over all phrases). This proves that EQ-CLOSED is NP-hard for |Σ| &gt; 1.</p><p>The EQ-CLOSED problem is a special case of the EQ problem, and therefore is in NP (since the EQ problem is in NP). This completes the proof. Note that Theorem 1 also proves that the verification of language containment (LC) for non-deterministic automata with finite languages is NP-complete (since verifying</p><p>Next, we reduce the LC problem to an instance of K-step opacity. The proof is omitted due to space limitations.</p><p>Theorem 2: Given two non-deterministic automata 2 G 1 = (X 1 , Σ, δ 1 , X 1,0 ) and G 2 = (X 2 , Σ, δ 2 , X 2,0 ) with finite languages of length K and |Σ| &gt; 1, define the nondeterministic automaton G = (X, Σ, δ, X 0 ) with the state set X = X 1 ∪X 2 , set of initial states X 0 = X 1,0 ∪X 2,0 , and state transition function δ :</p><p>and only if G is (S, P, K)-opaque where S ≡ X 1,0 and projection map P is with respect to the set of observable events Σ obs = Σ.</p><p>The time complexity of constructing</p><p>which is polynomial in the number of states of G 1 and G 2 . Therefore, Theorem 2 proves that deciding whether the (possibly non-deterministic) finite automaton is K-step opaque is NP-hard for |Σ obs | &gt; 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ROLE OF DELAY IN K -STEP OPACITY</head><p>In this section, we show that for K ′ &gt; K ≥ 2 N 2 -1, Kstep opacity and K ′ -step opacity are equivalent. Note that K-step opacity does not in general imply K ′ -step opacity for K ′ &gt; K. The idea behind the proof is the following: fix a point in the system's state trajectory. In the K-step opacity problem we are interested in finding how much we can say regarding the membership of the state, at that fixed point in time, within the set of secret states, even after we make K additional observations. We can gain insight to this question by considering the estimate of the state at this fixed point as the initial uncertainty for an initial-state estimation problem. In <ref type="bibr" target="#b5">[6]</ref>, we studied the problem of initial-state estimation for a (possibly non-deterministic) finite automaton which, given a sequence of observations s = α 0 α 1 . . . α n and a set of possible initial states X 0 (i.e., initial uncertainty), requires enumeration of all states that belong to X 0 , and which could have generated this sequence of observations s. We call these states the initial state estimate X0 (s) associated with the sequence of observations s. In <ref type="bibr" target="#b5">[6]</ref>, we showed that X0 (s) = m(1) where m = m 0 •M (α 0 )•M (α 1 ) . . .•M (α n ) 2 Without lost of generality, we assume that X 1 ∩ X 2 = ∅. One can always rename the states to achieve this.</p><p>WeA06.5</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A taxonomy of trace-based security properties for CCS</title>
		<author>
			<persName><forename type="first">R</forename><surname>Focardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th Workshop on Computer Security Foundations</title>
		<meeting>of the 7th Workshop on Computer Security Foundations</meeting>
		<imprint>
			<date type="published" when="1994-06">June 1994</date>
			<biblScope unit="page" from="126" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">CSP and anonymity</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sidiropoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 4th European Symposium on Research in Computer Security</title>
		<meeting>of the 4th European Symposium on Research in Computer Security</meeting>
		<imprint>
			<date type="published" when="1996-09">September 1996</date>
			<biblScope unit="page" from="198" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Opacity generalised to transition systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bryans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koutny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mazare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 3rd International Workshop on Formal Aspects in Security and Trust</title>
		<meeting>of the 3rd International Workshop on Formal Aspects in Security and Trust</meeting>
		<imprint>
			<date type="published" when="2005-07">July 2005</date>
			<biblScope unit="page" from="81" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Notions of security and opacity in discrete event systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Saboori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Hadjicostis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 46th IEEE Conference on Decision and Control</title>
		<meeting>of the 46th IEEE Conference on Decision and Control</meeting>
		<imprint>
			<date type="published" when="2007-12">December 2007</date>
			<biblScope unit="page" from="5056" to="5061" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Delayed state estimation in discrete event systems and its application to security problems</title>
		<idno>UILU-ENG-08-2204</idno>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Verification of initial-state opacity in security applications of DES</title>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th International Workshop on Discrete Event Systems</title>
		<meeting>of the 9th International Workshop on Discrete Event Systems</meeting>
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
			<biblScope unit="page" from="328" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Modelling opacity using Petri nets</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Bryans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koutny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Y A</forename><surname>Ryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">121</biblScope>
			<biblScope unit="page" from="101" to="115" />
			<date type="published" when="2005-02">February 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Concurrent secrets</title>
		<author>
			<persName><forename type="first">E</forename><surname>Badouel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bednarczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Borzyszkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Caillaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Darondeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Event Dynamic Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="425" to="446" />
			<date type="published" when="2007-12">December 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On the verification of intransitive noninterference in multilevel security</title>
		<author>
			<persName><forename type="first">N</forename><surname>Hadj-Alouane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lafrance</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mullins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yeddes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="948" to="958" />
			<date type="published" when="2005-10">October 2005</date>
		</imprint>
	</monogr>
	<note>Part B (Cybernetics)</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">C</forename><surname>Cassandras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lafortune</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
	<note>Introduction to Discrete Event Systems</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Computers and Intractability -A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Freeman</title>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The complexity of theorem-proving procedures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 3rd Annual ACM Symposium on Theory of Computing</title>
		<meeting>of the 3rd Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1971-04">April 1971</date>
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the time and tape complexity of languages, I</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">H B</forename><surname>Hunt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th Annual ACM Symposium on Theory of Computing</title>
		<meeting>of the 5th Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1973-04">April 1973</date>
			<biblScope unit="page" from="10" to="19" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
