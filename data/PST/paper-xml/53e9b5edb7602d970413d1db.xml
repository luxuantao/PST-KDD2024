<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards Type Inference for JavaScript</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Christopher</forename><surname>Anderson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing</orgName>
								<orgName type="institution">Imperial College London</orgName>
								<address>
									<addrLine>180 Queen&apos;s Gate</addrLine>
									<postCode>SW7 2BZ</postCode>
									<settlement>London</settlement>
									<country key="GB">U.K</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Paola</forename><surname>Giannini</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Dipartimento di Informatica</orgName>
								<orgName type="institution">Università del Piemonte Orientale</orgName>
								<address>
									<addrLine>Via Bellini 25/G</addrLine>
									<settlement>Alessandria</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sophia</forename><surname>Drossopoulou</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing</orgName>
								<orgName type="institution">Imperial College London</orgName>
								<address>
									<addrLine>180 Queen&apos;s Gate</addrLine>
									<postCode>SW7 2BZ</postCode>
									<settlement>London</settlement>
									<country key="GB">U.K</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Towards Type Inference for JavaScript</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">89066666573935ECD39D6D13C932CE21</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Object-oriented scripting languages like JavaScript and Python are popular partly because of their dynamic features. These include the runtime modification of objects and classes through addition of fields or updating of methods. These features make static typing difficult and so usually dynamic typing is used. Consequently, errors such as access to non-existent members are not detected until runtime. We first develop a formalism for an object based language, JS0, with features from JavaScript, including dynamic addition of fields and updating of methods. We give an operational semantics and static type system for JS0 using structural types. Our types allow objects to evolve in a controlled manner by classifying members as definite or potential. We define a type inference algorithm for JS0 that is sound with respect to the type system. If the type inference algorithm succeeds, then the program is typeable. Therefore, programmers can benefit from the safety offered by the type system, without the need to write explicitly types in their programs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The popularity of scripting languages stems from the flexible programming features they support. These include the runtime modification of objects through addition of fields or updating of methods. These features make static typing difficult and so usually dynamic typing is used. Consequently, errors such as access to non-existent members are not detected until runtime, or, as in JavaScript, not detected at all which can result in a web browser reporting an error when viewing a web page containing JavaScript code.</p><p>We introduce JS 0 , a formalism of JavaScript <ref type="bibr" target="#b16">[16]</ref>. JS 0 supports the standard JavaScript flexible features, e.g. functions creating objects, and dynamic addition/reassignment of fields and methods. We also introduce JS T 0 , an explicitly typed version of JS 0 . Types in JS T 0 comprise object types, function types, and Int (the type of integers). Object types list the methods and fields present in the object, µ α.[m 1 : (t 1 , ψ 1 ) • • • m n : (t n , ψ n )]. We use the µ-binder to allow a type to refer to itself. Our type system permits objects to evolve in a controlled manner by allowing members to be added to an object after it has been created. This is achieved by annotating with ψ, each member of an object type as either potential '•' or definite '•'.</p><p>Function types have the form, t = µ α.(O × t 1 t 2 ), where O is the type of the receiver, t 1 is the type of the formal parameter and t 2 is the return type. As for object types, the bound variable α allows references to t within O, t 1 , and t 2 . Thus, µ α.( × α) is a function that returns a value of the same type as the function itself.</p><p>A function can be used as a global function if its type does not make any requirements of its receiver. The type system is rich enough to allow typing of many JavaScript programs, and at the same time prevents runtime errors such as access to non-existing members of objects.</p><p>We develop a sound type inference algorithm to automatically translate JS 0 code to JS T 0 code. The algorithm uses type variables which represent the type of expressions. Constraints are generated between the type variables. If there is a solution to the constraints this can be used to translate code from JS 0 to JS T 0 . We define a translation between constraints and types that provides the types for the typed version of the code.</p><p>In <ref type="bibr" target="#b5">[6]</ref> we introduced the language JS 0 and its type system. In this paper we have simplified the presentation of JS T 0 and its type system and defined a sound type inference algorithm.</p><p>This paper is organized as follows. In Section 2 we define the syntax of JS 0 and its operational semantics, and in Section 3 we give JS T 0 . Properties of the type system for JS T 0 are outlined in Section 4. In Section 5 we show type inference for JS 0 , and in Section 6 we show how to turn constraints into types. In Section 7 we compare our work with others. In Section 8 we draw conclusions and outline our future directions. The proofs and a prototype implementation can be found at http://www.binarylord.com/work/js0/.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">JS 0</head><p>We have developed JS 0 a subset of JavaScript. Figure <ref type="figure" target="#fig_0">1</ref> gives an example JS 0 program that describes an implementation of the JavaScript Date object <ref type="foot" target="#foot_0">1</ref> . We define functions Date and addFn. The code preceded by the comment //Main is the entry point into the program. Although the syntax of JS 0 requires all code to be within a function body to aid presentation we allow a main body of code and the declaration of local variables x and y. The example demonstrates the core JavaScript features we have included:</p><p>1. creating objects using functions (line 10 and 11), 2. implicit creation of members in objects through assignment (lines 2 and 3), and 3. acquiring methods through assignment of a function to a member (line 3). We chose these features because, (1) represents the way objects are created in JavaScript, ( <ref type="formula">2</ref>) and (3) represent the way objects acquire fields and methods thus giving flexibility to the programmer. JS 0 does not include the following JavaScript features: member names as strings, functions as expressions, dynamic removal of members, automatic conversions, and delegation. We omitted the first three as we believe they are not essential in supporting flexible object-oriented programming. The last two while useful can complicate static typing and type inference. We can write the introductory examples from <ref type="bibr" target="#b15">[15]</ref> in JS 0 assuming libraries of functions, and predefined types e.g. floats, strings, etc.</p><p>The syntax of JS 0 is given in Figure <ref type="figure" target="#fig_1">2</ref>. Note that, in the syntax of JS 0 we omitted conditional expressions, which were present in <ref type="bibr" target="#b5">[6]</ref>. Their presence does not produce conceptual difficulties regarding the type system and type inference. A program is a sequence of function declarations. In JS 0 functions may have only one formal parameter. The extension to functions with multiple parameters is trivial, whereas going to a variable number of parameters, as in JavaScript, is an interesting possible future extension.</p><p>For a program P, we use P(f) as a shorthand for looking up the definition of function f in P .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Operational Semantics</head><p>We give a structural operational semantics for JS 0 that rewrites tuples of expressions, heaps and stacks into tuples of values, heaps and stacks in the context of a program. The signature of the rewriting relation is:  where:</p><formula xml:id="formula_0">: Program Exp × Heap × Stack (Val ∪ Dev) × Heap × Stack P ∈ Program ::= F * F ∈ FuncDecl ::= function f (x) { e } e</formula><formula xml:id="formula_1">:= f | f | . . . m ∈ MemberID ::= m | m | . . .</formula><formula xml:id="formula_2">H ∈ Heap = Addr → fin Obj χ ∈ Stack = {this, x} Val such that χ(this) ∈ Addr v ∈ Val = {null} ∪ FuncID ∪ Addr ∪ Int dv ∈ Dev = {nullPntrExc, stuckErr} o ∈ Obj = MemberID → fin Val</formula><p>The heap maps addresses to objects, where addresses, Addr, are ι 0 , ..ι n ... We use → fin to indicate a finite mapping. As usual, the notation f[x → y] denotes updating function f to map x to y. Thus, the meaning of heap update H[ι → v] and stack update χ[x → v] is clear. The stack maps this to an address and x to a value, where values, Val, are function identifiers (denoting functions), addresses (denoting objects), null , or integers. Finally objects are finite mappings from member identifiers to values. With &lt; &lt;m</p><formula xml:id="formula_3">1 : v 1 ...m n : v n &gt; &gt; we denote the object mapping m i to v i for i ∈ 1 • • • n.</formula><p>A full description of the rules is given in <ref type="bibr" target="#b5">[6]</ref>. In JavaScript access to nonexistent members result in an undefined value not a runtime error 2 . This may cause errors later on in the code. We consider accesses to non-existent members a runtime error and our type system prevents them. Below we give two of the more interesting rules, (memAdd) for adding/updating members and (memCall) for calling methods:</p><formula xml:id="formula_4">e 1 , H, χ ι, H 1 , χ 1 e 2 , H 1 , χ 1 v, H 2 , χ H = H 2 [ι → H 2 (ι)[m → v]] (memAdd ) e 1 .m = e 2 , H, χ v, H , χ e 1 , H, χ ι, H 1 , χ 1 e 2 , H 1 , χ 1 v , H 2 , χ H 2 (ι)(m) = f P(f) = function f(x) {e } χ 2 = {this → ι, x → v } e , H 2 , χ 2 v, H , χ (memCall ) e 1 .m(e 2 ), H, χ v, H , χ</formula><p>In rule (memAdd) we express how objects obtain new members. We first evaluate the receiver, then the right hand side. Using heap update we add/update member m in the receiver. Returning to the example in Figure <ref type="figure" target="#fig_0">1</ref>, executing this.mSec = x from Date with χ 0 (this) = ι 0 , χ 0 (x) = 1000, H 0 (ι 0 ) = &lt; &lt;&gt; &gt;, will produce H 1 with H 1 (ι 0 ) = &lt; &lt;mSec : 1000&gt; &gt;</p><p>In rule (memCall) we first evaluate the receiver and then the actual parameter of the method. We obtain the function definition (corresponding to the method) by looking up the value of member m in the receiver (obtained by evaluation of e) in P<ref type="foot" target="#foot_2">3</ref> . We execute the body with a stack in which this refers to the receiver of the call and x to the value of the actual parameter.</p><p>For example, executing the code in Figure <ref type="figure" target="#fig_0">1</ref> in the presence of an empty heap, H 0 and χ 0 , mapping x and y to null will result in stack χ 1 (x) = ι 0 , χ 1 (y) = ι 1 and updated heap H 1 , H 1 (ι 0 ) = &lt; &lt;mSec : 1100, add : addFn&gt; &gt;, H 1 (ι 1 ) = &lt; &lt;mSec : 100, add : addFn&gt; &gt;. For demonstration purposes the stack contains an extra variable y although the definition of stack allows only this and x.</p><p>Note that member add of both ι 0 and ι 1 has value addFn. This indicates that it is an alias of function addFn, which is invoked when x.add(y) is executed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A Type System for JS 0</head><p>In this section we introduce JS T 0 a typed version of JS 0 . Figure <ref type="figure" target="#fig_2">3</ref> shows the parts of JS T 0 that differ from JS 0 along with the definitions of types. Observe that functions are now annotated with a function type G.</p><p>Types t 1 , ..., t n , comprise object types, function types, or Int (the type of integers). Object types list the methods and fields present in the object. We use the µ-binder to allow a type to refer to itself. So µ α.M where</p><formula xml:id="formula_5">M = [m 1 : (t 1 , ψ 1 ) • • • m n : (t n , ψ n )],</formula><p>is the type of an object with members m 1 , ..., m n of type t 1 , ..., t n , respectively. Figure <ref type="figure" target="#fig_3">4</ref> gives a JS T 0 version of the Date example from Figure <ref type="figure" target="#fig_0">1</ref>. We use t 1 for type [mSec : (Int, •), add : ((t 2 × t 2 t 2 ), •)] and t 2 for type µ α.[mSec : (Int, •), add : ((α × α α), •)]. To aid the presentation we allow local variable type declarations on lines 10 and 11. These are not part of the syntax of JS T 0 , where type declarations are only allowed for the   Our type system permits objects to evolve in a controlled manner by allowing members to be added to an object after it has been created. This is achieved by annotating each member of an object type as either potential '•' or definite '•' e.g. mSec : (Int, •) in t 1 and mSec : (Int, •) in t 2 . When a potential member is assigned to, it becomes definite, replacing • with •. To keep the type system manageable we only track assignments to variables (formal parameters and this) within the scope of a function. In a well-typed program potential members may not be accessed until they have been assigned to.</p><formula xml:id="formula_6">Syntax P ∈ Program ::= F * F ∈ FuncDecl ::= function f(x) : G { e} Types t ∈ Type ::= O | G | Int tp ∈ PreType ::= α | t O ∈ ObjType ::= µ α.M | M G ∈ FuncType ::= µ α.R | R M ∈ ObjMembers ::= [(m : tm) * ] tm ∈ MemberType ::= (tp, ψ) R ∈ FuncRow ::= (O × tp tp) ψ ∈ Annotation ::= • | • α ∈ ObjVar ::= α | α | α . . .</formula><p>Function types, (O × t 1 t 2 ) or µ α.(O × t 1 t 2 ), list the type of the receiver, O, which is an object type, the type of the parameter, t 1 , and the type of the return value of the function, t 2 . As for object types the µ-binder allows a function type to refer to itself, thus µ α.( × α) is a function that returns a function with its type.</p><p>If the type of m is an object type, or Int, the member represents a field. If the type of m is a function type, then m represents a method. In case the type of the m is α then if α is bound in an objects type the member is a field, whereas if it is bound in a function type it is a method. An object type is well-formed if it is closed and contains unique member definitions that are themselves well-formed.</p><formula xml:id="formula_7">A function type G = µ α.R (or G = R) is well-formed, G , if the receiver, parameter and return types of G[α/R] (or R) are well-formed.</formula><p>For a well-formed object type O, define O(m), which selects the annotated type of the member</p><formula xml:id="formula_8">m in O (if it is defined) by first defining selection from O = [m 1 : (t 1 , ψ 1 ) • • • m n : (t n , ψ n )] as O(m) = (t i , ψ i ) if m = m i for some i, 1 ≤ i ≤ n Udf otherwise and then if O = µ α.M, O(m) = M[α/O](m)</formula><p>That is, the type is closed by substituting occurrences of α with the enclosing type. Therefore, if O is well-formed, then also O(m) is well-formed.</p><p>With O[m → (t, ψ)] we denote the updating of the member m to type t with annotation ψ in O. Note that, if O and t are well-formed, then O[m → (t, ψ)] is well-formed.</p><p>Congruence and Subtyping Congruence between types is defined in Figure <ref type="figure">5</ref>. With t 1 [α/t 2 ], we denote the substitution of the free occurrences of α in t 1 with t 2 . Object types are congruent up to α-conversion, permutation of their members, and unfolding of the bound variable, and function types are congruent up to α-conversion, and unfolding of the bound variable.</p><p>The subtyping judgement t ≤ t , defined in Figure <ref type="figure">6</ref>, means that an object or function of type t can be used whenever one of type t is required. For object types we have subtyping in width. If O ≤ O , then all definite members of O must be present and congruent with those in O, and all potential members of O must be present as potential or definite members of O with congruent types. This condition is needed to insure that the addition of a new member to an object does not break compatibility.</p><p>Returning to the example in Figure <ref type="figure" target="#fig_3">4</ref> we see that t 2 is a subtype of t 1 because all members of t 1 are also members of t 2 , and have congruent types; furthermore, all members of t 2 are definite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reflexivity Unfolding</head><p>Transitivity</p><formula xml:id="formula_9">t ≡ t µ α.M ≡ M[α/µ α.M] µ α.R ≡ R[α/µ α.R] t1 ≡ t2 t2 ≡ t3 t1 ≡ t3 Alpha -conversion α ∈ F V(M) µ α.M ≡ µ α .M[α/α ] α ∈ FV(R) µ α.R ≡ µ α .R[α/α ] Reordering Functions Members ∀ m : M(m) ≡ M (m) M ≡ M M ≡ M t1 ≡ t 1 t2 ≡ t 2 (M × t1 t2) ≡ (M × t 1 t 2 ) t ≡ t (t, ψ) ≡ (t , ψ)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 5. Congruence for types</head><p>For function types subtyping coincides with congruence. In future versions of this work we may relax this restriction and allow contravariance of the receiver and parameter type and covariance of the return type. However, since type inference was our main aim, we started with the reduced system. Given types t and t it is decidable whether t ≤ t or not.</p><formula xml:id="formula_10">ψ = • =⇒ ψ = • ψ ≤ ψ t ≡ t ψ ≤ ψ (t, ψ) ≤ (t , ψ ) t ≡ t t ≤ t ∀ m : O (m) = (t , ψ ) =⇒ (O(m) = (t, ψ) ∧ (t, ψ) ≤ (t , ψ )) O ≤ O Fig. 6. Subtyping</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Typing Expressions</head><p>Typing expression e in the context of program P , and environment Γ has form:</p><formula xml:id="formula_11">P, Γ e : t Γ</formula><p>The environment, Γ = {this : O, x : t}, maps the receiver, this, to a wellformed object type, and the formal parameter, x, to a well-formed type. The environment on the right hand side of the judgement, Γ , reflects the changes to the type of the receiver or parameter while typing the expression. The only possible difference between Γ and Γ is that some members that are annotated with • in Γ are annotated with • in Γ . With Γ[var → t] we denote the updating of var to type t in Γ.</p><p>Consider the typing rules of Figure <ref type="figure">7</ref>. Rules (var), (f unc), (const), and (seq) are straightforward. Note that null may have any object type.</p><p>In rule (memAcc) the expression e must be of an object type in which the member m is definite, i.e. with annotation •.</p><p>We use the notation G(this), G(x), and G(ret), to denote the types of the receiver, parameter and return value of G. As for member selection, we define for</p><formula xml:id="formula_12">G = (O × t 1 t 2 ) : G(this) = O G(x) = t 1 G(ret) = t 2 and for G = µ α.R, we define G(z) = (R[α/G])(z) where z ∈ {x, this, ret}.</formula><p>Rule (methCall) checks that the type of the receiver is an object type in which the member m has a definite function type. Moreover, the type of the receiver and actual parameter must be subtypes of the declared type of the receiver and formal parameter.</p><p>In (call) we consider global calls and constructors, and require that the type of the receiver defined in the function has no definite members. This is consistent with the operational semantics, as in the case of global call and object creation we start with an empty receiver object.</p><p>In rule (assignAdd) in Γ we ensure that member m (of this or the formal parameter) is definite. From this point onwards, member m of var may be accessed. For example, consider the expression x.m 2 = x in the environment Γ, where Γ(x) has type t = µ α.[m 1 : (Int, •), m 2 : (α, •)]. The expression is welltyped in Γ and we have P, Γ x.m 2 = x : t Γ where Γ maps this to Γ(this) and x to [m 1 : (Int, •), m 2 : (t, •)]. This reflects the updating of member m 2 . Any aliases to this or the formal parameter will not see the update of a member. This would require dataflow analysis techniques and is beyond the scope of this work. The fact that the type system requires a member to be known (either as potential or definite) for an assignment to succeed is not a limitation. The process of type inference will find all members for a type with their appropriate type and annotation.</p><p>Rule (assignU pd) is used when the assignment is to a definite member m. In this case we just check that the type of the expression on the right hand side is a subtype of the type of the member m.</p><p>A program P is well-formed if all the function declarations in P are well-typed. Figure <ref type="figure">7</ref> gives the definition. In this section we give the relevant definitions and the statement that asserts that our type system is sound w.r.t. to the operational semantics given in Section 2.1. We assume that types are well-formed. We first define the notion of a value being compatible with a given type. The definition is given co-inductively by first defining the properties that any agreement relation between values and well-formed types should have. Definition 1. Given a heap, H, and a program, P, we say that A ⊆ (Val×Type) is an agreement relation if the following conditions are satisfied: Note that an address may be compatible with more than one type. In particular, a value compatible with a type is compatible with all its supertypes. Lemma 1. If t ≤ t and P, H v t then P, H v t .</p><formula xml:id="formula_13">P, Γ e2 : t Γ Γ (var) = O O(m) = (t , ψ) t ≤ t Γ = Γ [var → O[m → (t , •)]] (assignAdd) P, Γ var.m = e2 : t Γ P, Γ e1 : O Γ P, Γ e2 : t Γ O(m) = (t , •) t ≤ t (assignU pd) P, Γ e1.m = e2 : t Γ Well -formed Programs ∀ f : P(f) = function f(x) : G {e} ∧ G =⇒ P, { this : G(this), x : G(x) } e : t Γ ∧ t ≤ G(ret) P</formula><formula xml:id="formula_14">-if (null, t) ∈ A, then t = O for some well-formed O, -if (n, t) ∈ A, then t = Int, -if (f, t) ∈ A, then P(f) = function f(x) : G and G ≡ t, -if (ι, t) ∈ A, then t = O for some well-formed O, H(ι) = &lt; &lt;m 1 : v 1 . . . m p : v p &gt; &gt;, and • O(m) = (t , •) =⇒ m = m i for some i, i ∈ 1...p, and (v i , t ) ∈ A • O(m) = (t , •) and m = m i for some i, i ∈ 1...p, =⇒ (v i , t ) ∈ A If A</formula><p>In the following we define when a stack χ and a heap H are compatible with an environment Γ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. P, Γ</head><p>H, χ holds if P, H χ(this) Γ(this) and P, H χ(x) Γ(x).</p><p>We can now state the Soundness Theorem. The theorem asserts that if an expression is well-typed, P, Γ e : t Γ then the evaluation of the expression starting in a heap and stack that are compatible with Γ will not get stuck. That is, the result of the evaluation is either a value compatible with type t, or it is a nullPntrExc exception. In particular, it is not a stuckErr error. Moreover, the stack and heap produced are compatible with the final environment Γ . We show how type inference for JS 0 can be expressed as a finite system of constraints between type variables. Type variables are used to represent the type of an expression. From a JS 0 program, we can generate a set of type variables with constraints between them. Constraints represent the relationships we expect between types in the program. For example, that the actual parameter to a function call should be a subtype of the formal parameter.</p><p>If the constraints have a solution we say that they are satisfiable. A solution can be used to translate a JS 0 program into an equivalent JS T 0 program. This involves annotating the JS 0 program with type declarations. We show that the annotated program is well-typed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Type Variables</head><p>As in <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b18">18]</ref>, we use type variables to express the -yet unknown -types of expressions. Thus, [[new Date(1000)]] expresses the type of new Date(1000).</p><p>Because the types of this and x differ for different occurrences in the same method body, we use labels to distinguish them, for example, We generate a new label for each method call; this label is used to generate three type variables. These variables denote the type of the receiver, parameter and return type of the method. For example, for x.add(y) we could use label 5 which would generate [[call this 5]], [[call x 5]], and [[call <ref type="bibr">ret 5]</ref>]. Note that these type variables depend on the label but not on the name of the method. <ref type="foot" target="#foot_5">5</ref>Figure <ref type="figure">8</ref> gives the syntax of labeled expressions.</p><p>Figure <ref type="figure">9</ref> defines type variables. Type variables can be used to describe function types, e.g. (τ × τ τ ), or object types, e.g. [m:(τ ,ψ)] with the obvious meaning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Constraints and Solutions</head><p>A solution, S, is a mapping from type variables to types. For the Date example, let t 2 be µ α.[mSec : (Int, •), add : ((α × α α), •)], S 0 represents part of a solution, as follows: </p><formula xml:id="formula_15">S 0 ([[this Date]]) = [mSec : (Int, •), add : ((t 2 × t 2 t 2 ), •)] S 0 ([[this 1]]) = [mSec : (Int, •), add : ((t 2 × t 2 t 2 ), •)] S 0 ([[ret Date]]) = t 2 S 0 ([[x Date]]) = Int S 0 ([[this Date.mSec]]) = Int S 0 ([[this 5]]) = [mSec : (Int, •)]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 8. Syntax of Labeled Expressions</head><p>Constraints between type variables express the relationship between the types of expressions, i.e. which members a type must have, how the members of two types may differ and whether a type has any definite members. The syntax of constraints is given in Figure <ref type="figure">9</ref>. There are three kinds of constraint: τ ≤ ρ, τ τ , and τ • . We use c to range over constraints and C for a set of constraints. Figure <ref type="figure" target="#fig_9">10</ref>, rule (solSat), defines that S satisfies a set of constraints, S C , if it satisfies each constraint. We now discuss each kind of constraint and how it is satisfied by a solution.</p><p>τ ≤ ρ -requires a type variable to be a subtype of ρ: Thus, τ ≤ Int requires τ to be Int, c.f. rule (solInt); while τ ≤ τ requires τ to be a subtype of τ , c.f. (solSub); while τ ≤ (τ 1 × τ 2 τ m τ -requires τ and τ to have the same members with the same types, but member m can be potential in τ but must be definite in τ , c.f. rule (solM emChange).</p><formula xml:id="formula_16">For example, S 0 [[this 1]] mSec [[this Date]], while S 0 [[this Date]] mSec [[this 1]]. Also S 0 [[this 1]] mSec [[this 5]]. Note, however, that S 0 [[this 1]] ≤ [[this<label>5</label></formula><p>]] -this should clarify the difference between the two kinds of constraint. τ • -requires τ to have no definite members, c.f. rule (solN oDef s). This is needed for constructors and global functions whose receiver must have no definite members. For example, S 0 [[this Date]] • .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Constraint Generation</head><p>Constraint generation for a JS 0 program produces a set of constraints between type variables, and a labeled version of the original expression, e. A Type Variables</p><formula xml:id="formula_17">τ ::= [[e]] Constraints ρ ∈ ConstRhs ::= τ | σ | [m : (τ, ψ)] σ ∈ FuncInt ::= (τ × τ ) τ | Int c ∈ Const ::= τ ≤ ρ | τ m τ | τ • C ∈ P(Const)</formula><p>Fig. <ref type="figure">9</ref>. Syntax of Type Variables and Constraints pre-environment, γ = {this : l, x : l , lab : L}, keeps track of the current labeling of this and x along with the set of labels used so far, stored in the set L. Constraint generation for an expression e in the context of a pre-environment, γ, has the form: where γ reflects the changes to the labeling of this, x and lab while generating constraints. The constraints generated for an expression consist of the union of the constraints for each subexpression augmented by local constraints.</p><formula xml:id="formula_18">γ e : e || γ || C C = {c1...cn} S ci ∀ i ∈ 1...n (solSat) S C S(τ ) ≤ S(τ ) (solSub) S τ ≤ τ S(τ ) ≤ (S(τ1) × S(τ2) S(τ3)) (solSubF unc) S τ ≤ (τ1 × τ2 τ3) S(τ ) = Int (solInt) S τ ≤ Int S(τ )(m) ≤ (S(τ ), ψ) (solM ember) S τ ≤ [m : (τ , ψ)] ∀ m = m : S(τ )(m ) ≡ S(τ )(m ) S(τ )(m) ≤ S(τ )(m) (solM emChange) S τ m τ {m | S(τ )(m) = (t, •)} = ∅ (solN oDef s) S τ •</formula><p>In (var) we generate a labeled expression for this and x by looking in the pre-environment for the current label. No constraints are generated.</p><p>In (f uncId) we require f to have a function type derived from the type of the receiver, parameter and return value of the function. The type variables come from the initial labeled this and x and the labeled return variable ret f. For example, function identifier addFn produces constraint:</p><formula xml:id="formula_19">[[addFn]] ≤ ([[this addFn]] × [[x addFn]] [[ret addFn]])</formula><p>In (assignAdd) we use var for this or x, and we model the change of member m of var to definite. var l and var l represent the type of var before and after the update, where l is fresh. Constraint For member access, (memAcc), and for assignment where the receiver is not this or x, (assignU pd), the receiver must have the definite member. For example, x.mSec, in a γ 1 = {x : 2, ... ...}, generates constraint:</p><formula xml:id="formula_20">[[x 2]] ≤ [mSec : ([[x 2.mSec]], •)]</formula><p>For method call, (methCall), we consider the label characterizing the occurrence of the call. For a call with label l we require the receiver to have a definite member, m, with function type</p><formula xml:id="formula_21">[[call this l]] × [[call x l]] [[call ret l]], as expressed through the con- straint [[e 1 ]] ≤ [m : ([[call this l]] × [[call x l]] [[call ret l]],</formula><p>•)]<ref type="foot" target="#foot_7">7</ref> . This will ensure that a solution to the constraints will give a type to the member, that is the least upper bound of all the receivers, parameters and return types at the call sites. For example, x.add(y) in a pre-environment γ 3 = {x : Main, y : Main, lab : L, ....} where 5 ∈ L, generates constraints:</p><formula xml:id="formula_22">[[x Main]] ≤ [add : ([[x Main.add]], •)], [[x Main.add]] ≤ ([[call this 5]] × [[call x 5]] [[call ret 5]]), [[x Main]] ≤ [[call this 5]], [[y Main]] ≤ [[call x 5]], [[call ret 5]] ≤ [[x Main.add(y Main)]] and the post-environment γ 3 [lab → L ∪ {5}].</formula><p>For programs, (P rog), we collect the constraints generated for each function with a pre-environment mapping this and x to their respective initial versions and lab to the given set of labels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Soundness of the Constraints</head><p>We now show that the constraints are sound with respect to the type system. Given a solution, S, and pre-environment, γ, we can generate an environment, Γ, as follows: Γ gen (γ, S) = {this → S(this γ(this)), x → S(x γ(x))}.</p><p>Theorem 2 guarantees soundness of the constraints at expression level: Given an expression and its constraints, if there is a solution then the type given by the type system is a subtype of that given in the solution. The environments used for type checking are those produced by Γ gen with pre-environments γ and γ . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">From Constraints to Solutions</head><p>We now discuss how constraints can be closed to make explicit a solution and how to check that constraints are well-formed. We show how a well-formed set of constraints can be used to generate a solution.</p><p>Constraint Generation for Expressions</p><formula xml:id="formula_23">(var) γ null : null || γ || ∅ γ n : n || γ || {[[n]] ≤ Int} γ this : this γ(this) || γ || ∅ γ x : x γ(x) || γ || ∅ C = {[[f]] ≤ ([[this f]] × [[x f]]) [[ret f]]} (f uncId) γ f : f || γ || C γ e : e || γ || C γ (var) = l l / ∈ γ (lab) γ = γ [var → l , lab → (γ (lab) ∪ {l }) ] C = {[[var l]] ≤ [m : ([[var l.m]], •)], [[var l ]] ≤ [m : ([[var l .m]], •)], [[var l ]] m [[var l]], [[e]] ≤ [[var l .m]], [[e]] ≤ [[var l .m = e]]} (assignAdd) γ var.m = e : var l .m = e || γ || C ∪ C γ e : e || γ || C C = {[[this f]] • , [[e]] ≤ [[x f]], [[ret f]] ≤ [[new f(e)]]} (new) γ new f(e) : new f(e) || γ || C ∪ C γ e : e || γ || C C = {[[this f]] • , [[e]] ≤ [[x f]], [[ret f]] ≤ [[f(e)]]} (f uncCall) γ f(e) : f(e) || γ || C ∪ C γ e : e || γ || C (memAcc) γ e.m : e.m || γ || C ∪ {[[e]] ≤ [m : ([[e.m]], •)]} γ e1 : e1 || γ || C γ e2 : e2 || γ || C C = {[[e1]] ≤ [m : ([[e1.m]], •)], [[e2]] ≤ [[e1.m]], [[e2]] ≤ [[e1.m = e2]]} (assignU pd) γ e1.m = e2 : e1.m = e2 || γ || C ∪ C ∪ C γ e1 : e1 || γ || C γ e2 : e2 || γ || C l / ∈ γ (lab) C = {[[e1]] ≤ [m : ([[e1.m]], •)], [[e1.m]] ≤ (([[call this l]] × [[call x l]]) [[call ret l]]), [[e1]] ≤ [[call this l]], [[e2]] ≤ [[call x l]], [[call ret l]] ≤ [[e1.m(e2)]]} (methCall) γ e1.m(e2) : e1.m(e2) || γ [lab → (γ (lab) ∪ {l}] || C ∪ C ∪ C γ e1 : e1 || γ || C γ e2 : e2 || γ || C C = {[[e2]] ≤ [[e1; e2]]} (seq) γ e1; e2 : e1; e2 || γ || C ∪ C ∪ C γ e : e || γ || C γ (x) = l C = {[[e]] ≤ [[x l]], [[e]] ≤ [[x l = e]]} (varAss) γ x = e : x l = e || γ || C ∪ C Constraint Generation for Programs P = function f1(x) { e1 } • • • function fn(x) { en } {this → fi, x → fi, lab → γ i-1 (lab)} e i : ei || γ i || Ci 1 ≤ i ≤ n ∧ γ0 = ∅ C = ∪ i ∈ 1..n Ci ∪ {[[ei]] ≤ [[ret fi]]}</formula><p>(P rog) P : C Fig. <ref type="figure" target="#fig_5">11</ref>. Constraint Generation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Constraint Closure</head><p>To simplify the extraction of a solution from a set of constraints we apply constraint closure, which makes the solutions (or lack of) explicit. The closing relation, C -→ C , is defined in Figure <ref type="figure" target="#fig_11">12</ref>  8 .</p><p>In (closeT rans) we add a constraint implied by the transitivity of subtyping.</p><p>In (closeT ransM em) the type variable τ is required to have the same members as τ with the same types definite annotation for m (because of τ m τ ); the type variable τ is required to have member m with type τ and annotation ψ (because of τ ≤ [m : (τ , ψ)]). Therefore, τ is also required to have the member m with type τ and annotation ψ, as expressed by τ ≤ [m : (τ , ψ)].</p><p>In (closeBalance) the type variable τ is required to be a subtype of τ , and τ is required to be a subtype of a σ, i.e. either of Int, or of a function type. Because the subtype relationship for Int and function types is the identity, it follows that τ and σ will have to be "the same", and therefore, it follows that τ will have to be a subtype of σ.</p><p>In (closeBalanceM em) the type variable τ is required to have member m with type τ and annotation ψ. Because τ is required to have the same members as τ with the same types it follows that τ will also have the member m with type τ . The annotation, ψ, depends on whether m = m . If m = m then ψ can be less defined i.e. • otherwise the annotations for m in τ and τ must be the same.</p><p>In (closeCong) the same type variable, τ , is required to contain a member m with type τ and also with type τ . It follows that τ should be "equivalent" with τ . Similarly, in (closeCongF unc) because τ is required to be a subtype of two function types, it follows that the two function types should be "equivalent", which, because of the subtype rules for function types, implies that the receiver, argument and return types should be "equivalent".</p><p>Thus, for [</p><formula xml:id="formula_24">[this 2]] add [[this 1]] and [[this 1]] ≤ [mSec : ([[this 1.mSec]], •)] application of (closeT ransM em) generates [[this 2]] ≤ [mSec : ([[this 1.mSec]], •)], which ensures that [[this 2]] will have member mSec. Also, closing [[this 2]] add [[this 1]] and [[this 2]] ≤ [add : ([[this 2.add]], •)] with (closeBalanceM em) generates [[this 1]] ≤ [add : ([[this 2.add]], •)]. Lastly, [[this 2]] ≤ [add : ([[this 1.add]], •)] and [[this 2]] ≤ [add : ([[this 2.add]], •)], closed with rule (closeCong) generate [[this 1.add]] ≤ [[this 2.add]], and [[this 2.add]] ≤ [[this 1.add]]. Definition 4. C is closed, C cl , if for any C : C -→ C implies that C = C .</formula><p>Lemma 2 states that a set of constraints and its closure have the same set of solutions.</p><formula xml:id="formula_25">Lemma 2. If S C and C -→ C then S C . c1, ..., cn -→ c 1 , ...c m c1, ..., cn ∈ C (closeM any1) C -→ C ∪ {c 1 , ...c m } (closeM any2) C -→ C (closeT rans) τ ≤ τ , τ ≤ ρ -→ τ ≤ ρ (closeT ransM em) τ τ , τ ≤ [m : (τ , ψ)] -→ τ ≤ [m : (τ , ψ)] (closeBalance) τ ≤ τ , τ ≤ σ -→ τ ≤ σ ψ = • (if m = m ) ψ = ψ (otherwise) (closeBalanceM em) τ m τ , τ ≤ [m : (τ , ψ)] -→ τ ≤ [m : (τ , ψ )] (closeCong) τ ≤ [m : (τ , )], τ ≤ [m : (τ , )] -→ τ ≤ τ , τ ≤ τ (closeCongF unc) τ ≤ (τ1 × τ2 τ3), τ ≤ (τ 1 × τ 2 τ 3 ) -→ τ 1 ≤ τ1, τ1 ≤ τ 1 , τ 2 ≤ τ2, τ2 ≤ τ 2 , τ3 ≤ τ 3 , τ 3 ≤ τ3</formula><p>Fig. <ref type="figure" target="#fig_11">12</ref>. Constraint Closure</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Well-formed Constraints</head><p>The well-formedness of constraints, C (shown in Figure <ref type="figure" target="#fig_8">13</ref>), ensures that a set of constraints can be used to create a solution. For a set of constraints, C, to be well-formed they must be closed and all the constraints in C must be well-formed. We define function A(C, τ, m) which determines the annotations that any solution satisfying C should give to m in τ . This is done by looking for constraints detailing members: τ ≤ [m : ( , )]. A member is annotated with • if there are no constraints indicating it should be definite:</p><formula xml:id="formula_26">A(C, τ, m) =    • if τ ≤ [m : ( , •)] ∈ C • if τ ≤ [m : ( , •)] ∈ C and τ ≤ [m : ( , •)] ∈ C Udf otherwise</formula><p>Intuitively, rule (wlf N oDef s) corresponds to the solution satisfaction rule (solN oDef s) in Figure <ref type="figure" target="#fig_9">10</ref>. Where S (τ )(m) is represented by looking for con-straints detailing members, τ ≤ [m : ( , )], with A(C, τ, m) being used to find the appropriate annotation.</p><p>Rules (wlf M ix1), (wlf M ix2) and (wlf M ix3) ensure that the constraints cannot mix object types with function types or integers.</p><formula xml:id="formula_27">C cl C = {c1...cn} C ci ∀ i ∈ 1...n (wlf All) C τ ≤ [m : ( , •)] ∈ C (wlf N oDef s) C τ • τ ≤ ( × ) ∈ C ∧ τ ≤ Int ∈ C (wlf M ix1) C τ ≤ [m : (τ , ψ)] τ ≤ [m : ( , )] ∈ C ∧ τ ≤ Int ∈ C (wlf M ix2) C τ ≤ (τ1 × τ2 τ3) τ ≤ ( × ) ∈ C ∧ τ ≤ [m : ( , )] ∈ C (wlf M ix3) C τ ≤ Int</formula><p>Fig. <ref type="figure" target="#fig_8">13</ref>. Well-formed Constraints</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">From Constraints to Solutions</head><p>We now show how well-formed constraints, C , can be translated into a solution. We first define a type variable function, V, from type variables to variables in the type system, α 1 ...α n ∈ ObjVar. We say that V is well-formed for C, i.e. C V , iff τ ≤ τ , τ ≤ τ ∈ C and V(τ ) = α implies V(τ ) = α.</p><p>The translation relation, C, V, τ tp, V , in Figure <ref type="figure" target="#fig_12">14</ref> translates a type variable, τ , into a type. If a type variable has no constraints indicating whether it should be an object, function or integer type, we default to making it an object type with no members. The extension of V, which is denoted by V τ , is defined as follows (where α is a fresh variable):</p><formula xml:id="formula_28">(V τ )(τ ) =        α if τ ∈ dom(V) and ( τ = τ or ( τ ≤ τ ∈ C and τ ≤ τ ∈ C ) ) V(τ ) if τ ∈ dom(V) Udf otherwise</formula><p>V τ extends V with new type variables thus, keeping track of type variables that have already been translated. Because each step of the translation either extends V or finishes when V(τ ) = α (or tp = Int or tp = µ α.[ ]) termination is guaranteed. Given a well-formed set of constraints and well-formed type variable function we define a generated solution, S C,V , such that S C,V (τ ) = t if and only if C, V, τ t, V . Theorem 4 states that a generated solution from a well-formed set of constraints is well-formed. Recursive Types and Subtyping Our choice of a recursive types was motivated by the need to allow typing of a large number of JavaScript programs, but at the same time make possible the development of a type inference algorithm. Hence, we have not considered more expressive type systems such as <ref type="bibr" target="#b19">[19]</ref>.</p><formula xml:id="formula_29">V(τ ) = α C, V, τ α, V τ ≤ Int ∈ C C, V, τ Int, V τ ≤ [m : ] ∈ C τ ≤ ( × ) ∈ C τ ≤ Int ∈ C V = V τ V (τ ) = α C, V, τ µ α.[ ], V n ≥ 1 V(τ ) = Udf V0 = V τ V0(τ ) = α {m1...mn} = {m | τ ≤ [m : ( , )] ∈ C } τ ≤ [mi : (τi, )] ∈ C (f or i ∈ 1...n) C, Vi-1, τi tp i , Vi ψi = A(C, τ, mi) C, V, τ µ α.[m1 : (tp 1 , ψ1)...mn : (tp n , ψn)], Vn V(τ ) = Udf V0 = V τ V0(τ ) = α τ ≤ (τ1 × τ2 τ3) ∈ C C, Vi-1, τi tp i , Vi (f or i ∈ 1...3) C, V, τ µ α.(tp 1 × tp 2 tp 3 ), V3</formula><p>Type systems for object based languages have been developed mainly in a functional setting, see <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b14">[14]</ref>. In <ref type="bibr" target="#b22">[22]</ref> a type system is defined for the Abadi Cardelli object calculus with concatenation that uses recursive types. The definition of the object types is like ours (without function types) with width subtyping.</p><p>Subtyping for recursive function types (that are a subset of our types) has been considered in <ref type="bibr" target="#b3">[4]</ref> where subtyping is contravariant on the input types and covariant on the return type. In our paper we have adopted congruence for subtyping between function types, because our aim is not to study the interaction between subtyping and recursive type (as in <ref type="bibr" target="#b3">[4]</ref>) but to have a type system allowing type inference.</p><p>An imperative, type safe object oriented language, TOIL, was introduced in <ref type="bibr" target="#b7">[8]</ref>. Even though the language is class based, its type system does not identify types with classes. This makes the definition of types similar to ours. TOIL, however, does not have extensible objects, so there is no need for identifying potential members.</p><p>Dynamic Addition of Members Extensible objects are considered in a functional setting in <ref type="bibr" target="#b13">[13]</ref>. An imperative calculus for extensible objects was proposed by Bono and Fisher, in <ref type="bibr" target="#b6">[7]</ref>. In their type system there are two types for objects: the proto-types that can be extended and the object-types that cannot. The type system tracks potential members. The main difference between our type system and their's is that we use recursive types (instead of row types plus universal and existential quantification). This makes it possible to have a decidable type inference algorithm. Note that, Bono and Fisher's aim was to encode classes in their object calculus, not to obtain a type inference algorithm.</p><p>In <ref type="bibr" target="#b24">[24]</ref> Thiemann gives a type system for a considerable subset of JavaScript. Types are based on discriminative sums with two levels. The outer level determines what kind of base type e.g. number, string, object etc. The inner level determines the features of the type such as the value e.g. the singleton type Number(100). Row types are used to detail the members of an object type. The type system models the automatic conversions that occur in JavaScript through a matching relation. As all conversions are tracked it is possible to flag those which could result in dangerous or unexpected behaviour. Access to a nonexistent member does not result in a type error. There are no recursive types and no type inference algorithm is given but there is an implementation.</p><p>In the context of type assembly language Morrisett et al. in <ref type="bibr" target="#b17">[17]</ref> uses an initialisation flag on the members of type to indicate if they have been assigned to. One could think of the potential and definite annotations of our types as representing the state of initialisation of a member.</p><p>Alias types are used in <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b8">[9]</ref> to track the evolution of objects. In particular, in <ref type="bibr" target="#b8">[9]</ref> potential members are used for the same purpose as the current paper. Alias types are, however, very different from the types used in this paper. They are singleton types identified with the address of objects.</p><p>Type Inference In <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b21">21]</ref>   <ref type="bibr" target="#b2">[3]</ref> this work is applied to the object based language SELF <ref type="bibr" target="#b12">[12]</ref>. Each occurrence of an object is given a unique token ω. Thus, object structure is derived from the program. Our work differs in that we must infer the structure of objects. With StarKiller <ref type="bibr" target="#b23">[23]</ref> Salib uses the Cartesian Product Algorithm <ref type="bibr" target="#b1">[2]</ref> to infer types for Python programs in order to improve compiled code. Object types maintain a reference to their definition when a member is added or updated new object types are generated and propagated through the system.</p><p>In <ref type="bibr" target="#b20">[20]</ref> Palsberg considers type inference for the first order type system (with recursive types and subtyping) for the Abadi Cardelli object calculus <ref type="bibr" target="#b0">[1]</ref>. The system of constraints is a subset of those used in this paper, with two kinds τ ≤ τ and τ ≤ [m : (τ, ψ)]. Furthermore, the Abadi Cardelli calculus does not allow member addition like JS 0 . The type system uses a subsumption rule which is encoded in the system by having two type variables for each program point, one before subtyping and one after. For variables there is x and [[x]] and member access, [[e.m]] and &lt; e.m &gt;. Instead of a subsumption rule, our type system uses the subtype relation where necessary e.g. the actual parameter being a subtype of the formal parameter. Hence, the subtype relation is always used explicitly between the types of expressions in the program. Therefore, we don't need to use two type variables to model the application of subsumption. After the constraints are generated a graph is generated and closed. A well-formedness criteria is given to graphs which are then converted to an automata which is used to annotate the program. Our work differs in that we specify closure and wellformedness in terms of constraints rather than convert to a graph.</p><p>In <ref type="bibr" target="#b9">[10]</ref> Eifrig et al. consider type inference for the class-based language I-LOOP. The types are recursively constrained in that a type is supplemented with a set of constraints, τ \C. They take a different approach to us by defining type rules that generate constraints and then modifying the rules to make a deterministic and complete inference system. Fields and methods of a type are detailed with constraints of the form τ ≤ Inst m : τ , which states that τ has a field m of type τ .</p><p>In <ref type="bibr" target="#b25">[25]</ref>, Wang et al. give a type inference system for Java that can statically verify the correctness of downcast. The types used are based on those used in <ref type="bibr" target="#b9">[10]</ref> as described above. There are types that describe the structure of ob-jects, obj (δ, [l i : τ i ]) where δ and l i are abstract labels for the class name and fields/methods respectively. The structure of the object types is derived from the class structure. Unlike our treatment of method call sites, where we always allocate new type variables, they delegates this to closure. By parameterizing closure with a mapping it is possible to share type variables between different invocations of a method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions and Further Work</head><p>In this paper a flexible type system for an idealized version of JavaScript is presented, its soundness is outlined, and a type inference algorithm for this type system is defined. The type inference algorithm is sound with respect to the type system. We show how well-formed constraints can be used to generate a solution and annotate an untyped JS 0 program. The main challenges for both the type system and the inference are the imperative nature of the language combined with the possibility of extending objects.</p><p>For future work we want to study the completeness of the type inference algorithm, its complexity, and extend the type system to allow more typeable expressions, e.g., allowing a more flexible subtyping for functions. To show completeness we need principality of the type produced, this is quite difficult to achieve for recursive type systems. We would also like to develop a mixed mode system where some of the type annotations are already given by the user. For example, we could provide a typing of the Document Object Model <ref type="bibr" target="#b10">[11]</ref> and check code in web pages against it.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Untyped JS 0 Date Example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Syntax of JS 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Syntax of JS T 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Typed JS 0 Date Example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 . 4 Formal</head><label>74</label><figDesc>Fig. 7. Type Rules for Expressions in JS T 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Theorem 1 .</head><label>1</label><figDesc>[T ype Soundness] For a well-formed program P, environment Γ, and expression e, such that: P, Γ e : t Γ If P, Γ H, χ and e, H, χ w, H , χ , then either w = nullPntrExc, or w = v, P, H v t, and P, Γ H , χ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>[[this 1]], [[x 2]], [[this 3]], etc.. Labeled type variables 4 [[this f]] and [[x f]] represent the type of this and x at the beginning of the function f, and [[ret f]] represents the return type of the function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>e ∈ LabExp ::= var | f | new f(e) | e; e | e.m(e) | e.m | f(e) | lhs = e | null | n | ie var ∈ LabEnvVars ::= this l | x l lhs ∈ LeftSide ::= x l | e.m ie ∈ InferExp ::= ret f | call this l | call x l | call ret l l ∈ Lab ::= 1 | 2 | ... | f | f | ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>τ 3 )</head><label>3</label><figDesc>requires τ to be the function type composed from τ 1 , τ 2 and τ 3 , c.f. (solSubF unc); finally, τ ≤ [m : (τ , ψ)] requires τ to have a member m of type τ with annotation at least ψ, c.f. (solM emChange). Thus, S 0 [[this 1]] ≤ [[this Date]], and S 0 [[this 1]] ≤ [[this 5]], S 0 [[this Date]] ≤ [mSec : ([[this Date.mSec]], •)], but S 0 [[this Date]] ≤ [mSec : ([[this Date.mSec]], •)].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Solution Satisfaction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>[[var l]] ≤ [m : ([[var l.m]], •)] requires var to have member m with annotation at least • before the update, while [[var l ]] ≤ [m : ([[var l .m]], •)] requires var to have member m with annotation definite after the update 6 . The constraint [[var l ]] m [[var l]] requires that only member m is affected by the assignment. The remaining constraints require that the type of member m, [[var l .m]], and the overall expression have the type of the right hand side of the assignment. For example, this.add = addFn in a pre-environment γ 2 = {this : 1, lab : L, ...} where 2 ∈ L, generates the constraints:[[this 1]] ≤ [add : ([[this 1.add]], •)], [[this 2]] ≤ [add : ([[this 2.add]], •)], [[this 2]] add [[this 1]], [[addFn]] ≤ [[this 2.add]], [[addFn]] ≤ [[this 2.add = addFn]] and the post-environment γ 2 [this → 2, lab → L ∪ {2}]. In (new) a function is used to create an object. The constraint [[this f]] • requires the initial this for f to have no definite members. The constraint [[e]] ≤ [[x f]] requires the actual parameter to have a subtype of the formal parameter, where x f is the type of the formal parameter at the beginning of the function body. The constraint [[ret f]] ≤ [[new f(e)]] requires the return type of the function to be a subtype of the overall type of the new expression . For example, new Date(1000) generates constraints: [[this Date]] • , [[1000]] ≤ [[x Date]], [[ret Date]] ≤ [[newDate(1000)]] The rule for global function (f uncCall) is similar in structure to that for (new).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Theorem 2 .</head><label>2</label><figDesc>If γ e : e || γ || C and S C and Γ = Γ gen (γ, S) and Γ = Γ gen (γ , S) then P, Γ e : t Γ and t ≤ S([[e]]).Theorem 3 states soundness of the constraints at the program level. Given a program and its constraints, if there is a solution we can use it to generate a well-typed version of the program. Given a JS 0 program and a solution, function T (P, S) generates the corresponding typed JS T 0 program, by using the solution to find the type of the formal parameter, receiver and return type of all the functions and removing the labeling. Theorem 3. If P : C and S C then T (P, S)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Generating the Solution</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Theorem 4 .</head><label>4</label><figDesc>If C then S C,∅ C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Palsberg et al. develop a type inference algorithm for a class based language based on flow analysis. The set of types is the class names defined in the program. Each expression, e, is given a type variable, [[e]], that expresses the -yet unknown -type. They employed a novel approach to model late binding through conditional constraints. A conditional constraint has the form t ∈ [[e]] =⇒ C saying that constraints C are only applicable when t is a possible type for [[e]]. In</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For more information on the Date object see<ref type="bibr" target="#b15">[15]</ref>. We give a simplified version and allow the adding of one date to another, with add.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For some interesting insights into issues surrounding JavaScript's treatment of undefined members see<ref type="bibr" target="#b24">[24]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>For clearness of presentation we omit P from the reduction rules.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>P(f) = function f(x) : G... (func) P, Γ f : G Γ (const) P, Γ null : O Γ P, Γ n : Int Γ P, Γ e 1 : t Γ P, Γ e 2 : t Γ (seq) P, Γ e 1 ; e 2 : t Γ P, Γ e : O Γ O(m) = (t , •) (memAcc) P, Γ e.m : t Γ P, Γ e : t Γ t ≤ Γ (x) (varAss) P, Γ x = e : t Γ P, Γ e1 : OΓ O(m) = (G, •) P, Γ e2 : t Γ t ≤ G(x) O ≤ G(this) (methCall) P, Γ e1.m(e2) : G(ret) Γ P, Γ e : t Γ P(f) = function f(x) : G... t ≤ G(x) {t | (G(this))(m) = (t , •)} = ∅(call) P, Γ new f(e) : G(ret) Γ P, Γ f(e) : G(ret) Γ</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>In [3] Agesen et al. use a similar labeling, [[e]]τ , to indicate who the sender, τ , of a method call is.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>It is possible to optimize the creation of new variables at the call site, for example by sharing some of them. Refer to Section 7 where we discuss<ref type="bibr" target="#b25">[25]</ref> which shows possible optimizations.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Using [[var l]] ≤ [m : ([[e]], )] instead of [[var l]] ≤ [m : ([[var l.m]],))] would have been too restrictive. Namely, a solution would require the type of m to be the same as the type of [[e]] rather than a supertype.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_7"><p>Constraint [[e1]] ≤ [m :([[e1]] × [[e2]] [[e1.m(e2)]],•)] would have been too restrictive. Namely, it would require all the receivers of the method to have the same type.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Acknowledgements</head><p>We would like to thank Mario Coppo, Mariangiola Dezani, Matthew Smith and Alex Buckley for their help and insight and our colleagues at Imperial College Department of Computing and Dipartimento di Informatica of Torino University. We would also like to thank the anonymous ECOOP reviewers.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Work partly supported by EU within the FET -Global Computing initiative, project DART IST-2001-33477,MURST Cofin'02 project McTati, and MIUR Prin'04 project EOS</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A Theory of Objects</title>
		<author>
			<persName><forename type="first">Martín</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymorphism</title>
		<author>
			<persName><forename type="first">Ole</forename><surname>Agesen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="2" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Type inference of SELF: Analysis of objects with dynamic and multiple inheritance</title>
		<author>
			<persName><forename type="first">Ole</forename><surname>Agesen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Palsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">I</forename><surname>Schwartzbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw., Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="975" to="995" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Subtyping recursive types</title>
		<author>
			<persName><forename type="first">Roberto</forename><forename type="middle">M</forename><surname>Amadio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="575" to="631" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Can addresses be types? (a case study: objects with delegation)</title>
		<author>
			<persName><forename type="first">C</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Barbanera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ENTCS</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<date type="published" when="2003">2003</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
	<note>In WOOD &apos;03</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Type checking for javascript</title>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paola</forename><surname>Giannini</surname></persName>
		</author>
		<ptr target="http://www.binarylord.com/work/js0wood.pdf" />
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
	<note>In WOOD &apos;04, volume WOOD of ENTCS</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An Imperative, First-Order Calculus with Object Extension</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fisher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A preliminary version already appeared in Proc. of 5th Annual FOOL Workshop</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1445</biblScope>
			<biblScope unit="page" from="462" to="497" />
		</imprint>
	</monogr>
	<note>Proc. of ECOOP&apos;98</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Polytoil: A type safe polymorphic objectoriented language</title>
		<author>
			<persName><forename type="first">Kim</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schuett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Gent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Object-Oriented Programming (ECOOP)</title>
		<meeting>the European Conference on Object-Oriented Programming (ECOOP)</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Alias types for environment aware computations</title>
		<author>
			<persName><forename type="first">F</forename><surname>Damiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Giannini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ENTCS</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<date type="published" when="2003">2003</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
	<note>In WOOD &apos;03</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Sound polymorphic type inference for objects</title>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Eifrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valery</forename><surname>Trifonov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)&apos;95</title>
		<meeting>Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)&apos;95<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="169" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hors</forename></persName>
		</author>
		<title level="m">Document Object Model (DOM) Level</title>
		<imprint>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">Core Specification</orgName>
		</author>
		<ptr target="http://www.w3.org/TR/2003/CR-DOM-Level-3-Core-20031107" />
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">The SELF 4.0 Programmer&apos;s Reference Manual</title>
		<author>
			<persName><forename type="first">Ole</forename><surname>Agesen</surname></persName>
		</author>
		<ptr target="http://research.sun.com/self/" />
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Type Systems for Object-Oriented Programming Languages. PhD thesis</title>
		<author>
			<persName><forename type="first">K</forename><surname>Fisher</surname></persName>
		</author>
		<idno>number STAN-CS-TR-98-1602</idno>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University ; Available as Stanford Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Lambda Calculus of Objects and Method Specialization</title>
		<author>
			<persName><forename type="first">K</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Honsell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symp. LICS&apos;93</title>
		<meeting>of IEEE Symp. LICS&apos;93</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="3" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">JavaScript -The Definitive Guide</title>
		<author>
			<persName><forename type="first">David</forename><surname>Flanagan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<pubPlace>O&apos;Reilly</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title/>
		<ptr target="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" />
	</analytic>
	<monogr>
		<title level="j">ECMAScript Language Specification. ECMA International. ECMA</title>
		<imprint>
			<biblScope unit="volume">262</biblScope>
			<date type="published" when="1999-12">december 1999</date>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">From system f to typed assembly language</title>
		<author>
			<persName><forename type="first">Greg</forename><surname>Morrisett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karl</forename><surname>Crary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neal</forename><surname>Glew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="527" to="568" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Making type inference practical</title>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Oxhoj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Palsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">I</forename><surname>Schwartzbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="329" to="349" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">F-bounded polymorphism for object-oriented programming</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Olthoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Canning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. on Functional Programming Languages and Computer Architecture</title>
		<meeting>Conf. on Functional Programming Languages and Computer Architecture</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="273" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient inference of object types</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Palsberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">123</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="198" to="209" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Object-oriented type inference</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Palsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">I</forename><surname>Schwartzbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)</title>
		<editor>
			<persName><forename type="first">Norman</forename><surname>Meyrowitz</surname></persName>
		</editor>
		<meeting>the Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">26</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Type inference for record concatenation and subtyping</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Palsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tian</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">189</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="54" to="86" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">Mike</forename><surname>Salib</surname></persName>
		</author>
		<ptr target="http://www.python.org/pycon/dc2004/papers/1/paper.pdf" />
		<title level="m">Static Type Inference (for Python) with Starkiller</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Towards a type system for analyzing javascript programs</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Thiemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="408" to="422" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Precise constraint-based type inference for java</title>
		<author>
			<persName><forename type="first">Tiejun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP &apos;01: Proceedings of the 15th European Conference on Object-Oriented Programming</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="99" to="117" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
