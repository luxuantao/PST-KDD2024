<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Falsification of LTL safety properties in hybrid systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012-05-23">23 May 2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Erion</forename><surname>Plaku</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Lydia</forename><forename type="middle">E</forename><surname>Kavraki</surname></persName>
							<email>kavraki@rice.edu</email>
						</author>
						<author>
							<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Rice University</orgName>
								<address>
									<postCode>77005</postCode>
									<settlement>Houston</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">Catholic University of America</orgName>
								<address>
									<postCode>20064</postCode>
									<settlement>Washington</settlement>
									<region>DC</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Falsification of LTL safety properties in hybrid systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2012-05-23">23 May 2012</date>
						</imprint>
					</monogr>
					<idno type="MD5">1E19C8E175741770886EF74EB07758FA</idno>
					<idno type="DOI">10.1007/s10009-012-0233-2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Hybrid systems</term>
					<term>Linear-temporal logic</term>
					<term>Safety properties</term>
					<term>Motion planning</term>
					<term>Model checking</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper develops a novel approach for the falsification of safety properties given by a syntactically safe linear temporal logic (LTL) formula φ for hybrid systems with nonlinear dynamics and input controls. When the hybrid system is unsafe, the approach computes a trajectory that indicates violation of φ. The approach is based on an effective combination of model checking and motion planning. Model checking searches on-the-fly the automaton of ¬φ and an abstraction of the hybrid system for a sequence σ of propositional assignments that violates φ. Motion planning incrementally extends trajectories that satisfy more and more of the propositional assignments in σ . Model checking and motion planning regularly exchange information to find increasingly useful sequences σ for extending the current trajectories. Experiments that test LTL safety properties on a robot navigation benchmark modeled as a hybrid system with nonlinear dynamics and input controls demonstrate the computational efficiency of the approach. Experiments also indicate significant speedup when using minimized DFA instead of non-minimized NFA for representing ¬φ.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Hybrid systems, which combine discrete logic and continuous dynamics, provide sophisticated mathematical models used in robotics, highway systems, air-traffic management, computational biology, and other areas <ref type="bibr" target="#b0">[1]</ref>. An important problem in hybrid systems is the verification of safety properties <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>, which assert that nothing "bad" happens, e.g., "the car avoids obstacles." A hybrid system is safe if there are no witness trajectories indicating a safety violation. Safety properties have been generally specified as a set of unsafe states and verification has been formulated as reachability analysis <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref>. Many verification methods perform reachability analysis by approximating reachable states <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5]</ref> or use abstractions to obtain finite-state models <ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref>. Reachability analysis in hybrid systems is generally undecidable <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b8">9]</ref>. Moreover, verification methods have an exponential dependency on the dimension of the state space and are limited in practicality to low-dimensional systems <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b4">5]</ref>.</p><p>To handle more complex hybrid systems, alternative methods <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref> have been proposed that shift from verification to falsification, which is often the focus of model checking in industrial applications <ref type="bibr" target="#b16">[17]</ref>. Even though these falsification methods <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref> cannot determine that a hybrid system is safe, they can compute witness trajectories when the hybrid system is unsafe (see also <ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref> for work that focuses on resolution completeness). Witness trajectories, similar to error traces in model checking <ref type="bibr" target="#b16">[17]</ref>, indicate flaws, which can then be corrected. The falsification methods in <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref> adapt the Rapidly exploring Random Tree (RRT) motion planner <ref type="bibr" target="#b20">[21]</ref>, which was originally developed for continuous systems. We recently proposed the Hybrid Discrete Continuous Exploration (HyDICE) falsification method <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>, which also takes advantage of motion planning, but shows significant speedup over RRT-based falsification <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>.</p><p>As more complex hybrid systems are considered, limiting safety properties to a set of unsafe states <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20]</ref>, as it was also the case in our previous work <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>, makes it difficult to adequately express the desired safe behavior of the system. To allow for more sophisticated properties, researchers have advocated the use of linear temporal logic (LTL), which makes it possible to express safety properties with respect to time, such as "once the concentration level of gene A reaches x, then the concentration level of gene B will never reach y" or "the robotic car, after inspecting a contaminated area A should immediately go to the decontamination station B and then eventually go to one of the base stations C or D." Using the temporal connectives G (globally), U (until), X (next), F (eventually), the safety property in the gene regulatory example is G(¬π A ∨ G(¬π B )), where proposition π A (π B ) is true iff the concentration level of gene A (resp., B) is at least x (resp., y). For the robotic car, the safety property is G(π A → (X (π B ) ∧ F(π C ∨ π D ))), where π i , i = A, B, C, D, is true iff the car enters i.</p><p>Linear temporal logic has been widely used in model checking of discrete systems in software and hardware <ref type="bibr" target="#b21">[22]</ref>, and timed systems <ref type="bibr" target="#b22">[23]</ref>. LTL has more recently been used in robotics applications. The work in <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25]</ref> generated trajectories that satisfy LTL constraints on the sequence of triangles visited by a point robot with Newtonian dynamics using a controller that could drive the robot between adjacent triangles. The work in <ref type="bibr" target="#b25">[26]</ref> developed an approach for designing controllers for linear systems that satisfy LTL specifications. Other work automatically synthesizes controllers from LTL specifications of tasks that the robot needs to accomplish <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b27">28]</ref>. LTL in conjunction with hierarchical abstractions has also been used to control robotic swarms <ref type="bibr" target="#b28">[29]</ref> and in computational biology to analyze gene networks <ref type="bibr" target="#b29">[30]</ref>. The work in <ref type="bibr" target="#b30">[31]</ref> developed a method to verify LTL safety properties for robust discrete-time hybrid systems.</p><p>Traditional approaches for the verification of LTL safety properties on hybrid systems often cast the problem as reachability analysis via model checking. The idea is to construct an abstraction M of the hybrid system H so that checking safety properties expressed by an LTL formula φ on H can be accomplished by checking φ on M <ref type="bibr" target="#b5">[6]</ref>. Moreover, since safety properties have finite counterexamples, an NFA A can be constructed to represent ¬φ, where the size of A is at most exponential compared to the size of φ <ref type="bibr" target="#b31">[32]</ref>. This allows for checking φ on H via model checking on M × A. The computation of a suitable abstraction M is a non-trivial issue <ref type="bibr" target="#b5">[6]</ref>.</p><p>Alternative approaches based on motion planning <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref> focus on hybrid-system falsification, but are limited to safety properties given as a set of unsafe states. Applying these alternative approaches to falsify LTL safety properties is challenging due to intricacies of motion planning. During the search, motion planning extends a tree T in the state space of the hybrid system H by adding valid trajectories as new branches. Consider the trajectory ζ from the root of T to a vertex v. In reachability analysis <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref>, a witness trajectory is found when the state associated with v is unsafe. This is not sufficient when considering a safety property given by an LTL formula φ, since ζ needs to satisfy ¬φ. It then becomes necessary to maintain the propositional assignments satisfied by ζ and to effectively extend T so that more and more of the propositional assignments of ¬φ are satisfied.</p><p>To handle LTL safety properties, one can consider a straightforward extension of the work in <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref> to use A as an external monitor to keep track of the automaton states associated with each tree trajectory and to determine from this information when a tree trajectory satisfies ¬φ. As shown in this work, however, such an approach is computationally inefficient.</p><p>The main contribution of this paper is to effectively incorporate LTL safety properties into hybrid-system falsification by combining model checking with motion planning. This extends our previous work <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> which limited safety properties to a set of unsafe states. The proposed approach, Temporal Hybrid Discrete and Continuous Exploration (TemporalHyDICE), can be used to compute witness trajectories that indicate violation of safety properties specified via syntactically safe LTL formulas. The reason for using syntactically safe LTL is that determining whether an LTL formula is safe is PSPACE-complete <ref type="bibr" target="#b32">[33]</ref>. The work in <ref type="bibr" target="#b32">[33]</ref> also provides sufficient syntactic requirements for safe LTL formulas. In particular, it shows that an LTL formula that uses only the temporal connectives X (next), R (release) and G (globally) when put in positive-normal form (by pushing negations all the way to leaves) is safe. Such formulas, when negated, can be translated to NFAs.</p><p>TemporalHyDICE allows for hybrid systems with nonlinear continuous dynamics and input controls. In fact, TemporalHyDICE only requires the availability of a simulator, which, when given a state s, an input control u, and a time step t, computes the new state that results from following the dynamics and the discrete transitions of H. Furthermore, TemporalHyDICE does not require explicit representations of invariants, guards, and propositions. These are treated as black-box functions used to answer membership queries. However, TemporalHyDICE needs an input abstraction M of the hybrid system H.</p><p>In its core, TemporalHyDICE draws from research in traditional and alternative approaches in hybrid systems to combine model checking and motion planning. This presents significant challenges, as it requires dealing with state-space search, memory usage, scalability, and passing of information between model checking and motion planning. In TemporalHyDICE, model checking guides motion planning by providing discrete witnesses along which to extend T . A discrete witness is a sequence [τ i ] n-1 i=0 of propositional assignments that violates φ, which is computed by searching on-the-fly the abstraction M and the automaton A. Motion planning extends T as guided by the discrete witness</p><formula xml:id="formula_0">[τ i ] n-1 i=0</formula><p>so that more and more of τ 0 , . . . , τ n-1 are satisfied in succession. As motion planning extends T , it also gathers information to estimate the progress made in the search for a witness trajectory. This information is fed back to model checking to select in future iterations alternative discrete witnesses that could expand the search along new directions. This interplay between model checking and motion planning is a crucial component that allows TemporalHyDICE to effectively search for a witness trajectory.</p><p>TemporalHyDICE is tested on a hybrid system which models a vehicle driving over different terrains, similar to the navigation benchmark proposed in <ref type="bibr" target="#b33">[34]</ref> and used in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>. The vehicle dynamics vary from one terrain to another and are selected from second-order models of cars, differential drives, and unicycles. Each terrain is subdivided into a uniform grid and some grid cells are labeled as guards, jumps, or propositions. Guards provide conditions that can trigger discrete transitions that enable the vehicle to move from one terrain to another. Syntactically safe LTL formulas are provided over the propositions. Experiments demonstrate the computational efficiency of TemporalHyDICE and show the importance of combining model checking and motion planning. Experiments also indicate significant speedup when using minimized DFA instead of non-minimized NFA for representing ¬φ. This agrees with the work in <ref type="bibr" target="#b34">[35]</ref>, which shows significant speedup when using DFAs instead of NFAs in model checking.</p><p>The paper is organized as follows. Section 2 provides the mathematical framework. Section 3 describes a straightforward approach of incorporating LTL into related work <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref> using A as an external monitor. Section 4 describes TemporalHyDICE, which effectively incorporates LTL. Section 5 describes the experiments. A discussion concludes the paper in Sect. 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Mathematical framework</head><p>This section defines hybrid automata, LTL syntax and semantics, the automaton for ¬φ, LTL over hybrid-system trajectories, and the problem statement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Hybrid systems</head><p>Hybrid systems are modeled by hybrid automata <ref type="bibr" target="#b1">[2]</ref>. This paper extends the definition of hybrid automata to allow for hybrid systems with nonlinear dynamics and input controls, and for invariants, guards, and jumps to be specified as blackbox functions.</p><p>Definition 1 (Hybrid automaton) A hybrid automaton is a tuple H = (S, INVARIANT, E, GUARD, JUMP, U, f ), where -S = Q × X is the Cartesian product of the discrete and continuous state spaces; -Q is a finite set; -X maps q ∈ Q to X q , where X q is the continuous state space associated with q; -INVARIANT maps q ∈ Q to INVARIANT q , where INVARIANT q : X q → {true, false} represents constraints that any x ∈ X q should satisfy; -E ⊆ Q × Q is the set of discrete transitions; -GUARD maps (q i , q j ) ∈ E to GUARD (q i ,q j ) , where GUARD (q i ,q j ) : X q i → {true, false} is the guard function associated with (q i , q j ); -JUMP maps (q i , q j ) ∈ E to JUMP (q i ,q j ) , where JUMP (q i ,q j ) : X q i → X q j is the jump function associated with (q i , q j ); -U maps q ∈ Q to U q , where U q ⊆ R dim(U q ) is the set of input controls associated with q; -f maps q ∈ Q to f q , where f q : X q × U q → Ẋq is a set of differential equations that describes the continuous dynamics associated with q.</p><p>The state of the hybrid automaton is a tuple (q, x) ∈ S, which describes both the discrete and the continuous components. While in mode q, when applying an input control function ũ : [0, T ] → U q for T ≥ 0 time units, the continuous state changes according to the dynamics expressed by f q , as shown in the following definition: Definition 2 (Continuous trajectory) A state s = (q, x) ∈ S, a time duration T ≥ 0, and an input control function ũ : [0, T ] → U q define a continuous trajectory χ s, ũ,T : [0, T ] → X q , such that for all t ∈ [0, T ]:</p><formula xml:id="formula_1">χ s, ũ,T (t) = x + t h=0 f q (χ s, ũ,T (h), ũ(h)) dh</formula><p>In this paper, each X q includes derivatives of different orders, e.g., velocity and acceleration, and, hence, f q is nonlinear. Numerical integration is used to integrate f q since closed-form solutions are generally not available.</p><p>A discrete transition occurs at (q, x) ∈ S when a guard is satisfied, i.e., GUARD (q,q j ) (x) = true for some (q, q j ) ∈ E. In this paper, the discrete transitions are urgent. As a result, the state of the hybrid system is instantaneously changed to (q j , x j ), where x j = JUMP (q,q j ) (x). There is, however, no inherent limitation in dealing with non-urgent discrete transitions. In such cases, the discrete transition can be applied only if the invariant is invalid or when some other user-defined condition is satisfied. The augmentation of a continuous trajectory with a discrete transition is defined as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Continuous trajectory + Discrete transition)</head><p>Given a continuous trajectory χ s, ũ,T : [0, T ] → X q , the trajectory Υ s, ũ,T : [0, T ] → S follows a discrete transition at time T if it occurs, i.e.,</p><formula xml:id="formula_2">Υ s, ũ,T (t) = ⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩ (q, χ s, ũ,T (t)),</formula><p>t ∈ [0, T ) and no guard is satisfied, (q, x T ), t = T and no guard is satisfied, (q j , JUMP (q,q j ) (x T )), t = T and GUARD (q,q j ) (x T ) = true for some (q, q j ) ∈ E, where x T = χ s, ũ,T (T ).</p><p>In Definition 3, when a state satisfies more than one guard, a user-defined procedure can be used to determine which jump to apply.</p><p>A trajectory Ψ can be extended by applying an input control function ũ to the last state of Ψ . More precisely, trajectory extension is defined as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Trajectory Extension)</head><p>The extension of a trajectory Ψ : [0, T ] → S by applying to Ψ (T ) the input control function ũ : [0, T ] → X q is written as</p><formula xml:id="formula_3">Ψ • ( ũ, T )</formula><p>and is another trajectory Υ : [0, T + T ] → S defined as</p><formula xml:id="formula_4">Υ (t) = Ψ (t), t ∈ [0, T ] Υ Ψ (T ), ũ,T (t -T ), t ∈ (T, T + T ].</formula><p>A hybrid-system trajectory consists of continuous trajectories interleaved with discrete transitions, as indicated by the following definition. Definition 5 (Hybrid-system trajectory) A state s ∈ S and a sequence of input control functions ũ1 : [0, T 1 ] → U q 1 , . . . , ũn : [0, T n ] → U q n define a hybrid-system trajectory</p><formula xml:id="formula_5">ζ : [0, T 1 + • • • + T n ] → S, where ζ = Υ s, ũ1 ,T 1 • ( ũ2 , T 2 ) • • • • • ( ũn , T n ).</formula><p>(Valid Hybrid-System Trajectory) ζ is valid iff it satisfies the invariant, i.e., ∀t ∈ [0, T 1 + • • • + T n ]:</p><formula xml:id="formula_6">INVARIANT q t (x t ) = true, where (q t , x t ) = ζ(t).</formula><p>2.2 Syntax, semantics, and syntactically safe LTL Let Π denote a set of propositions. LTL formulas combine propositions with Boolean connectives ¬, ∧, ∨ and temporal connectives X (next), U (until), R (release), F (future), G (globally), as defined below.</p><p>Definition 6 (LTL Syntax and semantics <ref type="bibr" target="#b31">[32]</ref>) Every π ∈ Π is a formula. If φ and ψ are formulas, then ¬φ, φ ∧ ψ, X φ, φ Uψ are also formulas. Let σ = τ 0 , τ 1 , . . . denote an infinite sequence, where each τ i ∈ 2 Π . Let σ i = τ i , τ i+1 , . . . denote the ith postfix of σ . The notation σ | φ indicates that σ satisfies φ and is defined as</p><formula xml:id="formula_7">σ | π if π ∈ Π and π ∈ τ 0 , σ | ¬φ if σ | φ, σ | φ ∧ ψ if σ | φ and σ | ψ, σ | X φ if σ 1 | φ, σ | φ Uψ if ∃ k ≥ 0 such that σ k | ψ and ∀ 0 ≤ i &lt; k : σ i | φ. Moreover, we use the abbreviations false ≡ π ∧ ¬π , true ≡ ¬false, φ ∨ ψ ≡ ¬(¬φ ∧ ¬ψ), Fφ ≡ true Uφ, Gφ ≡ ¬F¬φ, φ Rψ ≡ ¬(¬φ U¬ψ).</formula><p>Consider a language L ⊆ Σ ω of infinite words over the alphabet Σ. As defined in <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b35">36]</ref>, a finite word α ∈ Σ * is a violating prefix for L if for all β ∈ Σ ω it holds that α •β ∈ L, where α •β denotes the concatenation of α and β. A language L is a safety language iff every w ∈ L has a finite violating prefix <ref type="bibr" target="#b35">[36]</ref>. The language defined by an LTL formula φ, written as L(φ), consists of all infinite words over the alphabet Σ = 2 Π that satisfy φ. Then, φ is a safety formula iff L(φ) is a safety language <ref type="bibr" target="#b31">[32]</ref>.</p><p>The work in <ref type="bibr" target="#b32">[33]</ref>, which shows PSPACE-completeness for determining whether an LTL formula is safe, also provides sufficient syntactic requirements for safe LTL formulas. In particular, an LTL formula that uses only the temporal connectives X , R, and G when put in positive-normal form (by pushing negations all the way to leaves) is safe, as defined below.</p><p>Definition 7 (Positive normal form LTL <ref type="bibr" target="#b32">[33]</ref>) The formulas true, false, π, ¬π for π ∈ Π are in positive normal form. If φ and ψ are in positive normal form, then φ ∨ ψ, φ ∧ ψ, X φ, φ Uψ, φRψ are also in positive normal form. (F and G can be derived from U and R as indicated in Definition 6.) Definition 8 (Syntactically safe LTL <ref type="bibr" target="#b32">[33]</ref>) An LTL formula φ that, when written in positive normal form, uses only the temporals X , R, and G is syntactically safe. Every syntactically safe formula is a safety formula.</p><p>Since the violating prefixes of a safety LTL formula are of finite length, an NFA can be constructed to represent all the violating prefixes, as defined below.</p><p>Definition 9 (NFA for syntactically safe LTL <ref type="bibr" target="#b31">[32]</ref>) For a syntactically safe LTL formula φ, an NFA can be constructed to represent ¬φ with at most an exponential blow-up on the size of the NFA. An NFA is a tuple A = (Z , Σ, δ, z init , Accept), where</p><formula xml:id="formula_8">-Z is a finite set of states; -Σ = 2 Π is the input alphabet; -δ : Z × Σ → 2 Z is the transition function; -z init ∈ Z is the initial state; and -Accept ⊆ Z is the set of accepting states.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The set of states obtained by running</head><formula xml:id="formula_9">A on [τ i ] n i=1 , τ i ∈ 2 Π , is defined as A([τ i ] n i=1 ) = z init , n = 0 z∈A([τ i ] n-1 i=1 ) δ(z, τ n ), n &gt; 1. A accepts [τ i ] n i=1 iff A([τ i ] n i=1 ) ∩ Accept = ∅.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">LTL semantics over hybrid-system trajectories</head><p>The state space of the hybrid system gives meaning to the propositions π ∈ Π . Specifically, the truth value of each π ∈ Π is determined by a black-box function</p><formula xml:id="formula_10">PROP π : S → {true, false}.</formula><p>In this way, a state s ∈ S satisfies π iff PROP π (s) = true.</p><p>Note that s can satisfy more than one proposition. In fact, the map τ : S → 2 Π maps each s ∈ S to the propositions satisfied by s, i.e.,</p><formula xml:id="formula_11">τ (s) = {π : π ∈ Π ∧ PROP π (s) = true}.</formula><p>Moreover, τ makes it possible to contextualize LTL formulas over hybrid-system trajectories. Consider a hybrid-system trajectory ζ : [0, T ] → S. At time t 0 = 0, ζ satisfies the set of propositions τ 0 = τ (ζ(t 0 )). The trajectory ζ will continue to satisfy τ 0 until some later time t 1 , where ζ may satisfy a different set of propositions</p><formula xml:id="formula_12">τ 1 = τ (ζ(t 1 )), τ 0 = τ 1 .</formula><p>In this way, ζ can be broken down into a sequence of propositional assignments</p><formula xml:id="formula_13">[τ i ] n-1 i=0 and a sequence of time inter- vals [t 0 , t 1 ), . . . , [t n-2 , t n-1 ), [t n-1 , T ] such that inside the ith time interval ζ satisfies τ i = τ (ζ(t i )) and that τ i = τ i+1 . As discussed in Sect. 3.1.3, the sequence of propositional assignments [τ i ] n-1</formula><p>i=0 satisfied by ζ is numerically computed based on the forward simulation of the hybrid-system dynamics. The definition of LTL over hybrid-system trajectories follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10 (LTL over hybrid-system trajectories) Let</head><formula xml:id="formula_14">ζ : [0, T ] → S denote a hybrid-system trajectory. Let 0 = t 0 &lt; • • • &lt; t n-1 ≤ T , such that -τ i = τ i+1 , for all 0 ≤ i &lt; n -τ i = τ (ζ(t)) for all 0 ≤ i &lt; n -1 and t ∈ [t i , t i+1 ) -τ n-1 = τ (ζ(t)) for all t ∈ [t n-1 , T ]</formula><p>where</p><formula xml:id="formula_15">τ i = τ (ζ(t i )). Then, τ (ζ ) de f = [τ i ] n-1</formula><p>i=0 denotes the sequence of propositional assignments in the order satisfied by ζ . This mapping of a hybrid-system trajectory to a sequence of propositional assignments allows for the same semantics of LTL as in Definition 6 to carry over to hybridsystem trajectories, e.g., ζ satisfies X φ when τ (ζ ) | X φ. In this way, if φ denotes an LTL formula, then, it is said that</p><formula xml:id="formula_16">ζ satisfies φ iff τ (ζ ) | φ.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Problem statement</head><p>Given P = (H, s init , φ, Π, τ ), where -H is the hybrid automaton, -s init ∈ S is the initial state, -Π is the set of propositions, -φ is the syntactically safe LTL formula over Π , -τ is the propositional map, then compute a sequence of input control functions</p><formula xml:id="formula_17">ũ1 : [0, T 1 ] → U q 1 , . . . , ũn : [0, T n ] → U q n</formula><p>such that the resulting hybrid-system trajectory</p><formula xml:id="formula_18">ζ = Υ s init , ũ1 ,T 1 • ( ũ2 , T 2 ) • • • • • ( ũn , T n )</formula><p>is valid and satisfies ¬φ, i.e.,</p><formula xml:id="formula_19">INVARIANT q t (x t ) = true, for all t ∈ [0, T 1 + • • • + T n ], (q t , x t ) = ζ(t); and τ (ζ ) | ¬φ.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A straightforward approach to incorporate safety LTL into motion planning for hybrid-system falsification</head><p>The tree-search framework in motion planning has been adapted for reachability analysis in hybrid systems to compute valid witness trajectories to unsafe states <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref>.</p><p>There have been, however, no discussions in the literature <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref> on how to augment the tree-search framework so that it can also be used for the falsification of LTL safety properties. This section describes a straightforward extension of the tree-search framework in motion planning in order to handle LTL safety properties. The idea is to use the automaton A, which expresses ¬φ, to keep track of the automaton states associated with each trajectory added to the tree and to determine from this information when a tree trajectory witnesses a violation of φ. In this way, similar to model checking, the tree-search framework searches on-the-fly H and A. With these modifications, the tree-search framework can be used to falsify LTL safety properties in hybrid systems, and, thus, provide a basis for the experimental comparisons.</p><p>As demonstrated by the experiments, such a straightforward approach that uses A simply as an external monitor is, however, computationally inefficient. Sect. 4, which describes TemporalHyDICE, shows how to significantly increase the computational efficiency by effectively combining the LTL tree-search framework in motion planning with model checking.</p><p>3.1 Incorporating safety LTL into the tree-search framework using the safety automaton as an external monitor</p><p>The search for a witness trajectory is conducted by extending a tree in the state space H.S and using A as an external monitor. The tree is maintained as a graph T = (V, E). Each vertex v ∈ T .V is associated with a state s ∈ H.S, written as v.s.</p><p>An edge (v i , v j ) ∈ T .E indicates that a valid hybrid-system trajectory connects v i .s to v j .s. As the search proceeds iteratively, T is extended by adding new vertices and new edges. Consider the hybrid-system trajectory TRAJ(T , v) from the root of T to a vertex v ∈ T .V . Let τ (TRAJ(T , v)) denote the sequence of propositional assignments [τ i ] n-1 i=0 in the order satisfied by TRAJ(T , v), as described in Sect. 2.3. If τ (TRAJ(T , v)) | ¬φ, then TRAJ(T , v) is a witness trajectory, since it indicates a violation of φ. Determining whether TRAJ(T , v) satisfies ¬φ can be accomplished by running A on τ (TRAJ(T , v)). As described in Sect. 2.2, TRAJ(T , v) satisfies ¬φ iff an accepting state is reached when A is run on τ (TRAJ(T , v)), i.e.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>τ (TRAJ(T , v)) | ¬φ ⇐⇒</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A(τ (TRAJ(T , v))) ∩ A.Accept = ∅.</head><p>For this reason, each vertex v ∈ T .V is associated with the automaton states corresponding to TRAJ(T , v), written as v.α and defined as</p><formula xml:id="formula_20">v.α = A(τ (TRAJ(T , v))).</formula><p>Then, TRAJ(T , v) satisfies ¬φ iff v.α ∩ A.Accept = ∅. Note that v.α can be computed incrementally when v is added to its parent v parent in T . In particular, let ζ denote the hybridsystem trajectory from v parent to v; ζ is associated with the edge (v parent , v) ∈ T .E. Then, v.α can be computed by running A on τ (ζ ) but starting from the states v parent .α instead of the initial state of A.</p><p>In this way, when a vertex v is added to T such that TRAJ(T , v) satisfies ¬φ, then a witness trajectory is found. Otherwise, new vertices and new edges will continue to be added to T until an upper bound on the running time is exceeded. Pseudocode for the tree-search framework is given in Algorithm 1 and described below.</p><p>Algorithm 1 LTL-TSF(P, t max ) Incorporating Safety LTL into the Tree-Search Framework by using the Safety Automaton as an External Monitor</p><formula xml:id="formula_21">Input P = (H, s init , φ, , τ): problem specification ♦ 2.4 t max ∈ R &gt;0 :</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>upper bound on computation time</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Output</head><p>A valid hybrid-system trajectory that satisfies ¬φ if one is found or false otherwise 1: A ← construct automaton for ¬φ 2:</p><formula xml:id="formula_22">T ← InitializeTree(P, A) ♦ 3.1.1 3: while ElapsedTime &lt; t max do 4: v ← SelectVertexFromTree(P, T ) ♦ 3.1.2 5: (u, T, s new , α new ) ← ExtendTree(P, A, T , v) ♦ 3.1.3 6: if T &gt; 0 ∧ |α new | &gt; 0 then</formula><p>add a new vertex and edge to T 7:</p><formula xml:id="formula_23">v new ← new vertex; v new .s ← s new ; v new .α ← α new 8: (v, v new ) ← new edge; (v, v new ).{u, T } ← {u, T } 9: T .V ← T .V ∪ {v new }; T .E ← T .E ∪ {(v, v new )} 10: if A.Accept ∩ α new = ∅ then 11:</formula><p>return TRAJ(T , v new ) 12: return false</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Initializing the tree</head><p>InitializeTree(P, A) (Algorithm 1:2) associates the root vertex v init with the initial hybrid-system state, i.e., v init .s = s init , T .V = {v init }, and T .E = ∅. The automaton states associated with v init are computed by running A on the propositions satisfied by v init .s, i.e., v init .α = A.δ(A.z init , τ (v init .s)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Selecting a vertex from which to extend the tree</head><p>SelectVertexFromTree(P, T ) (Algorithm 1:4) selects a vertex v ∈ T .V from which to extend T . Over the years, numerous strategies have been proposed that rely on distance metrics, nearest neighbors, probability distributions, and many other factors, as surveyed in <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref>. As an example, RRT methods <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>, sample a hybrid-system state s ∈ H.S and select the vertex v ∈ T .V whose associated hybrid-system state v.s is the closest to s according to a distance metric. Other selection strategies are discussed in Sect. 3.2 when describing how related work <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref> can use Algorithm 1 to incorporate LTL safety properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Extending the tree by applying input controls and simulating the hybrid system forward in time</head><p>ExtendTree(P, A, T , v) (Algorithm 1:5) extends T from the selected vertex v by computing a valid hybrid-system trajectory ζ : [0, T ] → H.S that starts at v.s. A common strategy is to apply some input control function ũ : [0, T ] → H.U q to v.s, where q is the mode of v.s, and follow the dynamics H. f q until the invariant is no longer satisfied, a guard is satisfied, or a maximum number of steps is exceeded <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b37">38]</ref>. Note that if a guard is satisfied, the corresponding discrete transition is taken immediately and as a result will be part of the computed trajectory ζ , as described in Definition 3, i.e., ζ = Υ v.s, ũ,T .</p><p>ExtendTree(P, A, T , v) returns a tuple (u, T, s new , α new ).</p><p>The control input function ũ : [0, T ] → H.U q is generally defined by selecting pseudo-uniformly at random an input control u ∈ H.U q , i.e.,</p><formula xml:id="formula_24">ũ(t) = u, ∀t ∈ [0, T ].</formula><p>The random selection of input controls allows for subsequent calls to ExtendTree(P, A, T , v) to extend T along new directions. Moreover, it has been shown to work well in motion planning for robotic systems with complex continuous dynamics and reachability analysis in hybrid systems <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b37">38]</ref>. The trajectory ζ computed by ExtendTree is added to T as a new branch at the vertex v (Algorithm 1:7-9). More precisely, the new vertex v new and the edge (v, v new ) are added to the vertices and edges of T , respectively. The new edge (v, v new ) is associated with the input control function ũ and time duration T . The new vertex v new is associated with the state s new , which corresponds to the last state of ζ , i.e., s new = ζ(T ). The automaton states α new are computed by running A on τ (ζ ) but starting from the automaton states v.α instead of the initial state of A. In this way, as discussed in Sect. 3.1, α new corresponds to the automaton states obtained by running A on τ (TRAJ(T , v)•ζ ). If α new includes an accepting state of A, then TRAJ(T , v new ) constitutes a witness trajectory (Algorithm 1:10). TRAJ(T , v new ) is computed by concatenating the trajectories associated with the tree edges connecting the root of T to v new (Algorithm 1:11).</p><p>Note that any hybrid-system simulation method can be used to compute the hybrid-system trajectory ζ by simulating the continuous dynamics and the discrete transitions of the hybrid system when applying an input control function ũ : [0, T ] → H.U q starting from the state v.s. For completeness, we describe below a simple iterative procedure. Pseudocode is given in Algorithm 2.</p><p>Let n steps denote the number of steps and let &gt; 0 denote the step size (Algorithm 2:1). Initially, x 0 = x and α 0 = v.α, where v.s = (q, x) (Algorithm 2:2). At the ith iteration, x i is computed by integrating H. f q from x i-1 for an time step (Algorithm 2:5). If x i does not satisfy the invariant, then ExtendTree stops and returns the tuple [u, (i -1) * , (q, x i-1 ), α i-1 ] (Algorithm 2:6-7). When x i satisfies the invariant, then ExtendTree checks if a guard is satisfied, which would indicate a discrete event (Algorithm 2:8). In the hybrid-system benchmark in this paper, when a guard condition is satisfied, the corresponding jump is always applied. In the case of non-urgent discrete transitions, Algorithm 2 ExtendTree(P, A, T , v) Extend Tree by Applying Input Controls and Simulating the Hybrid System Forward in Time Input P = (H, s init , φ, , τ): problem specification ♦ 2.4 A: automaton for ¬φ T : current search tree v: vertex from which to extend the tree Output (u, T, s new , α new )</p><formula xml:id="formula_25">1: ∈ R &gt;0 ← time step; n steps ∈ N ← number of steps 2: s = (q, x) ← v.s; α ← v.α; x 0 ← x; α 0 ← α; τ 0 ← τ (s) 3: u ← sample control from H.U q</formula><p>simulate the continuous and discrete dynamics of H 4: for i = 1, 2, . . . , n steps do 5:</p><formula xml:id="formula_26">x i ← χ( ), where χ( ) = x i-1 + h=0 f q (χ(h), u) dh 6: if H.INVARIANT q (x i ) = false then 7:</formula><p>return (u, (i -1) * , (q, x i-1 ), α i-1 ) 8: if for some H.GUARD (q,qnew) (x i ) = true and discrete transition should be triggered then 9:</p><p>(x loc , T ) ← localize discrete event in ((i -1) * , i * ] 10:</p><formula xml:id="formula_27">τ loc ← τ ((q, x loc )) 11: if τ i-1 = τ loc then α loc ← α i-1 12: else α loc ← ∪ z∈α i-1 A.δ(z, τ loc ) 13:</formula><p>x new ← H.JUMP (q,qnew) (x loc ) 14:</p><formula xml:id="formula_28">τ new ← τ ((q new , x new )) 15: if τ loc = τ new then α new ← α loc 16: else α new ← ∪ z∈αloc A.δ(z, τ new ) 17:</formula><p>return (u, T, (q new , x new ), α new ) 18: else 19:</p><formula xml:id="formula_29">τ i ← τ ((q, x i )) 20: if τ i-1 = τ i then α i ← α i-1 21: else α i ← ∪ z∈α i-1 A.δ(z, τ i ) 22: return (u, n steps * , (q, x nsteps ), α nsteps )</formula><p>as discussed in Sect. 2.1, a user-defined procedure can determine when to apply the discrete transition. Discrete event detection is followed by event localization, which localizes the earliest time T ∈ ((i -1) * , i * ] where the guard is satisfied (Algorithm 2:9). Bisection or bracketing algorithms are typically used for event localization <ref type="bibr" target="#b38">[39]</ref>. Once the discrete event is localized, the discrete transition is then triggered to obtain the new state (Algorithm 2:13). The automaton states are also updated accordingly and (u, t, (q new , x new ), α new ) is returned (Algorithm 2:14-17). If no guard is satisfied, the automaton states α i associated with (q, x i ) are updated only if τ ((q, x i )) = τ ((q, x i-1 )) (Algorithm 2:19-21).</p><p>Numerical errors in simulation, invariant checking, event localization could in certain cases cause ExtendTree to miss an invariant violation, miss a guard, trigger a different discrete transition, or miss a change in the sequence of propositional assignments satisfied by a hybrid-system trajectory ζ , e.g.,</p><formula xml:id="formula_30">τ (ζ(t)) = τ (ζ(t + )) but τ (ζ(t + a)) = τ (ζ(t))</formula><p>for some 0 &lt; a &lt; . To minimize such errors, a practical approach is to choose a small . This approach is the norm in hybrid-system falsification based on motion planning <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref>. For hybrid systems with guards of the form {x : g(x) ≥ 0} where g(x) is continuously differentiable, it is also to use more accurate event localization algorithms, which come asymptotically close to the guard boundary <ref type="bibr" target="#b38">[39]</ref>. In many practical cases, hybrid systems exhibit a degree of robustness <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b39">40]</ref> that minimizes the impact of numerical errors, e.g., small perturbations do not change the mode-switching behavior. As noted, the simple implementation of ExtendTree presented here for completeness, can be replaced by more sophisticated hybrid-system simulation methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Incorporating safety LTL into related motion-planning approaches for hybrid-system falsification</head><p>Using A as an external monitor, Algorithm 1 provides a straightforward extension of how to incorporate LTL safety properties into the tree-search framework. This makes it possible to adapt related work in hybrid-system falsification <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref> so that it can handle LTL, as described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Incorporating safety LTL into RRT methods</head><p>LTL can be incorporated into RRT-based falsification methods <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref> using LTL-TSF (Algorithm 1) and implementing SelectVertexFromTree(P, T ) as in <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>, e.g., sample s ∈ H.S at random and select v ∈ T .V whose v.s is the closest to s according to a distance metric. This is referred to as RRT[LTL-TSF] in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Incorporating LTL safety properties into HyDICE[NoGuide]</head><p>Similarly to RRT, HyDICE <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> also falls into the broad category of tree-search algorithms. Distinctly from RRT, HyDICE <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> introduced discrete search over (H.Q, H.E) to guide the tree search in the context of reachability analysis to a set of unsafe states. At each iteration, the discrete search computed a sequence of discrete transitions from an initial to an unsafe mode. The tree-search framework then extended T along the direction provided by the discrete search. Experiments showed significant speedup over RRTbased falsification <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>.</p><p>Incorporating LTL into HyDICE is more involved than in the case of RRT, since the discrete search over (H.Q, H.E) does not take LTL into account. When considering LTL, a safety violation is not indicated by an unsafe state, but by a trajectory that satisfies ¬φ. Therefore, when considering LTL, unsafe states and unsafe modes are not defined. This means that the discrete search over (H.Q, H.E) from an initial to an unsafe mode is also not defined. The next section shows how to effectively incorporate LTL into HyDICE.</p><p>The version of HyDICE <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> that does not use the discrete search is referred to as HyDICE <ref type="bibr">[NoGuide]</ref>. Experiments in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> showed that HyDICE <ref type="bibr">[NoGuide]</ref> was significantly slower than HyDICE, but still considerably faster than RRT-based falsification <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>. HyDICE [NoGuide] corresponds to the tree-search framework, where the function SelectVertexFromTree(P, T ) is implemented by selecting v ∈ T .V according to a probability distribution over T .V , i.e., each v ∈ T .V is assigned a weight w(v) based on the number of times v has been selected in the past and the coverage density around v by other vertices in T ; then v is selected with probability proportional to w(v). This makes it possible to incorporate LTL safety properties into HyDICE[NoGuide] using LTL-TSF (Algorithm 1), which is referred to as HyDICE[NoGuide, LTL-TSF] in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">TemporalHyDICE</head><p>This section describes TemporalHyDICE, which constitutes the main contribution of this paper. TemporalHyDICE combines model checking and motion planning to effectively expand T during the search for a witness trajectory. To speed up the search for witness trajectories, TemporalHyDICE also needs as input an abstraction M of the hybrid system H. The construction of M is outside the scope of this paper; this paper focuses on how to effectively combine model checking with motion planning. For the purposes of this work the abstraction M is thought of as a graph D. Generally, a vertex v i ∈ D corresponds to some state-space region whose states satisfy a propositional assignment τ i and an edge (v i , v j ) ∈ D indicates the possibility of constructing a hybrid-system trajectory ζ that remains in the region associated with v i until it reaches the region associated with v j . An example is given in the experiments in Sect. 5. Interestingly, very few requirements are placed on M (and hence D). TemporalHyDICE tries to compensate for any shortcomings by exploiting the synergy of model checking and motion planning as explained in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Combining model checking and motion planning Consider a sequence [τ</head><formula xml:id="formula_31">i ] n-1 i=0 of propositional assignments that satisfies ¬φ. Let Γ (τ i ) = {s ∈ H.S : τ (s) = τ i }.</formula><p>If T can be extended so that a hybrid-system trajectory TRAJ(T , v) starts at Γ (τ 0 ) and reaches Γ (τ 1 ), . . . , Γ (τ n-1 ) in succession, i.e.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>τ (TRAJ(T , v)) = [τ</head><formula xml:id="formula_32">i ] n-1</formula><p>i=0 , then TRAJ(T , v) would be a witness trajectory. In this way, [τ i ] n-1 i=0 provides a sequence Γ (τ 0 ), . . . , Γ (τ n-1 ) of regions along which motion planning can attempt to extend T to compute a witness trajectory.</p><p>TemporalHyDICE relies on model checking to effectively compute sequences of propositional assignments that satisfy ¬φ. Specifically, model checking searches on-thefly A and the graph D to compute a discrete witness, i.e., a sequence</p><formula xml:id="formula_33">[(z i , τ i )] n-1 i=0 where (z i , τ i ) ∈ A.Z × 2 Π , z 0 = A.z init , z n-1 ∈ A.Accept.</formula><p>By not computing D × A explicitly, as described in Sect. 4.2, TemporalHyDICE considerably reduces the memory used by model checking. Note that model checking can provide many alternative discrete witnesses. Due to hybridsystem dynamics, invariants, guards, and jumps, in some cases, it may be easy for motion planning to extend T from some Γ (τ i ) to Γ (τ i+1 ) as indicated in the discrete witness, while in other cases, it may be difficult or even impossible. This raises the issue of which discrete witness to select among the many available alternatives. To address this issue, TemporalHyDICE maintains a running estimate</p><formula xml:id="formula_34">COST(z i , τ i )</formula><p>on the cost of having the motion planner spend additional computational time attempting to extend T from (z i , τ i ).vertices to Γ (τ i+1 ), where</p><formula xml:id="formula_35">(z i , τ i ).vertices = {v ∈ T .V : z i ∈ v.α ∧ τ i = τ (v.s)}.</formula><p>Note that τ i = τ (v.s) means that TRAJ(T , v) has reached Γ (τ i ), and z i ∈ v.α means that z i is an automaton state obtained when running A on τ (TRAJ(T , v)). Therefore, (z i , τ i ).vertices indicate that TemporalHyDICE has extended T in succession from Γ (τ 0 ), . . . , Γ (τ i ).</p><p>In this way, when COST(z i , τ i ) is low, TemporalHyDICE estimates that more computational time should be dedicated to extending T from (z i , τ i ).vertices toward Γ (τ i+1 ) so that T reaches Γ (τ 0 ), . . . , Γ (τ i+1 ) in succession. As described in Sect. 4.3, COST(z i , τ i ) is low when (z i , τ i ) is underexplored, since additional exploration by motion planning could add new connections from (z i , τ i ).vertices to Γ (τ i+1 ) and advance the search further. When (z i , τ i ) is overexplored, then COST(z i , τ i ) is high, since overexploration does not bring much new information and wastes valuable computational time. The cost of a discrete witness is then defined as</p><formula xml:id="formula_36">COST [(z i , τ i )] n-1 i=0 = n-2 i=0 COST(z i , τ i ) COST(z i+1 , τ i+1 ).</formula><p>Since when exploring (z i , τ i ) the objective of motion planning is to reach Γ (τ i+1 ) from (z i , τ i ).vertices, then COST(z i , τ i ) COST(z i+1 , τ i+1 ) is used in the summation instead of just paper, drawing from our earlier work <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> and extensive experiments, are designed to be computed efficiently and are shown to work well in practice.</p><p>Model checking in TemporalHyDICE biases the computation toward discrete witnesses associated with low cost. TemporalHyDICE estimates that additional exploration of these discrete witnesses can advance the search further by increasing exploration in underexplored regions and avoiding spending computational time in overexplored regions. TemporalHyDICE does not completely ignore high-cost discrete witnesses. In particular, in addition to low-cost discrete witnesses, random discrete witnesses are selected, although less frequently, as a way to correct for errors inherent with the cost estimates.</p><p>The computation of the current discrete witness, expansion of T by motion planning as guided by the discrete witness, and updates to cost estimates based on new information gathered by motion planning constitute the core loop of TemporalHyDICE. As a result of the updated cost estimates, a new discrete witness can be selected by model checking in the next iteration the core loop. this way, information gathered by motion planning leads TemporalHyDICE to consider alternative discrete witnesses that could expand the search for a witness trajectory along new directions. This interplay between model checking and motion planning through cost estimates, as demonstrated by the experiments, allows TemporalHyDICE to efficiently compute witness trajectories. Pseudocode is given in Algorithm 3. Sections describing the main steps in Algorithm 3 are referenced after each line.  <ref type="figure"></ref>and<ref type="figure">z</ref> </p><formula xml:id="formula_37">z i , τ i )] n-1 i=0 , where (z i , τ i ) ∈ A.Z × 2 Π , z 0 = A.z init ,</formula><formula xml:id="formula_38">n-1 ∈ A.Accept.</formula><p>With high probability, the discrete witness is computed as the shortest path from initial to accepting states in A × D where an edge ((z i , τ i ), (z j , τ j )) is assigned the weight COST(z i , τ i ) COST(z j , τ j ). This allows to select low-cost discrete witnesses. With small probability, the discrete witness is also computed as a random path by using a variation of depth-first-search which visits frontier nodes in a random order. This randomness provides a way to correct for errors inherent with the cost estimates by ensuring that each discrete witness is selected with non-zero probability.</p><p>TemporalHyDICE does not explicitly construct A × D. During the search for a discrete witness, the outgoing edges of (z i , τ i ) are computed implicitly as </p><formula xml:id="formula_39">EDGES(z i , τ i ) = {(z j , τ j ) : (v(τ i ), v(τ j )) ∈ D.E ∧ z j ∈ A.δ(z i , τ j )}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Cost estimates</head><p>Cost estimates are based on information gathered during motion planning. Specifically,</p><formula xml:id="formula_40">COST(z i , τ i ) = TIME 2 (z i , τ i ) COV(z i , τ i )</formula><p>where TIME(z i , τ i ) is the number of times motion planning has attempted to extend T from (z i , τ i ).vertices and COV(z i , τ i ) estimates the coverage of Γ (τ i ) by states associated with (z i , τ i ).vertices. In this way, TemporalHyDICE associates a low COST(z i , τ i ) with (z i , τ i ) when motion planning has made rapid progress in covering Γ (τ i ) with states associated with (z i , τ i ).vertices. The component TIME(z i , τ i ) gives priority to (z i , τ i )'s that have not been selected frequently in the past. These cost estimates are designed to be computed efficiently and are motivated by related work <ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b40">41]</ref> and extensive experiments, which show that it works well in practice.</p><p>As in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>, COV(z i , τ i ) is computed by imposing an implicit uniform grid on a low-dimensional projection of H.S and counting the number of grid cells that have at least one state from the states associated with (z i , τ i ).vertices.</p><p>In the experiments in this paper, where the hybrid system models a robotic vehicle navigating in different terrains, the low-dimensional projection corresponds to the vehicle position, i.e., POSITION(x ) (Sect. 5.1). Note that COV(z i , τ i ) needs to be updated only when a vertex v ∈ T .V is added to (z i , τ i ).vertices. To make this update efficient, each (z i , τ i ) maintains its own list of grid cells, (z i , τ i ).cells. Initially, (z i , τ i ).cells is empty. When a vertex v is added to (z i , τ i ).vertices, the low-dimensional projection of v.s = (q, x) is computed as p = POSITION(x ), which is then used to determine the grid cell c that should contain p. The cell c is then added to (z i , τ i ).cells if it is not already there. A hash-map is used to efficiently search if c ∈ (z i , τ i ).cells. In this way, COV(z i , τ i ) is efficiently updated as the number of covered cells, i.e., COV(z </p><formula xml:id="formula_41">i , τ i ) = |(z i , τ i ).cells|.</formula><p>As evidenced by the experiments, the cost estimates allow model checking to compute low-cost discrete witnesses that effectively guide motion planning as it expands T during the search for a witness trajectory. Since the cost estimates are updated efficiently there is also little computational overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Motion planning</head><formula xml:id="formula_42">Let σ = [(z i , τ i )] n-1</formula><p>i=0 denote the current discrete witness. The objective is to extend T so that it reaches Γ (τ 0 ), . . . , Γ (τ n-1 ) in succession. Motion planning proceeds by extending T from vertices associated with pairs (z i , τ i ) (Algorithm 3:5-15). Note that only pairs (z i , τ i ) ∈ σ reached by T , i.e., (z i , τ i ).vertices = ∅, have vertices from which to extend T . Let σ avail contain all such pairs, i.e.,</p><formula xml:id="formula_43">σ avail ={(z i , τ i ) ∈ σ : (z i , τ i ).vertices = 0} (Algorithm 3:5)</formula><p>At each iteration, a pair (z i , τ i ) is selected from σ avail to be further explored with probability 1/COST(z i , τ i ) (z j ,τ j )∈σ avail 1/COST(z j , τ j ) (Algorithm 3:7) selection favors pairs (z i , τ i ) associated with low cost, which indicate that additional progress can be made by further exploring (z i , τ i ). The exploration consists of extending several new branches from (z i , τ i ).vertices (Algorithm 3:9-15). Specifically, a vertex v is selected from (z i , τ i ).vertices with probability</p><formula xml:id="formula_44">1/TIME(v) v ∈(z i ,τ i ).vertices 1/TIME(v ) , (<label>Algorithm 3:8)</label></formula><p>where TIME(v) is one plus the number of times v has been selected in the past from (z i , τ i ).vertices. This is based on well-established strategies in motion planning that favor those vertices selected less frequently in the past <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref>. After a vertex v has been selected, as described in Sect. 3, T is extended from v by adding to T a valid hybrid-system trajectory that starts at v.s and ends at a new vertex, v new .s (Algorithm 3:9-13). If any of the automaton states v new .α is an accepting state, then TRAJ(T , v new ) is a witness trajectory (Algorithm 3:14-15). As a result of the exploration, cost estimates need to be updated (Algorithm 3:16-21) as described in Sect. 4.3. Moreover, v new is associated with each (z new , τ new ), where z new ∈ v new .α and τ new = τ (v new .s). COST(z new , τ new ) is also updated to reflect adding v new to (z new , τ new ).vertices. Each (z new , τ new ) is also added to σ avail , so that it becomes available for selection in the next iteration.</p><p>Updates to the cost estimates allow motion planning to select other pairs (z j , τ j ) ∈ σ avail to explore during the remaining iterations. Moreover, the updates provide better cost estimates for the discrete witnesses, which improves the selection of discrete witnesses in the next iteration of the core loop of TemporalHyDICE. This in turn allows motion planning to make more progress in extending T as guided by the discrete witness and eventually compute a witness trajectory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments and results</head><p>Experiments in this paper show that TemporalHyDICE provides a promising framework for the falsification of safety properties expressed by syntactically safe LTL formulas for hybrid systems with nonlinear continuous dynamics. TemporalHyDICE is shown to be significantly more efficient than the straightforward extensions of related work <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref>, which use the automaton A as an external monitor (Sect. 3). The experiments also demonstrate the importance of model checking and of the discrete transition model in the computational efficiency of TemporalHyDICE. This paper also studies the impact on the computational efficiency of TemporalHyDICE when using a minimized DFA, minimized NFA constructed by hand, or NFA constructed by standard tools <ref type="bibr" target="#b41">[42]</ref>.</p><p>Fig. <ref type="figure">1</ref> In the hybrid-system benchmark, a vehicle drives over different terrains. The vehicle dynamics vary from terrain to terrain, i.e., the vehicle dynamics in each terrain T i are selected from those of a car, unicycle, or differential drive. Each T i is subdivided into a uniform grid, and some grid cells are labeled as guards, jumps, or propositions. Grid cells labeled with G k i, j (in blue) denote guards. Discrete transitions are indicated by straight arrows. A discrete transition occurs when the vehicle center reaches a guard. Only one discrete transition per guard is shown. The corresponding jump cells are in green. Grid cells labeled with P k i (in yellow) denote propositions (color figure online)</p><p>5.1 Hybrid-system robot navigation benchmark</p><p>The hybrid system H models an autonomous vehicle driving over different terrains, similar to the navigation benchmark proposed in <ref type="bibr" target="#b33">[34]</ref> and used in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>. Figure <ref type="figure">1</ref> provides an illustration. Benchmark instances, as described below, are generated at random in order to test falsification methods over a large number of problems and obtain statistically significant results.</p><p>Terrains The number of terrains is n T = 10. Each terrain T i is a unit square. The vehicle dynamics vary from terrain to terrain. Specifically, the dynamics in each T i are selected pseudo-uniformly at random from those of a car, unicycle, or differential drive, which are described at the end of this section.</p><p>To compute guards, jumps, and propositions, each terrain T i is subdivided into a 35 × 35 uniform grid. Let c 1 , . . . , c m denote a random permutation of all the grid cells from all the terrains (m = n T × 35 × 35).</p><p>Guards and jumps c 1 , . . . , c n G are labeled as guards, where n G = 50. For each guard cell, the corresponding jump cell is selected uniformly at random from the remaining grid cells, i.e., {c n G +1 , . . . , c m A grid cell labeled as a guard G k i, j defines a guard function as follows:</p><p>GUARD k (q i ,q j ) (x) = true ⇐⇒ POSITION(x ) ∈ G k i, j , where POSITION(x ) denotes the position of the vehicle center when the continuous state is x. In other words, GUARD k (q i ,q j ) (x) is satisfied when the vehicle center reaches G k i, j . In that case, a discrete transition is triggered, which instantaneously changes the vehicle dynamics to the dynamics associated with terrain T j and resets the continuous state according to JUMP k (q i ,q j ) , where 1   JUMP k</p><formula xml:id="formula_45">(q i ,q j ) (x) = (POSITION(x) + CENTER(T j ) -CENTER(T i ), ORIENTATION(x ), 0, . . . , 0)</formula><p>and CENTER(T i ) denotes the center of terrain T i . Thus, the vehicle maintains the same position and orientation with respect to the origin of T j as it did with respect to the origin of T i immediately before the discrete transition. In this way, guards and jumps can be thought as providing overpasses that allow the vehicle to immediately move from one terrain to another.</p><p>Propositions The number of propositions is n P = 150. Then, a random subset of n P grid cells is selected from {c 2n G +1 , . . . , c m } and each selected grid cell is labeled as proposition. A grid cell labeled as a proposition P k i defines a proposition function as follows:</p><formula xml:id="formula_46">PROP π i,k (x) = true ⇐⇒ POSITION(x ) ∈ P k i .</formula><p>In this way, PROP k π i,k (x) is satisfied when the vehicle center reaches P k i . User-defined graph D For the hybrid-system benchmark in this paper, D is defined as follows. A vertex is added to D for each grid cell. If a grid cell c is not labeled as a guard, then an edge is added to D from c to its left, right, up, and down neighboring cells. If a grid cell c is labeled as a guard G k i, j , then an edge is added from c to the cell c , where c is the grid cell associated with the jump for G k i, j . Second-order models of vehicle dynamics Vehicle break dynamics associated with each q i ∈ Q are selected uniformly at random from second-order models of cars, differential drives, and unicycles. Details of these models can be found in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b37">38]</ref>. For completeness, these models are summarized below.</p><p>Car State x = ( p, θ, v, ψ) consists of position p ∈ R 2 , orientation θ ∈ [-π, π), velocity (|v| ≤ 3 m/s), and steering 1 After a discrete transition, components of the continuous state except position and orientation are reset to zero to account for the fact that state components can vary from mode to mode, e.g., the car has translational velocity and steering angle in the continuous state, but differential-drive has rotational velocities of the wheels. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Syntactically safe LTL formulas</head><p>Syntactically safe LTL formulas were manually designed in order to provide meaningful properties. These formulas are defined over the n P = 150 propositions generated for each benchmark instance. Let π 1 , . . . , π 150 denote a random permutation of the propositions PROP π i,k . Let β 0 denote a special proposition, which is true iff none of the propositions π 1 , . . . , π 150 is true. Note that β 0 geometrically corresponds to the grid cells not labeled as propositions, as illustrated in Fig. <ref type="figure">1</ref>. The syntactically safe LTL formulas are defined as follows.</p><p>Sequencing (n = 3, 4, 5, 6): A witness trajectory ζ reaches π 1 , . . . , π n in that order via β 0 . More specifically, ζ starts at β 0 and remains in β 0 until it reaches π 1 ; then remains in π 1 until it reaches β 0 ; then remains in β 0 until it reaches π 2 ; . . .; then remains in π n-1 until it reaches β 0 ; then remains in β 0 until it reaches π n . Formally, the formulas are as follows:</p><formula xml:id="formula_47">φ 3 1 = ¬(β 0 U(π 1 ∧ (π 1 U(β 0 U(π 2 ∧ (π 2 U(β 0 Uπ 3 ))))))) φ 4 1 = ¬(β 0 U(π 1 ∧ (π 1 U(β 0 U(π 2 ∧ (π 2 U(β 0 U (π 3 ∧ (π 3 U(β 0 Uπ 4 ))))))))) . . . φ n 1 = ¬(β 0 U(π 1 ∧ (π 1 U(β 0 U(. . . (π n-1 ∧ (π n-1 U(β 0 Uπ n ))))))))</formula><p>Note that ζ is never allowed to reach any of the propositions π n+1 , . . . , π 150 . In this way, π n+1 , . . . , π 150 serve as obstacles that must be avoided by ζ at all times.</p><p>Counting (n = 1, 2, 3, 4): A witness trajectory ζ starts at β 0 ∨ π 1 and remains there until it reaches π 1 . Then, ζ repeats the following n-times: remains in π 1 ∨ β 0 until it reaches π 2 ;</p><p>then remains in π 2 ∨ β 0 until it reaches π ; then remains in π 3 ∨ β 0 until it reaches π 4 ; then remains in π 4 until it reaches π 1 ∨ β 0 . After repeating these steps n times, ζ remains in π 1 ∨ β 0 until it reaches π 5 . Formally, the formulas are as follows:</p><formula xml:id="formula_48">φ n 2 = ¬(ς 1 U(π 1 ∧ Ξ n )),</formula><p>where</p><formula xml:id="formula_49">ς i = β 0 ∨ π i ; f (ψ) = ς 1 U(π 2 ∧(ς 2 U(π 3 ∧(ς 3 U(π 4 ∧(π 4 U(ς 1 ∧ψ)))))))</formula><p>(see note 2 ); and</p><formula xml:id="formula_50">Ξ 1 = f (ς 1 Uπ 5 ), Ξ 2 = f (Ξ 1 ), . . . , Ξ n = f (Ξ n-1 ).</formula><p>Note that ζ is never allowed to reach any of the propositions π 6 , . . . , π 150 , which, in this way, serve as obstacles that must be avoided at all times.</p><p>Coverage (n = 4, 5, 6, 7): A witness trajectory eventually reaches each π 1 , . . . , π n , i.e.,</p><formula xml:id="formula_51">φ n 3 = ¬ n i=1 F(π i ) .</formula><p>The automata A for the complement of each safety LTL formula are computed by standard tools <ref type="bibr" target="#b41">[42]</ref> For the experiments, 100 benchmark instances were generated at random as described in Sect. 5.1. For each combination of a method M i and an LTL safety formula φ, Fig. <ref type="figure" target="#fig_0">2</ref> reports the average time in seconds obtained by method M i when attempting to compute a witness trajectory for φ for each of the 100 benchmark instances. Timeout for each run was set to 400 s. Computational times for TemporalHyDICE include the construction of the graph D, which took &lt; 1 s. 2 The notation f (ψ) is used for convenience as a function that takes the argument ψ and places it as indicated in the expression.   <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref>, which make it possible for the related work to handle LTL specifications (since related work in its original formulation could not handle LTL specifications). As described in Sect. 3, these extensions are obtained by using the safety automaton A as an external monitor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Computational efficiency of TemporalHyDICE</head><p>The results in Fig. <ref type="figure" target="#fig_0">2</ref> indicate that TemporalHyDICE efficiently computed witness trajectories for all problem instances. Even for the most challenging problem in the experiments (instances where the LTL safety property is specified by φ 7</p><p>3 ), the average running time of TemporalHyDICE was less than five minutes. In the other cases, TemporalHyDICE was even faster. As an example, for the LTL safety formulas φ 3  1 , φ 4 1 , φ 5 1 , φ 6  1 , the average running times of TemporalHyDICE are 18.6s, 25.5s, 27.2s, and 40.4s, respectively.</p><p>As shown in Fig. <ref type="figure" target="#fig_0">2</ref>, while TemporalHyDICE efficiently solved all problem instances, RRT[LTL-TSF] timed out in almost every instance. RRT[LTL-TSF] relies on distance metrics and neighbors to guide the search. By relying on such limited information, as shown in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> in the context of reachability analysis, it quickly becomes difficult for RRT-based methods to find feasible directions along which to extend T , causing a rapid decline in the growth of T . The results in Fig. <ref type="figure" target="#fig_0">2</ref> confirm this observation also in the case of applying RRT[LTL-TSF] to falsify LTL safety properties in hybrid systems. By combining model checking and motion planning, TemporalHyDICE effectively guides the tree search. We also observe that the running time of TemporalHyDICE tends to increase sub-linearly (φ n 1 and φ n 2 ) or sub-quadratically (φ n 3 ) with the number of states in the minimized DFA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Impact of combining model checking and motion planning</head><p>Comparisons in Fig. <ref type="figure" target="#fig_0">2</ref> between TemporalHyDICE and HyDICE[NoGuide, LTL-TSF] show the importance of combining model checking and motion planning. Recall that, as described in Sect. 3, HyDICE[NoGuide, LTL-TSF] denotes the extension of our earlier work <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> to use the automaton A as an external monitor so that it can be applied for the falsification of LTL safety properties. ). When searching just A, a discrete witness may contain propositional assignments τ i and τ i+1 that cannot be satisfied consecutively, i.e., Γ (τ i ) is not directly connected to Γ (τ i+1 ). The graph D serves to eliminate from consideration many of these infeasible discrete witnesses. This in turn speeds up the search for a witness trajectory since T is extended far more frequently toward feasible directions. It is also important to note that, even though the discrete witnesses obtained by searching just A are not as beneficial as those obtained by searching D and A, TemporalHyDICE[no D] is still considerably faster than falsification methods that do not guide the tree search, such as RRT[LTL-TSF] and HyDICE[NoGuide, LTL-TSF]. Fig. <ref type="figure" target="#fig_5">3</ref> Comparison of the computational efficiency of TemporalHyDICE when using a minimal DFA, a minimal NFA constructed by hand, or an NFA constructed by standard tools <ref type="bibr" target="#b41">[42]</ref> for the safety properties specified by the various φ n 2 formulas. Reported is the average time in seconds to solve 100 problem instances for each of the LTL formulas. Timeout was set to 400 s (color figure online) determinizing and minimizing the NFAs. These experiments are motivated by the work in <ref type="bibr" target="#b34">[35]</ref>, which shows significant speedup when using DFAs instead of NFAs in the context of model checking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3">Impact of automata minimization and determinization</head><p>As Fig. <ref type="figure" target="#fig_5">3</ref> shows, TemporalHyDICE is only slightly faster when using minimal NFAs instead of minimal DFAs, even though minimal NFAs had significantly fewer states. As concluded in <ref type="bibr" target="#b34">[35]</ref>, DFAs offer computational advantages that can offset the drawbacks of a possibly exponential increase in the number of states. In particular, a DFA search has a significantly smaller branching factor, since there is exactly one transition that can be followed from each state for each propositional assignment, while when using an NFA there are generally many more. This observation is also supported by comparisons of minimal DFAs to standard NFAs in Fig. <ref type="figure" target="#fig_5">3</ref>, since in such cases there is significant speedup when using minimal DFAs. Therefore, the non-minimized NFA should be determinized and minimized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>This paper presented a novel method, TemporalHyDICE, for the falsification of safety properties specified by syntactically safe LTL formulas for hybrid systems with nonlinear dynamics and input controls. By effectively combining model checking and motion planning, when a hybrid system is unsafe, TemporalHyDICE computes a witness trajectory that indicates a violation of the safety property. Model checking in TemporalHyDICE computes discrete witnesses by searching on-the-fly an automaton A for the complement of the LTL safety formula and the user-defined abstraction of the hybrid system. Motion planning explores the state space of the hybrid system by extending a search tree, consisting of feasible hybrid-system trajectories, along the directions specified by the discrete witness. Information gathered during exploration is fed back to model checking to improve the discrete witnesses computed in future iterations. Experiments that test LTL safety properties on a robot navigation benchmark modeled as a hybrid system with nonlinear dynamics and input controls provide promising validation. Results show significant speedup over extensions of RRT-based falsification and demonstrate importance of combining model checking and motion planning for the falsification of LTL safety properties.</p><p>TemporalHyDICE opens up several venues for future research. As we consider increasingly challenging problems, it becomes important to further improve the synergistic combination of model checking and motion planning. Moreover, the development of algorithms that make use of parallel or multi-threaded computational resources provides an important venue to significantly improve the computational efficiency of the framework. Another research direction is to extend the theory developed in <ref type="bibr" target="#b42">[43]</ref> to show probabilistic completeness for TemporalHyDICE.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>4. 2</head><label>2</label><figDesc>Computation of discrete witnesses DiscreteWitness(P, A, D) (Algorithm 3:4) uses model checking to compute discrete witnesses by searching on-thefly A and D. The search produces a sequence [(</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>angle (|ψ| ≤ 40 • ). The distance between front and rear axles is L = 0.8 m. Controls consist of the acceleration (|u 0 | ≤ 0.8 m/s 2 ) and rotational velocity of the steering angle (|u 1 | ≤ 25 • /s). Dynamics equations are ṗ0= v cos(θ ), ṗ1 = v sin(θ ), θ = v tan(ψ)/L, v = u 0 , ψ = u 1 . Unicycle State x = ( p, θ, v, ω) consists of position p ∈ R 2 , orientation θ ∈ [-π, π),translational velocity (|v| ≤ 3 m/s), and rotational velocity (|ω| ≤ 20 • /s). Controls consist of the translational (|u 0 | ≤ 0.3 m/s 2 ) and rotational u 1 (|u 1 | ≤ 10 • /s 2 ) accelerations. Dynamics equations are ṗ0 = v cos(θ ), ṗ1 = v sin(θ ), θ = ω, v = u 0 , ω = u 1 . Differential drive State x = ( p, θ, ω , ω r ) consists of position p ∈ R 2 , orientation θ ∈ [-π, π), and rotational velocities (|ω |, |ω r | ≤ 5 • /s) of the left and right wheels. Wheel radius is r = 0.2 m and axis length is L = 0.8 m. Controls consist of the left and right wheel rotational accelerations (|u 0 |, |u 1 | ≤ 10 • /s 2 ). Dynamics equations are ṗ0 = 0.5r (ω + ω r ) cos(θ ), ṗ1 = 0.5r (ω + ω r ) sin(θ ), θ = r (ω r -ω )/L, ω = u 0 , ωr = u 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Comparison of TemporalHyDICE (denoted M1), RRT[LTL-TSF] (denoted M2), HyDICE[NoGuide, LTL-TSF] (denoted M3), TemporalHyDICE[no D] (denoted M4) when computing witness trajectories for various LTL safety properties of the hybrid-system model. Number inside parentheses after φ n i indicates number of states in minimized DFA. Reported is the average time in seconds to solve 100 problem instances for each of the LTL formulas. Times for TemporalHyDICE include the construction of D, which took &lt;1 s. Timeout was set to 400 s (color figure online)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2</head><label>2</label><figDesc>Figure2shows that TemporalHyDICE is significantly more efficient than RRT[LTL-TSF] and HyDICE[NoGuide LTL-TSF]. Recall that RRT[LTL-TSF] and HyDICE [NoGuide, LTL-TSF] correspond to extensions of related work<ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref>, which make it possible for the related work to handle LTL specifications (since related work in its original formulation could not handle LTL specifications). As described in Sect. 3, these extensions are obtained by using the safety automaton A as an external monitor.The results in Fig.2indicate that TemporalHyDICE efficiently computed witness trajectories for all problem instances. Even for the most challenging problem in the experiments (instances where the LTL safety property is specified by φ 73 ), the average running time of TemporalHyDICE was less than five minutes. In the other cases, TemporalHyDICE was even faster. As an example, for the LTL safety formulas φ3  1 , φ 4 1 , φ 5 1 , φ 6 1 , the average running times of TemporalHyDICE are 18.6s, 25.5s, 27.2s, and 40.4s, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Without model checking to guide motion planning, however, HyDICE[NoGuide, LTL-TSF], similar to RRT[LTL-TSF], times out in almost all instances. Comparisons in Fig. 2 between TemporalHyDICE and TemporalHyDICE[no D] indicate the importance of computing discrete witnesses by searching both the graph D and the automaton A (as in TemporalHyDICE) and not just A (as in TemporalHyDICE[no D]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 compares</head><label>3</label><figDesc>Figure 3 compares TemporalHyDICE when using for the automaton A NFAs computed by standard tools [42], minimal NFAs constructed by hand, or minimal DFAs obtained by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>TemporalHyDICE(P, D, t max ) Combining Model Checking and Motion Planning</figDesc><table><row><cell>Input</cell><cell></cell><cell></cell></row><row><cell cols="2">P = (H, s init , φ, , τ): problem specification</cell><cell>♦ 2.4</cell></row><row><cell cols="2">D = (V, E): abstraction t max ∈ R &gt;0 : upper bound on computation time</cell><cell></cell></row><row><cell cols="2">Output</cell><cell></cell></row><row><cell cols="3">A valid hybrid-system trajectory that satisfies ¬φ if one is found or</cell></row><row><cell cols="2">false otherwise</cell><cell></cell></row><row><cell cols="2">1: A ← construct automaton for ¬φ</cell><cell></cell></row><row><cell cols="2">2: T ← InitializeTree(P, A)</cell><cell>♦3.1.1</cell></row><row><cell cols="2">3: while ElapsedTime &lt; t max do</cell><cell></cell></row><row><cell cols="2">model checking: search on-the-fly D and A</cell><cell></cell></row><row><cell cols="2">bias search toward low-cost discrete witnesses</cell><cell></cell></row><row><cell>4: σ</cell><cell>de f = [(z i , τ i )] n i=1 ← DiscreteWitness(P, D, A)</cell><cell>♦4.2</cell></row><row><cell cols="2">motion planning: extend T guided by discrete witness</cell><cell></cell></row><row><cell cols="2">5: σ avail ← {(z i , τ i ) ∈ σ : (z i , τ i ).vertices = ∅}</cell><cell>♦4.4</cell></row><row><cell cols="2">6: for several times do</cell><cell></cell></row><row><cell>7:</cell><cell>(z i , τ i ) ← select pair from σ avail</cell><cell>♦4.4</cell></row><row><cell>8:</cell><cell>v ← select vertex from (z i , τ i ).vertices</cell><cell>♦4.4</cell></row><row><cell>9:</cell><cell cols="2">(u, T, s update cost estimates based on new info gathered from motion</cell></row><row><cell></cell><cell>planning</cell><cell></cell></row><row><cell>16:</cell><cell>UpdateCost(z i , τ i )</cell><cell>♦4.3</cell></row><row><cell>17:</cell><cell>τ vertices</cell><cell></cell></row><row><cell>21:</cell><cell>UpdateCost(z new , τ new )</cell><cell>♦4.3</cell></row><row><cell cols="2">22: return false</cell><cell></cell></row></table><note><p><p>COST(z </p>i , τ i ). Note that cost estimates in this Algorithm 3 new , α new ) ← ExtendTree(P, A, T , v) ♦3.1.3 10: if T &gt; 0 ∧ |α new | &gt; 0 then add a new vertex and edge to T 11: v new ← new vertex; v new .s ← s new ; v new .α ← α new 12: (v, v new ) ← new edge; (v, v new ).{u, T } ← {u, T } 13: T .V ← T .V ∪ {v new }; T .E ← T .E ∪ {(v, v new )} 14: if A.Accept ∩ α new = ∅ then 15: return TRAJ(T , v new ) new ← P.τ (v new .s) 18: for z new ∈ α new do 19: σ avail ← {(z new , τ new )} ∪ σ avail ♦4.4 20: (z new ,τ new ).vertices ←{v new } ∪ (z new ,τ new ).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Explicitly constructing A × D would produce a 4-ary relation, subset of A.Z ×Σ 2 ×A.Z . For this reason, TemporalHyDICE does not compute A×D explicitly. Reducing memory requirements is important, since it allows motion planning to extend T by adding more vertices and edges.</figDesc><table /><note><p>This allows TemporalHyDICE to considerably reduce the memory requirements of model checking. Note that the largest memory requirements in A are imposed by A.δ, which can be viewed as a ternary relation, subset of A.Z ×Σ ×A.Z , where Σ = 2 Π . The graph D can be viewed as a binary relation, subset of Σ × Σ.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>. The table below shows the number of states of the minimized DFA.</figDesc><table><row><cell cols="2">LTL safety formula (nr. states minimized DFA)</cell></row><row><cell>φ 3 1 (10) φ 4 1 (21) φ 5 1 (46) φ 1 2 (23) φ 2 2 (76) φ 3 2 (164) φ 4 3 (16) φ 5 3 (32) φ 6 3 (64)</cell><cell>φ 6 1 (105) φ 4 2 (287) φ 7 3 (128)</cell></row><row><cell>5.3 Results</cell><cell></cell></row><row><cell cols="2">Experiments were run on Rice Cray XD1 PBS and ADA</cell></row><row><cell cols="2">clusters, where each processor runs at 2.2 GHz and has up</cell></row><row><cell cols="2">to 8GB RAM. Each run uses a single processor and a single</cell></row><row><cell>thread, i.e., no parallelism.</cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments This work is supported in part by NSF CNS 0615328 (EP, LK, MV), NSF CCF 1018798 (LK, MV), and NSF CCF 0613889 (MV). Equipment is supported by NSF CNS 0454333 and NSF CNS 0421109 in partnership with Rice University, AMD, and Cray.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Computational techniques for the verification and control of hybrid systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Tomlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bayen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Oishi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="986" to="1001" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The algorithmic analysis of hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Olivero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="34" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">What&apos;s decidable about hybrid automata?</title>
		<author>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kopke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Puri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Varaiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symp on Theory of Computing</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="373" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Computational techniques for hybrid system verification</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chutinan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Krogh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Autom. Control</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="75" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Comparing forward and backward reachability as tools for safety analysis</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4416</biblScope>
			<biblScope unit="page" from="428" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Discrete abstractions of hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lafferriere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="971" to="984" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Abstraction and counterexample-guided refinement in model checking of hybrid systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fehnker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ouaknine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Stursberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theobald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Found. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="583" to="604" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bounded model checking for hybrid dynamical systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Giorgetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bemporad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Decision and Control</title>
		<meeting><address><addrLine>Seville, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="672" to="677" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Universal computation and other capabilities of continuous and hybrid systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Branicky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="67" to="100" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Samplingbased planning, control, and verification of hybrid systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Branicky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Curtiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Morgan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEE Proc. Control Theory Appl</title>
		<imprint>
			<biblScope unit="volume">153</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="575" to="590" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Incremental search methods for reachability analysis of continuous and hybrid systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bhatia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2993</biblScope>
			<biblScope unit="page" from="142" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Adaptive RRTs for validating hybrid robotic control systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Algorithmic Foundations of Robotics</title>
		<meeting><address><addrLine>Zeist, Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="107" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An RRT-based algorithm for testing and validating multi-robot controllers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Robotics: Science and Systems</title>
		<imprint>
			<biblScope unit="page" from="249" to="256" />
			<date type="published" when="2005">2005</date>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Coverage-guided test generation for continuous and hybrid systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Nahhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods Syst. Des</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="213" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Hybrid systems: from verification to falsification</title>
		<author>
			<persName><forename type="first">E</forename><surname>Plaku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Kavraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4590</biblScope>
			<biblScope unit="page" from="468" to="481" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Hybrid systems: from verification to falsification by combining motion planning and discrete search</title>
		<author>
			<persName><forename type="first">E</forename><surname>Plaku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Kavraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods Syst. Des</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="157" to="182" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Benefits of bounded model checking at an industrial setting</title>
		<author>
			<persName><forename type="first">F</forename><surname>Copty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fraer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Giunchiglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kamhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tacchella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2102</biblScope>
			<biblScope unit="page" from="436" to="453" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Sampling-based falsification and verification of controllers for continuous dynamic systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">11-12</biblScope>
			<biblScope unit="page" from="1232" to="1245" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sampling-based resolution-complete safety falsification of linear hybrid systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bhatia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on Decision and Control</title>
		<meeting><address><addrLine>New Orleans</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="3405" to="3411" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Sampling-based resolution-complete algorithms for safety falsification of linear systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bhatia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4981</biblScope>
			<biblScope unit="page" from="606" to="609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Randomized kinodynamic planning</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Lavalle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Kuffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="378" to="400" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Model Checking</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Uppaal-present and future</title>
		<author>
			<persName><forename type="first">G</forename><surname>Behrmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pettersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Decision and Control</title>
		<meeting><address><addrLine>Orlando, Florida</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="2881" to="2886" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Temporal logic motion planning for dynamic mobile robots</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Fainekos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Girard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kress-Gazit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automatica</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="343" to="352" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Temporal logic motion planning for mobile robots</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Fainekos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kress-Gazit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Robotics and Automation</title>
		<meeting><address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="2020" to="2025" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A fully automated framework for control of linear systems from temporal logic specifications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kloetzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Belta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Autom. Control</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="287" to="297" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Temporal-logicbased reactive mission and motion planning</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kress-Gazit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fainekos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1370" to="1381" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Receding horizon temporal logic planning for dynamical systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wongpiromsarn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Topcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Conference on Decision and Control</title>
		<imprint>
			<biblScope unit="page" from="5997" to="6004" />
			<date type="published" when="2009">2009</date>
			<pubPlace>Shanghai, China</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Temporal logic planning and control of robotic swarms by hierarchical abstractions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kloetzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Belta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="320" to="331" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Temporal logic analysis of gene networks under parameter uncertainty</title>
		<author>
			<persName><forename type="first">G</forename><surname>Batt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Belta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Autom. Control</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="215" to="229" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Guaranteed termination in the verification of LTL properties of non-linear robust discrete time hybrid systems</title>
		<author>
			<persName><forename type="first">W</forename><surname>Damm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratschan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Found. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="63" to="86" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Model checking of safety properties</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods Syst. Des</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="291" to="314" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Safety, liveness and fairness in temporal logic</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="495" to="511" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Benchmarks for hybrid systems verification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fehnker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ivancic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2993</biblScope>
			<biblScope unit="page" from="326" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Efficient LTL compilation for SAT-based model checking</title>
		<author>
			<persName><forename type="first">R</forename><surname>Armoni</surname></persName>
		</author>
		<author>
			<persName><surname>Egorov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fraer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Korchemny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer-Aided Design</title>
		<meeting><address><addrLine>San Jose</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="877" to="884" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Recognizing safety and liveness</title>
		<author>
			<persName><forename type="first">B</forename><surname>Alpern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distrib. Comput</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="117" to="126" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Choset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hutchinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kantor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Burgard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Kavraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thrun</surname></persName>
		</author>
		<title level="m">Principles of Robot Motion: Theory, Algorithms, and Implementations</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Planning Algorithms</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Lavalle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Accurate event detection for simulation of hybrid systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="204" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Robust test generation and coverage for hybrid systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Julius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Fainekos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4416</biblScope>
			<biblScope unit="page" from="329" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Discrete search leading continuous exploration for kinodynamic motion planning</title>
		<author>
			<persName><forename type="first">E</forename><surname>Plaku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Kavraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Robotics: Science and Systems</title>
		<meeting><address><addrLine>Atlanta, Georgia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="326" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Efficient model checking of safety properties</title>
		<author>
			<persName><forename type="first">T</forename><surname>Latvala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model Checking Software</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Rajamani</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2648</biblScope>
			<biblScope unit="page" from="74" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Motion planning for physical simulation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Ladd</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<pubPlace>Houston</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Rice University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
