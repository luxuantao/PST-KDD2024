<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Secure Untrusted Data Repository (SUNDR) *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jinyuan</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">NYU Department of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Maxwell</forename><surname>Krohn</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">NYU Department of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Mazi√®res</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">NYU Department of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dennis</forename><surname>Shasha</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">NYU Department of Computer Science</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Secure Untrusted Data Repository (SUNDR) *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We have implemented a secure network file system called SUNDR that guarantees the integrity of data even when malicious parties control the server. SUNDR splits storage functionality between two untrusted components, a block store and a consistency server. The block store holds all file data and most metadata. Without interpreting metadata, it presents a simple interface for clients to store variable-sized data blocks and later retrieve them by cryptographic hash.</p><p>The consistency server implements a novel protocol that guarantees close-to-open consistency whenever users see each other's updates. The protocol roughly consists of users exchanging version-stamped digital signatures of block server metadata, though a number of subtleties arise in efficiently supporting concurrent clients and groupwritable files. We have proven the protocol's security under basic cryptographic assumptions. Without somehow producing signed messages valid under a user's (or the superuser's) public key, an attacker cannot tamper with a user's files-even given control of the servers and network. Despite this guarantee, SUNDR performs within a reasonable factor of existing insecure network file systems.</p><p>*NYU computer science dept. technical report TR2003-841, June 2003.    </p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Nobody wants malicious attackers tampering with his files. This basic and obvious fact underlies much of the way people manage data. Important file systems must be kept on secure servers in machine rooms to which only authorized people have access. Only highly trusted administrators can perform mundane tasks such as backup and hardware maintenance. Conversely, people must address the constant threat of attackers gaining administrative privileges on servers. Otherwise, a number of readily available "rootkits" allow attackers who penetrate a system to replace core operating system utilities with altered versions that open back doors and conceal evidence of the security breach.</p><p>Data security is often viewed as the problem of building a better fence around storage servers-limiting the number of people with server access, disabling unnecessary daemons that might be remotely exploitable, and staying current with security patches to minimize the window of vulnerability to software flaws. This approach has two drawbacks. First, experience has shown in many cases that people do not build high enough fences. Second, perhaps more important, high fences are inconvenient; they restrict the ways in which people can manage data.</p><p>An alternative approach is to reduce the security needs of file servers. This paper presents SUNDR, a secure network file system designed to do exactly this. Assuming only the existence of digital signatures and a collisionresistant hash function, SUNDR's protocol provably guarantees the integrity and consistency of file system data, even when malicious parties entirely control the server. Unlike previous Byzantine-fault-tolerant file systems <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b20">22]</ref> that distribute trust but assume that a threshold fraction of servers are honest, SUNDR assumes no on-line trusted parties. To tamper with a user's files without being detected, an attacker must either compromise the user's client while the user is logged in, or otherwise produce valid digital signatures under the user's public key. In particular, the superuser's private signature key can be stored off-line when not in use, making it extremely difficult for an attacker to gain superuser access to the file system.</p><p>SUNDR does not currently address the issue of storage reliability. Of course, an attacker can always physically damage a server or wipe its disks. However, SUNDR stores all long-lived data in an append-only block log. Thus, it could use append-only storage <ref type="bibr" target="#b25">[27]</ref> to gain resilience to network attacks. Incremental off-site backups are also easily implementable to survive physical compromise. Moreover, because SUNDR does not trust the file server, after a disaster, any lost file system data can safely be recovered from other untrusted sources that might have the data, such as clients' file caches.</p><p>SUNDR's security model gives people more options for managing their data than current systems. For instance, organizations can outsource data storage without fear of the server operators tampering with data. It also offers a vast improvement over current file system security.</p><p>An attacker who compromises a SUNDR server cannot tamper with file contents. Our prototype implementation gives performance within a reasonable factor of the popular NFS file system, making SUNDR practical despite its significantly increased security.</p><p>The next section gives an overview of the SUNDR protocol. The following two sections describe SUNDR's implementation and how we tuned the protocol to give acceptable performance. Section 5 evaluates the performance of our implementation. Section 6 discusses related work, and Section 7 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Protocol</head><p>The SUNDR protocol provably guarantees the integrity and consistency of file system contents, preventing untrusted server operators or malicious parties who compromise a server from undetected tampering with data. This section gives an overview of the protocol and its security properties, and explains how SUNDR's semantics differ from those of ordinary Unix file systems. A more detailed description of the protocol and a proof of its security were presented in <ref type="bibr" target="#b12">[14]</ref>, though the published version of that paper did not present a protocol for group-writable files.</p><p>At the highest level, SUNDR consists of a client, a block server, and a consistency server. The block server is responsible for storing and serving data. It names each data block by a collision-resistant cryptographic hash, allowing clients to verify that every block they retrieve contains the correct contents. The consistency server is responsible for assigning an order to all file system operations. It employs a new protocol through which clients verify that other clients have been presented with a consistent view of the file system.</p><p>Every file in a SUNDR file system belongs to either a user or a group. For the purposes of this paper, a user is a principal logged into a single SUNDR client. (Human users logged into multiple terminals function as separate SUNDR users in the same SUNDR group.) Each user has a public signature key. To change a file, one must produce a message signed by the file's owner or, for group-owned files, by a member of the group that owns the file. As a special case, the superuser can sign any data structure.</p><p>All users know each other's public keys and group membership. Currently, this information is manually distributed to clients, though in the future we envisage managing keys and groups through superuser-owned files in the file system. The server does not have any user's signature key, and thus cannot make unauthorized changes to the file system. Moreover, the server operator does not need the superuser key. In fact, the superuser's signature key need not be anywhere on-line unless a privileged user is accessing the file system as an administrator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Data structures</head><p>Figure <ref type="figure">1</ref> shows the basic SUNDR data structures. Every file is identified by a principal, i-number pair, where principal is the user or group that owns the file and inumber is a per-user or per-group inode number. (Unlike traditional file systems, SUNDR allows files owned by different users to have the same i-number.) Directory entries map file names onto principal, i-number pairs. A per-principal data structure called the i-table maps each active i-number to a collision-resistant SHA-1 [7] hash of the file's inode. We call this value the file's i-hash. Inodes themselves contain SHA-1 hashes of file data blocks and indirect blocks, an approach taken from the SFSRO <ref type="bibr" target="#b8">[10]</ref> read-only file system.</p><p>SUNDR forms a cryptographic hash tree <ref type="bibr" target="#b13">[15]</ref> from each i-table. The root of this tree is called the i-handle. Given an i-handle and all appropriate intermediary data structures, one can verify any block of any file in the itable. Thus, securely retrieving file system contents boils down to the problem of first obtaining the latest i-handle of each user and group, then retrieving any needed data blocks by their SHA-1 hashes. The latter functionally is conceptually simple to implement in the block server, while the former requires a somewhat complex consistency protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Consistency protocol</head><p>Traditional network file systems provide close-to-open consistency. If one user modifies and closes a file, another user who subsequently opens and reads the file should see the data most recently written there. Concurrent operations can be ordered at the discretion of the server, but all clients must agree on the order of any conflicting operations.</p><p>SUNDR achieves consistency by embedding i-handles in digitally signed version structures through which clients can verify that the file system has been delivering close-to-open consistency. As long as users see the effects of each other's operations, they are guaranteed to be getting close-to-open consistency. <ref type="foot" target="#foot_0">1</ref> There remains the possibility of a malicious server entirely concealing some users' actions from others, if neither collection of users expects anyone from the other to have accessed the file system. However, such attacks are very likely to be discovered quickly, as once a malicious server has "forked" the state of the file system, it can never again allow deceived users to see any evidence of each other's on-line activity.</p><formula xml:id="formula_0">H * (t g ) i-handle group g's 0K‚Üí H(d 0 ) 8K‚Üí H(d 1 ) . . . 4 ‚Üí u 1 , 2 . . . (maps i#‚Üí user,i# ) 5 ‚Üí u 3 , 4 3 ‚Üí u 2 , 4 2 ‚Üí u 1 , 7 (maps offset‚Üídata) metadata (maps i#‚Üíi-hash) 2 ‚Üí H(i 2 ) 3 ‚Üí H(i 3 ) 4 ‚Üí H(i 4 ) 5 ‚Üí H(i 5 ) 6 ‚Üí H(i 6 )</formula><p>. . . Version structures use a technique somewhat similar to version vectors <ref type="bibr" target="#b3">[4]</ref> to detect inconsistencies. Each user and group has a version number. A version structure contains the latest version number of every user and group at the time of the file system operations it reflects. Two version structures are compatible if one contains at least as high a version number as the other for all principals. When creating a version structure, users increment both their own version numbers and the version numbers of any group whose i-tables they are modifying. Both opens and closes require new version structures to be computed. If the server fails to deliver close-to-open consistency, users will detect this upon seeing each other's incompatible version structures. Figure <ref type="figure">2</ref> gives an example.</p><formula xml:id="formula_1">data</formula><p>While the basic idea is simple, a significant complication is that under concurrent updates, SUNDR users need to compute and sign their own version structures without necessarily having access to all other users' latest version structures. To allow concurrent updates, the SUNDR consistency protocol introduces two RPCs, UPDATE and COMMIT, illustrated in Figure <ref type="figure">3</ref>. Both RPCs contain messages signed under users' public keys.</p><p>Intuitively, UPDATE declares a user's intent to perform some operation on the file system. An honest server totally orders all file system operations by the time at which it receives their update certificate. UPDATE returns the precise state of the file system at the time the corresponding operation is to have taken place. COMMIT contains the user's version structure, certifying the order that the server has assigned to operations. Clients wait for and verify users' signed version structures before reading the effects of any declared modifications, so as to verify the consistency provided by the server.</p><p>In more detail, when a user makes a file system call,</p><formula xml:id="formula_2">E) u 2 : u 1 -2 u 2 -2 g-4 A) u 1 : u 1 -1 u 2 -0 g-1 B) u 2 : u 1 -1 u 2 -1 g-2 C) u 1 : u 1 -2 u 2 -1 g-3 D) u 1 : u 1 -3 u 2 -1 g-4</formula><p>Figure <ref type="figure">2</ref>: Example version structures. In A-C, users u 1 and u 2 both modify group g's i-handle and increment its version number. u 1 again modifies g in D, but the malicious server conceals this update from u 2 , forking the file system state. u 2 subsequently signs a version structure incompatible with u 1 's, which the two users will discover should they ever again see any of each other's updates.</p><p>[system call returns on client] Consistency Server the client first sends the server a signed update certificate including the user's version number in the forthcoming version structure and a list of changes or deltas the user wishes to make to the file system. If the user is simply looking up a file name in a directory or opening a file for reading, the list of deltas is empty. Otherwise, when changing the state of the file system, deltas may be of four types:</p><p>‚Ä¢ Set file user, i# to i-hash h.</p><p>‚Ä¢ Set group file group, i# to user, i# .</p><p>‚Ä¢ Set/delete entry name in directory princ., i# .</p><p>‚Ä¢ Pre-allocate a range of group i-numbers (pointing them to unallocated user i-numbers).</p><p>The effects of all deltas are deterministic, so that multiple clients applying the same deltas to the same i-handles in the same order will always produce the same result.</p><p>In response to an update message, the server sends back the latest signed version structure that it has for every ihandle, plus a list of signed update certificates for operations not yet reflected in the version structure list. We call the collection of version structures returned the version structure list, or VSL, and the list of update certificates the pending version list, or PVL. An operation with update certificate x occurs after every operation reflected in the VSL and PVL returned for x, and before any operation whose UPDATE RPCs return x in the PVL.</p><p>When the client receives the reply to its update certificate, it checks the PVL for any read-after-write conflicts.</p><p>If it is not trying to read a file that another client is currently in the process of modifying, the client can return immediately from the file system call. Otherwise, it must wait for any pending conflicting operations to move from the PVL to the VSL. In either case, the client computes a new version structure based on the VSL and PVL it has received. This version structure contains the user's i-handle, the i-handles of any groups the user has modified, the current latest version number of every user and every group, and a list of pending operations in the PVL, including for each pending operation a SHA-1 hash of its forthcoming version structure without the i-handles. When computing group i-handles, the client must reflect any previous modifications to the group in the PVL.</p><p>A proof of the consistency protocol was presented in <ref type="bibr" target="#b12">[14]</ref>, but is beyond the scope of this paper. At a high level, however, its security follows from two properties. First, once two users have signed incompatible version structures, they can never again sign compatible ones without detecting the attack. Second, once a pending operation has appeared in the PVL, it will remain there until the corresponding version structure (or a later one) is signed by the user making the update. Thus, if server misbehavior makes two users' version structures incompatible, neither user can complete any system call that conflicts with an operation by the other that was pending at the time of the attack. It is this last property that makes it safe for one user to apply another user's deltas to group i-tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Semantics</head><p>SUNDR's semantics differ from traditional Unix file systems in several ways. The implementation currently does not keep track of time of last access ("atime") for files, as atime cannot be tracked securely by an untrusted server. Other file times, including the i-node change time ("ctime"), are set by clients, allowing users who hack their client software to set ctimes of files they own to arbitrary values. SUNDR also has no equivalent of the Unix "sticky bit" on directories.</p><p>While Unix files have both an owner and a group, group-writable files in SUNDR do not have a comparable notion of owner-the user who last wrote the file functions as its owner. The process of changing the permissions on a SUNDR file also functions more like making a new copy of the file; it requires write permission on the parent directory and does not affect other hard links to the file. Fortunately, SUNDR's content-hash based block store allows such copies to be made cheaply. The owner of a directory also can delete any entries in that directoryincluding non-empty directories to which he or she does not have write permission.</p><p>SUNDR's semantics were primarily driven by its secu- Though they depart significantly from traditional file systems in some areas, the new semantics offer several benefits. In particular, it is often useful to know which user has last written a group-writable file. Furthermore, if the SUNDR block server implemented disk quotas, it could limit users by the actual number of new blocks they write, whether to group-owned or userowned files. In Unix, the fact that users may be unable to delete subdirectories of their own directories is somewhat of an annoyance; giving them this right does not appreciably weaken security, as users anyway have the ability to rename directories they cannot remove. Note that except for the ctime value, malicious users who violate the protocol can only affect files in ways they equivalently could through the system call interface.</p><p>We emphasize also that SUNDR's focus is on guaranteeing the integrity and consistency of data. The current implementation does not directly address the questions of privacy, availability, or reliability, but SUNDR is entirely compatible with these goals. A number of previously developed cryptographic storage techniques could be applied to achieve some degree of privacy in SUNDR, e.g. <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b0">1]</ref>. Extensive work has also been done on ensuring data availability in the face of disk and server failures. The fact that STORE RPCs can safely be reordered would make it easy to replicate the block server, while the consistency protocol already replicates the PVL and and VSL on clients. SUNDR also facilitates reliability by storing long-lived data in an append-only log, making the server amenable to backup on write-once media and incremental transfer to off-site replicas. Because the server is not trusted, a damaged file system can be reconstructed from all available sources of data, including file caches on untrusted clients.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">File system implementation</head><p>Figure <ref type="figure" target="#fig_0">4</ref> shows the overall architecture of the SUNDR implementation. The client is implemented at user level, using a modified version of the xfs device driver from the ARLA <ref type="bibr" target="#b26">[28]</ref> file system on top of a slightly modified FreeBSD kernel. Server functionality is divided between a consistency server and a block server. The consistency server implements the UPDATE and COMMIT RPCs described in the previous section. The only file system data it ever sees are the i-handles embedded in version structures.</p><p>Most file system data is stored on the block server. The block server is a user-level program that reads and writes raw disks through character devices so as to manage its own cache and control the order in which writes go to disk. The interface primarily consists of three RPCs, STORE, RETRIEVE, and DECREF. STORE stores a block of data at the server. RETRIEVE takes a SHA-1 hash as an argument and returns a block with that hash (assuming one has been stored). DECREF informs the server that the client will no longer attempt to retrieve a particular SHA-1 hash, so that the server can discard the corresponding block if no one else has stored it. A few less fundamental RPCs are not shown in Figure <ref type="figure" target="#fig_0">4</ref>-for instance to support authenticated communication so that an attacker cannot impersonate the block server and begin discarding newly stored blocks.</p><p>The remainder of this section describes the implementation of the client and consistency server, and explains how we optimized the SUNDR protocol to make the file system perform acceptably. The next section gives the details of our high-performance block server implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">File system client</head><p>The xfs device driver used by SUNDR is designed for whole-file caching. When a file is opened, xfs makes an upcall to the SUNDR client asking for the file's data. The client returns the identity of a local file that has a cached copy of the data. All reads and writes are performed on the cached copy, without further involvement of SUNDR. When the file is closed (or flushed with fsync), if it has been modified, xfs makes another upcall asking the client to write the data back to the server. Several other types of upcalls allow xfs to look up names in directories, request file attributes, create/delete files, and change metadata.</p><p>As distributed, xfs's interface posed two problems for SUNDR. First, xfs caches information, such as local file bindings, which it uses to satisfy some requests without upcalls. In SUNDR, some of these requests require interaction with the consistency server for the security properties to hold. We therefore modified xfs to invalidate its cache tokens immediately after getting or writing back cached data, so as to ensure that the user-level client gets control whenever the protocol requires an UPDATE RPC. Second, some system calls that should require only a single interaction with the SUNDR consistency server result in multiple kernel vnode operations and xfs upcalls. For example, the system call "stat ("a/b/c", &amp;sb)" results in three xfs GETNODE upcalls (for the directory lookups) and one GETATTR. The whole system call should require only one UPDATE RPC. Yet if the user-level client does not know that the four upcalls are on behalf of the same system call, it must check the freshness of its ihandles four separate times with four UPDATE RPCs.</p><p>To eliminate unnecessary RPCs, we modified the FreeBSD kernel to keep a count of the number of invocations of system calls that might require an interaction with the consistency server. We increment the counter at the start of every system call that takes a pathname as an argument (e.g., stat, open, readlink, chdir). The SUNDR client memory maps this counter and records the last value it has seen. If xfs makes an upcall that does not change the state of the file system and the counter has not changed, then the client can use its cached copies of all i-handles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Protocol optimizations</head><p>Any implementation of the SUNDR protocol faces a number of potential performance bottlenecks. Digital signatures can be costly to compute and verify, yet are on the critical path for every RPC to the consistency server. Recomputing hash trees for every file system modification is expensive and requires large amounts of bandwidth and storage from the block server. Group i-tables in particular are expensive to update, as different users must transfer new hash nodes back and forth through the block server, and a new i-table could potentially force clients to flush their name caches.</p><p>The first requirement for decent performance was to reduce the cost of digital signatures in SUNDR. Our implementation does so in three ways-by choosing an efficient signature algorithm, by reducing the total number of signatures required, and by moving signatures and verifications out of the critical path wherever possible. We chose the Esign <ref type="bibr" target="#b16">[18]</ref> signature algorithm for SUNDR because it is over an order of magnitude faster than more popular schemes such as RSA. While there are no known attacks on the version of Esign we are using, a flaw was recently found in its proof of security and a better variant proposed <ref type="bibr" target="#b9">[11]</ref> with a correct proof. We intend to switch to the newer variant. All experiments reported in this paper use 2,048-bit public keys, which require a work factor of well over 2 80 to break using the fastest known algorithms.</p><p>To get verification out of the critical path, the consistency server also processes and replies to an UPDATE RPC before verifying the signature on its update certificate. If the signature fails to verify, the server reverts any effects of the RPC (before other clients can see them) and drops the TCP connection to the forging client. This behavior is acceptable because only a faulty client would forge signatures. With this optimization, the consistency server's ver-ification of one signature overlaps with the client's computation of the next.</p><p>The second class of optimizations reduces the cost of processing i-table hash trees. First, because group i-tables are particularly expensive to modify, SUNDR minimizes the number of times group i-handles change through a level of indirection; group i-table entries map to user itable entries which map to i-hashes. Thus, a group ihandle doesn't change when a group-writable file or directory is modified multiple times by the same user, a common case. When creating group-writable files, clients pre-allocate group i-numbers in batches, pointing them to unused ranges of user i-nodes. 256 group i-numbers can be pre-allocated with a single delta in an update certificate.</p><p>As a further optimization for both user and group itables, SUNDR avoids recomputing i-handles on every update. Instead, it specifies a principal's i-table with two hashes embedded in version structures-an i-handle, which is still the root of a hash tree, and a log hash, which is the SHA-1 hash of a vector of deltas to be applied to state of the hash tree. The COMMIT RPC takes a log as well as a version structure, and the UPDATE RPC returns a log for each i-handle. Clients only periodically compute new i-handles to clear the log hash.</p><p>Log hashes have a number of benefits. They amortize computation of new i-handles over many updates. They save bandwidth to the block server by requiring fewer hash tree blocks to be stored. For group i-tables, they allow one client to apply another's update certificate deltas without fetching any blocks from the server. Most importantly, they allow clients to validate cached information without fetching i-table blocks from the server. Both name cache entries and cached file contents are valid so long as the relevant i-handles haven't changed and the particular file is not affected by any deltas in the hashed log. Bandwidth to the consistency server could also be considerably reduced. UPDATE RPCs currently return the entire VSL and PVL. However, a client will generally already have many of the entries in these lists. The consistency server should therefore return only VSL and PVL entries that changed since the last UPDATE reply it has sent to a particular client. Similarly, both UPDATE replies and COMMIT RPCs currently send the entire delta log with each i-handle, when only new entries need be sent. Even version structures need not be sent in their entirety, as most of their content other than i-handles is implicit in the order of PVL entries and the groups they affect. On systems with many users, the messages exchanged with the consistency server should be proportional in size to the number of active users and groups, while currently they are proportional to the total number of principals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Future optimizations</head><p>Another class of possible optimizations target the block server. SUNDR currently breaks files into fixed-size 8K blocks, stores the blocks at the block server, and puts their SHA-1 hashes into inode and indirect block data structures. Because the block server handles variable-sized blocks efficiently, the client could compress blocks before sending, saving both network bandwidth and storage at the server. Moreover, recent work <ref type="bibr" target="#b15">[17]</ref> suggests that by breaking files into carefully-constructed variable-sized blocks, one can increase the number of blocks common across files. Such commonality would reduce the number of block transfers needed, save space at the block server, and furthermore increase the effectiveness of the block server's cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Block server implementation</head><p>In SUNDR, all data and most metadata are stored on and retrieved from the block server, called bsrv. bsrv presents clients with an extremely simple interface. Clients send the server data blocks and later retrieve them by SHA-1 hash. Since the client actually implements most file system functionality, the block server cannot interpret or prioritize blocks. Moreover, the server does not have any user signature keys, and thus does not even have permission to repair the file system should something go wrong. Thus, while traditional file systems write many types of data asynchronously, crash recoverability requires that bsrv write every block to stable storage before returning to the client. In addition, block server performance is critical to good file system performance in SUNDR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Background: Venti</head><p>bsrv is certainly not the first content-hash-based block server. In fact, bsrv's design takes its inspiration from the Venti <ref type="bibr" target="#b17">[19]</ref> block server. Venti appends variable-sized blocks sequentially to a large log disk or RAID array, and then indexes them by SHA-1 hash on a fast SCSI disk. An index entry is stored in a logical block on disk determined entirely by the SHA-1 hash. Overflow entries in Venti spill over onto the next block. Venti provides archival storage, i.e., it never deletes blocks. The authors argue that it nonetheless can be used to build a regular file system, because storage capacities are increasing faster than users can generate data. We agree with this assessment, and have likewise designed bsrv to be an archival block server. In the future, we envisage support for snapshots, allowing SUNDR users to access previous versions of the file system. Archival storage would easily allow such functionality.</p><p>Whereas we follow Venti's general design, we argue that it has drawbacks that make it ill-suited for SUNDR. In particular (1) it buffers writes so it cannot guarantee data stability (2) it is strictly archival and hence would store many short-lived blocks such as i-table hash tree nodes in perpetuity and (3) it can achieve only 5-7 MBytes/sec of write throughput, while we desire a block server capable of absorbing data at fast Ethernet rates. To overcome these problems, bsrv introduces a temporary log to Venti's original design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">bsrv architecture</head><p>Figure <ref type="figure" target="#fig_1">5</ref> shows bsrv's general architecture. The block server requires at least three disks, a large log disk (or RAID array), a small temporary log disk, and one or more index disks. As an example configuration, this paper reports on a server that uses high-capacity IDE disks for the log and temporary log, while striping the index over four fast SCSI disks.</p><p>bsrv accesses disks through the raw character device interface. Because Unix devices have a blocking interface, it uses a number of helper processes to issue concurrent I/O requests, thereby keeping multiple disks busy and enjoying better disk scheduling through SCSI tagged command queuing on the index disks. bsrv spawns four instances of the helper program, called aiod, for each disk on the system. It communicates with them through large regions of shared memory. Each group of four aiods also listens on a pipe. To initiate an I/O, bsrv writes to the appropriate pipe an 8-byte pointer to a command block in shared memory. When the I/O is complete, aiod writes the status into the command block and notifies bsrv by sending the command block's address back over a Unixdomain socket. In order to avoid waking up four kernellevel threads each time bsrv writes to a pipe, the aiod processes use an flock lockfile to ensure only one process at a time blocks reading a given pipe. (flock is specifically implemented to avoid waking threads up unnecessarily.)</p><p>The bsrv interface consists of the following five RPCs: STORE (header,block) RETRIEVE (hash) DECREF (hash) CSTORE (hash) PSTORE (header, block)</p><p>The STORE RPC takes a data block preceded by a block header and writes them both to stable storage if the server does not already have a copy of the block. The header has information encapsulating the owner and creation time of the block, as well as fields that could be used to store the encoding method and decoded length of compressed blocks. The RETRIEVE RPC retrieves a block from the server given its SHA-1 hash. It also returns the first header STOREd with the particular block. DECREF informs the server that a block with a particular SHA-1 hash is no longer needed and can be discarded. bsrv's dereferencing semantics are conservative. When a block is first STOREd, the server establishes a short window (one minute by default) during which it can be deleted. If a client STOREs then DECREFs a block within this window, the server marks the block as garbage and does not permanently store it. If two clients store the same block during the dereference window, the block is also marked as permanent. Once a block has been marked permanent, it can never be deleted from the block server.</p><p>Two more RPCs exist that are not currently used by the SUNDR client. CSTORE, short for "conditional store," functions like a read that doesn't return the data-it simply tells the client whether or not the server is storing a block with a particular SHA-1 hash. In addition, any CSTOREd block is automatically marked permanent. A client could use this RPC to save bandwidth when storing blocks that are likely to exist already at the server.</p><p>Internally, the block server has a function pstore ("permanent store") that bypasses the temporary log. We expose the pstore function through a PSTORE RPC for the purpose of testing and comparison. PSTORE functions like a store followed by a sync in Venti, and thus is useful for quantifying the benefits of bsrv's temporary log. The RPC is not intended to be called by clients.</p><p>We now describe how bsrv uses its disks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Temporary Log</head><p>When a client issues a STORE RPC, the server will immediately store the given block to the temporary log subsystem. In our implementation, this subsystem comprises a small raw partition on an IDE disk, and an in-memory cache that mirrors the contents of the temporary log. By the time it responds to the RPC, the server has either written the block to the temporary log disk or located a copy of the block on a disk in the system, thus guaranteeing durability in the event of a crash. Keeping a redundant copy of the block in memory assures us that we need to read from the temporary log only to support crash recovery.</p><p>Assuming the temporary log disk does not serve requests generated by other processes, it need rarely seek. Rather, an overwhelming portion of disk traffic will be sequential writes, thus enjoying the same performance characteristics as a database log. We should note that all writes to the temporary log are aligned along sector boundaries. This wastes, on average, half a sector of disk space per block. The space overhead is of little concern given that the server continually recycles the temporary log and that the temporary log is very small relative to the capacity of modern IDE disks. Aligning writes to sector boundaries avoids the need for successive writes of the same sector, which the operating system cannot issue concurrently and which therefore cost a disk rotation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Permanent Log</head><p>The server periodically processes the temporary log, aging out those blocks that have exceeded their dereference window. If a block has been dereferenced but not accessed in any other way, the server will delete the block from the temporary log, being certain not to enter the block into any of the various caching systems. Otherwise, the server pstores the block. pstore will write a block to the permanent log provided that the block does not already exist on the server. Blocks are organized in the permanent log sequentially along 4-byte boundaries to optimize storage density. Once a block is written to the permanent log, it is read-only and immutable.</p><p>Since the server processes the temporary log in batches, it will write blocks to the permanent log in batches. For a batch that consists of n blocks, the server will usually require only nb/m sequential writes to the log disk, where b is the average block size, and m is the maximum write size. On our system, b = 8K and m = 64K, thus we need only write to disk once every 8 blocks.</p><p>Our server uses a large raw IDE hard disk for its permanent log. The log subsystem also includes an LRU cache. We store blocks into this cache if they have been redundantly stored. A redundant store is a good cue that a block is common to multiple files; caching these blocks can save random seeks on the permanent log IDE drive during RE-TRIEVEs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Index</head><p>The index subsystem serves to locate blocks on the permanent log, keyed by their SHA-1 hashes. An ideal index would be a simple in-memory hash table mapping 20-byte SHA-1 hashes to an 8-byte disk offset. If we assume that the average block stored on the system is 8K, we see that the index must have roughly 1/128 the capacity of the log disk. Although at present, such a ratio of disk to memory is obtainable with commodity components, we are not convinced that memory will be able to maintain such a ratio with hard disks in the future.</p><p>Instead, we adopt Venti's strategy of implementing the index as a disk-resident hash table, striped over an array of high-speed SCSI disks. We hash 20-byte SHA-1 hashes down to index-disk-id, index-disk-offset pairs. The disk offsets point to sector-sized on-disk data structures called buckets, which contain 15 index-entries, sorted by SHA-1 hash. index-entries, in turn map SHA-1 hashes to offsets on the permanent data log.</p><p>The server might access the index subsystem during PSTORE, CSTORE, and RETRIEVE. Assuming the server has not found the requested block in the temporary log or the block LRU cache, it will look up the block's SHA-1 hash in the index. If it finds the hash in the index, it will trigger an immediate RPC response to PSTORE and CSTORE. In the case of RETRIEVE, it will then access the index-entry to find the block's location on the permanent log, read and then return the block to the client. If the server does not find the hash in the index, it will, in the case of PSTORE, write the block to the permanent log and then update the index to reflect where the block was stored, using quadratic hashing when index blocks overflow. In the case of CSTORE, the server will respond false to the RPC. In the case of RETRIEVE, the server will reply that the block was not found.</p><p>As the server receives CSTORE, RETRIEVE and PSTORE RPCs from the client, it should expect a random ordering of SHA-1 hashes. Thus, each RPC will require one random seek across an index disk, and a PSTORE that is storing a block not already on the system will need two. We use caching and striping to mitigate the effects of this bottleneck. After the server accesses or updates an indexentry, it will store it in an LRU cache. Furthermore, striping the index across multiple disks allows concurrency among lookups and limits the amount of space needed on each disk, hence shortening the range over which the index disks heads need to seek.</p><p>Unlike Venti, we do a large majority of our stores via STORE and the temporary log; therefore, we can make a much more efficient use of the index subsystem. Before moving a batch of blocks from the temporary log to the permanent log, the server sorts them by index-disk-offset. That is, we map each block to a SHA-1 hash, each SHA-1 hash to a bucket offset, and sort. As a result, the index disk arms can service a whole batch of index reads in one sweep. We use the same technique for scheduling lazywrites to the index disk after we have written a block to the permanent log disk. Despite the sorting of block batches, the server ensures that blocks are stored on the log in the order in which they arrived. Randomly reordering blocks would be detrimental to read performance for large multiblock files.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Crash Recovery</head><p>To recover from a crash or an unclean shutdown, the system first assures the consistency of the permanent log and index subsystems. Because the server updates the index lazily after storing blocks to the permanent log, a fair number of unwritten index entries and hence out-of-date buckets may exist. Finally, bsrv process the temporary log by pstoreing all its blocks to the permanent log.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Design Discussion</head><p>Our system differs from Venti mainly in our use of a temporary log subsystem and our preference of STORE over PSTORE. This architecture conveys several advantages in our application context:</p><p>Durability. When a close command returns in our case, the blocks of that file are on disk, albeit usually on the temporary log.</p><p>Dereferencing. The temporary log allows our server to dereference blocks within a minute of their creation. Because many files are short-lived, this saves space on the permanent log and eliminates disk accesses to both the index disk and the permanent log disk.</p><p>Fast Log Alignment. The temporary log allows us to write blocks continuously when copying to the permanent log. This saves space but also time. For example, suppose a system has 512-byte sectors and an application writes two 1000 byte blocks. In order to achieve good packing, a Venti-style system would have to do two writes to the second sector, at some cost in rotation time. Ours requires only one.</p><p>Index Disk Arm Scheduling. Writing blocks to the permanent log in large groups allows us to sort our accesses to the index disk thus minimizing the length of seeks.</p><p>The net result is the semantic benefit of durability with file-system-like throughput rates (e.g., 11MB/sec), a significant improvement on Venti.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Performance</head><p>Our primary goal in testing SUNDR was to ensure that its security benefits do not come at too high a price. In this section, we compare SUNDR's overall performance to NFS. We also perform microbenchmarks to help explain our application-level results, and to support our claims that our block server outperforms a Venti-like architecture in our setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>We carried out our experiments on three 3GHz Pentium IVs running FreeBSD 4.7. All machines are connected with 100Mbit, full-duplex, switched Ethernet. We measured TCP throughput between clients at 11.21 MBytes/sec, and round-trip times at 0.110 msec. All machines have 3GB of RAM and Seagate Cheetah 18GB SCSI hard drives, which spin at 15K RPM. We used four of these drives in our block server as index disks, and added 2 Western Digital Caviar 180GB 7200 RPM EIDE hard drives for temporary and permanent log disks.</p><p>Our cryptographic implementations use GNU Multiprecision Library version 4.1.2 for large integer arithmetic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Microbenchmarks</head><p>We perform a series of microbenchmarks on both the SUNDR block server, the SUNDR client, and the combined system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">SUNDR Block Server</head><p>Our SUNDR block server currently can store up to 175GB of data, but in our experimental setup, we partitioned our index disks so that we could comfortably accommodate up to 2TB of data. That is, for every 8K block stored on the server, we require approximately 64 bytes of space on the index disks. An index entry only takes up around 32 bytes of disk space, but we would expect performance to degrade if the index becomes more than half full. Thus, our index array must have a capacity of 2 41 2 6 /2 13  We did not heavily tune the block server, choosing its parameters somewhat arbitrarily. We allow SUNDR clients to make up to 40 outstanding RPCs. This is both for flow control and fairness. We set our dereference window to 60 seconds, and for the purposes of the microbenchmarks, we turned off the block cache. Throughout, we enable an index entry cache of up to 100,000 entries. Our temporary log is 720MB, circularly processed, and never filled up in the course of experiments. Over 100 Mbit Ethernet, the SUNDR block server can process the temporary log as fast as blocks can be sent over the network.</p><p>Figure <ref type="figure" target="#fig_2">6</ref> shows our measurements of the block server's throughput and latency. Recall that if we were to simply use Venti's architecture and did not have the benefit of the temporary log, we would use PSTORE and not STORE. These results legitimize our improvements: in terms write throughput, STORE outperforms PSTORE by 106%. For batches of data that can be transmitted in an amount of time less than the dereference window, the write throughput is limited only by the network bandwidth. For very large block batches, the server will start to process the temporary log while the client is still transmitting data. The server can processes the temporary log from its inmemory memory at 11.72 MBytes/s. However, the operation places demands on the CPU, thereby reducing the bandwidth observed by SUNDR clients. We see a 17% decrease in write throughput while the server is processing the temporary log. Even under these conditions, STORE still outperforms PSTORE by 72%.</p><p>In terms of write latency, STORE performs significantly better than PSTORE, responding to RPCs in 23% of the time it takes for a PSTORE under quiescent conditions, and 29% when simultaneously processing the temporary log.</p><p>Our block server does not perform well when asked to RETRIEVE randomly scattered blocks. Note that the Index LRU cache is of little help. The bottleneck is the IDE log disk, which is slow to make random seeks; Venti has a similar bottleneck. In the context of SUNDR, slow random RETRIEVEs should not affect overall system performance if the client aggressively caches blocks and reads large files sequentially. Figure <ref type="figure">7</ref>: From the client's perspective, a timeline of procedure calls for creating, reading, and unlinking a 1K file on SUNDR, in msecs. Bars represent procedure call durations; they begin when a procedure was called and end when it returns. Calls on the left side of the axes are RPCs to the block server. Calls on the right side are involved with file system consistency, and are either RPCs to the consistency server or local signatures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Client Profiling</head><p>We next performed a high-level profile of the SUNDR client, so as to better understand our other micro and macrobenchmarks. Figure <ref type="figure">8</ref> shows the performance of our underlying signature scheme in comparison to the more conventional Rabin scheme <ref type="bibr" target="#b18">[20]</ref>. We use 2,048 bit Esign keys in SUNDR, which can be broken with a work factor greater than 2 80 . In other words, an adversary with infinite storage could more easily find a SHA1 hash collision than break a 2,048 bit Esign key. We also provide benchmarks for 6,000 bit keys, which can be broken with a work factor of 2 128 <ref type="bibr" target="#b9">[11]</ref>.</p><p>Figure <ref type="figure">7</ref> provides a representation of how SUNDR's RPCs and signatures correspond with Unix system calls. The three cases shown correspond to file phases of the LFS small file benchmark <ref type="bibr" target="#b21">[23]</ref>. The timings were collected by inserting gettimeofday system calls in the code, and thus reflect a small amount of time dilation from measurement overhead.</p><p>The create phase calls the open, write and close system calls. This figure verifies that close can only return once its STORE call to the block server has returned-hence the importance of minimizing the latency of RPC STORE calls. The write call does not involve any remote RPCs or cryptographic operations; for this reason it is not shown in Figure <ref type="figure">7</ref>.</p><p>The read phase makes open, read and close calls. In this experiment, almost all of the expensive operations are handled in the open call. Since xfs does not currently support chunked file retrieves, SUNDR fetches the entirety of the file at the open call. However, our experiments assume a warm client-side cache, so no RETRIEVE calls actually went through to the server. Finally, the unlink phase consists only of a system call to unlink.</p><p>Figure <ref type="figure">7</ref> shows our prototype's efforts to interleave RPCs and to delay those not on the critical path until after returning to the user-level caller. We see that system calls do not wait for COMMIT RPCs to return. Moreover, even in small writes, the client sends data blocks to the block store concurrently, and waits for them to return only in the case of close and fsync. This increases concurrency without compromising our consistency guarantees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">LFS Small File Benchmark</head><p>Next, we ran our system using the LFS small file benchmark and measured end-to-end performance. Before doing so, we made a slight adjustment to the benchmark suite, and randomized the contents of the files written to disk. To write identical files would give SUNDR's block store architecture an unfair advantage, as only one unique file data block would ever need to be stored. In this and other benchmarks, we compare SUNDR to NFSv2 and NFSv3. Indeed, NFSv3 offers better performance, but NFSv2's semantics guarantee that a client's data has been written to stable storage on close. Since SUNDR offers the same guarantee, we believe a comparison to NFSv2 is a fairer one; we include results for NFSv3 regardless. Figure <ref type="figure" target="#fig_3">9</ref> details our results. SUNDR significantly outperforms NFSv2 in the create and unlink stages of the experiment-by 30% and 18% respectively. SUNDR is noticeably slower in the read phase, primarily because of latency introduced by the consistency protocol. In particular, open must wait for UPDATE to return before returning to the caller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Application-Level Benchmarks</head><p>Figure <ref type="figure" target="#fig_4">10</ref> shows SUNDR's performance in copying, uncompressing, untarring, configuring, compiling, installing, and removing the Apache webserver distribution (apache 1.3.27.tar.gz). We first note that during the experiment, bsrv processed 16,872 8K data blocks, of which 8,023 (48%) were dereferenced before they could be committed to the permanent log. The configure, compile and untar operations in particular involve many temporary files and sequential changes to filesystem metadata. Thus, in these benchmarks, clients frequently DE-CREF blocks within milliseconds of STOREing them.</p><p>SUNDR is competitive with NFSv2 in copying the source archive from local disk to the SUNDR partition; it completes this operation in 110 msecs, while NFSv2 does the same in 87 msecs. NFSv3 actually performs slower at this stage, completing the cp in 199 msecs. SUNDR's performance is similar to NFSv2's in the unzip, untar, compile and cleanup portions of the build process. The config and install segments clearly present a problem for us. We see several explanations for this. Most intuitively, many operations in these procedures reference the file system three times: once to load an executable shell script in the build directory, once to read an input file, and once to store to an output file. At the very least, we are experiencing a two-fold magnification of the read bottleneck seen in the LFS small file benchmark. Moreover, our current implementation of SUNDR does not handle concurrent xfs upcalls optimally. Our prototype sometimes serializes these requests for convenience.</p><p>In sum, we are encouraged by these results. Our experiments have shown SUNDR to be almost as fast as totally insecure network file systems when writing large amounts of data and files to the file system. We believe that our approach is fundamentally sound, and that future optimizations and design improvements will make SUNDR more competitive in all of these benchmarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Recently, there has been growing interest in peer-to-peer storage systems comprised of potentially untrusted nodes. Farsite <ref type="bibr" target="#b1">[2]</ref> investigated the possibility of spreading such a file system across people's unreliable desktop machines. Several new distributed hash tables such as Chord <ref type="bibr" target="#b24">[26]</ref> and Pastry <ref type="bibr" target="#b22">[24]</ref> show the potential to scale to millions of separately administered volunteer nodes, with CFS <ref type="bibr" target="#b4">[5]</ref> layering a read-only file system on top of such a highly distributed architecture. These systems could potentially replace the SUNDR block server, provide automated offsite backup, or be used to coordinate cooperative caching amongst mutually distrustful clients.</p><p>A number of file systems in the past have used cryptographic storage to keep data secret in the event of a server compromise. The swallow <ref type="bibr" target="#b19">[21]</ref> distributed file system used client-side cryptography to enforce access control. Clients encrypted files before writing them to the server. Any client could read any file, but could only decrypt the file given the appropriate key. Unfortunately, one could not grant read-only access to a file. An attacker with read access could, by controlling the network or file server, substitute arbitrary data for any version of a file.</p><p>CFS <ref type="bibr" target="#b0">[1]</ref> allows users to keep directories of files that get transparently encrypted before being written to disk. CFS does not allow sharing of files between users, nor does it guarantee freshness or integrity of data. It is intended for users to protect their most sensitive files from prying eyes, not as a general-purpose file system. Cepheus <ref type="bibr" target="#b6">[8]</ref> adds integrity and file sharing to a CFS-like file system, but trusts the server for the integrity of read-shared data. SNAD <ref type="bibr" target="#b14">[16]</ref> can use digital signatures for integrity, but does not guarantee freshness. PFS <ref type="bibr" target="#b23">[25]</ref> is an elegant scheme for checking the integrity of a file system stored on an untrusted disk. With minor modifications, PFS could make strong freshness guarantees. However, PFS is really a local file system designed to reside on untrusted, potentially remote disks. Users on multiple clients cannot simultaneously access the same file system. Plutus <ref type="bibr" target="#b10">[12]</ref> is secure file sharing system for untrusted storage which focuses primarily on data secrecy. The authors vaguely mention some ideas for protecting integrity, but have not implemented them and do not have a proof of security. We suspect their system cannot provide consistency.</p><p>The Byzantine fault-tolerant file system, BFS <ref type="bibr" target="#b2">[3]</ref>, uses replication to ensure the integrity of a network file system. As long as more than 2/3 of a server's replicas are uncompromised, any data read from the file system will have been written by a legitimate user. SUNDR, in contrast, does not require any replication or place any trust in machines other than a user's client. If data is replicated in SUNDR, only one replica need be honest for the file system to function properly. However, SUNDR provides weaker freshness guarantees than BFS, because of the possibility that a malicious SUNDR server can fork the file system state if users have no other evidence of each other's on-line activity.</p><p>Pond <ref type="bibr" target="#b20">[22]</ref> is a prototype of the OceanStore system, a large-scale data store that offers certain consistency and privacy guarantees. Pond trusts an "inner core" of Byzantine fault-tolerant servers to reliably order user file operations. Pond uses "heartbeat" messages, distributed throughout a peer-to-peer network of "secondary replicas," to convey a loose notion of file freshness to its clients. If a client desires a stronger assurance of a file's freshness, it must ask the inner core of servers to sign a cryptographic nonce. Like BFS, this provides stronger freshness than SUNDR can achieve without online trusted parties. However, signatures are very expensive for the servers in OceanStore, considering they must generate a threshold signature, which the authors report consumes an order of magnitude more computational time than a conventional signature. Pond cannot very well increase the number of core servers to distribute load amongst more servers, as this will only make matters worse: the complexity of its consistency protocol is quadratic in the number of primary servers. In SUNDR, by contrast, the consistency server only verifies signatures. File consistency is provably guaranteed by the clients, who sign with a standard and computationally practical signature scheme.</p><p>SUNDR uses hash trees, introduced in <ref type="bibr" target="#b13">[15]</ref>, to verify a file block's integrity without touching the entire file system. Duchamp <ref type="bibr" target="#b5">[6]</ref>, BFS <ref type="bibr" target="#b2">[3]</ref>, SFSRO <ref type="bibr" target="#b7">[9]</ref> and TDB <ref type="bibr" target="#b11">[13]</ref> have all made use of hash trees for comparing data or checking the integrity of part of a larger collection of data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>SUNDR is a general-purpose, multi-user network file system that never presents applications with incorrect file system state, even when data is stored on an untrusted server. SUNDR's protocol provably guarantees data integrity and consistency without assuming any on-line trusted parties. By reducing the amount of trust required for file servers, SUNDR both increases people's options for managing data and improves their file security. Performance measurements of our implementation show that while SUNDR's security comes at a cost, the protocol is still practical. Our prototype implementation gives performances within a reasonable factor of NFS and will most likely improve significantly as we implement proposed optimizations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Implementation overview</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Finally, we mentionFigure 5 :</head><label>5</label><figDesc>Figure 5: Block server architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>STOREFigure 6 :</head><label>6</label><figDesc>Figure6: Throughput and latencies for the SUNDR block server. Throughputs were collected over 10,000 asynchronous operations on 8K blocks, with 40 outstanding RPCs. Latencies were collected over 5,000 back-to-back synchronous operations on 8k blocks. The block cache was cold in all experiments.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: LFS Small File Benchmark. 1000 operations on files with 1K of random content.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Installation procedure for apache 1.3.27.tar.gz.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Figure 1: Basic SUNDR data structures. An i-handle is the root of a hash tree containing a user or group i-table.</figDesc><table><row><cell>user u 2 's</cell><cell></cell></row><row><cell>i-handle</cell><cell></cell></row><row><cell>H</cell><cell>inode i 4</cell></row><row><cell></cell><cell>block d 0</cell></row></table><note>* (t u2 ) user u 2 's i-table (t u 2 ) group g's i-table (t g ) A group i-table maps group inode numbers to user inode numbers. A user i-table maps a user's inode numbers to i-hashes. An i-hash is the hash of an inode, which in turn contains hashes of file data blocks.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>1. x n = {n, H(y n‚àí1 ), ‚àÜ 0 ‚àÜ 1 . . .} K ‚àí1</figDesc><table><row><cell>Client</cell></row><row><cell>UPDATE</cell></row><row><cell>u</cell></row><row><cell>2. VSL + PVL</cell></row><row><cell>COMMIT</cell></row><row><cell>3. y n = {i-handles, vers#s, pending} K ‚àí1 u</cell></row><row><cell>Figure 3: SUNDR consistency protocol. The client de-</cell></row><row><cell>clares its intent to fetch or modify file system content with</cell></row><row><cell>a signed update certificate. The server responds with the</cell></row><row><cell>latest version structure for each i-handle plus any pend-</cell></row><row><cell>ing update certificates. The client then computes new i-</cell></row><row><cell>handles and sends a signed version structure to the server.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>or</figDesc><table><row><cell></cell><cell>Rabin</cell><cell></cell><cell>Esign</cell><cell></cell></row><row><cell></cell><cell cols="4">1,024 bits 1,280 bits 2,048 bits 6,000 bits</cell></row><row><cell>Sign</cell><cell>3,656</cell><cell>6,424</cell><cell>169</cell><cell>695</cell></row><row><cell>Verify</cell><cell>27</cell><cell>34</cell><cell>120</cell><cell>575</cell></row><row><cell cols="5">Figure 8: Sign and verify times, in ¬µsecs</cell></row><row><cell cols="5">16GB to meet out storage needs. Given our 4 disk index</cell></row><row><cell cols="5">array, we need only use 4GB of each disk to accommodate</cell></row><row><cell>the index.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">More precisely, if user A sees the effect of an operation user B performed at time t, then, at least until t, A and B had close-to-open consistency with respect to each other. Moreover, anyone who sees a subsequent operation by A must also have had close-to-open consistency with respect to B until t.</note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported by National Science Foundation CAREER award CCR-0093361 and by the Defense Advanced Research Projects Agency (DARPA) and the Space and Naval Warfare Systems Center, San Diego, under contract N66001-00-1-8927.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A cryptographic file system for unix</title>
		<author>
			<persName><forename type="first">Matt</forename><surname>Blaze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1st ACM Conference on Communications and Computing Security</title>
				<imprint>
			<date type="published" when="1993-11">November 1993</date>
			<biblScope unit="page" from="9" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Feasibility of a serverless distributed file system deployed on an existing set of desktop pcs</title>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">J</forename><surname>Bolosky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">R</forename><surname>Douceur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Ely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marvin</forename><surname>Theimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMETRICS</title>
				<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="34" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Practical byzantine fault tolerance</title>
		<author>
			<persName><forename type="first">Miguel</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barbara</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Symposium on Operating Systems Design and Implementation</title>
				<meeting>the 3rd Symposium on Operating Systems Design and Implementation<address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-02">February 1999</date>
			<biblScope unit="page" from="173" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Detection of mutual inconsistency in distributed systems</title>
		<author>
			<persName><forename type="middle">D</forename><surname>Jr</surname></persName>
		</author>
		<author>
			<persName><surname>Stott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><forename type="middle">J</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerard</forename><surname>Popek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Allen</forename><surname>Rudisin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><forename type="middle">J</forename><surname>Stoughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evelyn</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johanna</forename><forename type="middle">M</forename><surname>Walton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><surname>Kiser</surname></persName>
		</author>
		<author>
			<persName><surname>Kline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering, SE</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="240" to="247" />
			<date type="published" when="1983-05">May 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Wide-area cooperative storage with cfs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Frans</forename><surname>Frank Dabek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Symposium on Operating Systems Principles</title>
				<meeting>the 18th ACM Symposium on Operating Systems Principles<address><addrLine>Chateau Lake Louise, Banff, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001-10">October 2001</date>
			<biblScope unit="page" from="202" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A toolkit approach to partially disconnected operation</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Duchamp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1997 USENIX</title>
				<meeting>the 1997 USENIX</meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="1997-01">January 1997</date>
			<biblScope unit="page" from="305" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Group sharing and random access in cryptographic storage file systems</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Fu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
		</imprint>
	</monogr>
	<note>Master&apos;s thesis, Massachusetts Institute of Technology</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fast and secure distributed read-only file system</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Frans</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mazi√®res</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Symposium on Operating Systems Design and Implementation</title>
				<meeting>the 4th Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Fast and secure distributed read-only file system</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Frans</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mazi√®res</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2002-02">February 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">How to repair esign</title>
		<author>
			<persName><forename type="first">Louis</forename><surname>Granboulan</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2002">2002/074, 2002</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Plutus: Scalable secure file sharing on untrusted storage</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kallahalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Riedel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Swaminathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd USENIX conference on File and Storage Technologies (FAST &apos;03)</title>
				<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-04">April 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">How to build a trusted database system on untrusted storage</title>
		<author>
			<persName><forename type="first">Umesh</forename><surname>Maheshwari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radek</forename><surname>Vingralek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Symposium on Operating Systems Design and Implementation</title>
				<meeting>the 4th Symposium on Operating Systems Design and Implementation<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-10">October 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Building secure file systems out of Byzantine storage</title>
		<author>
			<persName><forename type="first">David</forename><surname>Mazi√®res</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Shasha</surname></persName>
		</author>
		<idno>TR2002-826</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing</title>
				<meeting>the 21st Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing</meeting>
		<imprint>
			<date type="published" when="2002-05">July 2002. May 2002</date>
			<biblScope unit="page" from="108" to="117" />
		</imprint>
	</monogr>
	<note>The full version is available as NYU computer science department technical report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A digital signature based on a conventional encryption function</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ralph</surname></persName>
		</author>
		<author>
			<persName><surname>Merkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology-CRYPTO &apos;87</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Carl</forename><surname>Pomerance</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">293</biblScope>
			<biblScope unit="page" from="369" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Strong security for distributed file systems</title>
		<author>
			<persName><forename type="first">Ethan</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Darrell</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th IEEE International Performance, Computing, and Communications Conference</title>
				<meeting>the 20th IEEE International Performance, Computing, and Communications Conference<address><addrLine>Phoenix, AZ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-04">April 2001</date>
			<biblScope unit="page" from="34" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A low-bandwidth network file system</title>
		<author>
			<persName><forename type="first">Athicha</forename><surname>Muthitacharoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjie</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mazi√®res</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Symposium on Operating Systems Principles</title>
				<meeting>the 18th ACM Symposium on Operating Systems Principles<address><addrLine>Chateau Lake Louise, Banff, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001-10">October 2001</date>
			<biblScope unit="page" from="174" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A fast signature scheme based on quadratic inequalities</title>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Akira</forename><surname>Shiraishi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1985 IEEE Symposium on Security and Privacy</title>
				<meeting>the 1985 IEEE Symposium on Security and Privacy<address><addrLine>Oakland, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985-04">April 1985</date>
			<biblScope unit="page" from="123" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Venti: a new approach to archival storage</title>
		<author>
			<persName><forename type="first">Sean</forename><surname>Quinlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Dorward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First USENIX conference on File and Storage Technologies (FAST &apos;02)</title>
				<meeting><address><addrLine>Monterey, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Digitalized signatures and public key functions as intractable as factorization</title>
		<author>
			<persName><forename type="first">O</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><surname>Rabin</surname></persName>
		</author>
		<idno>TR-212</idno>
		<imprint>
			<date type="published" when="1979-01">January 1979</date>
		</imprint>
		<respStmt>
			<orgName>MIT Laboratory for Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Swallow: A distributed data storage system for a local network</title>
		<author>
			<persName><forename type="first">David</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liba</forename><surname>Svobodova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Local Networks for Computer Communications</title>
				<editor>
			<persName><forename type="first">A</forename><surname>West</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Janson</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>North-Holland Publ</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="355" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Pond: The OceanStore prototype</title>
		<author>
			<persName><forename type="first">Sean</forename><surname>Rhea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Eaton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Geels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd USENIX conference on File and Storage Technologies (FAST &apos;03)</title>
				<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-04">April 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The design and implementation of a log-structured file system</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ousterhout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th ACM Symposium on Operating Systems Principles</title>
				<meeting>the 13th ACM Symposium on Operating Systems Principles<address><addrLine>Pacific Grove, CA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1991-10">October 1991</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Pastry: Scalable, distributed object location and routing for large-scale peer-to-peer systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Middleware</title>
				<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Unifying file system protection</title>
		<author>
			<persName><forename type="first">Christopher</forename><forename type="middle">A</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">H</forename><surname>Howard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Margo</forename><forename type="middle">I</forename><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 USENIX. USENIX</title>
				<meeting>the 2001 USENIX. USENIX</meeting>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Chord: A scalable peer-to-peer lookup service for internet applications</title>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Frans</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hari</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGCOMM &apos;01 Conference</title>
				<meeting>the ACM SIGCOMM &apos;01 Conference<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-08">August 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Self-securing storage: Protecting data in compromised systems</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">D</forename><surname>Strunk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Garth</forename><forename type="middle">R</forename><surname>Goodson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">L</forename><surname>Scheinholtz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Craig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><forename type="middle">R</forename><surname>Soules</surname></persName>
		</author>
		<author>
			<persName><surname>Ganger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Symposium on Operating Systems Design and Implementation</title>
				<meeting>the 4th Symposium on Operating Systems Design and Implementation<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-10">October 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Arla-a free AFS client</title>
		<author>
			<persName><forename type="first">Assar</forename><surname>Westerlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johan</forename><surname>Danielsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1998 USENIX</title>
				<meeting>the 1998 USENIX<address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
	<note>Freenix track</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
