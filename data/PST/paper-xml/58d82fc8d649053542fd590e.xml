<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Motifs in Temporal Networks</title>
				<funder>
					<orgName type="full">Boeing</orgName>
				</funder>
				<funder ref="#_vvSxSkH">
					<orgName type="full">National Science Foundation</orgName>
					<orgName type="abbreviated">NSF</orgName>
				</funder>
				<funder ref="#_Sd9Hhsg">
					<orgName type="full">DARPA SIMPLEX</orgName>
				</funder>
				<funder>
					<orgName type="full">ARO MURI</orgName>
				</funder>
				<funder ref="#_YBj8yJf">
					<orgName type="full">Stanford Data Science Initiative</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ashwin</forename><surname>Paranjape</surname></persName>
							<email>ashwinpp@stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Austin</forename><forename type="middle">R</forename><surname>Benson</surname></persName>
							<email>arbenson@stanford.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Motifs in Temporal Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3018661.3018731</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Networks are a fundamental tool for modeling complex systems in a variety of domains including social and communication networks as well as biology and neuroscience. Small subgraph patterns in networks, called network motifs, are crucial to understanding the structure and function of these systems. However, the role of network motifs in temporal networks, which contain many timestamped links between the nodes, is not yet well understood.</p><p>Here we develop a notion of a temporal network motif as an elementary unit of temporal networks and provide a general methodology for counting such motifs. We define temporal network motifs as induced subgraphs on sequences of temporal edges, design fast algorithms for counting temporal motifs, and prove their runtime complexity. Our fast algorithms achieve up to 56.5x speedup compared to a baseline method. Furthermore, we use our algorithms to count temporal motifs in a variety of networks. Results show that networks from different domains have significantly different motif counts, whereas networks from the same domain tend to have similar motif counts. We also find that different motifs occur at different time scales, which provides further insights into structure and function of temporal networks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Networks provide an abstraction for studying complex systems in a broad set of disciplines, ranging from social and communication networks to molecular biology and neuroscience <ref type="bibr" target="#b20">[20]</ref>. Typically, these systems are modeled as static graphs that describe relationships between objects (nodes) and links between the objects (edges). However, many systems are not static as the links between objects dynamically change over time <ref type="bibr" target="#b8">[8]</ref>. Such temporal networks can be represented by a series of timestamped edges, or temporal edges. For example, a network of email or instant message communication can be represented as a sequence of timestamped directed edges, one for every message that is sent from one person to another. Similar representations can be used to model computer networks, phone calls, financial transactions, and biological signaling networks. * These authors contributed equally to this work.</p><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. WSDM '17, February 6-10, 2017, Cambridge, United Kingdom. While such temporal networks are ubiquitous, there are few tools for modeling and characterizing the underlying structure of such dynamical systems. Existing methods either model the networks as strictly growing where a pair of nodes connect once and stay connected forever <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b17">17]</ref> or aggregate temporal information into a sequence of snapshots <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b23">23]</ref>. These techniques fail to fully capture the richness of the temporal information in the data.</p><p>Characterizing temporal networks also brings a number of interesting challenges that distinguish it from the analysis of static networks. For example, while the number of nodes and pairs of connected nodes can be of manageable size, the number of temporal edges may be very large and thus efficient algorithms are needed when analyzing such data. Another interesting challenge is that patterns in temporal networks can occur at different time scales. For example, in telephone call networks, reciprocation (that is, a person returning a call) can occur on very short time intervals, while more intricate patterns (e.g., person A calling person B, who then calls C) may occur at larger time scales. Lastly, there are many possible temporal patterns as the order as well as the sequence of edges play an important role. Present work: Temporal network motifs. Here, we provide a general methodology for analyzing temporal networks. We define temporal networks as a set of nodes and a collection of directed temporal edges, where each edge has a timestamp. For example, Fig. <ref type="figure" target="#fig_0">1A</ref> illustrates a small temporal network with nine temporal edges between five ordered pairs of nodes.</p><p>Our analytical approach is based on generalizing the notion of network motifs to temporal networks. In static networks, network motifs or graphlets are defined as small induced subgraphs occurring in a bigger network structure <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b29">29]</ref>. We extend static mo-tifs to temporal networks and define ?-temporal motifs, where all the edges in a given motif M have to occur inside the time period of ? time units. These ?-temporal motifs simultaneously account for ordering of edges and a temporal window in which edges can occur. For example, Fig. <ref type="figure" target="#fig_0">1B</ref> shows a motif on three nodes and three edges, where the edge label denotes the order in which the edges appear. While we focus on directed edges with a single timestamp in this work, our methodology seamlessly generalizes to common variations on this model. For example, our methods can incorporate timestamps with durations (common in telephone call networks), colored edges that identify different types of connections, and temporal networks with undirected edges.</p><p>We then consider the problem of counting how many times does each ?-temporal motif occur in a given temporal network. We develop a general algorithm for counting temporal network motifs defined by any number of nodes and edges that avoids enumeration over subsets of temporal edges and whose complexity depends on the structure of the static graph induced by the temporal motif. For motifs defined by a constant number of temporal edges between 2 nodes, this general algorithm is optimal up to constant factors-it runs in O(m) time, where m is the number of temporal edges.</p><p>Furthermore, we design fast variations of the algorithm that allow for counting certain classes of ?-temporal motifs including star and triangle patterns. These algorithms are based on a common framework for managing summary counts in specified time windows. For star motifs with 3 nodes and 3 temporal edges, we again achieve a running time linear in the input, i.e., O(m) time. Given a temporal graph with ? induced triangles in its induced static graph, our fast algorithm counts temporal triangle motifs with 3 temporal edges in O(? 1/2 m) worst-case time. In contrast, any algorithm that processes triangles individually takes O(? m) worst-case time. In practice, our fast temporal triangle counting algorithm is up to 56 times faster than a competitive baseline and runs in just a couple of hours on a network with over two billion temporal edges.</p><p>Our algorithmic framework enables us to study the structure of several complex systems. For example, we explore the differences in human communication patterns by analyzing motif frequencies in text message, Facebook wall post, email and private online message network datasets. Temporal network motif counts reveal that text messaging and Facebook wall posting are dominated by "blocking" communication, where a user only engages with one other user at a time, whereas email is mostly characterized by "non-blocking" communication as individuals send out several emails in a row. Furthermore, private online messaging contains a mixture of blocking and non-blocking behavior.</p><p>Temporal network motifs can also be used to measure the frequency of patterns at different time scales. For example, the difference in ?-temporal motif counts for ? = 60 minutes and ? = 30 minutes counts only the motifs that take at least 30 minutes and at most 60 minutes to form. With this type of analysis, we find that certain question-and-answer patterns on Stack Overflow need at least 30 minutes to develop. We also see that in online private messaging, star patterns constructed by outgoing messages sent by one user tend to increase in frequency from time scales of 1 to 20 minutes before peaking and then declining in frequency.</p><p>All in all, our work defines a flexible notion of motifs in temporal networks and provides efficient algorithms for counting them. It enables new analyses in a variety of scientific domains and paves a new way for modeling dynamic complex systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Our work builds upon the rich literature on network motifs in static graphs, where these models have proved crucial to under-standing the mechanisms driving complex systems <ref type="bibr" target="#b19">[19]</ref> and to characterizing classes of static networks <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b29">29]</ref>. Furthermore, motifs are critical for understanding the higher-order organizational patterns in networks <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b4">4]</ref>. On the algorithmic side, a large amount of research has been devoted simply to counting triangles in undirected static graphs <ref type="bibr" target="#b14">[14]</ref>.</p><p>Prior definitions of temporal network motifs either do not account for edge ordering <ref type="bibr" target="#b30">[30]</ref>, only have heuristic counting algorithms <ref type="bibr">[7]</ref>, or assume temporal edges in a motif must be consecutive events for a node <ref type="bibr" target="#b13">[13]</ref>. In the last case, the restrictive definition permits fast counting algorithms but misses important structures. For example, many related edges occurring in a short burst at a node would not be counted together. In contrast, ?-temporal motifs capture every occasion that edges form a particular pattern within the prescribed time window.</p><p>There are several studies on pattern formation in growing networks where one only considers the addition of edges to a static graph over time. In this context, motif-like patterns have been used to create evolution rules that govern the ways that networks develop <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b24">24]</ref>. The way we consider ordering of temporal edges in our definition of ?-temporal motifs is similar in spirit. There are also several analyses on the formation of triangles in a variety of social networks <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b15">15]</ref>. In contrast, in the temporal graphs we study here, three nodes may form a triangle several times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PRELIMINARIES</head><p>We now provide formal definitions of temporal graphs and ?temporal motifs. In Section 4, we provide algorithms for counting the number of ?-temporal motifs in a given temporal graph. Temporal edges and graphs. We define a temporal edge to be a timestamped directed edge between an ordered pair of nodes. We call a collection of temporal edges a temporal graph (Fig. <ref type="figure" target="#fig_0">1A</ref>). Formally, a temporal graph T on a node set V is a collection of tuples (ui, vi, ti), i = 1, . . . , m, where each ui and vi are elements of V and each ti is a timestamp in R. We refer to a specific (ui, vi, ti) tuple as a temporal edge. There can be many temporal edges directed from u to v, and we refer to them as edges between u and v. We assume that the timestamps ti are unique so that the tuples may be strictly ordered. This assumption makes the presentation of the definitions and algorithms clearer, but our methods can easily be adapted to the case when timestamps are not unique. When it is clear from context, we refer to a temporal edge as simply an edge. Finally, by ignoring timestamps and duplicate edges, the temporal graph induces a standard directed graph, which we call the static graph G of T with static edges, i.e., (u, v) is an edge in G if and only if there is some temporal edge (u, v, t) in T . ?-temporal motifs and motif instances. We formalize ?-temporal motifs with the following definition. Definition. A k-node, l-edge, ?-temporal motif is a sequence of l edges, M = (u1, v1, t1), (u2, v2, t2) . . . , (u l , v l , t l ) that are timeordered within a ? duration, i.e., t1 &lt; t2 . . . &lt; t l and t l -t1 ? ?, such that the induced static graph from the edges is connected and has k nodes.</p><p>Note that with this definition, many edges between the same pair of nodes may occur in the motif M . Also, we note that the purpose of the timestamps is to induce an ordering on the edges. Fig. <ref type="figure" target="#fig_0">1B</ref> illustrates a particular 3-node, 3-edge ?-temporal motif.</p><p>The above definition provides a template for a particular pattern, and we are interested in how many times a given pattern occurs in a dataset. Intuitively, a collection of edges in a given temporal graph is an instance of a ?-temporal motif M if it matches the same edge pattern and all of the edges occur in the right order within the ? time window (Fig. <ref type="figure" target="#fig_0">1C</ref>). Formally, we say that any time-ordered sequence S = (w1, x1, t 1 ), . . . , (w l , x l , t l ) of l unique edges is an instance of the motif M = (u1, v1, t1), . . . , (u l , v l , t l ) if 1. There exists a bijection f on the vertices such that f (wi) = ui and f (xi) = vi, i = 1, . . . , l, and 2. the edges all occur within ? time, i.e., t l -t 1 ? ? A central goal of this work is to count the number of ordered subsets of edges from a temporal graph T that are instances of a particular motif. In other words, given a k-node, l-edge ?-temporal motif, we seek to find how many of the l! m l ordered length-l sequences of edges in the temporal graph T are instances of the motif. A naive approach to this problem would be to simply enumerate all ordered subsets and then check if it is an instance of the motif. In modern datasets, the number of edges m is typically quite large (we analyze a dataset in Section 5 with over two billion edges), and this approach is impractical even for l = 2. In the following section, we discuss several faster algorithms for counting the number of instances of ?-temporal motifs in a temporal graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ALGORITHMS</head><p>We now present several algorithms for exactly counting the number of instances of ?-temporal motifs in a temporal graph. We first present a general counting algorithm in Section 4.1, which can count instances of any k-node, l-edge temporal motif faster than simply enumerating over all size-l ordered subsets of edges. This algorithm is optimal for counting 2-node temporal motifs in the sense that it is linear in the number of edges in the temporal graph. In Section 4.2, we provide faster, specialized algorithms for counting specific types of 3-node, 3-edge temporal motifs (Fig. <ref type="figure" target="#fig_3">3</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">General counting framework</head><p>We begin with a general framework for counting the number of instances of a k-node, l-edge temporal motif M . To start, consider H to be the static directed graph induced by the edges of M . A sequence of temporal edges S is an instance of M if and only if the static subgraph induced by edges in S is isomorphic to H, the ordering of the edges in S matches the order in M , and all the edges in S span a time window of at most ? time units. This leads to the following general algorithm for counting instances of M in a temporal graph T : Algorithm 1: Algorithm for counting the number of instances of all possible l-edge ?-temporal motifs in an ordered sequence of temporal edges. We assume the keys of counts[?] are accessed in order of length.</p><p>Input: Sequence S of edges (e1 = (u1, v1), t1), . . . , (eL, tL) with t1 &lt; . . . &lt; tL, time window ? Output: Number of instances of each l-edge ?-temporal motif M contained in the sequence start ? 1, counts ? Counter(default = 0) for end = 1, . . . , L : while tstart + ? &lt; tend do DecrementCounts(estart), start += 1</p><formula xml:id="formula_0">IncrementCounts(eend) return counts Procedure DecrementCounts(e) counts[e] -= 1 for suffix in counts.keys of length &lt; l -1 : counts[concat(e, suffix)] -= counts[suffix]</formula><p>Procedure IncrementCounts(e) for prefix in counts.keys.reverse() of length &lt; l :</p><formula xml:id="formula_1">counts[concat(prefix, e)] += counts[prefix] counts[e] += 1</formula><p>1. Identify all instances H of the static motif H induced by M within the static graph G induced by the temporal graph T (e.g., there are three instances of H induced by M in Fig. <ref type="figure" target="#fig_0">1</ref>). 2. For each static motif instance H , gather all temporal edges between pairs of nodes forming an edge in H into an ordered sequence S = (u1, v1, t1), . . ., (uL, vL, tL). 3. Count the number of (potentially non-contiguous) subsequences of edges in S occurring within ? time units that correspond to instances of M .</p><p>The first step can use known algorithms for enumerating motifs in static graphs <ref type="bibr" target="#b27">[27]</ref>, and the second step is a simple matter of fetching the appropriate temporal edges. To perform the third step efficiently, we develop a dynamic programming approach for counting the number of subsequences (instances of motif M ) that match a particular pattern within a larger sequence (S ). The key idea is that, as we stream through an input sequence of edges, the count of a given length-l pattern (i.e., motif) with a given final edge is computed from the current count of the length-(l -1) prefix of the pattern. Inductively, we maintain auxiliary counters of all of the prefixes of the pattern (motif). Second, we also require that all edges in the motif be at most ? time apart. Thus, we use the notion of a moving time window such that any two edges in the time window are at most ? time apart. The auxiliary counters now keep track of only the subsequences occurring within the current time window. Last, it is important to note that the algorithm only counts the number of instances of motifs rather than enumerating them.</p><p>Alg. 1 counts all possible l-edge motifs that occur in a given sequence of edges. The data structure counts[?] maintains auxiliary counts of all (ordered) patterns of length at most l. Specifically, counts[e1 ? ? ? er] is the number of times the subsequence [e1 ? ? ? er] occurs in the current time window (if r &lt; l) or the number of times the subsequence has occurred within all time windows of length ? (if r = l). We also assume the keys of counts[?] are accessed in order of length. Moving the time window forward by adding a new edge into the window, all edges (e = (u, v), t) farther than ? time from the new edge are removed from the window and the appropriate counts are decremented (the DecrementCounts() method). First, the single edge counts ([e]) are updated. Based on these updates, length-2 subsequences formed with e as its first edge are updated and so on, up through length-(l -1) subsequences. On the other hand, when an edge e is added to the window, similar updates take place, but in reverse order, from longest to shortest subsequences, in order to increment counts in subsequences where e is the last edge (the IncrementCounts() method). Importantly, length-l subsequence counts are incremented in this step but never decremented. As the time window moves from the beginning to the end of the sequence of edges, the algorithm accumulates counts of all length-l subsequences in all possible time windows of length ?.</p><p>Fig. <ref type="figure" target="#fig_1">2</ref> shows the execution of the Alg. 1 for a particular sequence of edges. Note that the figure only displays values of counts <ref type="bibr">[?]</ref> for contiguous subsequences of the motif M , but the algorithm keeps counts for other subsequences as well. In general, there are O(l 2 ) contiguous subsequences of an l-edge motif M , and there are O(|H| l ) total keys in counts <ref type="bibr">[?]</ref>, where |H| is the number of edges in the static subgraph H induced by M , in order to count all l-edge motifs in the sequence (i.e., not just motif M ).</p><p>We now analyze the complexity of the overall 3-step algorithm. We assume that the temporal graph T has edges sorted by timestamps, which is reasonable if edges are logged in their order of occurrence, and we pre-process T in linear time such that we can access the sorted list of all edges between u and v in O( <ref type="formula">1</ref> In the remainder of this section we analyze our 3-step algorithm with respect to different types of motifs (2-node, stars, and triangles) and argue benefits as well as deficiencies of the proposed framework. We show that for 2-node motifs, our general counting framework takes time linear in the total number of edges m. Since all the input data needs to be examined for computing exact counts, this means the algorithm is optimal for 2-node motifs. However, we also show that for star and triangle motifs the algorithm is not optimal, which then motivates us to design faster algorithms in Sec. 4.2. General algorithm for 2-node motifs. We first show how to map 2-node motifs to the framework described above. Any induced graph H of a 2-node ?-temporal motif is either a single or a bidirectional edge. In either case, it is straightforward to enumerate over all instances of H in the static graph. This leads to the following procedure: (1) for each pair of nodes u and v for which there is at least one edge, gather and sort the edges in either direction between u and v; (2) call Alg. 1 with these edges. The obtain the total motif count the counts from each call to Alg. 1 are then summed together.</p><p>We only need to input each edge to Alg. 1 once, and under the assumption that we can access the sorted directed edges from one node to another in O(1) time, the merging of edges into sorted order takes linear time. Therefore, the total running time is O(2 l m), which is linear in the number of temporal edges m. We are mostly interested in small patterns, i.e., cases when l is a small constant. Thus, this methodology is optimal (linear in the input, m) for counting 2-node ?-temporal motif instances. General algorithm for star motifs. Next, we consider k-node, l- The 24 other motifs are stars. We index the 36 motifs Mi,j by 6 rows and 6 columns. The first edge in each motif is from the green to the orange node. The second edge is the same along each row, and the third edge is the same along each column.</p><formula xml:id="formula_2">M 6,1 M 6,2 M 6,3 M 6,4 M 6,5 M 6,6 M 5,1 M 5,2 M 5,3 M 5,4 M 5,5 M 5,6 M 4,1 M 4,2 M 4,3 M 4,4 M 4,5 M 4,6 M 3,1 M 3,2 M 3,3 M 3,4 M 3,5 M 3,6 M 2,1 M 2,2 M 2,3 M 2,4 M 2,5 M 2,6 M 1,1 M 1,2 M 1,3 M 1,4 M 1,5 M 1,6 1, 2, 3 1, 2 3 1, 2 3 1, 2 3 1, 2<label>3</label></formula><formula xml:id="formula_3">1, 2 3 1, 3 2 1 2, 3 1 2 3 1 2 3 1 2 3 1 2 3 1, 3 2 1 3 2 1 2, 3 1 2 3 1 2 3 1 2 3 1, 3 2 1 3 2 1 2 3 1 2, 3 1 2 3 1 2 3 1, 3 2 1 3 2 1 2 3 1 2 3 1 2, 3 1 2 3 1, 3 2 1 3 2 1 2 3 1 2 3 1 2 3 1 2, 3</formula><p>edge star motifs M , whose induced static graph H consists of a center node and k -1 neighbors, where edges may occur in either direction between the center node and a neighbor node. For example, in the top left corner of Fig. <ref type="figure" target="#fig_3">3</ref>, M1,1 is a star motif with all edges pointing toward the center node. In such motifs, the induced static graph H contains at most 2(k-1) = 2k-2 static edges-one incoming and outgoing edge from the center node to each neighbor node. We have the following method for counting the number of instances of k-node, l-edge star motifs: (1) for each node u in the static graph and for each unique set of k -1 neighbors, gather and sort the edges in either direction between u and the neighbors; (2) count the number of instances of M using Alg. 1. The counts from each call to Alg. 1 are summed over all center nodes. The major drawback of this approach is that we have to loop over each size-(k -1) neighbor set. This can be prohibitively expensive even when k = 3 if the center node has large degree. In Section 4.2, we shall design an algorithm that avoids this issue for the case when the star motif has l = 3 edges and k = 3. General algorithm for triangle motifs. In triangle motifs, the induced graph H consists of 3 nodes and at least one directed edge between any pair of nodes (see Fig. <ref type="figure" target="#fig_3">3</ref> for all eight of the 3-edge triangle motifs). The induced static graph H of M contains at least three and at most six static edges. A straightforward algorithm for counting l-edge triangle motifs in a temporal graph T is:</p><p>1. Use a fast static graph triangle enumeration algorithm to find all triangles in the static graph G induced by T [14]. 2. For each triangle (u, v, w), merge all temporal edges from each pair of nodes to get a time-sorted list of edges. Use Alg. 1 to count the number of instances of M . This approach is problematic as the edges between a pair of nodes may participate in many triangles. Fig. <ref type="figure" target="#fig_5">4</ref> shows a worst-case example for the motif M = (w, u, t 1 ), (w, v, t 2 ), (u, v, t 3 ) with ? = ?. In this case, the timestamps are ordered by their index. There are m -2n edges between u and v, and each of these edges forms an instance of M with every wi. Thus, the overall worst-case running time of the algorithm is O(TriEnum + m? ), where TriEnum is the time to enumerate the number of triangles ? in the static graph. In  the following section, we devise an algorithm that significantly reduces the dependency on ? from linear to sub-linear (specifically, ? ? ) when there are l = 3 edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Faster algorithms</head><p>The general counting algorithm from the previous subsection counts the number of instances of any k-node, l-edge ?-temporal motif, and is also optimal for 2-node motifs. However, the computational cost may be expensive for other motifs such as stars and triangles. We now develop specialized algorithms that count certain motif classes faster. Specifically, we design faster algorithms for counting all 3-node, 3-edge star and triangle motifs (Fig. <ref type="figure" target="#fig_3">3</ref> illustrates these motifs). Our algorithm for stars is linear in the input size, so it is optimal up to constant factors. Fast algorithm for 3-node, 3-edge stars. With 3-node, 3-edge star motifs, the key drawback of using the previous algorithmic approach would be that we would have to loop over all pairs of neighbors given a center node. Instead, we will count all instances of star motifs for a given center node in just a single pass over the edges adjacent to the center node.</p><p>We use a dynamic programming approach for counting star motifs. First, note that every temporal edge in a star with center u is defined by (1) a neighbor node, (2) a direction of the edge (outward from or inward to u), and (3) the timestamp. With this insight we then notice that there are 3 classes of star motifs on 3 nodes and 3 edges:</p><formula xml:id="formula_4">pre post mid 1, 2 3 1 2, 3 1, 3<label>2</label></formula><p>where each class has 2 3 = 8 motifs for each of the possible directions on the three edges. Now, suppose we process the time-ordered sequence of edges containing the center node u. We maintain the following counters when processing an edge with timestamp tj:</p><p>? pre_sum[dir1, dir2] is the number of sequentially ordered pairs of edges in [tj -?, tj) where the first edge points in direction dir1 and the second edge points in direction dir2 ? post_sum[dir1, dir2] is the analogous counter for the time window (tj, tj</p><formula xml:id="formula_5">+ ?]. ? mid_sum[dir1, dir2</formula><p>] is the number of pairs of edges where the first edge is in direction dir1 and occurred at time t &lt; tj and the second edge is in direction dir2 and occurred at time t &gt; tj such that t -t ? ?. If we are currently processing an edge, the "pre" class gets pre_sum[dir1, dir2] new motif instances for any choice of directions dir1 and dir2 (specifying the first two edge directions) and the current edge serves as the third edge in the motif (hence specifying the third edge direction). Similar updates are made with the post_sum[?, ?] and mid_sum[?, ?] counters, where the current edge serves as the first or second edge in the motif, respectively.</p><p>In order for our algorithm to be efficient, we must quickly update our counters. To aid in this, we introduce two additional counters: Algorithm 2: Algorithmic framework for faster counting of 3-node, 3-edge star and triangle temporal motifs. The fast star counting method (Alg. 3) and triangle counting method (Alg. 4) implement different versions of the Push(), Pop(), and ProcessCurrent() subroutines.</p><p>Input: Sequence of edges (e1 = (u1, v1), t1), .  Finally, we note that our counting scheme incorrectly includes instances of 2-node motifs such as M = (u, vi, t1), (u, vi, t2), (u, vi, t3), but we can use the efficient 2-node motif counting algorithm to account for this. Putting everything together, we have the following procedure:</p><p>1. For each node u in the temporal graph T , get a time-ordered list of all edges containing u. 2. Use Algs. 2 and 3 to count star motif instances. 3. For each neighbor v of a star center u, subtract the 2-node motif counts using Alg. 1. If the m edges of T are time-sorted, the first step can be done in linear time. The second and third steps run in linear time in the input size. Each edge is used in steps 2 and 3 exactly twice: once for each end point as the center node. Thus, the overall complexity of the algorithm is O(m), which is optimal up to constant factors. Fast algorithm for 3-edge triangle motifs. While our fast star counting routine relied on counting motif instances for all edges adjacent to a given node, our fast triangle algorithm is based on counting instances for all edges adjacent to a given pair of nodes. Specifically, given a pair of nodes u and v and a list of common neighbors w1, . . . , w d , we count the number of motif instances for triangles (wi, u, v). Given all of the edges between these three Algorithm 3: Implementation of Alg. 2 subroutines for efficiently counting instances of 3-node, 3-edge star motifs. Temporal edges are specified by a neighbor nbr, a direction dir (incoming or outgoing), and a timestamp. The ":" notation represents a selection of all indices in an array. nodes, the counting procedures are nearly identical to the case of stars. We use the same general counting method (Alg. 2), but the behavior of the subroutines Push(), Pop(), and ProcessCurrent() depends on whether or not the edge is between u and v.</p><p>These methods are implemented in Alg. 4. The input is a list of edges adjacent to a given pair of neighbors u and v, where each edge consists of four pieces of information: (1) a neighbor node nbr, (2) an indicator of whether or not the node nbr connects to node u or node v, (3) the direction dir of the edge, and ( <ref type="formula">4</ref> Recall that the problem with counting triangle motifs by the general framework in Alg. 1 is that a pair of nodes with many edges might have to be counted for many triangles in the graph. However, with Alg. 4, we can simultaneously count all triangles adjacent to a given pair of nodes. What remains is that we must assign each triangle in the static graph to a pair of nodes. Here, we propose to assign each triangle to the pair of nodes in that triangle containing the largest number of edges, which is sketched in Alg. 5. Alg. 5 aims to process as many triangles as possible for pairs of nodes with many edges. The following theorem says that this is faster than simply counting for each triangle (described in Section 4.1). Specifically, we reduce O(m? ) complexity to O(m ? ? ). Theorem. In the worse case, Alg. 5 runs in time O(TriEnum + m ? ? ), where TriEnum is the time to enumerate all triangles in the static graph G, m is the total number of temporal edges, and ? is the number of static triangles in G. Proof. Let ?i be the number of edges between the ith pair of nodes with at least one edge, and let pi ? 1 be the number of times that edges on this pair are used in a call to Alg. 4 by Alg. 5. Since Alg. 4 runs in linear time in the number of edges in its input, the total running time is on the order of i ?ipi.</p><p>The ?i are fixed, and we wish to find the values of pi that maximize the summation. Without loss of generality, assume that the ?i are in decreasing order so that the most number of edges between a pair of nodes is ?1. Consequently, pi ? i. Note that each triangle contributes to at most a constant repeat processing of edges for a given pair of nodes. Hence, i pi ? c? for some constant c. The Algorithm 4: Implementation of Alg. 2 subroutines for counting 3-edge triangle motifs containing a specified pair of nodes u and v. Temporal edges are specified by a neighbor nbr, a direction dir (incoming or outgoing), an indicator "uorv" denoting if the edge connects to u or v, and a timestamp. The ":" notation represents a selection of all indices in an array. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initialize counter count</head><formula xml:id="formula_6">else utov = (nbr == u) XOR dir for 0 ? i, j, k ? 1 : count[i, j, k] += mid_sum[j XOR utov, i, k] +post_sum[i XOR utov, j, 1 -k] +pre_sum[k XOR utov, 1 -i, 1 -j]</formula><p>/ * count key map to Fig. <ref type="figure" target="#fig_3">3</ref>:</p><formula xml:id="formula_7">* / / * [0, 0, 0] ? M1,3, [0, 0, 1] ? M1,4, [0, 1, 0] ? M2,3 * / / * [0, 1, 1] ? M2,4, [1, 0, 0] ? M3,5, [1, 0, 1] ? M3,6 * / / * [1, 1, 0] ? M4,5, [1, 1, 1] ? M4,6</formula><p>* / return count foreach undirected edge e in G do Update counts using Alg. 4 with input ae summation i ?ipi is maximized when p1 = 1, p2 = 2, and so on up to some index j = O( ? ? ) for which j i=1 pj = j i=1 i = c? . Now given that the pj are fixed and the ?i are ordered, the summation is maximized when ?1 = ?2 = . . . = ?j = m/j. In this case,</p><formula xml:id="formula_8">i ?ipi = j i=1 (m/j)(1 + i) = O(m ? ? ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTS</head><p>Next, we use our algorithms to reveal patterns in a variety of temporal network datasets. We find that the number of instances of various ?-temporal motifs reveal basic mechanisms of the networks. Datasets and implementations of our algorithms are available at http://snap.stanford.edu/temporal-motifs. </p><formula xml:id="formula_9">3 3 3 3 0.4M 59K 0.8M 40K 34K 28K 68K 59K 28K 16K 38K 15K 0.7M 35K 0.8M 45K 6K 6K 18K 12K 35K 40K 3K 6K 18K 30K 3K 2K 35K 14K 13K 10K 4K 6K 14K 28K Email-Eu 4M 0.3M 0.7M 2M 2M 0.9M 0.3M 0.3M 0.3M 0.3M 0.3M 0.3M 0.6M 0.2M 0.7M 0.3M 68K 75K 2M 0.2M 0.3M 1M 46K 71K 1M 0.3M 57K 50K 2M 0.3M 0.5M 0.2M 56K 69K 0.3M 0.8M Phonecall-Eu 5M 3M 0.2M 90K 84K 62K 3M 3M 0.1M 81K 89K 58K 0.1M 59K 0.2M 0.1M 1K 1K 38K 35K 0.1M 91K 1K 2K 45K 47K 1K 0.9K 97K 82K 31K 26K 2K 2K 75K 85K SMS-A 0.3M 0.2M 0.2M 0.1M 0.1M 0.2M 0.2M 0.1M 0.1M 0.1M 0.1M 0.1M 0.2M 79K 0.3M 0.1M 3K 2K 81K 85K 0.1M 0.2M 2K 3K 92K 64K 2K 2K 0.1M 0.1M 0.1M 75K 3K 2K 0.1M 0.2M CollegeMsg 7M 2M 8M 4M 5M 7M 0.4M 4M 4M 3M 3M 3M 3M 3M 9M 5M 0.7M 0.3M 2M 2M 2M 6M 0.3M 0.7M 2M 2M 0.6M 0.2M 6M 2M 6M 4M 1M 1M 7M 8M StackOverflow 15B 9B 25B 25B 20B 23B 8B 9B 14B 16B 17B 15B 21B 11B 25B 14B 1B 1B 19B 14B 15B 19B 2B 1B 15B 13B 1B 2B 22B 15B 18B 10B 1B 1B 14B 23B Bitcoin 17M 0.7M 0.4B 2M 1M 2M 0.8M 0.7M 1M 0.3M 0.8M 0.3M 0.2B 0.7M 0.4B 1M 91K 91K 0.6M 0.1M 1M 2M 27K 0.1M 0.6M 0.3M 0.1M 18K 1M 0.2M 1M 0.1M 0.1M 0.2M 0.2M 1M WikiTalk 0.3M 0.2M 27K 17K 17K 22K 0.3M 0.2M 24K 27K 22K 22K 13K 12K 30K 21K 2K 2K 15K 15K 19K 14K 1K 1K 11K 14K 2K 1K 28K 34K 18K 22K 2K 2K 35K 27K FBWall</formula><p>Figure <ref type="figure" target="#fig_8">5</ref>: Counts of instances of all 2-and 3-node, 3-edge ?-temporal motifs with ? = 1 hour. For each dataset, counts in the ith row and jth column is the number of instances of motif Mi,j (see Fig. <ref type="figure" target="#fig_3">3</ref>); this motif is the union of the two edges in the row label and the edge in the column label. For example, there are 0.7 million instances of motif M4,1 in the EMAIL-EU dataset. The color for the count of motif Mi,j indicates the fraction over all Mi,j on a linear scale-darker blue means a higher count. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Data</head><p>We gathered a variety of datasets in order to study the patterns of ?-temporal motifs in several domains. The datasets are described below and summary statistics are in Table <ref type="table" target="#tab_3">1</ref>. The time resolution of the edges in all datasets is one second. EMAIL-EU. This dataset is a collection of emails between members of a European research institution <ref type="bibr" target="#b17">[17]</ref>. An edge (u, v, t) signifies that person u sent person v an email at time t. PHONECALL-EU. This dataset was constructed from telephone call records for a major European service provider. An edge (u, v, t) signifies that person u called person v starting at time t. SMS-A. Short messaging service (SMS) is a texting service provided on mobile phones. In this dataset, an edge (u, v, t) means that person u sent an SMS message to person v at time t <ref type="bibr" target="#b28">[28]</ref>. COLLEGEMSG. This dataset is comprised of private messages sent on an online social network at the University of California, Irvine <ref type="bibr" target="#b21">[21]</ref>. Users could search the network for others and then initiate conversation based on profile information. An edge (u, v, t) means that user u sent a private message to user v at time t. STACKOVERFLOW. On stack exchange web sites, users post questions and receive answers from other users, and users may comment on both questions and answers. We derive a temporal network by creating an edge (u, v, t) if, at time t, user u: (1) posts an answer to user v's question, (2) comments on user v's question, or (3) comments on user v's answer. We formed the temporal network from the entirety of Stack Overflow's history up to March 6, 2016. BITCOIN. Bitcoin is a decentralized digital currency and payment system. This dataset consists of all payments made up to October 19, 2014 <ref type="bibr" target="#b11">[11]</ref>. Nodes in the network correspond to Bitcoin addresses, and an individual may have several addresses. An edge (u, v, t) signifies that bitcoin was transferred from address u to address v at time t. FBWALL. The edges of this dataset are wall posts between users on the social network Facebook located in the New Orleans region <ref type="bibr" target="#b26">[26]</ref>. Any friend of a given user can see all posts on that user's wall, so communication is public among friends. An edge (u, v, t) means that user u posted on user v's wall at time t. WIKITALK. This dataset represents edits on user talk pages on Wikipedia <ref type="bibr" target="#b16">[16]</ref>. An edge (u, v, t) signifies that user u edited user v's talk page at time t. PHONECALL-ME and SMS-ME. This dataset is constructed from phone call and SMS records of a large telecommunications service provider in the Middle East. An edge (u, v, t) in PHONECALL-ME means that user u initiated a call to user v at time t. An edge (u, v, t) in SMS-ME means that user u sent an SMS message to user v at time t. We use these networks for scalability experiments in Section 5.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Empirical observations of motif counts</head><p>We first examine the distribution of 2-and 3-node, 3-edge motif instance counts from 8 of the datasets described in Section 5.1 with ? = 1 hour (Fig. <ref type="figure" target="#fig_8">5</ref>). We choose 1 hour for the time window as this is close to the median time for a node to take part in  three edges in most of our datasets. We make a few empirical observations uniquely available due to temporal motifs and provide possible explanations for these observations. Blocking communication. If an individual typically waits for a reply from one individual before proceeding to communicate with another individual, we consider it a blocking form of communication. A typical conversation between two individuals characterized by fast exchanges happening back and forth is blocking as it requires complete attention of both individuals. We capture this behavior in the "blocking motifs" M5,1, M5,2 and M6,2, which contain 3 edges between two nodes with at least one edge in either direction (Fig. <ref type="figure">6</ref>, left). However, if the reply doesn't arrive soon, we might expect the individual to communicate with others without waiting for a reply from the first individual. This is a non-blocking form of communication and is captured by the "non-blocking motifs" M4,1, M4,3 and M6,3 having edges originating from the same source but directed to different destinations (Fig. <ref type="figure">6</ref>, right)</p><p>The fractions of counts corresponding to the blocking and nonblocking motifs out of the counts for all 36 motifs in Fig. <ref type="figure" target="#fig_3">3</ref> uncover several interesting characteristics in communication networks (? = 1 hour; see Fig. <ref type="figure">6</ref>). In FBWALL and SMS-A, blocking communication is vastly more common, while in EMAIL-EU non-blocking communication is prevalent. Email is not a dynamic method of communication and replies within an hour are rare. Thus, we would expect non-blocking behavior. Interestingly, the COLLEGEMSG dataset shows both behaviors as we might expect individuals to engage in multiple conversations simultaneously. In complete contrast, the PHONECALL-EU dataset shows neither behavior. A simple explanation is that that a single edge (a phone call) captures an entire conversation and hence blocking behavior does not emerge. Cost of switching. Amongst the non-blocking motifs discussed above, M4,1 captures two consecutive switches between pairs of nodes whereas M4,3 and M6,3 each have a single switch (Fig. <ref type="figure">7</ref>, right). Prevalence of M4,1 indicates a lower cost of switching targets, whereas prevalence of the other two motifs are indicative of a higher cost. We observe in Fig. <ref type="figure">7</ref> that the ratio of 2-switch to 1-   switch motif counts is the least in STACKOVERFLOW, followed by WIKITALK, COLLEGEMSG and then EMAIL-EU. On Stack Overflow and Wikipedia talk pages, there is a high cost to switch targets because of peer engagement and depth of discussion. On the other hand, in the COLLEGEMSG dataset there is a lesser cost to switch because it lacks depth of discussion within the time frame of ? = 1 hour. Finally, in EMAIL-EU, there is almost no peer engagement and cost of switching is negligible. Cycles in BITCOIN. Of the eight 3-edge triangle motifs, M2,4 and M3,5 are cyclic, i.e., the target of each edge serves as the source of another edge. We observe in Fig. <ref type="figure" target="#fig_12">8</ref> that the fraction of triangles that are cyclic is much higher in BITCOIN compared to any other dataset. This can be attributed to the transactional nature of BITCOIN where the total amount of bitcoin is limited. Since remittance (outgoing edges) is typically associated with earnings (incoming edges), we should expect cyclic behavior. Datasets from the same domain have similar counts. Static graphs from similar domains tend to have similar motif count distributions <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b29">29]</ref>. Here, we find similar results in temporal networks. We formed two collections of datasets from similar domains. First, we took subsets of the EMAIL-EU dataset corresponding to email communication within four different departments at the institution. Second, we constructed temporal graphs from the stack exchange communities Math Overflow, Super User, and Ask Ubuntu to study in conjunction with the STACKOVERFLOW dataset. We form count distributions by normalizing the counts of the 36 different motifs in Fig. <ref type="figure" target="#fig_8">5</ref>. For datasets from a similar domain, we expect that if the count distributions are similar, then most of the variance is captured by a few principal components. To compare, we use four datasets from dissimilar domains (EMAIL-EU, PHONECALL-EU, SMS-A, WIKITALK). Fig. <ref type="figure" target="#fig_14">9</ref> shows that to explain 90% variance, EMAIL-EU subnetworks need just one principal component, stack exchange networks need two, and the dissimilar networks need three. Motif counts at varying time scales. We now explore how motif counts change at different time scales. For the STACKOVERFLOW dataset we counted the number of instances of 2and 3-node, 3edge ?-temporal motifs for ? = 60, 300, 1800, and 3600 seconds</p><formula xml:id="formula_10">[0s,60s] (60s,300s] StackOverflow 4M 0.8M 3M 2M 2M 4M 0.2M 2M 2M 1M 1M 2M 2M 1M 4M 2M 0.4M 0.2M 1M 1M 0.8M 3M 0.2M 0.4M 1M 1M 0.3M 88K 3M 0.9M 4M 3M 0.6M 0.6M 4M 5M 3M 0.7M 4M 2M 3M 3M 0.2M 2M 3M 2M 1M 1M 1M 1M 5M 3M 0.2M 92K 0.6M 1M 0.8M 4M 0.1M 0.2M 1M 0.7M 0.2M 62K 3M 1M 2M 1M 0.3M 0.3M 2M 3M (1800s,3600s] 3 3 3 3 3 3 1, 2 1 2 1 2 1 2 1 2 1 2 1, 2 1 2 1 2 1 2 1 2 1 2 3 3 3 3 3 3 7K 0.4K 1K 2K 1K 14K 0.4K 0.3K 0.4K 1K 0.3K 4K 0.7K 0.3K 1K 0.2K 0.9K 0.7K 4K 1K 1K 2K 0.3K 2K 3K 1K 2K 0.3K 2K 1K 32K 9K 5K 9K 3K 17K 0.3M 41K 0.2M 0.1M 80K 0.5M 17K 77K 49K 98K 72K 0.2M 0.1M 54K 0.2M 35K 39K 24K 0.1M 0.1M 59K 0.1M 16K 70K</formula><p>89K 90K 39K 8K 0.1M 34K 0.8M 0.4M 0.1M 0.1M 0.3M 0.6M Figure <ref type="figure" target="#fig_0">10</ref>: Counts for all 2-and 3-node, 3-edge ?-temporal motifs in four time intervals for the STACKOVERFLOW dataset. For each interval, the count in the ith row and jth column is the number of instances of motif Mi,j (see Fig. <ref type="figure" target="#fig_3">3</ref>). (Fig. <ref type="figure" target="#fig_0">10</ref>). These counts determine the number of motifs that completed in the intervals [0, 60], (60, 300], (300, 1800s], and (1800, 3600] seconds (e.g., subtracting 60 second counts from 300 second counts gives the interval (60, 300]). Observations at smaller timescales reveal phenomenon which start to get eclipsed at larger timescales. For instance, on short time scales, motif M1,1 (Fig. <ref type="figure" target="#fig_0">10</ref>, top-left corner) is quite common. We suspect this arises from multiple, quick comments on the original question, so the original poster receives many incoming edges. At larger time scales, this behavior is still frequent but relatively less so. Now let us compare counts for M1,5, M1,6, M2,5, M2,6 (the four in the top right corner) with counts for M3,3, M3,4, M4,3, M4,4 (the four in the center). The former counts likely correspond to conversations with the original poster while the latter are constructed by the same user interacting with multiple questions. Between 300 and 1800 seconds (5 to 30 minutes), the former counts are relatively more common while the latter counts only become more common after 1800 seconds. A possible explanation is that the typical length of discussions on a post is about 30 minutes, and later on, users answer other questions. Next, we examine messaging behavior in the COLLEGEMSG dataset at fine-grained time intervals. We counted the number of motifs consisting of a single node sending three outgoing messages  to one or two neighbors (motifs M6,1, M6,3, M4,1, and M4,3) in the time bins [10(i -1), 10i) seconds, i = 1, . . . , 500 (Fig. <ref type="figure" target="#fig_0">11</ref>). We first notice that at small time scales, the motif consisting of three edges to a single neighbor (M6,1) occurs frequently. This pattern could emerge from a succession of quick introductory messages. Overall, motif counts increase from roughly 1 minute to 20 minutes and then decline. Interestingly, after 5 minutes, counts for the three motifs with one switch in the target (M6,1, M6,3, and M4,3) grow at a faster rate than the counts for the motif with two switches (M4,1). As mentioned above, this pattern could emerge from a tendency to send several messages in one conversation before switching to a conversation with another friend.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Algorithm scalability</head><p>Finally, we performed scalability experiments of our algorithms. All algorithms were implemented in C++, and all experiments ran using a single thread of a 2.4GHz Intel Xeon E7-4870 processor. We did not measure the time to load datasets into memory, but our timings include all pre-processing time needed by the algorithms (e.g., the triangle counting algorithms first find triangles in the static graph). We emphasize that our implementation is single threaded, and the methods can be sped up with a parallel algorithm.</p><p>First, we used both the general counting method (Alg. 1) and the fast counting method (Alg. 5) to count the number of all eight 3-edge ?-temporal triangle motifs in our datasets (? = 1 hour). Table <ref type="table" target="#tab_4">2</ref> reports the running times of the algorithms for all datasets with at least one million triangles in the static graph. For all of these datasets, our fast temporal triangle counting algorithm provides significant performance gains over the general counting method, ranging between a 1.29x and a 56.5x speedup. The gains of the fast algorithm are the largest for BITCOIN, which is due to some pairs of nodes having many edges between them and also participating in many triangles.</p><p>Second, we measured the time to count various 3-edge ?temporal motifs in our largest dataset, PHONECALL-ME. Specif-ically, we measured the time to compute (1) 2-node motifs, (2) 3-node stars, and (3) triangles on the first k million edges in the dataset for k = 250, 500, . . . , 2000 (Fig. <ref type="figure" target="#fig_16">12</ref>). The time to compute the 2-node, 3-edge motifs and the 3-node, 3-edge stars scales linearly, as expected from our algorithm analysis. The time to count triangle motifs grows superlinearly and becomes the dominant cost when there is a large number of edges. For practical purposes, the running times are quite modest. With two billion edges, our methods take less than 3.5 hours to complete (executing sequentially).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION</head><p>We have developed ?-temporal network motifs as a tool for analyzing temporal networks. We introduced a general framework for counting instances of any temporal motif as well as faster algorithms for certain classes of motifs and found that motif counts reveal key structural patterns in a variety of temporal network datasets. Our work opens a number of avenues for additional research. First, our fast algorithms are designed for 3-node, 3-edge star and triangle motifs. We expect that the same general techniques can be used to count more complex temporal motifs. Next, it is important to note that our fast algorithms only count the number of instances of motifs rather than enumerate the instances. This concept has also been used to accelerate static motif counting <ref type="bibr" target="#b22">[22]</ref>. Temporal motif enumeration algorithms provide an additional algorithmic design challenge. There is also a host of theoretical questions in this area for lower bounds on temporal motif counting. Finally, motif counts can also be measured with respect to a null model <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b19">19]</ref>. Such analysis may yield additional discoveries. Importantly, our algorithms will speed up such computations, which use raw counts from many random instances of a generative null model.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Temporal graphs and ?-temporal motifs. A: A temporal graph with nine temporal edges. Each edge has a timestamp (listed here in seconds). B: Example 3-node, 3-edge ?-temporal motif M . The edge labels correspond to the ordering of the edges. C: Instances of the ?-temporal motif M in the graph for ? = 10 seconds. The crossed-out patterns are not instances of M because either the edge sequence is out of order or the edges do not all occur within the time window ?.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Example execution of Alg. 1 for counting instances of the ?-temporal motif M in Fig. 1. Each column shows the value of counters at the end of the for loop that processes temporal edges. Color indicates change in the variable: incremented (blue), decremented (red), incremented and decremented (purple), or no change (black). At the end of execution, counts[(a, b)(a, c)(c, a)] = 2 for the two instances of the temporal motif M with center node a. Here we only show the counters needed to count M ; in total, Alg. 1 maintains 39 total counters for this input edge sequence, 25 of which are non-zero.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>) time. Constructing the time-sorted sequence S in step 2 of the algorithm then takes O(log(|H|)|S |) time. Each edge inputted to Alg. 1 is processed exactly twice: once to increment counts when it enters the time window and once to decrement counts when it exits the time window. As presented in Alg. 1, each update changes O(|H| l ) counters resulting in an overall complexity of O(|H| l |S |). However, one could modify Alg. 1 to only update counts for contiguous subsequences of the sequence M , which would change O(l 2 ) counters and have overall complexity O(l 2 |S |). We are typically only interested in small constant values of |H| and l (for our experiments in Section 5, |H| ? 3 and l = 3), in which case the running time is linear in the size of the input to the algorithm, i.e., O(|S |).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: All 2-node and 3-node, 3-edge ?-temporal motifs. The green background highlights the four 2-node motifs (bottom left) and the grey background highlights the eight triangles.The 24 other motifs are stars. We index the 36 motifs Mi,j by 6 rows and 6 columns. The first edge in each motif is from the green to the orange node. The second edge is the same along each row, and the third edge is the same along each column.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Worst-case example for counting triangular motifs with Alg. 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>, and mid_sum[?, ?] can be maintained when processing an edge with just a few simple primitives: ? Push() and Pop() update the counts for pre_nodes[?, ?], post_nodes[?, ?], pre_sum[?, ?] and post_sum[?, ?] when edges enter and leave the time windows [tj -?, tj) and (tj, tj + ?]. ? ProcessCurrent() updates motif counts involving the current edge and updates the counter mid_sum[?, ?]. We describe the general procedure in Alg. 2, which will also serve as the basis for our fast triangle counting procedure, and Alg. 3 implements the subroutines Push(), Pop(), and ProcessCurrent() for counting instances of 3-node, 3-edge star motifs. The count_pre[?, ?, ?], count_post[?, ?, ?], and count_mid[?, ?, ?] counters in Alg. 3 maintain the counts of the three different classes of stars described above.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>) the timestamp. The node counters (pre_nodes[?, ?, ?] and post_nodes[?, ?, ?]) in Alg. 4 have an extra dimension compared to Alg. 3 to indicate whether the counts correspond to edges containing node u or node v (denoted by "uorv"). Similarly, the sum counters (pre_sum[?, ?, ?], mid_sum[?, ?, ?] and post_sum[?, ?, ?]) have an extra dimension to denote if the first edge is incident on node u or node v.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Algorithm 5 :</head><label>5</label><figDesc>Sketch of fast algorithm for counting the number of 3-edge ?-temporal triangle motifs in a temporal graph T . Enumerate all triangles in the undirected static graph G of T ? ? number of temporal edges on each static edge e in G foreach static triangle ? = (e1, e2, e3) in G do emax = arg maxe??{?e} foreach e in ? do Add emax to edge set e / * e ? e if e ? ? and ? assigned to e * / foreach temporal edge (e = (u, v), t) in time-sorted T do foreach e in e do Append (e, t) to temporal-edge list a e / * (e, t) ? a e if e ? ? and ? assigned to e * /</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>Figure6: Fraction of all 2 and 3-node, 3-edge ?-temporal motif counts that correspond to two groups of motifs (? = 1 hour). Motifs on the left capture "blocking" behavior, common in SMS messaging and Facebook wall posting, and motifs on the right exhibit "non-blocking" behavior, common in email.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Fraction of 3-edge ?-temporal triangle motif counts (? = 1 hour) corresponding to cyclic triangles (right) in the four datasets for which this fraction is the largest. BITCOIN has a much higher fraction compared to all other datasets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Percentage of explained variance of relative counts of collections of datasets plotted as a function of the number of principal components. In datasets from the same domain, 90% of variance is explained with fewer components.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>3 Figure 11 :</head><label>311</label><figDesc>Figure 11: Counts over various time scales for the motifs representing a node sending 3 outgoing messages to 1 or 2 neighbors in the COLLEGEMSG dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Time to count 3-edge motifs on the first k temporal million edges in the PHONECALL-ME as a function of k.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>. . , (eL, tL) with t1 &lt; . . . &lt; tL, time window ? ? pre_nodes[dir, vi] is the number of times node vi has appeared in an edge with u with direction dir in the time window [tj -?, tj) ? post_nodes[dir, vi] is the analogous counter but for the time window (tj, tj + ?]. Following the ideas of Alg. 1, it is easy to update these counters when we process a new edge. Consequently, pre_sum[?, ?], post_sum[?, ?]</figDesc><table><row><cell>Initialize counters pre_nodes, post_nodes, mid_sum, pre_sum,</cell></row><row><cell>and post_sum; start ? 1, end ? 1</cell></row><row><cell>for j = 1, . . . , L :</cell></row><row><cell>while tstart + ? &lt; tj do</cell></row><row><cell>Pop(pre_nodes, pre_sum, estart), start += 1</cell></row><row><cell>while tend ? tj + ? do</cell></row><row><cell>Push(post_nodes, post_sum, eend), end += 1</cell></row><row><cell>Pop(post_nodes, post_sum, ej)</cell></row><row><cell>ProcessCurrent(ej)</cell></row><row><cell>Push(pre_nodes, pre_sum, ej)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Summary statistics of datasets.</figDesc><table><row><cell>dataset</cell><cell cols="3"># nodes # static # edges time span</cell></row><row><cell></cell><cell></cell><cell>edges</cell><cell>(days)</cell></row><row><cell>EMAIL-EU</cell><cell>986</cell><cell>2.49K 332K</cell><cell>803</cell></row><row><cell cols="3">PHONECALL-EU 1.05M 2.74M 8.55M</cell><cell>7</cell></row><row><cell>SMS-A</cell><cell cols="2">44.1K 67.2K 545K</cell><cell>338</cell></row><row><cell>COLLEGEMSG</cell><cell cols="2">1.90K 20.3K 59.8K</cell><cell>193</cell></row><row><cell cols="3">STACKOVERFLOW 2.58M 34.9M 47.9M</cell><cell>2774</cell></row><row><cell>BITCOIN</cell><cell cols="2">24.6M 88.9M 123M</cell><cell>1811</cell></row><row><cell>FBWALL</cell><cell cols="2">45.8K 264K 856K</cell><cell>1560</cell></row><row><cell>WIKITALK</cell><cell cols="2">1.09M 3.13M 6.10M</cell><cell>2277</cell></row><row><cell cols="3">PHONECALL-ME 18.7M 360M 2.04B</cell><cell>364</cell></row><row><cell>SMS-ME</cell><cell cols="2">6.94M 51.5M 800M</cell><cell>89</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Time to count the eight 3-edge ?-temporal triangle motifs (? = 3600) using the general counting method (Alg. 1) and the fast counting method (Alg. 5).</figDesc><table><row><cell>dataset</cell><cell cols="4"># static time, Alg. 1 time, Alg. 5 speedup</cell></row><row><cell></cell><cell cols="2">triangles (seconds)</cell><cell>(seconds)</cell><cell></cell></row><row><cell>WIKITALK</cell><cell>8.11M</cell><cell>51.1</cell><cell>26.6</cell><cell>1.92x</cell></row><row><cell>BITCOIN</cell><cell>73.1M</cell><cell>27.3K</cell><cell>483</cell><cell>56.5x</cell></row><row><cell>SMS-ME</cell><cell>78.0M</cell><cell>2.54K</cell><cell>1.11K</cell><cell>2.28x</cell></row><row><cell cols="2">STACKOVERFLOW 114M</cell><cell>783</cell><cell>606</cell><cell>1.29x</cell></row><row><cell>PHONECALL-ME</cell><cell>667M</cell><cell>12.2K</cell><cell>8.59K</cell><cell>1.42x</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgements. We thank <rs type="person">Moses Charikar</rs> for valuable discussion. This research has been supported in part by <rs type="funder">NSF</rs> <rs type="grantNumber">IIS-1149837</rs>, <rs type="funder">ARO MURI</rs>, <rs type="funder">DARPA SIMPLEX</rs> and <rs type="grantNumber">NGS2</rs>, <rs type="funder">Boeing</rs>, <rs type="affiliation">Bosch, Huawei, Lightspeed, SAP, Tencent, Volkswagen</rs>, <rs type="funder">Stanford Data Science Initiative</rs>, and a <rs type="grantName">Stanford Graduate Fellowship</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_vvSxSkH">
					<idno type="grant-number">IIS-1149837</idno>
				</org>
				<org type="funding" xml:id="_Sd9Hhsg">
					<idno type="grant-number">NGS2</idno>
				</org>
				<org type="funding" xml:id="_YBj8yJf">
					<orgName type="grant-name">Stanford Graduate Fellowship</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Com2: fast automatic discovery of temporal (&apos;comet&apos;) communities</title>
		<author>
			<persName><forename type="first">M</forename><surname>Araujo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>G?nnemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Swami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">E</forename><surname>Papalexakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Koutra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PAKDD</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Emergence of scaling in random networks</title>
		<author>
			<persName><forename type="first">A.-L</forename><surname>Barab?si</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Albert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">286</biblScope>
			<biblScope unit="issue">5439</biblScope>
			<biblScope unit="page" from="509" to="512" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Tensor spectral clustering for partitioning higher-order network structures</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Gleich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SDM</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Higher-order organization of complex networks</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Gleich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">353</biblScope>
			<biblScope unit="issue">6295</biblScope>
			<biblScope unit="page" from="163" to="166" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Mining graph evolution rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>Berlingerio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bringmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gionis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECML PKDD</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Temporal link prediction using matrix and tensor factorizations</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Dunlavy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Kolda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Acar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TKDD</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">10</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Commit: A scalable approach to mining communication motifs from dynamic networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gurukar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ranu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ravindran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Temporal networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Holme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Saram?ki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physics Reports</title>
		<imprint>
			<biblScope unit="volume">519</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="97" to="125" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Mining triadic closure patterns in social networks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Assembling thefacebook: Using heterogeneity to understand online social network assembly</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Z</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Way</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ugander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Clauset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Do the rich get richer? an empirical analysis of the bitcoin transaction network</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kondor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>P?sfai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Csabai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vattay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLOS ONE</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">86197</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Empirical analysis of an evolving social network</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kossinets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Watts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">311</biblScope>
			<biblScope unit="issue">5757</biblScope>
			<biblScope unit="page" from="88" to="90" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Temporal motifs in time-dependent networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kovanen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Karsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kaski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kert?sz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Saram?ki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">P11005</title>
		<imprint>
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Main-memory triangle computations for very large (sparse (power-law)) graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Latapy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">407</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="458" to="473" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Signed networks in social media</title>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Huttenlocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Governance in social media: A case study of the wikipedia promotion process</title>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Huttenlocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICWSM</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Graph evolution: Densification and shrinking diameters</title>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TKDD</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Superfamilies of evolved and designed networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Itzkovitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kashtan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Levitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shen-Orr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ayzenshtat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sheffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Alon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">303</biblScope>
			<biblScope unit="issue">5663</biblScope>
			<biblScope unit="page" from="1538" to="1542" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Network motifs: simple building blocks of complex networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shen-Orr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Itzkovitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kashtan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chklovskii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Alon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">298</biblScope>
			<biblScope unit="issue">5594</biblScope>
			<biblScope unit="page" from="824" to="827" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The structure and function of complex networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Newman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Review</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="167" to="256" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Patterns and dynamics of users&apos; behavior and interaction: Network analysis of an online community</title>
		<author>
			<persName><forename type="first">P</forename><surname>Panzarasa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Opsahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Carley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JASIST</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Pinar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Seshadhri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vishal</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1610.09411</idno>
		<title level="m">ESCAPE: Efficiently Counting All 5-Vertex Subgraphs</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A framework for community identification in dynamic social networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tantipathananandh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Berger-Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kempe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Subgraph frequencies: Mapping the empirical and extremal geography of large graph collections</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ugander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Backstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The topological relationship between the large-scale attributes and local interaction patterns of complex networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Vazquez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dobrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sergi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Eckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Oltvai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-L</forename><surname>Barab?si</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PNAS</title>
		<imprint>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="issue">52</biblScope>
			<biblScope unit="page" from="17940" to="17945" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On the evolution of user interaction in Facebook</title>
		<author>
			<persName><forename type="first">B</forename><surname>Viswanath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mislove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Gummadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">WOSN</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Fanmod: a tool for fast network motif detection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wernicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rasche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1152" to="1153" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Evidence for a bimodal distribution in human communication</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kurths</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Schellnhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PNAS</title>
		<imprint>
			<biblScope unit="volume">107</biblScope>
			<biblScope unit="issue">44</biblScope>
			<biblScope unit="page" from="18803" to="18808" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Revealing the hidden language of complex networks</title>
		<author>
			<persName><forename type="first">?</forename><forename type="middle">N</forename><surname>Yaveroglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Malod-Dognin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Levnajic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Janjic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karapandza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stojmirovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pr?ulj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific Reports</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Communication motifs: a tool to characterize social communications</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Oliver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
