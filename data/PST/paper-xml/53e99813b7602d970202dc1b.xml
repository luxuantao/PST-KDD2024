<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Differential interaction nets ଁ</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">T</forename><surname>Ehrhard</surname></persName>
							<email>ehrhard@iml.univ-mrs.fr</email>
							<affiliation key="aff0">
								<orgName type="department">Institut de Mathémathiques de Luminy</orgName>
								<address>
									<addrLine>Campus de Luminy, Case 907</addrLine>
									<postCode>13288, Cedex 9</postCode>
									<settlement>Marseille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">L</forename><surname>Regnier</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institut de Mathémathiques de Luminy</orgName>
								<address>
									<addrLine>Campus de Luminy, Case 907</addrLine>
									<postCode>13288, Cedex 9</postCode>
									<settlement>Marseille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Differential interaction nets ଁ</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9F7BF00E7852769F32D408FC8746E866</idno>
					<idno type="DOI">10.1016/j.tcs.2006.08.003</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:57+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Lambda-calculus</term>
					<term>Linear logic</term>
					<term>Differential lambda-calculus</term>
					<term>Interaction nets</term>
					<term>Resource lambda-calculus</term>
					<term>Lambda-calculus with multiplicities</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce interaction nets for a fragment of the differential lambda-calculus and exhibit in this framework a new symmetry between the of course and the why not modalities of linear logic, which is completely similar to the symmetry between the tensor and par connectives of linear logic. We use algebraic intuitions for introducing these nets and their reduction rules, and then we develop two correctness criteria (weak typability and acyclicity) and show that they guarantee strong normalization. Finally, we outline the correspondence between this interaction nets formalism and the resource lambda-calculus.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In previous semantic investigations <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>, the first author observed that it can perfectly make sense to extend linear logic and the lambda-calculus with differential constructions. From these observations, he derived with the second author in <ref type="bibr" target="#b8">[9]</ref> a differential lambda-calculus, which is a lambda-calculus equipped with a notion of formal differentiation (and new term constructions corresponding to differentials). In the same paper, it is moreover advocated that derivation is a very natural operation from an operational viewpoint: it corresponds to the possibility of feeding a term (of type A → B for instance) with exactly one copy of its argument. In other words, taking the derivative of a term means extracting the linear part of the term, where "linear" takes here its logical (or computer science) meaning of "using ones argument exactly once". One of the main ideas developed in <ref type="bibr" target="#b8">[9]</ref> is precisely that this logical notion of linearity coincides with the mathematical meaning (remember that the derivative, in mathematics, is the best linear approximation of a function). This idea is further reinforced by a result relating the Taylor formula to the linear head reduction strategy of the lambda-calculus (the reduction implemented by Krivine's machine for instance).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Exponential and differentiation</head><p>In the present paper, our goal is to give a linear logic account of this extension of functional languages with differential constructs. More precisely, motivated by the structures of the models mentioned above, we want to express the differential operations developed in the differential lambda-calculus as new operations on the exponential "!" of linear logic. Remember that, in linear logic, the structural operations of weakening and contraction obtain a logical status thanks to the introduction of the two exponential modalities "?" and "!", which are De Morgan dual of each other (through linear negation, which is involutive). So exponentials are responsible for the possibility of erasing and copying data, which is of course essential during computations. In linear logic without exponentials, a proof uses linearly its hypotheses.</p><p>In Köthe spaces <ref type="bibr" target="#b6">[7]</ref> as well as finiteness spaces <ref type="bibr" target="#b7">[8]</ref>, formulae are interpreted as topological vector spaces, and proofs of linear logic as linear continuous maps between these spaces. Then exponentials appear as "symmetric tensor algebra" constructions <ref type="bibr" target="#b1">[2]</ref>. In linear logic, an intuitionist implication A ⇒ B is translated as !A B (where this symbol corresponds to linear implication). In the models considered here, linear maps from !X to Y can be seen as "analytic functions" (that is, functions definable by a power series) from the vector space X to the vector space Y. For each space X, the space !X is equipped with the following structure, which is standard from the viewpoint of linear logic:</p><p>• There is a map !X → X (dereliction) and a map !X → !!X (digging) which are natural and turn "!" (which must be a functor) into a comonad. The basic use of dereliction (which also explains its name) is that, by composition on the left, it allows to turn a linear function from X to Y into an analytic function from X to Y (it is a forgetful operation: linear functions are particular analytic functions). • There is a map !X → 1 (where 1 is the unit of the tensor product) and a map !X → !X ⊗ !X which correspond, respectively, to weakening and contraction. These maps turn !X into a ⊗-comonoid (co-algebra). Contraction allows to turn a two-parameter analytic function f into a one-parameter g defined by g(x) = f (x, x). Similarly, given a vector y of Y, seen as a linear function from 1 to Y (1 is the field and this map is just the linear function t → ty), by composing on the left with weakening, we define the constant analytic function X → Y , with value y. In these models, as we have said, the morphisms of the (cartesian closed) Kleisli category of the comonad "!" can naturally be seen as analytic functions, and therefore can be differentiated. Classically, the derivative of a function f : X → Y is a function f : X → (X Y ) such that for each x ∈ X, the linear function f (x) (the derivative of f at point x) is the "best linear approximation" of the function X → Y which maps u ∈ X to f (x + u) ∈ Y (the general definition is local). Of course, if the function f is "very regular" (for instance, smooth or even analytic) then the derivative f will have the same degree of regularity. In the analytic case, differentiation turns a linear function f : !X → Y into a linear function f : !X → (X Y ), that is, f : (!X ⊗ X) Y . It turns out that, just like for the structural logical operations above, f can be obtained from f by composing it (as a linear function from !X to Y) on the left with a particular linear morphism (!X⊗X) → !X. This morphism itself can be defined in terms of more primitive operation on !X which appear somehow as symmetrical to the above mentioned structural morphisms.</p><p>• There is a linear map X → !X (co-dereliction) which corresponds to a particular case of differentiation: given an analytic function f : X → Y seen as a linear function !X → Y , by composing f with co-dereliction, we obtain a linear map X → Y which is the derivative of f at point 0. Unlike the transformation of a linear function into an analytic function using dereliction, the transformation of an analytic function into a linear function using co-dereliction is very destructive, since all the non-linear part of the function is forgotten (think of the case where the analytic function is constant). • There is a linear map !X ⊗ !X → !X (co-contraction) which has the following effect. Given an analytic function f : X → Y seen as a linear function !X → Y , by composing f with co-contraction, we obtain a linear map !X ⊗ !X → Y , that is an analytic function g with two parameters of type X, which is the function defined by g(x, y) = f (x + y). Similarly, there is a particular vector in !X (categorically, a linear map 1 → !X), called coweakening, and whose effect by left-composition on an analytic f seen as a linear map !X → Y is to produce the value f (0). These maps turn !X into a ⊗-monoid (or algebra). Of course, there are a number of commutations satisfied by these morphisms and the morphisms associated to the "?" modality. One can see the present formalism of differential nets as a graphical presentation of these commutations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Differential nets</head><p>The exponential fragment of linear logic contains constructions for the weakening, contraction and dereliction operations of "?"; they can be equivalently presented in sequent calculus or proof nets formalisms <ref type="bibr" target="#b10">[11]</ref>. In proof nets, unary, ternary and binary links (respectively) are associated with these three operations. On the other hand, linear logic has only one rule for "!", an introduction rule called promotion. It is certainly the most complicated rule of linear logic: in sequent calculus, its application requires the context to have a certain shape -all formulae being ?-formulae -and in proof nets, it requires the introduction of boxes, whose main operational effect is to delimit sub-nets to be erased or duplicated as a whole by weakening or contraction links during cut elimination.</p><p>In the present setting, we have more rules associated with "!": co-weakening, co-contraction and co-dereliction, as we have seen. Moreover, among these rules, co-weakening and co-dereliction appear as new introduction rules, exactly as weakening and dereliction are introduction rules for "?". We can hope that it will make sense to extend proof nets with three new kinds of links associated to these rules, and even that such a system could exist without promotion, since we have other ways of introducing "!"-formulae. We develop here such a promotion-free formalism, using Lafont's notion of interaction nets <ref type="bibr" target="#b13">[14]</ref> rather than proof nets. <ref type="foot" target="#foot_0">1</ref>In interaction nets, logical rules are represented by cells. Nets are made of cells connected with each other by wires through their ports. Each cell has a unique principal port and reduction occurs between cells connected by their principal ports: this means that the cuts of proof nets are replaced in interaction nets by wires between principal ports (see <ref type="bibr" target="#b14">[15]</ref>).</p><p>As we have seen, there is a complete symmetry between ?-cells and !-cells (weakening vs. co-weakening, contraction vs. co-contraction and dereliction vs. co-dereliction). Strikingly, this symmetry extends to the reduction rules we have deduced from our models: if a redex consisting of two exponential cells connected by their principal ports (a "?"-cell, for instance a dereliction, and a "!"-cell, for instance a co-contraction) reduces to a net , then the dual redex obtained by swapping "?" and "!" reduces to where "?" and "!" are swapped.</p><p>One fundamental point which departs this syntax from standard interaction nets or proof nets is that, just like in <ref type="bibr" target="#b8">[9]</ref>, we are obliged to consider sums of nets, due to the fact that our reduction is "non-deterministic" (this point is extensively discussed and illustrated in <ref type="bibr" target="#b8">[9]</ref>). These sums are created by the dereliction/co-contraction and co-dereliction/contraction reduction rules (the 0-ary versions of these rules, dereliction/co-weakening and co-dereliction/weakening yield zero nets, where 0 is the neutral element of the sum). In spite of this non-determinism, the calculus enjoys the Church-Rosser confluence property, as soon as reduction is properly extended to sums. The same phenomenon was already observed in <ref type="bibr" target="#b8">[9]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Correctness</head><p>Not all nets obtained by connecting together tensor, par, weakening, contraction, dereliction, co-weakening, co-contraction and co-dereliction cells are correct differential interaction nets. Obviously, it does not make sense to connect two tensor cells through their principal ports for instance. We avoid such ill-formed nets by introducing a typing system allowing recursive types and we prove that this notion of typability is preserved under reduction. But being typable in such a system is not enough for a differential net to be acceptable<ref type="foot" target="#foot_1">2</ref> : just as in multiplicative proof nets, a correctness criterion is needed. In ordinary linear logic, a proof net satisfying the Girard, or Danos-Regnier <ref type="bibr" target="#b5">[6]</ref> criterion (for instance, but others have been designed) has the fundamental property of being sequentializable <ref type="bibr" target="#b10">[11]</ref>, which means that it comes from a proof in the sequent calculus of linear logic. Here we do not propose any sequent calculus corresponding to our interaction nets (though such a calculus exists, and sequentialization certainly holds), but we nevertheless define a correctness criterion, obviously inspired by the Danos-Regnier criterion: contraction is handled like a par and co-contraction like a tensor. What we prove is that this criterion is preserved under reduction, which guarantees that the normal forms of correct nets (typable nets satisfying the criterion) do not contain cycles (deadlocks). We also sketch a proof that all nets satisfying this criterion are strongly normalizable.</p><p>Observe that this criterion is the only feature of the presented formalism which breaks the symmetry between its positive (⊗, !) and negative (o, ?) connectives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4.">Resource lambda-calculus</head><p>Then, we illustrate the connection between these nets and lambda-calculus. Of course, since we have decided to exclude promotion from this presentation, it is impossible to translate the (differential) lambda-calculus in differential interaction nets. <ref type="foot" target="#foot_2">3</ref> However, in <ref type="bibr" target="#b9">[10]</ref>, we observed that, when Taylor-expanding all the applications of a lambda-term, only a fragment of the differential lambda-calculus is needed. The target language of this translation can be seen as a resource lambda-calculus similar to those previously introduced and studied by various authors <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b12">13]</ref>. We translate this resource lambda-calculus in differential interaction nets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5.">Promotion</head><p>Last, we shortly discuss the issue of adding promotion (and hence ordinary application) to this resource calculus. Inspired by the Taylor formula, which is syntactically valid in lambda-calculus (see <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>), we present promotion as an "exponential function" on terms, subject to congruences similar in spirit to the "!P = P |!P " congruence of process calculi (see <ref type="bibr" target="#b16">[17]</ref>) and meaning that a promoted term can be used as many times as needed. Such a presentation of promotion could easily be adapted to the present interaction net setting.</p><p>The more traditional presentation of promotion would require the introduction of "exponential boxes" (in the interaction nets formalism, such a box can be represented as a cell labeled by the net contained in the box), and, just as with proof-nets of ordinary linear logic, these boxes could interact with other boxes and cells through their principal and auxiliary ports. This is perfectly possible, the associated rewriting rules are the standard rules for exponential boxes in linear logic (see <ref type="bibr" target="#b10">[11]</ref>), plus reduction rules corresponding to the interaction of a co-weakening, co-contraction or co-dereliction cell with an auxiliary port of a box, which can easily be deduced from the semantics <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7]</ref>, or from the intuitions presented in the present paper. For instance, the interaction between a co-dereliction and an auxiliary port of a box corresponds to the well known chain rule of differential calculus. The corresponding commuting categorical diagrams are made explicit in <ref type="bibr" target="#b0">[1]</ref>.</p><p>The resulting formalism, however, is more complicated than ordinary interaction nets. In particular, because boxes can interact with other boxes or with cells through their auxiliary ports, one loses the nice property of interaction nets which makes confluence proofs so easy: interaction can occur only between principal ports of cells. For that reason, and also because promotion breaks fundamentally the symmetry between "?" and "!" that we want to emphasize here, we have preferred not to give a detailed account of promotion in the present paper.</p><p>Our differential nets can be seen as a non-deterministic extension of multiplicative proof nets of linear logic, with exponential operations of contraction and co-contraction considered as multiplexing operators allowing several agents to communicate in a common "broadcast area", and dereliction and co-dereliction transforming agents into communicating agents. This viewpoint on exponentials strongly suggests to address the possible connections between differential nets and process calculi.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Syntax and reduction rules</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">General interaction nets</head><p>We assume to be given a collection of symbols. Each of these symbols is given together with a non-negative integer, its arity.</p><p>An interaction net consists of the following data: • a finite set P of free ports; • a finite set C of cells, each cell c being given with a symbol l(c) (and the pairs (c, i) where i is a non-negative integer at most equal to the arity of c are called connected ports);</p><p>• a set W of wires together with a function j mapping each wire to a set of 0 or 2 (free or connected) ports, and such that the collection of these sets be a partition of the set of all ports. Each cell c ∈ C has a particular port (c, 0) which is called its principal port, the others being called auxiliary ports.</p><p>A cell of symbol of arity n is usually pictured as follows:</p><p>the singled out port on the right being the principal port, and the other n -1 ports on the left being the auxiliary ports. Interaction always occurs between two cells connected by their principal ports (such an interaction net is called a redex), and consists in replacing this redex by a given interaction net (depending only on the redex) having the same "free ports". To be more precise, a redex is a net reducing to a net with the same ports p 1 , . . . , p l , q 1 , . . . , q r , and which only depends on the labeling symbols and :</p><p>This means that if the redex occurs within an interaction net as follows:</p><p>then this interaction net reduces to An oriented wire is a wire w ∈ W such that jw has two elements, together with an ordering of these elements (that is, an ordered pair (p 1 , p 2 ) with jw = {p 1 , p 2 }). Such an oriented wire w will be naturally pictured as an arrow, and can obviously be reversed into an oriented wire w * . Typing 4 a net will consist in associating to each of its oriented wires a formula of linear logic, with the constraint that the formula associated to w * must be the linear negation of the formula associated to w.</p><p>When dealing with interaction nets, we shall not use this completely formal presentation which would lead to very boring developments. We shall stay at a more informal level, but all of our reasonings can be formalized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Differential interaction nets</head><p>We consider the following symbols. First, we have two multiplicative cells of arity 2: the tensor cell and the par cell, depicted as follows, together with their typing rules:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>&amp; &amp;</head><p>For each of the two exponentials, we have 3 cells of respective arities 0, 1 and 2. We give them together with their typing rule.</p><p>Weakening and co-weakening (or application to 0):</p><p>Dereliction and co-dereliction (or derivation at 0):</p><p>Contraction and co-contraction (or convolution product<ref type="foot" target="#foot_4">5</ref> ):</p><p>The interaction nets built with these cells will be called simple nets, and general nets will be linear combinations of simple nets. We shall see that reducing simple nets gives rise in general to non-trivial linear combinations. These linearly combined simple nets must have the same free ports, which will be considered as the free ports of the linear combination itself. This allows to connect together general nets and not only simple nets, through their free ports. To turn such a connection of linear combinations of simple nets into a general net, we simply apply multi-linearity. In this way, we are reduced to considering only simple nets and linear combinations thereof. More precisely, if we have two nets and , both of which are sums of simple nets ( = l i=1 i and = r j =1 j ) and if we want to connect these two nets through their common free ports p 1 , . . . , p n (of course, and can have other free ports), then the result of this operation is the sum of the l × r simple nets obtained by connecting <ref type="foot" target="#foot_5">6</ref>i with j through the ports p 1 , . . . , p n for all i, j .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Reduction rules</head><p>The first reduction rule concerns the multiplicative cells and it is completely standard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1.">Tensor/par</head><p>&amp; One has to be careful about the fact that the ports of a cell have indexes and reduction respects these indexes. We have written here these indexes (0, 1 and 2) explicitly for both cells. This is also essential for typing: if the port 1 of a ⊗ cell is connected to an incoming wire of type A and the port 2 to an incoming wire of type B, then any outcoming wire connected to its principal port 0 will carry type A ⊗ B (and not B ⊗ A!). Similarly for o cells, of course. A priori, one has also to take this into account for contraction and co-contraction cells. But we shall see in the reduction rules that they are actually commutative (this point will be made more explicit in future work).</p><p>Next come the rules concerning the exponential cells. As we shall see, they are completely symmetrical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2.">Co-weakening/weakening</head><p>This yields nothing (or more precisely, a multiplicative nothing), as follows:</p><p>This means that if a simple net contains the weakening/co-weakening redex, it reduces to the same net, but without this redex.</p><p>We justify this rule as follows. Imagine that we have a (simple) net with conclusion B, and that we build a constant function f : A → B of value as the following net:</p><p>Applying this function to the value 0 amounts to building the net, whose only pending wire is of type B:</p><p>Obviously, the value of this expression is , which justifies the reduction rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3.">Co-weakening/dereliction and co-dereliction/weakening</head><p>These rules cancel completely simple nets. Let us start with the dereliction/co-weakening which has a ludics <ref type="bibr" target="#b11">[12]</ref> flavor (if we identify co-weakening with daemon):</p><p>where the box on the right-hand side denotes the 0 net, with the same free ports as the left-hand net.</p><p>As an intuitive justification, consider the following situation, where can be considered as a linear function from A to B:</p><p>The complete net above, with conclusions ?A ⊥ and B has therefore to be considered as an "analytic" function from A to B which happens to be linear: this is precisely the purpose of the dereliction cell. Plugging a co-weakening as follows: amounts to applying this linear function to 0, and we obtain the value 0 of type B, as prescribed by our reduction rule. In this reduction, the whole simple net disappears (whether connected or not) and our initial configuration is replaced by a 0-net of type B.</p><p>The co-dereliction/weakening interaction is completely symmetrical.</p><p>Again, let us give an intuitive justification. Using a weakening cell, we can build a constant "analytic" function f from A to B, which always takes the value corresponding to :</p><p>The following net represents then the derivative of f at point 0:</p><p>which indeed must be a linear function from A to B. This function must be null since f is constant. This is exactly what our reduction rules prescribe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.4.">Co-weakening/contraction and weakening/co-contraction</head><p>Both rules are duplications. The first rule is as follows:</p><p>As a justification, consider the following net, where represents an analytic function f (y, z) with two parameters (named here y and z for notational convenience, and that we indicate in the picture below) of type A and value of type B</p><p>This net represents the analytic function g from A to B such that g(x) = f (x, x). Building the net amounts to apply the function g to 0, which clearly produces the same result as the following net (which corresponds to f (0, 0)):</p><p>The second reduction rule is symmetrical to that one.</p><p>Consider indeed the following net, which represents a constant function f (with value b of type B, represented by ), and with one parameter of type A:</p><p>Then we build the following two parameter function g by plugging a co-contraction cell This function is defined by g(y, z) = f (y + z) = b and is just a two parameter constant function, in accordance with our reduction rule which produces the following net:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.5.">Co-dereliction/dereliction</head><p>This is a simplification without much surprises.</p><p>Consider again the following net:</p><p>which represents an analytic function f from A to B which happens to be the linear function h represented by the net . Then the following net:</p><p>represents the linear function f (0), the derivative of f at point 0; it is well known that this function must be h, in accordance with our reduction rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.6.">Co-contraction/dereliction and contraction/co-dereliction</head><p>Both situations lead to sums as follows. The first rule is Consider once more the net which represents an analytic function f from A to B which happens to be the linear function h represented by the net . Then the following net:</p><p>represents the two parameters analytic function g given by g(y, z) = f (y + z). By linearity of f, we have g(y, z) = f (y) + f (z). But this latter expression is represented by the following sum of simple nets:</p><p>In the first summand, the variable z is not used, whence the weakening cell, and symmetrically for the second summand. This is exactly the equation implemented by the reduction rule under consideration (taking into account our conventions on distributivity). Strikingly enough, the contraction/co-dereliction configuration leads to a completely symmetrical pattern, but for rather different mathematical reasons.</p><p>Consider indeed the following net, where represents an analytic function f (y, z) with two parameters (named here y and z for notational convenience, and that we indicate in the picture below) of type A and value of type B:</p><p>This net represents the analytic function g from A to B such that g(x) = f (x, x). Then the following net represents the linear function g (0), from A to B Given a vector u of type A, we know (by the usual laws of calculus) that g (0) • u = f y (0, 0) • u + f z (0, 0) • u (f y (0, 0) and f z (0, 0) are the two partial derivatives, computed at point (0, 0), which are linear functions from A to B).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This latter expression corresponds to the following sum of nets:</head><p>which is the net obtained by applying the co-dereliction/contraction reduction above, as well as our convention on distributivity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.7.">Co-contraction/contraction</head><p>This is just the standard rule of bi-algebras.</p><p>We have typed the wires of the right-hand net in various different ways for illustrating our conventions. Consider again the following net, where represents an analytic function f (y, z) with two parameters of type A and value of type B:</p><p>This net represents the analytic function g from A to B such that g(x) = f (x, x). Plugging a co-contraction, we get the net which represents the two parameters function h given by h(y , z ) = f (y +z , y +z ). Now it is clear that the following net represents exactly the same function. Here, the variables y and z are duplicated before being added, whereas in the net above, duplication was performed after addition; the result is obviously the same, in accordance with our reduction rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">What we have defined so far</head><p>To be precise, we have defined a relation , which is a relation from simple nets to nets (actually, sums of 0, 1 or 2 simple nets only). This relation will be called simple one step reduction and will be generalized later, when we shall be concerned with the confluence issue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Example of reduction</head><p>Consider the following simple net (the reader can check that it is typable):</p><p>We suggest the reader to try the following game: on the right side of this configuration, connect a simple net representing a bilinear function f (y, z), taking two parameters of type A, and yielding values of type B, as follows:</p><p>Using the above explanation about the cells as operating on analytic functions, try to figure out what should be the function corresponding to this configuration, and compare your computation with the following reduction.</p><p>There is only one redex, and the reduction yields a simple net with 4 redexes. Each of these redexes leads to a sum of two simple nets. So we obtain a sum of 16 simple nets, 14 of which will disappear reducing to 0 as we shall see. After reducing the upper-left redex, we get a sum of two similar simple nets 1 and 2 :</p><p>We consider only the first of these nets. If now we reduce the upper-right redex, we get</p><p>In the right-hand term of this sum, we have a co-dereliction/weakening redex which annihilates completely this simple net, and the sum reduces to its first member. Reducing the lower-left redex in this net, we get</p><p>The right-hand member of this sum contains a co-dereliction/weakening redex and therefore reduces to 0. In the left-hand member, we can fire the weakening/co-weakening redex, which vanishes, and the co-contraction/dereliction redex, leading to</p><p>The right-hand term of this sum reduces again to 0 (it contains a dereliction/co-weakening and a co-dereliction/weakening redex), whereas the first net, after having fired the weakening/co-weakening and the two dereliction/co-dereliction redexes, leads simply to Performing the same computation on 2 , we obtain Finally, the normal form of our simple net is the sum of these two wirings:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Weak typing</head><p>The nets defined in the previous section can contain pathological patterns consisting of two cells connected by their principal ports and for which we have given no reduction rules-for instance two tensor cells connected by their principal ports-or can reduce to nets containing such pathological patterns. We therefore introduce a very weak typing system which will have the following two key features: • a weakly typable net contains no pathological pattern (weak correctness), and • if is weakly typable and reduces to , then is also weakly typable (subject reduction). Let us assume to be given a denumerable set A of type variables. Types are defined by the following syntax.</p><p>• If is a type variable, then and ¯ are (atomic) types. The atomic type ¯ corresponds to the linear negation of and is called a "negated type variable". • If A and B are types, then A ⊗ B and AoB are types.</p><p>• If A is a type then !A and ?A are types. If A is a type, then A ⊥ is defined by induction using the De Morgan laws of linear logic (with of course ⊥ = ¯ and (¯ ) ⊥ = ). An important operation is substitution of a formula for a type variable within another formula; this is defined as usual, and requires (for the negated occurrences of the substituted variable) computing linear negations "on the fly". For instance, ( ⊗ ¯ )[! / ] = ! ⊗ ? ¯ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Typing a net</head><p>Let be a simple net. To the cells c of , we associate pairwise disjoint sets of type variables S c and we assign types to all ports of all cells (considered conventionally, for each cell, as oriented toward the outside) as follows. We also assign to each free port of type variables, these variables being distinct from each other and distinct from the variables assigned to connected ports. This assignment of types to ports will sometimes be called the primitive type assignment of .</p><p>If c is a tensor or a par cell, then S c must have two elements 1 and 2 , and the types associated to the ports are</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>&amp; &amp;</head><p>If c is an exponential cell, then S c must have one element , and the associated types are</p><p>Warning: for a technical reason related to the dereliction/co-contraction and co-dereliction/contraction reduction rules, in the case where c is a weakening or co-weakening cell, and only in these cases, we allow also the unique element of S c to be a negated type variable. In this way, each port of receives a type. We define now a set E of equations between types: it is the set of all the equations A B ⊥ where A and B are types associated to ports related by a wire in . Up to renaming of type variables, this set of equations is uniquely defined and depends only on .</p><p>A set E of equations between types is called a simultaneous recursion (following <ref type="bibr" target="#b4">[5]</ref>) if E = { 1 A 1 , . . . , n A n } (we use the symbol " " rather than "=" for denoting these formal equations) where the i 's are pairwise distinct type variables and the A i are types which are not of the shape ¯ (negated atom). <ref type="foot" target="#foot_6">7</ref>Let be a simple net, and let p 1 , . . . , p k a repetition-free list of its free ports. We say that the simple net is weakly typable of type A 1 , . . . , A k if there is a simultaneous recursion E such that E ٛ eq E where ٛ eq stands for standard equational reasoning (with the multiplicative and exponential connectives of linear logic as function symbols, and substitution defined as explained above) and E ٛ eq i = A i ⊥ for i = 1, . . . , k (where i are the type variables associated to the free ports p i by the primitive type assignment of ). In this situation, we write</p><formula xml:id="formula_0">E ٛ | p 1 : A 1 , . . . , p k : A k</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Subject reduction</head><p>The first property of this notion of typing is subject reduction. If is a simple net, if E ٛ | p 1 : A 1 , . . . , p k : A k and if reduces to a sum of simple nets n j =1 n , then there is a simultaneous recursion E such that E ٛ j | p 1 : A 1 , . . . , p k : A k for each j. This is proved by simply examining each reduction. We just consider the two most complicated cases. Assume that is of the shape Then we know that E ٛ eq G 1 ! , E ٛ eq G 2 ! , E ٛ eq ! ! ¯ , E ٛ eq G 3 and E ٛ eq j A j ⊥ for j = 1, . . . , k. According to the co-contraction/dereliction reduction rule, this net reduces to a sum of two simple nets 1 + 2 ; we consider only 1 , the other one being similar:</p><p>We have kept the same primitive assignment for the subnet , and we have introduced fresh type variables and for the cells obtained by reducing the redex under consideration (warning: for the new weakening cell c, we have taken S c = {¯ }). Of course, this primitive assignment induces the same types as above for the free ports of (namely</p><formula xml:id="formula_1">, 1 ,…, k , G 1 , G 2 and G 3 ). Let E = E ∪ { , }.</formula><p>Then E is a simultaneous recursion. By hypothesis, and since E ⊇ E, we know that E ٛ eq E and E ٛ eq j A j ⊥ for j = 1, . . . , k. Moreover,</p><formula xml:id="formula_2">E ٛ eq G 1 ! , hence E ٛ eq G 1 !</formula><p>since E ٛ eq . Similarly E ٛ eq G 3 . Last, by hypothesis we have E ٛ eq G 2 ! , and also E ٛ eq ! ! ¯ .</p><p>But E ٛ eq , hence E ٛ eq ! ! ¯ . Therefore E ٛ eq G 2 ! ¯ , and finally E ٛ 1 | p 1 : A 1 , . . . , p k : A k . One checks easily that, with a similar extension of E as a simultaneous recursion E , one has</p><formula xml:id="formula_3">E ٛ 2 | p 1 : A 1 , . . . , p k : A k (and of course E ٛ 1 | p 1 : A 1 , . . . , p k : A k remains valid).</formula><p>The case of a co-dereliction/contraction reduction is completely similar. Last, let us consider the co-contraction/contraction reduction. So we start with a simple net of the shape</p><p>We know as above that</p><formula xml:id="formula_4">E ٛ eq G 1 ! , E ٛ eq G 2 ! , E ٛ eq ! ! ¯ , E ٛ eq G 3 ?</formula><p>, ٛ eq G 4 ? and E ٛ eq j A j</p><p>⊥ for j = 1, . . . , k. Firing this redex, we obtain the following simple net :</p><p>Again, we assume that the type variables i and i are fresh.</p><formula xml:id="formula_5">Let E = E ∪ { i , i | i = 1, 2}</formula><p>which is a simultaneous recursion. Then we have E ٛ eq G 1 ! and E ٛ eq ! ! ¯ by hypothesis, hence E ٛ eq G 1 ! ¯ 1 ; the equations concerning G 2 , G 3 and G 4 are dealt with similarly. The "internal" equations such as E ٛ eq ! ¯ 1 = ! 2 result from E ٛ eq ! ! ¯ and from the four equations we have added to E. The other reduction rules are similarly simple to deal with. Observe that this general notion of typing subsumes the simple typing outlined at the beginning of the paper: a net with ports p 1 , . . . , p n is simply typable with type A i for port p i iff E ٛ | p 1 : A 1 , . . . , p n : A n with a recursion E = { j B j | i = 1, . . . , m} such that, for each j and each l j , the variable j does not appear in the type B l (such a recursion will be called a loop-free recursion).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Weak correctness of weakly typed nets</head><p>Let us say that a net is weakly correct if it contains no pathological pattern. It is very easy to prove that a weakly typed net is weakly correct. It suffices to consider the set T of infinite types built with the connectives ⊗, o, ! and ? (the infinite trees whose nodes are either binary, and then labeled by ⊗ or by o, or are unary, and then labeled by ! or by ?).</p><p>A valuation I : A → T can be extended to all finite types in the obvious way. Given a set E of equations, let us write I E if I(A) = I(B) for all equation A B belonging to E. Equational reasoning on types is sound with respect to this semantics: if E ٛ eq E and I E, then I E . Now we conclude observing first that, if E is a simultaneous recursion, there exists a valuation I : A → T such that I E (this is fundamentally due to our restriction that simultaneous recursions cannot contain equations of the shape = ¯ where and are type variables, and to the fact that, in a simultaneous recursion, a type variable cannot occur twice as left member of an equation), and second that if for some valuation I, one has I E , then the simple net is weakly correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Confluence</head><p>One of the nice features of Lafont's interaction nets is that they enjoy the Church-Rosser property in the strongest sense: the diamond property holds for the one-step reduction. This will also be the case here, but we have to be careful when extending the one-step reduction to arbitrary nets (that is, to sums of simple nets). An adequate definition of this concept is the following. Let be a net which is a sum = n i=1 i of simple nets, and let be another net. We say that reduces in one step to if = n i=1 n where for each i, i = i or i i , and i i for at least one i. In that case, we write . Observe that when is simple, then the original notion of simple one-step reduction coincides with this new notion, so it makes sense to keep the same notation for both. Observe also that if 1 and 2 are nets and if i i for i = 1, 2, then 1 + 2 1 + 2 . This may seem weird for a notion of one-step reduction, but one must keep in mind that the sum represents a kind of non-deterministic superimposition of simple nets. Now the following statement is easy to check. Let , 1 and 2 be nets. If i for i = 1, 2, then 1 = 2 or there exists a net such that i for i = 1, 2. From our definition of one-step reductions for general nets, we can restrict our attention to the case where is simple. For producing 1 and 2 , we choose two redexes in , that we can of course assume to be distinct. If none of these redexes is a co-dereliction/contraction or dereliction/co-contraction redex, then we conclude as in standard interaction nets, using the fact that reduction is purely local (there is of course the case where one of the redexes is a co-dereliction/weakening or co-weakening/dereliction, but in that case we can converge to the 0 net).</p><p>Assume for instance that one of the redexes is a co-dereliction/contraction redex and that the other one is a co-contraction/dereliction redex, so that our net has the following shape:</p><p>Reducing the left redex, we obtain in one step the following sum: Now reducing the right redex in both terms of this sum, we obtain in one step again the following sum, which we also obtain from the original net by reducing first the right redex, and then the left redexes (up to associativity and commutativity of addition, of course):</p><p>The other cases are similar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Acyclicity criterion</head><p>We extend the Danos-Regnier criterion for multiplicative proof nets to the present setting. We shall not prove a sequentialization theorem, simply because we do not present here any sequent calculus corresponding to these nets. The criterion is nevertheless essential because it will prevent the appearance of cyclic structures during reduction, and thereby ensure strong normalization.</p><p>Let be a simple net. A switching is a map S from the set of par and contraction cells of to the set {1, 2} (the names of the auxiliary ports of the cell). Given such a switching S, we define a non-oriented graph G( , S). The nodes of this graph are the ports of . Let p and q be two ports of , there is an edge between p and q in G( , S) if • there is a wire between p and q in , or • p and q are the two ports of a dereliction or co-dereliction cell, or • p and q are the principal port and one of the auxiliary ports of a tensor or of a co-contraction cell, or • p and q are the principal port and the port i (i = 1 or i = 2) of a par or of a contraction cell c such that S(c) = i. We say that is acyclic if G( , S) is an acyclic graph (a forest) for each switching S of .</p><p>We cannot require connexity as one usually does in multiplicative linear logic because this property is not preserved by the co-contraction/dereliction reduction (the redex itself is a simple net without par or contraction cells and which gives rise to a connected graph, whereas each summand of the result of the reduction gives rise to is a disconnected graph; this problem might be solved by introducing an edge between the weakening cell and the dereliction cell, but we do not care so much about connexity anyway here).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Preservation under reduction</head><p>The main property is again that this acyclicity property is preserved under reduction: if an acyclic simple net reduces to a sum n i=1 i of simple nets, then each of the i 's is acyclic. The proof is a simple checking of all the possible reductions, as we did for subject reduction. Let us concentrate on the tensor/par and on the contraction/co-contraction reductions, the other ones obviously reducing the connectivity of the net.</p><p>Consider first the case where has the following structure. <ref type="foot" target="#foot_7">8</ref> (we have given names to the ports involved in the reduction): &amp; Due to the acyclicity of , we must have p = q, p = q , p = q and p = q . To be more precise, what we have pictured here is not a simple net, but two simple nets, namely and the considered redex consisting of c and d, these two simple nets being connected by identifying the free ports p and r, p and r , etc. As far as acyclicity is concerned, this is harmless.</p><p>The reduced net is Let S be a switching of , that is, a switching of the subnet . Assume towards a contradiction that the graph G( , S) has a cycle C = (p 1 , . . . , p n ) (so p i are pairwise distinct ports of , such that p i and p i+1 as well as p n and p 1 are connected in G( , S), and moreover n 3). Then C must contain both wires w and w . Indeed, if it contains none, then C is a cycle in G( , S) which is impossible since G( , S) is acyclic because is a subnet of which is acyclic. If C passes only through w, then extend S to the switching S 1 of which maps the par cell d to 1; it is easy to transform C into a cycle in the graph G( , S 1 ), contradiction. So we can assume without loss of generality that p 1 = p and p 2 = q, and that there exists i &lt; n such that (1) i &gt; 2, p i = p and p i+1 = q , or (2) i &gt; 2, p i = q and p i+1 = p . In the first case, consider the switching S 1 of obtained by extending S with d → 1. The corresponding graph is In this graph, (q, p 3 , . . . , p i-1 , p , r , r , s , s) is a cycle which contradicts the acyclicity of . In the second case, both switching S 1 and S 2 (where d → 2) provide the cycle (p, r, r , r , p , p i+2 , . . . , p n ).</p><p>Consider now the co-contraction/contraction situation, in a simple net :</p><p>By reducing this redex, we obtain the following simple net :</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Generalized reduction</head><p>Observe that the reduction rules involving a contraction cell or a co-contraction cell generalize in the obvious way (but now with several steps of reductions of course). For instance where 1 , . . . , n are n disjoint copies of , and similarly for the j 's. Similarly, we have the following reduction, generalizes both co-dereliction/contraction (m = 2) and co-dereliction/weakening (m = 0) reductions.</p><p>Last, there is a dual reduction which generalizes both dereliction/co-contraction and dereliction/co-weakening (just swap the "!" and the "?" in the picture above). We define a new relation g from simple nets to nets as the reduction which takes these as elementary steps (plus the tensor/par reduction, still considered as an elementary step). We extend this relation to general nets as we did for . This new reduction relation is clearly included in * , the transitive closure of .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Weak normalization (sketch)</head><p>We outline a proof that is a (weakly) normalizing reduction; strong normalization follows, by the diamond property of , established in Section 4. If is a simple net, its pure size | | P is the number of tensor, par, dereliction and co-dereliction cells in . Its structural size | | S is the number of contraction and co-contraction cells (we do not count weakening and co-weakening cells as one might have expected here).</p><p>In the present context, let us call structural redex a co-weakening/weakening, co-weakening/contraction, weakening/ co-contraction or co-contraction/contraction redex. By examining the auxiliary ports of the two cells involved in such a redex R (whose principal ports will be denoted l and r) within a simple net , we observe that such a redex is uniquely embedded into a subnet of which has the following structure poly-term [t], and if S and T are simple poly-terms, then ST is the concatenation of the multi-sets S and T (that is, the multi-set union of S and T: the number of occurrences of a simple term in ST is its number of occurrences in S plus its number of occurrences in T). So, the poly-term [s 1 , . . . , s n ] will simply be written as the product s 1 • • • s n . Similarly, we write T 2 for TT, the multi-set concatenation of T with itself, etc.</p><p>From now on we drop the adjective "resource" everywhere and say "term" instead of "resource term". Let be the set of all simple terms and ! be the set of all simple poly-terms Let R be a ring. 10 If U is a set, we denote by R U the free R-module built on U, that is the set of all finite formal linear combinations of elements of U with coefficients in R. The elements of R are called terms, and the elements of R ! are called poly-terms. All syntactic constructions on simple terms and poly-terms are extended to arbitrary terms and poly-terms by linearity (when they are unary constructions) or multi-linearity (when they are multi-ary constructions: this is the case of application and of poly-term construction). For instance, if s = n i=1 a i s i is a term which is a linear combination of the pairwise distinct simple terms s i , then</p><formula xml:id="formula_6">x s = n i=1 a i x s i</formula><p>and if S = n i=1 a i S i is a poly-term which is a linear combination of the pairwise distinct simple poly-terms S i , and T = m j =1 b j T j is a poly-term which is a linear combination of the pairwise distinct simple poly-terms T j , then the following equation will hold:</p><formula xml:id="formula_7">ST = n,m i=1,j =1 a i b j S i T j .</formula><p>To give a concrete example of this quite standard convention, the expression x 2y (3x + z) 2 stands for the term 18 x y x 2 + 12 x y xz + 2 x y z 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Substitution and partial derivation</head><p>Substitution of a term t for a variable x in a simple term or poly-term (we use this kind of Greek letter for denoting a term or poly-term, when we do not want to make a distinction between these two sorts) is defined as usual by induction on (warning: t is not assumed to be simple, so the result is not simple in general, and one uses the generalized syntactic constructions defined above by multi-linearity). This operation is then extended to arbitrary 's by linearity; it is linear in but not in t. A particularly important case is when t = 0: if contains at least one free occurrence of x, then [0/x] = 0, and otherwise [0/x] = .</p><p>More important is the operation of partial derivation of terms and poly-terms, in the direction of a given term. Given a variable x and a term u, by induction on the simple term or poly-term , we define j jx • u (linear in and in u) as follows:</p><formula xml:id="formula_8">jy jx • u = u if y = x, 0 otherwise, j y t jx • u = y jt jx • u</formula><p>where we assume of course that y = x, 10 We can use arbitrary coefficients as long as normalization issues are not concerned, for our resource terms as well as for differential nets: this point is discussed in <ref type="bibr" target="#b8">[9]</ref> and more accurately studied in <ref type="bibr" target="#b17">[18]</ref>. As set R of coefficients, we can also take a semi-ring, which is like a ring apart from the fact that the additive monoid is not supposed to be a group; the set N of natural numbers is a typical semi-ring.</p><formula xml:id="formula_9">j s S jx • u = js jx • u S + s jS jx • u , j[s 1 , . . . , s n ] jx • u = n i=1 s 1 , . . . , s i-1 , js i jx • u, s i+1 , . . . , s n .</formula><p>Observe that with our notations for poly-terms,</p><formula xml:id="formula_10">j1 jx • u = 0 and jST jx • u = ( jS jx • u)T + S( jT jx • u).</formula><p>Observe also that more generally j jx • u = 0 as soon as x does not occur free in , and that j jx • u is linear in u in the sense that j jx • ( a i u i ) = a i j jx • u i . This operation j jx • u is then extended by linearity to arbitrary terms and poly-terms . The basic commutation property of this operation is the following equation, which is a syntactic version of Schwarz Lemma:</p><formula xml:id="formula_11">j jy jt jx • u • v = j jx jt jy • v • u + jt jx • ju jy • v ,</formula><p>where we assume that x does not occur free in v. In particular, if we assume moreover that y does not occur free in u, then the two partial derivatives commute (whence the name we gave to this property).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Reduction</head><p>A redex is a simple term s of the shape s = x t T (so t and T are simple). A redex reduces to a term which is not simple in general. If T = 1, then s reduces to t[0/x], and if T = uU , then s reduces to x ( jt jx • u) U (of course, T can be written as a product uU in various different ways in general and thus this redex can reduce to various different terms in general). This notion of reduction is then defined for arbitrary simple terms and poly-terms (and not simply redexes) by extension to contexts. We denote by the corresponding reduction relation, which is thus included in ( × R ) ∪ ( ! × R ! ) (and more precisely in ( × N ) ∪ ( ! × N ! ). This relation can be extended to arbitrary terms and poly-terms (with coefficients in R) as we did in <ref type="bibr" target="#b8">[9]</ref>. But here, when we are concerned with reduction, we assume for simplicity that R = N, and we extend to arbitrary linear combinations as we did for differential nets.</p><p>This notion of reduction enjoys confluence as well as strong normalization. Confluence results from the syntactic version of Schwarz Lemma we mentioned above. Strong normalization is essentially trivial, as reducing a simple term or poly-terms, one obtains a sum of terms or poly-terms whose all elements have less symbols than the original term.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Translation</head><p>We define a translation of simple terms and poly-terms to correct simple nets which are typable in a simultaneous recursion E which is a loop-free recursion to which we add the two following equations involving two distinct type variables and o:</p><formula xml:id="formula_12">= !o ⊗</formula><p>and o ? oo Such a net will be said to be DR-typable (in reference to the pure proof nets of Danos and Regnier, which have the same kind of typing, see <ref type="bibr" target="#b15">[16]</ref>).</p><p>Let l be a list ((x 1 , p 1 ), . . . , (x n , p n )) where the x i 's are pairwise distinct variables and the p i 's are pairwise distinct free ports (in other words, l is a finite partial injection from variables to free ports). Given a simple term or poly-term whose all free variables are contained in the domain {x 1 , . . . , x n } of l, and given a free port p not belonging to the image {p 1 , . . . , p n } of l, we define a simple differential net Last, if = ST , then (with the same notational conventions as in the case of an application) * l,p is Due to this last case, the translation is not exactly deterministic, because there are many ways of decomposing a polyterm as products. But the various nets obtained are equivalent (in a sense to be defined in future work) simply because all co-contraction trees having the same arity are equivalent, and similarly for contraction trees.</p><p>A straightforward induction shows that the simple differential nets obtained in that way are DR-typable as well as acyclic, and thus correct, and hence strongly normalizing.</p><p>Moreover, it can be checked that if t * t , then the normal forms of the differential interaction nets t * l,p and t * l,p are equal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">A few words about promotion</head><p>This resource calculus is essentially finitary, in the sense that it lacks the usual application operation of lambdacalculus which allows for arbitrary duplications. Duplication is present here since we have a contraction cell in our differential nets, but is not a real duplication in the sense of lambda-calculus: here, when a poly-term (multi-set of simple terms) is "duplicated" by a contraction cell, it is cut into two disjoint pieces which are communicated to the two auxiliary ports of this cell; this is done in all possible ways, whence the sums which appear during the reduction.</p><p>The finitary nature of this calculus is revealed by its strong normalization property which holds even in the untyped case. For obtaining the full power of lambda-calculus (and in particular the possibility of representing all partial recursive functions), one has to introduce a promotion operation (in the sense of promotion in linear logic, which turns a proof of !A B into a proof of !A !B). In the present resource calculus, promotion is represented by a new way of constructing poly-terms, similar to the t → t ∞ construction of Boudol's resource lambda-calculus <ref type="bibr" target="#b2">[3]</ref>, or the t →!t of the -calculus <ref type="bibr" target="#b16">[17]</ref>, and which plays exactly the same role of providing a potentially infinite supply of t.</p><p>So given a simple term t, we introduce a new simple poly-term exp 0 (t), which corresponds to the promotion of t. The intention behind this construction is that exp 0 (t) is equal to an infinite "exponential" sum, where the exponents have to be understood in the sense of the product of poly-terms:</p><formula xml:id="formula_13">exp 0 t = ∞ n=0 t n n!</formula><p>assuming of course that this makes sense with our choice of R (take for instance R to be a field).</p><p>The reason for the index 0 in exp 0 t is that if we want to keep our calculus finite (no infinite sums of simple terms appearing during computations), then we have to equip our promotion with a rule similar to the "!t = (t|!t)" congruence of the -calculus. One very natural way to proceed is to say that exp 0 t = 1 + t exp 1 t, Of course, to complete the description of this extension of the resource lambda-calculus, one has to say what j exp n s jx •t should be in general. Fortunately, this does not require the introduction of new term constructions, but surprisingly introduces negative coefficients. The reader will check easily that the following equation holds, when one expands the exp n 's into power series:</p><formula xml:id="formula_14">exp 1 t = 1 + t 2</formula><formula xml:id="formula_15">j exp n s jx • t = exp n s - n n + 1 exp n+1 s js jx • t,</formula><p>where, again, the product has to be taken in the sense of poly-terms multiplication (for n = 0, this is just the fact that the exponential is its own derivative). It can be checked that the calculus so defined still enjoys confluence, but of course, strong normalization is lost in the untyped case. More material on the differential viewpoint on the resource lambda-calculus, and especially on the Taylor expansion of ordinary lambda-terms as infinite linear combinations of resource terms, can be found in <ref type="bibr" target="#b9">[10]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>((x 1 , p 1 ), . . . , (x n , p n )) and l = ((x 1 , p 1 ), . . . , (x n , p n )) are finite injections such that l, l and l have disjoint images, and p, p and p are distinct free ports, not belonging to the union of these images.Let us turn now to the interpretation of poly-terms.If = 1, then * l,p is If = [t]where t is a simple term, then * l,p is</figDesc><table><row><cell>as follows:</cell></row><row><cell>where = o when is a simple term, and = !o when is a simple poly-term.</cell></row><row><cell>The definition is by induction on . If is a variable, and hence = x i for a uniquely determined i ∈ {1, . . . , n}, then  *  l,p is</cell></row><row><cell>If = x t, then  *  l,p is</cell></row></table><note><p>* l,p whose free ports are p 1 , . . . , p n and p. This net will be typable &amp; where q, p are distinct free ports, distinct from p and from the p i 's. If = s S, then * l,p is where l =</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>So our extension of the syntax of the resource lambda-calculus consists in introducing, for each simple term t and non-negative integer n, a new poly-term exp n t corresponding intuitively to the series ∞ .We can consider the equation exp n t = 1 + t n+1 exp n+1 t as part of the reduction, saying that exp n t 1 + t n+1 exp n+1 t but this of course has the serious drawback of preventing strong normalization to hold, even in the simply typed case. It is certainly wiser, and fundamentally equivalent, to implement this equation by saying that</figDesc><table><row><cell></cell><cell cols="2">exp 2 t,</cell></row><row><cell>. . .</cell><cell></cell><cell></cell></row><row><cell>exp n t = 1 +</cell><cell>t n + 1</cell><cell>exp n+1 .</cell></row><row><cell cols="3">k=0 (n+k)! t k x s exp n t s[0/x] + n! 1 n + 1 x js jx • t exp n+1 t.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This is basically an aesthetic choice: in proof nets, one of our reduction rules, the contraction/co-contraction reduction, would require the introduction of new axiom links in the reduced net, whereas axiom links are kept "implicit" in interaction nets as wires between auxiliary ports of cells.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>At least from a logical viewpoint. Such "incorrect" nets might be interesting from a purely computational viewpoint.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This is actually not quite true: lambda-terms can be interpreted as generally infinite sums of differential nets, by Taylor expanding all applications.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>We shall give later a more precise definition of net typing.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>This terminology comes from an analogy with distributions, see the end of<ref type="bibr" target="#b6">[7]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>This operation should be defined precisely and the correct definition would be rather long because each of the two connected nets can contain wires w with jw consisting of two elements belonging to {p 1 , . . . , p n }; such wires can be connected in the resulting net just like electric extensions, and these composed wires must be reduced to standard ones, producing possibly loops in the resulting net (wires w with jw = ∅). But there is of course no conceptual difficulty here.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>The purpose of this restriction is to avoid the dramatic cyclic definition ¯ ; we have no trouble with equations between positive atoms, we shall see that they are necessary.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>This case is well known by the way, since it corresponds to the standard correctness criterion of MLL proof nets. We give the proof here for self-containedness, and because it corresponds to a sub-case of the contraction/co-contraction situation.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>As before, "simple" here means not being a linear combination.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>and we must show that G( , S ) is acyclic, whatever be the switching S of that we consider. Such a switching is obtained by extending a switching S of by giving values 1 or 2 to the two contraction cells d 1 and d 2 . Up to symmetries, there are only two such extensions: S 1 which maps d 1 to 1 and d 2 to 2, and S 2 which maps d 1 and d 2 to 1. The first switching produces a graph G( , S 1 ) whose acyclicity is obtained exactly as in the tensor/par situation above. The second switching produces the following graph G( , S 2 ): whose acyclicity results from the acyclicity of G( , S 1 ) where S 1 is the switching of which is equal to S on and maps d to 1.</p><p>We shall say that a net is correct if it is weakly typable and acyclic. As we have seen, if is correct and reduces to , then is also correct. A simple net, even if it is simply typable, can have infinite reductions, as shown by the following example:</p><p>The trouble with this net is of course that it contains a cycle (put the contraction switch on the lower position). The main property of correct nets is that they enjoy strong normalization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Co-contraction and contraction trees</head><p>We call contraction trees the simple nets generated by the following inductive definition (we define in the same induction the principal port and the auxiliary ports of a contraction tree).</p><p>• A weakening cell is a contraction tree, whose principal port is the principal port of the cell and which has no auxiliary ports. • If 1 and 2 are contraction trees with disjoint sets of ports, and with principal ports p 1 and p 2 , respectively, then the net obtained by plugging p 1 and p 2 to the auxiliary ports of a contraction cell c is a contraction tree, whose principal port is the principal port of c, and whose auxiliary ports are those of 1 and those of 2 . In a completely similar way, one defines the notion of co-contraction tree.</p><p>A contraction tree with auxiliary ports p 1 , . . . , p n will typically be pictured as follows:</p><p>We adopt similar conventions for co-contraction trees.</p><p>where</p><p>• is a co-contraction tree and is a contraction tree;</p><p>• no port p i is the principal port of a co-contraction tree of and • no port q j is the principal port of a contraction tree of . This structure will be called the generalized structural redex associated to R and j = 1, . . . , m. Observe moreover that if is correct, by acyclicity, one has p i = q j for each i = 1, . . . , n. Therefore, when reducing this generalized structural redex, no new structural redex is created: this is the key observation in our proof sketch. Let S( ) be the number of structural redexes in .</p><p>If is a correct simple net, we define its measure M( ), a triple of non-negative integers, by setting M( ) = (| | P , S( ), | | S ) if is not normal, and M( ) = (0, 0, 0) if is normal. We extend this notion of measure to arbitrary correct nets = n i=1 i (where the i 's are simple and correct) by setting M( ) = max n i=1 M( i ), triples of integers being ordered under the lexicographic order.</p><p>We define now a particular reduction (a non-deterministic reduction strategy) first as a relation from correct simple nets to correct nets as follows. Let be a correct simple net and let be a net, we say that w if (1) contains a dereliction/co-weakening or a co-dereliction/weakening redex and = 0, and else if (2) contains a tensor/par or a dereliction/co-dereliction redex and is obtained from by reducing this redex, and else if (3) contains a structural redex and is obtained from by reducing the associated generalized structural redex (in the sense of the generalized reduction defined above), and else if (4) contains a dereliction/co-contraction or a co-dereliction/contraction redex and is obtained from by reducing this redex. Observe then that * (and hence is correct) and that M( ) &lt; M( ) (for the lexicographic order on triples of integers). Observe also that if is a correct simple net which is not normal, then w for some net since one of the four cases enumerated above must occur. We extend this reduction relation to arbitrary correct nets as follows: if is a sum n i=1 i of simple correct nets, we say that w if = n i=1 i where, for each i, i = i if i is normal, and i w i otherwise. Again, if is an arbitrary correct net and w for this extended notion of reduction, then * (and hence is correct) and M( ) &lt; M( ). This proves that our reduction is weakly normalizing, as announced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Interpreting the resource lambda-calculus in differential nets</head><p>The resource lambda-calculus (or lambda-calculus with multiplicities) has been invented by Boudol <ref type="bibr" target="#b2">[3]</ref> and further studied also by Curien and Lavatelli <ref type="bibr" target="#b3">[4]</ref>. The work of Kfoury <ref type="bibr" target="#b12">[13]</ref> develops the same line of ideas consisting in introducing, within an ordinary lambda-calculus, the idea of linear application, a new kind of application where the argument is provided exactly once to the function. The motivations of these authors were quite different, but their basic idea of linear application can be interpreted in our setting as differential application.</p><p>Let us consider a version of the resource lambda-calculus where application is really linear (not affine). A more comprehensive study of this calculus is available in <ref type="bibr" target="#b9">[10]</ref> The syntax we define has two sorts (simple 9 terms and simple poly-terms) which are defined by mutual induction as follows. As usual, we are given a denumerable supply of variables.</p><p>• If x is a variable, then x is a simple resource term.</p><p>• If x is a variable and s is a simple resource term, then x s is a simple resource term.</p><p>• If s is a simple resource term and S is a simple poly-term, then s S is a simple resource term.</p><p>• If s 1 , . . . , s n are simple resource terms, then [s 1 , . . . , s n ] (the multi-set consisting of these terms, repetitions being taken into account) is a simple poly-term. In the present setting, we find convenient to use the following more algebraic notations for multi-sets representing simple poly-terms: 1 represents the empty simple poly-term, if t is a simple resource term, t also denotes the simple</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Blute</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cockett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Seely</surname></persName>
		</author>
		<title level="m">Differential categories</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>unpublished article</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fock space: a model of linear exponential types</title>
		<author>
			<persName><forename type="first">R</forename><surname>Blute</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Panangaden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Seely</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Ninth Conf. on Mathematical Foundations of Programming Semantics</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Ninth Conf. on Mathematical Foundations of Programming Semantics<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">802</biblScope>
			<biblScope unit="page" from="1" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The lambda calculus with multiplicities</title>
		<author>
			<persName><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">2025. 1993</date>
			<pubPlace>Sophia-Antipolis</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A semantics for lambda calculi with resource</title>
		<author>
			<persName><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-L</forename><surname>Curien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lavatelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Structures Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="437" to="482" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Decidability properties of recursive types</title>
		<author>
			<persName><forename type="first">F</forename><surname>Cardone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICTCS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Blundo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Laneve</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2841</biblScope>
			<biblScope unit="page" from="242" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The structure of multiplicatives</title>
		<author>
			<persName><forename type="first">V</forename><surname>Danos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Regnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Arch. Math. Logic</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="181" to="203" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On Köthe sequence spaces and linear logic</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ehrhard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Structures Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="579" to="623" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<author>
			<persName><forename type="first">T</forename><surname>Ehrhard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Finiteness spaces</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="615" to="646" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The differential lambda-calculus</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ehrhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Regnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">309</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="1" to="41" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Uniformity and the Taylor expansion of ordinary lambda-terms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ehrhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Regnier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Institut de mathmatiques de Luminy</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>accepted for publication</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Linear logic</title>
		<author>
			<persName><forename type="first">J.-Y</forename><surname>Girard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="1" to="102" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J.-Y</forename><surname>Girard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Solum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Structures Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="301" to="506" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A linearization of the lambda-calculus</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Kfoury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Comput</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="411" to="436" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Interaction nets</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lafont</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th Annu. Symp. on Principles of Programming Languages</title>
		<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="95" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">From proof nets to interaction nets</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lafont</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Linear Logic</title>
		<editor>
			<persName><forename type="first">J.-Y</forename><surname>Girard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Lafont</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Regnier</surname></persName>
		</editor>
		<meeting>Workshop on Linear Logic<address><addrLine>Cambridge; Ithaca, New York</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1993">1995. June 1993</date>
			<biblScope unit="page" from="225" to="247" />
		</imprint>
	</monogr>
	<note>Advances in Linear Logic</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Lambda-calcul et réseaux</title>
		<author>
			<persName><forename type="first">L</forename><surname>Regnier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-01">January, 1992</date>
			<biblScope unit="volume">7</biblScope>
		</imprint>
		<respStmt>
			<orgName>Université Paris</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Thèse de doctorat</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Pi-calculus</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Mobile Processes</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The differential lambda-mu calculus</title>
		<author>
			<persName><forename type="first">L</forename><surname>Vaux</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Institut de Mathématiques de Luminy</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>submitted for publication</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
