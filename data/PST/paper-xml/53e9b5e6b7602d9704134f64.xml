<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Algorithms for processing K-closest-pair queries in spatial databases</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">A</forename><surname>Corral</surname></persName>
							<email>acorral@ual.es</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Languages and Computation</orgName>
								<orgName type="institution">University of Almeria</orgName>
								<address>
									<postCode>04120</postCode>
									<settlement>Almeria</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Y</forename><surname>Manolopoulos</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">Aristotle University of Thessaloniki</orgName>
								<address>
									<postCode>54006</postCode>
									<settlement>Thessaloniki</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Y</forename><surname>Theodoridis</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">University of Piraeus</orgName>
								<address>
									<postCode>18534</postCode>
									<settlement>Piraeus</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><surname>Vassilakopoulos</surname></persName>
							<affiliation key="aff3">
								<orgName type="department" key="dep1">Department of Informatics</orgName>
								<orgName type="department" key="dep2">Technological Educational Institute of Thessaloniki</orgName>
								<address>
									<postBox>P.O. Box 14561</postBox>
									<postCode>54101</postCode>
									<settlement>Thessaloniki</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Algorithms for processing K-closest-pair queries in spatial databases</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">145EDE98CCA263BD1E04C7CC046B3925</idno>
					<idno type="DOI">10.1016/j.datak.2003.08.007</idno>
					<note type="submission">Received 4 December 2002; received in revised form 18 June 2003; accepted 20 August 2003</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Spatial databases</term>
					<term>Branch-and-bound algorithms</term>
					<term>Query processing</term>
					<term>R-tree</term>
					<term>Distance join</term>
					<term>I/O and response time performance</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper addresses the problem of finding the K closest pairs between two spatial datasets (the socalled, K closest pairs query, K-CPQ), where each dataset is stored in an R-tree. There are two different techniques for solving this kind of distance-based query. The first technique is the incremental approach, which returns the output elements one-by-one in ascending order of distance. The second one is the nonincremental alternative, which returns the K elements of the result all together at the end of the algorithm. In this paper, based on distance functions between two MBRs in the multidimensional Euclidean space, we propose a pruning heuristic and two updating strategies for minimizing the pruning distance, and use them in the design of three non-incremental branch-and-bound algorithms for K-CPQ between spatial objects stored in two R-trees. Two of those approaches are recursive following a Depth-First searching strategy and one is iterative obeying a Best-First traversal policy. The plane-sweep method and the search ordering are used as optimization techniques for improving the naive approaches. Besides, a number of interesting extensions of the K-CPQ (K-Self-CPQ, Semi-CPQ, K-FPQ (the K-farthest pairs query), etc.) are discussed. An extensive performance study is also presented. This study is based on experiments performed with real datasets. A wide range of values for the basic parameters affecting the performance of the algorithms is examined in order to designate the most efficient algorithm for each setting of parameter values. Finally, an experimental study of the behavior of the proposed K-CPQ branch-and-bound algorithms in terms of scalability of the dataset size and the K value is also included.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The term ''Spatial Database'' refers to a database that stores data for phenomena on, above or below the earthÕs surface <ref type="bibr" target="#b24">[25]</ref>, or in general, various kinds of multidimensional entities of modern life (e.g. the layout of a VLSI design). In other words, a spatial database is a database system with the ability to handle geometric, geographic, or spatial data (i.e. data related to space). In a computer system, these data are represented by points, line segments, regions, polygons, volumes and other kinds of 2-d/3-d geometric entities and are usually referred to as spatial objects (from now on, simply objects). For example, a spatial database may contain polygons that represent building footprints from a satellite image, or points that represent the positions of cities, or line segments that represent roads. Spatial databases include specialized systems like Geographical databases, CAD databases, Multimedia databases, Image databases, etc. Recently, the role of spatial databases is continuously increasing in many modern applications; e.g. mapping, urban planning, transportation planning, resource management, geomarketing, archeology and environmental modeling are just some of these applications.</p><p>The key characteristic that makes a spatial database a powerful tool is its ability to manipulate spatial data, rather than simply to store and represent them. The basic form of such a database is answering queries related to the spatial properties of data. Some typical spatial queries are the following.</p><p>• A ''Point Location Query'' seeks for the objects that fall on a given point (e.g. the country where a specific city belongs). • A ''Range Query'' seeks for the objects that are contained within a given region, usually expressed as a rectangle or a sphere (e.g. the pathways that cross a forest). • A ''Join Query'' may take many forms. It involves two or more spatial datasets and discovers pairs (or tuples, in case of more than two datasets) of objects that satisfy a given spatial predicate <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b27">28</ref>] (e.g. the pairs of boats and stormy areas, for boats sailing across a storm). The distance join <ref type="bibr" target="#b20">[21]</ref> was recently introduced to compute a subset of the Cartesian product of two datasets, specifying an order on the result based on distance (e.g. the pairs of hotels and archeological sites, ordered by driving distance up to 50 km between them). • Finally, very common is the ''Nearest Neighbor Query'' that seeks for the objects residing more closely to a given object. In its simplest form, it discovers one such object (the nearest neighbor) <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b31">32]</ref>. Its generalization discovers K such objects (K nearest neighbors), for a given K (e.g. the K ambulances closer to a spot where an accident with K injured persons occurred).</p><p>Branch-and-bound <ref type="bibr" target="#b22">[23]</ref> has been the most successful technique for designing algorithms that answer queries on tree structures. Lower and upper bounding functions are the basis of the computational efficiency of branch-and-bound algorithms. Moreover, the computational behavior of this kind of algorithms is highly dependent on the searching strategy chosen, for instance Best-First and Depth-First, which are used in most situations. Numerous branch-and-bound algorithms for queries (exact query, range query, nearest neighbor query and spatial join) using spatial access methods have been studied in the literature. Here, we show how these bounding functions and searching strategies perform when they are included in branch-and-bound algorithms for a special distance-based query, the K closest pairs query.</p><p>The distance between two objects is measured using some metric function over the underlying data space. The most common metric function is the Euclidean distance. We can use the Euclidean distance for expressing the concepts of ''neighborhood'' and ''closeness''. The concept of ''neighborhood'' is related to the discovery of all objects that are ''near'' to a given query object. The concept of ''closeness'' is related to the discovery of all pairs of objects that are ''close'' to each other. In this paper, we examine a query, called ''K Closest Pairs Query'' (K-CPQ), that discovers the K pairs (K P 1) of objects formed from two datasets that have the K smallest distances between them. The K-CPQ is a combination of join and nearest neighbor queries. Like a join query, all pairs of objects are candidates for the result. Like a nearest neighbor query, proximity metrics form the basis for pruning heuristics and the final ordering.</p><p>K-CPQs are very useful in many applications that use spatial data for decision making and other demanding data handling operations. For example, the first dataset may represent the cultural landmarks of the United States, while the second set may contain the most populated places of North America (see Fig. <ref type="figure" target="#fig_7">9</ref>). A K-CPQ will discover the K closest pairs of cities and cultural landmarks providing an order to the authorities for the efficient scheduling of tourist facilities creation, etc. The K value could be dependent on the budget of the authorities allocated for this purpose.</p><p>The fundamental assumption is that the two datasets are indexed by structures of the R-tree family <ref type="bibr" target="#b17">[18]</ref>. The R-tree and its variants (R þ -tree <ref type="bibr" target="#b33">[34]</ref>, R Ã -tree <ref type="bibr" target="#b1">[2]</ref>, etc.) are considered as excellent choices for indexing various kinds of spatial data (points, line segments, rectangles, polygons, etc.) and have already been adopted in commercial systems (e.g. Informix <ref type="bibr" target="#b3">[4]</ref>, Oracle <ref type="bibr" target="#b26">[27]</ref>). In this paper, based on distance functions between minimum bounding rectangles (MBRs) in the multidimensional Euclidean space, we present a pruning heuristic and two updating strategies for minimizing the pruning distance (i.e. the distance of the Kth closest pair found during the processing of the algorithm) and use them in the design of three different non-incremental branchand-bound algorithms for solving the K-CPQ. Two of them are recursive algorithms following a Depth-First searching strategy; the third one is iterative following a Best-First traversal policy. The plane-sweep method and the search ordering are used as optimization techniques for improving the naive approaches. Moreover, an extensive performance study, based on experiments performed with real datasets, is presented. A wide range of values for the basic parameters affecting the performance of the algorithms is examined. The outcome of the above studies is the determination of the algorithm outperforming all the others for each set of parameter values.</p><p>In addition, experimental results for three special cases of the query under consideration are examined: <ref type="bibr" target="#b0">(1)</ref> the K self-closest pair query (K-Self-CPQ), where both datasets refer to the same entity; (2) the semi-closest pair query (Semi-CPQ), where for each object of the first dataset, the closest object of the second dataset is computed; and (3) the K-farthest pairs query (K-FPQ), finding the K farthest pairs of objects from two datasets. Besides, the scalability of the proposed algorithms is studied. That is, the increase of the I/O cost and response time of each algorithm is analyzed in terms of the dataset size and the number K of closest pairs. The organization of this paper is as follows: Section 2 discusses the incremental and non-incremental algorithmic approaches for the CPQ, as well as the motivation of this research. In Section 3, the K-CPQ, a review of R-trees and some useful functions on pairs of MBRs are presented. In Section 4, a pruning heuristic, two updating strategies and three new non-incremental branch-and-bound algorithms for K-CPQ are introduced. Section 5 exhibits a detailed performance study of all algorithms for K-CPQs, including the effect of buffering, K-Self-CPQ, Semi-CPQ, K-FPQ and a scalability study. In Section 6, conclusions on the contribution of this paper and related future research plans are presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work and motivation</head><p>There are two approaches for solving distance-based queries. The first one is the incremental alternative <ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b32">33]</ref>, which satisfies the query by reporting the desired elements of the result in ascending order of distance in a pipelined fashion (one-by-one), i.e. the user can have part of the final result before the end of the algorithm execution. In other words, when the incremental algorithms have obtained K elements of the result, then it is not necessary to restart the algorithm to find the (K þ 1)th element but just to perform an additional step. The kernel of the incremental algorithms is a priority queue built on a distance function associated to the specific kind of the distance-based query. The strong point of this approach is that, when K is unknown in advance, the user stops when he/she is satisfied by the result. On the other hand, when the number of elements in the result grows, the amount of the required resources to perform the query increases too. Thus, incremental algorithms are competitive when a small quantity of elements of the result is needed.</p><p>The second approach is the non-incremental one <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b31">32]</ref>, which assumes that K is known in advance and reports the K elements of the result all together at the end of the algorithm, i.e. the user can not have any result until the algorithm ends. The main issue of the non-incremental variant is to separate the treatment of the terminal candidates (the elements of the final result) from the rest of the candidates. Since the algorithm is not incremental, when one wants to obtain M results just after the execution of the algorithm for K (M &gt; K), he/she must restart the algorithm with M as input without reusing the previous result to obtain the remaining M À K elements. However, the advantage of the non-incremental approach is that the pruning process during the algorithm execution is more effective even when K is large enough, as it will be shown later in the experimental section.</p><p>Numerous algorithms exist for answering distance-based queries. Most of these algorithms focus in the nearest neighbors query (NNQ) on multidimensional access methods. The importance of NNQ is motivated by the great number of application fields such as GIS, CAD, pattern recognition, document retrieval, etc. For example, algorithms exist for k-d-trees <ref type="bibr" target="#b13">[14]</ref>, quadtreerelated structures <ref type="bibr" target="#b19">[20]</ref>, R-trees <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b31">32]</ref>, etc. In addition, similar algorithms can be applied to other recent multidimensional access methods for decreasing the I/O activity and the CPU cost.</p><p>To the authorsÕ knowledge, <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b32">33]</ref> are the most relevant references for closest pairs queries (CPQ) in spatial databases using R-trees. In <ref type="bibr" target="#b20">[21]</ref>, an incremental algorithm based on priority queues is presented for solving the distance join query and its extension for semi-distance join query. The techniques proposed in <ref type="bibr" target="#b20">[21]</ref> are enhanced in <ref type="bibr" target="#b32">[33]</ref> for the K-distance join and incre-mental distance join by using adaptive multistage and plane-sweep techniques <ref type="bibr" target="#b30">[31]</ref>, as well as other improvements based on sweeping axis and sweeping direction. In <ref type="bibr" target="#b7">[8]</ref>, non-incremental recursive and iterative branch-and-bound algorithms are presented for solving the K-CPQ on points.</p><p>The first two efforts described in the previous paragraph follow the incremental approach, optimizing the required resources and the processing strategy. The motivation for this paper (our main objective), is to extend and enhance the work presented in <ref type="bibr" target="#b7">[8]</ref> with respect to the design of branch-and-bound algorithms (recursive and iterative) in a non-incremental way for answering K-CPQs between two datasets stored in an R-tree <ref type="bibr" target="#b17">[18]</ref>. To carry out this extension and enhancement, we study the distance functions and the branch-and-bound algorithms used to answer the K-CPQ. We propose a pruning heuristic and two updating strategies that comprise the kernel in the design of branch-and-bound algorithms for solving this kind of query. Besides, we apply techniques for improving the performance with respect to the I/O activity (buffering) and response time (planesweep). Moreover, we study extensions of our non-incremental algorithms for operations related to the K-CPQ, as K-Self-CPQ, Semi-CPQ, K-FPQ, etc. Finally, in our experiments we employ very large real datasets of different nature (line segments and points) to study the performance of the algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The K-closest-pair query using R-trees</head><p>In this section, K-CPQ is defined and a brief description of R-trees is also presented, pointing out the main characteristics of the R Ã -tree. Moreover, some useful functions on pairs of MBRs, which will be used in branch-and-bound algorithms for answering the K-CPQ are introduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Definition of the query</head><p>We assume a finite point dataset P in the d-dimensional data space R d and a metric distance function dist for a pair of points, i.e. dist : P Â P ! R þ . 8p; q; r 2 P , the function dist satisfies the four following conditions: (1) distðp; qÞ P 0, ''non-negativity''. (2) distðp; qÞ ¼ 0 () p ¼ q, ''identity''. (3) distðp; qÞ ¼ distðq; pÞ, ''symmetry''. (4) distðp; qÞ 6 distðp; rÞ þ distðr; qÞ, ''D-inequality''.</p><p>The more general expression for dist between two points, p ¼ ðp 1 ; p 2 ; . . . ; p d Þ and q ¼ ðq 1 ; q 2 ; . . . ; q d Þ in the d-dimensional data space is called L t -distance ðL t Þ, L t -metric or Minkowski distance. Its definition (included in this paper for clarity) is as follows:</p><formula xml:id="formula_0">L t ðp; qÞ ¼ X d i¼1 jp i À q i j t ! 1=t ; 1 6 t &lt; 1 and L 1 ðp; qÞ ¼ max 1 6 i 6 d jp i À q i j; t ¼ 1</formula><p>For t ¼ 2 we derive the Euclidean distance and for t ¼ 1 the Manhattan distance. These are the most known L t -metrics. Often, the Euclidean distance is used as the distance function but, depending on the application, other distance functions may be more appropriate.</p><p>A property of the L t -distance function (dimension distance property) is that the value of this function for a given dimension (1 6 i 6 d) is always smaller than or equal to the total computation of the L t -distance for all d-dimensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dimension distance property:</head><p>L t ðp; q; iÞ ¼ jp i À q i j 6 L t ðp; qÞ; 1 6 i 6 d and 1 6 t 6 1 ð 1Þ</p><p>The d-dimensional Euclidean space, E ðdÞ , is the pair</p><formula xml:id="formula_1">ðR d ; L 2 Þ.</formula><p>In other words, it is the ddimensional data space R d , equipped with the Euclidean distance (in the sequel, we will use dist instead of L 2 ). In the following, we formally define the K-CPQ.</p><p>Definition. Let two point sets, P ¼ fp 1 ; p 2 ; . . . ; p NP g and Q ¼ fq 1 ; q 2 ; . . . ; q NQ g in E ðdÞ , be stored in a spatial database. Then, the result of the K closest pairs query K-CPQðP ; Q; KÞ is a set of ordered sequences of K (1 6 K 6 jP j Á jQj) different pairs of points of P Â Q, with the K smallest distances between all possible pairs of points that can be formed by choosing one point of P and one point of Q: K-CPQðP ; Q; KÞ ¼ fððp 1 ; q 1 Þ; ðp 2 ; q 2 Þ; . . . ; ðp K ; q K ÞÞ; p 1 ; p 2 ; . . . ; p K 2 P ; q 1 ; q 2 ; . . . ; q K 2 Q : ðp i ; q i Þ 6 ¼ ðp j ; q j Þ; i 6 ¼ j; 1 6 i; j 6 K and 8ðp i ;</p><formula xml:id="formula_2">q j Þ 2 P Â Q À fðp 1 ; q 1 Þ; ðp 2 ; q 2 Þ; . . . ; ðp K ; q K Þg; distðp i ; q j Þ P distðp K ; q K Þ P distðp KÀ1 ; q KÀ1 Þ P Á Á Á P distðp 2 ; q 2 Þ P distðp 1 ; q 1 Þg</formula><p>Note that, due to ties of distances, the result of the K-CPQ may not be a unique ordered sequence for a specific pair of point sets P and Q. The aim of the proposed algorithms is to find one of the possible instances, although it would be straightforward to obtain all of them.</p><p>The extension of K-CPQ definition in terms of points to other spatial data types (line segment, region, rectangles, etc.) is straightforward. An object ''obj'' in a spatial database is usually defined by several non-spatial attributes and one attribute of some spatial data type. This spatial attribute describes the objectÕs spatial extent ''obj.G'', i.e. the location, shape, orientation and size of the object. In the spatial database literature, the terms: geometric description, shape description and spatial extension are often used instead of spatial extent. The single modification on the K-CPQ definition is the replacement of points p and q with objects p and q with spatial extent p.G and q.G, respectively, in E ðdÞ and the replacement of the distance between two points (dist) with the distance between two objects, provided that a distance function can be defined between the type of the objects.</p><p>As stated earlier, the two datasets are stored in R-trees. This means that the specific data organization by R-trees should be taken into account in the design of efficient algorithms. In the next subsection, we briefly review the R-tree family.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">R-trees</head><p>R-trees <ref type="bibr" target="#b17">[18]</ref> are hierarchical, height balanced multidimensional data structures, designed for using in secondary storage, and it is a generalization of B-trees <ref type="bibr" target="#b9">[10]</ref> for multidimensional data spaces. They are used for the dynamic organization of a set of d-dimensional objects represented by their d-dimensional MBRs. These MBRs are characterized by ''min'' and ''max'' points of hyper-rectangles with faces parallel to the coordinate axes. Using the MBR instead of the exact geometrical representation of the object, its representational complexity is reduced to two points, where the most important object features (position and extension) are maintained. Consequently, the MBR is an approximation widely employed.</p><p>Each R-tree node corresponds to the MBR that contains its children. The tree leaves contain pointers to the database objects instead of pointers to child nodes. The nodes are implemented as disk pages. It must be noted that the rectangles that surround different nodes may overlap. Besides, a rectangle can be included (in the geometrical sense) in many nodes, but can be associated to only one of them. This means that a search may demand visiting many nodes, before confirming the existence or not of a given MBR.</p><p>The rules obeyed by the R-tree are as follows: leaves reside on the same level; each leaf contains entries of the form (MBR, Oid), such that MBR is the minimum bounding rectangle that encloses the object determined by the identifier Oid; internal nodes contain entries of the form (MBR, Addr), where Addr is the address of the child node and MBR is the minimum bounding rectangle that encloses MBRs of all entries in that child node; nodes (except possibly for the root) of an Rtree of class ðm; MÞ contain between m and M entries, where m 6 dM=2e (M and m are also called maximum and minimum branching factor or fan-out); the root contains at least two entries, if it is not a leaf. Fig. <ref type="figure" target="#fig_0">1</ref> depicts some rectangles on the left and the corresponding R-tree on the right. Dotted lines denote the bounding rectangles of the subtrees that are rooted in inner nodes.</p><p>Like other tree access methods, an R-tree partitions the multidimensional space by grouping objects in a hierarchical manner. A subspace occupied by an R-tree node is always contained in the subspace of its parent node, i.e. the MBR enclosure property. According to this property, an MBR of an R-tree node (at any level, except at the leaf level) always encloses the MBRs of its descendent R-tree nodes. Spatial join algorithms as well as distance-based query algorithms commonly use this characteristic of spatial containment between MBRs of R-tree nodes.</p><p>Another important property of the R-trees is the MBR face property <ref type="bibr" target="#b31">[32]</ref>. This property means that every face of any MBR of an R-tree node (at any level) touches at least one point of some object in the spatial database. This characteristic of the MBR faces stored in R-tree nodes is used by distance-based query algorithms.</p><p>Many variations of R-trees have appeared in the literature (an exhaustive survey can be found in <ref type="bibr" target="#b14">[15]</ref>). One of the most popular and efficient variations is the R Ã -tree <ref type="bibr" target="#b1">[2]</ref>. The R Ã -tree added two major enhancements to the R-tree, in case that a node overflows. First, rather than just considering the area, the node-splitting algorithm in the R Ã -tree also minimized the perimeter and overlap enlargement of the MBRs. It tends to reduce the number of subtrees to follow for search operations. Second, the R Ã -tree introduced the notion of forced reinsertion to make the tree shape less dependent to the insertion order. When a node overflows, it is not split immediately, but a portion of entries of the node is reinserted from the tree root. The forced reinsertion provides two important improvements: (i) it may reduce the number of splits and, (ii) it is a dynamic technique for tree reorganization. With these two enhancements, the R Ã -tree generally outperforms R-tree.</p><p>It is commonly accepted that the R Ã -tree is one of the most efficient R-tree variants. Thus, we choose R Ã -trees to perform our experimental study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Functions on pairs of MBRs</head><p>Since the different algorithms for K-CPQ act on pairs of R-trees (R P and R Q ), some important functions on pairs of MBRs will be defined. Let N P and N Q be two internal nodes of R P and R Q , with M P and M Q the respective MBRs of N P and N Q . These MBRs contain all the points residing in the respective subtrees. In order for these MBRs to be the minimum ones, at least one point has to be located at each edge of their rectangles. The following functions of MBRs work for any number of dimensions, although in the examples are restricted to two dimensions. Let r 1 , r 2 , r 3 and r 4 be the four edges of M P , whereas s 1 , s 2 , s 3 and s 4 are the four edges of M Q . By MinDistðr i ; s i Þ we denote the minimum distance between two points falling on r i and s i . Accordingly, by MaxDistðr i ; s i Þ we denote the maximum distance between two points falling on r i and s i . In the sequel, we extend definitions of metrics between a point and an MBR that appear in <ref type="bibr" target="#b31">[32]</ref> and define a set of useful functions of two MBRs. In case M P and M Q are disjoint we can define a function that expresses the minimum possible distance of two points contained in different MBRs:</p><formula xml:id="formula_3">MINMINDISTðM P ; M Q Þ ¼ min i;j fMinDistðr i ; s j Þg<label>ð2Þ</label></formula><p>If the two nodesÕ MBRs intersect, MINMINDISTðM P ; M Q Þ equals 0. In any case (either intersecting or disjoint MBRs) we can define the functions:</p><formula xml:id="formula_4">MINMAXDISTðM P ; M Q Þ ¼ min i;j fMaxDistðr i ; s j Þg<label>ð3Þ</label></formula><formula xml:id="formula_5">MAXMAXDISTðM P ; M Q Þ ¼ max i;j fMaxDistðr i ; s j Þg<label>ð4Þ</label></formula><p>MAXMAXDIST expresses the maximum possible distance of any two points contained in different MBRs. MINMAXDIST expresses an upper bound for the distance of at least one pair of points. More specifically, there exists at least one pair of points (contained in different MBRs) with distance smaller than or equal to MINMAXDIST. In Fig. <ref type="figure" target="#fig_1">2</ref>, two MBRs and their MIN-MINDIST, MINMAXDIST and MAXMAXDIST distances are depicted. Let Rðs; tÞ represent an MBR in E ðdÞ , where s ¼ ðs 1 ; s 2 ; . . . ; s d Þ and t ¼ ðt 1 ; t 2 ; . . . ; t d Þ, such that s i 6 t i , for 1 6 i 6 d, are the endpoints of one of its major diagonals. We present algorithmic definitions of the above functions in E ðdÞ . Using these definitions, it is easy to devise efficient algorithms for calculating the functions.</p><p>Definition. Given two MBRs R 1 ðs; tÞ and R 2 ðp; qÞ in E ðdÞ , MINMINDISTðR 1 ðs; tÞ; R 2 ðp; qÞÞ is defined as:</p><formula xml:id="formula_6">MINMINDISTðR 1 ðs; tÞ; R 2 ðp; qÞÞ ¼ ffiffiffiffiffiffiffiffiffiffiffiffi X d i¼1 y 2 i v u u t</formula><p>; where y i ¼</p><formula xml:id="formula_7">p i À t i ; if p i &gt; t i s i À q i ; if s i &gt; q i 0; otherwise 8 &lt; :<label>ð5Þ</label></formula><p>It is interesting that Eq. ( <ref type="formula" target="#formula_7">5</ref>) also holds between points or between an MBR and a point: </p><formula xml:id="formula_8">• If t i ¼ s i for</formula><formula xml:id="formula_9">MINMINDISTðR 1 ; R 2 Þ ¼ PointDistanceðs; pÞ ¼ ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi ffi X d i¼1 js i À p i j 2 v u u t • If q i ¼ p i for R 2 ðp; qÞ, R 2 degenerates into a point p ¼ ðp 1 ; p 2 ; . . . ; p d Þ; then [32]: MINMINDISTðR 1 ; R 2 Þ ¼ MINDISTðR 1 ; pÞ ¼ ffiffiffiffiffiffiffiffiffiffiffiffi X d i¼1 y 2 i v u u t where y i ¼ p i À t i ; if p i &gt; t i s i À p i ; if s i &gt; p i 0; otherwise 8 &lt; :</formula><p>Thus, MINMINDIST of two MBRs is a generalization of the distance between points and MBRs. This property allows us to apply MINMINDIST to pairs of any kind of elements (i.e. MBRs or points) stored in R-trees during the computation of branch-and-bound algorithms for K-CPQ.</p><p>Another property of the MINMINDIST function is based on the dimension distance property, and it can be stated as follows (easily proven by combining the definition of MINMINDIST between two MBRs (Eq. ( <ref type="formula" target="#formula_7">5</ref>)) and the dimension distance property (Eq. ( <ref type="formula">1</ref>))).</p><p>Dimension MINMINDIST property: Given two MBRs R 1 ðs; tÞ and R 2 ðp; qÞ in E ðdÞ , the value of MINMINDISTðR</p><formula xml:id="formula_10">1 ; R 2 Þ for a given dimension 1 6 i 6 d is always smaller than or equal to MINMINDISTðR 1 ; R 2 Þ. MINMINDISTðR 1 ; R 2 ; iÞ 6 MINMINDISTðR 1 ; R 2 Þ; 81 6 i 6 d such that MINMINDISTðR 1 ; R 2 ; iÞ ¼ y i ; where y i ¼ p i À t i ; if p i &gt; t i s i À q i ; if s i &gt; q i 0; otherwise 8 &lt; :</formula><p>The main usefulness of MINMINDIST for a given dimension is that it is computationally cheaper than MINMINDIST and thus we may obtain a performance gain in some situations (e.g. plane-sweep technique <ref type="bibr" target="#b30">[31]</ref>) for a given dimension.</p><p>A third important property of the MBRs stored in two different R-trees related to the MIN-MINDIST function is called MBRs MINMINDIST property. This property can be stated as follows (again, it is easily proven by combining the definition of MINMINDIST between two MBRs (Eq. ( <ref type="formula" target="#formula_7">5</ref>)) and the MBR enclosure property).</p><p>MBRs MINMINDIST property: Consider two R-tree internal nodes N P and N Q (with MBRs M P 0 and M Q0 ) of two R-trees R P and R Q , respectively. These two internal nodes are enclosing two sets of MBRs fM P 1 ; M P 2 ; . . . ; M PA g and fM Q1 ; M Q2 ; . . . ; M QB g. Then (the proofs are simple and left as an exercise to the interested reader)</p><formula xml:id="formula_11">MINMINDISTðM Pi ; M Qj Þ P MINMINDISTðM P 0 ; M Q0 Þ 81 6 i 6 A and 81 6 j 6 B MINMINDISTðM P 0 ; M Qj Þ P MINMINDISTðM P 0 ; M Q0 Þ 81 6 j 6 B MINMINDISTðM Pi ; M Q0 Þ P MINMINDISTðM P 0 ; M Q0 Þ 81 6 i 6 A</formula><p>In other words, the minimum distance between two MBRs of two internal nodes N P and N Q (with MBRs M P 0 and M Q0 ) is always smaller than or equal to the minimum distance between one of the MBRs enclosed by M P 0 and one of the MBRs enclosed by M Q0 (i.e. MINMINDIST is monotonically non-decreasing with the R-tree heights). This property allows us to limit the search space when we apply a branch-and-bound algorithm for K-CPQ. Fig. <ref type="figure">3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>illustrates this property for</head><formula xml:id="formula_12">A ¼ B ¼ 3.</formula><p>Definition. Given two MBRs R 1 ðs; tÞ and R 2 ðp; qÞ in E ðdÞ , MAXMAXDISTðR 1 ðs; tÞ, R 2 ðp; qÞÞ is defined as:</p><formula xml:id="formula_13">MAXMAXDISTðR 1 ðs; tÞ; R 2 ðp; qÞÞ ¼ ffiffiffiffiffiffiffiffiffiffiffiffi X d i¼1 y 2 i v u u t</formula><p>; where y i ¼ maxfjs i À q i j; jt i À p i jg ð6Þ</p><p>Definition. </p><formula xml:id="formula_14">8 &gt; &gt; &gt; &lt; &gt; &gt; &gt; : 9 &gt; &gt; &gt; = &gt; &gt; &gt; ;<label>ð7Þ</label></formula><formula xml:id="formula_15">MP0 MQ0 MINMINDIST(M P2 , M Q2 ) MP1 MP3 MP2 MQ3 M Q1 MQ2 MINMINDIST(M P0 , M Q0 ) Fig. 3. MBRs MINMINDIST property in E ð2Þ .</formula><p>where F ðRðz; xÞ; i; x i Þ denotes the face of the MBR Rðz; xÞ containing all points with value x i at coordinate i. In other words, it denotes the face that is orthogonal to dimension i at value x i (note that, for an MBR Rðz; xÞ, there are two faces orthogonal to dimension i, one at value x i and another at value z i ). The function MAXDIST calculates the maximum distance between two such faces from different MBRs. For this calculation, it suffices to compare the distances between each endpoint of one face to each endpoint of the other face. Each face of dimension d has 2 dÀ1 endpoints. For example, the set of endpoints of F ðRðz; xÞ; i; x i Þ consists of all the points with value x i at coordinate i and with value either x l , or z l at each coordinate l 6 ¼ i.</p><p>Note that the definitions of MINMINDIST and MAXMAXDIST lead to algorithms of OðdÞ time, whereas the definition of MINMAXDIST results in an exponential algorithm, due to the computation of the distances (MAXDIST) between each endpoint of one face (2 dÀ1 ) and each endpoint of the other face (2 dÀ1 ) and the calculation of the minimum distance from 2d faces in one MBR against the other 2d faces in the other MBR. For small d values (e.g. d &lt; 4) the cost of using definition of MINMAXDIST is not prohibitive. For larger d values, an alternative definition could be used which gives an upper bound for the value produced by definition of MINMAX-DIST. This definition is presented in the following and leads to an OðdÞ algorithm. For each dimension j (where 1 6 j 6 d), it computes the minimum of the MAXDIST values of all the pairs of faces orthogonal to dimension j (the two faces of each pair belong in different MBRs). The final result is the minimum of all these j values (a minimum of subminima). In general, the computed value is larger than or equal to (an upper bound of) the minimum of the MAXDIST values of every possible pair of faces.</p><p>Definition. Given two MBRs R 1 ðs; tÞ and R 2 ðp; qÞ in E ðdÞ , an upper bound of MINMAXDISTðR 1 ðs; tÞ; R 2 ðp; qÞÞ is:</p><formula xml:id="formula_16">MINMAXDISTðR 1 ðs; tÞ; R 2 ðp; qÞÞ ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi min 1 6 j 6 d x 2 j þ X d i¼1;i6 ¼j y 2 i ( ) v u u t<label>ð8Þ</label></formula><p>where x j ¼ minfjs j À p j j; js j À q j j; jt j À p j j; jt j À q j jg and y i ¼ maxfjs i À q i j; jt i À p i jg:</p><p>Definition. Given two objects o 1 and o 2 in E ðdÞ , the minimum distance between them, denoted by kðo 1 ; o 2 Þk, is:</p><formula xml:id="formula_17">kðo 1 ; o 2 Þk ¼ min f 1 2F ðo 1 Þ;f 2 2F ðo 2 Þ min p 1 2f 1 ;p 2 2f 2 fdistðp 1 ; p 2 Þg<label>ð9Þ</label></formula><p>where F ðo 1 Þ and F ðo 2 Þ denote the set of faces of the object o 1 and o 2 in E ðdÞ , respectively. Moreover, f 1 and f 2 are instances of the sets of faces F ðo 1 Þ and F ðo 2 Þ. Here, dist is the Euclidean distance between two points p 1 and p 2 defined in E ðdÞ .</p><p>Lemma 1. Consider two MBRs M P 0 ðs; tÞ and M Q0 ðp; qÞ in E ðdÞ , enclosing two set of objects</p><formula xml:id="formula_18">O 1 ¼ fo 1i : 1 6 i 6 N 1 g and O 2 ¼ fo 2j : 1 6 j 6 N 2 g, respectively.</formula><p>The following holds:</p><formula xml:id="formula_19">8ðo 1i ; o 2j Þ 2 O 1 Â O 2 ; MINMINDISTðM P 0 ; M Q0 Þ 6 kðo 1i ; o 2j Þk<label>ð10Þ</label></formula><p>Proof. From the definition of MINMINDIST between two MBRs and the MBR face property. h Lemma 2. Consider two MBRs M P 0 ðs; tÞ and M Q0 ðp; qÞ in E ðdÞ , enclosing two set of objects</p><formula xml:id="formula_20">O 1 ¼ fo 1i : 1 6 i 6 N 1 g and O 2 ¼ fo 2j : 1 6 j 6 N 2 g, respectively.</formula><p>The following is true:</p><formula xml:id="formula_21">8ðo 1i ; o 2j Þ 2 O 1 Â O 2 ; kðo 1i ; o 2j Þk 6 MAXMAXDISTðM P 0 ; M Q0 Þ ð<label>11Þ</label></formula><p>Proof. From the definition of MAXMAXDIST between two MBRs and the MBR face property. h Lemma 3. Consider two MBRs M P 0 ðs; tÞ and M Q0 ðp; qÞ in E ðdÞ , enclosing two set of objects</p><formula xml:id="formula_22">O 1 ¼ fo 1i : 1 6 i 6 N 1 g and O 2 ¼ fo 2j : 1 6 j 6 N 2 g, respectively.</formula><p>The following holds:</p><formula xml:id="formula_23">9ðo 1i ; o 2j Þ 2 O 1 Â O 2 ; kðo 1i ; o 2j Þk 6 MINMAXDISTðM P 0 ; M Q0 Þ ð<label>12Þ</label></formula><p>Proof. From the definition of MINMAXDIST between two MBRs and the MBR face property. h</p><p>From the previous properties and lemmas, we can deduce that MINMINDISTðR 1 ; R 2 Þ and MAXMAXDISTðR 1 ; R 2 Þ serve respectively as lower and upper bounding functions of the Euclidean distance from the K closest pairs of objects within the MBRs R 1 and R 2 . In the same sense, MINMAXDISTðR 1 ; R 2 Þ serves as an upper bounding function of the Euclidean distance from the closest pair of objects (K ¼ 1) enclosed by the MBRs R 1 and R 2 .</p><p>Usually, the distance functions are all based on a distance metric for points, distðp 1 ; p 2 Þ, such as the Euclidean metric. As in <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref>, as long as the distance functions are ''consistent'', the algorithms based on them will work correctly. Informally, by consistent, it is meant that no pair can have a smaller distance than a pair that we access during the processing of an algorithm over tree access methods <ref type="bibr" target="#b20">[21]</ref>. In the case of R-trees, this means that if o 1 and o 2 are objects indexed by the R-trees R P and R Q , respectively, and R 1 and R 2 are the MBRs at leaf level that contain o 1 and o 2 , respectively, then we must have MINMINDISTðR 1 ; R 2 Þ 6 kðo 1 ; o 2 Þk. This constraint is clearly ensured by Lemma 1 (lower-bounding property), the MBR MINMINDIST property, and the Euclidean distance properties: non-negativity and triangle inequality. Therefore, since our MINMINDIST function applied to R-tree elements is consistent, we can design algorithms based primarily on this distance function that will work correctly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Algorithms for K-closest pairs queries</head><p>In the following, based on functions between two MBRs, we present a pruning heuristic and two updating strategies for minimizing the pruning distance during the processing of branch-andbound algorithms for K-CPQ. After that, three non-incremental branch-and-bound algorithmic approaches (two recursive following a Depth-First searching strategy and one iterative following a Best-First traversal policy) for K-CPQ between objects stored in two R-trees are presented. The unfamiliar reader is advised to study the algorithms presented in <ref type="bibr" target="#b7">[8]</ref>, as a first reading. The planesweep method and the search ordering are used as optimization techniques for improving the naive approaches. Since the R-tree height depends on the number of inserted objects (as well as in the insertion order and the page size), the two R-trees may have the same or different heights, and we study two alternatives to treat this case. Finally, some extensions of the K-CPQ algorithms are shown.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Pruning heuristic and updating strategies</head><p>Based on the previous bounding functions and lemmas, we propose a pruning heuristic to discard pairs of MBRs, which will not contain the K closest pairs during the execution of the algorithm for reporting the result of K-CPQ. Besides, we present two updating strategies for minimizing the pruning distance z (distance of the Kth closest pair found so far), which are used in the pruning process.</p><p>First of all, we establish a data structure that stores the K closest pairs. This data structure will help updating z, which is the distance of the Kth closest pair discovered so far. This structure is organized as a maximum binary heap (called K-heap) and will hold pairs of objects according to their distance. The pair of objects with the largest distance resides in the K-heap root. In the implementation of the branch-and-bound algorithms for K-CPQ we must consider the following cases:</p><p>• Initially the K-heap is empty (z is initialized to 1).</p><p>• The pairs of objects discovered at the leaf level are inserted in the K-heap until it gets full (z keeps the value of 1). • Then, if the distance of a new pair of objects discovered at the leaf level is smaller than the distance of the pair residing in the K-heap root, then the latter pair is extracted, this new pair is inserted in the K-heap and the root is updated with the pair with the largest distance (z is equal to the distance of the pair of objects residing in the K-heap root).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1.">Pruning heuristic</head><p>In Fig. <ref type="figure">4</ref> two R-tree nodes (dotted rectangles) containing two MBRs (thickline rectangles) and the MINMINDIST (thin lines) and MINMAXDIST (dashed lines) distances between each pair of MBRs are depicted. It is obvious that MINMINDISTðM P 2 ; M Q2 Þ is the largest one, MINMINDISTðM P 1 ; M Q2 Þ and MINMINDISTðM P 2 ; M Q1 Þ follow, and</p><formula xml:id="formula_24">MINMINDISTðM P 1 ; M Q1 Þ M P1 M Q2 M P2 M Q1</formula><p>Fig. <ref type="figure">4</ref>. Two R-tree nodes and MINMINDISTðM Pi ;</p><formula xml:id="formula_25">M Qj Þ; MINMAXDISTðM Pi ; M Qj Þ.</formula><p>is the smallest one. If, for example MINMINDISTðM P 1 ; M Q2 Þ &gt; z &gt; MINMINDISTðM P 2 ; M Q1 Þ, the paths corresponding to ðM P 2 ; M Q2 Þ and ðM P 1 ; M Q2 Þ will be pruned.</p><p>Given two MBRs M Pi and M Qj in E ðdÞ , stored in nodes of two R-trees R P and R Q , respectively. If MINMINDISTðM Pi ; M Qj Þ &gt; z, then the pair ðM Pi ; M Qj Þ will be discarded. z can be obtained from the distance of the Kth closest pair among all pairs that have been found so far. Moreover, the z value can be optionally updated using the upper bounding functions MAXMAXDISTðR 1 ; R 2 Þ and MINMAXDISTðR 1 ; R 2 Þ for any K and K ¼ 1, respectively. However, if we apply these functions, the number of disk accesses will not be reduced and the computational cost can be increased, as was proved for K-NNQ in <ref type="bibr" target="#b5">[6]</ref>. Thereby, we can optionally use the following strategies based on upper bounding functions for updating z (trying to minimize its value, if possible).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2.">Updating strategy 1 (based on MINMAXDIST)</head><p>This first updating strategy uses Lemma 3 only for the case of K ¼ 1. That is, given two R-tree nodes N P and N Q stored in internal nodes of the R-trees R P and R Q , and enclosing two sets of MBRs fM Pi : 1 6 i 6 jN P jg and fM Qj : 1 6 j 6 jN Q jg, respectively. Then, z can be updated if, and only if z 0 has a smaller value, where z 0 is defined as follows:</p><formula xml:id="formula_26">z 0 ¼ minfMINMAXDISTðM Pi ; M Qj Þ : 1 6 i 6 jN P j and 1 6 j 6 jN Q jg<label>ð13Þ</label></formula><p>In Fig. <ref type="figure">4</ref>, the minimum MINMAXDISTðz 0 Þ is the one of the pair ðM P 1 ; M Q1 Þ. Suppose that z 0 is smaller than z, thus z is updated with MINMAXDISTðM P 1 ; M Q1 Þ. If after this updating strategy we apply the pruning heuristic, then the paths corresponding to ðM P 2 ; M Q2 Þ and ðM P 1 ; M Q2 Þ will be pruned, because MINMINDISTðM P</p><formula xml:id="formula_27">2 ; M Q2 Þ &gt; MINMINDISTðM P 1 ; M Q2 Þ &gt; z.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3.">Updating strategy 2 (based on MAXMAXDIST)</head><p>A second updating strategy uses Lemma 2 for any K. That is, consider two internal R-tree nodes N P and N Q of the R-trees R P and R Q: N P and N Q enclose two sets of MBRs fM Pi : 1 6 i 6 jN P jg and fM Qj : 1 6 j 6 jN Q jg, respectively. Then, z can be updated if, and only if z 0 has a smaller value, where z 0 can be obtained by the following procedure:</p><p>• MxMxDList is a set of all possible pairs of MBRs ðM Pi ; M Qj Þ that can be formed from the two internal nodes N P and N Q . MAXMAXDISTðM Pi ; M Qj Þ is calculated for each pair of MBRs. • MxMxDList is sorted in ascending order according to the MAXMAXDIST values (creating a sequence of pairs of MBRs with its respective MAXMAXDIST value). • We know from the properties of the R-tree index structure that the minimum number of spatial objects stored on the leaf nodes that can be enclosed by two MBRs ðM Pi ; M Qj Þ stored in internal nodes is X ðM Pi ; M Qj Þ, where m P and m Q are the minimum fan-outs of R P and R Q , respectively.</p><formula xml:id="formula_28">X ðM Pi ; M Qj Þ ¼ m level of M Pi P Â m level of M Qj Q<label>ð14Þ</label></formula><p>• Using X ðM Pi ; M Qj Þ, we can find the xth element of the sorted list MxMxDList, until the following condition is satisfied, where Total ¼ jN P j Á jN Q j.</p><formula xml:id="formula_29">X TotalÀ1 x¼0 X ðMxMxDList½x Á M Pi ; MxMxDList½x Á M Qj Þ ! P K<label>ð15Þ</label></formula><p>• Then, we can obtain z 0 ¼ MxMxDList½x Á MAXMAXDIST if ðx &lt; TotalÞ is satisfied, otherwise ðx ¼ TotalÞ z 0 ¼ 1. After that, we will update z with the z 0 value, if z 0 &lt; z holds.</p><p>The previous procedure for updating z based on MAXMAXDIST must be applied locally to two internal nodes in recursive branch-and-bound algorithms following a Depth-First searching strategy.</p><p>In Fig. <ref type="figure">5</ref> we have the same two R-tree nodes as in Fig. <ref type="figure">4</ref>, where the MAXMAXDIST distances between each pair of MBRs are depicted. Also, the sorted list MxMxDList with the value of MAXMAXDIST between all possible pairs is illustrated. For example, we suppose the level of M Pi ¼ level of M Qj ¼ 1 (the level just above the leaf level), m P ¼ m Q ¼ 3, K ¼ 10, and z ¼ 15:35 (at the current moment during the execution of the algorithm). The updating strategy works as follows:</p><formula xml:id="formula_30">x ¼ 0 [enclosedPairs ¼ 9 &lt; 10]; x ¼ 1 [enclosedPairs ¼ 18 P 10]; z 0 ¼ MxMxDList½1Á MAXMAXDIST ¼ MAXMAXDISTðM P 1 ; M Q2 Þ ¼ 9</formula><p>:70, and z ¼ 9:70 because z &lt; z 0 (9.70 &lt; 15.35). After this updating strategy we will apply the pruning heuristic with the new z value.</p><p>For the iterative branch-and-bound algorithm following a Best-First searching strategy, the global set of pairs of MBRs that take part in the above procedure for computing z 0 is the current set of pairs (set of all possible pairs of MBRs ðM Pi ; M Qj Þ that can be formed from the current two internal nodes N P and N Q ) plus the pairs of MBRs already inserted in the main minimum binary heap. In this case, we will have a maximum binary heap, MxMxDHeap, with MAXMAXDIST as a key that stores globally all pairs of MBRs for which (</p><formula xml:id="formula_31">P ðX ðM P ; M Q Þ i Þ)</formula><p>is smaller than or equal to K, and a hash table associated to this data structure to support locating a particular pair, as in <ref type="bibr" target="#b20">[21]</ref>. The procedure to update MxMxDHeap and z is very similar to the previous one for MxMxDList:</p><p>• When a candidate pair of MBRs ðM P ; M Q Þ is inserted in the main minimum binary heap, it is also inserted in MxMxDHeap. If this insertion causes the sum (</p><formula xml:id="formula_32">P ðX ðM P ; M Q Þ i Þ)</formula><p>of the minimum number of objects stored in the leaves that can be generated by all pairs of MBRs stored in MxMxDHeap be larger than K, then we remove pairs of MBRs from MxMxDHeap until this sum is smaller than or equal to K, setting z 0 to the MAXMAXDIST value of the last removed pair.</p><p>• When a candidate pair of MBRs ðM P ; M Q Þ is removed from the main minimum binary heap, it must also be removed from MxMxDHeap, if it is present. • Then, we can update z with the z 0 value, if z 0 &lt; z holds. Fig. <ref type="figure">5</ref>. Two R-tree nodes and the updating strategy using MAXMAXDISTðM Pi ; M Qj Þ.</p><p>After presenting these two updating strategies for minimizing the pruning distance (z), we must emphasize that their use is optional (controlled by a parameter passed to the algorithms), since their computational cost is greater than the performance gain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">The sorted distances recursive algorithm</head><p>This first branch-and-bound algorithm follows a Depth-First searching strategy and makes use of recursion and the previous pruning heuristic and updating strategies. In addition, we employ the property that pairs of MBRs that have smaller MINMINDIST are more likely to contain the K closest pairs and to lead to a smaller z value. A heuristic that aims at improving this branchand-bound algorithm when two internal nodes are accessed, is to sort the pairs of MBRs according to ascending order of MINMINDIST and to obey this order in propagating downwards recursively. This order of processing is expected to improve pruning of paths. Such an algorithm (sorted distances recursive, SDR) for two R-trees with the same height appears in Fig. <ref type="figure">6</ref>.</p><p>We point out that at the R-tree leaf level an object (point or MBR) or MBR of another type of objects can be stored, together with a pointer to its exact geometry kept outside of the R-tree, e.g. in a sequential file. In the first case, we will calculate MINMINDIST, since this function returns the distance between two points if the two MBRs have degenerated to two points as shown in the MINMINDIST property. In the second case, we must read the exact geometry of the pair of objects ðO 1 ; O 2 Þ and calculate its distance ObjectDistanceðO 1 ; O 2 Þ, using techniques presented in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>In the example of Fig. <ref type="figure">4</ref>, the order of paths that will be followed is: ðM P 1 ; M Q1 Þ, i.e. the one with the smallest MINMINDIST and then ðM P 2 ; M Q1 Þ. In such a case, there may be ties between the MINMINDIST values. This is likely to happen especially when the two datasets overlap. In that case, MINMINDIST will usually be 0. It is possible to get a further improvement by choosing the next pair in case of a tie using some heuristic (not following the order produced by the sorting method). In <ref type="bibr" target="#b7">[8]</ref> various such heuristics have been proposed and experimentally studied. Now, we will ignore this special treatment, since it does not significantly affect the behavior of the branch-Fig. <ref type="figure">6</ref>. The SDR algorithm. and-bound algorithm with respect to the I/O activity, and it needs computational time to be carried out.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">The plane-sweep recursive algorithm</head><p>Another improvement for a branch-and-bound algorithm making use of recursion (Depth-First traversal) is to exploit the R-tree structure utilizing the plane-sweep technique, which is a common technique for computing intersections <ref type="bibr" target="#b30">[31]</ref>. The basic idea is to move a line, the so-called sweepline, perpendicular to one of the dimensions, e.g. X -dimension, from left to right. We apply this technique for restricting all possible combinations of pairs of MBRs from two R-tree nodes N P ¼ fM Pi : 1 6 I 6 jN P jg and N Q ¼ fM Qj : 1 6 j 6 jN Q jg from R P and R Q , respectively. If we do not use this technique, then we must create a set with all possible combinations of pairs of MBRs from two R-tree nodes (jN P j Á jN Q j) and process it as in the previous recursive algorithm.</p><p>In general, the technique consists of sorting the entries of the two current R-tree nodes, based on the coordinates of one of the corners of the MBRs (e.g. lower left corner) in increasing or decreasing order. First, the dimension for the sweep-line (e.g. Sweeping_Dimension ¼ 0 or X -axis) is established based on sweeping axis criteria <ref type="bibr" target="#b32">[33]</ref>. After that, two pointers are maintained initially pointing to the first entry of each sorted R-tree node. Let Pivot be the entry of the smallest value of the MBR with lower left corner pointed by one of these two pointers, e.g. M P 1 , then Pivot is initialized to the entry associated to the MBR M P 1 . The MBR of the pivot must be paired up with the MBRs of the entries stored in the other R-tree node fM Qj : 1 6 j 6 jN Q jg from left to right that satisfies the MINMINDISTðPivot:MBR; M Qj ; Sweeping DimensionÞ 6 z, obtaining a set of entries for candidate pairs where the element Pivot.MBR is fixed. This partial set with respect to the MBR of the pivot entry will be added to a global set of candidate pairs of entries, called EN-TRIES (empty at the beginning). After all possible pairs of entries that contain Pivot.MBR have been found, the pointer of the pivot node is increases to the next entry, Pivot is updated with the entry of the next smallest value of a lower left corner of MBRs pointed by one of the two pointers, and the process is repeated.</p><p>Notice that we apply MINMINDISTðM Pi ; M Qj ; Sweeping DimensionÞ because in the planesweep technique, the sweep is only over one dimension (the best dimension according to the criteria suggested in <ref type="bibr" target="#b32">[33]</ref>). Moreover, the search is only restricted to the closest MBRs with respect to the MBR of the pivot entry according to the current z value. No duplicated pairs are obtained, since the MBRs are always checked over sorted R-tree nodes. Also, the application of this technique can be viewed as a sliding window on the sweeping dimension with a width equal to the z value starting in the MBR of the pivot, where we only choose all possible pairs of MBRs that can be formed using the MBR of the pivot and the other MBRs from the remainder entries of the other R-tree node that fall into the current sliding window. We must point out that this sliding window has a length equal to z value plus the length of the MBR of the pivot on the sweeping dimension.</p><p>The plane-sweep recursive (PSR) algorithm applies the plane-sweep technique for obtaining a reduced set of candidate pairs of entries from two R-tree nodes (ENTRIES) and it can be improved by sorting its pairs of MBRs according to ascending order of MINMINDIST or organizing ENTRIES as a minimum binary heap with MINMINDIST as a key. Then, it iterates in the set ENTRIES and propagates downwards only for the pairs of entries with MINMINDIST smaller than or equal to the z value. The PSR algorithm for two R-trees with the same height appears in Fig. <ref type="figure" target="#fig_3">7</ref>.</p><p>In the example of Fig. <ref type="figure">4</ref>, suppose that we do not apply the updating strategies for reducing z and z ¼ 2. Then we apply the plane-sweep technique taking the sweeping dimension the X -axis. The set of pairs of MBRs produced is ENTRIES ¼ fðM P 1 ; M Q1 Þg. We calculate MINMINDISTðM P 1 ; M Q1 Þ, which is smaller than z. Thus, we propagate only for ðM P 1 ; M Q1 Þ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">The plane-sweep iterative algorithm</head><p>Unlike the previous ones, this branch-and-bound algorithm is iterative. In order to overcome recursion and to keep track of propagation downwards while accessing the two R-trees, a minimum binary heap, called Main-heap, is used. Main-heap holds only pairs of addresses pointing two R-tree nodes that will be processed during the execution of the algorithm and the MIN-MINDIST value of the pair of MBRs that encloses these two R-tree nodes. That is, the item structure for Main-heap is &lt;MINMINDIST, NodeAddressR P , NodeAddressR Q &gt;, and it allows us to store this data structure entirely in main memory even for a large K value or large datasets. The pair with the smallest MINMINDIST value resides on top of Main-heap (in the root of the minimum binary heap). This pair is the next candidate for processing. Also, we can apply the plane-sweep technique in this branch-and-bound iterative algorithm in the same way as in the recursive one. Such and algorithm (plane-sweep iterative, PSI) for two R-trees with the same height appears in Fig. <ref type="figure" target="#fig_4">8</ref>.</p><p>Note that ties between MINMINDIST values may also appear as in the sorted recursive algorithm. That is, two or more pairs may have the same MINMINDIST value. If this value is the minimum one, then more than one such pairs would appear close to the Main-heap root. As in the sorted recursive algorithm, we will ignore this special treatment, since it does not significantly affect the behavior of the branch-and-bound algorithm with respect to the I/O activity and it consumes computational time.</p><p>In the example of Fig. <ref type="figure">4</ref>, suppose that we consider the same situation (internal nodes). The set of pairs of MBRs produced by the application of plane-sweep technique is ENTRIES ¼ fðM P 1 ; M Q1 Þg. We calculate MINMINDISTðM P 1 ; M Q1 Þ, which is smaller than z. Thus, we insert in Main-heap only the entry &lt;MINMINDISTðM P 1 ; M Q1 Þ, entryOfM P1 .address, entryOfM Q1 . address&gt;.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.">Treatment of different heights</head><p>When the two R-trees storing have different heights, the algorithms are slightly more complicated. In the recursive branch-and-bound algorithm, there are two approaches for treating different heights:</p><p>• The first approach is called ''fix-at-root''. The idea is, when the algorithm is called with a pair of internal nodes at different levels, stop propagating downwards in the R-tree of the smaller level node, while propagation in the other R-tree continues until both nodes are located at the same level. Then, propagation continues in both subtrees as usual. • The second approach is called ''fix-at-leaves'' and works in the opposite way. Recursion propagates downwards as usual. When the algorithm is called with a leaf on the one hand and an internal node on the other hand, downwards propagation stops in the R-tree of the leaf, while propagation in the other R-tree continues as usual.</p><p>The iterative algorithm can also be modified to deal with different heights by the ''fix-at-leaves'', or the ''fix-at-root'' strategy. The only difference is that the recursive call is replaced by an insertion in the Main-heap. The necessary modifications for applying these techniques of treating R-trees with different heights in recursive and iterative algorithms are presented in <ref type="bibr" target="#b7">[8]</ref>, along with experimental results on the performance behavior of each approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6.">Extending the K-CPQ algorithms</head><p>Numerous operations can be extended from the branch-and-bound algorithms for K-CPQ. The K-Self-CPQ, Semi-CPQ, the K-FPQ, and obtaining K or all closest pairs of objects with the distances within a range [Dist_Min, Dist_Max] (0 6 Dist Min 6 Dist Max) are the more representative ones. Next, we will present these operations and the modifications in our branch-andbound algorithms in order to carry them out.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6.1.">K-Self-CPQ</head><p>A special case of K-CPQ is the called ''K-Self-CPQ'' where both datasets actually refer to the same entity. That is, the input dataset is joined with itself. Taking into account the K-CPQ definition, the result set of the K-Self-CPQ is given by the following expression: K-Self-CPQðP; KÞ ¼ fK-CPQðP ; Q; KÞ : Q P g</p><p>As an example from operational research, we may need to find the K pairs of facilities (hospitals, schools, etc.) that are closer than others in order to make a reallocation. In the terminology of Section 3, P and Q are identical datasets, and hence their entries are indexed in a single R-tree. The algorithms proposed in this paper are able to support this special case with only two slight modifications that correspond to necessary conditions on candidate results ðp i ; p j Þ:</p><p>• ðp i ; p j Þ can be included in the result set if, and only if i 6 ¼ j and • ðp i ; p j Þ can be included in the result set if, and only if ðp j ; p i Þ is not already in the K-heap.</p><p>To improve the performance of the branch-and-bound algorithm for this query with respect to the candidate pairs in the result, we have included a hash table associated to the K-heap for testing whether the same or the symmetric of a given pair is already stored in K-heap or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6.2.">Semi-CPQ</head><p>Another special case of closest pairs query is called ''Semi-CPQ'' (''distance semi-join'' in <ref type="bibr" target="#b20">[21]</ref>). In Semi-CPQ for each object of the first dataset, the closest object of the second dataset is computed. The result set of Semi-CPQ is a sequence of pairs of objects given by the following definition:</p><p>Definition. Let two point sets, P ¼ fp 1 ; p 2 ; . . . ; p NP g and Q ¼ fq 1 ; q 2 ; . . . ; q NQ g in E ðdÞ . Then, the result of the semi-closest pairs query, Semi-CPQ(P ; Q), is a set of ordered sequences of jP j different pairs of points of P Â Q, where each object in P forms a pair with its closest object (or one of its closest objects, if there is not only one such object) in Q: Semi-CPQðP; QÞ ¼ fððp 1 ; q 1 Þ; ðp 2 ; q 2 Þ; . . . ; ðp jP j ; q jP j ÞÞ; p 1 ; p 2 ; . . . ; p jP j 2 P ; q 1 ; q 2 ; . . . ; q jP j 2 Q : p i 6 ¼ p j ; i 6 ¼ j; 1 6 i; j 6 jP j and distðp jP j ; q jP j Þ P distðp jP jÀ1 ; q jP jÀ1 Þ P Á Á Á P distðp 1 ; q 1 Þ and 8ðp i ; q j Þ 2 P Â Q À fðp 1 ; q 1 Þ; ðp 2 ; q 2 Þ; . . . ; ðp jP j ; q jP j Þg; distðp i ; q j Þ P distðp i ; q i Þ; 1 6 i 6 jP jg Note that, due to ties of distances, the result of the Semi-CPQ may not be a unique ordered sequence for a specific pair of point sets P and Q. Our aim is to find one of the possible instances, although it would be straightforward to obtain all of them. The Semi-CPQ works by reporting a sequence of pairs of objects ðp i ; q i Þ in order of distance. Note that once we have determined the closest object q i to a particular p i , that p i does not participate in other pairs. Unlike most join operations, the Semi-CPQ is not commutative, i.e. Semi-CPQðP ; QÞ 6 ¼ Semi-CPQðQ; P Þ.</p><p>To implement this operation, we have transformed the recursive and iterative branch-andbound algorithms for answering Semi-CPQ. These versions are similar to those proposed in <ref type="bibr" target="#b20">[21]</ref>. In the first version, called ''GlobalObjects'', we maintain a global list of objects belonging to leaves of the first R-tree. Each object is accompanied by the minimum distance to all the objects of the second R-tree visited so far. In the second version, called ''GlobalAll'', we maintain an analogous global list of objects. Moreover, we keep another global list of MBRs of the first Rtree, where each MBR is accompanied by the minimum MINMAXDIST value to all the MBRs of the second R-tree visited so far.</p><p>The Self-Semi-CPQ is an operation derived from Self-CPQ and Semi-CPQ, which, for one dataset, finds for each object its nearest neighbor. This operation is a Semi-CPQ where the input dataset is combined with itself: Self-Semi-CPQðPÞ ¼ fSemi-CPQðP ; QÞ : Q P g.</p><p>The implementation of this operation is just a combination of the transformations of the Semi-CPQ with the constraint of Self-CPQ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6.3.">K-farthest pairs query</head><p>In the same sense that we have defined the K-CPQ, it can be easily extended to find the K farthest pairs of objects from two datasets. The result set of the K-FPQ is given by the following definition.</p><p>Definition. Let two subsets of E ðdÞ , P ¼ fp 1 ; p 2 ; . . . ; p NP g and Q ¼ fq 1 ; q 2 ; . . . ; q NQ g. The result of the K-farthest pairs query K-FPQðP ; Q; KÞ is a set of ordered sequences of K (1 6 K 6 jP j Á jQj) different pairs of objects of P Â Q, with the K largest distances between all possible pairs of objects that can be formed by choosing one object of P and one object of Q: K-FPQðP; Q; KÞ ¼ fððp 1 ; q 1 Þ; ðp 2 ; q 2 Þ; . . . ; ðp K ; q K ÞÞ; p 1 ; p 2 ; . . . ; p K 2 P ; q 1 ; q 2 ; . . . ; q K 2 Q : ðp i ; q i Þ 6 ¼ ðp j ; q j Þ; i 6 ¼ j; 1 6 i; j 6 K and 8ðp i ;</p><formula xml:id="formula_33">q j Þ 2 P Â Q À fðp 1 ; q 1 Þ; ðp 2 ; q 2 Þ; . . . ; ðp K ; q K Þg; distðp i ; q j Þ 6 distðp K ; q K Þ 6 distðp KÀ1 ; q KÀ1 Þ 6 Á Á Á 6 distðp 2 ; q 2 Þ 6 distðp 1 ; q 1 Þg</formula><p>In this case and in order to design a branch-and-bound recursive algorithm for solving K-FPQ by extending the K-CPQ algorithms, we take into consideration the following constraints:</p><p>(1) K-heap is organized as a minimum binary heap with MAXMAXDIST as a key. In this case, z is the distance value of the Kth farthest pair discovered so far and stored in K-heap ðz ¼ 0Þ. (2) If two internal nodes are accessed, MAXMAXDIST for each possible pair of MBRs is calculated and these pairs are sorted in decreasing order of MAXMAXDIST. Following this order, we propagate downwards recursively only for those pairs of entries that have MAXMAXDIST P z. (3) If two leaves are accessed, then the distance of each possible pair of objects is calculated. If this distance is larger than or equal to z, then the pair located in the K-heap root is removed and the new pair is inserted in K-heap, updating z.</p><p>Along the same lines, we extend the iterative branch-and-bound algorithm for K-CPQ to obtain one for K-FPQ. In this case, we only consider the following conditions:</p><p>(1) Main-heap is organized as a maximum binary heap and K-heap is organized as a minimum binary heap, with MAXMAXDIST as a key in both cases. Moreover, z is the distance of the Kth farthest pair discovered so far and stored in K-heap (z ¼ 0). ( <ref type="formula" target="#formula_3">2</ref>) If two internal nodes are accessed, MAXMAXDIST for each possible pair of MBRs is calculated and the pairs of addresses of R-tree nodes (together with MAXMAXDIST), the MBRs of which have a MAXMAXDIST value larger than or equal to z, are inserted into Main-heap. (3) If two leaves are accessed, then the distance of each possible pair of objects is calculated. If this distance is larger than or equal to z, then the pair located in the K-heap root is removed and the new pair is inserted in K-heap, updating z.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6.4.">Obtaining K-or all-closest pairs of objects with their distances within a range</head><p>The proposed algorithms can be also extended for obtaining the K closest pairs of objects with distances within a range, [Dist_Min, Dist_Max] (0 6 Dist Min 6 Dist Max). This user-defined range determines the minimum and maximum desired distance for the query result. The necessary modifications of the branch-and-bound algorithms are the following: On the other hand, one may wish to obtain all possible pairs of objects with the distances within the interval <ref type="bibr">[Dist_Min, Dist_Max]</ref>. In this case, neither K nor the K-heap size are known a priori and Dist_Max is the bound distance for the pruning heuristic. Apparently, when Dist Max ¼ 1, our branch-and-bound algorithms degenerate in backtracking ones (obtaining all possible feasible solutions of a given problem), as when K P jP j Á jQj, jP j and jQj being the numbers of the objects stored in the R-trees R P and R Q , respectively. The modifications in the algorithms for this variant are the same to the previous ones, with only one difference: the management of the K-heap. In the worst case, the K-heap can grow as large as the product of all objects belonging to the two R-trees. That is, the size of K-heap can reach jP j Á jQj elements. Thus, it is not always feasible to store the K-heap in main memory, and we must use a hybrid memory/disk scheme and techniques based on range partitioning, as in <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b32">33]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experimental results</head><p>This section provides the results of an extensive experimentation study aiming at measuring and evaluating the efficiency of the three K-CPQ algorithms proposed in Section 4, namely SDR, PSR and PSI algorithms. In our experiments we used the R Ã -tree <ref type="bibr" target="#b1">[2]</ref> as the underlying disk-resident access method. In order to evaluate our branch-and-bound algorithms for K-CPQ we have taken into account several performance metrics. The effect of buffering and results over disjoint datasets are also studied, since these two parameters have an important influence on this kind of distancebased query. Moreover, we have adapted our K-CPQ algorithms to execute its more representative extensions: K-Self-CPQ, Semi-CPQ and K-FPQ. Finally, in this experimental section we have included studies on the scalability of the algorithms with varying the dataset sizes and K.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Experimental settings</head><p>All experiments were run on an Intel/Linux workstation with 128 Mbytes RAM and several Gbytes of secondary storage. The programs were created using the GNU C++ compiler with maximum optimization (-O3). The page size was set to 4 Kbytes, resulting to an R Ã -tree node capacity M ¼ 204; minimum capacity was set to m ¼ bM Ã 0:4c ¼ 81 since this m value yields the best performance according to <ref type="bibr" target="#b1">[2]</ref>. Moreover, the binary heaps (Main-heap and MxMxDHeap optionally) for the iterative algorithm were stored completely in main memory as well as the Kheap for the result.</p><p>In order to evaluate K-CPQ algorithms, we have used real datasets from <ref type="bibr" target="#b11">[12]</ref>, performing new experiments and using different datasets with respect to <ref type="bibr" target="#b7">[8]</ref>. The particular datasets represented populated places (points), rail-roads (line segments), roads (line segments) and cultural landmarks (points) from the United States of America, Canada and Mexico with different cardinalities as shown in Table <ref type="table" target="#tab_2">1</ref>. Just as an indication, four of them are illustrated in Fig. <ref type="figure" target="#fig_7">9</ref>.</p><p>We have measured the performance of our K-CPQ algorithms based on the following five performance metrics to compare the algorithms in different aspects such as CPU cost and I/O activity.  It is another important performance metric related to the query cost. It represents the number of pairs of MBRs created by decomposition before the algorithm termination and provides the number of partial subproblems considered during the algorithm execution. Thus, by minimizing this parameter we obtain the algorithm with the lowest computational cost. (5) Number of insertions in the Main-heap for the iterative algorithm (PSI). The task of managing the main binary heap (Main-heap) is largely CPU intensive as its size increases. Thus, the total number of insertions to the main binary required by the K-CPQ iterative algorithm provides a reasonable indication of its activity, since insertions are much more frequent than deletions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Performance comparison of K-closest pairs query algorithms</head><p>We proceed with the evaluation of the three algorithms for K-CPQ (SDR, PSR and PSI) as a function of K that varies from 1 to 100,000, assuming zero buffer and obviously for the same workspaces. Fig. <ref type="figure" target="#fig_8">10a</ref> illustrates the number of disk accesses for K-CPQ over the (USrr, USrd) configuration, where USrr and USrd are the rail-roads and roads of USA, respectively. On the other hand, Fig. <ref type="figure" target="#fig_8">10b</ref> shows the same metric for the (NArr, NApp) configuration, where NArr and NApp are the rail-roads and populated places of North America, respectively. For this last configuration and in the sequel, when the R Ã -trees have different heights we will use the fixat-leaves technique.</p><p>Fig. <ref type="figure" target="#fig_8">10</ref> shows that the number of R Ã -tree nodes fetched from disk (I/O activity) of each algorithm gets higher as K increases, and PSI is better than the recursive alternatives in both configurations with similar I/O trends. Moreover, the deterioration is not smooth; after a threshold the cost increases slightly for large K values (this threshold was usually around K ¼ 1000). This demonstrates that the iterative algorithm was more effective than the recursive ones in the pruning process in the absence of buffers, since it follows a Best-First searching strategy optimized with the plane-sweep technique.</p><p>For the (USrr, USrd) configuration, Table <ref type="table">2</ref> compares the remaining performance parameters, i.e. total response time (bold), number of distance computations (italic), number of subproblems (regular) and the amount of Main-heap insertions (in parentheses) needed by each algorithm. For all K values, the plane-sweep technique needed a significantly reduced number of distance computations; this implies that the required response time was also considerably smaller than SDR (it does not use this optimization technique). This demonstrates that the plane-sweep method was very effective for this kind of distance-based query, since the number of possible pairs from the combination of two R Ã -tree nodes is also reduced considerably, as well as the number of insertion in the Main-heap. For instance, for small K values (K 6 1000) PSR was slightly faster, and for large K values (K P 10; 000) the best was PSI. The explanation of this behavior is due to the fact that the recursive alternative traverses the R Ã -trees using a Depth-First searching strategy and it can deviate to the branches where no optimal solutions are located. Moreover, PSI is the algorithm with the minimum number of subproblems, since it follows a Best-First traversal. On the other hand, SDR was the worst alternative, because it combines all possible entries from two R Ãtree nodes (depending on the fan-out (m; M) of the R Ã -trees, we have a list from 6561 to 41,616 number of pairs), calculates its minimum distances, sorts them when they are internal; all these tasks consume significant CPU time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Results on disjoint datasets</head><p>In <ref type="bibr" target="#b7">[8]</ref> the effect of overlap between the datasets for K-CPQ was studied. In the absence of buffers, the conclusion was that: the greater percentage of overlapping, the better performance of the iterative algorithm with respect to the recursive ones. In order to verify this behavior, we performed experiments with datasets corresponding to disjoint workspaces. Fig. <ref type="figure" target="#fig_9">11a</ref> illustrates the number of disk accesses for K-CPQ over the (MXrd, USrr) configuration, where MXrd are the roads of Mexico. On the other hand, Fig. <ref type="figure" target="#fig_9">11b</ref> shows the same metric for the (CDrr, USpp) configuration, where CDrr are the rail-roads of Canada. Fig. <ref type="figure" target="#fig_9">11</ref> shows, like Fig. <ref type="figure" target="#fig_8">10</ref>, that the PSI performance is comparable to PSR (K must be really large to observe a slight outperformance of PSI with respect to PSR) without buffers for disjoint Table <ref type="table">2</ref> Comparison of the K-CPQ algorithms without buffering and varying K for the (USrr, Usrd)  or overlapped workspaces, although the cost is notably smaller for disjoint datasets. Evidently, the algorithms are cheaper for disjoint workspaces than for overlapping ones, since the MIN-MINDIST values are large enough for disjoint datasets and the pruning is much more effective.</p><formula xml:id="formula_34">K ¼ 1 K ¼ 10 K ¼ 100 K ¼ 1000 K ¼ 10;</formula><p>For the (MXrd, USrr) configuration, Table <ref type="table" target="#tab_4">3</ref> compares the other performance metrics. For all K values and for all performance metrics, PSI outperforms SDR and PSR, proving that the iterative algorithms work better than the recursive ones in absence of buffers. For instance, if we consider the total response time consumed by the algorithms as the metric under consideration, PSI is on the average 90% and 80% faster than SDR and PSR, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">The effect of buffering</head><p>DBMS performance is sensitive to the size of buffers in main memory. There exist two basic research directions that aim at reducing the disk activity and enhancing the system throughput during query processing using buffers. The first one focuses on the availability of buffer pages at runtime by adapting memory management techniques for buffer managers used in operating systems to database systems <ref type="bibr" target="#b12">[13]</ref>. The second one focuses on query access patterns, where the query optimizer dictates the query execution plan to the buffer manager, so that the latter can allocate and manage its buffers accordingly <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9]</ref>.</p><p>To speed up query processing, DBMSs use indices that may partially reside in main memory buffers. The buffering effect should be studied, since even a small number of buffer pages can drastically improve the overall performance. In DBMSs, the buffer manager is responsible for operations in the buffer pool, including buffer space assignment to queries, replacement decisions and buffer reads and writes in the event of page faults. When buffer space is available, the manager decides about the number of pages that are allocated to an activated query. This decision may depend on the availability of pages at runtime (page replacement algorithms), or the access pattern of queries (nature of the query). Following the former criterion, in <ref type="bibr" target="#b10">[11]</ref> several buffer pool structures, page replacement policies and buffering schemes for K-CPQ algorithms were analyzed, aiming at reducing the number of disk accesses. For the experiments of this section, we will adopt the best configuration for this kind of distance-based query that was proposed in <ref type="bibr" target="#b10">[11]</ref>: LRU with a single buffer pool structure, using a global buffering scheme. For the experiments of this subsection, we are going to consider the workspace configuration (USrr, USrd) with different buffer sizes, B, varying from 0 to 1024 pages. This means that we have in memory a variable percentage of R Ã -tree nodes, depending on the number of buffer pages. Besides, the buffer does not use any global optimization criterion, i.e. the buffer pages are handled as the algorithms are required, depending on which R Ã -tree are located.</p><p>Fig. <ref type="figure" target="#fig_10">12a</ref> shows that PSI presents an average excess of I/O activity around 14% and 18% for K ¼ 1000 with respect to SDR and PSR, respectively, as can be noticed by the gap between the lines. Moreover, the influence of buffer is slightly greater for PSR than for SDR, due to the use of the plane-sweep technique. This behavior is due to the fact that recursion favors the most recently used pages (LRU) in the backtracking phase and this effect is preserved in case of large buffers. On the other hand, Fig. <ref type="figure" target="#fig_10">12b</ref> illustrates that the gap for K-CPQ algorithms remains when the K value is incremented and B ¼ 512 pages. For instance, the average I/O saving between PSR and SDR with increasing K (1. . .100,000) is 3%, and PSR with respect to PSI is 16%. Again, this effect is due to the combination of recursion and LRU page replacement policy.</p><p>Fig. <ref type="figure" target="#fig_11">13</ref> illustrates the performance of the best K-CPQ recursive (PSR) and the iterative (PSI) algorithms as a function of buffer size (B P 0). For PSR, when B P 64, the savings in terms of the number of disk accesses are large and almost the same for all K values. However, the savings are considerably less when B 6 32, whereas for K ¼ 100; 000 and B ¼ 0 we can notice a characteristic peak. For PSI, the savings trend is similar to the PSR, but for high K values these savings become less than PSR. For instance, if we have available adequate buffer space, PSR is the best alternative for the number of disk accesses, since it provides an average I/O savings of 18% with respect to the PSI for K-CPQ using our buffering configuration.</p><p>From the results shown in Fig. <ref type="figure" target="#fig_11">13</ref>, we have obtained the percentage of I/O savings (induced by the use of buffer size B &gt; 0 in contrast to using no buffer) of PSR and PSI. For PSR, the percentage of saving grows as the buffer size increases, for all K values. The trend of the behavior of PSI is almost the same to PSR, although the increase is 8% less in average with respect to the recursive algorithm.</p><p>From the results and conclusions of this subsection, we can notice that the influence of our buffer scheme according to <ref type="bibr" target="#b10">[11]</ref> is more important for the recursive K-CPQ algorithms (mainly for PSR) than for the iterative one (PSI), primarily due to the fact that the use of recursion in a Depth-First traversal and the plane-sweep technique is affected by our buffering scheme more than the case of a Best-First searching strategy implemented through a minimum binary heap.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">K-Self-CPQ, Semi-CPQ and K-FPQ</head><p>The three more important extensions of our K-CPQ algorithms are the so-called K-Self-CPQ, Semi-CPQ and K-FPQ. First of all, we proceed with the evaluation of the three K-CPQ algorithms adapted to the K-Self-CPQ constrains. For the (NApp, NApp) configuration, Table <ref type="table">4</ref> compares all our performance metrics (disk accesses are in brackets) for each adapted algorithm for K-Self-CPQ and B ¼ 256 pages. For the number of disk accesses, these increasing trends are Table <ref type="table">4</ref> Comparison of the K-Self-CPQ algorithms for the (Napp, NApp) configuration, with varying K and B ¼ 256 pages due to the fact that we must discard two kinds of candidate pairs (equal to and symmetric). The behavior of PSR, where for all K values we obtain the same number of disk accesses, is interesting. Respect to the total response time, for small K values (K 6 100) PSR was the best alternative, but PSI is the fastest for large K values (K P 1000). Moreover, PSI was the algorithm with the minimum number of subproblems for all K values, and SDR was the worst algorithm for all metrics showed in this table. These results confirm our conjecture that the plane-sweep technique adapted to this kind of distance-based query reduces the number of distance computations, and this results in the reduction in response time. Besides, the Best-First traversal minimizes the number of subproblems and this effect can be shown for large K values. Next, we report the results of our tests on the extension of the non-incremental algorithms for Semi-CPQ. We have implemented the recursive version of ''GlobalObjects'' (GOR), ''GlobalAll'' for recursive (GAR and GASR &lt;sorting the pairs based on MINMINDIST&gt;) and iterative (GAI) schema. We have not applied the plane-sweep technique, since in this case the z value is not global to the query result and each object of the first dataset must maintain its own lower bound. This query can also be implemented using a nearest neighbor algorithm. For each object in the first R Ãtree, we perform a nearest neighbor query in the second R Ã -tree, and sort the result once all neighbors have been calculated. We have called this procedure T+NNQ, since it consists of three steps: (1) traverse recursively the first R Ã -tree, accessing the object in order of appearance within each leaf; (2) for each object, perform a nearest neighbor query into the second R Ã -tree and (3) sort the results (array of object with its distances) in ascending order of distances.</p><formula xml:id="formula_35">K ¼ 1 K ¼ 10 K ¼ 100 K ¼ 1000 K ¼ 10;</formula><p>From these experiments, we have considered the (NApp, NArd) configuration without buffer. Obviously, we have reported 24,493 pairs in the result (cardinality of NApp). Table <ref type="table" target="#tab_7">5</ref> compares the four performance metrics for this query. Our extensions obtain the best behavior with respect to the number of disk accesses, mainly ''GlobalAll'' iterative (GAI). However, for the other metrics, T+NNQ is better than our extensions, since it needs less distance computations. Also, we must highlight that T+NNQ needs a main memory array of objects with their distances for all objects indexed in the first R Ã -tree, whereas our ''GlobalObjects'' extension needs the same amount of main memory and ''GlobalAll'' needs memory for objects and MBRs from internal nodes. From these results, we can conclude that our extensions are adequate for Semi-CPQ with respect to the number of disk accesses without buffers, but they consume significant space and time resources to report the result.</p><p>Another extension of K-CPQ is to find the K farthest pairs of objects from two datasets (K-FPQ). For this purpose, we have implemented recursive and iterative extensions of our algorithms (without using the plane-sweep technique) for K-CPQ. The algorithms have been called: nonsorted distances recursive (NSDR), SDR and non-sorted distances iterative (NSDI).  shows all our performance metrics (disk accesses are in brackets) for K-FPQ using the (USrr, USrd) configuration with a global LRU buffer of 256 pages. From these measurements, we can observe the reduced number of disk accesses needed for this query, even for large K values. The explanation is that MAXMAXDIST is the function for pruning in the extended branch-andbound algorithms instead of MINMINDIST, and MAXMAXDIST is very effective in this case.</p><p>In addition, SDR and NSDI have the best behavior, and they are notably better that NSDR. For the other performance measurements, SDR and NSDI are considerably better than NSDR. In particular, NSDI consumes slightly less time to report the result, although the number of distance computations is greater. This behavior is due to the sorting of MAXMAXDIST of all possible pairs of MBRs from two internal nodes that SDR needs to execute the query. Moreover, we have executed the algorithms for the (NArd, NApp) configuration (lines, points) over R Ã -trees with different heights and we have obtained similar results and conclusions with respect to the (USrr, USrd) configuration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6.">Scalability of the algorithms, varying the dataset sizes and K</head><p>As already pointed out, we are going to study the scalability of the K-CPQ algorithms with respect to the dataset sizes and K. First of all, we will study the effect of varying the dataset sizes, fixing the K value, for the datasets with rail-roads (line segment) and roads (line segment) from California (CA), West USA (WU), United States of America (US), USA + Mexico (UX) and North America (NA) as shown in Table <ref type="table" target="#tab_9">7</ref>.</p><p>Fig. <ref type="figure" target="#fig_12">14</ref> shows that the performance (i.e. number of disk accesses) increases almost linearly with the increase of the cardinalities of the real datasets, even for large K values. The trends for two diagrams are very similar, since the savings in disk accesses using a global LRU buffer is very high. Moreover, in the presence of buffer, again, the PSR is the best alternative and PSI provides the largest number of disk accesses. For the previous five configurations, Table <ref type="table" target="#tab_10">8</ref> compares the other performance metrics for K ¼ 100; 000 and B ¼ 256. Clearly, PSI is the best algorithm for total response time, distance computations and subproblems. Also, we have executed experiments for the other K values, and the results were analogous to the ones of Section 5.2 in all configurations: PSR won when K 6 1000 and PSI when K P 10; 000. Besides, the increase of the performance was almost linear   with the increase of the cardinalities of the real datasets for a given K, following the same trend to the disk accesses. Another way to measure the scalability of our K-CPQ algorithms is to take into account their behavior with increasing K values using large real datasets. Fig. <ref type="figure" target="#fig_13">15a</ref> shows that the number of disk accesses increases in a sublinear way with the increase of the cardinalities of the result for the recursive alternative, using the (NArr, NArd) configuration and B ¼ 256 pages. Namely, with increasing K values (1. . .1,000,000), the performance of PSR is not significantly affected; there is only a 6% extra cost, whereas for PSI this extra cost is about 16%. Moreover, SDR for K ¼ 1; 000; 000 is slightly better than PSR, only 2%. Fig. <ref type="figure" target="#fig_13">15b</ref> illustrates the response time for the fastest K-CPQ algorithms (PSR and PSI) for the increase of cardinality of the result. For instance, they have very similar results for K 6 10; 000, but for K ¼ 100; 000 and 10,000,000 PSI is 20% and 48% faster than PSR, respectively. Table <ref type="table" target="#tab_11">9</ref> presents the other performance metrics for the (NArr, NArd) configuration and B ¼ 256, varying K from 1 to 1,000,000. From these results we can conclude that PSR was the best when K 6 1000 and PSI when K P 10; 000, with respect to the time response and the number of distance computations. Besides, PSI is the algorithm with the smallest number of subproblems for all K values, whereas it needs only a 48% extra of insertions in the Main-heap to carry out the query from K ¼ 1 to 1,000,000. On the other hand, SDR is the worst, since it does not use the plane-sweep technique for reducing the number of distance computations and avoiding intermediate sorting processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and open problems</head><p>Efficient processing of K-CPQs is of great importance in spatial databases due to the wide area of applications that may address such queries. Although popular in computational geometry literature <ref type="bibr" target="#b30">[31]</ref>, the closest pair problem has not gained special attention is spatial database research. Certain other problems of computational geometry, including the ''all nearest neighbor'' problem (that is related to the closest pair problem), have been solved for external memory systems <ref type="bibr" target="#b16">[17]</ref>. To the best of the authorsÕ knowledge, <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b32">33]</ref> are the only references to this type of queries. In this  paper, based on the properties of distance functions between two MBRs in the multidimensional Euclidean space, we propose a pruning heuristic and two updating strategies for minimizing the pruning distance to apply them in the design of three non-incremental branch-and-bound algorithms for K-CPQ between objects indexed in two R-trees, extending and enhancing the work presented in <ref type="bibr" target="#b7">[8]</ref>. Two of the algorithms are recursive, following a Depth-First searching strategy and one is iterative, obeying a Best-First traversal policy. The plane-sweep method and the search ordering (this heuristic is based on the ordering of MINMINDIST) are used as optimization techniques for improving the naive approaches. Furthermore, some interesting extensions of the K-CPQ are presented: K-Self-CPQ, Semi-CPQ, Self-Semi-CPQ, K-FPQ and a method to obtain the K or all closest pairs of objects with the distances within a range [Dist_Min, Dist_Max].</p><p>In the experimental section, we have used an R-tree variant (R Ã -tree) in which the objects are stored directly in the tree leaves. Moreover, an extensive experimentation was also included, which resulted to several conclusions about the efficiency of each algorithm (disk accesses, response time, distance computations and subproblems) with respect to K, the size of the underlying buffer, the disjointedness of the workspaces and the algorithmic scalability. The more important conclusions for the K-CPQ algorithms over overlapped or disjoint workspaces are listed as follows:</p><p>• The SDR algorithm has a good performance with respect to the number of disk accesses when we include a global LRU buffer for all configurations. But, it consumes much time for reporting the results, since it must combine all possible entries from two internal R-tree nodes in a temporary list of pairs of MBRs, compute its MINMINDIST for each pair, and sort this list of pairs in ascending order of MINMINDIST. • The PSR algorithm is the best alternative with regards to the I/O activity when buffer space is available, since the combination of recursion in a Depth-First traversal and LRU page replacement policy favors this performance metric. Moreover, this algorithm is the fastest for small and medium K values, since it reduces the distance computations using the plane-sweep technique.</p><p>• The PSI algorithm is the best alternative for the number of disk accesses without buffer, but when we have a global LRU buffer this behavior is inverted, since the Best-First traversal implemented through a minimum binary heap is less affected in contrast to the combination of recursion in a Depth-First searching strategy with an LRU replacement policy. Moreover, this algorithm is the fastest for large K values, since it obtains the minimum number of distance computations and subproblems (Best-First traversal and plane-sweep technique) in this case. Also, it is interesting to observe the small number of insertions in the Main-heap even for very large K values, because our pruning heuristic based on MINMINDIST is very effective in nonincremental branch-and-bound algorithms for K-CPQ. • K does not radically affect the relative performance with respect to the number of disk accesses, since the increase of this function grows sublinearly with the increase of K. • The number of disk accesses grows almost linearly with the increase of the dataset cardinalities; this trend is noticed for the other performance metrics, too. • In general, the PSI and PSR response times are significantly lower than SDRÕ one (one order of magnitude for large datasets), while disk accesses keep comparable. Therefore, PSI is preferable when enough main memory resources are available to store the Main-heap (PSI outperforms the two other recursive algorithms, except for disk accesses), otherwise PSR is the best alternative.</p><p>We have also implemented and presented experimental results for three special cases of closest pairs queries: K-Self-CPQ, where both datasets actually refer to the same entity, Semi-CPQ, where for each element of the first dataset, the closest object of the second dataset is computed, and K-FPQ, where the K farthest pairs of objects from to datasets are found. Again, the iterative variants have the best overall performance, although the recursive ones are I/O competitive in the presence of buffers.</p><p>Future work on CPQs may include: <ref type="bibr" target="#b0">(1)</ref> The study of multiway K-CPQs where tuples of objects are expected to be the answers, extending related work on multiway spatial joins <ref type="bibr" target="#b29">[30]</ref>. <ref type="bibr" target="#b1">(2)</ref> The analytical study of K-CPQs, extending related work on spatial joins <ref type="bibr" target="#b34">[35]</ref> and nearest neighbor queries <ref type="bibr" target="#b28">[29]</ref>. <ref type="bibr" target="#b2">(3)</ref> The extension of our K-CPQ algorithms using multidimensional data for exact result or approximate K-closest pairs query (the degree of inexactness can be specified by an upper bound e and indicates the reported answer and the exact closest pair distance) in a sense similar to the approximate nearest neighbor searching <ref type="bibr" target="#b0">[1]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig.1. An example of an R-tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Two MBRs and their MINMINDIST, MINMAXDIST and MAXMAXDIST in E ð2Þ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The PSR algorithm.</figDesc><graphic coords="18,84.29,95.57,382.68,155.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. The PSI algorithm.</figDesc><graphic coords="19,79.37,95.57,382.68,245.37" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>( 1 )</head><label>1</label><figDesc>If two internal nodes are accessed, do not update z (by updating strategies based on MIN-MAXDIST or MAXMAXDIST). Calculate MINMINDIST for each possible pair of MBRs and recursively propagate downwards only for those pairs of MBRs with MINMINDIST 6 Dist Max. (2) If two leaves are accessed, calculate the distance of each possible pair of objects. If this distance is in the range [Dist_Min, Dist_Max], insert the new pair in the K-heap and do not update z. If K-heap becomes full, remove the Kth closest pair (in the K-heap root) and insert the new one, updating the K-heap structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>( 1 )</head><label>1</label><figDesc>Number of disk accesses. It is the most representative parameter to measure the I/O activity, using or not additional buffers. The number of R Ã -tree nodes fetched from disk is reported as the number of disk accesses, and it may not exactly correspond to actual disk I/O, since R Ãtree nodes can be found in the system buffers. (2) Response time. Total query response times were measured for overall performance of the K-CPQ algorithms. The execution time is reported in seconds and represents the overall CPU time consumed, as well as the total I/O performed by the algorithms for this kind of distance join operation. (3) Number of distance computations. The cost of computing distances between pairs of MBRs (MINMINDIST) and objects (line-line, line-point and point-point) constitutes a significant portion of the computational cost for this kind query. Thus, the total number of distance computations required by a K-CPQ algorithm provides a direct indication of its computational performance. (4) Number of subproblems created by decomposition (simply referred to as number of subproblems).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Four real-world datasets from [12]: (a) roads of USA, (b) rail-roads of North America, (c) cultural landmarks of USA and (d) populated places of North America.</figDesc><graphic coords="24,109.80,95.57,330.84,206.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Comparison of the K-CPQ algorithms in terms of the number disk accesses without buffering and varying K for (a) (Usrr, USrd) and (b) (NArr, NApp) configurations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Comparison of the K-CPQ algorithms in terms of the number of disk accesses without buffering and varying K for disjoint workspaces (a) (MXrd, USrr) and (b) (CDrr, USpp) configurations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Comparison of the K-CPQ algorithms in terms of the number of disk accesses using the (USrr, USrd) configuration: (a) varying the buffer size and K ¼ 1000, (b) varying K and B ¼ 512 pages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. The number of disk accesses for (a) PSR and (b) PSI, as a function of the LRU buffer size (B) and the cardinality of the result (K).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Comparison of the K-CPQ algorithms in terms of the number of disk accesses for B ¼ 256 pages, using different configurations of the datasets in increasing size for (a) K ¼ 1000 and (b) K ¼ 100; 000.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Comparison of the K-CPQ algorithms in terms of the (a) number of disk accesses and (b) total response time, with varying K (1. . .1,000,000), B ¼ 256 pages and (NArr, NArd) configuration.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="16,84.29,487.76,382.68,155.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>R 1 ðs; tÞ and q i ¼ p i for R 2 ðp; qÞ, R 1 and R 2 degenerate into two points s ¼ ðs 1 ; s 2 ; . . . ; s d Þ and p ¼ ðp 1 ; p 2 ; . . . ; p d Þ; then:</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell cols="2">Cardinalities of the real datasets</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>Cultural landmarks</cell><cell>Populated places</cell><cell>Rail-roads</cell><cell>Roads</cell></row><row><cell>Canada</cell><cell>2099</cell><cell>4994</cell><cell>35,074</cell><cell>121,416</cell></row><row><cell>Mexico</cell><cell>1087</cell><cell>4293</cell><cell>10,060</cell><cell>92,392</cell></row><row><cell>USA</cell><cell>6017</cell><cell>15,206</cell><cell>146,503</cell><cell>355,312</cell></row><row><cell>North America</cell><cell>9203</cell><cell>24,493</cell><cell>191,637</cell><cell>569,120</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3</head><label>3</label><figDesc>Comparison of the K-CPQ algorithms without buffering and varying K for the (MXrd, Usrr)</figDesc><table><row><cell></cell><cell>K ¼ 1</cell><cell>K ¼ 10</cell><cell>K ¼ 100</cell><cell>K ¼ 1000</cell><cell>K ¼ 10; 000</cell><cell>K ¼ 100; 000</cell></row><row><cell>SDR</cell><cell>21.72</cell><cell>21.74</cell><cell>22.05</cell><cell>22.32</cell><cell>25.01</cell><cell>34.46</cell></row><row><cell></cell><cell>4,994,760</cell><cell>4,994,760</cell><cell>5,063,198</cell><cell>5,121,658</cell><cell>5,684,082</cell><cell>7,312,475</cell></row><row><cell></cell><cell>316</cell><cell>316</cell><cell>320</cell><cell>322</cell><cell>352</cell><cell>440</cell></row><row><cell>PSR</cell><cell>3.65</cell><cell>3.71</cell><cell>4.15</cell><cell>5.67</cell><cell>18.14</cell><cell>77.76</cell></row><row><cell></cell><cell>703,426</cell><cell>712,269</cell><cell>782,245</cell><cell>968,723</cell><cell>2,754,905</cell><cell>8,890,146</cell></row><row><cell></cell><cell>373</cell><cell>373</cell><cell>379</cell><cell>389</cell><cell>495</cell><cell>848</cell></row><row><cell>PSI</cell><cell>0.50</cell><cell>0.56</cell><cell>0.76</cell><cell>1.37</cell><cell>3.42</cell><cell>12.70</cell></row><row><cell></cell><cell>115,127</cell><cell>126,827</cell><cell>160,575</cell><cell>259,818</cell><cell>571,547</cell><cell>1,658,221</cell></row><row><cell></cell><cell>316</cell><cell>316</cell><cell>319</cell><cell>322</cell><cell>349</cell><cell>426</cell></row><row><cell></cell><cell>(71,116)</cell><cell>(71,116)</cell><cell>(71,116)</cell><cell>(71,116)</cell><cell>(71,123)</cell><cell>(71,139)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 6</head><label>6</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 5</head><label>5</label><figDesc>Comparison of the Semi-CPQ algorithms for the (NApp, NArd) configuration without buffering</figDesc><table><row><cell></cell><cell>T+NNQ</cell><cell>GOR</cell><cell>GAR</cell><cell>GASR</cell><cell>GAI</cell></row><row><cell>Disk accesses</cell><cell>94,209</cell><cell>69,894</cell><cell>45,296</cell><cell>38,962</cell><cell>38,868</cell></row><row><cell>Response time</cell><cell>29.52</cell><cell>1180.95</cell><cell>703.35</cell><cell>681.82</cell><cell>589.04</cell></row><row><cell>Distance comp.</cell><cell>17,007,578</cell><cell>674,087,280</cell><cell>437,822,358</cell><cell>376,471,488</cell><cell>363,864,610</cell></row><row><cell>Sub. decomp.</cell><cell></cell><cell>34,771</cell><cell>22,472</cell><cell>19,305</cell><cell>19,258</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 6</head><label>6</label><figDesc>Comparison of the K-FPQ algorithms, with varying K and B ¼ 256 pages for the (USrr, USrd) configuration</figDesc><table><row><cell></cell><cell>K ¼ 1</cell><cell>K ¼ 10</cell><cell>K ¼ 100</cell><cell>K ¼ 1000</cell><cell>K ¼ 10; 000</cell><cell>K ¼ 100; 000</cell></row><row><cell>NSDR</cell><cell>{124}</cell><cell>{127}</cell><cell>{143}</cell><cell>{196}</cell><cell>{290}</cell><cell>{520}</cell></row><row><cell></cell><cell>13.32</cell><cell>13.66</cell><cell>16.13</cell><cell>24.68</cell><cell>48.18</cell><cell>173.64</cell></row><row><cell></cell><cell>2,913,526</cell><cell>2,977,628</cell><cell>3,454,505</cell><cell>5,008,063</cell><cell>8,393,499</cell><cell>20,184,013</cell></row><row><cell></cell><cell>140</cell><cell>144</cell><cell>169</cell><cell>252</cell><cell>426</cell><cell>1016</cell></row><row><cell>SDR</cell><cell>{7}</cell><cell>{7}</cell><cell>{7}</cell><cell>{7}</cell><cell>{12}</cell><cell>{24}</cell></row><row><cell></cell><cell>0.14</cell><cell>0.15</cell><cell>0.15</cell><cell>0.17</cell><cell>0.57</cell><cell>1.85</cell></row><row><cell></cell><cell>43,030</cell><cell>43,030</cell><cell>43,030</cell><cell>43,030</cell><cell>124,228</cell><cell>343,390</cell></row><row><cell></cell><cell>3</cell><cell>3</cell><cell>3</cell><cell>3</cell><cell>8</cell><cell>2 0</cell></row><row><cell>NSDI</cell><cell>{7}</cell><cell>{7}</cell><cell>{7}</cell><cell>{7}</cell><cell>{12}</cell><cell>{24}</cell></row><row><cell></cell><cell>0.11</cell><cell>0.11</cell><cell>0.11</cell><cell>0.13</cell><cell>0.59</cell><cell>1.92</cell></row><row><cell></cell><cell>72,488</cell><cell>72,488</cell><cell>72,488</cell><cell>72,488</cell><cell>153,686</cell><cell>372,848</cell></row><row><cell></cell><cell>3</cell><cell>3</cell><cell>3</cell><cell>3</cell><cell>8</cell><cell>2 0</cell></row><row><cell></cell><cell>(29,458)</cell><cell>(29,458)</cell><cell>(29,458)</cell><cell>(29,458)</cell><cell>(29,458)</cell><cell>(29,458)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 7</head><label>7</label><figDesc>Cardinalities of the real datasets for studying the algorithm scalability</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Rail-roads</cell><cell></cell><cell>Roads</cell><cell></cell><cell></cell></row><row><cell cols="2">California</cell><cell></cell><cell></cell><cell>11,381</cell><cell></cell><cell></cell><cell>21,831</cell><cell></cell><cell></cell></row><row><cell cols="2">West USA</cell><cell></cell><cell></cell><cell>81,043</cell><cell></cell><cell></cell><cell>244,385</cell><cell></cell><cell></cell></row><row><cell cols="2">USA</cell><cell></cell><cell></cell><cell>146,503</cell><cell></cell><cell></cell><cell>355,312</cell><cell></cell><cell></cell></row><row><cell cols="2">USA + Mexico</cell><cell></cell><cell></cell><cell>156,563</cell><cell></cell><cell></cell><cell>447,704</cell><cell></cell><cell></cell></row><row><cell cols="2">North America</cell><cell></cell><cell></cell><cell>191,637</cell><cell></cell><cell></cell><cell>569,120</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>SDR</cell><cell>PSR</cell><cell>PSI</cell><cell></cell><cell></cell><cell>SDR</cell><cell>PSR</cell><cell>PSI</cell></row><row><cell></cell><cell>7000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>7000</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>5600</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>5600</cell><cell></cell><cell></cell><cell></cell></row><row><cell>disk accesses</cell><cell>2800 4200</cell><cell></cell><cell></cell><cell></cell><cell>disk accesses</cell><cell>2800 4200</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>1400</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1400</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>CArr/CArd</cell><cell>WUrr/WUrd</cell><cell>USrr/USrd</cell><cell>UXrr/UXrd</cell><cell>NArr/NArd</cell><cell>CArr/CAdr</cell><cell>WUrr/WUrd</cell><cell>USrr/USrd</cell><cell>UXrr/UXrd</cell><cell>NArr/NArd</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Datasets</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Datasets</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 8</head><label>8</label><figDesc>Comparison of the K-CPQ algorithms for K ¼ 100; 000 and B ¼ 256 pages, using different configurations of the real datasets in increasing size</figDesc><table><row><cell></cell><cell>CArr/Card</cell><cell>WUrr/Wurd</cell><cell>USrr/USrd</cell><cell>UXrr/UXrd</cell><cell>NArr/NArd</cell></row><row><cell>SDR</cell><cell>37.25</cell><cell>382.21</cell><cell>639.94</cell><cell>726.38</cell><cell>891.82</cell></row><row><cell></cell><cell>7,933,307</cell><cell>86,584,811</cell><cell>145,538,868</cell><cell>165,453,915</cell><cell>202,997,777</cell></row><row><cell></cell><cell>388</cell><cell>4132</cell><cell>6947</cell><cell>7963</cell><cell>9924</cell></row><row><cell>PSR</cell><cell>19.66</cell><cell>55.58</cell><cell>68.56</cell><cell>71.65</cell><cell>75.39</cell></row><row><cell></cell><cell>2,583,242</cell><cell>7,410,232</cell><cell>9,513,814</cell><cell>10,021,597</cell><cell>10,539,267</cell></row><row><cell></cell><cell>503</cell><cell>4289</cell><cell>7135</cell><cell>8083</cell><cell>10,149</cell></row><row><cell>PSI</cell><cell>13.67</cell><cell>37.47</cell><cell>48.58</cell><cell>50.56</cell><cell>59.97</cell></row><row><cell></cell><cell>1,838,280</cell><cell>5,455,709</cell><cell>7,454,867</cell><cell>7,787,764</cell><cell>9,045,976</cell></row><row><cell></cell><cell>388</cell><cell>3964</cell><cell>6770</cell><cell>7697</cell><cell>9699</cell></row><row><cell></cell><cell>(12,720)</cell><cell>(139,850)</cell><cell>(187,743)</cell><cell>(122,471)</cell><cell>(191,207)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 9</head><label>9</label><figDesc>Comparison of the K-CPQ algorithms with varying K (1. . .1,000,000), B ¼ 256 pages and (NArr, NArd) configuration</figDesc><table><row><cell></cell><cell>K ¼ 1</cell><cell>K ¼ 10</cell><cell>K ¼ 100</cell><cell>K ¼ 1000</cell><cell>K ¼ 10; 000</cell><cell>K ¼ 100; 000</cell><cell>K ¼ 1; 000; 000</cell></row><row><cell>SDR</cell><cell>855.24</cell><cell>855.58</cell><cell>855.75</cell><cell>856.41</cell><cell>858.26</cell><cell>892.39</cell><cell>1116.02</cell></row><row><cell></cell><cell>196,679,155</cell><cell>196,679,155</cell><cell>196,679,155</cell><cell>196,679,155</cell><cell>197,186,117</cell><cell>202,997,777</cell><cell>236,040,339</cell></row><row><cell></cell><cell>9601</cell><cell>9601</cell><cell>9601</cell><cell>9601</cell><cell>9626</cell><cell>9924</cell><cell>11,612</cell></row><row><cell>PSR</cell><cell>26.88</cell><cell>26.89</cell><cell>26.97</cell><cell>27.41</cell><cell>31.46</cell><cell>75.31</cell><cell>421.45</cell></row><row><cell></cell><cell>4,305,737</cell><cell>4,307,645</cell><cell>4,318,106</cell><cell>4,386,909</cell><cell>4,979,372</cell><cell>10,539,267</cell><cell>44,331,311</cell></row><row><cell></cell><cell>9607</cell><cell>9608</cell><cell>9610</cell><cell>9618</cell><cell>9668</cell><cell>10,149</cell><cell>12,700</cell></row><row><cell>PSI</cell><cell>27.32</cell><cell>27.34</cell><cell>27.39</cell><cell>27.68</cell><cell>30.77</cell><cell>60.05</cell><cell>225.13</cell></row><row><cell></cell><cell>4,439,791</cell><cell>4,441,921</cell><cell>4,452,615</cell><cell>4,501,059</cell><cell>4,956,503</cell><cell>9,045,976</cell><cell>28,188,435</cell></row><row><cell></cell><cell>9601</cell><cell>9601</cell><cell>9601</cell><cell>9601</cell><cell>9601</cell><cell>9699</cell><cell>10,416</cell></row><row><cell></cell><cell>(156,659)</cell><cell>(156,671)</cell><cell>(156,739)</cell><cell>(156,970)</cell><cell>(157,822)</cell><cell>(191,207)</cell><cell>(298,557)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>A.Corral  et al. / Data &amp; Knowledge Engineering 49 (2004) 67-104</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>A. Corral et al. / Data &amp; Knowledge Engineering 49 (2004) 67-104</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An optimal algorithm for approximate nearest neighbor searching fixed dimensions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Mount</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Netanyahu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Silverman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="891" to="923" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The R Ã -tree: an efficient and robust access method for points and rectangles</title>
		<author>
			<persName><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Kriegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="322" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient processing of spatial joins using R-trees</title>
		<author>
			<persName><forename type="first">T</forename><surname>Brinkhoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Kriegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="237" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Object-Relational Database Development, A PlumberÕs Guide</title>
		<author>
			<persName><forename type="first">P</forename><surname>Brown</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An evaluation of buffer management strategies for relational database systems</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 11th VLDB Conference</title>
		<meeting>11th VLDB Conference</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="127" to="141" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Enhanced nearest neighbour search on the R-tree</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="16" to="21" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Minimum vertex distance between separable convex polygons</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Y</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="45" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Closest pair queries in spatial databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Corral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Manolopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Theodoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vassilakopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="189" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Extensible buffer management of indexes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Y</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 18th VLDB Conference</title>
		<meeting>18th VLDB Conference</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="444" to="454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The ubiquitous B-tree</title>
		<author>
			<persName><forename type="first">D</forename><surname>Comer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="121" to="137" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The impact of buffering for the closest pairs queries using Rtrees</title>
		<author>
			<persName><forename type="first">A</forename><surname>Corral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vassilakopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Manolopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 5th ADBIS Conference</title>
		<meeting>5th ADBIS Conference</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="41" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Digital Chart of the World: real spatial datasets of the world at 1:1,000,000 scale</title>
		<ptr target="&lt;http://www.maproom.psu.edu/dcw&gt;" />
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Principles of database buffer management</title>
		<author>
			<persName><forename type="first">W</forename><surname>Effelsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Harder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="560" to="595" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An algorithm for finding best matches in logarithmic expected time</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Finkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Mathematical Software</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="209" to="226" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Multidimensional access methods</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gaede</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Unther</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="170" to="231" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A fast procedure for computing the distance between complex objects in three-dimensional space</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Keerthi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal of Robotics and Automation</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="193" to="203" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">External-memory computational geometry</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Tsay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Vengroff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 34th FOCS Conference</title>
		<meeting>34th FOCS Conference</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="714" to="723" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">R-trees: a dynamic index structure for spatial searching</title>
		<author>
			<persName><forename type="first">A</forename><surname>Guttman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="47" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Spatial joins using R-trees: breadth-first traversal with global optimizations</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">W</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Rundensteiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 23rd VLDB Conference</title>
		<meeting>23rd VLDB Conference</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="396" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Ranking in spatial databases</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Hjaltason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 4th SSD Conference</title>
		<meeting>4th SSD Conference</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="83" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Incremental distance join algorithms for spatial databases</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Hjaltason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings ACM SIGMOD</title>
		<imprint>
			<biblScope unit="page" from="237" to="248" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Distance browsing in spatial databases</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Hjaltason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="265" to="318" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">T</forename><surname>Ibaraki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Operations Research</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Scientific Publishing Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Size separation spatial join</title>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Sevcik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="324" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Laurini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thomson</surname></persName>
		</author>
		<title level="m">Fundamentals of Spatial Information Systems</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Ravishankar</surname></persName>
		</author>
		<title level="m">Proceedings ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="247" to="258" />
		</imprint>
	</monogr>
	<note>Spatial hash-joins</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Oracle Technology Network: Oracle Spatial UserÕs Guide and Reference</title>
		<ptr target="&lt;http://technet.oracle.com/doc/Oracle8i_816/inter.816/a77132.pdf&gt;" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Partition based spatial-merge join</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="259" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Performance of nearest neighbor queries in R-trees</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Manolopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 6th ICDT Conference</title>
		<meeting>6th ICDT Conference</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="394" to="408" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Processing and optimization of multiway spatial joins using R-trees</title>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mamoulis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Theodoridis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 18th ACM PODS Conference</title>
		<meeting>18th ACM PODS Conference</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="44" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Preparata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Shamos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry: An Introduction</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Nearest neighbor queries</title>
		<author>
			<persName><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vincent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="71" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Adaptive multi-stage distance join processing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="343" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The R þ -tree: a dynamic index for multidimensional objects</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 13th VLDB Conference</title>
		<meeting>13th VLDB Conference</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="507" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Cost models for join queries in spatial databases</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Theodoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 14th ICDE Conference</title>
		<meeting>14th ICDE Conference</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="476" to="483" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Since January 2002, he is a Lecturer at the Department of Languages and Computation, University of Almeria. He has received several research scholarships in Spain (FIAPA and University of Almeria) and Greece (under the CHOROCHRONOS project) and has published several times in international books and conferences</title>
		<author>
			<persName><forename type="first">Antonio</forename><surname>Dr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">; Acm</forename><surname>Corral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ssd</forename><surname>Sigmod</surname></persName>
		</author>
		<ptr target="http://www.ual.es/~acorral/" />
	</analytic>
	<monogr>
		<title level="m">Computer Science (European Doctorate) from the University of Almeria (Spain)</title>
		<imprint>
			<date type="published" when="1970">1970. 1993. 2002</date>
		</imprint>
		<respStmt>
			<orgName>University of Granada (Spain</orgName>
		</respStmt>
	</monogr>
	<note>His research interests include query processing in spatial databases, location-based data management, and geographical information systems. Further information can be</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">He is co-author of a book on &apos;&apos;Advanced Database Indexing&apos;&apos; and &apos;&apos;Advanced Signature Indexing for Multimedia and Web Applications&apos;&apos; by Kluwer. He is also author of two textbooks on Data Structures and File Structures, which are recommended in the vast majority of the computer science/engineering departments in Greece</title>
		<author>
			<persName><forename type="first">B</forename><surname>Eng</surname></persName>
		</author>
		<ptr target="http://delab.csd.auth.gr" />
	</analytic>
	<monogr>
		<title level="m">He served/serves as PC Co-chair of the 8th National Computer Conference (2001), the 6th ADBIS Conference (2002) the 5th WDAS Workshop (2003), the 8th SSTD Symposium (2003) and the 1st Balkan Conference in Informatics</title>
		<editor>
			<persName><forename type="first">Electrical</forename><surname>Eng</surname></persName>
		</editor>
		<editor>
			<persName><forename type="middle">D</forename><surname>Ph</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1981">1981. 1986. 2003</date>
		</imprint>
		<respStmt>
			<orgName>Aristotle University of Thessaloniki. Currently ; Computer Science of the University of Toronto, the Department of Computer Science of the University of Maryland at College Park and the University of Cyprus</orgName>
		</respStmt>
	</monogr>
	<note>Also, currently he is Vice-chairman of the Greek Computer Society. His research interests include access methods and query processing for databases, data mining, and performance evaluation of storage subsystems. Further information can be</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Prior to joining the faculty of the University of Piraeus, he was Researcher with the NatÕl Documentation Centre (NDC), 1998-1999, and with CTI, 1999-2001, where he headed the Data and Knowledge Engineering Group</title>
		<author>
			<persName><surname>Dr</surname></persName>
		</author>
		<author>
			<persName><forename type="middle">D</forename><surname>Yannis Theodoridis ; Ph</surname></persName>
		</author>
		<ptr target="http://thalis.cs.unipi.gr/~ytheod/" />
	</analytic>
	<monogr>
		<title level="m">ACM Multimedia, IEEE Transactions in Knowledge and Data Engineering, and in conferences such as ACM SIGMOD, PODS, ICDE, VLDB. His work has over 250 citations in scientific journals and conference proceedings. He has served in the program committee for several conferences, including SIGMOD, ICDE, and SSTD, as organizing committee chair for the 1st Hellenic Data Management Sysmposium (HDMSÕ02), and as general chair for the 8th IntÕl Symposium on Spatial and Temporal Databases</title>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1967">1967. 1990. 1996. January 2002. 1999</date>
		</imprint>
		<respStmt>
			<orgName>Electrical and Computer Engineering, both from the National Technical University of Athens, Greece. Since</orgName>
		</respStmt>
	</monogr>
	<note>He is member of ACM and IEEE</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Electrical and Computer Eng. from the Aristotle University of Thessaloniki. His B.Eng. thesis deals with Algorithms of Computational Geometry and his doctoral thesis deals with spatial databases. Apart from the above, his research interests include Access Methods, Spatio-temporal Databases, WWW Databases, Multimedia and GIS. He has published over 35 papers/chapters in refereed scientific journals, conference proceedings and books. He has been with the Department of Applied Informatics of the University of Macedonia, the Department of Informatics of the Aristotle University of Thessaloniki. For three years he also served the greek Public Administration as an Informatics Engineer where he participated in the evaluation and supervision of several information technology projects</title>
		<author>
			<persName><forename type="first">B</forename><surname>Eng</surname></persName>
		</author>
		<author>
			<persName><forename type="middle">D</forename><surname>Ph</surname></persName>
		</author>
		<ptr target="http://www.it.teithe.gr/~vasilako" />
	</analytic>
	<monogr>
		<title level="m">Computer Eng. and Informatics from the University of Patras and a</title>
		<imprint>
			<date type="published" when="1990">1990. 1995</date>
		</imprint>
	</monogr>
	<note>Michael Vassilakopoulos was born in Thessaloniki. he is an Associate Professor at the Department of Informatics of the Technological Educational Institute of Thessaloniki. Further information can be</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
