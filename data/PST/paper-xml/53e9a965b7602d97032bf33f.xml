<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scan-Based Movement-Assisted Sensor Deployment Methods in Wireless Sensor Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-01-09">9 Jan. 2007.</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Shuhui</forename><surname>Yang</surname></persName>
							<email>syang1@cse.fau.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Florida Atlantic University</orgName>
								<address>
									<addrLine>777 Glades Road</addrLine>
									<postCode>33431</postCode>
									<settlement>Boca Raton</settlement>
									<region>FL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Minglu</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Florida Atlantic University</orgName>
								<address>
									<addrLine>777 Glades Road</addrLine>
									<postCode>33431</postCode>
									<settlement>Boca Raton</settlement>
									<region>FL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jie</forename><surname>Wu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Florida Atlantic University</orgName>
								<address>
									<addrLine>777 Glades Road</addrLine>
									<postCode>33431</postCode>
									<settlement>Boca Raton</settlement>
									<region>FL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="middle">M</forename><surname>Li</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Shanghai Jiao Tong University</orgName>
								<address>
									<addrLine>1954 Huashan Road</addrLine>
									<settlement>Shanghai</settlement>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scan-Based Movement-Assisted Sensor Deployment Methods in Wireless Sensor Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-01-09">9 Jan. 2007.</date>
						</imprint>
					</monogr>
					<idno type="MD5">C2EFA84AD5B9C71499730D6079B2E888</idno>
					<idno type="DOI">10.1109/TPDS.2007.1048</idno>
					<note type="submission">received 1 June 2006; revised 28 Sept. 2006; accepted 2 Oct. 2006;</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Dimension exchange</term>
					<term>Hungarian method</term>
					<term>load balance</term>
					<term>movement-assisted</term>
					<term>scan</term>
					<term>sensor deployment</term>
					<term>wireless sensor networks</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The efficiency of sensor networks depends on the coverage of the monitoring area. Although, in general, a sufficient number of sensors are used to ensure a certain degree of redundancy in coverage, a good sensor deployment is still necessary to balance the workload of sensors. In a sensor network with locomotion facilities, sensors can move around to self-deploy. The movement-assisted sensor deployment deals with moving sensors from an initial unbalanced state to a balanced state. Therefore, various optimization problems can be defined to minimize different parameters, including total moving distance, total number of moves, communication/computation cost, and convergence rate. In this paper, we first propose a Hungarian-algorithm-based optimal solution, which is centralized. Then, a localized Scan-based Movement-Assisted sensoR deploymenT method (SMART) and several variations of it that use scan and dimension exchange to achieve a balanced state are proposed. An extended SMART is developed to address a unique problem called communication holes in sensor networks. Extensive simulations have been done to verify the effectiveness of the proposed scheme.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>W IRELESS sensor networks (WSNs) [1], [2] combine processing, sensing, and communications to form a distributed system that is capable of self-organizing, selfregulating, and self-repairing. The application of WSNs ranges from environmental monitoring to surveillance to coordinated target detection. The efficiency of a sensor network depends on the coverage of the monitoring area. Although, in general, a sufficient number of sensors are used to ensure a certain degree of redundancy in coverage so that sensors can rotate between active and sleep modes, a good sensor deployment is still necessary to balance the workload of sensors. Mobile sensors <ref type="bibr" target="#b2">[3]</ref> can be exploited to provide a redistribution.</p><p>After an initial random deployment of sensors in the field, movement-assisted sensor deployment <ref type="bibr" target="#b3">[4]</ref> can be applied, which uses a potential-field-based approach to move existing sensors by treating sensors as virtual particles subject to virtual forces. Basically, movement-assisted sensor deployment deals with moving sensors from an initial unbalanced state to a balanced state. Therefore, various optimization problems can be defined to minimize different parameters, including total moving distance, total number of moves, communication/computation cost, and convergence rate.</p><p>More recently, some extended virtual force methods, such as those in <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b5">[6]</ref>, which are based on disk packing theory <ref type="bibr" target="#b6">[7]</ref> and the virtual force field concept from robotics <ref type="bibr" target="#b7">[8]</ref>, are proposed. These methods simulate the attractive and repulsive forces between particles. Sensors in a relatively dense region will explode slowly according to each other's repulsive force and head toward a sparse region. In this way, the whole monitoring area can achieve an even distribution of sensors. However, these methods may have long deployment times since sensors move independently, and they may even fail if all the sensors can achieve force balance but not load balance.</p><p>We assume that sensors are deployed randomly into the square monitoring area without consideration of any physical obstacles. Then, if we partition the monitoring area into many small regions and use the number of sensors in a region as its load, the sensor deployment problem can be viewed as a load balance problem in traditional parallel processing, where each region corresponds to a processor and the number of sensors in a region corresponds to the load. The sensor deployment resembles the traditional load balance issue in parallel processing, with several key differences:</p><p>. Different objectives. In traditional load balancing, the total moving distance, rather than the number of moves, is important, whereas in sensor networks, the number of moves is also important because of a relatively heavy energy consumption to start or stop a move.</p><p>. Different technical issues. One unique issue in sensor networks is the communication hole (or simply "hole") problem, where some regions of the network have no deployed sensors. Since there is no centralized control, the network can be partitioned. Therefore, the network needs to be connected prior to load balancing. In this paper, we first provide an optimal solution in 2D meshes. This solution is based on the classic Hungarian method but requires global information without considering sensor network connectivity. We then propose a method using a 2D scan called Scan-based Movement-Assisted sensoR deploymenT method (SMART). A typical scan operation <ref type="bibr" target="#b8">[9]</ref> involves a binary operator È and an ordered set ½w 0 ; w 1 ; . . . ; w nÀ1 , where each w i represents the number of sensors in a region and returns the ordered set ½w 0 ; ðw 0 È w 1 Þ; . . . ; ðw 0 È w 1 È; . . . ; Èw nÀ1 Þ:</p><p>In this paper, we consider only integer addition and Boolean AND operations for the scan. By using integer addition, the scan operation will return the partial and total sums of the number of sensors. Since each region position and n are known, the average load information can be easily calculated and distributed, as can the overload/underload situation of each ordered subset corresponding to a prefix of the ordered set.</p><p>In SMART, a given rectangular sensor field is first partitioned into a 2D mesh through clustering. Each cluster corresponds to a square region and has a clusterhead that is in charge of bookkeeping and communication with adjacent clusterheads. A hybrid approach is used for load balancing, where the 2D mesh is partitioned into one-dimensional (1D) arrays by row and by column. Two scans are used in sequence: one for all rows and another for all columns. Within each row and column, the scan operation is used to calculate the average load and then to determine the amount of overload and underload in clusters. Load is shifted from overloaded clusters to underloaded clusters in an optimal way to achieve a balanced state. By optimal, we mean the minimum number of moves and minimum total moving distance. By a balanced state, we refer to a state with the maximum cluster size (the number of sensors in a cluster) and the minimum cluster size being different by at most 1.</p><p>The communication hole problem in a 2D mesh corresponds to a cluster with a cluster size of 0. Clearly, the scan approach cannot be used in a row or column with holes, since clusterheads separated by one or more holes cannot communicate with each other to perform a scan operation. In extreme cases, the 2D mesh may be disconnected as shown in Fig. <ref type="figure" target="#fig_0">1</ref>, where the number in each circle corresponds to the cluster size, and sensors in each cluster can communicate with sensors in adjacent clusters as well as sensors in the same cluster. In Fig. <ref type="figure" target="#fig_0">1</ref>, the network is partitioned into two components. Our solution to the hole issue is based on planting a "seed" from a nonempty cluster to an adjacent empty cluster. Various solutions are proposed in such a way that this seed-planting process (also called preprocessing) can be easily integrated with the normal 2D scan process to achieve a good balance of various objectives. The network can use newly developed location services <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref> to estimate the locations of sensors. Thus, no GPS service is required at each sensor, and the corresponding overhead is avoided. For example, locations of sensors can be determined by using sensors themselves as landmarks <ref type="bibr" target="#b11">[12]</ref>.</p><p>The contributions of this paper are listed as follows:</p><p>1. We develop an optimal load balance solution based on the classic Hungarian method that achieves the minimum total moving distance and use it as a baseline to check the performance of other approaches. 2. We systematically discuss the similarities and differences between the traditional load balancing in parallel processing and the movement-assisted sensor deployment in sensor networks. 3. We propose a new hybrid approach called SMART, together with several variations, that combines some desirable features of both local and global approaches while overcoming their drawbacks. 4. We identify a unique technical problem called the communication hole and provide solutions to it. 5. We systematically study different trade-offs among various contradictory goals. 6. We conduct extensive simulations and compare the results with several existing local movementassisted sensor deployment methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES AND RELATED WORKS 2.1 Load Balance in Multiprocessor Systems</head><p>Extensive work on load balancing has been done in the parallel processing community. In general, load balance algorithms can be classified as local (such as iterative nearest neighbor exchanging <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>) and global (such as direct mapping <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>). In the DIFF method, the balancing procedure is divided into a sequence of synchronous steps. At each step, each node i interacts and exchanges load with all its neighbors adjðiÞ. A DIFF parameter decides the portion of the excess load to be diffused between nodes i and each of its neighbors. Xu and Lau <ref type="bibr" target="#b16">[17]</ref> proved that the optimal uniform DIFF parameter that leads to the fastest convergence for 2D meshes is 1/4.</p><p>In the EXCH method, the edges of the graph are colored such that no two adjacent edges have the same color. A "dimension" is then defined as a collection of edges with the same color. In Fig. <ref type="figure" target="#fig_0">1</ref>, all edges are grouped into four dimensions. Edges with label ðiÞ belong to dimension i ði ¼ 1; 2; 3; 4Þ. At each iteration, one particular color (dimension) is considered, and every two adjacent nodes i and j connected by an edge with the selected color exchange their load according to an exchange rate. Again, Xu and Lau <ref type="bibr" target="#b16">[17]</ref> showed the optimal uniform exchange rate for 2k 1 Â 2k 2 2D meshes (where both row and column numbers are even).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Movement-Assisted Sensor Deployment</head><p>The sensor placement issue has been researched recently <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref>. A random placement of sensors may not satisfy the deployment requirement due to a hostile deployment environment. Therefore, the movementassisted sensor deployment method is developed. Most existing movement-assisted protocols rely on the notion of virtual force to move existing sensors from an initial unbalanced state to a balanced state. These protocols are similar to the nearest neighbor exchange in load balancing. Sensors are involved in a sequence of computation (for a new position) and movement.</p><p>In <ref type="bibr" target="#b5">[6]</ref>, Zou and Chakrabarty proposed a centralized virtual-force-based mobile sensor deployment algorithm (VFA), which combines the ideas of potential field and disk packing <ref type="bibr" target="#b6">[7]</ref>. In VFA, there is a powerful clusterhead that will communicate with all the other sensors, collect sensor position information, and calculate forces and desired position for each sensor. In VFA, the distance between two adjacent nodes when all nodes are evenly distributed is defined as a threshold to distinguish an attractive or a repulsive force between two nodes. The force between two nodes is 0 if their distance is equal to the threshold, attractive if less, and repulsive if greater. The total force on a node is the sum of all the forces given by other sensors together with obstacles and preferential coverage in the area. The clusterhead executes VFA and directs each sensor's movement. VFA has the drawbacks of centralized algorithms, single point of failure, bottleneck of processing, and less scalability.</p><p>In <ref type="bibr" target="#b4">[5]</ref>, Wang et al. developed a novel distributed selfdeployment protocol for mobile sensors. They used Voronoi diagrams <ref type="bibr" target="#b20">[21]</ref> to find coverage holes in the sensor network and proposed three algorithms-VEC (vector-based), VOR (Voronoi-based), and Minimax-to guide sensor movement toward the coverage hole. When applied to randomly deployed sensors, these algorithms can provide high coverage within a short time and limited moving distance. If the initial distribution of the sensors is extremely uneven, then disconnection may occur; thus, the Voronoi polygon constructed may not be accurate enough, which results in more moves and larger moving distance. They adopted the optimization of random scattering of some sensors to cover holes. The termination condition of their algorithms is coverage instead of load balance. In <ref type="bibr" target="#b21">[22]</ref>, they further explored the motion capability of sensors for relocation to deal with sensor failure or respond to new events. The algorithm contains two phases: The first is redundant sensor location, and the second is redundant sensor relocation. A grid-quorum solution was proposed to quickly locate the closest redundant sensors to the target area, where a sensor failure occurs. In their recent work <ref type="bibr" target="#b22">[23]</ref>, they designed a virtual movement scheme for the deployment protocol to reduce the moving distance of sensors. To our best knowledge, our work is the first to exploit scanbased movement-assisted solution for sensor redistribution.</p><p>Some recent work focus on sensors with limited mobility, which is motivated by the DARPA project called Intelligent Mobile Land Mine Units (IMLM) <ref type="bibr">[24]</ref>. In IMLM, the mobility system is based on a hopping mechanism. Chellapan et al. <ref type="bibr" target="#b23">[25]</ref> studied a special hopping model in which each sensor can flip (or flop) to a new location only once. In addition, the flip distance is bounded. The deployment problem is then formulated as a minimumcost, maximum-flow problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">AN OPTIMAL SOLUTION</head><p>This section starts with an optimal solution for 2D meshes based on the classic Hungarian method. Although, due to its potential drawback of centralization, this optimal solution is not practical, especially when the WSNs are not connected, we can use it as a baseline to examine the performance of other proposed methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Hungarian Method</head><p>Let us consider the edge-weighted matching problem in a complete bipartite graph K m;m (m nodes on the left side and m on the right), with numbers associated with the edges called weights. The objective is to find a perfect matching (of m pairs) such that the sum of the weights of edges in the matching is maximum (or minimum). The matching finds m edges to connect nodes on the left side to those on the right, and each node has only one edge.</p><p>A naive approach to solve the matching problem is to enumerate all m perfect matchings and find an optimal one among them. A better solution called the Hungarian method<ref type="foot" target="#foot_0">1</ref> exists. The following is the algebraic formulation for the matching problem. We let x ij (i; j ¼ 1; . . . ; m) be a set of variables. m is the number of nodes in the node sets of the complete bipartite graph B ¼ ðV ; U; EÞ, where V and U are two node sets, and E is the edge set. x ij ¼ 1 means that the edge ðv i ; u j Þ is included in the matching, whereas x ij ¼ 0 means that it is not. c ij is the weight of edge ðv i ; u j Þ. An optimal solution is</p><formula xml:id="formula_0">Minimize AE ij c ij x ij subject to X j¼1 x ij ¼ 1 i ¼ 1; . . . ; m X i¼1 x ij ¼ 1 j ¼ 1;</formula><p>. . . ; m: To use the Hungarian method to load balance in WSNs, we need to first convert the 2D mesh to a complete bipartite graph by using the following procedure: 1) Calculate the global average " v and determine the "give," "take," and "neutral" states of each grid. 2) Construct a node-weighted and edge-weighted bipartite graph, where the "give" and "take" grids appear at the left-hand and right-hand sides of the graph, respectively. The node weight corresponds to the amount of overload and underload, and the edge weight represents the distance between the "give" and "take" grids in a matching pair. 3) Derive an edge-weighted perfect bipartite graph by expanding each node with weight k to k "clone" nodes. The edge weight of the clone nodes will inherit from the original nodes. It is obvious that the total sensor moving distance is minimized. The total number of moves is also minimized, since each sensor, if necessary, only moves once to its destination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Examples and Analysis</head><p>In Fig. <ref type="figure">3</ref>, the global average in case is 5. There are three overloaded nodes and five underloaded nodes. M½3; 3 ¼ 3 means overloaded by three units, and M½1; 2 ¼ 1 means underloaded by one unit. The edge weight is the Manhattan distance between two end nodes M½i; j and M½i 0 ; j 0 . That is, Áx þ Áy ¼ ji À i 0 j þ jj À j 0 j. 2 For example, the edge connecting M½3; 3 to M½1; 2 has a weight of 3. In Fig. <ref type="figure">2a</ref>, the node and edge-weighted bipartite graph shows the weights of all edges connecting M½3; 3 to underloaded nodes. In Fig. <ref type="figure">2b</ref>, the edge-weighted complete bipartite graph of Fig. <ref type="figure">2a</ref> is shown, where each node (overloaded or underloaded) with weight k has k "clone" nodes. For example, M½3; 3 has three clone nodes labeled from 1 to 3. The Hungarian method is then applied as shown in Fig. <ref type="figure">2b</ref>, and the optimal result is shown in Fig. <ref type="figure">2c</ref>. The optimal result shows that M½5; 5 (now with four clone nodes) needs to move one sensor to each of M½1; 2, M½5; 2, M½2; 3, and M½4; 3.</p><p>There are several polynomial implementations for the Hungarian method. Our implementation is based on Munkres' method <ref type="bibr" target="#b24">[26]</ref>. Another implementation <ref type="bibr" target="#b25">[27]</ref> solves the problem in Oðm 3 Þ, exploiting the solution to the maximum flow problem. The cost of implementing the Hungarian method for load balance in WSNs is Oðm 3 Þ, where m is the amount of overloads (underloads) that is bounded by the number of sensors. Usually, the number of sensors is one or two magnitudes higher than the number of grids ðnÞ. A base station (BS) is needed to connect to the WSN, serving as the central controller for information collection and algorithm execution. Then, the BS informs all clusterheads about the sensor movement via direct or multihop communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SMART</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Basic Ideas</head><p>Unlike the optimal solution, SMART is a hybrid of the local and global approaches. Its extension (discussed in Section 5) can be used in disconnected WSNs. The sensor network is partitioned into an n Â n 2D mesh of clusters (the method can be easily extended to the general n Â m 2D mesh). Each cluster covers a small square area and is controlled by a clusterhead. The role of each clusterhead can be rotated within the cluster. Each clusterhead, in charge of communicating with adjacent clusters, knows the following information: 1) its cluster position i in the 2D mesh (via GPS) and 2) the number of sensors w i in the cluster.</p><p>Two rounds of balancing are used, one for each dimension: rows first, then columns. As shown in Fig. <ref type="figure">3b</ref>, after the first round, all rows are balanced. After the second round, all columns are balanced, as is the whole area. Although balancing within a row or column can be done either locally such as iterative nearest neighbor interaction or globally such as direct mapping, SMART relies on an extended scan method.</p><p>2. The general distance between two points is defined as </p><formula xml:id="formula_1">ððÁxÞ k þ ðÁyÞ k Þ 1=k . When k ¼ 2, it is euclidean distance, and when k ¼ 1, it is Manhattan distance.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Clustering</head><p>Since each sensor node knows its cluster ID i, sensors in the same cluster elect a unique clusterhead based on a predefined priority. Assume that each cluster covers an x Â x square. To ensure that the square is covered whenever there is a sensor in the region, the sensing range r 1 should be set to ffiffi ffi 2 p x (the diagonal length of the square). To support the transmission from a nonclusterhead to a clusterhead, the intracluster transmission range should be set to at least ffiffi ffi 2 p x (also denoted as r 1 ). To ensure that the clusterhead can communicate with clusterheads in four adjacent clusters, the intercluster transmission ranges of each clusterhead should be at least the diagonal of the rectangle constructed from two adjacent squares. That is, r 2 ¼ ffiffi ffi 5 p</p><p>x. If a sensor does not support two transmission ranges, then r 2 can be used for intracluster communication.</p><p>Generally, the role of the clusterhead should rotate among all the nodes in the cluster to achieve a balanced energy consumption and to prolong the life span of each individual node, such as in <ref type="bibr" target="#b26">[28]</ref>. Nonclusterheads only need to report their own position and energy to clusterheads by using transmission range r 1 , whereas clusterheads will communicate with neighboring clusters, take over the information of sensors in their cluster, and direct the movement of sensors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Scan</head><p>Consider the 1D array of clusters where the cluster ID is labeled following the sequence in the linear line. Again, denote w i as the number of sensors in cluster i. Let v i be the prefix sum of the first i clusters, that is, v i ¼ P i j¼1 w j . v n ¼ P n j¼1 w j is the total sum. Clearly, w ¼ v n =n is the average number of sensors in a balanced state, and v i ¼ iw is the prefix sum in the balanced state. Note that w is a real number that should be rounded to an integer bwc or dwe. In a balanced state, jw i À w j j 1 for any two clusters in the network.</p><p>The scan algorithm works from one end of the array to another (first scan) and then from the other end back to the initial end (second scan). The direction of the first sweep is called positive (with an increasing order of cluster ID), and that of the second sweep is negative (with a decreasing order of cluster ID). The first sweep calculates the prefix sum v i , where each clusterhead i determines its prefix sum v i by adding v iÀ1 þ w i and forwarding v i to the next cluster. The clusterhead in the last cluster determines v n and w ¼ v n =n (load in a balanced state) and initiates the second scan by sending out w. During this scan, each clusterhead can determine that v i ¼ iw (the load of prefix sum in a balanced state) based on w, which is passed around, and its own cluster position i.</p><p>By knowing the load in the balanced state, each cluster can easily determine its "give/take" state. Specifically, when w i À w ¼ 0, cluster i is in the "neutral" state. When w i À w &gt; 0, it is overloaded and is in the "give" state. When w i À w &lt; 0, it is underloaded and is in the "take" state. Each cluster in the give state also needs to determine the number of sensors (load) to be sent to each direction: w ! i for the load in the positive direction (or simply give-right) and w i for the load in the negative direction (give-left). Based on the scan procedure, we have</p><formula xml:id="formula_2">w ! i ¼ minfw i À w; maxfv i À v i ; 0gg<label>ð1Þ</label></formula><formula xml:id="formula_3">w i ¼ ðw i À wÞ À w ! i :<label>ð2Þ</label></formula><p>The 2D scan process involves a row scan followed by a column scan as shown in Figs. <ref type="figure">3b</ref> and<ref type="figure">3c, respectively</ref>. Table <ref type="table" target="#tab_1">1</ref> shows the details of the row scan on the third row, where i is the column number. Only the cluster at column 3 is in the "give" state, since its load is higher than w ¼ 5. For column 3, w ! 3 ¼ 2 (the load will be assigned to column 4; the actual schedule will be discussed later), and w 3 ¼ 1 (it will be assigned to column 2). Similarly, a set of conditions can be given for the "take" state: w i for take-right and ! w i for take-left. It is clear that</p><formula xml:id="formula_4">! w i ¼ minfw À w i ; maxfv iÀ1 À v iÀ1 ; 0gg;<label>ð3Þ</label></formula><formula xml:id="formula_5">w i ¼ ðw À w i Þ À ! w i :<label>ð4Þ</label></formula><p>In the subsequent discussion, we use ! w i for both the number of take-left units and the take-left state of cluster i. The same convention is used for the other three notations. The distinguishing feature of scan is its simplicity, where each clusterhead in i passes only one package in each sweep: the prefix sum w i in the first sweep followed by the global average w in the second sweep.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Properties of Scan</head><p>An optimal load balance scheduling based on scan should satisfy the above four conditions related to give-right, giveleft, take-right, and take-left for each cluster. By optimal we mean the minimum number of moves and minimum total moving distance. The following theorem shows that any violation of the conditions will result in the increase of the overall moving distance and/or the total number of moves to reach a load balance state.</p><p>Theorem 1. Any violation of the four conditions on the give and take states of each cluster will result in the increase of the overall moving distance and/or the total number of moves to reach a load balance state.</p><p>Proof. We consider four types of violations: take state changed to give state, give state changed to take state, take-right (take-left) changed to take-left (take-right), and give-right (give-left) changed to give-left (give-right). Suppose cluster i's state is changed from take to give and one unit is sent to cluster j. To ensure load balancing, that one unit at cluster i will be compensated by another unit from cluster k (that is, k gives one unit The Scan Process on the Third Row of Fig. <ref type="figure">3</ref> back to i). A better scheme would be k giving one unit directly to j to save one move and shorten the distance if j and k are at the same side of i in the 1D array.</p><p>Suppose cluster i's state is changed from give to take and one unit is given from cluster j. To ensure load balancing, that one unit will be given away to cluster k. It would be better for j to give one unit directly to k to save one move and shorten the distance if k and j are at the same side of i.</p><p>When cluster i's state mixes give-right with give-left, we assume that one unit is moved from w ! i to w i (similarly, for w i to w ! i ). We show that this schedule will generate a longer moving distance. Suppose this unit is moved from i to i 0 (1 i 0 &lt; i). Based on the balanced state requirement, one unit in cluster j in region ½1 . . . i À 1 needs to be moved out to cluster j 0 , with i &lt; j 0 n. We consider swapping these two units at i and j. To compare the moving distance between these two cases (before and after the swap), we consider two situations shown in Fig. <ref type="figure">4</ref> as follows:</p><p>1. When i 0 j &lt; i, we have ji À i 0 j þ jj À j 0 j &gt; jj À i 0 j þ ji À j 0 j:</p><formula xml:id="formula_6">2. When 1 j &lt; i 0 , we have ji À i 0 j þ jj À j 0 j ¼ ji À i 0 j þ jj À i 0 j þ ji 0 À jj &gt; jj À ij þ ji À jj:</formula><p>In both cases, the moving distance before the swap ji À i 0 j þ jj À j 0 j is longer than that after the swap.</p><p>When cluster i's state mixes take-right with take-left, we again assume that one unit is moved from ! w i to w i (similarly, for w i to ! w i ). Suppose this unit is moved from i 0 to i ði &lt; i 0 nÞ. Based on the balanced state requirement, one unit in a cluster j in region ½1 . . . i À 1 needs to be moved out to cluster j 0 , with n ! j 0 &gt; i. We consider swapping these two units at i and j. To compare the moving distance between these two cases (before and after the swap), we consider two situations shown in Fig. <ref type="figure">5</ref> for j 0 i 0 and j 0 &gt; i 0 . By following and argument similar to that in the above case, the moving distance before the swap ji À i 0 j þ jj À j 0 j is longer than that after the swap.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>t u</head><p>The following theorem shows that, when the four conditions are met, the overall moving distance is independent of the actual schedule.</p><p>Theorem 2. When take-right (take-left) states get loads from give-left (give-right) states, the overall moving distance is independent of the actual schedule.</p><p>Proof. Let us consider schedules for all take-right states that get loads from give-left states. The case of the take-left states getting loads from give-right states can be argued in a similar way. Starting from cluster 1 and checking toward cluster n (that is, along the positive direction), for each unit of underload in a take-right state i, assign one unit of load from the closest give-left state i 0 (that is, a cluster in a give-left state with a minimum ID). Now, we show that all other assignments can be converted to the above schedule without changing the total moving distance. Suppose that, in the above state, the unit to i comes from a nonclosest give-left state j 0 , and the unit from i 0 is assigned to a take-right state j, where i j i 0 . By swapping i 0 with j 0 , the total moving distance remains the same, and the unit in i now comes from i 0 (see Fig. <ref type="figure">6</ref>). This kind of swapping can be done iteratively. t u</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">An Optimal Scan in 1D Arrays and Its Extension in 2D Meshes</head><p>In this section, we propose a simple sender-initiated optimal load balance algorithm for 1D arrays. The unique property is that the algorithm starts from each cluster in the give state (give-left and give-right) in parallel, without the need to be concerned with the detail of the take state of other clusters. Suppose i is in a take state, where " w À w i &gt; 0. Then, we do not distinguish take-right from take-left.</p><p>Sender-initiated optimal load balance in 1D arrays:</p><p>1. For each cluster i in the give state, the clusterhead sends w ! i units to its right neighbor and sends w i units to its left neighbor. 2. For each cluster i in the take state, when the clusterhead senses several bypassing units, it intersects as many units as possible to fill in its "holes." Unintersected units move along the same direction.</p><p>Theorem 3. The proposed greedy schedule ensures an optimal schedule in 1D arrays. Proof. It suffices to show that the case in Fig. <ref type="figure">5</ref> is avoided. That is, the two conditions related to the take state are satisfied. Based on the algorithm, when a unit is passed to i from right to left as shown in Fig. <ref type="figure">5</ref>, it is implied that subarray ½i . . . n is in the overloaded state. Similarly, when a unit is passed to j 0 from left to right, the subarray ½1 . . . j 0 is in the overloaded state. Since i &lt; j 0 , the array ½1 . . . n, as a whole, is overloaded, which corresponds to a contradiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>t u</head><p>When the scan procedure is extended from 1D arrays to 2D meshes, the scan procedure is applied twice: once on all rows and once on all columns. This 2D scanning process represents the core of SMART. However, this approach is no longer optimal in 2D meshes. For example, consider a 2 Â 2 mesh M½1; 1 ¼ 3, M½1; 2 ¼ 1, M½2; 1 ¼ 3, and M½2; 2 ¼ 5. A scan on its rows will change the load distribution of the mesh to M½1; 1 ¼ 2, M½1; 2 ¼ 2, M½2; 1 ¼ 4, and M½2; 2 ¼ 4, and a scan on its columns will balance the mesh to M½1; 1 ¼ 3, M½1; 2 ¼ 3, M½2; 1 ¼ 3, and M½2; 2 ¼ 3. A total of four moves occur; however, the optimal solution requires only two moves from M½2; 2 to M½1; 2 directly. Theorem 4. The ratio between the 2D scan and the optimal solution in terms of the number of moves is bounded by 2.</p><p>Proof. During the 2D scan, wasted moves occur during the first scan when a (global) underloaded cluster i moves the load to another (global) underloaded cluster j. Suppose L units of load are moved from i and j. L units of load for j are necessary, whereas L units for i are wasted units. A similar situation occurs when a (global) overloaded cluster i moves load to another (global) overloaded cluster j. In this case, L units for j are wasted, whereas L units for i are necessary. It is easy to follow that for each wasted move, there is a matching necessary move; therefore, the ratio is bounded by 2. t u</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Several Variations of SMART</head><p>In SMART, an "aggressive" approach is used, where a local "give" state in a row or column can be a global "take" state.</p><p>To avoid this situation, a "conservative" approach can be used to decide on local "give" and "take" states based on global average information.</p><p>Besides the prefix sum of the first i grids in a row (or column) in the positive direction, that is, v i ¼ P i j¼1 w j , another, negative-direction prefix sum is exploited, where v 0 i ¼ P n j¼i w j and v 0 1 ¼ P n j¼1 w j is the total sum in the row (or column). The negative-direction prefix sum is achieved in the negative sweep, where the average is sending out. Now, w l ¼ v n =n is the average number of sensors in a local balanced state with respect to the current row (or column). v ¼ P n i¼1 P n j¼1 w ij is the global total sum. Then, w g ¼ v=n 2 is the average number of sensors in a global balanced state. We define a third kind of average as w m ¼ jw g À w l j=2, the mean of global and local balanced states. This average is to achieve a compromise between conservative and aggressive approaches.</p><p>The variation differs from the original SMART in its definition of threshold w used to determine the "give/take" state. Still, when w i À w ¼ 0, grid i is in the "neutral" state.</p><p>When w i À w &gt; 0, it is overloaded and is in the "give" state. When w i À w &lt; 0, it is underloaded and is in the "take" state. w can be one of three possible choices: w l , w g , and w m . Again, v i ¼ iw is the prefix sum in the balanced state under the given threshold w, and v i 0 ¼ ðn À i þ 1Þw is that of the negative direction. w should be rounded to an integer.</p><p>In the original SMART, the threshold is based on the local average w l when "give" and "take" states are balanced in a row (or column). With a changing threshold, such a balance is no longer held. That is, there could be more "give" than "take" grids, and vice versa. Therefore, w ! i for a load in the positive direction (or simply give-right) and w i for a load in the negative direction (give-left) are changed as follows: A grid is in the "give" state if its value is over the given threshold w. The amount of excessive load to be transferred to its right (or left) depends on the amount of underload to its right (or left) provided that the amount does not cause the underload of the current node. More formally, we have</p><formula xml:id="formula_7">w ! i ¼ minfw i À w; maxfv 0 iþ1 À v 0 iþ1 ; 0gg;<label>ð5Þ</label></formula><formula xml:id="formula_8">w i ¼ minfðw i À wÞ À w ! i ; maxfðv iÀ1 À v iÀ1 Þ; 0gg:<label>ð6Þ</label></formula><p>The threshold-based scan approach:</p><p>1. If w 6 ¼ w l , then determine global balanced value w g . 2. Perform a row scan followed by a column scan by using the selected w. 3. If w 6 ¼ w l , then repeat Step 2 by using w ¼ w l . w g in Step 1 can be calculated during Step 2. Basically, w g is determined after row-then-column scans. However, in these scans, there are no actual sensor movements. Movements occur once w is derived from w g . Step 3 is needed, since the result of Step 2 cannot guarantee a global balanced state. When w ¼ w m , one variation of the algorithm is to repeat Step 2 a constant ðcÞ number of times before applying Step 3. We use SMARTðgÞ, SMARTðlÞ, and SMARTðm; cÞ to represent the threshold-based scan that uses the global average, the local average (the original SMART), and the mean of the global and local averages, respectively. c in SMARTðm; cÞ corresponds to the number of iterations of Step 2.</p><p>If the total number of sensors is unknown, more information propagation is necessary. After the last cluster of each row gets the total number in its row, one more scan is generated in the last column to achieve the global average. Then, a scan in the negative direction in the column is conducted to distribute the average to each row.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXTENDED SMART</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Simple Solutions</head><p>The 2D scan discussed previously works only when there is no hole. Otherwise, certain rows and columns may not be connected. In the worst case, the 2D mesh may be disconnected. A preprocessing is needed to plant "seeds" in holes at each 1D scan, and these seeds will serve as clusterheads in these holes.</p><p>Planting seeds in holes in an asymptotically optimal way is a nontrivial task. Suppose we want to optimize the total moving distance, the number of moves, and the communication latency (where each sequential neighbor communication is considered one step). The total moving distance should be Oðn 2 Þ (as in the case of the first row of Fig. <ref type="figure" target="#fig_0">1</ref>), the number of moves should be OðnÞ, and the communication latency should be OðnÞ.</p><p>A conservative approach could be sending out one seed at a time to an adjacent empty cluster. This will work for the case of the third row of Fig. <ref type="figure" target="#fig_0">1</ref>, where k is a number larger than 5, and the direction is from left to right. However, this approach does not work well for the case of the first row, since the frontier node, which is the clusterhead of the first nonempty cluster in the expansion direction, needs to communicate with the leftmost node after each probing and expansion. The corresponding communication latency is</p><formula xml:id="formula_9">2 P nÀ1 i¼1 i ¼ Oðn 2 Þ.</formula><p>Note that, if the moving distance is the dominating factor rather than the communication latency, this is still an acceptable solution.</p><p>In an aggressive approach, each cluster that has a sufficient number of sensors (seeds) can send out multiple seeds to cover the rest. This approach certainly works for the case of the first row but fails for the case of the third row. In this case, the total moving distance would be</p><formula xml:id="formula_10">ðn À 1Þ 2 þ ðn À 3Þ 2 þ . . . þ 3 2 þ 1 2 ¼ Oðn 3 Þ;</formula><p>since clusters in the give state can initiate the process simultaneously. Moreover, the number of moves is</p><formula xml:id="formula_11">ðn À 1Þ þ ðn À 3Þ þ . . . þ 3 þ 1 ¼ Oðn 2 Þ.</formula><p>The simple recursive doubling does not work for the case of the second row either, where the span of each expansion is doubled in the subsequent step. This is because log n expansions will incur at least an n=2 Â log n ¼ Oðn log nÞ communication latency, assuming that the initial span is 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Optimal Seed Planting in 1D Arrays with Holes</head><p>We propose a solution for the hole issue that is asymptotically optimal for several parameters, including communication latency ðOðnÞÞ, total moves ðOðnÞÞ, and total moving distance ðOðn 2 ÞÞ, assuming that each cluster knows only the state of its two neighbors through probing. It is also assumed that the sensor network is sufficiently dense such that global w ! 2 (that is, on the average, each cluster has two sensors). Later, we will resort to a slightly stronger condition when the solution is extended from 1D arrays to 2D meshes.</p><p>First, we give some notation used in the solution. A segment S i is a maximum sequence of nonempty clusters. W i is the summation of load in S i , and C i is the length of S i . Now, we introduce two important concepts related to S i :</p><p>. Expansion level L i of S i :</p><formula xml:id="formula_12">2 L i C i &lt; 2 L i þ1 . . Energy level E i of S i : E i ¼ W i À C i .</formula><p>The expansion level L i determines spans of successive expansions 2 Li ; 2 Liþ1 ; 2 Liþ2 ; . . . , whereas the energy level E i indicates the number of denotable sensors in the segment. E i should be large enough to cover holes in each expansion; that is, E i ! 2 L i þk for the kth expansion, which is called the expansion condition. Any cluster that has more than one sensor is in a denotable state for providing seeds, even though the cluster may be in an underloaded state.</p><p>The solution is based on a recursive doubling of the span for each successive expansion until there is no sufficient energy for expansion, but the actual size of expansion is governed by the current expansion level. For segment S i with level L i , the sequence of span is 2 Li ; 2 Liþ1 ; 2 Liþ2 ; . . . . For example, suppose the length C i of S i is 13. The first span is 2 3 ¼ 8, making a new segment with a length of 21; the next expansion with span 2 4 ¼ 16 will increase the length to 29, and so on.</p><p>Two approaches, reactive or proactive, can be used here. In the reactive approach, each cluster waits for an expansion signal from one of its predecessors or until a predefined timeout expires (the timeout value is given in Theorem 5). This approach trades a potential long delay for small total moving distance and total moves. This approach operates in the synchronized environment, where the synchronization point can be set during the initial deployment phase. In the proactive approach, each segment acts independently for expansion. This approach has a minimum communication latency but has occasional extra sensor movements for the lack of synchronization. The solution can be described in the following steps: 1) By following the positive direction, each segment performs an expansion through recursive doubling, at which point either it is informed from a predecessor segment or a predefined tim-out expires in the reactive approach, without waiting for any signal or timeout for activation in the proactive approach until it either reaches the last cluster of the 1D array or fails the expansion condition. 2) Repeat</p><p>Step 1 for the negative direction, except that no timeout is needed at this step.</p><p>The efficiency of the method depends on the worst case time-out in the reactive approach and the excessive movement in parallel seed planting in the proactive approach. The next theorem shows that it is sufficient to set the timeout to 5ði À 1Þ, where i is the ID of the first cluster in the segment. The total moving distance in the proactive approach is still bounded within Oðn 2 Þ. Theorem 5. In each segment S in a scan, the total moving distance in constructing S is bounded by C 2 and the communication latency is bounded by 5C.</p><p>Proof. We prove by induction that, when S i expands to connect S j to form a new S k along the positive direction, we assume that C 0 i is the span S i used to connect S j , and C 0 j is the span of the nonoverlapping region in S j as in Fig. <ref type="figure" target="#fig_3">7</ref>. Note that S i may merge with another segment S j to form a new segment S k as a result of the expansion of S i (as shown in Fig. <ref type="figure" target="#fig_3">7</ref>). S k will calculate its W k and L k accordingly. The special case S j does not exist and has a length of 0. The following proof still applies.</p><p>Based on the induction, the latency in the formation of S i is bounded by 5C i . In the current expansion, C i is needed for the frontier node to inform all relevant clusters along the negative direction in S i , and it takes C i þ C 0 i time to pass seeds to relevant positions. Finally, it takes C 0 j steps to reach the frontier of S k (that is, the rightmost node in S j ). Based on the fact that C 0 i C i &lt; 2C 0 i (expansion conditions), we have</p><formula xml:id="formula_13">5C i þ C i þ ðC i þ C 0 i Þ þ C 0 j &lt; 5ðC i þ C 0 i þ C 0 j Þ ¼ 5C k :</formula><p>Similarly, we show the total moving distance by induction. Based on induction, the formation of S i is bounded by C 2 i . In the current expansion, the total moving distance is bounded by</p><formula xml:id="formula_14">X C 0 i À1 l¼0 ðC i þ lÞ ¼ C i C 0 i þ C 0 i ðC 0 i À 1Þ=2:</formula><p>In the proactive approach, the formation of S j needs to be included, which is bounded by</p><formula xml:id="formula_15">C 2 j &lt; ðC 0 i þ C 0 j Þ 2 . Based on the fact that C 0 i C i &lt; 2C 0 i , we have C 2 i þ C i C 0 i þ C 0 i ðC 0 i À1Þ=2 þ ðC 0 i þC 0 j Þ 2 &lt; ðC i þ C 0 i þ C 0 j Þ 2 ¼ C 2 k : t u</formula><p>Since the method involves two sweeps, the overall moving distance is clearly bounded by Oðn 2 Þ, and the overall communication latency is bounded by OðnÞ. The total moves are bounded by OðnÞ in the reactive approach and by Oðn log nÞ in the proactive approach. In the latter case, clusters can plant seeds in parallel, but recursive doubling limits parallel merging to log n levels of the merging tree. Therefore, the proposed method in the proactive mode is optimal for the three parameters.</p><p>The following theorem shows that no timeout is needed in the second scan and proves the correctness of the 1D scan approach. The postfix of the 1D array is a subarray that contains the last cluster in the array. Theorem 6. Assume that the average load is at least 2 for each cluster. After the first scan, at least one postfix of the 1D array is a segment. In the second scan, no timeout is needed. All holes will be filled.</p><p>Proof. It is assumed that the average load for each cluster is at least 2. Suppose S 1 ; S 2 ; . . . ; S kÀ1 ; S k is the sequence of segments after Step 1 of preprocessing, where for each</p><formula xml:id="formula_16">S i (except S k ), E i &lt; 2 L i ; that is, W i &lt; 2C i . If we let P kÀ1 i¼1 W i ¼ W M and P kÀ1 i¼1 C i ¼ C M , then W M &lt; 2C M .</formula><p>Based on the assumption of "at least average load of 2" for each cluster, we have</p><formula xml:id="formula_17">W M þ W k ! 2C M þ 2C k &gt; W M þ 2C k ; therefore, W k &gt; 2C k . S k</formula><p>has sufficient energy for expansion. The only case for preventing such an expansion is when S k includes the last cluster in the 1D array. Therefore, S k is a postfix of the 1D array.</p><p>During Step 2 of preprocessing, since S k has sufficient energy, it will fill in the "gap" (a consecutive sequence of empty clusters) between S k and S kÀ1 by planting seeds in holes between them. By following the same argument, the newly formed segment will have sufficient energy to fill the next gap. In this way, all gaps will be filled after the second scan.</p><p>t u</p><p>The result from Theorem 6 shows that the scan process can be combined with the preprocessing (planting the seeds). That is, the scan process can start at step 2 of the preprocessing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Extended SMART</head><p>Now, let us extend the approach from 1D to 2D. The first issue is to ensure that each 1D row array in the 2D mesh meets w ! 2. Instead of enforcing it (which is impossible), we propose a smoothing process on all columns before the preprocessing on rows. The smoothing process on columns includes preprocessing (that is, plant seeds in holes) and scan (that is, load balance). This columnwise smoothing process does not completely remove holes or balance the load along columns, unless the number of sensors in each column is at least 2n initially. However, when the sensor network is sufficiently dense, each row will have w ! 2 after the columnwise smoothing process. The following theorem shows the density requirement. Theorem 7. Suppose the average number of sensors in a cluster is at least 4. After the columnwise smoothing, each row will have at least 2n sensors.</p><p>Proof. We try to find the maximum number of sensors that can be deployed when at least one row still has less than 2n sensors after the columnwise smoothing. If that number is less than 4n 2 , then the theorem is proven. Assume that, initially, k columns have a load of at least 2n, and the remaining n À k columns have a load under 2n. The former k columns will achieve load balancing after smoothing, whereas the latter n À k columns will not. Without loss of generality, we assume that row 1 (that is, the first nodes in all columns) has less than 2n sensors after smoothing. All the first nodes of those n À k columns that have not achieved the balanced state are holes. The maximum total load of nodes other than the first nodes in these n À k columns is bounded by ðn À kÞð2n À 1Þ. The loads of the first nodes of the other k columns that have achieved the balanced state along columns are assumed to be i 1 ; i 2 ; . . . ; i k , respectively. Based on the balanced state definition, the maximum total load of nodes other than the first nodes in these k columns is bounded by ðn</p><formula xml:id="formula_18">À 1Þ½ði 1 þ 1Þ þ ði 2 þ 1Þ þ . . . ði k þ 1Þ.</formula><p>Therefore, the total number is bounded by</p><formula xml:id="formula_19">I þ ðn À 1ÞðI þ kÞ þ ðn À kÞð2n À 1Þ ð2n À 1Þ þ ðn À 1Þð2n þ k À 1Þ þ ðn À kÞð2n À 1Þ since I ¼ i 1 þ i 2 þ . . . þ i k 2n À 1.</formula><p>Clearly, the total number is bounded by 4n 2 À ð2 þ kÞn &lt; 4n 2 . This number is maximized when k ¼ 1, and the corresponding distribution is shown in Fig. <ref type="figure" target="#fig_4">8</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>t u</head><p>With the above result, the extended SMART protocol can be resolved to the following steps:</p><p>. Step 1 (Columnwise smoothing). Preprocess on columns (positive direction). If the last cluster fails condition 1 (discussed below), then terminate the preprocessing; otherwise, simultaneously preprocess and scan on columns (negative direction). If the first cluster fails condition 2 (discussed below), terminate the preprocessing; otherwise, scan on columns (positive direction). . Step 2 (Row-wise preprocessing and scanning).</p><p>Preprocess on rows (positive), then simultaneously preprocess and scan on rows (negative), and finally, scan on rows (positive). . Step 3 (Columnwise scanning). Scan on columns (negative followed by positive). Both conditions 1 and 2 are used for early termination when a particular column has less than 2n sensors. Condition 1 is defined when the last cluster is included in a segment S and W ! 2C. Condition 2 is defined when the first cluster is included in a segment S such that C ¼ n and W ! 2n. In Step 1, each column needs one, two, or three sweeps, depending on whether that column has 2n sensors or not. In Step 2, three sweeps are needed. Two sweeps are needed in Step 3. In the worst case, a total of eight sweeps are needed.</p><p>The above approach has potential drawbacks in generating a longer communication latency even in the absence of holes. To resolve this issue, we introduce some simple bookkeeping. Once the first sweep of Step 1 is completed, each end node in the last row will set a flag to 1 whenever it registers at least 2n sensors in the corresponding segment. If all flags in the last row are set, Step 3 can be skipped. Checking whether all flags are set can be done in parallel with Step 2, which needs 2n steps with two sweeps on the last row. The first sweep is a scan using Boolean AND, and the second is a broadcast of the scan value of the first sweep that is a Boolean value (1 for all flags set and 0 otherwise).</p><p>With the above modification, the worst case number of sweeps is reduced to 5. One more sweep can be eliminated by combining preprocessing and scanning in Step 1. Whenever the first cluster is included in the current segment, the scan process also starts. At the end of the first sweep, if the current segment includes both first and last clusters, then the third sweep in Step 1 can be eliminated, since its function can be done at the second sweep. The optimization for the number of moves discussed in Section 3 can still be used after the scan process starts. However, the number of moves during the smoothing and preprocessing phases cannot be further reduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">SIMULATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Simulation Environment</head><p>We use a custom simulator. The initial deployment that it generates could be a uniform or normal random distribution. We set up the simulation in a 500 Â 500 area, which is the target field. The tunable parameters in our simulation are listed as follows: 1) Cluster numbers n Â n. A large n can improve the speed of deployment, whereas a small n can achieve more balanced results. We use 4 and 10 as n's values. 2) Number of sensors N. We have proven that at least 4n 2 sensors are needed to guarantee the validation of SMART. Therefore, we vary N's value from 400 to 1,000. We also include cases of under 4n 2 sensors to check the robustness of SMART. 3) Normal distribution parameter . is the standard deviation of the normal distribution of the initial deployment, which can control the density degree of the sensor clustering. We use 1 to 5 as its values. When is 1, around 98 percent of the sensors are in the 10 percent region of the area. When is 10, the distribution is very close to uniform random distribution. For each tunable parameter, the simulation is repeated 1,000 times. In addition to the proposed algorithms, we also simulate the traditional load balancing algorithms DIFF, EXCH, and the Voronoi-based localized sensor redistribution algorithm (VOR) for comparison.</p><p>The performance metrics are 1) deployment quality and 2) deployment cost. Deployment quality is shown by the balance degree measured by two simulation results. One is the standard deviation of the number of sensors in all the clusters. The other is grads, which is the difference between the largest cluster and the smallest one. Deployment cost is measured by the time of deployment, in terms of rounds, and energy consumption, in terms of overall moving distance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Simulation Results</head><p>Fig. <ref type="figure" target="#fig_5">9</ref> compares the number of rounds and the moving distance of the three algorithms, namely, DIFF, EXCH, and SMART in uniform random distribution. Based on Figs. 9a, 9b, and 9c, we can see that the proposed SMART has a small and stable number of rounds. When the initial deployment is relatively balanced and n is small, every row can have more than 2n sensors; thus, it has five rounds; otherwise, it takes eight rounds (the worst case). DIFF and EXCH both have large numbers of rounds, which increase with the growth of node number, especially when n is large and the initial deployment is uneven. Figs. <ref type="figure" target="#fig_5">9d, 9e,</ref> and<ref type="figure" target="#fig_5">9f</ref> show the overall moving distance comparison. We can see that the overall sensor moving distance is proportional to the number of sensors. Therefore, the average moving distance of a sensor is insensitive to node numbers in all these algorithms. Among the three, SMART has the largest moving distance. This is because it achieves the most balanced final state, which leads to more sensor movements.</p><p>Figs. <ref type="figure" target="#fig_6">10a</ref> and<ref type="figure" target="#fig_6">10b</ref> show the balance degree of the results of these three algorithms by standard deviation in uniform random distribution. SMART achieves a balanced final state, and its standard deviation is less than or equal to 2. Figs. <ref type="figure" target="#fig_6">10c</ref> and<ref type="figure" target="#fig_6">10d</ref> show the balance degree in terms of grads. The grads of SMART are less than or equal to 2, and the grads in a row or a column are less than or equal to 1. In DIFF and EXCH, only the relative balanced state, which is the neighboring balance, is guaranteed. That is, the difference between adjacent clusters is less than or equal to 1. Therefore, the result could be a ladderlike distribution, which leads to very large grads and standard deviations. When n is large, the grads of DIFF and EXCH are large, and their balance degrees are low.</p><p>Figs. 11a, 11b, 11d, and 11e compare the standard deviation and moving distance of algorithms using different normal distribution parameters . The curve "Initial" is the standard deviation of the initial deployment. SMART can achieve a more balanced state than DIFF and EXCH. SMART also outperforms them in a number of moves. In SMART, sensors move at most twice: one move for the vertical  direction and another for the horizontal direction; more than 75 percent of sensors move only once. When N is 400, and is 1, SMART has 444, DIFF has 1,040, and EXCH has 1,137. Since the startup usually consumes more power than moving with invariable speed, less movement is desired. Fig. <ref type="figure" target="#fig_7">11c</ref> shows the standard deviation, and Fig. <ref type="figure" target="#fig_7">11f</ref> shows the moving distance comparison of VOR and SMART. We can see that VOR can only slightly reduce the standard deviation of the initial deployment. It has been mentioned in <ref type="bibr" target="#b4">[5]</ref> that the basic VOR algorithm has difficulties in dealing with high-degree clustering, where sensors are centered around a few locations. When is 1, after applying VOR, the clustering area still has high density, whereas the original blank area has low density. The optimized VOR (O-VOR) proposed to deal with this problem is better than VOR, but SMART still outperforms O-VOR.</p><formula xml:id="formula_20">(a) n ¼ 4, ¼ 1. (b) n ¼ 4, ¼ 5. (c) n ¼ 10, ¼ 1. (d) n ¼ 4, ¼ 1. (e) n ¼ 4, ¼ 5. (f) n ¼ 10, ¼ 1.</formula><p>VOR is designed for a relatively sparse sensor network that has a uniform random initial deployment, whereas SMART is designed for a relatively dense network with high-degree clustering. For fairness, we conduct the following simulation to compare the performance of SMART and VOR in a relatively sparse network where the condition of Theorem 7 for SMART is not necessarily satisfied.</p><p>Figs. 12a and 12b show the comparisons of the resultant balance degree (in terms of standard deviation) and the number of rounds of SMART, VOR, and O-VOR ( ¼ 3, n ¼ 10). In Fig. <ref type="figure" target="#fig_8">12a</ref>, when N is larger than 400, SMART guarantees the balanced final state, where the standard deviation of the resultant deployment of SMART should be less than 2. This result is consistent with the analytical results in the previous section, where, if the average number of sensors in a cluster is less than 4, some rows may have less than 2n sensors after smoothing. When the node number is smaller than 400, the standard deviation is larger than 2, and the balanced status is not achieved. However, the increase of standard deviation is small, and the balance degree of SMART can still beat that of VOR. For VOR, when the node number is small, the resultant deployment is more balanced. With the growth of the number of deployed nodes, the balance degree gets lower. This is because, in the high-degree clustering environment, when the coverage termination condition of VOR is met, most of the area can be covered by at least one node, but VOR terminates before nodes in the clustering area scatter out. Fig. <ref type="figure" target="#fig_8">12b</ref> shows the comparison of the number of rounds. At least 400 deployed nodes are needed to achieve the best performance, five rounds, for SMART. The worst is eight rounds. For VOR, a smaller node number leads to fewer rounds. However, VOR has fewer rounds than SMART when the node number is smaller than 150. O-VOR achieves a more balanced degree with a smaller round number than VOR.</p><p>Figs. <ref type="figure" target="#fig_8">12c</ref> and<ref type="figure" target="#fig_8">12d</ref> show the comparisons of several variations of SMART and also the optimal Hungarianbased method (OPT) in uniform and normal random distributions, respectively (n ¼ 10, N ¼ 500). SMARTðlÞ, SMARTðgÞ, and SMARTðm; 3Þ are simulated. To check the effect of Step 3 in the threshold-based scan algorithm, we simulate SMARTðg 0 Þ, which is SMARTðgÞ without Step 3. As shown in Fig. <ref type="figure" target="#fig_8">12c</ref>, SMARTðmÞ has the most moving distance, whereas SMARTðgÞ has a smaller moving distance than SMARTðlÞ. OPT has the smallest moving distance. Fig. <ref type="figure" target="#fig_8">12d</ref> shows the results in normal random distribution. With the growth of , the moving distance decreases, and the number of moves decreases slightly. SMARTðgÞ and SMARTðmÞ have smaller moving distances than SMARTðlÞ. SMARTðmÞ has the smallest among the three. SMARTðlÞ has close or even better performance than OPT because it does not achieve a balanced result as OPT does.</p><p>Simulation results can be summarized as follows:</p><p>1. SMART achieves a more balanced state than DIFF, EXCH, and VOR sensor deployment methods in unevenly deployed sensor networks. 2. SMART needs a few rounds, which are bounded by eight, for load balancing. 3. The centralized optimal algorithm has the best performance; among all variations of SMART, SMARTðgÞ has the best overall performance. 4. SMART can be effective when used in relatively dense sensor networks as a complement for the existing sensor deployment methods. 5. When the number of deployed nodes is less than 4n 2 , the performance of SMART is reduced, since more rounds are needed, and a balanced final state cannot be achieved. 6. In a sparse network, SMART may need more rounds than VOR to achieve a balanced degree, but it still beats VOR in terms of standard deviation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>In this paper, we have proposed the SMART algorithm, which is a hybrid approach of the local and global methods.</p><p>We have considered a unique issue called the "communication hole," where certain sensing areas have no deployed sensors. A method of seed planting has been proposed to move one sensor to each uncovered area before the scanning process. We also developed an optimal solution that is based on the Hungarian method. Simulation results show that the proposed method can achieve an even deployment of sensors with modest costs. In the future, we will perform an in-depth simulation on energy consumption of sensor deployment algorithms and design some intracluster balancing algorithms to achieve high-resolution load balancing. We also plan to consider the case where only parts of the sensors are mobile. In this case, the ultimate goal is to maximize the minimum load of these grids. This is a more general measurement for the balance degree of the final distribution. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A sample clustered sensor network that corresponds to a 2D mesh.</figDesc><graphic coords="2,316.91,65.48,195.65,101.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .Fig. 3 .</head><label>23</label><figDesc>Fig. 2. (a) The node-and edge-weighted bipartite graph of Fig. 3, with "give" grids at the left-hand side and "take" grids at the right-hand side. (b) The edge-weighted complete bipartite graph of (a). (c) The optimal solution.</figDesc><graphic coords="4,99.21,65.48,367.99,154.54" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .Fig. 6 .</head><label>46</label><figDesc>Fig. 4. Two cases for mixing up give-right with give-left. Fig. 5. Two cases for mixing up take-right with take-left.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The merging of two segments.</figDesc><graphic coords="8,316.12,65.48,197.18,81.81" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. A worst-case distribution.</figDesc><graphic coords="10,74.78,65.48,153.92,153.81" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Comparison of DIFF, EXCH, and SMART in (a), (b), and (c) round number and (d), (e), and (f) distance.(a) n ¼ 4, ¼ 1. (b) n ¼ 4, ¼ 5. (c) n ¼ 10, ¼ 1. (d) n ¼ 4, ¼ 1. (e) n ¼ 4, ¼ 5. (f) n ¼ 10, ¼ 1.</figDesc><graphic coords="11,115.82,378.99,334.83,285.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Balance degree of DIFF, EXCH, and SMART ð ¼ 1Þ. (a) Standard deviation, ðn ¼ 4Þ. (b) Standard deviation, ðn ¼ 10Þ. (c) Grads, ðn ¼ 4Þ. (d) Grads, ðn ¼ 10Þ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. SMART compared with DIFF, EXCH, and VOR by using different (N ¼ 400). (a) Standard deviation, n ¼ 4. (b) Standard deviation, n ¼ 10. (c) Standard deviation, n ¼ 10. (d) Moving distance, n ¼ 4. (e) Moving distance, n ¼ 10. (f) Moving distance, n ¼ 10.</figDesc><graphic coords="12,32.77,65.48,500.94,283.63" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Property analysis of SMART and VOR and comparison of variations of SMART. (a) Standard deviation. (b) Round number. (c) Moving distance, uniform. (d) Moving distance, normal.</figDesc><graphic coords="13,114.41,65.48,337.72,278.82" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 1</head><label>1</label><figDesc></figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In honor of the Hungarian mathematicians D. K} onig and E. Egerva ´ry who developed it.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was supported in part by US National Science Foundation grants ANI 0073736, CCR 0329741, CNS 0422762, CNS 043533, EIA 0130806, CNS 0531410, and CNS 0626240, National Natural Science Foundation of China grants No. 60628201, No. 60473092, and No. 90612018, and National Basic Research Program of China grant No. 2006CB303000.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>. For more information on this or any other computing topic, please visit our Digital Library at www.computer.org/publications/dlib.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Survey on Sensor Networks</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Akyildiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sankrasubramaniam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Cayirci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comm. Magazine</title>
		<imprint>
			<biblScope unit="page" from="102" to="114" />
			<date type="published" when="2002-08">Aug. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Wireless Sensor Networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="30" to="33" />
			<date type="published" when="2004-06">June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Robomote: A Tiny Mobile Robot Platform for Large-Scale Sensor Networks</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Sibley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Rahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sukhatme</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int&apos;l Conf. Robotics and Automation (ICRA)</title>
		<meeting>IEEE Int&apos;l Conf. Robotics and Automation (ICRA)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Real Time Obstacle Avoidance for Manipulators and Mobile Robots</title>
		<author>
			<persName><forename type="first">O</forename><surname>Khatib</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int&apos;l J. Robotics Research</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="90" to="98" />
			<date type="published" when="1986-08">Aug. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Movement-Assisted Sensor Deployment</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">La</forename><surname>Porta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2004-03">Mar. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Sensor Deployment and Target Localization Based on Virtual Forces</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chakrabarty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2003-03">Mar. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Packing Equal Circles in a Square: A Deterministic Global Optimization Approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Locateli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Raber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Math</title>
		<imprint>
			<biblScope unit="volume">122</biblScope>
			<biblScope unit="page" from="139" to="166" />
			<date type="published" when="2002-10">Oct. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An Incremental Self-Deployment Algorithm for Mobile Sensor Networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Howard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Mataric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sukhatme</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Autonomous Robots: Special Issue on Intelligent Embedded Systems</title>
		<imprint>
			<date type="published" when="2002-09">Sept. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scans as Primitive Parallel Operations</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1526" to="1538" />
			<date type="published" when="1989-11">Nov. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Recursive Position Estimation in Sensor Networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Albowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int&apos;l Conf. Network Protocols (ICNP)</title>
		<meeting>IEEE Int&apos;l Conf. Network Protocols (ICNP)</meeting>
		<imprint>
			<biblScope unit="page" from="35" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">GPS-Less Low Cost Outdoor Localization for Very Small Devices</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bulusu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Personal Comm.: Special Issue on Smart Spaces and Environment</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="28" to="34" />
			<date type="published" when="2000-10">Oct. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Relaxation on a Mesh: A Formation for Generalized Localization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Howard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Mataric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sukhatme</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/RSJ Int&apos;l Conf. Intelligent Robots and Systems (IROS)</title>
		<meeting>IEEE/RSJ Int&apos;l Conf. Intelligent Robots and Systems (IROS)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Communication Finite Automata Approach to Modeling Distributed Computation and Its Application to Distributed Decision Making</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Casavant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Kuhl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="628" to="639" />
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Load Balancing for Distributed Memory Multiprocessors</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cybenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="279" to="301" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Dynamic Load Balancing Policy with a Central Job Dispatcher (LBC)</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Raghavendra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="148" to="158" />
			<date type="published" when="1992-02">Feb. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Distributed Drafting Algorithm for Load Balancing</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">B</forename><surname>Gendreau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1153" to="1161" />
			<date type="published" when="1985-10">Oct. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Load Balancing in Parallel Computers</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">C M</forename><surname>Lau</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Kluwer Academic</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Sensor Deployment Strategy for Target Detection</title>
		<author>
			<persName><forename type="first">T</forename><surname>Clouqueur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Phipatanasuphorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ramanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Saluja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop Wireless Sensor Networks and Applications (WSNA)</title>
		<meeting>Workshop Wireless Sensor Networks and Applications (WSNA)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sensor Placement for Grid Coverage under Imprecise Detections</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dhillon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chakrabarty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Iyengar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Information Fusion</title>
		<meeting>Int&apos;l Conf. Information Fusion</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Exposure in Wireless Ad Hoc Sensor Networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Meguerdichian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Koushanfar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Potkonjak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MobiCom</title>
		<meeting>MobiCom</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Voronoi Diagrams and Delaunay Triangulations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fortune</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Euclidean Geometry and Computers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Sensor Relocation in Mobile Sensor Networks</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">La</forename><surname>Porta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Movement-Assisted Sensor Deployment</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">La</forename><surname>Porta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Mobile Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="640" to="652" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Mobility Limited Flip-Based Sensor Networks Deployment</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chellappan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xuan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Mobile Ad Hoc and Sensor Systems (MASS)</title>
		<meeting>IEEE Mobile Ad Hoc and Sensor Systems (MASS)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Dictionary of Algorithms and Data Structures</title>
		<ptr target="http://www.nist.gov/dads/HTML/munkresAssignment.html" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Combinatorial Optimization, Algorithms and Complexity</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Steiglitz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Dover</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Distributed Clustering in Ad Hoc Sensor Networks: A Hybrid Energy-Efficient Approach</title>
		<author>
			<persName><forename type="first">O</forename><surname>Younis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fahmy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2004-03">Mar. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
