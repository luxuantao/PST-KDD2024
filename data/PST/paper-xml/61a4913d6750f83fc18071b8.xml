<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Understanding and Simplifying One-Shot Architecture Search</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Gabriel</forename><surname>Bender</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Pieter-Jan</forename><surname>Kindermans</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Barret</forename><surname>Zoph</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Vijay</forename><surname>Vasudevan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Quoc</forename><surname>Le</surname></persName>
						</author>
						<title level="a" type="main">Understanding and Simplifying One-Shot Architecture Search</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>There is growing interest in automating neural network architecture design. Existing architecture search methods can be computationally expensive, requiring thousands of different architectures to be trained from scratch. Recent work has explored weight sharing across models to amortize the cost of training. Although previous methods reduced the cost of architecture search by orders of magnitude, they remain complex, requiring hypernetworks or reinforcement learning controllers. We aim to understand weight sharing for one-shot architecture search. With careful experimental analysis, we show that it is possible to efficiently identify promising architectures from a complex search space without either hypernetworks or RL.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Designing neural networks is a labor-intensive process that requires a large amount of trial and error by experts. There is growing interest in automating the search for good neural network architectures <ref type="bibr" target="#b31">(Zoph &amp; Le, 2016;</ref><ref type="bibr" target="#b2">Baker et al., 2016;</ref><ref type="bibr" target="#b22">Real et al., 2017)</ref>. For instance, <ref type="bibr" target="#b32">Zoph et al. (2017)</ref> show that one can find an architecture that simultaneously achieves state-of-the-art performance on the CIFAR-10, ImageNet, and COCO datasets. However these search methods are incredibly resource-hungry. <ref type="bibr" target="#b32">Zoph et al. (2017)</ref> used 450 GPUs for four days in order to run a single experiment. They proposed an RL-based approach in which a neural network (the controller) enumerates a set of architectures to evaluate. Each architecture is trained from scratch on CIFAR-10 for a fixed number of epochs and then evaluated on a validation set. The weights of the controller are subsequently updated based on the validation accuracies of the trained models.</p><p>Training thousands of models is difficult or impossible for a typical machine learning practitioner. To address this weakness of architecture search, new methods have been</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proceedings of the 35 th</head><p>International Conference on Machine <ref type="bibr">Learning, Stockholm, Sweden, PMLR 80, 2018.</ref> Copyright 2018 by the author(s). proposed <ref type="bibr" target="#b8">(Brock et al., 2017;</ref><ref type="bibr" target="#b20">Pham et al., 2018;</ref><ref type="bibr" target="#b10">Elsken et al., 2017;</ref><ref type="bibr" target="#b17">Liu et al., 2017a;</ref><ref type="bibr" target="#b9">Cai et al., 2017;</ref><ref type="bibr" target="#b18">Liu et al., 2017b)</ref>. One promising direction is sharing weights between models <ref type="bibr" target="#b8">(Brock et al., 2017;</ref><ref type="bibr" target="#b20">Pham et al., 2018)</ref>: rather than training thousands of separate models from scratch, one can train a single large network capable of emulating any architecture in the search space.</p><p>A simple example is shown in Figure <ref type="figure" target="#fig_0">1</ref>, where we have the option of applying either a 3x3 convolution, a 5x5 convolution, or a max-pooling layer at a particular position in the network. Instead of training three separate models, we can train a single model containing all three operations (the one-shot model). We selectively zero out two of the three operations' outputs at evaluation time in order to determine which operation leads to the best prediction accuracy.</p><p>In more complex examples, a search space may include choices at many different positions within a network. The size of the search space grows exponentially with the number of choices, while the size of the one-shot model grows only linearly. The same weights are used to evaluate many different architectures, reducing the resources required to run an architecture search by orders of magnitude.</p><p>Despite the improvements in efficiency, it is natural to wonder whether there are inherent limits to weight sharing across models. Why should a heterogeneous set of architectures be able to share a single set of weights? One-shot models are typically only used to rank architectures in the search space; the best-performing architectures are retrained from scratch after the search is completed. But even with that restriction, the idea that a single fixed set of weights can work well across a wide range of architectures is counterintuitive. SMASH <ref type="bibr" target="#b8">(Brock et al., 2017)</ref> tries to address this concern by using a hypernetwork to generate a large fraction of the weights in each candidate architecture. Efficient Neural Architecture Search (ENAS) <ref type="bibr" target="#b20">(Pham et al., 2018)</ref> addresses the same concern by alternating between training the shared model weights and training a controller that identifies a subset of architectures from the search space to focus on.</p><p>Our goal in this paper is to understand the role that weight sharing plays in efficient architecture search methods. Perhaps surprisingly, we show that neither a hypernetwork nor an RL controller is necessary to achieve good results. To do this, we train a large one-shot model containing every possible operation in the search space. We then zero out some of the operations and measure the impact on the model's prediction accuracies. When trained carefully, we show that the network automatically focuses its capacity on the operations that are most useful for generating good predictions. Zeroing out the less important operations has only a small impact on the model's predictions. In contrast, zeroing out the more important operations has an exaggerated effect on both the model's predictions and its validation set accuracy. In fact, it is possible to predict an architecture's validation set accuracy by looking at its behavior on unlabeled examples from the training set. This behavior is an implicit consequence of weight sharing, and requires neither a hypernetwork nor an explicit controller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>The use of meta-learning to improve machine learning has a long history <ref type="bibr" target="#b23">(Schmidhuber, 1987;</ref><ref type="bibr" target="#b12">Hochreiter et al., 2001;</ref><ref type="bibr" target="#b27">Thrun &amp; Pratt, 2012)</ref>. Beyond architecture search, metalearning has been used to optimize other components of learning algorithms such as update rules <ref type="bibr" target="#b1">(Andrychowicz et al., 2016;</ref><ref type="bibr" target="#b28">Wichrowska et al., 2017;</ref><ref type="bibr" target="#b4">Bello et al., 2017)</ref> and activation functions <ref type="bibr" target="#b21">(Ramachandran et al., 2017)</ref>.</p><p>Our work is most closely related to SMASH <ref type="bibr" target="#b8">(Brock et al., 2017)</ref>, which in turn is motivated by NAS <ref type="bibr" target="#b31">(Zoph &amp; Le, 2016)</ref>. In NAS, a neural network controller is used to search for good architectures. The training of the NAS controller requires a loop: The controller proposes child model architectures, which are trained and evaluated. The controller is then updated by policy gradient <ref type="bibr" target="#b29">(Williams, 1992)</ref> to sample better architectures over time. Once the controller is done training, the best architectures are selected and trained longer to improve their accuracies. The main bottleneck of NAS is the training of the child model architectures; SMASH aims to amortize this cost. In SMASH, a hypernetwork is trained a priori to generate suitable weights for every child model architecture in the search space. The same fixed hypernetwork is then used to evaluate many different child model architectures.</p><p>NAS and SMASH both treat architecture search as a blackbox optimization problem, which can be optimized using off-the-shelf techniques. <ref type="bibr" target="#b7">(Bergstra et al., 2011;</ref><ref type="bibr" target="#b5">Bergstra &amp; Bengio, 2012;</ref><ref type="bibr" target="#b6">Bergstra et al., 2013;</ref><ref type="bibr" target="#b24">Snoek et al., 2012;</ref><ref type="bibr">2015)</ref> In hyperparameter optimization, the idea of sharing parameters between models has been also explored in the context of Population Based Training <ref type="bibr" target="#b15">(Jaderberg et al., 2017)</ref>.</p><p>Genetic and neuro-evolution algorithms have also been used for designing good neural network architectures, e.g., <ref type="bibr" target="#b26">Stanley &amp; Miikkulainen (2002)</ref>; <ref type="bibr" target="#b3">Bayer et al. (2009)</ref>; <ref type="bibr" target="#b16">Jozefowicz et al. (2015)</ref>; <ref type="bibr" target="#b19">Miikkulainen et al. (2017)</ref>; <ref type="bibr" target="#b30">Xie &amp; Yuille (2017)</ref>. For these methods, parameter sharing between models, also known as weight inheritance, has been explored with positive effects <ref type="bibr" target="#b22">(Real et al., 2017)</ref>.</p><p>Black-box methods measure the accuracies of trained architectures on a held-out validation set. In contrast, Mor-phNets <ref type="bibr" target="#b11">(Gordon et al., 2017</ref>) make architectural decisions directly on the training set, applying L1 regularization to induce sparsity. Like MorphNets, we start with an overcomplete network architecture and then prune the least useful parts. But while <ref type="bibr" target="#b11">Gordon et al. (2017)</ref> focus on filter sizes, we focus on pruning ops and skip-connections. Experiments from SMASH and ENAS suggest our method might be extended to search over filter sizes. We could also apply MorphNets to the models found by our architecture search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">One-Shot Architecture Search</head><p>The proposed approach for one-shot architecture search consists of four steps: (1) Design a search space that allows us to represent a wide variety of architectures using a single one-shot model. (2) Train the one-shot model to make it predictive of the validation accuracies of the architectures.</p><p>(3) Evaluate candidate architectures on the validation set using the pre-trained one shot model. (4) Re-train the most promising architectures from scratch and evaluate their performance on the test set. We describe these steps in the remainder of this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Search Space Design</head><p>Designing a good search space for one-shot architecture search is a challenging problem, as it requires us to balance a number of competing requirements. First: the search space should be large and expressive enough to capture a diverse set of interesting candidate architectures. Second: the validation set accuracies produced by the one-shot model must be predictive of the accuracies produced by stand-alone model training. Third: the one-shot model must be small enough to train using limited compute resources (i.e., memory and time). The best architectures in the search space must also have competitive accuracies. However, since our main goal is to understand the role of weight sharing, our search space is not yet fully optimized for quality, and we believe that further improvements are possible. We begin with an example of a search space (shown in  More generally, we have the option of enabling or disabling any combination of the incoming connections. In this way, the the size of the search space grows exponentially with the number of incoming skip-connections, while the size of the one-shot model grows only linearly. The concatenation is always followed by a 1x1 convolution; the number of output filters in the convolution remains constant no matter how many incoming skip-connections there are.</p><p>The one-shot model then applies several different operations to the output of the 1x1 convolution and adds the results together. At evaluation time, we zero out or remove some of these operations from the network. In our running example, we have four possible operations: a pair of 3x3 convolutions, a pair of 5x5 convolutions, a max pooling layer, or an identity operation. However, only the 5x5 convolutions' outputs are used when the architecture is evaluated.</p><p>This approach is applied to a much larger model as shown in Figure <ref type="figure" target="#fig_2">3</ref>. Following <ref type="bibr" target="#b32">Zoph et al. (2017)</ref>, our network is composed of several identical cells which are stacked on top of each other. Each cell is divided into a fixed number of choice blocks. The inputs to a given choice block come from (1) outputs of previous cells, and (2) outputs of previous choice blocks within the same cell.</p><p>The number of choice blocks within each cell, N choice , is a hyper-parameter of the search space. In our experiments, we set N choice = 4. Each choice block can consume the outputs of the two most recent cells in the network. This means that each choice block can select from up to five possible inputs: two from previous cells and up to three from previous choice blocks within the same cell.</p><p>Each choice block can select up to two operations from a menu of seven possible options: (1) identity, (2) a pair of depthwise separable 3x3 convolutions, (3) a pair of depthwise separable 5x5 convolutions, (4) a pair of depthwise separable 7x7 convolutions, (5) a 1x7 convolution followed by a 7x1 convolution, (6) a max pooling layer, and (7) an average pooling layer.</p><p>Search Space Size. Each architecture in our search space consists of a stack of identical cells; we now estimate the number of possible cells in our search space. Each cell has four choice blocks. For i = 0, 1, 2, 3, the ith choice block takes at least 1 and at most 2 + i inputs. This means that there are 2 2+i 1 possible combinations of inputs to the ith choice block. Furthermore, each choice block applies either one or two different operations out of 7 possible options.</p><p>There are therefore 7 1 + 7 2 = 7 + 21 = 28 possible combinations of operations that we can apply in each block. Across the entire search space, there are therefore (2 2 1)</p><formula xml:id="formula_0">• (2 3 1) • (2 4 1) • (2 5 1) • 28 4 ⇡ 6 • 10 9 possible cells.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Training the One-Shot Model</head><p>Many architecture search methods use a proxy metric to find promising models efficiently. If the proxy metric provides a strong relative ranking of models, this enables the discovery of high performing models when trained to convergence. For example, one common proxy metric is the accuracy on the validation set after a short amount of training. This proxy metric was successfully used in the original NAS paper. In this work, as well as in SMASH and ENAS, the proxy metric is the validation accuracy obtained by activating individual architectures in the one shot model.</p><p>The one-shot model is a standard large neural network trained using SGD with Momentum. To make sure that the one-shot model accuracies for specific architectures correlate well with stand-alone model accuracies we have to consider the aspects discussed below.</p><p>Robustness to Co-adaptation. At evaluation time, we zero out large portions of the one-shot model to evaluate specific architectures. If we train the one-shot architecture naively, the components can co-adapt. Removing operations -even unimportant ones -from the network can cause the quality of the model's predictions to degrade severely. The correlations between one-shot and stand-alone model accuracies also degrade.</p><p>We incorporate path dropout at model training time in order to ensure that the model is robust to such changes. When training the one-shot model, we randomly zero out a subset of the ops for each batch of examples. We achieved good results by disabling path dropout at the beginning of training and gradually increasing the rate of dropout over time using a linear schedule. The dropout rate at the end of training is set to r 1/k where 0 &lt; r &lt; 1 is a hyper-parameter of the model and k is number of incoming paths to a given operation in the network. The higher the fan-in, the more likely each possible input is to be dropped out. However, the probability of dropping out all inputs to a node is kept constant regardless of its fan-in. Suppose r = 0.05. If a node has k = 2 inputs then each one will independently be dropped out with probability 0.05 1/2 ⇡ 0.22 and will be retained with probability 0.78. If a node has k = 7 incoming paths then each one will independently be dropped out with probability 0.05 1/7 ⇡ 0.65 and will be retained with probability 0.35. In both cases, the probability of dropping out all of the op's incoming paths is 5%.</p><p>Within a single cell, different operations are dropped out independently of each other. If a model contains multiple cells, however, the same operations will be dropped out in each one. We found that independently dropping out different paths within the same cell was beneficial, but did not investigate the behavior of dropout across cells. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Evaluating Candidate Architectures</head><p>Once the one-shot model is trained, we use it to evaluate the performance of many different architectures on a held-out validation set. In our experiments, architectures are sampled independently from a fixed probability distribution, following <ref type="bibr" target="#b8">Brock et al. (2017)</ref>. We note that random search could be replaced by other search methods, such as evolutionary algorithms or neural network-based reinforcement learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Final Model Selection and Training</head><p>The output of the search is a list of candidate architectures ranked by one-shot accuracy. After completing a search, one can retrain the best-performing architectures from scratch. Depending on the amount of compute resources available and the model accuracy requirements, one can additionally screen and hyperparameter tune many of the best-performing models as a post-processing step. However, other efficient architecture search methods elide this accuracy-boosting step, and we follow suit for purposes of comparison with these methods. To evaluate the use of a one-shot model, we sample the best-performing architectures found by our search. On CIFAR-10, each architecture is trained from scratch for 300 epochs on the full training set, then evaluated on the test set. On ImageNet, each architecture is trained for 200 epochs. Experiments were implemented using TensorFlow <ref type="bibr" target="#b0">(Abadi et al., 2016)</ref>.</p><p>It is possible to either scale up an architecture (to increase its accuracy) or scale down (to reduce its inference cost). In our experiments, we scale up architectures by increasing the number of filters. It may be possible to increase the number of cells in the model to further improve performance, but we use a fixed depth of six cells in all of our CIFAR-10 experiments and eight cells in our ImageNet experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">One-Shot Model Experiments</head><p>In this section, we explain and analyze the steps of architecture search. The goal is twofold: (1) to show that our approach is competitive with existing approaches for oneshot architecture search and (2) to provide insights into what makes one-shot architecture search possible.</p><p>On CIFAR-10 we used a 45,000 element training set, 5,000 element validation set, and 10,000 element test set. Ima-geNet was partitioned into a 1,281,167 training set, 50,046 element validation set, and 50,000 element test set. One-shot model accuracies and accuracies from abbreviated training were computed on the validation sets, while the final accuracies of architectures were computed on the test sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Experiments on CIFAR-10</head><p>Training the One-Shot Model. Given the search space detailed in the previous section, we begin by training a one-shot model on CIFAR-10. Each one-shot model was trained for 5,000 -10,000 steps (113 -225 epochs) on a cluster of 16 P100 GPUs. Each worker used a batch size of 64, which was divided into two ghost batches of size 32. We used a global learning rate of 0.1 and Nesterov momentum 0.9.<ref type="foot" target="#foot_1">1</ref> Increasing the number of training steps improved the correlations between one-shot and stand-alone model accuracies in our experiments, but only slightly. We therefore used a shorter training period for our initial hyperparameter tuning experiments and a longer period for the model that was used in our large-scale architecture search.</p><p>Impact of Dropout Rate. Compared with vanilla SGD, one-shot model training introduces just one new hyperparameter: the dropout rate. The value of this hyperparameter is important, however, and it must be tuned carefully in order to achieve good correlations between one-shot and stand-alone model accuracies.</p><p>To demonstrate its importance, we trained one-shot models with varying dropout rates. Following the setup described at the beginning of the section, each one-shot model was trained for 5,000 steps (113 epochs) using Synchronous SGD with 16 workers. The dropout rates in these experiments were kept constant throughout training.</p><p>The results of our experiment are shown in Figure <ref type="figure" target="#fig_3">4</ref>. When the dropout rate is very low (i.e., most of the paths in the oneshot model are retained at each training step), the correlation plots develop a "snout." A few of the architectures in the search space receive relatively high accuracies from the one-shot model. But while these architectures are usually good, the ones that receive the highest accuracies are not necessarily the best ones in the search space. Most of the architectures, however, receive very low accuracies. Due to the low dropout rate at training time, the one-shot model is ill-prepared for large portions of the model to be zeroed out at evaluation time.</p><p>When the dropout rate is very high (i.e., most of the paths in the one-shot model are dropped out at each training step), we encounter a different problem: the extent to which the oneshot model focuses its capacity on the most useful paths in the network is greatly diminished. Instead of ranging from 0.3 to 0.9, the one-shot model accuracies now range between 0.66 to 0.78. In early experiments, we found that high dropout rates yielded respectable results when the one-shot models were relatively shallow (e.g., networks containing Right: model trained with a constant dropout rate of r = 0.3, a high value where some paths are retained only 15% of the time.</p><p>up to 12 layers in total). However, using a high dropout rate became increasingly problematic as the search space grew more complex and the one-shot model grew deeper.</p><p>One-Shot Model Training and Evaluation. For the oneshot model used in our large-scale architecture search experiments, we made two changes from the smaller-scale experiments described above. First: we increased the number of training steps from 5,000 to 10,000. Second: we allowed the dropout rate to increase over time. At the start of training, dropout was effectively disabled, while at the end of training, we had a dropout rate determined by the coefficient r = 0.1. Between these two points, the rate of dropout for each operation in the network was increased linearly over the course of training.</p><p>Armed with a calibrated one-shot model, we randomly sampled around 20,000 architectures from the search space, and computed the accuracy of each one on the one-shot model. We then divided the architectures into buckets based on their accuracies, and sampled four architectures from each bucket. Finally, we retrained each of the sampled architectures from scratch for around 28 epochs with a batch size of 64 and a ghost batch size of 32. These stand-alone model accuracies were averaged across five runs. Using the one-shot model, each architecture took around 15 seconds to evaluate on a P100 GPU. It took around 80 GPU-hours to evaluate all 20,000 architectures. However, we spent little time optimizing the code, and the search was trivially parallelizable. We believe that with more engineering effort, the cost of a search could be decreased dramatically.</p><p>We then compared these stand-alone model accuracies to the one-shot model accuracies. Figure <ref type="figure" target="#fig_4">5</ref> shows that there is a near-monotonic correlation between the two. This confirms that in our experimental setup, both proxy metrics are likely to favor similar network architectures.</p><p>On the bottom of Figure <ref type="figure" target="#fig_4">5</ref> we take a look at the histogram of one-shot model accuracies. About 34% of architectures receive one-shot model accuracies of 0.8 or above, while only 9% have accuracies of 0.85 or above and only 1% have accuracies of 0.88 or above. The quality improvements of better-performing models are modest but still noticeable: after 25 epochs of training, models in our sample with oneshot accuracies from 0.8 -0.85 have average validation set accuracies of around 0.941 after 28 epochs of stand-alone training. Meanwhile, architectures with one-shot accuracies of 0.90 or above have average validation set accuracies of around 0.944. This suggests that the truly high performing architectures only make up a limited part of the search space. This will be confirmed by a random sample that is trained until convergence in the next experiment.</p><p>Final Model Selection and Training. After screening 20,000 random architectures with the one-shot model, we performed another selection. From the top 100 architectures, we took a stratified sample of 10 for further evaluation. We then increased the number of filters in the models and trained them for 300 epochs without additional hyper-parameter tuning. The results are shown in the "One-Shot Top" section of Table <ref type="table" target="#tab_1">1</ref>. When comparing based on the number of parameters in the model, our approach is competitive with SMASHv2 and almost all ENAS variations. We parameterize our models based on F , the number of filters in the first convolutional layer. When F = 64, we obtain an average accuracy of 95.9% with about 10M parameters. SMASH has 96.0% accuracy with 16M parameters. If we make the model even bigger (F = 128), we get 96.1% accuracy. The best models get up to 96.5% accuracy with around 41M parameters.</p><p>We conclude that our approach is competitive with SMASH and all but one ENAS variation. This shows that our simplified architecture search is solid and can be used to better understand one-shot model behaviour. This we will analyze in more detail now and in the next section.</p><p>Comparing our sample of 10 top architectures ("One-Shot Top") against 10 randomly sampled architectures ("Random"), we find that the top architectures have better accuracies by around .5% absolute. However, they also have about 1.6x as many parameters. A natural follow-up question is whether the one-shot model always favors the architectures with the most parameters. To answer this question, we searched for the smallest architectures whose one-shot model accuracies exceeded a certain threshold (roughly in the 90th percentile). The resulting architectures ("One-Shot Small") have nearly the same accuracies as the top models but fewer parameters than both the top and random models.</p><p>The baseline All On trains the model with all paths turned on. This approach gets .1% higher accuracies, with the best models obtaining 96.5%. However, the number of parameters is nearly 2x that of One-Shot Top and 4x that of One-Shot Small. In this respect, we could see architecture search as a way to prune the less useful parts of the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Experiments on ImageNet</head><p>To evaluate our approach on larger datasets, we ran an architecture search directly on ImageNet using Cloud TPUs.</p><p>The One-Shot model was trained for 15k steps (about 47 epochs or 6 hours) with a batch size of 4,096 on four Cloud TPUs (16 chips). Each candidate architecture took 1-2 TPU chip-minutes to evaluate. The final models were trained and evaluated using 224 ⇥ 224 input images. 6.8 ± 0.9 73.8 ± 0.4 One-Shot Top (F = 32) 11.9 ± 1.5 75.2 ± 0.4 One-Shot Small (F = 16)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results, shown in</head><p>1.4 ± 0.4 67.9 ± 0.5 One-Shot Small (F = 24) 3.0 ± 0.8 72.4 ± 0.4 One-Shot Small (F = 32) 5.1 ± 1.5 74.2 ± 0.3 Random (F = 16) 2.0 ± 0.5 67.9 ± 1.0 Random (F = 24) 4.4 ± 1.0 72.2 ± 0.7 Random (F = 32) 7.7 ± 1.9 74.1 ± 0.6</p><p>Table <ref type="table" target="#tab_2">2</ref>. Architecture search results on ImageNet.</p><p>accuracies than random models, but also more parameters.</p><p>By searching for the smallest models whose one-shot accuracies exceed a predetermined threshold, we are able to improve the trade-off between quality and model size.</p><p>We also discovered that although our models have significantly better accuracies than NASNet and Mo-bileNet <ref type="bibr" target="#b14">(Howard et al., 2017)</ref> for the same number of parameters, they have higher inference costs (measured in terms of multiply-adds). In follow-up experiments in Appendix A, we tweaked our top models in order to roughly match the computation of these mobile-sized models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Understanding One-Shot Models</head><p>We next discuss why the same fixed set of model weights can be shared across many different architectures. One key observation from Figure <ref type="figure" target="#fig_4">5</ref> is that while one-shot model accuracies range from 30% to 90% on CIFAR-10, stand-alone model accuracies range from 92.0% to 94.5%. Although the accuracies of the best models decrease by only 5 -10 percentage points when we switch from stand-alone to oneshot training, the accuracies of less promising architectures drop by as much as 60 percentage points. Similar behavior is shown in <ref type="bibr" target="#b8">Brock et al. (2017)</ref>, where one-shot model accuracies range from 10% to 60% on CIFAR-100 while stand-alone model accuracies range from 70% to 75%. Why should the spread of one-shot model accuracies be so much larger than the spread of stand-alone model accuracies?</p><p>Our hypothesis is that the one-shot model learns which operations in the network are most useful, and comes to rely on these operations when they are available. Removing the less important operations from the network has relatively little influence on the model's predictions and only a modest effect on its final prediction accuracy. Removing the most important operations from the network, however, can lead to dramatic changes in the model's predictions and a large drop in prediction accuracy.</p><p>In order to test this hypothesis, we sampled a collection of architectures where almost all the operations in the one-shot model were enabled (base dropout rate r = 10 8 ). We compared the predictions made by these reference architec- tures against the predictions of candidate architectures with fewer operations that were sampled from our actual search space. The comparison was performed on batches examples from the training set. If our hypothesis is correct then we should expect the predictions made by the best-performing models to be similar to the predictions made when all the operations in the network are enabled.</p><p>We use symmetrized KL divergence to quantify the extent to which candidate architectures' predictions differ from those of reference architectures on a given example. Our one-shot model is trained using a logistic loss function, so the reference output can be interpreted as a probability distribution (p 1 , p 2 , . . . , p n ) over output classes.</p><p>Compared against a candidate architecture that produces output distribution (q 1 , q 2 , . . . , q n ), the KL divergence is estimated as D KL (p || q) = P n i=1 p i log pi qi . We use D KL (p || q) + D KL (q || p), the symmetrized KL divergence between p and q, to quantify the similarity of the two distributions. If the distributions are nearly identical for the current training example then the symmetrized KL divergence will be close to 0. Conversely, the symmetrized KL divergence can grow quite large if the distributions are very different. We compute the KL divergence on 64 random examples from the training set and report the average. The results of our experiment, shown in Figure <ref type="figure" target="#fig_5">6</ref>, are striking. KL divergences measured on the training set are strongly correlated with prediction accuracies measured on the validation set. Furthermore, the KL divergences are computed without making use of any information about the examples' training labels. Combined with the results of Figure <ref type="figure" target="#fig_4">5</ref>, this means that the closer a candidate architecture's predictions are to those of our reference architectures (where most of the operations in the one-shot model are turned on), the higher its quality typically is during standalone training. Weight sharing implicitly forces the one-shot model to identify and focus on the operations that are most useful for generating good predictions. The same experiment suggests an explanation for the exaggerated difference in validation set accuracies that we observe when using the one-shot model. If certain operations are especially useful to the one-shot model, it will come to rely on those operations' outputs when generating predictions. Removing them from the network will result in catastrophic damage and extremely low validation set accuracies. On the other hand, less-useful operations can be removed from the network with only a modest impact on the one-shot model's predictions.</p><p>We next explore how the KL divergences evolve over time. We sampled six different architectures and tracked their symmetrized KL divergences over the course of training. Results are shown in Figure <ref type="figure" target="#fig_6">7</ref>. Initially, all of the KL divergences are low because the model's predictions are initially low-confidence, and each output class is assigned a roughly equal probability. Our model gradually becomes more confident in its predictions, and the predictions of different architectures begin to separate. This accounts for the spike in KL divergences. Later in training, the most useful operations in the network have a strong influence over the model's predictions, and receive low KL divergences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion</head><p>We analyzed a class of efficient architecture search methods based on weight sharing in a model containing the entire search space of architectures. We designed a training method and search space to address the fundamental challenges in making these methods work. Through this simplified lens, we explained how the fixed set of weights in a one-shot model can be used to predict the performance of stand-alone architectures, demonstrating that one shot architecture search only needs gradient descent, not reinforcement learning or hypernetworks, to work well.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Example building block used in a one-shot model. The search space contains three different operations; the one-shot model adds their outputs together. Some of the operations are removed or zeroed out at evaluation time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Example of a cell during one-shot model evaluation. Although the one-shot model contains four separate operations, we can emulate a cell containing a max-pooling op by removing the other operations from the network without retraining the weights.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3</head><label>3</label><figDesc>Figure3.1) that incorporates non-trivial decisions about both the network structure and the operations that are applied at different positions within the network.At training time, the one-shot model contains three different inputs which are concatenated together. At evaluation time, however, we can simulate a network containing only Input 2 by zeroing out or removing the incoming connections from Input 1 and Input 3 from the trained network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. One-shot models trained with constant dropout rates. Left: model training with a constant dropout rate of r = 10 6 ; paths in the network are retained more than 85% of the time. Middle: model trained with a constant dropout rate of r = 0.01, a moderate value.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Top: Comparison of one-shot and stand-alone model accuracies from a stratified sample of architectures. Stand-alone models were trained for an abbreviated period of around 28 epochs, and stand-alone model accuracies were averaged across 5 runs. Bottom: Distribution of sampled one-shot model accuracies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Comparison of one-shot model accuracies on the validation set vs. symmetrized KL divergences on the training set. Lower KL divergences on the training set are strongly correlated with higher validation set accuracies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Left: symmetrized KL divergences from six architectures over the course of one-shot model training. Right: the one-shot validation accuracies of all six architectures at the end of training. The top-to-bottom order of the KL divergences in the plot mirrors the top-to-bottom order of the entries in the legend.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Diagram of the one-shot architecture used in our experiments. Solid lines indicate components that are present in every architecture, while dashed lines indicate optional components that are part of the search space.</figDesc><table><row><cell>Input</cell><cell>Input A</cell><cell></cell><cell>Input B</cell><cell>Input 1</cell><cell>Input 2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Input K</cell></row><row><cell>Stem 1</cell><cell>1x1</cell><cell>Cell</cell><cell>1x1</cell><cell></cell><cell></cell><cell></cell><cell>Choice Block</cell><cell></cell><cell></cell></row><row><cell>Stem 2</cell><cell>Avg. Pool</cell><cell></cell><cell>Avg. Pool</cell><cell></cell><cell></cell><cell></cell><cell>Concat.</cell><cell></cell><cell></cell></row><row><cell>Cell 1</cell><cell>Choice 1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1x1</cell><cell></cell><cell></cell><cell>Fixed edge Legend</cell></row><row><cell>Cell 2</cell><cell></cell><cell>Choice 2</cell><cell></cell><cell>3x3</cell><cell>5x5</cell><cell>7x7</cell><cell>1x7</cell><cell>Max Pool</cell><cell>Avg. Pool</cell><cell>Identity</cell><cell>Edge selected by architecture search</cell></row><row><cell>1x1 Cell 3</cell><cell></cell><cell></cell><cell>Choice 3</cell><cell>3x3</cell><cell>5x5</cell><cell>7x7</cell><cell>7x1</cell><cell></cell><cell></cell><cell>Avg. Pool</cell><cell>Only present when resolution is reduced</cell></row><row><cell>Avg. Pool</cell><cell></cell><cell>Concat.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Sum</cell><cell></cell><cell></cell></row><row><cell>Output</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Figure 3.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Stabilizing ModelTraining. One-shot model training was highly unstable in early experiments. We found that a careful application of batch normalization could be used to stabilize training. We experimented with the orders BN-Relu-Conv and Relu-BN-Conv. While both showed promise, we use the former for the experiments reported in this paper. When the one-shot model is used to evaluate a candidate architecture from the search space, we zero out a subset of its operations. Doing so changes the batch statistics at each layer. Because we do not know the batch statistics for a candidate architecture in advance, batch normalization is applied exactly the same way at evaluation time as during training -computing the batch statistics on the fly. Architecture search on CIFAR-10. We evaluate ten models and report the mean x and standard deviation y as x ± y. with batch normalization, which is better able to compute batch statistics when the same paths are dropped out for multiple examples. As a compromise, we partition each training batch into multiple ghost batches. A single training batch might contain 1024 examples, which can be partitioned into 32 ghost batches of size 32. We drop out the same paths for each example within a ghost batch, but drop out different paths for different ghost batches.</figDesc><table><row><cell>A variant of ghost batch normalization (Hoffer et al., 2017)</cell></row><row><cell>further stabilized training. One-shot model training tended</cell></row><row><cell>to become unstable if we dropped out the same subset of</cell></row><row><cell>paths for every example within a single batch. We found,</cell></row></table><note>however, that it could be stabilized if we dropped out different paths on different subsets of the examples. We initially tried dropping different paths independently for every example in the batch. However, this approach didn't work well Preventing Over-regularization. A given convolutional layer might only be used for a subset of the architectures in the search space. During training, L2 regularization is applied only to parts of our model that are used by the current architecture. Without this change, layers that are dropped out frequently are regularized more.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2</head><label>2</label><figDesc></figDesc><table><row><cell>, are consistent with our CIFAR-</cell></row><row><cell>10 experiments. The top-performing models have better</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">Google Brain, Mountain View, CA. Correspondence to: Gabriel Bender &lt;gbender@google.com&gt;.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1">In early experiments where the dropout rate was kept constant, using at least 16 ghost batches helped stabilize training. Gradually increasing the dropout rate over time may make it possible to use fewer workers, but we did not explore this in depth.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank David Dohan, Irwan Bello, Vishy Tirumalashetty, Samy Bengio, Jeff Dean, Geoff Hinton, and the rest of the Google Brain team for their helpful comments and discussions. We are grateful to Ryan Sepassi for his infrastructure work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Tensorflow: A system for large-scale machine learning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Devin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Irving</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kudlur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Levenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Monga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Steiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vasudevan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Warden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;16</title>
				<meeting>the 12th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;16<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="265" to="283" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Learning to learn by gradient descent by gradient descent</title>
		<author>
			<persName><forename type="first">M</forename><surname>Andrychowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Denil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pfau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schaul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Freitas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="3981" to="3989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raskar</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1611.02167</idno>
		<title level="m">Designing neural network architectures using reinforcement learning</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Evolving memory cell structures for sequence learning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wierstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Togelius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Artificial Neural Networks</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="755" to="764" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">I</forename><surname>Bello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vasudevan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1709.07417</idno>
		<title level="m">Neural optimizer search with reinforcement learning</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Random search for hyperparameter optimization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="281" to="305" />
			<date type="published" when="2012-02">Feb. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Making a science of model search: Hyperparameter optimization in hundreds of dimensions for vision architectures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yamins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
				<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="115" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Algorithms for hyper-parameter optimization</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bardenet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kégl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="2546" to="2554" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">SMASH: One-shot model architecture search through hypernetworks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Brock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Ritchie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Weston</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1708.05344</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Reinforcement learning for architecture search by network transformation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1707.04873</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Simple and efficient architecture search for convolutional neural networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Elsken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Metzen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hutter</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1711.04528</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Fast &amp; simple resource-constrained structure learning of deep networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Eban</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Nachum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><surname>Morphnet</surname></persName>
		</author>
		<idno>CoRR, abs/1711.06798</idno>
		<ptr target="http://arxiv.org/abs/1711.06798" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Learning to learn using gradient descent</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Younger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Conwell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Artificial Neural Networks</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="87" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Train longer, generalize better: closing the generalization gap in large batch training of neural networks</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hoffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hubara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Soudry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1729" to="1739" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Howard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kalenichenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Weyand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Andreetto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Adam</surname></persName>
		</author>
		<author>
			<persName><surname>Mobilenets</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1704.04861</idno>
		<title level="m">Efficient convolutional neural networks for mobile vision applications</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Population based training of neural networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jaderberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Dalibard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Osindero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Razavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dunning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1711.09846</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An empirical exploration of recurrent network architectures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jozefowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="2342" to="2350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fei-Fei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yuille</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Murphy</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1712.00559</idno>
		<title level="m">Progressive neural architecture search</title>
				<imprint>
			<date type="published" when="2017">2017a</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fernando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1711.00436</idno>
		<title level="m">Hierarchical representations for efficient architecture search</title>
				<imprint>
			<date type="published" when="2017">2017b</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Miikkulainen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Meyerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Francon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Raju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Navruzyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Duffy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hodjat</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.00548</idno>
		<title level="m">Evolving deep neural networks</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Faster discovery of neural architectures by searching for paths in a large model</title>
		<author>
			<persName><forename type="first">H</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Guan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=ByQZjx-0-" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Ramachandran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1710.05941</idno>
		<title level="m">Searching for activation functions</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Large-scale evolution of image classifiers</title>
		<author>
			<persName><forename type="first">E</forename><surname>Real</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Selle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">L</forename><surname>Suematsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kurakin</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.01041</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Evolutionary principles in self-referential learning, or on learning how to learn: the meta-meta-... hook</title>
		<author>
			<persName><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität München</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Practical bayesian optimization of machine learning algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Snoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="2951" to="2959" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Scalable bayesian optimization using deep neural networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Snoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Rippel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Swersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kiros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Satish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Patwary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Prabhat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="2171" to="2180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Evolving neural networks through augmenting topologies</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">O</forename><surname>Stanley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miikkulainen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="99" to="127" />
		</imprint>
	</monogr>
	<note>Evolutionary computation</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Learning to learn</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thrun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Pratt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Wichrowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Maheswaranathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Colmenarejo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Denil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>De Freitas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sohl-Dickstein</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.04813</idno>
		<title level="m">Learned optimizers that scale and generalize</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Simple statistical gradient-following algorithms for connectionist reinforcement learning</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reinforcement Learning</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="5" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">L</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><surname>Yuille</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.01513</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">A. Genetic cnn. arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Neural architecture search with reinforcement learning</title>
		<author>
			<persName><forename type="first">B</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Learning transferable architectures for scalable image recognition</title>
		<author>
			<persName><forename type="first">B</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vasudevan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1707.07012</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
