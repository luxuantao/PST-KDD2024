<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">EASE: An Effective 3-in-1 Keyword Search Method for Unstructured, Semi-structured and Structured Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Guoliang</forename><surname>Li</surname></persName>
							<email>liguoliang@tsinghua.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Beng</forename><forename type="middle">Chin</forename><surname>Ooi</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<postCode>117543</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jianhua</forename><surname>Feng</surname></persName>
							<email>fengjh@tsinghua.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jianyong</forename><surname>Wang</surname></persName>
							<email>jianyong@tsinghua.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lizhu</forename><surname>Zhou</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">EASE: An Effective 3-in-1 Keyword Search Method for Unstructured, Semi-structured and Structured Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E601769D4F47B0BB9B2AC19F23E533E8</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.8 [Database Applications ]: Miscellaneous Algorithms</term>
					<term>Performance</term>
					<term>Languages Keyword Search</term>
					<term>Indexing</term>
					<term>Ranking</term>
					<term>Graph Index</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Conventional keyword search engines are restricted to a given data model and cannot easily adapt to unstructured, semistructured or structured data. In this paper, we propose an efficient and adaptive keyword search method, called EASE, for indexing and querying large collections of heterogenous data. To achieve high efficiency in processing keyword queries, we first model unstructured, semi-structured and structured data as graphs, and then summarize the graphs and construct graph indices instead of using traditional inverted indices. We propose an extended inverted index to facilitate keyword-based search, and present a novel ranking mechanism for enhancing search effectiveness. We have conducted an extensive experimental study using real datasets, and the results show that EASE achieves both high search efficiency and high accuracy, and outperforms the existing approaches significantly.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Keyword search is a proven and widely popular mechanism for querying document systems and the World Wide Web. Recently, it has even been extensively applied to extract useful and relevant information from the Internet. Furthermore, the database research community has also recognized the benefits of keyword search and has been introducing keyword search capability into relational databases <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23]</ref>, XML databases <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b27">28]</ref> and graph databases <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b16">17]</ref>.</p><p>However, the existing web search engines cannot integrate information from multiple interrelated pages to answer key-word queries meaningfully. Next-generation web search engines require link-awareness, or more generally, the capability of integrating correlative information items that are linked through hyperlinks. Meanwhile, the efficiency of keyword search on structured and semi-structured data remains a challenging problem. This is so because the traditional approaches have always employed the inverted index to process keyword queries, which is effective for unstructured data but inefficient for semi-structured and structured data. This is because the inverted index is inadequate for identifying the "best" answers with complex structural information, which is rather rich in XML documents or relational databases.</p><p>To the best of our knowledge, very few existing studies could be universally applied to unstructured data (e.g., text documents), semi-structured data (e.g., XML documents), structured data (e.g., relational databases) and graph data. Therefore, providing both effective and efficient search ability over such heterogeneous collections within a single search engine remains a big challenge. As it is, the structure of the data, such as the potentially hierarchical embedding in XML documents, is not fully exploited for answering keyword queries. It is also not taken into account for result ranking in most search engines. Consequently, current implementations focus on either IR-style search to meaningfully rank the results but ignore the rich structural information, or DB-style search to discover answers by identifying structural relationships but employ a very straightforward ranking mechanism.</p><p>This less-than-ideal situation calls for a framework for indexing and querying over large collections of unstructured, semi-structured or structured data, and adaptive ranking of the results retrieved over those heterogeneous data. In this paper, we propose EASE, an Efficient and Adaptive keyword SEarch method, as an attempt in that direction. Our work is in line with the current trend of seamlessly integrating databases (DB) and information retrieval (IR) techniques <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b26">27]</ref>. EASE seamlessly integrates efficient query evaluation and adaptive scoring for ranking results. From the DB point of view, EASE provides an efficient algorithmic basis for scalable top-k-style processing of large amounts of heterogenous data for the discovery of rich structural relationships. It works by employing an adaptive, efficient and novel index beyond the inverted index. From the IR viewpoint, EASE integrates an effective ranking mechanism to improve search effectiveness.</p><p>In our approach, we model unstructured, semi-structured and structured data as graphs, with nodes being documents, elements and tuples respectively, and edges being hyper-links, parent-child relationships (or IDREFS) and primaryforeign-key relationships respectively. We enable efficient keyword queries on these heterogenous data by summarizing, clustering the graphs and constructing graph indices. To facilitate efficient keyword-based query processing, we examine the issues of indexing and ranking to improve search quality. To the best of our knowledge, this is the first attempt to efficiently and adaptively process keyword queries on such heterogenous data, and also the first work to propose the novel graph index, which is efficient in identifying rich structural relationships.</p><p>Our contributions in this paper are as follows:</p><p>• We model unstructured, semi-structured and structured data as graphs and propose an efficient keyword search method, EASE, to adaptively process keyword queries over the heterogenous data. We devise an effective graph index as opposed to the inverted index, to improve search efficiency and effectiveness. • We propose a novel ranking mechanism for effective keyword search by taking into account both the structural compactness of answers from the DB viewpoint and the textual relevancy from the IR point of view. • We examine the issues of indexing and ranking, and devise a simple and yet efficient indexing mechanism to index the structural relationships between the transformed data. The index is amenable to the deployment of existing top-k ranking methods. • We have conducted an extensive performance study using real datasets and various queries with different characteristics. The results show that EASE achieves both high search efficiency and accuracy, and outperforms existing state-of-the-art methods.</p><p>The rest of this paper is organized as follows. We present the r-radius Steiner graph problem in Section 2. Section 3 introduces a novel graph index. We present a novel scoring function in Section 4. We examine the issues of indexing and ranking, and propose an indexing mechanism in Section 5. Extensive experimental evaluations are provided in Section 6. We review the related work in Section 7 and conclude the paper with Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">ADAPTIVE KEYWORD SEARCH MODEL 2.1 Motivation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Unstructured data</head><p>Although many prior studies of keyword search over text documents (e.g., HTML documents) have been proposed, they all produce a list of individual pages as results. In the event that there are no pages that contain all the keywords, they will return pages with some of the input keywords ranked by relevancy. Even if two or more interrelated pages contain all the keywords, the existing methods cannot integrate the pages into one relevant and meaningful answer. For example, to search for conferences covering the topic of "Data Integration" held in "Canada" in 2008, one may issue a keyword query of "Conference 2008 Canada Data Integration" to a search engine such as GOOGLE. As we all know, the venue of SIGMOD 2008 is Canada and "Data Integration" is one of its major research topics. Yet surprisingly, the homepage of SIGMOD 2008 is neither in the top 10 results nor even in the first 100 answers. Why? The reason is that SIGMOD 2008 splits its information into several pages methodically as shown in Figure <ref type="figure">1</ref>(a) and Important date contains the keywords "2008, Conference" while "Data Integration" is contained in the Call For Paper page. Such data lineage problem also persists in most recently proposed community information management platforms <ref type="bibr" target="#b4">[5]</ref>. Consequently, the existing search engines often include a number of false negatives due to the limitation of their models, which take only a list of individual pages as search results but neglect the fact that interrelated pages linked by hyperlinks may be more meaningful. Yet, this is not an ad hoc problem but a ubiquitous one over the Internet. As another example, most researchers organize their homepages according to content, as shown in Figure <ref type="figure">1</ref>(b). Suppose a user searches for professors who teach a specific course and have a specified project, and inputs some keywords. Although there may be no page that contains all input keywords, the page units composed of Homepage, Project and Course of some professors may answer this query meaningfully.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SIGMOD Homepage</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Call For Paper</head><note type="other">Important</note><p>The accuracy and lineage of data have recently received considerable attention, but mainly from a theoretical perspective. While existing studies such as Trio <ref type="bibr" target="#b23">[24]</ref> extend conventional data management by incorporating accuracy and lineage as integral components of both data and queries, few works are link aware to search text documents over the Internet and take into consideration the fact that multiple interrelated pages linked by hyperlinks may be more meaningful. Indeed, the accuracy problem of traditional search engines is ubiquitous over the Internet. This is so because most web sites organize their data systematically and relevant data may be separated into different pages but linked through hyperlinks. Although Li et al. <ref type="bibr" target="#b17">[18]</ref> have proposed a method of retrieving and organizing web pages by "Information Unit", they model the problem of retrieving web pages as the minimum-weighted group Steiner tree problem, which is an NP-hard problem. It is rather difficult to identify Steiner trees over large graphs. Also, their method employs a heuristic method to identify the top-k answers, and it may fall into the local optimal point and fail to reach the global optimum. In this paper, we propose an effective search method, EASE, to address the problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Semi-structured, Structured and Graph Data</head><p>Traditional studies of keyword search over semi-structured data always compute LCAs (lowest common ancestors) or its variants <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b27">28]</ref> of content nodes which directly contain input keywords and take the subtrees rooted at LCAs as answers. However, the problem as to which subtrees are more meaningful for answering the keyword queries remains open. This is because it is not a straightforward task to decide which subtrees with meaningful and complementary elements besides the content nodes should be used as results in order to meaningfully expand their answerability.</p><p>Prior works <ref type="bibr" target="#b1">[2]</ref> of keyword search over structured data always identify connected trees with minimal cost in the labeled graph as answers. Called Steiner trees, they have nodes which are tuples in the database and links which are primary-foreign-key relationships. The trees are identified with the use of an approximation to the Steiner tree problem. However, it is fairly difficult to extract all the Steiner trees in a large graph, which is NP-hard <ref type="bibr" target="#b1">[2]</ref>. Moreover, the Steiner tree problem is difficult to adapt for complicated graph databases <ref type="bibr" target="#b9">[10]</ref>, e.g., complex biological databases, as it only discovers simple tree structures but cannot identify the more meaningful graph structures with rich structural relationships, such as circles. Although Guo et al. <ref type="bibr" target="#b9">[10]</ref> have proposed data topology search to improve search effectiveness, their method is constrained by the input of only two keywords.</p><p>Traditionally, the inverted index is employed to answer keyword queries. It has been shown to be effective for text and document-based retrieval. However, it is inadequate for supporting keyword queries over structured, semi-structured and graph data because it is fairly difficult to identify the "best" answers that capture rich structural relationships through the inverted index. To address the above-mentioned issues, we propose an effective graph index to improve search performance in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">r-Radius Steiner Graph Problem</head><p>EASE models unstructured data (e.g., text documents), semi-structured data (e.g., XML databases) and structured data (e.g., relational databases) as graphs, where the nodes are respectively documents, elements and tuples, and the edges are respectively hyperlinks * , parent-child relationships (or IDREFS) and primary-foreign-key relationships. The advantage is obvious as EASE addresses the problem of keyword search over graph data. We now formally define the problem of modeling heterogenous data as graphs.</p><p>Inspired by the Steiner tree problem <ref type="bibr" target="#b1">[2]</ref>, we introduce the Steiner graph problem. However, graphs with a larger diameter (which is defined as the longest distance between any two nodes in a graph) are not so meaningful and relevant to queries as users are generally frustrated by large and complex graphs. Consequently, we introduce the rradius Steiner graph problem, which is a more interesting and challenging problem of identifying meaningful Steiner graphs with acceptable sizes. To formally describe this problem, we first present several concepts as follows.</p><p>Definition 1. ( Centric Distance) Given graph G and any node v in G, the centric distance of v, denoted as CD(v), is the maximal value among the distances between v and any node u in G, i.e., CD(v)=maxu∈G{D(v, u)}, where D(v, u) denotes the distance between v and u, i.e., the length of the shortest path between v and u. * There may be a large number of hyperlinks among pages on the Web; however, to extract more meaningful and relevant answers, we can only consider the hyperlinks between pages in the same domain. Obviously, we can take the r-radius graphs that contain all or a portion of the input keywords as answers, as the r-radius graphs are very compact and meaningful, and also contain some relevant and complementary nodes for expanding their answerability. Moreover, r-radius Steiner graphs are more concise since non-Steiner nodes are excluded. Although we can take either r-radius graphs or r-radius Steiner graphs as answers of keyword search over graph data, we adopt the latter option in this paper.</p><p>However, it is very difficult to identify all r-radius Steiner graphs from a large graph, and hence, we will introduce an effective index later to improve the efficiency of extracting rradius Steiner graphs. Here, to better explain our proposal, we give a running example as described in Example 1.  <ref type="table" target="#tab_0">1</ref>. We model it to a graph G as illustrated in Figure <ref type="figure">2</ref>. D(a1,a3)=4, CD(p2)=5 and R(G)=4. Given a query " IR,Hristidis" on the database in Table <ref type="table" target="#tab_0">1</ref>, we compute the Steiner graph composed of p4,p5 and a3 with associated edges between them as an answer. This differs from the Steiner tree (i.e., p5-a3) of prior studies, which can cause the loss of meaningful information, especially in databases with complicated structures.</p><p>We now formally state the r-radius Steiner graph problem for identifying the most relevant subgraphs with acceptable sizes to answer keyword queries over graph data.</p><p>The r-Radius Steiner Graph Problem: Given a graph G and an input keyword query K, the r-Radius Steiner Graph Problem is to find all the r-radius Steiner graphs in G, which contain all or a portion of the input keywords in K, ranked by relevancy with K.</p><p>As users are usually interested in the top-k answers, we mainly discuss how to identify top-k r-radius Steiner graphs with the highest scores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">EASE: AN ADAPTIVE SEARCH METHOD</head><p>The efficiency and advantages of using inverted indices for facilitating the computation of the "best" answers for online keyword queries are well recognized. However, the inverted indices are not effective for discovering the much richer structural relationships existing in databases with complicated structures <ref type="bibr" target="#b9">[10]</ref>. It is therefore important to be able to efficiently and effectively discover these structural relationships, and index them for fast and accurate response. Intuitively, a straightforward way is to enumerate all the combinations of keywords, compute the corresponding rradius Steiner graphs for each combination, and index these graphs. However, it is prohibitively expensive to discover all these structures since the number of combinations of all keywords in real databases is very large.</p><p>Consequently, we propose an effective strategy to discover a portion of the r-radius graphs such that the number of which is proportional to the number of nodes in the graph, and we only need to index and materialize these graphs. More importantly, all of the r-radius graphs can be effectively identified through the indexed ones. In a later section, we will address the issue of extracting r-radius Steiner graphs on the fly by removing non-Steiner nodes from the corresponding indexed r-radius graphs.  </p><formula xml:id="formula_0">(a) M a1 p1 a2 p2 p3 p4 a3 p5 a4 p6 p7 a5 a1 1 1 0 1 0 0 0 0 0 0 0 p1 1 1 1 1 0 0 0 0 0 0 0 a2 0 1 1 0 0 0 0 0 0 0 0 p2 1 1 0 1 1 0 0 0 0 0 0 p3 0 0 0 1 1 1 0 0 0 0 0 p4 0 0 0 0 1 1 1 1 0 0 0 a3 0 0 0 0 0 1 1 1 0 0 0 p5 0 0 0 0 0 1 1 1 1 1 0 a4 0 0 0 0 0 0 0 1 1 1 1 p6 0 0 0 0 0 0 0 1 1 1 0 p7 0 0 0 0 0 0 0 0 1 0 1 a5 0 0 0 0 0 0 0 0 0 1 0 (b) M 2 a1 p1 a2 p2 p3 p4 a3 p5 a4 p6 p7 a5 a1 1 1 1 1 1 0 0 0 0 0 0 p1 1 1 1 1 1 0 0 0 0 0 0 a2 1 1 1 1 0 0 0 0 0 0 0 p2 1 1 1 1 1 1 0 0 0 0 0 p3 1 1 0 1 1 1 1 1 0 0 0 p4 0 0 0 1 1 1 1 1 1 1 0 a3 0 0 0 0 1 1 1 1 1 1 0 p5 0 0 0 0 1 1 1 1 1 1 1 a4 0 0 0 0 0 1 1 1 1 1 1 p6 0 0 0 0 0 1 1 1 1 1 1 p7 0 0 0 0 0 0 0 1 1 1 1 a5 0 0 0 0 0 0 0 1 1 1 0 p3 p4 p1 p2 a1 a4 a2 p3 p1 p2 a1 a4 a2 G 2 p1 G 2 p2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Adjacency Matrix</head><p>In order to efficiently extract r-radius graphs from a given graph G(R(G)≥r) † , we introduce the concept of Adjacency Matrix, M=(mij)n×n, with respect to G, which is an n×n boolean matrix. In M, the element mij is 1, iff, there is an edge between vi and vj in G, i.e., vi 1 vj , where vi(vj) denotes the node at the i-th(j-th) row or column in M while vi d vj denotes that there is a path between vi and vj with distance no larger than d; otherwise, mij is 0 (mii is always 1). Iteratively, m r ij =1, iff, vi r vj , where</p><formula xml:id="formula_1">M r = r M × • • • × M=(m r ij )n×n.</formula><p>To ease the discussion that follows, we summarize the notation we use in Table <ref type="table" target="#tab_3">2</ref>. M r is said to be the r-th power of M. N r i ={vj |M r ij =1} is the set of nodes which have a path to vi with distance no larger than r. G r i denotes the subgraph of G with respect to the i-th row of M r , which is composed of the nodes in N r i and the associated edges. G r v i (N r v i ) can be interchangeably employed instead of G r i (N r i ) if there is no ambiguity. We use Gi¢Gj to denote that Gi is a subgraph of Gj (equivalently, † Without loss of generality, we suppose G is a connected graph, the radius of which is no smaller than r, i.e., R(G)≥r. Even if G is an unconnected graph, we can decompose it into a set of connected graphs and thus EASE can adapt to the unconnected graphs.</p><p>Gj is also called a super-graph of Gi). Gi Gj denotes that Gi is a proper subgraph of Gj, i.e., Gi Gj and Gi =Gj. |G| denotes the number of nodes in G.</p><p>Example 2. We can construct the adjacency matrix of the graph in Figure <ref type="figure">2</ref> as illustrated in Table <ref type="table" target="#tab_4">3</ref>. We note that v1=a1, v2=p1, v3=a2 and v4=p2. <ref type="figure" target="#fig_1">3</ref>. To effectively extract r-radius graphs according to the adjacency matrix, we provide Lemma 1 to help determine the subgraphs in G that are r-radius graphs.</p><formula xml:id="formula_2">N 2 2 =N 2 p 1 ={a1,p1, a2,p2,p3} and N 2 4 =N 2 p 2 ={a1,p1,a2,p2,p3,p4}. The two sub- graphs G 2 2 (G 2 p 1 ) and G 2 4 (G 2 p 2 ) are illustrated in Figure</formula><formula xml:id="formula_3">Lemma 1. Given a graph G(R(G)≥r&gt;1), ∀i,1≤i≤|G|, G r v i is an r-radius graph, if, ∀v k ∈N r v i , N r v i ⊆N r-1 v k . Proof.</formula><p>As all the nodes in N r v i connect to vi and all the nodes with distances no larger than r to vi are in N r v i , the nodes in N r v i and the edges associated with them can construct a subgraph of G, G r v i . We need to prove R(G r v i )=r. We first prove that R(G r v i )≤r. ∀u∈N r v i , D(vi, u)≤r according to the definition of M r , and thus CD(vi)=maxu∈Gr v i {D(vi, u)}≤r. Hence, based on</p><formula xml:id="formula_4">Definition 2, we have R(G r v i )=minv∈Gr v i {CD(v)}≤CD(vi)≤r.</formula><p>We then prove that R(G r v i )≥r.</p><formula xml:id="formula_5">∀v k ∈N r v i , as N r v i ⊆N r-1 v k , there must exist a node u k , u k ∈N r v i and u k / ∈N r-1 v k , thus D(v k , u k )≥r (otherwise, if D(v k , u k )&lt;r, u k ∈N r-1 v k , which contradicts u k / ∈N r-1 v k ). Thus, ∀v k ∈N r v i , we have CD(v k )=maxu∈Gr v i {D(v k , u)}≥D(v k , u k )≥r in G r v i . Accordingly, R(G r v i )=minv k ∈G r v i {CD(v k )}≥r. Therefore, R(G r v i )=r and G r v i is an r-radius graph.</formula><p>As formalized in Lemma 1, we can determine whether the subgraph G r v i with respect to the i-th row of M r is an rradius graph. For example, G 2 p 2 is a 2-radius graph while G 2 a 2 is not as N 2 a 2 ⊆N 1 p 1 as shown in Table <ref type="table" target="#tab_4">3</ref>. In order to extract all of the r-radius Steiner graphs from G, we must prove that any r-radius Steiner graph in G corresponds to a subgraph G r v i , and we provide Theorem 1 for extracting r-radius Steiner graphs.</p><p>Theorem 1. Suppose {SG r 1 ,SG r 2 ,...,SG r p } is the set of the r-radius Steiner graphs with respect to a graph G(R(G)≥r) and a keyword query, ∀1≤j≤p, ∃1≤i≤|G|, SG r j ¢ G r v i holds. Proof. ∀SG r j , there must exist a corresponding r-radius graph Gr j according to Definition 3, such that SG r j ¢Gr j . We then prove that ∃G r v i , Gr j ¢G r v i . As Gr j is an r-radius graph, there must exist a node vi∈Gr j and CD(vi)=r. Since for any node u∈Gr j , D(vi, u)≤r, thus u must be in the node set of G r v i (i.e., N r v i ) according to the definitions of G r v i and M r . Hence, all the nodes in Gr j must be in G r v i . Thus, Gr j ¢G r v i . Hence, SG r j ¢Gr j ¢G r v i .</p><p>Based on Theorem 1, we can extract r-radius Steiner graphs through the adjacency matrix. To facilitate efficient retrieval of r-radius graphs, we construct a novel graph index. The entries of the graph index are terms contained in the graph and each entry preserves the r-radius graphs that contain the term. To construct the graph index, we first extract r-radius graphs as stated in Lemma 1, then for each term ki, we keep the set of all r-radius graphs that contain ki, denoted as</p><formula xml:id="formula_6">I k i , i.e., I k i ={G r v j |G r v j contains ki}.</formula><p>To process a keyword query K={k1,k2,...,km}, we first retrieve the set I k i of those r-radius graphs which contain ki based on the graph index, and then union every I k i to compute ∪ m i=1 I k i , which is the set of r-radius graphs that contain all or a portion of the keywords in K ‡ . Finally, we extract the r-radius Steiner graphs by removing the non-Steiner nodes from the corresponding r-radius graphs, and rank the results to return the top-k answers.</p><p>Given an r-radius graph G r and its content nodes, c1,c2,...,cq , which directly contain some of the input keywords, we compute the Steiner nodes and construct the corresponding rradius Steiner graph as follows: i) Compute P(ci), the set of those nodes which have a path to ci in Gi, i.e., P(ci)={u|u ci in Gi}, where Gi is the subgraph of G r , by removing the nodes in {c1,c2,...,ci-1,ci+1,...,cq } and the associated edges. ii) Extract the set of Steiner nodes in G r , P, where P= ∪ q i=1 ∪ q j=i+1 (P(ci)∩P(cj))∪{c1,c2,...,cq }. iii) Construct the r-radius Steiner graph, i.e., the subgraph of G r , which is composed of the nodes in P and the associated edges.</p><p>Example 3. Consider the database described in Table <ref type="table" target="#tab_0">1</ref>, we obtain its adjacency matrix M and compute M r as shown in Table <ref type="table" target="#tab_4">3</ref> (r is set to 2 in the remaining examples throughout this paper). Subsequently, we derive the r-radius graphs, e.g., G r p1 and G r p2 based on the second and fourth rows of M r respectively, which are illustrated in Figure <ref type="figure" target="#fig_1">3</ref>. We note that G r p1 ¡G r p2 . To answer the keyword query " Shanmugasundaram, Guo,XRANK", we first retrieve the r-radius graphs, G r p1 and G r p2 , which contain the three keywords, based on the graph index, and then extract the corresponding r-radius Steiner graphs, i.e., the circled subgraphs as illustrated in Figure <ref type="figure" target="#fig_1">3</ref>, by removing the non-Steiner nodes.</p><p>From Example 3, we observe that some r-radius graphs are contained in others. As a further illustration, we get the following expressions from the graph in Figure <ref type="figure">2</ref></p><formula xml:id="formula_7">: i) G r a2 ¡G r a1 =G r p1 ¡G r p2 ; ii) G r a3 ¡G r p4 ; iii) G r a5 ¡G r p6 =G r a4 ¡G r p5 ; and iv) G r p7 ¡G r p6 =G r a4 ¡G r p5</formula><p>. Consequently, it is sufficient for us just to keep the graphs G r p2 ,G r p3 ,G r p4 and G r p5 in the graph index. We shall address this problem next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Maximal r-Radius Graph</head><p>To avoid maintaining redundant overlapping r-radius graphs in the graph index, we introduce the concept of maximal rradius graph in this section.</p><formula xml:id="formula_8">Definition 4. ( Maximal r-Radius Graph) Given a graph G and an r-radius subgraph G r v i in G, G r v i is called a maximal r-radius subgraph if there is no other r-radius subgraph that contains G r v i .</formula><p>Based on Definition 4, we only need to keep the maximal r-radius graphs in the graph index to minimize storage without affecting the search results. This is because all other r-radius graphs can be reconstructed from their corresponding super-graphs. For example, G r p2 ,G r p3 ,G r p4 and G r p5 are maximal r-radius graphs and will be kept in the graph index while other graphs, e.g., G r p1 and G r a4 , can be reconstructed when necessary.</p><p>In fact, the maximal r-radius graphs can be directly extracted from M r , as captured by Lemma 2 below.</p><formula xml:id="formula_9">Table 4: Graph similarities G r p2 G r p3 G r p4 G r p5 G r p2 1 5/8 3/10 1/6 G r p3 - 1 5/9 4/11 G r p4 - - 1 2/3 G r p5 - - - 1 Lemma 2. Given a graph G(R(G)≥r), ∀i,1≤i≤|G|, G r v i is a maximal r-radius graph if ∀k∈{t|M r it =1,N r t =N r i }, N r i ⊂N r k . Proof. We first prove that G r v i is an r-radius graph. i) ∀k∈{t|M r it =1, N r t =N r i }, as N r i ⊂N r k , there must exist u k , u k ∈N r</formula><p>i and u k ∈N r k , and thus we have</p><formula xml:id="formula_10">D(v k , u k )&gt;r (oth- erwise, if D(v k , u k )≤r, u k must be in N r k , which contradicts u k ∈N r k ). Hence, CD(v k )=maxu∈Gr v i {D(v k , u)}≥D(v k , u k )&gt;r. ii) ∀j∈{t|M r it =1, N r t =N r i }, as R(G)≥r, CD(vj )=r in G r v i . Thus, ∀v k ∈G r v i , CD(v k )≥r and CD(vi)=r. Hence, we have R(G r v i )=minv k ∈G r v i</formula><p>{CD(v k )}=r, and G r v i is an r-radius graph. We then prove that G r v i must be a maximal r-radius graph. As ∀k∈{t|M r it =1, N r t =N r i }, N r i ⊂N r k , there cannot exist another r-radius graph that is a super-graph of G r v i . Thus, G r v i must be a maximal r-radius graph.</p><p>There are still some overlaps between different maximal r-radius graphs. For example, G r p2 and G r p3 both contain the nodes, a1,p1,p2,p3 and p4. To further reduce storage and improve search performance, we introduce a technique for clustering the maximal r-radius graphs in Section 3.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Graph Partitioning</head><p>Conventional Steiner tree based methods <ref type="bibr" target="#b1">[2]</ref> typically need to traverse the graph initializing from the content nodes to identify the Steiner trees with the minimal cost. They have to maintain the whole graph in memory, which is not practical for large graphs. To alleviate the problem, we propose a graph partitioning based method to achieve the needed search efficiency.</p><p>We cluster r-radius graphs so that we can partition the graph to facilitate identifying r-radius graphs. We first cluster the r-radius graphs and then partition the whole graph based on the clusters. Each cluster corresponds to a portion of the graph. Clustering maximal r-radius graphs has the following salient advantages: (i) We only need to maintain a physical graph for each cluster while all the maximal rradius graphs only preserve their nodes instead of the corresponding overlapping graphs. This avoids the incurrence of huge storage, and is similar to the views on top of underlying physical tables in RDBMS, in which clusters correspond to physical tables while maximal r-radius graphs correspond to views. (ii) We only need to retrieve the corresponding relevant graph partitions instead of maintaining the whole graph in order to identify the r-radius graphs.</p><p>To meaningfully cluster r-radius graphs, we first define the similarity between any two graphs and then cluster the maximal r-radius graphs based on their similarities. Definition 5. ( Graph Similarity) Given two maximal r-radius subgraphs G r i and G r j in a given graph, their graph similarity, S(G r i ,G r j ), is</p><formula xml:id="formula_11">|N r i ∩N r j | |N r i ∪N r j |</formula><p>, where N r i and N r j denote the node sets of G r i and G r j respectively. A bigger overlap between the nodes of the two graphs implies a larger graph similarity between them, and consequently, a higher probability that they will be clustered G r p2 + G r p3 (cluster 1) G r p4 + G r p5 (cluster 2) Figure <ref type="figure">4</ref>: Two clusters together. It is obvious that the graph similarity scales well with the number of overlapping nodes. Moreover, given two maximal r-radius subgraphs, employing the number of their overlapping nodes is sound as the edges associated with the overlapping nodes are also the same. In addition, we note that the graph similarity preserves the following properties:</p><p>• Symmetry. S(Gi,Gj)=S(Gj,Gi); • Positivity. 0≤S(Gi,Gj)≤1, for any Gi and Gj; • Reflexivity. S(Gi,Gj )=1 iff Gi=Gj; which indicate that graph similarity is a good metric to evaluate the similarity between any two graphs. Based on the graph similarity, we can now cluster the maximal r-radius subgraphs by employing an existing method such as the Kmean, K-medoids and EM algorithms.</p><p>To effectively compute the graph similarity between two maximal r-radius graphs, we introduce Lemma 3.</p><formula xml:id="formula_12">Lemma 3. Given two maximal r-radius subgraphs w.r.t. M r , G r i and G r j , S(G r i ,G r j ) = |{k|M r ik =1 and M r jk =1}| |{k|M r ik =1 or M r jk =1}| .</formula><p>Following Lemma 3, we can compute the graph similarity based on the adjacency matrix, which is much easier to manipulate than the original graphs.</p><p>Example 4. Consider the database in Table <ref type="table" target="#tab_0">1</ref>, we note that the four graphs G r p2 ,G r p3 ,G r p4 and G r p5 are the maximal r-radius graphs. We can compute their graph similarities as shown in Table <ref type="table">4</ref> based on the adjacency matrix in Table <ref type="table" target="#tab_4">3</ref>. If we cluster the four maximal r-radius graphs into two clusters, G r p2 and G r p3 will fall into the same cluster while G r p4 and G r p5 will be in another cluster as illustrated in Figure <ref type="figure">4</ref>. On the other hand, if we cluster them into three clusters, G r p4 and G r p5 will fall into the same cluster while G r p2 and G r p3 are in the other two clusters respectively.</p><p>To summarize, given a graph, we first obtain its adjacency matrix M and compute M r . We then extract the maximal r-radius graphs according to Lemma 2 and compute the graph similarities between any two maximal r-radius graphs based on Lemma 3. Subsequently, we cluster the graphs by employing the existing K-means algorithm and partition the graph. Finally, we construct the graph index to materialize the maximal r-radius graphs. To illustrate, we consider the example below, which computes the set of r-radius Steiner graphs that contain all or a portion of the input keywords.</p><p>Example 5. Given the database in Table <ref type="table" target="#tab_0">1</ref> and a keyword query " DISCOVER,Relational,Database,Papakonstantinou", we first retrieve the keyword lists based on the graph index (Table <ref type="table">5</ref>). We then derive the set of {G r p 2 ,G r p 3 ,G r p 4 ,G r p 5 },</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 5: Graph index</head><p>Terms r-radius graphs :</p><formula xml:id="formula_13">I k i Database G r p 2 ,G r p 3 ,G r p 4 ,G r p 5 DISCOVER G r p 5 Papakonstantinou G r p 4 ,G r p 5 Relational G r p 3 ,G r p 4 ,G r p 5</formula><p>where each graph contains some input keywords. G r p 5 contains all of the input keywords. Finally, we refine the maximal r-radius graphs on top of the corresponding graph partitions (instead of traversing the whole graph) to obtain the r-radius Steiner graphs. For instance, we can get SG r p 5 by removing the non-Steiner nodes, e.g., p3,p4,a3 and a5, from G r p 5 , as shown in Figure <ref type="figure">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">RANKING FUNCTIONS</head><p>In this section, we first discuss how to meaningfully rank r-radius Steiner graphs and identify the top-k answers based on the existing proposals. Next, we propose a new measure based on the structural compactness between content nodes and the structural relevancy between input keywords with respect to an r-radius Steiner graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">TF • IDF-based IR Ranking</head><p>The basic idea of the ranking method used in the existing literature, such as <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b21">22]</ref>, is to first assign each r-radius graph a score using a standard IR-ranking formula (or its variants), and then combine the individual scores using a score aggregation function, such as SUM, to obtain the final score. For example, the TF•IDF-based IR-style ranking function weights an r-radius Steiner graph by considering textual relevancy in IR literature, which takes into account term frequency (tf), inverse document frequency (idf) and normalized document length (ndl). tf and idf are well employed to rank documents in the IR literature while ndl is used to normalize document length as a longer document has a higher likelihood to contain many more keywords. We can compute the three parameters as follows:</p><formula xml:id="formula_14">ntf (k i ,G) = 1 + ln(1 + ln(1 + tf (k i ,G) )) (<label>1</label></formula><formula xml:id="formula_15">)</formula><formula xml:id="formula_16">idf k i = ln N + 1 N k i + 1 (2) ndlG = (1 -s) + s * tlG avg tl (<label>3</label></formula><formula xml:id="formula_17">)</formula><p>where tf (k i ,G) in Equation 1 denotes the term frequency of ki in G; N and N k i in Equation 2 respectively denote the number of maximal r-radius graphs and the number of those maximal r-radius graphs that contain ki. tlG in Equation <ref type="formula" target="#formula_16">3</ref>denotes the total number of terms in G and avg tl is the average number of terms among all such r-radius graphs while s is a parameter taken from IR literature, which has been extensively discussed and typically set to 0.2 <ref type="bibr" target="#b19">[20]</ref>. We combine the three parameters to evaluate the document relevancy between an input keyword ki and a given Steiner graph SG, denoted as ScoreIR(ki, SG) as formalized in Equation <ref type="formula" target="#formula_22">4</ref>, where G is the corresponding r-radius graph w.r.t. SG § .</p><formula xml:id="formula_18">ScoreIR(ki, SG) = ntf (k i ,G) * idf k i ndlG (4)</formula><p>Based on the textual relevancy of ki in SG, we compute the overall score between an input keyword query K and SG by summing up ScoreIR(ki, SG), as shown in Equation <ref type="formula" target="#formula_20">5</ref>. </p><formula xml:id="formula_19">§ ntf (k i ,SG) =ntf (k i ,G) ; tf (k i ,SG) =tf (k i ,G) for each input keyword ki.</formula><p>Although the TF•IDF-based ranking methods are efficient for textual documents, they are inefficient for semi-structured and structured data. From the IR perspective, traditional textual relevancy is important. However, due to our use of graph in modeling, the ranking of graph data becomes equally if not more important, and the structural compactness of r-radius Steiner graphs is the essence of the comparison. This is so because identifying rich structural relationships should be at least as important as discovering more keywords, and in some cases, even more crucial. Therefore, we propose a novel ranking function by incorporating structural compactness from the DB point of view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Structural Compactness-based DB Ranking</head><p>Intuitively, when an r-radius Steiner graph SG is more compact, SG is more likely to be meaningful and relevant. Accordingly, the structural compactness score should be larger. As such, the compactness of SG should include the following parameters: i) the structural compactness between content nodes in SG, and ii) the structural relevancy between input keywords w.r.t. SG. We note that when the length of a path between two content nodes is larger, the relevancy between them is smaller. Further, there may be multiple paths between two content nodes, and we should consider all of them. Based on the above rationale, we propose Equation <ref type="formula" target="#formula_21">6</ref>to score the overall structural compactness between any two content nodes:</p><formula xml:id="formula_21">Sim(ni, nj ) = n i n j 1 (|ni nj| + 1) 2<label>(6)</label></formula><p>where </p><formula xml:id="formula_22">(a4, p5)= Sim G 2 p 5 (a4, p5)= 1 (<label>|a4</label></formula><formula xml:id="formula_23">p5|+1) 2 + 1 (|a4<label>p6</label></formula><formula xml:id="formula_24">p5|+1) 2 = 1 4 + 1 9 = 13 36 .</formula><p>Lemma 4. Given an r-radius graph G and its corresponding Steiner graph SG with respect to a given keyword query, the following equation holds:</p><p>SimG(ni, nj ) = SimSG(ni, nj ) where ni and nj are any two content nodes in SG.</p><p>Proof. Note that if there is a path from ni to nj in G, there must be a similar path in SG and vice versa based on Definition 3. Thus, SimG(ni, nj )=SimSG(ni, nj ).</p><p>Although the structural compactness between two content nodes can measure the structural relevancy of r-radius graphs, it cannot evaluate the structural relevancy among input keywords, which captures the phrase-based relevancy between input keywords. It follows that a smaller distance between input keywords indicates a higher structural relevancy between them. This is particularly so for keywords in the same node that will represent a phrase. We therefore propose Equation <ref type="formula">7</ref>to capture this parameter.</p><formula xml:id="formula_25">Sim(&lt; ki, kj &gt; |SG) = 1 |C k i ∪ C k j | n i ∈C k i ; n j ∈C k j</formula><p>Sim(ni, nj) <ref type="bibr" target="#b6">(7)</ref> where C k i denotes the set of all the content nodes that contain ki in SG, and |C k i | denotes the number of nodes in C k i , which is used to normalize the structural relevancy between two input keywords. Consequently, a larger overall structural compactness score of SG indicates that SG is more likely to be relevant and meaningful to K.</p><p>We note that the structural relevancy between input keywords has a salient feature that if Sim(&lt;ki,kt&gt;|SG) and Sim(&lt;kt,kj &gt;|SG) are large, Sim(&lt;ki,kj&gt;|SG) must be also large and thus ki,kj and kt must be very relevant to each other w.r.t. SG. Thus, a key feature of structural relevancy is that we can use the structural relevancy between any two input keywords to capture the relevancy between all of the input keywords as illustrated in Equation <ref type="formula">8</ref>. This feature can help capture the rich structural information of SG while the textual relevancy in Equation 5 cannot. Formally, given a keyword query K={k1,k2,...,km} and an r-radius Steiner graph SG, the overall structural compactness of SG w.r.t. K, denoted as ScoreDB(K,SG), can be computed as follows:</p><formula xml:id="formula_26">ScoreDB(K, SG) = 1≤i&lt;j≤m Sim(&lt; ki, kj &gt; |SG) (8)</formula><p>By taking into account both document relevancy from the IR perspective and structural compactness/relevancy from the DB perspective to capture structural relationships, we present a more accurate function for scoring r-radius Steiner graphs as given in Equation <ref type="formula">9</ref>.</p><formula xml:id="formula_27">Score(K, SG) = 1≤i&lt;j≤m Score(&lt; ki, kj &gt; |SG) (9)</formula><p>where Score(&lt; ki, kj &gt; |SG) =Sim(&lt; ki, kj &gt; |SG) * (ScoreIR(ki, SG) + ScoreIR(kj, SG)) <ref type="bibr" target="#b9">(10)</ref> Score(&lt;ki, kj&gt;|SG) measures the overall relevancy score of &lt;ki, kj &gt; in SG based on the structural compactness/relevancy and IR scores. Note that, Sim(&lt;ki, kj&gt;|SG) is taken as the weight of the sum of two IR scores, i.e., ScoreIR(ki, SG) and ScoreIR(kj , SG). A larger Sim(&lt;ki, kj &gt;|SG) means that ki and kj are more relevant w.r.t. SG, and thus, the overall score of &lt;ki, kj &gt; in SG is expected to be larger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">INDEXING</head><p>To efficiently identify the top-k answers with the highest scores, we examine the issues of indexing in this section.</p><p>Given any two keywords ki and kj in the graph, and an r-radius graph SG, the scores of ScoreIR(ki,SG) and ScoreIR(kj ,SG) in Equation <ref type="formula" target="#formula_22">4</ref>and Sim(&lt;ki, kj &gt;|SG) in Equation 7 share the key feature that they can be pre-computed and materialized off-line. Based on this observation, we can materialize Score(&lt;ki, kj&gt;|SG). </p><formula xml:id="formula_28">&lt;• • • , • • • &gt; • • •</formula><p>We devise an extended inverted index (EI-Index) to maintain such scores. Different from the traditional inverted index, the entries of EI-Index are keyword pairs (combinations of two keywords), and the values of each entry is the maximal r-radius graphs that contain the keyword pair and the corresponding scores. For example, we can construct the EI-Index of the graph in Figure <ref type="figure">2</ref> as illustrated in Table <ref type="table" target="#tab_6">6</ref>.</p><p>To answer a keyword query K={k1,k2,• • • ,km}, we first retrieve the maximal r-radius graphs for each keyword pair &lt;ki, kj &gt; according to EI-Index, and then compute the scores of every relevant maximal r-radius graph according to Equation 9. Finally, we rank the results and return the top-k r-radius Steiner graphs with the highest scores by refining the corresponding r-radius graphs.</p><p>For example, recall the query "DISCOVER, Relational, Database,Papakonstantinou" in Example 5. We first retrieve the relevant maximal r-radius graphs based on EI-Index and compute the corresponding overall scores. We then rank them based on such scores, i.e., G5, G4, G3. Finally, we identify the r-radius Steiner graphs on top of the corresponding graph partitions.</p><p>However, this method needs to first compute the scores for all relevant maximal r-radius graphs and then rank them. This leads to low efficiency in the presence of large numbers of r-radius Steiner graphs. To alleviate the problem, we introduce an effective technique of progressively identifying the top-k answers. Note that there are many studies of effectively retrieving top-k answers from multiple inverted lists, such as Fagin Algorithm (FA) <ref type="bibr" target="#b6">[7]</ref> and Threshold Algorithm (TA) <ref type="bibr" target="#b7">[8]</ref>. We can employ such techniques to identify the top-k answers on top of our EI-Index as follows: Given a keyword query K={k1, k2, • • • , km}, we can retrieve the inverted lists composed of relevant r-radius graphs and corresponding scores for every keyword pair according to our EI-Index. Then, we adopt existing algorithms to progressively identify the top-k answers. The advantage of our approach is obvious -we need not discover the structural relationships by traversing the whole graph. Instead, we first materialize such rich relationships into our EI-Index off-line, and then identify the top-k answers according to EI-Index online.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXPERIMENTAL STUDY</head><p>We have designed and performed a comprehensive set of experiments to evaluate the search performance of EASE. We employed the datasets of DBLife ¶ , DBLP and IMDB * * to evaluate EASE on unstructured, semi-structured and structured data respectively. There were about 10,000 pages in the DBLife dataset, and the raw file of DBLP was about 400MB. IMDB contained about one million anonymous ratings of approximately 3900 movies made by 6040 users. All datasets were deposited as per submission requirement. </p><formula xml:id="formula_29">Q 5 Q 4 Q 3 Q 2 Q 1 Elapsed Time(ms) (a) Queries (Unstructured)</formula><p>InfoUnit EASE 1 10 100 1000 10000  The experiments were conducted on an Intel(R) Core(TM) 2.0GHz computer with 2GB of RAM running Windows Vista, and the algorithms were implemented in Java. We used MYSQL 5.0.45 † † to maintain the graph index. We employed the threshold algorithm <ref type="bibr" target="#b7">[8]</ref> to progressively identify the topk answers based on the EI-Index. We compared our approach with existing state-of-the-art approaches. For the unstructured data, we compared EASE with DBLife <ref type="bibr" target="#b4">[5]</ref> by submitting keyword queries to its interface and InfoUnit <ref type="bibr" target="#b17">[18]</ref>. For the semi-structured data, we compared EASE with SLCA <ref type="bibr" target="#b27">[28]</ref> while for structured data, we compared it with DPBF <ref type="bibr" target="#b5">[6]</ref>. We selected 20 queries as illustrated in Table <ref type="table" target="#tab_7">7</ref> for testing different aspects of search problems such as the ability of the methods in capturing data lineage and relationships, and their search accuracy.</p><formula xml:id="formula_30">Q 10 Q 9 Q 8 Q 7 Q 6 Elapsed Time(ms) (b) Queries (Semi-structured) SLCA EASE</formula><p>The graph w.r.t. DBLife contains about 10,000 nodes, which are far fewer than the approximate 1,000,000 nodes of IMDB and 12,000,000 nodes of DBLP. Note that the graph † † http://dev.mysql.com/downloads/mysql/5.0.html w.r.t. IMDB is much denser than that of DBLP, which in turn is denser than that of DBLife. The elapsed time of indexing DBLife, IMDB and DBLP is respectively 13, 25 and 87 minutes. The sizes of the graph indices of DBLife, IMDB and DBLP are respectively 128MB, 96MB and 922MB, compared with the data sizes of 131MB, 30MB and 405MB. The graph index of DBLife is smaller than its data size due to: i) tokenization for removing tags, and ii) its sparser structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Search Efficiency on Different Datasets</head><p>We evaluate the search efficiency of EASE in this section. We tested every algorithm on the selected queries, identified the top-100 results and compared their corresponding elapsed time. Figure <ref type="figure">6</ref> summarizes the experimental results. We observe that EASE always achieves the best performance for various keyword queries and outperforms the other methods significantly on different datasets.</p><p>On unstructured data, InfoUnit identifies Steiner trees by traversing the whole graph to discover structural relationships online, which is not as efficient as our method that materializes rich structural information into the graph indices for facilitating online keyword-based query processing.</p><p>On semi-structured data, SLCA has to first identify all the relevant results, and then ranks them and returns the top-k answers with the highest scores. In contrast, EASE employs the threshold based algorithm <ref type="bibr" target="#b7">[8]</ref> to progressively identify top-k answers and thus produces a dramatic improvement over the existing methods.</p><p>On structured data, although DPBF can progressively compute the top-k answers, it has to discover the structural information between tuples in different relational tables online. At the same time, it also needs to identify the Steiner trees on top of the whole graph. These needs lead to low efficiency. In contrast, EASE first identifies the r-radius graphs based on EI-Index and then constructs rradius Steiner graphs on top of the corresponding graph partitions. These partitions are much smaller than the whole graph, and the method therefore achieves better search performance and outperforms DPBF significantly.</p><p>To better evaluate the selected algorithms, we identified the top-k answers with different values of k and compared the corresponding average elapsed time. Figure <ref type="figure" target="#fig_5">7</ref> illustrates the experimental results obtained. We observe that EASE outperforms the other methods significantly. We note that, with the increase of k values, the elapsed time of InfoUnit </p><formula xml:id="formula_31">Q 20 Q 19 Q 18 Q 17 Q 16</formula><p>Elapsed Time(ms) (a) Queries (Top-100) EASE (Mixed) EASE (DBLife) EASE (DBLP) EASE (IMDB) Elapsed Time(ms) (b) Top-k EASE (Mixed) EASE (DBLife) EASE (DBLP) EASE (IMDB)</p><p>Figure <ref type="figure">10</ref>: Search efficiency on heterogenous data and DPBF also increases, but the elapsed time of EASE varies only slightly (as SLCA cannot progressively identify answers, its elapsed time also varies little). The elapsed time of InfoUnit and DPBF to return top-100 results is always a little more than that of top-5 while the elapsed time of EASE remains about the same. This is so because we adopt the threshold based technique to progressively identify the top-k answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Search Efficiency on Heterogenous Datasets</head><p>To evaluate the overall performance of EASE on heterogenous data, we mixed the three datasets and tested EASE on the combined data. We constructed the graph index on top of the heterogenous data and employed Q16-Q20 to evaluate the search efficiency of EASE over heterogenous data. To better understand the performance of EASE, we first evaluated the elapsed time of identifying the top-100 answers for every query. We then varied the values of k to evaluate the average elapsed time. We also provide the elapsed time of EASE on different datasets as a baseline to show the search efficiency of EASE over heterogenous data. The results are summarized in Figure <ref type="figure">10</ref>. We can see that EASE is still capable of achieving high search efficiency over heterogenous data and is not much worse off than on homogeneous datasets. That is, even for a large volume of heterogenous data, EASE can still effectively identify the top-k answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Search Accuracy on Different Datasets</head><p>This section evaluates search accuracy, indicating the fraction of relevant results in the approximate answer that are correct. We employed the metric, top-k precision, which measures the ratio of the number of relevant answers among the first k answers with the highest scores of an algorithm to k. Answer relevance is judged from discussions of researchers in our database group. Interested readers can test our algorithm through our deposited demo as per submis-sion requirement. Moreover, to evaluate the search accuracy of the selected algorithms, we identified the top-100 results for every query and compared the corresponding top-100 precision. Figure <ref type="figure">8</ref> illustrates the experimental results obtained. We observe that EASE achieves much higher precision than existing methods such as, DBLife, InfoUnit, SLCA and DPBF on the corresponding datasets.</p><p>On unstructured data, as InfoUnit and EASE integrate relevant pages to answer keyword queries, they achieve much higher precision than DBLife. EASE is better than InfoUnit because EASE employs a ranking mechanism that takes into account both the structural compactness of answers from the DB viewpoint and textual relevancy from the IR viewpoint. On semi-structured data, r-radius Steiner graphs, alongside content nodes, also contain some relevant elements, such as the Steiner nodes, which may expand the answerability. They are more meaningful than the subtrees/path-trees rooted at LCAs (or its variants) of existing methods, which may miss some relevant information. Thus, EASE yields higher precision. On structured data, EASE also outperforms DPBF in that: (i) r-radius Steiner graphs are more meaningful than Steiner trees; and (ii) Again, this is due to the consideration of structural compactness between input keywords in our ranking function.</p><p>For example, consider query Q7. Its answer should be the papers about "Database" and "IR". However, "IR" may appear in the name of an author, and traditional methods such as SLCA cannot distinguish the papers entitled with "Database" and "IR" and the papers with "IR" being a term of the author and "Database" being a term of the title. They may mistakenly take the latter as answers, leading to low search accuracy. As another example, two input keywords may appear in two different authors of a paper, and the conventional methods will mistakenly take the two keywords as an author. EASE ranks the results with structures that are less compact lower. This is done by means of our structural relevancy based ranking method. Hence, EASE achieves much higher precision.</p><p>As users are usually interested in top-k answers, we varied different values of k to evaluate the selected algorithms. The average results of the top-k precision for Q1-Q15 are illustrated in Figure <ref type="figure">9</ref>. As expected, EASE consistently achieved high precision in many queries, which is approximately 10-30% higher than those of InfoUnit, DBLife, DPBF and SLCA. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Search Accuracy on Heterogenous Datasets</head><p>To evaluate the robustness of our algorithm, we evaluate its search accuracy using the heterogenous dataset. We first evaluated search accuracy by identifying the top-100 results on various queries, and then varied different values of k to evaluate the average precision. For a better understanding of our ranking method, we compared EASE employing IR ranking parameters (ref. Equation <ref type="formula" target="#formula_20">5</ref>) with EASE considering both DB and IR (ref. <ref type="bibr">Equation 9)</ref>. Figure <ref type="figure" target="#fig_8">11</ref> summarizes the experimental results. We observe that EASE(DB+IR) consistently achieves much higher accuracy than EASE(IR). This again confirms that TF•IDF based IR ranking cannot capture the structural relationships effectively.</p><p>For example, consider query Q20. Some results on DBLife dataset will obtain higher IR scores than those on IMDB dataset as the term frequencies of some documents on DBLife dataset are larger than those on IMDB dataset. Thus, the IR based ranking method will rank the results on DBLife dataset higher. However, in the IMDB dataset, which is a collection of ratings of movies made by users, the three input keywords can describe the instances of users with occupation of Educator scoring the movies with genres of Romance and Action. Hence, the three keywords are more compact and highly relevant to IMDB dataset. Our DB+IR ranking method considers the structural relevancy and ranks the results on the IMDB dataset higher, and thus achieves much higher precision. This comparison reflects the effectiveness and applicability of our proposed ranking mechanism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Sensitivity of Indexing</head><p>In this section, we evaluate the sensitivity of our indexing method. We first created the indices on top of the DBLife dataset, and then inserted 5% additional new irrelevant data in each step. After each set of insertions, we evaluated EASE on the updated indices by using queries Q1-Q5. Figure <ref type="figure">12</ref> summarizes the effects of insertions on our indexing method. We observe that the search accuracy of EASE does not degrade drastically with the increase of new data. This demonstrates the robustness and scalability of our method with respect to data insertions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>The first area of research related to our work is keyword search over relational databases by identifying Steiner trees. As opposed to the traditional Steiner tree based methods, which identify the structural relationships online, EASE identifies and materializes the rather rich structural relationships so as to improve the online processing of keyword queries.</p><p>DBXplorer <ref type="bibr" target="#b0">[1]</ref>, DISCOVER-I <ref type="bibr" target="#b14">[15]</ref>, DISCOVER-II <ref type="bibr" target="#b12">[13]</ref>, BANKS-I <ref type="bibr" target="#b1">[2]</ref> and BANKS-II <ref type="bibr" target="#b16">[17]</ref> are systems built on top of relational databases. DISCOVER and DBXplorer generate trees of tuples connected through primary-foreign key relationships that contain all of the input keywords. BANKS </p><formula xml:id="formula_32">% % % % % Q 1 Q 2 Q 3 Q 4 Q 5</formula><p>Figure <ref type="figure">12</ref>: Sensitivity of indexing identifies connected trees in a labeled graph by using an approximation of the Steiner tree problem. DISCOVER-II considers the problem of keyword proximity search in terms of disjunctive semantics, as opposed to DISCOVER-I which only considers conjunctive semantics. Kacholia et al. <ref type="bibr" target="#b16">[17]</ref> presented the bidirectional strategy (BANKS-II) to improve the efficiency of keyword search over graph data. However, their method still works by identifying Steiner trees from the whole graph, which is inefficient as it is rather difficult to identify structural relationships through inverted indices.</p><p>Liu et al. <ref type="bibr" target="#b19">[20]</ref> proposed a novel ranking strategy to solve the effectiveness problem for relational databases. It employs phrase-based and concept-based models to improve search effectiveness by introducing IR techniques. More recently, Ding et al. <ref type="bibr" target="#b5">[6]</ref> employed dynamic programming (DPBF) to improve the efficiency of identifying Steiner trees. Guo et al. <ref type="bibr" target="#b9">[10]</ref> proposed data topology search to retrieve meaningful structures from richer structural data, such as complex biological databases. He et al. <ref type="bibr" target="#b11">[12]</ref> proposed a partition-based method to improve search efficiency with a novel BLINKS index. Markowetz et al. <ref type="bibr" target="#b22">[23]</ref> studied the problem of keyword search over relational data streams in a first attempt to answer keyword search over relational data streams. Luo et al. <ref type="bibr" target="#b21">[22]</ref> proposed a new ranking method that adapts state-of-the-art IR ranking function and principles into the ranking trees of joined database tuples. In addition, Yu et al. <ref type="bibr" target="#b28">[29]</ref> studied the problem of relational data source selection in P2P environments by summarizing the relationships between keywords in underlying databases.</p><p>In terms of keyword search over XML documents, the subtrees rooted at the lowest common ancestors (LCAs) of content nodes have been proposed as answers. As an extension of LCA, SLCA, Multiway-SLCA, XSeek and GDMCT have recently been proposed to answer keyword queries over XML documents in <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b20">[21]</ref> and <ref type="bibr" target="#b13">[14]</ref> respectively. SLCA <ref type="bibr" target="#b27">[28]</ref> can avoid the false positives of LCA but it does so at the expense of false negatives. Multiway-SLCA <ref type="bibr" target="#b24">[25]</ref> offers a search paradigm in support of keyword search beyond the traditional AND semantics, including both AND and OR boolean operators. GDMCT <ref type="bibr" target="#b13">[14]</ref> returns grouped connected trees as answers but it still needs to traverse the whole graph to identify answers by employing the inverted index. XSeek <ref type="bibr" target="#b20">[21]</ref> generates return nodes which can be explicitly inferred from keywords or dynamically constructed according to entities in the data that are relevant to the search.</p><p>XRANK <ref type="bibr" target="#b10">[11]</ref> and XSEarch <ref type="bibr" target="#b3">[4]</ref> are systems facilitating keyword search for XML documents, and they return connected subtrees as answers for keyword queries. XRANK presents a ranking method, where for a given tree T containing all the keywords, a score is assigned to T with an adaptation of PageRank for XML documents. XSEarch focuses on semantics and the ranking of results; during execution, it uses an all-pairs interconnection index to check the connectivity between nodes. XKeyword <ref type="bibr" target="#b15">[16]</ref> is a system that offers keyword proximity search over XML documents that conform to an XML schema. However, it needs to compute candidate networks and thus is constrained by schemas. TopX <ref type="bibr" target="#b25">[26]</ref> is a prototype search engine for the ranked retrieval of XML, but it processes XML queries with support for XPath axes but not the more simple keyword queries, and it cannot adapt to relational databases. Graupmann et al. <ref type="bibr" target="#b8">[9]</ref> presented the SphereSearch engine to provide unified ranked retrieval on heterogeneous XML and Web data. However, it is orthogonal to our method in that: i) it does not support relational databases and it transforms HTML documents into XML, and ii) it depends on its own query language to discover structural relationships and thus is not a pure keyword based search method. Chaudhuri, Ramakrishnan and Weikum <ref type="bibr" target="#b2">[3]</ref> point out a number of interesting research opportunities for integrating DB and IR technologies. In <ref type="bibr" target="#b26">[27]</ref>, Weikum provides a summary of the existing DB and IR techniques and discusses the difficulties, opportunities and challenges of combining DB and IR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>In this paper, we have proposed an efficient and adaptive keyword search method, EASE, to answer keyword queries over unstructured, semi-structured and structured data. EASE seamlessly integrates the efficient query evaluation of DB and the adaptive scoring models of IR for the ranking of results. EASE models heterogenous data as graphs and processes keyword queries on the graphs. To the best of our knowledge, this is the first attempt to efficiently and adaptively process keyword queries on heterogenous data. We have proposed summarizing and clustering the graphs, and devised effective graph indices to materialize structural relationships for fast and accurate response. To facilitate efficient keyword-based query processing, we have examined the issues of indexing and ranking by taking into account both the structural compactness of r-radius graphs from the DB point of view and textual relevancy from the IR viewpoint. Finally, we have conducted an extensive performance study to evaluate the efficiency and effectiveness of our approach using real datasets. The experimental results show that EASE achieves both high search efficiency and quality for keyword search over heterogenous data, and significantly outperforms the existing methods. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">ACKNOWLEDGEMENT</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">REPEATABILITY ASSESSMENT RESULT</head><p>All the results in this paper were verified by the SIGMOD repeatability committee. Code and data used in the paper are available at http://www.sigmod.org/codearchive/sigmod2008/.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure 1: Homepages</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Two 2-radius graphs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>5 (b) SG 2 p 5 Figure 5 : G 2 p 5 and SG 2 p 5</head><label>5555</label><figDesc>Figure 5: G 2 p 5 and SG 2 p 5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 6: Search efficiency on various queries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Figure 8: top-100 precision on various queries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Search accuracy on heterogenous data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Inserted Data/Original Data (Top-100)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>The research of B.C. Ooi was in part funded by NUS Grant R-252-000-338-112. This work is in part supported by the National Natural Science Foundation of China under Grant No.60573094, the National High Technology Development 863 Program of China under Grant No.2007AA01Z152 and 2006AA01A101, the National Grand Fundamental Research 973 Program of China under Grant No.2006CB303103.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : A publication database</head><label>1</label><figDesc></figDesc><table><row><cell cols="2">Authors Schema</cell><cell>AID</cell><cell cols="2">Author-Paper</cell><cell>PID</cell><cell cols="2">Papers</cell><cell>PID</cell><cell>Paper-Reference</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>citedPID</cell></row><row><cell cols="2">Authors</cell><cell></cell><cell></cell><cell cols="4">Paper-Reference Author-Paper</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>AID</cell><cell>PID</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>a1</cell><cell>p1</cell></row><row><cell>AID</cell><cell></cell><cell></cell><cell>Name</cell><cell></cell><cell></cell><cell>PID</cell><cell>citedPID</cell><cell>a1</cell><cell>p2</cell></row><row><cell>a1</cell><cell cols="5">J. Shanmugasundaram</cell><cell>p1</cell><cell>p2</cell><cell>a2</cell><cell>p1</cell></row><row><cell>a2</cell><cell></cell><cell cols="2">L. Guo</cell><cell></cell><cell></cell><cell>p2</cell><cell>p3</cell><cell>a3</cell><cell>p4</cell></row><row><cell>a3</cell><cell></cell><cell cols="3">V. Hristidis</cell><cell></cell><cell>p3</cell><cell>p4</cell><cell>a3</cell><cell>p5</cell></row><row><cell>a4</cell><cell cols="4">Y. Papakonstantinou</cell><cell></cell><cell>p4</cell><cell>p5</cell><cell>a4</cell><cell>p5</cell></row><row><cell>a5</cell><cell></cell><cell cols="3">A. Balmin</cell><cell></cell><cell>p5</cell><cell>p6</cell><cell>a4</cell><cell>p6</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>a4</cell><cell>p7</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>a5</cell><cell>p6</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Papers</cell></row><row><cell>PID</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Title</cell></row><row><cell>p1</cell><cell></cell><cell></cell><cell cols="5">Topology Search over Biological Databases</cell></row><row><cell>p2</cell><cell cols="7">XRANK: Ranked Keyword Search over XML Documents</cell></row><row><cell>p3</cell><cell></cell><cell cols="6">Bidirectional Expansion for Keyword Search on Graphs</cell></row><row><cell>p4</cell><cell></cell><cell cols="6">Finding top-k Answers in Keyword Proximity Search</cell></row><row><cell>p5</cell><cell cols="7">Efficient IR-Style Keyword Search over Relational Databases</cell></row><row><cell>p6</cell><cell></cell><cell></cell><cell cols="5">Keyword Proximity Search on XML Graphs</cell></row><row><cell>p7</cell><cell></cell><cell cols="6">DISCOVER: Keyword Search in Relational Databases</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>p3</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">p1</cell><cell>p2</cell><cell>p4</cell><cell>p5</cell><cell>p6</cell><cell>p7</cell></row><row><cell></cell><cell></cell><cell>a1</cell><cell>a4 a2</cell><cell></cell><cell>a3</cell><cell></cell><cell>a4</cell><cell>a5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Figure 2: The graph model for the publication database in Table 1</head><label></label><figDesc></figDesc><table><row><cell>Definition 2. ( Radius) The radius of a graph G, de-</cell></row><row><cell>noted as R(G), is the minimal value among the centric dis-</cell></row><row><cell>tances of every node in G, i.e., R(G)=minv∈G{CD(v)}. G</cell></row><row><cell>is called an r-radius graph if the radius of G is exactly r.</cell></row><row><cell>Definition 3. ( r-Radius Steiner Graph) Given an r-</cell></row><row><cell>radius graph G</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>and a keyword query K. Node ω in G is called a content node if ω directly contains some input keywords in K. Node s in G is called a Steiner node if there exist two content nodes, u and v, and s is on the path u v (s may be u or v), where u v denotes a path between u and v. The subgraph of G composed of the Steiner nodes and associated</head><label></label><figDesc></figDesc><table><row><cell>edges is called an r-radius Steiner graph. The radius of an</cell></row><row><cell>r-radius Steiner graph may be smaller than r but cannot be</cell></row><row><cell>larger than r.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 : Summary of notation</head><label>2</label><figDesc></figDesc><table><row><cell cols="2">Notation</cell><cell></cell><cell>Descriptions</cell></row><row><cell>G</cell><cell></cell><cell></cell><cell>a graph</cell></row><row><cell cols="2">|G|</cell><cell cols="2">the number of nodes in G</cell></row><row><cell cols="2">SG</cell><cell></cell><cell>a Steiner graph</cell></row><row><cell>K</cell><cell></cell><cell cols="2">an input keyword query</cell></row><row><cell cols="2">M</cell><cell cols="2">the adjacency matrix w.r.t. G</cell></row><row><cell cols="2">M r</cell><cell></cell><cell>the r-th power of M</cell></row><row><cell cols="2">N r i (or N r v i G r i (or G r v i ) )</cell><cell cols="2">{vj |M r ij =1} the subgraph of G composed of the nodes in N r i</cell></row><row><cell>vi</cell><cell>vj</cell><cell cols="2">there is a path between vi and vj</cell></row><row><cell cols="2">D(vi, vj )</cell><cell cols="2">the distance of vi and vj</cell></row><row><cell cols="2">CD(v)</cell><cell></cell><cell>maxu∈G {D(v, u)}</cell></row><row><cell cols="2">R(G)</cell><cell cols="2">the radius of G and R(G)=minv∈G {CD(v)}</cell></row><row><cell>vi</cell><cell>d vj</cell><cell>vi</cell><cell>vj and D(vi, vj )≤d</cell></row><row><cell cols="2">Gi¢Gj</cell><cell cols="2">Gi is a subgraph of Gj (or Gj is a super-graph of Gi)</cell></row><row><cell cols="2">Gi Gj</cell><cell></cell><cell>Gi¢Gj and Gi =Gj</cell></row><row><cell cols="2">S(Gi, Gj )</cell><cell cols="2">the similarity between Gi and Gj</cell></row><row><cell cols="4">Example 1. Consider the database in Table</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 : Adjacency matrix of the graph for the pub- lication databases</head><label>3</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>It is clear that we can compute the overall structural compactness by summing up several materialized scores. For example, in Figure5, Sim SG 2</figDesc><table><row><cell>p 5</cell></row></table><note><p>ni and nj are two content nodes, ni nj is any path between ni and nj , and |ni nj | is the length of ni nj. An important feature of Sim(ni, nj ) is that it can be pre-computed and materialized off-line, based on the fact that SimG(ni, nj )=SimSG(ni, nj ) holds as formalized in Lemma 4 below, where G denotes the corresponding r-radius graph of SG while SimG(ni, nj) and SimSG(ni, nj ) denote the structural compactness between ni and nj in G and SG respectively.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 6 : EI-Index: an extended inverted index</head><label>6</label><figDesc></figDesc><table><row><cell>Keyword Pair</cell><cell>&lt;r-radius Graph, Score&gt;</cell></row><row><cell>&lt;Database, DISCOVER&gt; &lt;Database, Papakonstantinou&gt; &lt;Database, Relational&gt; &lt;DISCOVER, Papakonstantinou&gt; &lt;DISCOVER, Relational&gt; &lt;Papakonstantinou, Relational&gt;</cell><cell>G r p 5 ,1.53 G r p 5 ,0.38; G r p 4 ,0.19 G r p 5 ,0.85; G r p 3 ,0.35; G r p 4 ,0.34 G r p 5 ,0.54 G r p 5 ,1.95 G r p 5 ,0.57; G r p 4 ,0.28</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 7 :</head><label>7</label><figDesc>Queries employed in the experiments (a) Queries on unstructured data (DBLife)</figDesc><table><row><cell>Query ID</cell><cell></cell><cell>Queries</cell></row><row><cell>Q1</cell><cell></cell><cell>2007 Conference Data Integration</cell></row><row><cell>Q2</cell><cell></cell><cell>XML Relational Keyword Search</cell></row><row><cell>Q3</cell><cell cols="2">Turkey Conference 2007 Uncertainty Fuzziness</cell></row><row><cell>Q4</cell><cell cols="2">Berkeley Phone Dataspaces Information Management</cell></row><row><cell>Q5</cell><cell cols="2">Beijing Conference 2007 Data Integration</cell></row><row><cell cols="3">(b) Queries on semi-structured data (DBLP)</cell></row><row><cell cols="2">Query ID</cell><cell>Queries</cell></row><row><cell></cell><cell>Q6</cell><cell>Information Retrieval Database</cell></row><row><cell></cell><cell>Q7</cell><cell>IR Database</cell></row><row><cell></cell><cell>Q8</cell><cell>DB IR XML</cell></row><row><cell></cell><cell>Q9</cell><cell>XML Relational Keyword Search</cell></row><row><cell></cell><cell>Q10</cell><cell>Data Mining Algorithm 2006</cell></row><row><cell cols="3">(c) Queries on structured data (IMDB)</cell></row><row><cell></cell><cell>Query ID</cell><cell>Queries</cell></row><row><cell></cell><cell>Q11</cell><cell>Lethal Weapon 4 academic</cell></row><row><cell></cell><cell>Q12</cell><cell>Police Academy 3 customer</cell></row><row><cell></cell><cell>Q13</cell><cell>Halloween 5 college</cell></row><row><cell></cell><cell>Q14</cell><cell>Love 45 tradesman</cell></row><row><cell></cell><cell>Q15</cell><cell>Robocop 3 college</cell></row><row><cell></cell><cell cols="2">(d) Queries on heterogenous data</cell></row><row><cell cols="2">Query ID</cell><cell>Queries</cell></row><row><cell>Q16</cell><cell></cell><cell>XML Keyword Search 2007</cell></row><row><cell>Q17</cell><cell></cell><cell>Dennis Shasha Database Tuning</cell></row><row><cell>Q18</cell><cell cols="2">Dataspaces 2006 Information Management</cell></row><row><cell>Q19</cell><cell cols="2">Database Indexing Ranking Search</cell></row><row><cell>Q20</cell><cell></cell><cell>Romance Action Educator</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>‡ If we consider "AND" predicate, we merge I k i to compute ∩ m i=1 I k i , which is the set of r-radius graphs that contain all keywords.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>¶ http://dblife.cs.wisc.edu/download/surfaceWeb-2007-07-25.tgz http://dblp.uni-trier.de/xml * * http://www.grouplens.org/node/73 (1,000,000 Data Set(5.73 MB)) http://www.grouplens.org/system/files/million-ml-data.tar 0.gz</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Dbxplorer: A system for keyword-based search over relational databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="5" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Keyword searching and browsing in databases using banks</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bhalotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hulgeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Nakhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="431" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Integrating db and ir technologies: What is the sound of one hand clapping</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Xsearch: A semantic search engine for XML</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mamou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kanza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Dblife: A community information management platform for the database research community</title>
		<author>
			<persName><forename type="first">P</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burdick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Finding top-k min-cost connected trees in databases</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Combining fuzzy information from multiple systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="216" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fuzzy queries in multimedia database systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The spheresearch engine for unified ranked retrieval of heterogeneous XML and web documents</title>
		<author>
			<persName><forename type="first">J</forename><surname>Graupmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schenkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="529" to="540" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Topology search over biological databases</title>
		<author>
			<persName><forename type="first">L</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shanmugasundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Yona</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Xrank: Ranked keyword search over XML documents</title>
		<author>
			<persName><forename type="first">L</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Botev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shanmugasundaram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="16" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Blinks: Ranked keyword searches on graphs</title>
		<author>
			<persName><forename type="first">H</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient ir-style keyword search over relational databases</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="850" to="861" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Keyword proximity search in XML trees</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TKDE</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="525" to="539" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Discover: Keyword search in relational databases</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Keyword proximity search on XML graphs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Balmin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="367" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Bidirectional expansion for keyword search on graph databases</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kacholia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pandit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Karambelkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="505" to="516" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Retrieving and organizing web pages by &apos;information unit</title>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Candan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient Keyword Search for Valuable LCAs over XML Documents</title>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Effective keyword search in relational databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chowdhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Identifying return information for XML keyword search</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Spark: Top-k keyword query in relational databases</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Keyword search on relational data streams</title>
		<author>
			<persName><forename type="first">A</forename><surname>Markowetz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Trio-one: Layering uncertainty and lineage on a conventional dbms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mutsuzaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Keijzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Agrawal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Multiway slca-based keyword search in XML data</title>
		<author>
			<persName><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Y</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Goenka</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An efficient and versatile query engine for topx search</title>
		<author>
			<persName><forename type="first">M</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schenkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Db &amp; ir: Both sides now (keynote)</title>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Efficient keyword search for smallest lcas in XML databases</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="527" to="538" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Effective keyword-based selection of relational databases</title>
		<author>
			<persName><forename type="first">B</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sollins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K H</forename><surname>Tung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
