<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Control Flow Checking at Virtual Edges</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2017-01-31">January 31, 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Liping</forename><surname>Liu</surname></persName>
							<email>liuliping_bit@163.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Linlin</forename><surname>Ci</surname></persName>
							<email>cilinlin_bit@126.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wei</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hui</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Control Flow Checking at Virtual Edges</title>
					</analytic>
					<monogr>
						<idno type="ISSN">1976-7277</idno>
						<imprint>
							<date type="published" when="2017-01-31">January 31, 2017</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.3837/tiis.2017.01.021</idno>
					<note type="submission">Received October 2, 2016; revised May 8, 2016; accepted November 29, 2016;</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Trusted computing</term>
					<term>Dynamic measurement</term>
					<term>Control-flow errors</term>
					<term>Error detection</term>
					<term>Virtual edges</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Dynamically checking the integrity of software at run-time is always a hot and difficult spot for trusted computing. Control-flow integrity is a basic and important safety property of software integrity. Many classic and emerging security attacks who introduce illegal control-flow to applications can cause unpredictable behaviors of computer-based systems. In this paper, we present a software-based approach to checking violation of control flow integrity at run-time. This paper proposes a high-performance and low-overhead software control flow checking solution, control flow checking at virtual edges (CFCVE). CFCVE assigns a unique signature to each basic block and then inserts a virtual vertex into each edge at compile time. This together with insertion of signature updating instructions and checking instructions into corresponding vertexes and virtual vertexes. Control flow faults can be detected by comparing the run-time signature with the saved one at compile time. Our experimental results show that CFCVE incurs only 10.61% performance overhead on average for several C benchmark programs and the average undetected error rate is only 9.29%. Compared with previous techniques, CFCVE has the characteristics of both high fault coverage and low memory and performance overhead.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Distributed computing and worldwide business transactions over open networks, such as the Internet, increasingly demand for secure communication and secure operation due to rising online fraud and software attacks <ref type="bibr" target="#b0">[1]</ref>. Some of these vulnerabilities are due to the complexity and architectural constraints of the underlying execution environment (CPU hardware and commodity operating systems), some are due to poor software development practices and lack of software security in applications <ref type="bibr" target="#b1">[2]</ref>. In this context, the integrity of system software and applications is a fundamental requirement and necessary consequence in order to ensure trust in the computing infrastructure <ref type="bibr" target="#b2">[3]</ref>.</p><p>Trusted Computing as proposed by the Trusted Computing Group (TCG) offers a technology that is able to verify the integrity of executable content through remote attestation. The cores of trusted computing technology are trusted computing base and trusted chain <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>, and trusted measurement is a key problem of this technology <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>. Trusted computing treats the integrity as a fundamental attribute of trust. However, such attestation mechanisms provide only integrity verification at load-time but not at run-time: An attacker can change the flow of execution of a program, e.g., via buffer overflow attacks that are despite numerous counter measures still a great security concern in software systems today. Some attacks do not need to inject new code, but instead use code that already exists in the process's memory. Existing protection mechanisms such as marking the stack as non-executable cannot detect this class of attacks because only instructions are executed that reside in valid code pages. Moreover, the new attacks generalize the original return-into-libc attack by allowing the attacker arbitrary computation without calling any functions <ref type="bibr" target="#b7">[8]</ref>. In a traditional return-into libc attack, an attacker could execute only straight-line code without using branching, and could only invoke functions that reside in libc. In the new attacks, an attacker overwrites the stack with return addresses that point to existing code fragments in the program or system libraries.</p><p>SEU-induced soft errors have been known as one of the major threats to functionality and reliability of space-borne computers and their host spacecrafts. Soft errors may be explicit bit flips in latches or memories, or glitches in combinational logics that can propagate and be captured in latches <ref type="bibr" target="#b8">[9]</ref>. If not handled properly, such errors can cause illegal accesses to peripherals, memory overflow, data corruption, false and sometimes fatal data or action outputs, and so on. Therefore, it is necessary to detect and correct errors in control flows hopefully before damages are caused.</p><p>Various control-flow checking techniques have been proposed in the literature. These techniques are suggested in literature that would fall into two general classes, hardware <ref type="bibr">[10, 11, and 12]</ref> or software <ref type="bibr">[13, 14, 15, 16, and 17]</ref> redundancy. The methods based on hardware redundancy have a better fault coverage but need additional hardware or modification of the existing hardware and cannot guarantee portability to various platforms. Software-based techniques have less fault coverage and larger delay; however, mean lower cost and overhead on the system and can be utilized in different types of industrial systems due to their flexibility. The basic idea of software control flow checking is to partition the program into basic blocks (branch-free parts of code) <ref type="bibr" target="#b14">[14]</ref>. For each block a deterministic signature is calculated and saved somewhere during compile time; then errors can be detected by comparing the run-time signature with the saved one. This method does not require any additional hardware and can be automatically applied for software control flow checking. It should be noted that, in practical industrial applications, whatever approach is used, whether it is software-based or hardware-based, it should be able to handle the errors mentioned above as much as possible and, in doing so, impose as little memory overhead and as little increase in execution time as possible.</p><p>We propose a control flow checking technology based on updating a signature at the directed edges called CFCVE, which assigns a unique signature occupying the least bit of each basic block and updating the signatures at the virtual edges of the control flow graph, allowing it to detect all the single inter-block control flow error. CFCVE is comparable in performance overhead incurred with CFCSS. However, its fault coverage is always higher than CFCSS and is comparable with RSCFC. Furthermore it overcomes the limitations of CFCSS with less memory than RSCFC. This solution is inspired by <ref type="bibr">[13, 14, 15, 16, and 17]</ref> and incorporates their advantages. The contributions of this work are as follows:</p><p>ÔÅ¨ Our work is the first to update the signatures at the directed edges instead of at the nodes of control flow graph.</p><p>ÔÅ¨ We propose a novel fitness factor in this paper that can compare different approaches, based on their fault coverage, memory overheadÔºåperformance overhead and error detection latency.</p><p>ÔÅ¨ We assess control flow checking technology based on updating a signature at the directed edges under novel fitness factor.</p><p>The remainder of the paper is organized as follows. In Section 2 the related works on software control flow checking methods are reviewed, while Section 3 describes the proposed approach. In Section 4 we introduce how to further enhance the error detection capability of the proposed method. The capabilities of the proposed technique are analyzed in Section 5. Section 6 reports the experimental results we gathered and finally section 7 draws some conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>A variety of defense mechanisms are proposed to detect and correct control flow errors (e.g., <ref type="bibr">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, and 20]</ref>). Clearly, this is a crowded, important research area. Next we elaborate on some of the pieces of work most closely related to ours.</p><p>The most important three software-based solutions proposed in the literature are the techniques called Enhanced Control Flow Checking Using Assertions (ECCA) <ref type="bibr" target="#b12">[13]</ref> and Control Flow Checking by Software Signatures (CFCSS) <ref type="bibr" target="#b15">[15]</ref> and On-line control flow error detection using relationship signatures among basic blocks (RSCFC) <ref type="bibr" target="#b14">[14]</ref>.</p><p>ECCA, firstly, assigns a unique prime number identifier (BID) to each basic block of a program; then a test assertion and a set assignment, which are composed of a global integer variable (id) and the BID, are individually inserted into the beginning and the end of each basic block. During the execution, the id is dynamically updated and it can transfer a control flow error into a divide by zero error. ECCA is able to detect all the single inter-block control flow error, except the faults that cause an incorrect decision on a conditional branch. Due to its complexity of the test and set assertions, ECCA has higher memory and time overhead than CFCSS.</p><p>CFCSS assigns a unique signature i s to each basic block and uses a global variable (G) to contain the run-time signature. When control transfers from one basic block to another, CFCSS uses the first instruction to compute the signatures of the destination block from the signature of the source block and a pre-computed variable d, which is the EXOR difference between the signatures of the source and destination blocks, and updates G with the value at the beginning of the basic block; in the following instruction, CFCSS then tests whether G is equal to the destination block's signature. If the control can enter from multiple blocks, then an adjusting signature (D) is assigned in each source block and used in the destination block to compute the signature. In absence of errors, the signature contained in G is equal to the signature of destination block. However, CFCSS cannot cover control flow errors if multiple source blocks share multiple branch-fan-in blocks as their destination blocks, aliasing could occur between legal and illegal branches.</p><p>One of the works in this field is Relationship Signature CFC (RSCFC) in which the program is divided into some basic blocks. In the first stage, the relationship between blocks is extracted and then based on the kind of the relationship, a signature is assigned to each block in which the existing relationships are coded in it. The faults in the control flow of the program are detected by logic AND the run-time signatures with the information at the beginning and end of the blocks. In comparison to the previous works, this method has more fault coverage and a better efficiency. However, RSCFC, codes the transfer relationship among basic blocks into each block's signature, which leads to the signature of each block have many bits exceeding the limitation of machine word possibly, consumes more memory than CFCSS. Although this situation can be cooperated by grouping basic blocks, however, error detection latency will be increased.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Methodology</head><p>To start with, definitions of relevant concepts are presented in table <ref type="table">1</ref> for the sake of clarity. CFCVE checks the control flow of the program using a dedicated register called the global signature register (GSR), which contains the run-time signature G associated with the current node (the node that contains the instruction currently executed) in the program flow graph. Every basic block (represented by a node i v in the program flow graph) is identified and assigned a unique signature i s when the program is compiled. Let i G be the run-time value of G when the program flow is at node i v . Under normal execution of the program (no errors), i G should be equal to i s . If G contains a number different from the signature associated with the current node, it means an error has occurred in the program <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1. Definitions of relevant concepts used in this paper</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Concept Definition</head><p>Basic Block A Basic Block (BB) is a maximal set of ordered non-branching instructions (except in the last instruction) or branch destinations (except in the first instruction) in which the execution always enters at the first instruction and leaves via the last instruction <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Control Flow Graph</head><p>A program P can be represented with a directed graph composed of a set of node V and a set of edges</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>{V,E} E,P =</head><p>, where</p><formula xml:id="formula_0">} ‚Ä¶ ‚Ä¶ { , , , , 2 , 1 m i v v v v V = and } e , ‚Ä¶ , e , ‚Ä¶ , , { m i 2 1 e e E =</formula><p>Each node i v represents a basic block and each edge i e represents the branch j i br , from i v to j v . This directed graph is called the control flow graph (CFG).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Vertex</head><p>Basic blocks are denoted by vertexes</p><formula xml:id="formula_1">}) , ‚Ä¶ , 2 , 1 { ( N i vi ‚àà</formula><p>in the control flow graph CFG, where N is the total number of basic blocks.</p><formula xml:id="formula_2">}} , ‚Ä¶ , 2 , 1 { ; { : N i v V i ‚àà</formula><p>, a set of vertexes denoting basic blocks.</p><p>A set of successors of in CFG, if and only if , then the node .</p><p>A set of predecessors of in CFG, only if , then the node .</p><p>Virtual Vertex A Virtual Vertex (VV) denotes a basic block that does not contain any other effective instructions except an unconditional jump instruction and has only one successor vertex and one predecessor vertex. represents a virtual vertex whose predecessor vertex is vertex and successor vertex is .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Edge</head><p>A legal branch from one basic block to another is denoted by a directed edge between the two correspondent vertexes in CFG.</p><p>Virtual Edge A Virtual Edge (VE) is an Edge in which a Virtual Vertex is embedded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Control-flow error</head><p>A control-flow error (CFE) is said to have occurred if the sequence of instructions executed in presence of a fault is different from the fault-free sequence.</p><p>Internode CFEs Internode CFEs occur if the program control before and after the illegal jump resides in different nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intranode CFEs</head><p>Intranode CFEs occur if the program control before and after the illegal jump resides in the same node. <ref type="bibr" target="#b22">[22]</ref> XOR operation</p><p>The xor-difference of a and b is the result of performing the bitwise XOR operation ( ) of a and b, i.e., xor-difference = a b, where a and b are binary numbers. The CFCVE approach consists of the following steps: Algorithm A:</p><p>1) Extracting the Basic Block and generating the CFG of the program.</p><p>2) Assigning a signature , which is generated by a specific algorithm, to node , in which , where is the total number of nodes in the program. 3) Inserting a Virtual vertex into each Edge and inserting the signature updating instructions into each Virtual Vertex.</p><p>4) Inserting the appropriate instructions into the start and end of each Vertex in order to update the signature in run-time phase.</p><p>5) Inserting the checking instructions into the end of each Vertex (Virtual Vertex) in order to detect the control flow errors.</p><p>In this section the proposed scheme is explained in details. Subsection 1 explains the signature generation for the basic blocks and subsection 2 introduce the insertion of Virtual Vertexes into Edges and the insertion of updating instructions into a Vertex (Virtual Vertex) are introduced. Insertion of the checking instructions into each Vertex is described in subsection 3, and the control flow checking scenario is described in subsection 4. Memory overhead is an important indicator in a control flow checking algorithm. In order to guarantee the minimum memory overhead, the length of the signature for each basic block should be as short as possible and try to use the least bit of the registers. In CFCVE we assign a binary positive number to each BB, and the length of a signature Len can be obtained by equation <ref type="bibr" target="#b0">(1)</ref>, where N is the number of total BBs. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Signature Generation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Visual edges creation and insertion of the updating instructions</head><p>CFCVE primarily focuses on internode CFEs. An illegal branch j i br , ( j i br , is not included in E) from i v to j v indicates a CFE, i.e., each edge in E uniquely determines a legal branch j i br , , therefore, the essence of a control flow checking technique is to determine whether the current branch j i br , is included in E. For this purpose, CFCVE transforms the structure of CFG by inserting a Virtual Vertex ij vv into each Edge j i e , . Note that Edges pointing from the vertexes to themselves should not have Virtual Vertexes inserted. Fig. <ref type="figure">3</ref> shows an example of a control flow graph and the result of the transformation. The following is the complete description of Algorithm B, which creates a Visual Edge and inserts updating instructions into each Edge in a CFG.</p><p>Algorithm B: For each Edge</p><formula xml:id="formula_3">N j i e j i , ‚Ä¶ , 2 , 1 , , , = . 1) Generate a Virtual Vertex j i vv , whose successor vertex is j v and predecessor vertex is i v into j i e , 2) Insert Virtual Vertex j i vv , into j i e , . 3) Insert updating instructions i s G G ‚äï = and j s G G ‚äï = into Virtual Vertex j i vv , .</formula><p>Suppose that we mark the inserted Virtual Vertex j i vv , as p vv and that i s and j s are the signatures of the source node i v and the destination node j v of branch j i br , . After inserting the Virtual Vertex j i vv , , the original Edge j i e , is divided into Edge ip e and Edge j p e , , i.e., the original branch j i br , is divided into branch p i br , and branch j p br , . Since the Virtual Vertex p vv contain no other instructions except an unconditional jump instruction (the destination node is j v ), once branch p i br , is taken, the control flow will transfer to Vertex j v . Thus, the original Edge j i e , can be observed as a Virtual Edge in which a Virtual Vertex p vv is embedded. An example of creating a virtual edge is showed in Fig. <ref type="figure">3</ref>. The dotted circle in Fig. <ref type="figure">3</ref> shows a Virtual Vertex. After inserted a Virtual Vertex, the original edge is transformed into a virtual edge. Virtual edges indicate that as execution of their origins completes, control flow continues from their terminals. In other words, they do not damage the control flow nature of original edges. For example for Virtual Edge e is not affected. In order to update the run-time signature associated with the current node of CFG, two signature updating instructions and , are inserted into Virtual Vertex . Before the branch is taken, is equal to , which is the same as . After the branch is taken, the control is transferred to , and the first signature updating instruction is executed. Then, is updated with a new run-time signature , , and then the second signature updating instructions is executed, after which . Thus, when the control transfers to , the run-time signature is equal to the signature of node . A Virtual Vertex with signature updating instructions is shown in Fig. <ref type="figure">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Insertion of checking instructions into each vertex</head><p>To check the control flow, the checking instruction '</p><p>' is inserted into the top of each BB. In other words, this checking instruction is executed prior to the execution of the original instructions in the BB; therefore, fault detection latency inside BB is avoided. As shown in Fig. <ref type="figure" target="#fig_5">5</ref>, the basic block consists of the original instructions and with additional checking instruction located at its top. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The control flow checking scenario</head><p>When control is transferred from one Virtual Vertex to its successor vertex , the program execution reaches the start of node first. Before execution of the signature checking instruction, the value of is updated to , and then the signature checking instruction is executed. If is not equal to the signature of vertex , then a control flow error has occurred and control will be transferred to the error handling routine. On the other hand, if is equal to , it tells us there is no control flow error, then the rest instructions of vertex will be executed. After that, the control is transferred to Virtual Vertex , which is the successor vertex of . After the branch is taken, the first signature updating instruction is executed, and then is updated with a new run-time signature , , the value of is updated to 0. Then the second signature updating instructions is executed where is the successor vertex of , . Next, the unconditional jump instruction of Virtual Vertex is executed, and control is transferred to vertex .Thus, when the control is transferred to , the run-time signature is equal to the signature of node .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Enhancement of Methodology</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Entry/Exit bit</head><p>It has been shown that illegal branches violating the control flow entered at the beginning of each Basic Block can be detected by CFCVE. However, there are cases where legal branches entering somewhere inside a basic block cannot be detected. For example, in Fig. <ref type="figure">6</ref>, node is the predecessor of node . After executing the last instruction of node , the branch will take; the control will transfer to node v 2 . There is no problem when enters at the beginning of node ; however, intranode CFE occurs if enters at the middle of node , and this intranode CFE cannot be detected by current CFCVE. In order to enhance the Error detection capabilities of CFCVE, the Entry/Exit bit, which can detect the control flow errors that jump to or from the middle of a BB is introduced. The length of the Entry/Exit bit is 1 bit, and the value is set to 1/0 when the execution reaches the entrance/exit of each BB. Thus, the new signature for each basic block consists of two sections; the Entry/Exit code and the original signature, i.e., Label of current BB (see the Fig. <ref type="figure">7</ref>).</p><p>We call the new signature when the value of the Entry/Exit bit is equal to 1/0. For each BB, a signature updating instruction is inserted behind the original checking instruction and then a signature updating instruction is inserted into the end before the last instruction of Vertex . In addition, the original checking instruction ' ' is changed to ' '. Moreover, the original signature updating instructions and are changed to and respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Control flow checking scenario</head><p>When control is transferred from one Virtual Vertex to its successor vertex , the signature checking instruction is executed. If is not equal to the signature of vertex , then a control flow error has occurred and control will be transferred to the error handling routine. However, if is equal to , there is no control flow error. Then the program execution reaches the start of node , before execution of the first signature updating instruction, the value of will be equal to in the absence of any errors. Then, the first signature updating instruction is executed, and the value of is updated to 0; next, the remaining instructions of node will be executed and after the second signature updating instruction is executed, the value of will be set to . When control is transferred from vertex to its successor Virtual Vertex , the program execution reaches the start of first. Before execution of the first signature updating instruction, the value of will be equal to in the absence of any errors. Next, the first signature updating instruction is executed and the value of is updated to 0, then the second signature updating instruction is executed, and the value of G will be set to j BS .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Error detection capabilities</head><p>As mentioned in section 3.2, CFCVE primarily focuses on internode CFEs. An internode CFE falls into one of the following two cases: ÔÅ¨ a branch j i br , to a basic block j v not belonging to ) ( i v suc ÔÅ¨ a branch j i br , to somewhere inside a basic block j v belonging to ) i v suc CFCVE is capable of detecting all internode CFEs. Proof:</p><p>Type 1: a branch j i br , to a basic block j v not belonging to ) ( i v suc Suppose that j i br , is an illegal branch, and</p><formula xml:id="formula_4">) ( i j v suc v ‚àâ . If i v is a Virtual Vertex, then at node i v G is equal to k BS , where ) ( i k v suc v ‚àà</formula><p>. Before the branch j i br , is taken, the new run-time signature is generated,</p><formula xml:id="formula_5">k k k BS BS BS G G = ‚äï = ‚äï = 0 . If j v is a Virtual Vertex and ) ( j m v suc v ‚àà</formula><p>, after the branch is taken, the two signature updating instructions of node i v are executed. Then, the branch m j br , is taken, and the checking instruction ' error ) ( br</p><formula xml:id="formula_6">m BS G ‚â†</formula><p>' of node m v is executed. G is not equal to m BS , because the signature of CFCVE is unique. Control is then transferred to the error handler, thus the error is detected. If j v is not a Virtual Vertex, then after the branch j i br , is taken, the checking instruction ' error ) ( br</p><formula xml:id="formula_7">j BS G ‚â† ' is executed. Since j k BS BS G ‚â† =</formula><p>control is transferred to the error handler, thus the mismatch is detected.</p><p>The situation of i v is not a Virtual Vertex is similar with above. Type 2: a branch to somewhere inside a basic block j v belonging to ) ( i v suc Suppose that j i br , is an illegal branch and the branch is taken to the middle of the node j v , i.e., skipping the signature checking instruction and the first signature updating instruction.</p><p>If i v is a Virtual Vertex, then j v is not a Virtual Vertex, and at node i v G is equal to j BS . After the branch is taken, the run-time signature is still equal to j BS , and then the remaining instructions including the second signature updating instruction are executed, and the new run-time signature is generated,</p><formula xml:id="formula_8">j j j ES BS ES G G ‚äï = ‚äï =</formula><p>. After the instructions in node j v are executed,</p><formula xml:id="formula_9">k j br , is taken, where ) ( j k v suc v =</formula><p>, and k v is a Virtual Vertex. The signature updating instructions in k v update the value of</p><formula xml:id="formula_10">j j j ES ES BS G ‚äï ‚äï = m BS ‚äï , where ) ( k m v suc v = and m v is not a Virtual Vertex. After m k br , is taken, the checking instruction ' error ) ( br m BS G ‚â† ' is executed. Thus, the error is detected due to m m j m j j j BS BS BS BS ES ES BS ‚â† ‚äï = ‚äï ‚äï ‚äï . If i</formula><p>v is not a Virtual Vertex, then j v is a Virtual Vertex, and at node i v G= is equal to i ES . After the branch is taken, G will be updated to k BS in the absence of control errors, where</p><formula xml:id="formula_11">) ( j k v suc v =</formula><p>and k v is not a Virtual Vertex, by the signature updating instructions of j v . Suppose that j i br , is taken to the second signature updating instruction and skipping the first signature updating instruction. Then,</p><formula xml:id="formula_12">k i k BS ES BS G G ‚äï = ‚äï =</formula><p>is generated, and the unconditional jump instruction is executed. The control is transferred to m v , where</p><formula xml:id="formula_13">) ( k m v suc v = and m v is not a Virtual Vertex. At node m v , the checking instruction ' error ) ( br m BS G ‚â† ' is executed. Since m k i BS BS ES G ‚â† ‚äï =</formula><p>, the error is detected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Experimental evaluation</head><p>In order to assess the effectiveness of the proposed approach, four benchmark programs are chosen for the experiment: Quick sort (QS), Bubble Sort (BS), Matrix Multiplication (MM), Fast Fourier Transformation (FFT). These target programs are chosen for a certain set of reasons. Firstly, they present certain varieties of control flow graph patterns. QS and BS are branch intensive programs. They have small size Basic Blocks and take a lot of branching among relatively simple calculations, resulting in more substantial overheads. MM and FFT are calculation intensive programs that perform substantial time-consuming multiplication and much less branching. Thus, the overhead of checking instructions is smaller compared to branch intensive programs. At the same time, these target programs use almost all instructions available, including the ones for arithmetic and logic calculations, and branching. Meanwhile, the target programs are merely the most common standardized algorithms that see a large number of applications, which makes them even more representative.</p><p>The proposed solution is experimentally evaluated on an ARM920T microprocessor machine running Linux kernel 2.6.32. The microprocessor has 3GB SDRAM and runs at a frequency of 400 MHz. Memory overhead, performance overhead, error detection latency and error detection coverage are imperative parameters for evaluating our approach. Thus, all of these parameters are measured and reported. First, the memory overhead and performance loss results of the presented scheme are evaluated, and then the average error detection latency of the presented scheme is analyzed and the last part allotted to error detection coverage. We considered four versions for each benchmark:</p><p>ÔÅ¨ the original code, ÔÅ¨ a safe one, obtained by applying the CFCSS <ref type="bibr" target="#b15">[15]</ref> technique to the original code, ÔÅ¨ a safe one, obtained by applying the RSCFC <ref type="bibr" target="#b14">[14]</ref> technique to the original code, ÔÅ¨ a safe one, obtained by applying the CFCVE technique to the original code. Each program (totally 16) is compiled and executed for 500 times. Memory overhead and performance overhead are compared between the hardened programs and the original ones , we determined the overheads recorded in Table <ref type="table" target="#tab_0">2</ref>.</p><p>As shown in Table <ref type="table" target="#tab_0">2</ref>, CFCVE incurs the least memory overhead (2.21%) compared with CFCSS (2.44%) and RSCFC (2.35%). In terms of performance overhead, the CFCVE (10.60%) is comparable to the CFCSS (10.55%), but less than the RSCFC <ref type="bibr">(18.45)</ref>. The memory overhead is mainly caused by signature overhead of these target programs. This memory overhead also affect on program performance. The extra execution time for the signature updating and signature checking instructions of these target programs is considered performance overhead. In CFCSS, each node is assigned a unique signature and has two additional instructions. When the node is a branch-fan-in node a run-time adjusting signature and another two additional instructions are introduced to solve the aliasing of signatures. In CFCVE, only one unique signature is employed to identify each node, and three additional instructions are used to detect control flow errors. In order to solve the aliasing of signatures, a Virtual Vertex containing three instructions is inserted into each Edge. Thus, due to the introduction of the run-time adjusting signature, the memory overhead of CFCSS is larger than for CFCVE; the instructions overhead is considerable, even the number of instructions is relatively small. In RSCFC, each block takes one bit in the signatures of basic blocks. When the total number of basic blocks in a program is large, the signature of each block will have many bits, possibly exceeding the limitation of machine word possibly. In order to deal with this situation, basic blocks are grouped into multiple hierarchies. Thus, a hierarchy signature is introduced and hierarchy signature should be checked in each node. This process leads to a higher memory overhead than CFCVE. In addition, the local cumulative signature checking instructions increase the performance overhead greatly. Therefore, RSCFC incurs more performance overhead than CFCVE.</p><p>The error detection latency is the latency between fault occurrence and error detection. It may cause erroneous output and can directly affect rollback recovery. Therefore, the errors should be detected and addressed before erroneous output occurs. Detection latency can be quantified in processor cycles, and is defined here as the number of processor cycles to run between the terminal of the illegal branching and the line detecting the error here. The detection latency result in Table <ref type="table" target="#tab_0">2</ref> is calculated according to the equation 2 and 3 of <ref type="bibr" target="#b17">[17]</ref>. Table <ref type="table" target="#tab_0">2</ref> shows that the detection latency of CFCVE is comparable to RSCFC, but much higher than for CFCSS. The reason is that the number of additional instructions in CFCSS is 2-4, 6 in CFCVE and 7 in RSCFC. We adopted a method in which the faults are injected into the program through modifying the assembly codes of the source file <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b24">24]</ref>. For each program (totally 16), the source file is compiled and assembly code is generated firstly. Secondly, one of the branch deletion, branch creation or branch operand changes was randomly applied to the assembly codes. Finally, the resulting assembly code is compiled and executed. Each kind of fault is injected 2000 times into the original program.</p><p>The results of fault injection and fault detection we gathered during fault injection experiments are reported in Tables <ref type="table" target="#tab_2">3 and 4</ref>. Transient faults injected into the unhardened programs are categorized according to their effects (Table <ref type="table" target="#tab_1">3</ref>) and then compared with the results of injection into the 3 safe versions (CFCSS, RSCFC and CFCVE), as reported in Table <ref type="table" target="#tab_2">4</ref>. Fault detection effects are classified as follows:</p><p>ÔÅ¨ Wrong Result (WR): the fault modifies the results of the program without being detected. ÔÅ¨ OS detection (OS): the fault is detected by the operating system or the hardware. ÔÅ¨ Software Detection (SD): the fault is detected by the software detection mechanisms employed. The undetected incorrect outputs are gotten by WR and error detection coverage is gotten by SD. Fig. <ref type="figure" target="#fig_8">8</ref> was generated based on the WR in Tables <ref type="table" target="#tab_2">3 and 4</ref> and illustrates the fraction of faults that are not detected for the original programs and the hardened programs with CFCSS, RSCFC and CFCVE under each fault types. As it can be seen in Fig. <ref type="figure" target="#fig_8">8</ref>, the average undetected incorrect outputs for CFCSS, RSCFC and CFCVE are 12.11%, 9.44% and 9.29% respectively. The figures of average error detection coverage are 55.32%, 63.20%, and 62.91%, respectively. As mentioned before, memory overhead, performance overhead, error detection latency and error detection coverage are imperative parameters for evaluating our approach. In order to balance these parameters a new parameter, called Evaluation Factor (EF), is introduced in Literature <ref type="bibr" target="#b25">[25]</ref>. However, the error detection latency is not taken into account. We redefined the Evaluation Factor; the new definition of Evaluation Factor is showed in equation 2. The averages of the Evaluation Factors are 0.42, 0.23 and 0.44 respectively. Thus, CFCVE is comparable in fault coverage the best of the previously proposed techniques. Meanwhile it has a higher evaluation factor because of the lower memory overhead and performance overhead compared with other methods.</p><p>The following reasons can account for the excellent performance of CFCVE. First, in CFCSS, if multiple nodes are sharing multiple branch-fan-in nodes as their destination nodes, aliasing may occur between legal and illegal branches, and cause an undetectable control flow error. CFCVE can solve the aliasing by updating signature at the directed edges instead of at the nodes of control flow graph. Thus, the error detection coverage is higher than CFCSS. Second, in RSCFC, each block takes one bit in the signatures of basic blocks. The length of signature and the total number of basic blocks are in the direct ratio. This will incur substantial memory overhead when the quantity is large. Therefore, CFCVE incurs less memory overhead than RSCFC. Third, the memory overhead and error detection latency are lower due to the moderate additional instructions of CFCVE. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions and Future Research</head><p>This article proposes a software-based control flow checking technique CFCVE. This method assigns a unique signature occupying the least bit to each basic block and updates the signatures at the virtual edges of the control flow graph. A Virtual Edge is introduced to resolve the signature aliasing. Fault and error injection experiments were conducted to assess the effectiveness of the proposed approach. The experiments showed that the CFCVE technique incurs the least memory overhead and performance overhead. The error detection latency is moderate. Error injection experiments on benchmarks showed that CFCVE can detect all the single inter-block control flow errors and has higher method efficiency [26] than previous techniques. However, Virtual Vertex introduces addition branches into the code, which may be affected by faults themselves.</p><p>Research is being conducted to develop excellent methods to protect checking instruction and signature updating instructions themselves in order to improve error coverage without increasing performance overhead. The trade-off between error detection latency and performance overhead is also a new research topic for our research group. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Acknowledgment</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A typical example of program and its CFG</figDesc><graphic url="image-14.png" coords="5,158.02,454.22,304.10,219.35" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The original CFG and the CFG with assigned signatures</figDesc><graphic url="image-21.png" coords="6,183.97,411.72,256.30,185.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>( 1 )</head><label>1</label><figDesc>Fig.2shows an example of generation signature for each node of CFG. Fig.2(a) shows a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .Fig. 4 .</head><label>34</label><figDesc>Fig. 3. An example of creating a virtual edge</figDesc><graphic url="image-23.png" coords="8,225.97,134.77,158.15,228.95" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. A basic block with checking instruction</figDesc><graphic url="image-45.png" coords="9,260.77,134.77,99.60,189.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .Fig. 7 .</head><label>67</label><figDesc>Fig. 6. The example of control flow transfers to the middle of node</figDesc><graphic url="image-82.png" coords="10,258.12,134.77,93.85,165.85" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. The comparison of undetected incorrect outputs percentage under three fault types</figDesc><graphic url="image-116.png" coords="15,201.63,276.03,206.65,146.15" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>This research was supported by the National Natural Science Foundation of China under grant No. 61370134, the National High Technology Research and Development Program of China (863 Program) under grant No. 2013AA013901.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 2 .</head><label>2</label><figDesc>Memory overhead, performance overhead and error detection latency comparison</figDesc><table><row><cell>Program</cell><cell cols="9">Memory overhead (%) CFCSS RSCFC CFCVE CFCSS RSCFC CFCVE CFCSS RSCFC CFCVE Performance overhead (%) Detection latency (cycle)</cell></row><row><cell>QS</cell><cell>2.42</cell><cell>2.93</cell><cell>2.24</cell><cell>14.50</cell><cell>25.0</cell><cell>11.0</cell><cell>4.70</cell><cell>5.72</cell><cell>5.20</cell></row><row><cell>BS</cell><cell>2.71</cell><cell>2.13</cell><cell>2.46</cell><cell>11.00</cell><cell>16.30</cell><cell>10.50</cell><cell>4.56</cell><cell>5.51</cell><cell>5.40</cell></row><row><cell>MM</cell><cell>2.17</cell><cell>1.36</cell><cell>1.94</cell><cell>6.50</cell><cell>14.20</cell><cell>5.51</cell><cell>5.63</cell><cell>7.16</cell><cell>6.51</cell></row><row><cell>FFT</cell><cell>2.47</cell><cell>2.96</cell><cell>2.25</cell><cell>10.20</cell><cell>18.30</cell><cell>15.42</cell><cell>5.37</cell><cell>7.37</cell><cell>7.12</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 3 .</head><label>3</label><figDesc>Experiment results of fault detection effects in original programs.</figDesc><table><row><cell>Original Program</cell><cell cols="2">Del (2000#) (%) OS WR</cell><cell cols="2">Change (2000#) (%) OS WR</cell><cell cols="2">Insert (2000#) (%) OS WR</cell></row><row><cell>QS</cell><cell>31.2</cell><cell>36.7</cell><cell>71.2</cell><cell>25.4</cell><cell>52.4</cell><cell>28.7</cell></row><row><cell>BS</cell><cell>35.1</cell><cell>48.7</cell><cell>67.9</cell><cell>26.7</cell><cell>57.9</cell><cell>16.7</cell></row><row><cell>MM</cell><cell>32.5</cell><cell>40.3</cell><cell>65.1</cell><cell>25.3</cell><cell>58.6</cell><cell>25.3</cell></row><row><cell>FFT</cell><cell>36.6</cell><cell>40.9</cell><cell>64.5</cell><cell>30.9</cell><cell>64.5</cell><cell>26.5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 4 .</head><label>4</label><figDesc>Experiment results of fault detection effects in programs with CFCSS, RSCFC and CFCVE.</figDesc><table><row><cell>Programs</cell><cell>Del (2000#) (%) OS WR</cell><cell>SD</cell><cell cols="3">Change (2000#) (%) OS WR SD</cell><cell cols="2">Insert (2000#) (%) OS WR</cell><cell>SD</cell></row><row><cell>QS-CFCSS</cell><cell>22.3 17.4</cell><cell>38.2</cell><cell>21.8</cell><cell>10.5</cell><cell>58.2</cell><cell>25.1</cell><cell>7.46</cell><cell>56.2</cell></row><row><cell>BS-CFCSS</cell><cell>14.2 6.73</cell><cell>38.6</cell><cell>12.7</cell><cell>16.9</cell><cell>68.1</cell><cell>15.2</cell><cell>8.64</cell><cell>64.3</cell></row><row><cell>MM-CFCSS</cell><cell>19.4 12.7</cell><cell>37.5</cell><cell>16.1</cell><cell>5.30</cell><cell>65.4</cell><cell>28.7</cell><cell>14.5</cell><cell>50.4</cell></row><row><cell>FFT-CFCSS</cell><cell>13.4 20.3</cell><cell>53.2</cell><cell>11.5</cell><cell>13.4</cell><cell>73.7</cell><cell>21.4</cell><cell>11.6</cell><cell>60.1</cell></row><row><cell>QS-RSCFC</cell><cell>19.3 15.1</cell><cell>43.5</cell><cell>15.6</cell><cell>7.82</cell><cell>65.7</cell><cell>17.1</cell><cell>6.20</cell><cell>65.4</cell></row><row><cell>BS-RSCFC</cell><cell>4.63 5.34</cell><cell>60.2</cell><cell>8.64</cell><cell>13.2</cell><cell>76.3</cell><cell>12.5</cell><cell>4.24</cell><cell>71.4</cell></row><row><cell>MM-RSCFC</cell><cell>15.2 7.60</cell><cell>47.8</cell><cell>13.1</cell><cell>4.83</cell><cell>69.4</cell><cell>23.5</cell><cell>13.3</cell><cell>54.6</cell></row><row><cell>FFT-RSCFC</cell><cell>9.82 15.4</cell><cell>62.3</cell><cell>8.16</cell><cell>11.6</cell><cell>76.3</cell><cell>13.7</cell><cell>8.64</cell><cell>65.5</cell></row><row><cell>QS-CFCVE</cell><cell>21.4 15.5</cell><cell>49.0</cell><cell>14.4</cell><cell>8.34</cell><cell>64.6</cell><cell>16.5</cell><cell>4.75</cell><cell>67.7</cell></row><row><cell>BS-CFCVE</cell><cell>6.40 4.20</cell><cell>55.5</cell><cell>8.25</cell><cell>14.5</cell><cell>75.4</cell><cell>12.8</cell><cell>4.64</cell><cell>72.2</cell></row><row><cell>MM-CFCVE</cell><cell>13.6 8.92</cell><cell>48.1</cell><cell>15.5</cell><cell>5.35</cell><cell>67.7</cell><cell>22.5</cell><cell>12.9</cell><cell>55.4</cell></row><row><cell>FFT-CFCVE</cell><cell>13.1 14.9</cell><cell>59.5</cell><cell>7.12</cell><cell>10.8</cell><cell>78.6</cell><cell>15.8</cell><cell>6.78</cell><cell>61.3</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Detecting LDoS Attacks based on Abnormal Network Traffic</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.3837/tiis.2012.07.007</idno>
	</analytic>
	<monogr>
		<title level="j">Ksii Transactions on Internet &amp; Information Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1831" to="1853" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Out of Control: Overcoming Control-Flow Integrity[C]</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ktas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Athanasopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bos</surname></persName>
		</author>
		<idno type="DOI">10.1109/VLSI.Design.2009.76</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
				<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="575" to="589" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Dynamic integrity measurement and attestation: towards defense against return-oriented programming attacks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><surname>Sadeghi A R</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winandy</surname></persName>
		</author>
		<idno type="DOI">10.1145/1655108.1655117</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Workshop on Scalable Trusted Computing</title>
		<imprint>
			<biblScope unit="page" from="49" to="54" />
			<date type="published" when="2009-11">2009. November. 2009</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Dynamic trust enhanced security model for trusted platform based services</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nagarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Varadharajan</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.future.2010.10.008</idno>
	</analytic>
	<monogr>
		<title level="j">Future Generation Computer Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="564" to="573" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A hijacker&apos;s guide to communication interfaces of the trusted platform module</title>
		<author>
			<persName><forename type="first">J</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Dietrich</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.camwa.2012.06.018</idno>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Mathematics with Applications</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="748" to="761" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Architecture Support for Dynamic Integrity Checking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kanuparthi A K, Zahran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karri</forename><forename type="middle">R</forename></persName>
		</author>
		<idno type="DOI">10.1109/TIFS.2011.2166960</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Forensics &amp; Security</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="321" to="332" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Protecting the integrity of trusted applications in mobile phone systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Muthukumaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schiffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hassan</surname></persName>
		</author>
		<idno type="DOI">10.1002/sec.194</idno>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Security &amp; Communication Networks</publisher>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="633" to="650" />
		</imprint>
	</monogr>
	<note>CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The geometry of innocent flesh on the bone: return-into-libc without function calls (on the x86)[C]</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<idno type="DOI">10.1145/1315245.1315313</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM Conference on Computer and Communications Security, CCS 2007</title>
				<meeting>of ACM Conference on Computer and Communications Security, CCS 2007<address><addrLine>Alexandria, Virginia, Usa</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-10">October. 2007</date>
			<biblScope unit="page" from="552" to="561" />
		</imprint>
	</monogr>
	<note>CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">RADJAM: A Novel Approach for Reduction of Soft Errors in Logic Circuits</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bhattacharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ranganathan</surname></persName>
		</author>
		<idno type="DOI">10.1109/VLSI.Design.2009.76</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of International Conference on Vlsi Design</title>
				<meeting>of International Conference on Vlsi Design</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="453" to="458" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Control-Flow Checking Using Watchdog Assists and Extended-Precision Checksums</title>
		<author>
			<persName><forename type="first">R</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Mccluskey</surname></persName>
		</author>
		<idno type="DOI">10.1109/12.54849</idno>
	</analytic>
	<monogr>
		<title level="j">Computers IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="554" to="559" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Hardware Approach to Concurrent Error Detection Capability Enhancement in COTS Processors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rajabzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Miremadi</surname></persName>
		</author>
		<idno type="DOI">10.1109/PRDC.2005.7</idno>
	</analytic>
	<monogr>
		<title level="m">Pacific Rim International Symposium on Dependable Computing, 2005. Proceedings. IEEE, 83-90</title>
				<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Control-Flow Checking Using Branch Instructions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jafari-Nodoushan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Miremadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ejlali</forename><forename type="middle">A</forename></persName>
		</author>
		<idno type="DOI">10.1109/EUC.2008.44</idno>
	</analytic>
	<monogr>
		<title level="m">Ieee/ipip International Conference on Embedded and Ubiquitous Computing</title>
				<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="66" to="72" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Design and evaluation of system-level checks for on-line control flow error detection</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Alkhalifa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S S</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<idno type="DOI">10.1109/71.774911</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel &amp; Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="627" to="641" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On-line control flow error detection using relationship signatures among basic blocks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hong</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.compeleceng.2008.08.010</idno>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Electrical Engineering</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="132" to="141" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Control-flow checking by software signatures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Oh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Shirvani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Mccluskey</surname></persName>
		</author>
		<idno type="DOI">10.1109/24.994926</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Reliability</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="111" to="122" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Control Flow Checking Method based on Abstract Basic Block and Formatted Signature</title>
		<author>
			<persName><forename type="first">Jian-Li L I</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q P</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L F</forename></persName>
		</author>
		<idno type="DOI">10.1109/PAAP.2010.73</idno>
	</analytic>
	<monogr>
		<title level="j">Chinese Journal of Computers</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Graph-tree-based software control flow checking for COTS processors on pico-satellites</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.cja.2013.02.019</idno>
	</analytic>
	<monogr>
		<title level="j">Chinese Journal of Aeronautics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="413" to="422" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">S-SETA: Selective Software-Only Error-Detection Technique Using Assertions</title>
		<author>
			<persName><forename type="first">E</forename><surname>Chielle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G S</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F L</forename><surname>Kastensmidt</surname></persName>
		</author>
		<idno type="DOI">10.1109/TNS.2015.2484842</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Nuclear Science</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="3088" to="3095" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Hardware-Software Approach for On-line Soft Error Mitigation in Interrupt-Driven Applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Martinez-Alvarez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Restrepo-Calle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cuenca-Asensi</surname></persName>
		</author>
		<idno type="DOI">10.1109/TDSC.2014.2382593</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Dependable &amp; Secure Computing</title>
		<imprint>
			<biblScope unit="page" from="502" to="508" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Malware Detection in Cloud Computing Infrastructures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shirazi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marnerides</surname></persName>
		</author>
		<idno type="DOI">10.1109/TDSC.2015.2457918</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Dependable &amp; Secure Computing</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="192" to="205" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Low-cost on-line fault detection using control flow assertions[C]</title>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J P</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Murray B T</forename></persName>
		</author>
		<idno type="DOI">10.1109/OLT.2003.1214380</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of On-Line Testing Symposium, Iolts. IEEE</title>
				<meeting>of On-Line Testing Symposium, Iolts. IEEE</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="137" to="143" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Soft-Error Detection Using Control Flow Assertions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goloubeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rebaudengo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M S</forename><surname>Reorda</surname></persName>
		</author>
		<idno type="DOI">10.1109/DFTVS.2003.1250158</idno>
	</analytic>
	<monogr>
		<title level="j">Nonlinear Dynamics</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="581" to="588" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">A Software-Based Error Detection Technique Using Encoded Signatures</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sedaghat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Miremadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fazeli</surname></persName>
		</author>
		<idno type="DOI">10.1109/DFT.2006.11</idno>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="389" to="400" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">A Design Methodology for Software Fault Injection in Embedded Systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jhaveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abraham</forename><forename type="middle">J</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Software-Based Control Flow Checking Against Transient Faults in Industrial Environments</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Asghari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Taheri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pedram</surname></persName>
		</author>
		<idno type="DOI">10.1109/TII.2013.2248373</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Industrial Informatics</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="481" to="490" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">CEDA: Control-Flow Error Detection Using Assertions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Vemu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abraham</forename><forename type="middle">J</forename></persName>
		</author>
		<idno type="DOI">10.1109/TC.2011.101</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1233" to="1245" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>CrossRef Link</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
