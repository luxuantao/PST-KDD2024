<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Thorough Static Analysis of Device Drivers</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Ball</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ella</forename><surname>Bounimova</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Byron</forename><surname>Cook</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vladimir</forename><surname>Levin</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jakob</forename><surname>Lichtenberg</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Con</forename><surname>Mcgarvey</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bohus</forename><surname>Ondrusek</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sriram</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Abdullah</forename><surname>Ustuner</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Thorough Static Analysis of Device Drivers</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D4586B71E7F618CD41CBDBC1F0130AD3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Software]: Software Engineering-Program Verification; D.4.5 [Software]: Operating Systems-Reliability Reliability</term>
					<term>Verification Software model checking</term>
					<term>formal verification</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Bugs in kernel-level device drivers cause 85% of the system crashes in the Windows XP operating system <ref type="bibr" target="#b47">[44]</ref>. One of the sources of these errors is the complexity of the Windows driver API itself: programmers must master a complex set of rules about how to use the driver API in order to create drivers that are good clients of the kernel. We have built a static analysis engine that finds API usage errors in C programs. The Static Driver Verifier tool (SDV) uses this engine to find kernel API usage errors in a driver. SDV includes models of the OS and the environment of the device driver, and over sixty API usage rules. SDV is intended to be used by driver developers "out of the box." Thus, it has stringent requirements: (1) complete automation with no input from the user; (2) a low rate of false errors. We discuss the techniques used in SDV to meet these requirements, and empirical results from running SDV on over one hundred Windows device drivers.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Writing a robust device driver requires a great deal of expertise and precise understanding of how drivers are supposed to interact with the operating system or kernel. Testing a device driver is just as tricky. There are two main difficulties that typically limit the testability of device drivers:</p><p>Observability: It is difficult to determine when something goes wrong in the interaction between a driver and the kernel. In the Windows operating system there are a large number of kernel-level APIs, which gives rise to many ways in which a driver can misuse these APIs. Such errors rarely lead to immediate failures. Instead, the system is left in an inconsistent state, resulting in a crash or improper behavior at a later time. It would be useful to detect the driver error at the point where the root cause of the error happens.</p><p>Controllability/Coverage: Drivers that work correctly under normal circumstances can have subtle errors that appear only under rare and exceptional situations. Such cases can be hard to purposefully exercise. As a result, traditional testing techniques usually fail to provide high coverage through the driver's set of execution paths.</p><p>What makes these problems particularly important is the fact that, at least in the Windows operating system, device drivers are the defacto mechanism for efficiently adding basic functionality into the operating system. In Linux, kernel modules provide a similar facility. Software for virus protection, virtual machine emulation, performance monitoring, and HTTP are all typically implemented, in part, as Windows kernel-level device drivers.</p><p>For this reason a surprising number of developers across the world are, in effect, Windows kernel developers. In order for a kernel to execute correctly on a machine, the developers of the drivers and kernel modules installed on that machine must have all written their code to obey the kernel-level API usage rules. Furthermore, features such as plug-and-play, power management and asynchronous I/O all substantially enhance yet complicate the Windows driver model-making them a common source of driver errors.</p><p>We present a tool called SDV that uses static analysis to enhance both the observability and coverage of device driver testing. Increased observability is obtained by stating and checking rules about the proper use of kernel APIs. Increased coverage is provided by a combination of two techniques: (1) a hostile model of the driver's execution environment tests the driver in many stressful scenarios, such as operating system calls continually failing; <ref type="bibr" target="#b4">(2)</ref> an analysis engine-called Slam 1 -based on model checking and symbolic execution that simulates all possible behaviors of the code. This analysis engine seeks to find all ways that a device driver can disobey a set of API usage rules. Violations that are found by the analysis engine are then presented as source-level error paths through the driver code.</p><p>The Driver Abstraction Challenge. It is SDV's goal to check that device drivers make proper use of the driver API. It is not SDV's goal to check that device drivers perform any useful function with respect to their intended feature. Our hypothesis is that the amount of state that needs to be tracked in order to make an accurate determination about whether or not a driver obeys an API usage rule is relatively small compared to the entire state of the driver. The challenge is to automatically separate the relevant state from the irrelevant state.</p><p>SDV automatically abstracts the C code of a device driver to a simpler form. We call this alternative program an abstraction of the original because it does not lose errors: any API usage rule violation that appears in the original code also appears in the abstraction. This abstraction then can be checked efficiently against the API usage rule, which can be encoded as a state machine.</p><p>The program abstraction is expressed as a Boolean program, which has all the control-flow constructs of C (including procedures and procedure calls) but only Boolean variables. These variables track the state of relevant Boolean expressions in the C program. SDV automatically constructs a Boolean program from a C program and a set of predicates (Boolean expressions) to be observed. SDV uses a symbolic model checking algorithm based on binary decision diagrams <ref type="bibr" target="#b13">[11]</ref> to check if a Boolean program obeys an API usage rule. To give a rough example, consider a driver with 100,000 lines of source code and complicated data structures. Suppose the API usage rule being checked is intended to verify that a particular spin lock is properly used. To check this rule, SDV constructs a Boolean program where at each line of the program it keeps track of the state of the spin lock (via one Boolean variable), which can either be in the locked or unlocked state. Thus, the Boolean program can have on the order of 200,000 states (100,000 lines, with two states per line), which is well within the limits of symbolic model checking.</p><p>However, if this abstraction process were to yield too many false errors, SDV would be ineffective. When SDV finds an error path in the Boolean program, it checks that same path in the original C program to determine if it is a true error path. If necessary, rather than report false error paths to the user, SDV refines the Boolean program (through the addition of new predicates) to eliminate false error paths. This three step process of abstraction, model checking and refinement is repeated until a feasible error path is found or a proof of correctness is found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Results and Overview</head><p>This paper makes the following contributions:</p><p>• It presents a static analysis tool that is able to find all errors that a device driver (C program) may contain with respect to a well-defined set of API usage rules. SDV's analysis has the effect of searching all code paths. It uses abstraction to make the analysis tractable and iterative refinement to greatly reduce the number of false errors reported. This analysis process distinguishes SDV from other dataflow analysis tools that do not perform refinement and, as a result, may report many false errors.</p><p>• It presents our experience with developing an environment model to stress the driver under analysis and a set of rules that specify what it means for a driver to be a good client of the Windows Driver Model (WDM) API. The rules and models have been tuned over several years, resulting in an automatic tool that works "out of the box" on the developer's desktop and has a low rate of false errors.</p><p>• It presents the results of running SDV on 126 WDM drivers with over 60 rules and on 20 KDMF drivers (KDMF is a new driver API for kernel-level Windows drivers) with over 40 rules. These results show that the tool finds multiple errors in almost every driver. We have investigated a number of error reports produced by SDV together with the developers of these drivers.</p><p>We have found that 75%-80% of the errors that we have investigated were acknowledged as real errors in the drivers by the developers. In practice we found that all of the false errors that are reported are due to inaccuracies either in the rules or in the environment model. We continually refine both the rules and the environment model when we notice such false errors.</p><p>The remainder of the paper is organized as follows. Section 2 discusses related work. Sections 3 through 5 present the core components of SDV: Section 3 presents the rules, Section 4 discusses SDV's environment models and Section 5 presents the architecture and workings of SDV's analysis engine using an example. Section 6 illustrates a real error found by SDV on a Windows parallel port driver. Section 7 presents the results of running SDV on over one hundred Windows device drivers. Section 8 discusses some of the limitations of the SDV tool and how it can be improved. Section 9 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>The testing and verification of systems code is mature research area in which many advances have been made over the years. For example, run-time testing tools that instrument checks into a binary or OS system calls have been successfully used together with test cases. Purify, for example, performs this analysis in order to find array bounds violations and errors related to the reading and freeing of memory. Another example is Driver Verifier (DV) which examines the actions of a Windows driver during execution. DV is able to find many of the most frequently occurring errors in a driver-and these errors can be extremely deep.</p><p>The drawback of concrete execution tools is they only find errors which can be demonstrated during execution on the particular machines in which the driver is being tested, and only under the scenarios that are explicitly tried. This limits the coverage of the analysis. In contrast, SDV uses techniques such as model checking and symbolic execution to systematically get high coverage.</p><p>Another approach is that of driver isolation, where the driver writer is not given as much responsibility for the system's stability. Current research in this area focuses on finding the right balance between system performance and stability. Drivers can sometimes be executed in user-space, or  the operating system can sometimes provide a virtual execution environment that appears to be kernel-space, but offers more protection to the system from driver faults. Examples of this approach include Nooks <ref type="bibr" target="#b47">[44]</ref> and Xen <ref type="bibr" target="#b35">[32]</ref>. Tools like CCured <ref type="bibr" target="#b44">[41]</ref> can also be used to provide a limited form of isolation. Detecting errors at compile time also is an active area of current research. Tools in this area are based on theorem proving, type systems, program analysis, model checking, and combinations of these techniques.</p><p>Tools based on theorem proving, such as ESC <ref type="bibr" target="#b43">[40]</ref> and ESC/java <ref type="bibr" target="#b34">[31]</ref> compile a program to a verification condition and use a theorem prover to prove the verification condition. These tools typically require a user to annotate preconditions and post-conditions on functions, and in certain cases loop invariants on loops. By powering up type systems, we can encode certain kinds of errors as type errors, and use the type checker to detect these errors. Examples of such systems include the vault language <ref type="bibr" target="#b30">[27]</ref> and the cqual type-system. The esp tool checks C code against state machine properties <ref type="bibr" target="#b29">[26]</ref> using interprocedural dataflow analysis. The mops tool <ref type="bibr" target="#b16">[14]</ref> uses push-down model checking essentially on a reduced interprocedural control-flow graph of the program to check for security errors on large systems. Abstract interpretation <ref type="bibr" target="#b26">[23]</ref> is a generic framework for studying all such analyses. Instantiation of the framework requires a specific abstract domain to be chosen by the designers of the tool. Since the abstraction is conservative, all these tools are prone to reporting false errors. In specific domains such as numerically intensive programs, the abstract interpreter can be tuned to reduce false errors to manageable limits <ref type="bibr" target="#b27">[24]</ref>.</p><p>In addition to the above tools, heuristic static analysis tools that do not attempt to cover all paths, have also demonstrated significant value. The PREfix <ref type="bibr" target="#b14">[12]</ref> and PREfast tools <ref type="bibr" target="#b42">[39]</ref> perform heuristic analysis that does not cover all of the execution paths, but has reportedly found many errors in source code within Microsoft. Tools from the Meta Compilation project at Stanford use heuristic analyses <ref type="bibr" target="#b32">[29,</ref><ref type="bibr" target="#b17">15,</ref><ref type="bibr" target="#b36">33]</ref> as well, and they have successfully found many errors in Linux. The false errors produced by these tools can be man-aged after the analysis using techniques such as statistical ranking.</p><p>SDV's analysis engine, called Slam [1-9,37], implements automatic iterative refinement based on error paths. This idea first appeared in <ref type="bibr" target="#b39">[36]</ref>, and more recently in <ref type="bibr" target="#b18">[16]</ref>. Both efforts deal with finite state systems. In addition to Slam, other tools have been built to check safety properties of C programs using iterative refinement, notably Blast <ref type="bibr" target="#b38">[35]</ref> and Magic <ref type="bibr" target="#b15">[13]</ref>. In the published literature, these tools have been applied to some device drivers, but on a small scale. In principle, SDV could use any of these model checkers as its analysis engine. The contribution of SDV is the combination of its C analysis engine together with the large and polished set of rules and environment models that are specific to Windows drivers. The contribution of this paper is in the application of techniques from Slam and Blast at an industrial scale.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">API USAGE RULES</head><p>SDV's analysis engine checks temporal safety properties of sequential C programs. Roughly stated, temporal safety properties are those properties whose violation is witnessed by a finite execution path (see <ref type="bibr" target="#b41">[38]</ref> for a formal definition). A simple example of a safety property is that a lock should be alternatingly acquired and released. We encode temporal safety properties in a C-like language that allows the definition of a safety automaton <ref type="bibr" target="#b46">[43,</ref><ref type="bibr" target="#b48">45]</ref>. The automaton monitors the execution behavior of a program at the level of function calls and returns. The automaton can read (but not modify) the state of the C program that is visible at the function call/return interface, maintain a history, and signal when a bad state occurs.</p><p>An API usage rule describes a state machine and has two components: (1) a static set of state variables, described as a C structure, and (2) a set of events and state transitions on the events. The state variables can be of any C type, including integers and pointers. Figure <ref type="figure" target="#fig_0">1</ref>(a) shows a rule describing the proper usage of spin locks. There is one state variable locked that is initialized to 0. There are two events on which state transitions happen -returns of calls to the  functions KeAcquireSpinLock and KeReleaseSpinLock. Erroneous sequences of calls to these functions results in the execution of the error statement.</p><p>In fact, Figure <ref type="figure" target="#fig_0">1</ref> shows a simplified version of the real spin lock rule. Figure <ref type="figure" target="#fig_1">2</ref> shows a more complete version of this rule, which ensures that the analysis engine doesn't get confused by calls to KeAcquireSpinLock and KeReleaseSpinLock that acquire and release locks on different objects. The rule exhibits two additional elements: watch points and guards. The watch annotation to the state structure instructs SDV to track the state machine for each unique pointer value that can arise as the first parameter of KeAcquireSpinLock. (That is, the effect of the watch statement is to track the state machine for each particular pointer value that can flow into the first parameter of KeAcquireSpinLock). The guard annotation on the events identifies which parameter corresponds to the pointer value being "watched". Combined together, the effect of these two annotations is to instruct SDV to check the locking rule on each unique pointer value in isolation.</p><p>SDV comes with over 60 API usage rules (properties), ranging from simple locking properties (such as given above) to complex properties dealing with completion routines, plugand-play, and power management. Figure <ref type="figure" target="#fig_3">3</ref> summarizes some of these rules. For example, the rule markingqueuedirps checks that drivers mark an I/O request packet as pending (using IoMarkIrpPending) before queuing it. Another rule, pnpsurpriseremove, checks that drivers do not call IoDetachDevice or IoDeleteDevice when processing a plugand-play I/O request packet with type surprise removal.</p><p>These rules are a product of more than three years of effort. Each rule was developed from a suggestion in the documentation on Windows device drivers, and then rewritten and refined based on candidate violations found in device driver code when using SDV. While the rules were difficult to define and refine, the cost of their development is now being amortized over the value of the errors that are found in each new driver.  A device driver operates in the complex environment of the operating system and other drivers in the driver stack. Of course, for SDV to be usable it must analyze the source code of a driver without access to the source code of Windows or other drivers. For this reason SDV provides a model for the environment in which the driver is executing. This environment model is in the form of a C program and has two parts. The harness code simulates the operating system initializing and invoking the device driver (in various ways). The stub code provides the semantics for the kernel APIs that the driver might call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">OS ENVIRONMENT MODEL</head><p>The SDV environment model is quite hostile to the device driver under analysis. The harness probes the driver in many different ways and the stubs simulate the kernel behaving in both successful and failing modes. A key way we make the environment model hostile to the driver is through the introduction of non-deterministic behavior into the harness and stubs. This non-determinism simulates the kernel behaving in many unexpected ways, which is important for probing error paths in the driver. It is exactly these paths that are hard to cover with testing. The combination of non-determinism (in the model) with static analysis and symbolic execution (in the analysis engine) achieves the effect of covering all paths in the driver.</p><p>Figure <ref type="figure" target="#fig_2">4</ref> shows SDV's stub that overapproximates the meaning of the function function IoAllocateAdapterChannel. This stub encodes the possibilities that the procedure could return either a success or failure status. The analysis considers both possibilities at every call to this function. Both possibilities are considered due to SDV's special treatment of SdvMakeChoice. Each call to SdvMakeChoice returns a fresh symbolic (unknown) integer and assigns it into the variable choice. As a result, IoAllocateAdapterChannel will non-deterministically either return STATUS SUCCESS or STATUS INSUFFICIENT RESOURCES, depending on the value of choice.</p><p>As mentioned before, the harness is the piece of C code that mimics the operating system initializing and invoking a driver. SDV associates one of two harnesses with each API usage rule. SDV's simple harness simulates the effect of all of the following possible events:</p><p>• calling any of the driver's dispatch routines  • executing any deferred procedure calls</p><p>• executing any interrupt service routines The routines are given symbolic inputs and arbitrary initial states. In other words, SDV is effectively asking: does an API usage rule hold for any of the available dispatch routines when called on any input request?; does a rule hold for all interrupt service routines if they are called from any state?; etc. If a driver passes a rule using this harness, the result is quite strong; it is valid regardless of the state of the system before or after the execution.</p><p>However, for some rules the correctness of a driver will depend on an event occurring in the driver's DriverEntry or AddDevice routines, or even the plug-and-play dispatch routine when invoked on an I/O request packet with type IRP MN START DEVICE. In these cases SDV uses a more complicated harness which executes the driver symbolically with respect to the following events:</p><p>• The driver's DriverEntry routine, which initializes the driver's data structures, and then</p><p>• the driver's AddDevice routine, which adds the device and driver to their respective stacks, and then</p><p>• the driver's plug-and-play dispatch routine with an IRP MN START DEVICE I/O request packet (to start the device), and then</p><p>• any dispatch routine, or deferred procedure call, or interrupt service routine, or the driver's StartIo function, and then</p><p>• the driver's plug-and-play dispatch routine with an IRP MN REMOVE DEVICE I/O request packet (to simulate the device being removed from the computer) , and finally</p><p>• the driver's Unload routine, which the operating system would call after a device remove event.</p><p>This harness leads to fewer false errors being reported but results in increased analysis times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">ANALYSIS ENGINE</head><p>Figure <ref type="figure" target="#fig_4">5</ref> shows the architecture of SDV's analysis engine. SDV uses a technique called counterexample-guided abstraction refinement to automatically search for an abstract model of the original program which is sufficiently precise in order to prove the program's correctness with respect to an API usage rule or find a true error. The key idea is to find the C program state that is relevant to the rule being checked, and to discard the rest. The details of this process were published by the authors in previous papers. Here, we give just the briefest overview of the technique, by application to a small code example.</p><p>Figure <ref type="figure" target="#fig_5">6</ref>(a) presents a sample of (simplified) C code from a PCI device driver that processes I/O request packets. We apply SDV to check if the code in Figure <ref type="figure" target="#fig_5">6</ref>(a) obeys the locking API usage rule of Figure <ref type="figure" target="#fig_0">1(a)</ref>.</p><p>SDV first compiles the API usage rule into a set of C procedures (see Figure <ref type="figure" target="#fig_0">1(b)</ref>), one for each event named in the API usage rule. SDV also performs a pointer analysis <ref type="bibr" target="#b28">[25]</ref> on the program, which builds a graph representing a static overapproximation of the possible pointer alaising relationships between expressions occuring in the program. Function pointers are compiled away using explicit calls to the functions that appear in the aliasing graph. This graph is kept around, as it is used throughout SDV's analysis.</p><p>For each procedure p mentioned in the API usage rule, SDV finds all calls to procedure p in the code and instruments the code to call the appropriate procedure of Fig-   This serves to convert the API usage checking problem into a reachability problem: the function error() is called by the composite program (driver + rule + environment) if and only if the device driver violates the API usage rule. SDV's task is then to check that error() is not reachable in the composite program. If, during the instrumentation step, we discover that no event that triggers a call to error() can be instrumented, then we report that the rule is not applicable to the driver.</p><p>Otherwise, SDV passes the instrumented program to the abstraction module, called Abstract. Abstract automatically constructs a Boolean program abstraction of the original program with respect to a finite set of predicates. The set of initial predicates are those appearing in the C code of the API usage rule. In our example, this set of predicates consists of the single predicate (state==Locked) (as the other predicate is simply the negation of this predicate).</p><p>First, let's consider the translation of the C code in   <ref type="figure" target="#fig_7">6(c)</ref>. Note that many of the assignment statements in the example C procedure are abstracted to empty statements in the Boolean program. The Abstract tool uses the points-to analysis to determine whether or not an assignment statement through a pointer dereference can affect the predicate (state == Locked). The points-to analysis of the C program shows that no location in the example procedure can alias the address of the global state variable. Therefore, none of the assignment statements in the example procedure can affect the value of the predicate (state==Locked). Furthermore: a side-effect analysis shows that none of the procedures, with the exception of KeAcquireSpinLock return and KeReleaseSpinLock return, can modify the variable state, so calls to these procedures are eliminated.</p><p>Finally, because none of the conditionals in the example are related to the state variable, they are replaced with calls to the SdvMakeChoice function (which non-deterministically returns an integer value). As a result of this abstraction of conditionals, the Boolean program will have more behaviors (feasible execution paths) than the original C program.</p><p>Once a Boolean program is constructed, SDV's Check module exhaustively explores all possible states of the Boolean program and checks whether the model can ever reach the error procedure. In the Boolean program of Figure <ref type="figure" target="#fig_7">6(c)</ref>, there are many execution paths leading to the error procedure. Check outputs a shortest error path which executes the function KeAcquireSpinLock return twice in a row without an intervening call to KeReleaseSpinLock return. This is possible because all the conditions in the procedure example have been abstracted to call SdvMakeChoice.</p><p>Because the C program and the Boolean program abstractions have identical control-flow graphs, the error path in the Boolean program also is a path of the C program. Now, this path may or may not be a feasible execution path of the original program. The Refine module takes a C program and a potential error path as an input. It then uses verification condition generation to determine if the path is feasible. The answer may be "yes" or "no" or "don't know" (since this problem is undecidable, in general). If the answer is "yes" or "don't know" then SDV displays the path in the original driver code using a GUI that is similar to a visual </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>debugger.</head><p>Consider the (unique) execution path through the code in Figure <ref type="figure" target="#fig_5">6</ref>(a) that executes KeAcquireSpinLock twice without executing an intervening call to KeReleaseSpinLock. Refine detects that the path is infeasible in the original program and generates the predicate (nPackets!=npacketsOld) as the explanation for the infeasibility. This is because the assignment of nPacketsOld to nPackets in the path makes the predicate (nPackets!=npacketsOld) false. Since the path does not contain the assignment statement nPackets++ (since the path avoids the call to KeReleaseSpinLock inside the loop), the predicate still will be false at the end of the loop. However, in order to reach the second call to KeAcquireSpinLock, the path requires the predicate (nPackets != npacketsOld) to be true. This contradiction is easily detected using symbolic analysis. Now, Abstract constructs the second Boolean program (see Figure <ref type="figure">7</ref>), which has a new Boolean variable b2 to track the state of the predicate (nPackets!=npacketsOld). The conditional of the do-while is refined from SdvMakeChoice() to (b2) and two assignment statements now appear in the Boolean program. The first assignment statement is b2=false which captures the effect of the statement nPacketsOld = nPackets on the predicate of interest. The increment statement nPackets++ translates to the statement b2=!b2?true:SdvMakeChoice() which captures the fact that if nPacketsOld!=nPackets is false before the assignment statement nPackets++ then the predicate nPacketsOld!=nPackets must be true afterwards.</p><p>Executing the Check module on the refined Boolean program establishes that it cannot execute the error function. That is, all false error paths have been eliminated and no true error paths have been found. Put another way, SDV has established that the lock is held at the end of the dowhile loop if and only if nPacketsOld==nPackets. So, if the lock is held then the loop terminates and KeReleaseSpinLock is called. Otherwise, the lock is not held and the loop iterates, calling KeAcquireSpinLock once more.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">AN EXAMPLE ERROR FROM THE WIN-DOWS PARALLEL PORT DRIVER</head><p>The previous section showed how SDV can validate that a piece of code obeys an API usage rule. This section shows a real error in a shipping Windows device driver that was not found until SDV was applied to the driver. The parallel port device driver used in Windows XP is a variation of a device driver that was originally developed for Windows NT (on which Windows XP is based). This device driver is available as a sample in the Windows device driver development kit (DDK). It consists of 24536 lines of C code. The error was introduced when the device driver was updated to support plug-and-play. The error survived code reviews and extensive testing and was not found until SDV was applied to the driver.</p><p>The error was found when checking a SDV rule called doublecompletion which ensures that device driver dispatch routines do not call the kernel-level API IoCompleteRequest more than once on the same I/O request packet pointer. The meaning of IoCompleteRequest is akin to free in C. This function frees up the space pointed to by a pointer to a request packet. This space may be re-allocated and passed to another thread in the system. For this reason, calling IoCompleteRequest again on the same parameter I/O request packet can have disastrous consequences to the sys-  On the 126 WDM drivers, SDV reported 206 defects, of which we have carefully investigated 65 to date. We double checked the results of our investigation with the developers who own and maintain the driver code. Of the 65 defects, 53 were true errors and 12 were false errors. Of the 60 rules packaged into SDV, all the defects were found from 40 rules. The other 20 rules are able to find injected defects but did not find any defects in the drivers analyzed.</p><p>We also have developed over 40 rules for a new driver API called Kernel-Mode Driver Framework (KMDF). KMDF implements the fundamental features required for kernel mode drivers, including complete support for plug-and-play, power management, I/O queues, DMA, and synchronization. Rule development for SDV influenced some KMDF design decisions, helped clarify coding patterns for drivers that KMDF is promoting, and made those design decisions precise by specifying them as API usage rules. For example, by writing rules that check request completion and cancellation of requests in the driver, some inconsistencies and ambiguities in the design have been discovered and corrected.</p><p>We applied SDV to 20 KMDF sample drivers, including a disk driver, a serial device driver that supports power man-  agement, as well as drivers for 1394, mouse, keyboard, PCI, modem and video. The sample drivers were written by the team that is developing KMDF by converting existing DDK samples. The code for the samples was reviewed by several independent experts. On these 20 drivers, SDV reported 18 defects, all carefully investigated together with the driver owners. Out of 18 defects found, 12 have been confirmed to be real errors in the drivers and have been corrected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">True Errors</head><p>The following is a brief summary of some of the true errors that SDV found in the 126 device drivers:</p><p>• In one particular path the device driver is marking I/O request packet pending with a kernel API, but is forgetting to also mark it pending by setting a flag in the data structure (the value of the flag is checked at the end of the dispatch routine by the SDV rule).</p><p>• The driver's dispatch routine is returning the return value STATUS PENDING but has declared the I/O request packet as completed with IoCompleteRequest</p><p>• The driver is calling IoStartNextPacket from within its StartIo routine, which can lead to recursion that exceeds the stack space.</p><p>• Early in the execution the device driver is calling an API that can raise the interrupt request level of the thread, and then (much later) is calling another kernel API that should not be called when the interrupt request level is raised due to the fact that it touches paged data.  • The driver is detaching a device object from the device stack when handling a IRP MN SURPRISE REMOVAL I/O request packet.</p><p>• Upon a driver exiting, an acquired resource is not released (for example, the rules ZwRegistryOpen and CancelSpinLock found such errors).</p><p>Figure <ref type="figure" target="#fig_3">13</ref> provides some details about the true errors that were found in the 26 DDK sample drivers. In the figure, "# functions" is the number of C functions from the device driver and OS environment model that occur in the path; "# steps" indicates the number of assignments, conditional checks, function calls or function returns that occured in the error path. These numbers show that the error paths are interprocedural in nature, spanning a good number of procedures in both the driver and OS model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">False Errors</head><p>The three most common causes for false errors found by SDV are deficiencies in: (1) the C model of the Windows kernel routines; (2) the API usage rules; (3) the harness that calls the dispatch routines. Few false errors have been attributed to SDV's analysis engine.</p><p>Let us address each of these problem areas in turn. First, our C model of the kernel is written by hand rather than derived automatically from analysis of the kernel. This model has been kept as simple as possible for the set of rules SDV checks. However, sometimes we abstract away too much from the state of the kernel. As a result, there may be correlations between two calls to the kernel that SDV misses. This typically results in false errors, which lead us to refine the kernel model. Second, the kernel APIs for plug-and-play and power management are quite complex, with many corner cases. The rules for these APIs were hard to get right. Often, kernel experts in these areas would disagree with one another about subtle points in the rules. As a result, we would develop a rule and have to iterate many times with the experts, showing them errors found by SDV and then refining the rules if the errors were false. This took a tremendous amount of time and energy.</p><p>Third, the harness only tries a limited set of execution sequences of dispatch routines (see Section 3). Suppose that a device driver programmer knows that a certain dispatch routine will always be called before others and sets up important invariants that the later dispatch routines depend on. If this sequence is not encoded in the harness, false errors may result. Unfortunately, it is too expensive to sequentially execute all possible interleavings of the dispatch routines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Performance of SDV</head><p>We now present results about the performance of SDV on the 26 drivers from the DDK on the 64 rules supplied with SDV. (These runs were performed on a Pentium 3.06 GHz dual processor machine with hyper-threading and 2Gb of RAM.) There are a total of 1664 separate checks (checking a driver against a rule) performed. Of these checks, 885 Of the 717 checks in which the model checking engine ran and completed with a definite result ("Pass" or "Error"), it iterated 5.63 times on average with a standard deviation of 11.21 iterations. That is, on average, five false errors (infeasible error path) were encountered and eliminated before the engine was able to complete a proof or find a feasible error path through the device driver. The median number of iterations is two, which deviates substantially from the average. That is, about half of the runs require only one iteration. The average run-time of the 717 checks is 101 seconds with a standard deviation of 267 seconds and a median run-time of 17 seconds. There is a substantial variation in run-time because the introduction of each new predicate by refinement doubles the potential state space to be explored. The average peak memory consumption of SDV over these checks was 30.5Mb. Generally, SDV runs effectively in under half a gigabyte of memory (though in certain situations it can become a memory hog if the binary decision diagram data structures used by the Check module blow-up in size).</p><p>In Section ??, we postulated that API usage rules could be checked in device drivers by tracking a relatively small amount of state when compared to the entire state of the device driver. To demonstrate this we collected data about the number of predicates generated when checking the rules over the DDK device drivers. These statistics were collected only in the cases where the API usage rule was actually applicable to the driver. Figure <ref type="figure" target="#fig_2">14</ref> shows that, on average, eight predicates (Boolean variables) are needed at each program location during SDV's analysis. This is well within the scope of the model checking technology that SDV uses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">DISCUSSION</head><p>We now discuss some of the ways in which SDV could be extended to increase its applicability, precision and efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Memory Safety</head><p>When SDV says that a driver passes a rule, this is a guarantee that the tool is able to make after examining all the code paths. However the guarantee comes with some caveats. The soundness of SDV depends critically on the assumption that the device driver does not have wild pointers. That is, SDV does not check for the memory safety of a device driver, but assumes it. Another analysis (see for example CCured <ref type="bibr" target="#b44">[41]</ref>) is needed to discharge the assumption of memory-safe behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Concurrency with Shared Memory</head><p>SDV currently analyzes each device driver in isolation with a sequential semantics, whereas in reality device drivers execute in the multi-threaded environment of the operating system. While many SDV's rules are motivated by concurrency issues, since SDV only analyzes one thread at a time it will miss errors that only are exhibited in the presence of more than one thread. That is, SDV does not detect errors that result from the interleavings of multiple threads. A new tool Kiss <ref type="bibr" target="#b45">[42]</ref> has been developed on top of SDV to find some classes of concurrency errors. Kiss is not sound (i.e. if Kiss reports that no race conditions have been found this does not guarentee that no race conditions exist). We are also investigating sound methods of supporting multiple threads in SDV through extensions to the Check module <ref type="bibr" target="#b22">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Integer and Bit-level Operations</head><p>SDV uses an automatic theorem prover <ref type="bibr" target="#b4">[2]</ref> to implement symbolic simulation of C programs in its Refine module. This theorem prover (and provers like it, such as Simplify <ref type="bibr" target="#b31">[28]</ref>) treat numbers as unbounded integers, rather than fixedwidth bitvectors. This can lead to cases where SDV reports both false errors and also misses errors (in cases where the error is due to overflow).</p><p>Furthermore, bit-level operations are treated as uninterpreted functions, which means that SDV may produce additional false errors. Because we have not included rules that rely on the values of bitwise operations, we find that few false errors can be attributed to our approximate modeling of bit vector operations, but this is an area for improvement. See <ref type="bibr" target="#b19">[17,</ref><ref type="bibr" target="#b20">18,</ref><ref type="bibr" target="#b21">19]</ref> for recent work on this subject.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Liveness and Termination</head><p>It would be nice to show that a driver always makes progress. For example, we would like to show that when given an I/O request packet, a driver eventually will cancel or complete the packet. However, such a progress property is not a safety property but a liveness property. SDV currently does not support analysis of such properties. See <ref type="bibr" target="#b12">[10,</ref><ref type="bibr" target="#b24">21,</ref><ref type="bibr" target="#b25">22]</ref> for recent work in this area.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Supporting Binary-level Analysis</head><p>SDV is a source-level tool, meaning that bugs introduced during compilation will be missed. In principle we could adapt SDV for use on binaries, perhaps using techniques described in <ref type="bibr" target="#b33">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">Scaling SDV</head><p>There are a number of dimensions to scaling SDV. One is to get SDV to run efficiently on larger drivers. Work in the BLAST project has shown how to greatly increase the efficiency of the abstract-check-refine loop through the use of incremental analysis <ref type="bibr" target="#b38">[35]</ref> and better predicate generation <ref type="bibr" target="#b37">[34]</ref>. We also have found that SDV performs many refinements because its pointer analysis <ref type="bibr" target="#b28">[25]</ref> is not field-sensitive. We believe that replacing SDV's pointer analysis with a fieldsensitive one would greatly decrease the number of calls to the Refine module and increase SDV's efficiency.</p><p>Another challenge related to scaling is to develop API usage rules for other driver models. As we have mentioned above, KMDF is a new driver model that we have developed rules for. But there are many legacy driver models supported by Windows, including networking, storage, audio, display, etc. Each of these "models" is a library that abstracts away from the WDM driver model but has its own set of rules. It is an open question of how to scale rule development in the face of a large number of APIs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSION</head><p>Device drivers provide the mechanism by which any developer can add functionality into the Windows kernel. But kernel-level modules are hard to develop, and hard to test. SDV is an automatic tool that attempts to prove the correctness of these device drivers with respect to a set of kernel API usage rules. It has been used to find a number of deep and hard-to-reproduce errors within device drivers for the Windows operating system, including those that are distributed as a part of the Windows driver development kit.</p><p>Like a dataflow analyzer, SDV analyzes all code paths. However, it uses iterative refinement to greatly reduce false errors. This iterative refinement, also known as counterexampleguided abstraction refinement, distinguishes SDV from other dataflow analysis tools that do not perform refinement. Perhaps surprisingly, even though the analysis engine can produce false errors in theory, in practice we find that all the false errors were inaccuracies either in the rules or in the environment model, and we continually refine both the rules and the environment model whenever we notice such false errors.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: (a) An API usage rule for spin locks, (b) its compilation into C code and (c) its corresponding Boolean program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Locking rule with watch and guard annotations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: SDV's model of the kernel routine IoAllocateAdapterChannel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Summaries of some of the API usage rules included with SDV.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: SDV's analysis engine's architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 (</head><label>6</label><figDesc>b) shows the instrumented version of the code from Figure 6(a). Note that calls to the appropriate functions (from Figure 1(b)) are introduced at labels A, B, and C in Figure 6(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Figure 1(b) to the Boolean program code in Figure 1(c</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: (a) A sample of device driver code P , (b) instrumented code P ′ that checks proper use of spin locks, and (c) initial Boolean program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Source code from fdoClose.c in Parallel port device driver</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Source code from util.c in Parallel port device driver</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: The 26 drivers from the Windows DDK.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Checks that returns of STATUS PENDING and IoMarkIrpPending are correlated.Checks that plug-and-play I/O request packets are passed on to the lower driver in the stack if one exists.</figDesc><table><row><cell>Rule</cell><cell>Summary</cell><cell></cell><cell>Rule</cell><cell>Summary</cell></row><row><cell>adddevice</cell><cell cols="2">Checks that a driver's AddDevice routine calls certain key APIs.</cell><cell>pendedcompletedrequest</cell><cell>Checks STATUS PENDING if IoCompleteRequest has been that drivers do not return called.</cell></row><row><cell>cancelspinlock</cell><cell cols="2">Checks that cancel spinlocks are locked and unlocked in strict alternation.</cell><cell></cell><cell></cell></row><row><cell>criticalregions</cell><cell cols="2">Checks for certian common problems when using critical regions.</cell><cell></cell><cell></cell></row><row><cell>danglingdeviceobjref</cell><cell>Checks ObDereferenceObject that IoGetAttachedDeviceReference. the after driver</cell><cell>calls calling</cell><cell>pnpsamedeviceobject pnpsurpriseremove</cell><cell>Checks that IoAttachDeviceToDeviceStack is called with an appropriate device object. Ensure that drivers do not detach or delete on IRP MN SURPRISE REMOVAL I/O request packets.</cell></row><row><cell>doublecompletion</cell><cell cols="2">Checks that drivers do not complete an I/O request packet twice with IoCompleteRequest.</cell><cell>queuedspinlock</cell><cell>Checks that queued spinlocks are locked and unlocked in strict alternation.</cell></row><row><cell cols="3">exclusiveresourceaccess Checks for common problems with exclusive resource access.</cell><cell>spinlock</cell><cell>Checks that spinlocks are locked and unlocked in strict alternation.</cell></row><row><cell>forwardedatbadirql</cell><cell cols="2">Checks that I/O request packets that are forwarded to other drivers at the wrong interrupt request level</cell><cell>spinlocksafe</cell><cell>Checks for specific deadlock cases with spinlocks</cell></row><row><cell>irpprocessingcomplete</cell><cell cols="2">Checks that dispatch routines completely process I/O request packets.</cell><cell>startiocancel</cell><cell>Checks for cancellation races.</cell></row><row><cell>irql*</cell><cell cols="2">Many rules checking that functions are called at correct levels of interrupt request level.</cell><cell>startiorecursion</cell><cell>Checks for potential recursion in StartIo routines. Checks that dispatch routine call</cell></row><row><cell></cell><cell cols="2">Checks that, if a driver calls another driver</cell><cell>targetrelationneedsref</cell><cell>ObReferenceObject on pointers returned by an-other dispatch routine from a TargetRelation</cell></row><row><cell>lowerdriverreturn</cell><cell cols="2">routine returns the same status that was that is lower in the stack, then the dispatch</cell><cell></cell><cell>plug-and-play I/O request packet.</cell></row><row><cell>markingqueuedirps</cell><cell cols="2">returned by the lower driver. packets as pending while queuing them. Checks that drivers mark I/O request</cell><cell>wmicomplete</cell><cell>Checks that dispatch routines do not return without completing a WMI I/O request packet.</cell></row><row><cell></cell><cell></cell><cell></cell><cell>wmiforward</cell><cell>Checks that dispatch routines do not re-turn without forwarding WMI I/O request packets with disposition IrpForward.</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">• calling the driver's StartIo routine</cell></row></table><note><p>markirppending pnpirpcompletion</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>). Because state is a global variable and we wish to track the state of the predicate (state==Locked), Abstract introduces a global Boolean variable b1 to track this predicate. The variable is initialized to false because the variable state is initialize to Unlocked. The translation of the other statements is straightforward, as the state variable already is acting as a Boolean variable. (We will see a more complicated example of abstraction soon.) The predicates (state ==Locked) and !(state==Locked) are translated to (b1) and (!b1), as expected.</figDesc><table /><note><p>Now, let's consider the translation of the C code of Figure 6(b) to the Boolean program code of Figure</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>•</head><label></label><figDesc>IoCompleteRequest is being called while holding a spinlock, which can cause deadlock.</figDesc><table><row><cell>Driver</cell><cell>Lines of Code</cell></row><row><cell>src/vdd/dosioctl/krnldrvr</cell><cell>304</cell></row><row><cell>src/general/tracedrv/tracedrv</cell><cell>337</cell></row><row><cell>src/general/ioctl/sys</cell><cell>556</cell></row><row><cell>src/input/moufiltr</cell><cell>678</cell></row><row><cell>src/general/cancel/sys</cell><cell>702</cell></row><row><cell>src/input/kbfiltr</cell><cell>753</cell></row><row><cell>src/general/cancel/startio</cell><cell>760</cell></row><row><cell>src/general/event/sys</cell><cell>760</cell></row><row><cell>src/kernel/mca/imca/sys</cell><cell>803</cell></row><row><cell>src/general/toaster/toastmon</cell><cell>1010</cell></row><row><cell>src/wdm/1394/driver/1394diag</cell><cell>1923</cell></row><row><cell>src/wdm/1394/driver/1394vdev</cell><cell>1958</cell></row><row><cell>src/storage/filters/diskperf</cell><cell>2110</cell></row><row><cell>src/network/modem/fakemodem</cell><cell>2324</cell></row><row><cell>src/wdm/hid/gameenum</cell><cell>2797</cell></row><row><cell>src/general/toaster/bus</cell><cell>3633</cell></row><row><cell>src/kernel/serenum</cell><cell>4430</cell></row><row><cell>src/general/toaster/func</cell><cell>4755</cell></row><row><cell>src/input/mouclass</cell><cell>5042</cell></row><row><cell>src/storage/fdc/flpydisk</cell><cell>5074</cell></row><row><cell>src/input/kbdclass</cell><cell>5316</cell></row><row><cell>src/input/mouser</cell><cell>5476</cell></row><row><cell>src/storage/fdc/fdc</cell><cell>7101</cell></row><row><cell>src/input/pnpi8042/daytona</cell><cell>15398</cell></row><row><cell>src/kernel/serial</cell><cell>23197</cell></row><row><cell>src/kernel/parport</cell><cell>24536</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>So, we see that SDV is able to automatically prove that the majority of checks pass (1546/1664 = .93). Of the remaining 118 checks, SDV found 32 errors, failed in 26 cases and timed out in 64 cases with no definite result (a check times out after 2000 seconds = 33.33 minutes). The failure cases are broken into two categories: Abstraction failures are when the tool is unable to eliminate a known false error path. These account for 24 checks. Tool failures are undiagnosed errors in the SDV tool.</figDesc><table><row><cell>Avg. total predicates in scope</cell><cell>8.012</cell></row><row><cell>Avg. global predicates</cell><cell>6.194</cell></row><row><cell cols="2">Avg. min. local predicates per function 0.938</cell></row><row><cell cols="2">Avg. max. local predicates per function 4.550</cell></row><row><cell cols="2">Figure 14: Averages regarding predicates generated</cell></row><row><cell cols="2">during checking of 26 DDK sample drivers.</cell></row><row><cell cols="2">trivially pass because the error routine is not reachable in</cell></row><row><cell cols="2">the call graph of the instrumented program (see Figure 5</cell></row><row><cell cols="2">and Section 5). The remaining checks break down into the</cell></row><row><cell>following categories:</cell><cell></cell></row><row><cell>Pass</cell><cell>661</cell></row><row><cell>Error found</cell><cell>32</cell></row><row><cell>Abstraction failure</cell><cell>24</cell></row><row><cell>Tool failure</cell><cell>2</cell></row><row><cell>Timeout</cell><cell>64</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We will refer to Slam as SDV's analysis engine throughout the remainder of the article</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank Nar Ganapathy, Bob Rinne, Rob Short, Jim Larus, Adrian Oney, Amitabh Srivastava, and Peter Wieland for their support of the SDV project.</p></div>
			</div>


			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EXPERIMENTAL RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Errors Found</head><p>We first present the results of applying SDV to 126 WDM drivers. This sample includes 26 DDK samples (see Figure <ref type="figure">12</ref>) and 100 other kernel-mode drivers obtained from various sources (ranging in size from 48 to 130,000 lines of code with an average size of 12,000 lines of code). The set includes device drivers for basic ports, storage, USB, 1394-interface, mouse, keyboard, PCI battery and file system filters. These drivers were verified together with DLLs (so called "export drivers") they utilize. A total of twenty DLLs were involved. All these 126 drivers have been in use for many years. They are very well tested and have been code reviewed by Windows kernel experts. Additionally, the sources of the 26 DDK sample drivers have been open and available to anyone in the world for over five years. Thus, we did not expect to find many errors in these drivers.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Figure <ref type="figure">8</ref> displays a simplified version of the rule. This rule is then checked over each dispatch routine found in the device driver, where the first parameter to the dispatch routine is a global variable defined in the harness as SdvHarnessIrp. The rule defines one event: the calling of the kernel function IoCompleteRequest. During SDV's analysis, if it is exploring a path through which there are calls to the function IoCompleteRequest, then the code presented with this event in Figure <ref type="figure">8</ref> will be executed.</p><p>In order to demonstrate this example error we have included the relevant code from the driver in Figures <ref type="figure">9,</ref><ref type="figure">10</ref>, and 11. The key steps in the path found by SDV are as follows:</p><p>• The environment (the OS, or possibly another driver) calls the parallel port device driver's close dispatch routine, which is called PptDispatchClose (Fig.  • PptDispatchClose calls PptFdoClose (Fig. <ref type="figure">10,</ref><ref type="figure">line 4</ref>).</p><p>• PptFdoClose enters the conditional statement at line 19 in Fig. <ref type="figure">10</ref> and calls P4CompleteRequest (Fig. <ref type="figure">11</ref>, line 1775). P4CompleteRequest calls the kernel API IoCompleteRequest on a pointer which aliases the value of Irp from Figure <ref type="figure">9</ref> and returns to the call site.</p><p>• PptFdoClose (Fig. <ref type="figure">10</ref>) leaves the conditional statement via the goto on line 26. At line 63, PptFdoClose calls P4CompleteRequestReleaseRemLock (Fig. <ref type="figure">11</ref>, line 1790).</p><p>• P4CompleteRequestReleaseRemLock calls the function P4CompleteRequest, which makes the second call to IoCompleteRequest on a pointer that aliases Irp from Figure <ref type="figure">9</ref>.</p><p>Why wasn't this error previously detected by concrete execution tools or static analysis tools? Triggering it in real life requires putting the parallel port device driver into a state where it is handling a close request from the operating system while the user simultaneously physically removes the parallel port from the computer (via the removal of a laptop from a docking station, for example). This scenario is difficult to realize via testing. Furthermore, the static analysis required to find this error involves interprocedural program analysis and careful tracking of pointer relationships (to ensure that IoCompleteRequest is called twice on the same pointer value)-without this tracking a static analysis will report too many false errors.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">prevent rollover -strange as it may seem, it is perfectly 49 // legal for us to receive more closes than creates -this 50</title>
		<imprint/>
	</monogr>
	<note>PnP himself 51 // 52 if( ((LONG)InterlockedDecrement(&amp;fdx-&gt;OpenCloseRefCount)) &lt; 0 ) { 53 // handle underflow 54 InterlockedIncrement(&amp;fdx-&gt;OpenCloseRefCount</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">59 target_exit: 60 61 DD((PCE)fdx,DDT</title>
		<idno>PptFdoClose -.......</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">63 return P4CompleteRequestReleaseRemLock</title>
		<imprint/>
	</monogr>
	<note>Irp, STATUS_SUCCESS, 0, 64 &amp;fdx-&gt;RemoveLock</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Refining approximations in software predicate abstraction</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 04: Tools and Algorithms for the Construction and Analysis of Systems</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="388" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automatic theorem proving for predicate abstraction refinement</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Lahiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><surname>Zapato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 04: Computer-Aided Verification</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="457" to="461" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatic predicate abstraction of C programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 01: Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="203" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">From symptom to cause: Localizing errors in counterexample traces</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 03: Principles of programming languages</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="97" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Boolean and cartesian abstractions for model checking C programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 01: Tools and Algorithms for Construction and Analysis of Systems</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="268" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On the relative completeness of abstraction refinement</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 02: Tools and Algorithms for Construction and Analysis of Systems</title>
		<imprint>
			<date type="published" when="2002-04">April 2002</date>
			<biblScope unit="page" from="158" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Bebop: A symbolic model checker for Boolean programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN 00: SPIN Workshop</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="113" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatically validating temporal safety properties of interfaces</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN 01: SPIN Workshop</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="103" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Bebop: A path-sensitive interprocedural dataflow engine</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PASTE 01: Workshop on Program Analysis for Software Tools and Engineering</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="97" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Linear ranking with reachability</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bradley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sipma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 05: Computer-Aided Verification</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="491" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Graph-based algorithms for boolean function manipulation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Bryant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers, C</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="677" to="691" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A static analyzer for finding dynamic programming errors</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Bush</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Pincus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Sielaff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software-Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="775" to="802" />
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Modular verification of software components in c</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Groce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE 03: International Conference on Software Engineering</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="385" to="395" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Model checking one million lines of c code</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS 04: Network and Distributed System Security Symposium</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An empirical study of operating systems errors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP 01: Symposium on Operating System Principles</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="73" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Counterexample-guided abstraction refinement</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 00: Computer Aided Verification</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="154" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Predicate abstraction of ANSI-C programs using SAT</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yorav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design (FMSD)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="105" to="127" />
			<date type="published" when="2004-11">September-November 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Using Stalmårck&apos;s algorithm to prove inequalities</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gonthier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFEM 05: Conference on Formal Engineering Methods</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="330" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Cogent: Accurate theorem proving for program verification</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 05: Computer-Aided Verification</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="296" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Symbolic model checking for asynchronous boolean programs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m">SPIN 01: SPIN Workshop</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="75" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Abstraction refinement for termination</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS 05: Static Analysis Symposium</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="87" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Termination proofs for systems code</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 06: Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Abstract interpretation: a unified lattice model for the static analysis of programs by construction or approximation of fixpoints</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 77: Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The ASTRE É analyzer</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Feret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mauborgne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miné</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Monniaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP 05: European Symposium on Programming</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="21" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Unification-based pointer analysis with directional assignments</title>
		<author>
			<persName><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 00: Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="35" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">ESP: Path-sensitive program verification in polynomial time</title>
		<author>
			<persName><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Seigle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 02: Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="page" from="57" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Enforcing high-level protocols in low-level software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 01: Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="59" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Simplify: A theorem prover for program checking</title>
		<author>
			<persName><forename type="first">D</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<idno>HPL-2003-148</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>HP Labs</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Checking system rules using system-specific, programmer-written compiler extensions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI 00: Operating System Design and Implementation</title>
		<imprint>
			<publisher>Usenix Association</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Model checking x86 executables with CodeSurfer/x86 and WPDS++</title>
		<author>
			<persName><forename type="first">G</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 05: Computer-Aided Verification</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Extended static checking for java</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lillibridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 02: Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="234" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Safe hardware access with the Xen virtual machine monitor</title>
		<author>
			<persName><forename type="first">K</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Neugebauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Warfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OASIS&apos;04: Workshop on Operating System and Architectural Support for the on demand IT InfraStructure</title>
		<imprint>
			<date type="published" when="2004-06">June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A system and language for building system-specific, static analyses</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 02: Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="69" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Abstractions from proofs</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 04: Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="232" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Lazy abstraction</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sutre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 02: Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="2002-01">January 2002</date>
			<biblScope unit="page" from="58" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Kurshan</surname></persName>
		</author>
		<title level="m">Computer-aided Verification of Coordinating Processes</title>
		<imprint>
			<publisher>Princeton University Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Predicate abstraction via symbolic decision procedures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lahiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 05: Computer-Aided Verification</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="24" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Proving the correctness of multiprocess programs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="125" to="143" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
	<note>SE-</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Righting software</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pincus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatapathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="92" to="100" />
			<date type="published" when="2004-06">May/June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">An extended static checker for Modula-3</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CC 98: Compiler Construction</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="302" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">CCured: Type-safe retrofitting of legacy code</title>
		<author>
			<persName><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 02: Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="2002-01">January 2002</date>
			<biblScope unit="page" from="128" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">KISS: keep it simple and sequential</title>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 04: Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="14" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Enforceable security policies</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="50" />
			<date type="published" when="2000-02">February 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Improving the reliability of commodity operating systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP 03: Symposium on Operating System Principles</title>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
			<biblScope unit="page" from="207" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">An automata theoretic apporach to automatic program verification</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS 86: Logic in Computer Science</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="332" to="344" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
