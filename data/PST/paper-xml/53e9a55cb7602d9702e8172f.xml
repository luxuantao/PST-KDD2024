<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Energy Efficient Data Management for Wireless Sensor Networks with Data Sink Failure</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Hyunyoung</forename><surname>Lee</surname></persName>
							<email>hlee@cs.du.edu</email>
						</author>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Klappenecker</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Texas A&amp;M University</orgName>
								<address>
									<postCode>77843-3112</postCode>
									<settlement>College Station</settlement>
									<region>TX</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kyungsook</forename><surname>Lee</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Lan</forename><surname>Lin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Gaylord</forename><surname>St</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Denver</orgName>
								<address>
									<postCode>80208</postCode>
									<settlement>Denver</settlement>
									<region>CO</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Energy Efficient Data Management for Wireless Sensor Networks with Data Sink Failure</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">88EA77E3377D6A0D0338954EEBBA6C2A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:03+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper proposes an energy efficient protocol for sensor data management. The protocol employs replicated data sinks to achieve (1) resiliency to data sink failure, and (2) efficiency in storing and retrieving sensor data. A simple address assignment scheme is introduced that partitions the sensor field into cells, where each cell contains one data sink and all sensors that are closest to this data sink. It is shown that this scheme is scalable and resilient against data sink and sensor node failures. Furthermore, the scheme has a reasonably low message complexity and a high energy efficiency.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>There is an upsurge of interest in wireless sensor networks, since they have many important applications in everyday life, ranging from monitoring and detection to space exploration. In this paper, we propose an energy efficient protocol for storing and retrieving sensor data. Our protocol provides fault-tolerance in the presence of data sink and sensor failures. As a result, our protocol can maximize the overall life of the sensor network.</p><p>Sensors are usually very simple units that are equipped with a sensing functionality. As indicated by Moore's law <ref type="bibr" target="#b16">[17]</ref>, one can expect that wireless sensors become smaller, cheaper, and more powerful. Sensors can even carry out simple computations and communicate with each other.</p><p>However, a wireless sensor node has limited resources since it typically runs on battery power and usually has a very small memory space. Thus, sensing devices must operate under severe resource contraints and one of the foremost goals is to minimize the energy consumption. There-fore, there is a need for an energy-efficient communication scheme to store and retrieve a vast amount of sensor data. Furthermore, in many applications, the sensing devices are placed outdoors, resulting in a vulnerability to various noises and errors. With these characteristics of a wireless sensor network, we consider the following naturally arising questions:</p><p>1. What kind of data storage and retrieval structure in a wireless sensor network is energy-efficient?</p><p>2. How can we make the wireless sensing system faulttolerant, when sensor nodes and data sinks may fail?</p><p>3. How can we achieve scalability in wireless sensor data management so that the sensor system can be easily expanded by deploying new sensors and even adding new data sinks?</p><p>As an effort to answer these questions, we designed a protocol based on ideas inspired by de Bruijn digraphs <ref type="bibr" target="#b0">[1]</ref> and Voronoi diagrams <ref type="bibr" target="#b1">[2]</ref>. It is well-known that de Bruijn networks can provide efficient routing among large number of nodes. Our routing scheme imitates certain aspects de Bruijn routing, but is simpler, more flexible, and dynamically reconfigurable. In our scheme, the address of a sensor node already indicates the length of the path to the closest data sink.</p><p>Recall that a countable set P of points in the Euclidean plane R 2 leads to a partition of the plane in terms of Voronoi cells, where each cell contains exactly one point p of P and all points in R 2 that are closer to p than to any other point in P . Inspired by this geometric notion, we partition the sensor network into different cells, where a cell contains one data sink s and any sensor that has a smaller hop count to s than to any other data sink. If a sensor has the same hop-count to two or more data sinks, then we agree that this border node will belong to the cell of each of these data sinks. Figure <ref type="figure" target="#fig_4">2</ref> (c) illustrates this concept.</p><p>By partitioning the sensor network into such cells, we obtain scalability and improve the energy efficiency. If some data sink or sensor node fails, then our protocol dynamically re-assigns the cells to provide resilience against such failures.</p><p>Our communication architecture uses a hybrid model that effectively utilizes a variation of the peer-to-peer communication paradigm among the sensors, and a variation of the client-server paradigm between the sensors and the data sinks. The wireless sensors act as clients in the networked sensor system and the data sinks act as servers. The data sinks process the collected data and return feedback control data to the sensor nodes.</p><p>The remainder of this paper is structured as follows. In Section 2, we discuss related work and give some background on de Bruijn digraph routing. In Sections 3 and 4, we specify the system model and describe our protocol. In Sections 5 and 6, we analyze the properties of our protocol and conclude the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Our work is related to two intertwined themes in wireless sensor networks: routing and data aggregation. Numerous architectures and protocols have been proposed to solve both problems at the same time.</p><p>Our scheme requires an initial flooding of messages in the sensor field to establish the routing paths. This step is somewhat similar to directed diffusion <ref type="bibr" target="#b7">[8]</ref>, a mechanism that uses limited flooding of queries towards events and sets up reverse gradients for the best path. One fundamental difference is that directed diffusion is designed for the single data sink scenario, whereas our protocol can serve multiple data sinks.</p><p>GPSR is an efficient routing scheme that relies on the localized nodes and restricts flooding to a geographical region <ref type="bibr" target="#b9">[10]</ref>. One drawback of this approach, however, is its assumption that the locations of the sensor nodes are known to all nodes in the network. We designed our protocol such that knowledge of locations is not required.</p><p>SHORT is a self-healing, path-and energy-aware routing framework that shows a good performance with the reduced energy costs <ref type="bibr" target="#b4">[5]</ref>. In a path-aware scheme, shorter paths are found by connecting non-adjacent nodes on a path that are within communication range of each other. In an energyaware scheme, a routing path is switched when the energy of the nodes on the path is running low. By letting the neighboring nodes of a route, together with the on-route nodes, monitor the route, up-to-date information of local topology and link quality can be exploited. Our work resembles their approach regarding self-healing and energy-efficiency. In our case, the routing of messages to a data sink is optimal, and we take advantage of shortcuts in peer message routing, though without introducing much overhead.</p><p>Demirbas, Arora, and Mittal <ref type="bibr" target="#b2">[3]</ref> presented a clustering service, called FLOC, that can achieve efficient and scalable control in large-scale ad hoc wireless sensor networks.</p><p>To achieve high energy efficiency and resiliency, rolebased hierarchical self-organized networks are explored in <ref type="bibr" target="#b10">[11]</ref>. Depending on their connectivity and sensing capability, sensor nodes are assigned the role of data collection and data dissemination. Based on certain metrics, the network is partitioned into sensing zones, in which the sensor nodes collaborate to achieve a sensing objective. Like our scheme, this approach relies only on local information. However, as a hierarchy-based architecture, this approach is vulnerable to failures, especially when particular roles are prone to become points of failure. The authors mention that systematic rotation of roles among the nodes can resolve this problem. A periodically repeated role assignment scheme is proposed in <ref type="bibr" target="#b5">[6]</ref>, for Bluetooth-based sensor networks.</p><p>ACQUIRE <ref type="bibr" target="#b12">[13]</ref> is an active query forwarding mechanism in a sensor network. A query packet is forwarded through the network that follows a random or guided path. At each step, a node, upon receiving a query, performs an update to gather data from all of its neighbors within a lookahead of d steps. As this query progresses through the network, it is gradually resolved into smaller components until it is completely solved and is returned back to the querying node. This approach works at its best for one-shot, nonaggregate, complex queries for replicated data.</p><p>TAG is a high-level abstraction of a declarative interface for data collection and aggregation in wireless sensor networks of TinyOS motes <ref type="bibr" target="#b11">[12]</ref>. It realizes a distributed query aggregation scheme that is sensitive to resource constraints and can cope with lossy communication of wireless sensor networks.</p><p>Finally, we should mention mobile agent based systems, such as <ref type="bibr" target="#b15">[16]</ref>, where agents exchange data with nearby sensors or access points that they encounter as they pass by. The advantage of such an approach is that less infrastructure is required than in other methods and that there is no overhead caused by packet routing. When the density of mobile agents is sufficiently high, the system is more robust than a fixed network. The primary drawback of such a system is that the latency is high, so it is not suitable for all applications. Unexpected failures such as loss of mobile agents or limitations on mobility can compromise the fault-tolerance of such a system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">De Bruijn Digraphs</head><p>We recall the basics of de Bruijn digraphs, see <ref type="bibr" target="#b0">[1]</ref> for details. Routing in such graphs is a well-studied problem, see, for instance, the references <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b17">18]</ref>.</p><p>Let h and k be integers ≥ 2. The de Bruijn digraph B(h, k) has vertex set V = {0, 1, . . . , h -1} k , and there is an edge from vertex a = (a 1 , . . . , a k ) to vertex b = (b 1 , . . . , b k ) if and only if a i = b i+1 for all i in the range</p><formula xml:id="formula_0">1 ≤ i ≤ k -1.</formula><p>Thus every vertex has an out-degree of h, and the diameter of B(h, k) is equal to k. Figure <ref type="figure" target="#fig_1">1</ref>   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">System Model and Assumptions</head><p>Let W (t, n) denote a wireless sensor network with t replicated data sinks D = {d 1 , . . . , d t }, and n sensors S = {s 1 , . . . , s n }. The data sinks are sensor-oblivious, which means that a sensor can store and retrieve data to and from any data sink. We assume that the t data sinks are reasonably regularly deployed over the sensor field.</p><p>We make the following assumptions about the cost for an interaction between a data sink and a sensor.</p><p>• The cost (energy consumption) of storing and retrieving data is the same at every data sink.</p><p>• The cost of sending and receiving data to and from a data sink can be computed by the hop count in the routing path to the data sink times a fixed cost per hop.</p><p>Each sensor tries to minimize the cost of storing and retrieving data by communicating with the nearest data sink, where the distance from a sensor to a data sink is measured in terms of hop counts. It follows that the sensor network is partitioned into cells such that the sensors in the same cell communicate with the same data sink. We call the nodes on the border of two or more cells "border nodes". We assume that unique identifiers (ID) are given to data sinks. We also assume that every sensor node has a unique identifier, such as a MAC address. There is no functional difference among data sinks, that is, they all act as final data storage and gateway to the outside networks. Data can be sent to any of the data sinks as long as the data sink is alive.</p><p>We assume that the wireless sensor nodes as well as the data sinks are stationary, i.e. not mobile. We also assume that the data sink servers know the total number n of sensor nodes, and that only a subset of the sensors are within onehop range from the data sinks (if all the sensors are within a radio range from the data sinks, then there is no need for routing).</p><p>The wireless signal (message) that a sensor node sends is broadcast within the radio range, that is, every node within the radio range of a sensor node i will hear the messages broadcast by i. Delivering a message requires more processing power than receiving a message. Therefore, in the design of our protocol, we try to minimize the redundant delivery of messages without compromizing the faulttolerance in data transmission.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The Protocol</head><p>In this section, we describe our protocol for energyefficient, fault-tolerant data storage and retrieval, without relying on any geographic or physical location information of the sensors as well as the servers. Our protocol uses the five types of messages:</p><p>1. The initialization message (init) is used in the initialization step to assign hop-count based addresses.</p><p>2. The toSink message is used to send a message from a sensor node to the data sink to perform a data storage operation.</p><p>3. The fromSink message is used to broadcast a message from the data sink server to every sensor node. This message carries the ID of the sending data sink. This type of message is used when the server proactively retrieves data from the sensors or when it needs to broadcast control messages to the sensors.</p><p>4. The peer message is used to communicate among the peer sensors.</p><p>5. The nodeFail message is used to inform nodes about a failed node. This type of message is used by successors of a failed node to negotiate new routing paths.</p><p>We first describe how the initial setup is performed, where one or more de Bruijn-style addresses are assigned to each sensor node. Then we illustrate how message routing is performed. Finally, we explain how resilience against node failures is achieved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Initialization</head><p>The data sink servers start the initialization step by a dynamic address assignment procedure. The t data sink servers have addresses 1, . . . , t. Suppose that the data sink server i has h sensors within its one-hop radio range. The data sink server i assigns the h sensor nodes the addresses (i, 0), (i, 1), . . . , (i, h -1). When a sensor node s with h one-hop neighbors receives an address a = (a 1 , a 2 , . . . , a ) from an one-hop neighbor j, then it takes one of the following actions:</p><p>• If s does not have a valid address, then s takes a as its address.</p><p>And it assigns each one-hop neighbor, except j, an address in the range of (a 1 , a 2 , . . . , a , 0), . . . , (a 1 , a 2 , . . . , a , h -2).</p><p>• If s already has a valid address of length , then it keeps a as an alias address. Notice that all aliases of a sensor node have the same length.</p><p>• If s has a valid address of length &gt; , then it deletes all its address aliases and keeps a as a new address. And it once again assigns each onehop neighbor, except j, an address in the range of (a 1 , a 2 , . . . , a , 0), . . . , (a 1 , a 2 , . . . , a , h -2).</p><p>In this way, every sensor node that is reachable from a data sink will receive at least one address. The number of address aliases of a sensor node does not exceed the number of its one-hop neighbors. A sensor node informs its one-hop neighbors about its address aliases. This simple address assignment scheme has some remarkable properties: If a sensor node has an address alias (a 1 , a 2 , . . . , a ), then there is a path of -1 hops to the data sink a 1 , and there is no shorter path to a 1 . This assignment scheme realizes the partitioning into cells. If a node has only address aliases that start with a 1 , then it is within the cell of a 1 . The border nodes are characterized by the fact that they have address aliases that start with different digits.</p><p>An example will be helpful to illustrate the main features of the address assignment. Figure <ref type="figure" target="#fig_4">2</ref> (a) shows a sensor network with three data sinks (that are depicted by black circles) and several sensor nodes (that are depicted by white circles). If two nodes are within radio-range of each other, then there is an edge between these nodes. The result after address assignment is shown in Figure <ref type="figure" target="#fig_4">2 (b)</ref>. Figure <ref type="figure" target="#fig_4">2 (c)</ref> illustrates the subdivision into different cells. Each cell contains a data sink and all sensor nodes that are closer to this data sink than to any other in terms of hop-count. If a sensor node has the same distance from more than one data sink, then it belongs to the cell of each of those data sinks; such nodes are called border nodes. The nodes 120, 230, 310 are examples of such border nodes.</p><p>If a sensor node s has address (a 1 , a 2 , . . . , a -1 , a ), then there exists a node p with address (a 1 , a 2 , . . . , a -1 ). We call p a predecessor of s, and s a successor of p. The as-(a) A sensor network with three data sinks (black nodes) and several sensor nodes (white nodes); an edge between two nodes indicates that the nodes are within radio range.   sociates of s are all one-hop neighbors of s that are neither predecessors nor successors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Routing</head><p>After the addresses have been assigned to the nodes, we can perform routing. The most common type of message is a toSink message from a sensor node to a data sink, which is typically routed through predecessors. Occasionally, a data sink may send fromSink messages to the sensor nodes, which are forwarded through successors. A peer message is routed through any combination of predecessors, associates, and successors.</p><p>• A toSink message is routed by randomly selecting one predecessor; this is done by right-shifting one randomly selected address alias. Then the same process is repeated until the data sink is reached. For instance, one possible path from the address (a 1 , . . . , a ) is through the predecessors (a 1 , . . . , a -1 ), (a 1 , . . . , a -2 ), . . . , (a 1 , a 2 )</p><p>to the data sink a 1 .</p><p>• A fromSink message is broadcast by sending the message from the data sink to its successors, and each sensor node receiving such a message forwards it to all its successors.</p><p>• Suppose that a peer message is sent from a node with address a = (a 1 , . . . , a ) to a node with address b = (b 1 , . . . , b k ). The node a or any node receiving the message forwards it to the one-hop neighbor that has an address alias with the longest common prefix with b; if several one-hop neighbors qualify, then the one with the shortest address alias is chosen. If a data sink = b 1 receives such a message, then it will forward it to the data sink b 1 .</p><p>We remark that the design of the protocol ensures that the routing of the toSink messages is optimal; in a typical sensor network application the toSink messages are by far the most frequent ones, since they are used to communicate the sensor data.</p><p>Peer messages can be used, for example, by a sensor to check whether its sensor readings are reasonable. Although such messages are rare or not used at all in typical sensor network applications, we remark that routing between any two nodes is possible. Let us first look at an example that illustrates this routing rule.</p><p>Example 1 Consider the sensor network given in Figure <ref type="figure" target="#fig_4">2 (c</ref>). Suppose that node 110 wants to send peer message to node 210. Since both neighbors of 110 have an empty common prefix with 210, the message is forwarded to 11, the shorter address alias. Among the neighbors of 11, the node 200 has the longest common prefix with 210, so it is routed there, and node 200 routes the message to 210.</p><p>Example 2 Suppose that node 130 wants to send a peer message to node 210 in the sensor network given in Figure <ref type="figure" target="#fig_4">2 (c</ref>). Then the message is routed through 130 → 13 → 1, then forwarded to data sink 2, and the final hops are 2 → 21 → 210.</p><p>A straightforward routing rule for peer messages could use a sequence of predecessors until the node with the longest common prefix of a and b is reached, from which b can be reached through successors. Our peer message routing rule improves upon this rule by taking shortcuts whenever information about one-hop neighbors reveals such a possibility, as was shown in Example 1. Unlike toSink routing, it should be noted that peer routing is not necessarily optimal; this is the price one has to pay for the very limited memory usage. In view of the fact that peer messages are rare and typically local, this does not appear to be a significant disadvantage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Fault-Tolerance</head><p>The failure of a node has significant impact on its successors and, to some extend, on its associates. Indeed, if a node fails, then its successor nodes might not be able to further deliver their sensor data to a data sink, unless some corrective measures are taken.</p><p>Fortunately, if a sensor node or a data sink fails, then this can be easily detected by a simple acknowledgment scheme. Therefore, we can assume that the one-hop neighbors of a failed node s become aware of the failure of s within a short amount of time. If a node s fails, then its one-hop neighbors take the following action:</p><p>• A predecessor of s informs the data sink that the node s has failed.</p><p>• All associates of s delete the address aliases that belong to s from their lists.</p><p>• All successors of s make their address aliases invalid that have an address alias of s as a prefix, and they send a nodeFail(s) message to their successors.</p><p>Each node receiving a nodeFail(s) message makes its address alias invalid that has s as a prefix, and forwards nodeFail(s) to its succcessors. Basically, the effect of the nodeFail messages is that all nodes that potentially route through s will eliminate this possibility. Data sink failures obviously have the biggest impact. For intance, let us assume that the data sink 3 in Figure <ref type="figure" target="#fig_4">2</ref> fails. The effect is that all addresses of sensor nodes within the cell of data sink 3 become invalid, with the exception of the border nodes, as shown in Figure <ref type="figure" target="#fig_5">3</ref>.</p><p>The impact of sensor node failure is less dramatic, since fewer successors are affected, but the situation does not differ in any essential way.</p><p>If a sensor node t does not have any valid address anymore, then it queries its one-hop neighbors to assign him address aliases. Then t proceeds exactly as in the initial address assignment step; it keeps only the shortest address aliases received, and rejects all others. Figure <ref type="figure" target="#fig_6">4</ref> illustrates the result of these address negotiations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experiments</head><p>Suppose that a sensor network consists of n sensor nodes. Let us assume that every sensor node and every data sink has about d one-hop neighbors, where d n. Given a regular distribution of the sensor nodes, we can safely assume that the diameter of the sensor network is O( √ n). Let us define the message complexity of a sensor network as the number of messages that need to be delivered by the sensor nodes until a message sent from a source node reaches its final destination node.</p><p>The message complexity of a simple flooding scheme is</p><formula xml:id="formula_1">d × n × Ω( √ n) = Ω(dn<label>3</label></formula><p>2 ). In contrast, in our scheme the message complexity for communication between a sensor node and a data sink is at most O( √ n), and for peer messages the message complexity is at most O(2 √ n). We define the fault tolerance of a sensor network to be the probability of messages from any sensor node being successfully stored at any data sink. Therefore, it suffices to find the probability of a network partition.</p><p>We implemented a subset of our protocol to experiment with the expected behavior of a wireless sensor network. The topology we used as the input to the simulator is a √ n × √ n grid of n sensors and a single data sink in the middle. First, we measured the node connectivity by computing the expected number of (non-faulty) sensors that can still communicate with the data sink when k-out-of-n sensors fail, which is shown in Figure <ref type="figure" target="#fig_8">5</ref>.  In a second experiment, we simulated the expected number of hops taken by toSink messages. The result is shown in Figure <ref type="figure" target="#fig_9">6</ref>. The plot shows the average value of n k different scenarios of k-out-of-n failing nodes.</p><p>The simulation results show that in the case of node failures our scheme is able to maintain the connectivity between the nodes and the data sink. At the same time, it maintains a short average path length, as expected. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>We proposed an energy-efficient communication protocol for data storage and retrieval in a wireless sensor network. Our protocol employs replicated data sinks to improve fault-tolerance in the face of data sink failures. We achieve resilience against sensor node and data sink failures through a dynamic re-assignment of addresses and the introduction of alternate paths.</p><p>The most common application in sensor networks is the delivery of sensor data. Our protocol ensures that such messages from the sensor nodes are always routed in an optimal way to the closest data sink using the least possible number of hops. We avoid the overhead of keeping routing tables to accomodate the memory constraints of sensor nodes; a node simply needs to keep the address aliases of itself and of its one-hop neighbors. Furthermore, our protocol does not require any location information. The reasonably low message complexity of our scheme can extend the battery life of each node, maximizing the overall life of the sensor network.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>illustrates the digraph B(2, 2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The de Bruijn digraph B(2,2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Sensor network after address assignment. Some nodes have several address aliases that lead to different routes in toSink messages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Induced partition of the network. All nodes that have an address alias beginning with the same digit belong to the same cell. Border nodes belonging to two different cells are shaded grey.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Address assignment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Failure of data sink 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Re-assignment of addresses after failure of data sink 3 and the induced partition into two cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Expected node connectivity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Average path length.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. The research by H.L. was supported by the University of Denver PROF grant 88197. The research by A.K. was supported by NSF grant CCR-0218582 and NSF CAREER award CCF-0347310.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Extremal Graph Theory with Emphasis on Probabilistic Methods</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bollobás</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>American Mathematical Society</publisher>
			<pubPlace>Providence, RI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Overmars</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Schwarzkopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">FLOC: A fast local clustering service for wireless sensor networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Demirbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Mittal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Dependability Issues in Wireless Ad Hoc Networks and Sensor Networks (DIWANS/DSN)</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Analysis on the redundancy of wireless sensor networks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Int. Workshop on Wireless Sensor Networks and Applications (WSNA)</title>
		<meeting>of Int. Workshop on Wireless Sensor Networks and Applications (WSNA)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="108" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">SHORT: self-healing and optimizing routing techniques for mobile ad hoc networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mohapatra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 4th ACM Int. Symp on Mobile Ad Hoc Networking and Computing (MobiHoc)</title>
		<meeting>of the 4th ACM Int. Symp on Mobile Ad Hoc Networking and Computing (MobiHoc)</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
			<biblScope unit="page" from="279" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">DCP: A new data collection protocol for Bluetooth-based sensor networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Handy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Grassert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Timmermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROMICRO Symposium on Digital System Design</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="566" to="573" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient routing and sorting schemes for de Bruijn networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1157" to="1170" />
			<date type="published" when="1997-11">November 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Directed diffusion: A scalable and robust communication paradigm for sensor networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Intanagonwiwat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th Annual Int. Conf. on Mobile Computing and Networking (MobiCom)</title>
		<meeting>of the 6th Annual Int. Conf. on Mobile Computing and Networking (MobiCom)</meeting>
		<imprint>
			<date type="published" when="2000-08">August 2000</date>
			<biblScope unit="page" from="56" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Koorde: A simple degreeoptimal distributed hash table</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Karger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Int. Workshop on Peer-to-Peer Systems (IPTPS)</title>
		<meeting>of Int. Workshop on Peer-to-Peer Systems (IPTPS)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">GPSR: Greedy perimeter stateless routing for wireless networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Kung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th Annual Int. Conf. on Mobile Computing and Networking (Mo-biCom)</title>
		<meeting>of the 6th Annual Int. Conf. on Mobile Computing and Networking (Mo-biCom)</meeting>
		<imprint>
			<date type="published" when="2000-08">August 2000</date>
			<biblScope unit="page" from="243" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Role-based hierarchical self organization for wireless ad hoc sensor networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kochhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Schwiebert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2nd ACM Int. Conf. on Wireless Sensor Networks and Applications (WSNA)</title>
		<meeting>of the 2nd ACM Int. Conf. on Wireless Sensor Networks and Applications (WSNA)</meeting>
		<imprint>
			<date type="published" when="2003-09">September 2003</date>
			<biblScope unit="page" from="98" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">TAG: a tiny aggregation service for ad-hoc sensor networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th Symp. on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>of the 5th Symp. on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The ACQUIRE mechanism for efficient querying in sensor networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Sadagopan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamachari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Helmy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First IEEE Int. Workshop on Sensor Network Protocols and Applications (SNPA)</title>
		<meeting>of the First IEEE Int. Workshop on Sensor Network Protocols and Applications (SNPA)</meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The de Bruijn multiprocessor network: a versatile parallel processing and sorting network for VLSI</title>
		<author>
			<persName><forename type="first">M</forename><surname>Samatham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pradhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="567" to="581" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">nD-dBPN: New self-routing permutation networks based on the de Bruijn digraphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Samsudin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Y</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1998 Int. Conf. on Parallel Processing</title>
		<meeting>of the 1998 Int. Conf. on Parallel essing</meeting>
		<imprint>
			<date type="published" when="1998-08">August 1998</date>
			<biblScope unit="page" from="604" to="611" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Data MULEs: Modeling a three-tier architecture for sparse sensor networks</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Brunette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First IEEE Int. Workshop on Sensor Network Protocols and Applications (SNPA)</title>
		<meeting>of the First IEEE Int. Workshop on Sensor Network Protocols and Applications (SNPA)</meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Reliability of Computer Systems and Networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shooman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Lightwave networks based on de Bruijn graphs</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">N</forename><surname>Sivarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramaswami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1994-02">February 1994</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
