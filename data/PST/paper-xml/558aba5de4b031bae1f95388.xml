<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Optimizations Enabled by a Decoupled Front-End Architecture</title>
				<funder ref="#_QTPhXwT">
					<orgName type="full">National Science Foundation</orgName>
					<orgName type="abbreviated">NSF</orgName>
				</funder>
				<funder>
					<orgName type="full">Compaq Computer Corporation</orgName>
				</funder>
				<funder ref="#_KPTzz5b">
					<orgName type="full">US National Science Foundation</orgName>
					<orgName type="abbreviated">NSF</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Glenn</forename><surname>Reinman</surname></persName>
							<email>greinman@cs.ucsd</email>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Brad</forename><surname>Calder</surname></persName>
							<email>calder@cs.ucsd</email>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Todd</forename><surname>Austin</surname></persName>
							<email>taustin@eecs.umich.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>San Diego, La Jolla</addrLine>
									<postCode>92093</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<postCode>48109-2122</postCode>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Optimizations Enabled by a Decoupled Front-End Architecture</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note type="submission">received 18 Feb. 2000; revised 16 aug. 2000; accepted 10 Oct. 2000.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Abstract?In the pursuit of instruction-level parallelism, significant demands are placed on a processor's instruction delivery mechanism. Delivering the performance necessary to meet future processor execution targets requires that the performance of the instruction delivery mechanism scale with the execution core. Attaining these targets is a challenging task due to I-cache misses, branch mispredictions, and taken branches in the instruction stream. To counter these challenges, we present a fetch architecture that decouples the branch predictor from the instruction fetch unit. A Fetch Target Queue (FTQ) is inserted between the branch predictor and instruction cache. This allows the branch predictor to run far in advance of the address currently being fetched by the cache. The decoupling enables a number of architecture optimizations, including multilevel branch predictor design, fetch-directed instruction prefetching, and easier pipelining of the instruction cache. For the multilevel predictor, we show that it performs better than a singlelevel predictor, even when ignoring the effects of cycle-timing issues. We also examine the performance of fetch-directed instruction prefetching using a multilevel branch predictor and show that an average 19 percent speedup is achieved. In addition, we examine pipelining the instruction cache to achieve a faster cycle time for the processor pipeline and show that pipelining provides an average 27 percent speedup over not pipelining the instruction cache for the programs examined.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>A T a high level, a modern high-performance processor is composed of two processing engines: the front-end processor and the execution core. The front-end processor is responsible for fetching and preparing (e.g., decoding, renaming, etc.) instructions for execution. The execution core orchestrates the execution of instructions and the retirement of their register and memory results to nonspeculative storage. Typically, these processing engines are connected by a buffering stage of some form, e.g., instruction fetch queues or reservation stations?the frontend acts as a producer, filling the connecting buffers with instructions for consumption by the execution core. This is shown in Fig. <ref type="figure">1</ref>.</p><p>This producer/consumer relationship between the frontend and execution core creates a fundamental bottleneck in computing, i.e., execution performance is strictly limited by fetch performance. The trend toward exploiting more ILP in execution cores works to place further demands on the rate of instruction delivery from the front-end. Without complementary increases in front-end delivery performance, more exploitation of ILP will only decrease functional unit utilization with little or no increase in overall performance.</p><p>In this paper, we focus on improving the scalability and performance of the front-end by decoupling the branch predictor from the instruction cache. A Fetch Target Queue (FTQ) is inserted between the branch predictor and instruction cache, as seen in Fig. <ref type="figure">2</ref>. The FTQ stores predicted fetch addresses from the branch predictor, later to be consumed by the instruction cache. As we will show, the FTQ enables two primary classes of optimizations that can provide significant speedup in the processor.</p><p>First, the FTQ enables the branch predictor to run ahead of the instruction cache and provide a glimpse at the future stream of instruction fetch addresses. These addresses can then be used to guide a variety of PC-based predictors, such as instruction and data cache prefetchers, value predictors, and instruction reuse tables. Typically, these structures are accessed after the decode stage, but, by bringing the predictor access before even the instruction cache is accessed, we are able to tolerate longer latency predictors. Furthermore, the fetch address stream made available is no longer constrained by the number of ports on the instruction cache. The rate at which predictions can be made determines the rate at which instructions are delivered to the FTQ, which can then be consumed by prediction mechanisms. A single ported instruction cache can only provide a cache block every cycle, but a high bandwidth branch predictor can provide several fetch block addresses each cycle. We investigate an instruction cache prefetching scheme in Section 4. In this scheme, we use the FTQ to guide prefetching into a fully associative prefetch buffer. We also investigate the use of different filtration methods to reduce the bus utilization of the prefetcher.</p><p>Second, the FTQ provides prediction buffering that can enable a multilevel branch predictor hierarchy. A multilevel branch predictor can provide highly accurate predictions while keeping the structure's access time low, much like a multilevel cache hierarchy. Entries stored in the FTQ can be consumed by the instruction cache, while the branch predictor accesses higher levels of its hierarchy. This technique can be used with virtually any branch predictor and may become even more useful as process technology sizes shrink and the access time for large structures grows <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b22">[23]</ref>. We discuss the benefits and implementation of a multilevel branch predictor in Section 5.</p><p>The remainder of this paper is organized as follows: Section 2 reviews some of the prior work in this area. In Section 3, we present the FTQ and the decoupled front-end it enables. In Section 4, we investigate the optimizations possible using the stream of fetch addresses stored in the FTQ. In Section 5, we examine the multilevel branch predictor design. In Section 6, we describe the methodology used to gather the results shown in Section 7. Section 8 provides a summary and concludes with future directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED RESEARCH</head><p>Much work has been put into the front-end architecture in an effort to improve the rate of instruction delivery to the execution core. Techniques to reduce the impact of I-cache misses include multilevel instruction memory hierarchies <ref type="bibr" target="#b16">[17]</ref> and instruction prefetch <ref type="bibr" target="#b39">[40]</ref>. Techniques to reduce the impact of branch mispredictions include hybrid <ref type="bibr" target="#b20">[21]</ref> and indirect <ref type="bibr" target="#b5">[6]</ref> branch predictors and recovery miss caches to reduce misprediction latencies <ref type="bibr" target="#b1">[2]</ref>. A number of compilerbased techniques work to improve instruction delivery performance. They include branch alignment <ref type="bibr" target="#b4">[5]</ref>, trace scheduling <ref type="bibr" target="#b11">[12]</ref>, and block-structured ISAs <ref type="bibr" target="#b14">[15]</ref>.</p><p>We will now examine some of the more relevant prior work in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Future Technology Scaling</head><p>Palacharla et al. <ref type="bibr" target="#b22">[23]</ref> examined the effects of process technology scaling on the performance of the execution core. They found that the performance of operand bypass logic and datapaths scales poorly due to the large amount of interconnect in their datapaths.</p><p>Agarwal et al. <ref type="bibr" target="#b0">[1]</ref> also examined the effects of process technology scaling and found that current techniques of adding more transistors to a chip and superlinear clock scaling will provide diminishing returns to processor performance. Both studies show that larger memory performance scales worse than small memory because they are composed of significantly more interconnect. We examine the effect of this in Section 7.3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Out of Order Instruction Fetching</head><p>Stark et al. <ref type="bibr" target="#b38">[39]</ref> proposed an out-of-order fetch mechanism that allows instruction cache blocks to be fetched in the presence of instruction cache misses. On an instruction cache miss, the branch predictor would continue to produce one prediction per cycle, fetch the instructions, and put them into a result fetch queue out of order.</p><p>The main difference between our approach and the one by Stark et al. <ref type="bibr" target="#b38">[39]</ref> is that our decoupled architecture can expose a larger address stream in front of the fetch unit enabling additional optimizations. A branch predictor can run farther ahead of the instruction cache since it can produce fetch addresses for several cache blocks per prediction, which is more than the instruction cache can consume each cycle. These addresses can then be used for optimizations like prefetching, building a multilevel branch predictor, or making more scalable predictors (e.g., value prediction). In their approach <ref type="bibr" target="#b38">[39]</ref>, the branch predictor is tied to the lockup-free instruction cache and produces addresses that are directly consumed by the instruction cache. This keeps the instruction cache busy and provides potential fetch bandwidth in the presence of instruction cache misses, but does not expose the large number of fetch addresses ahead of the fetch unit as in our decoupled design.</p><p>We call the number of instruction addresses stored in the FTQ at a given time the occupancy of the FTQ. Our results in Section 7 show that we can have a large FTQ occupancy even when the instruction window doesn't fill up and stall since the branch predictor can predict more fetch blocks than the instruction cache can consume each cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Fetch Guided Cache Prefetch</head><p>A form of fetch guided prefetching was first proposed by Chen and Baer <ref type="bibr" target="#b8">[9]</ref> for data prefetching. In their prefetching architecture, they created a second PC, called the Look-Ahead PC, which runs ahead of the normal instruction fetch engine. This LA-PC was guided by a branch prediction architecture and used to index into a reference prediction Fig. <ref type="figure">1</ref>. Two processing engines: the processor pipeline at a high level. The instruction fetch unit prepares and decodes instructions and supplies them to the issue buffer. The execution core consumes instructions from the issue buffer and then orchestrates their execution and retirement. The instruction fetch unit is a fundamental bottleneck in the pipeline: The execution core can only execute instructions as fast as the instruction fetch unit can prepare them. Fig. <ref type="figure">2</ref>. The decoupled front-end design at a high level. The fetch target queue (FTQ) buffers fetch addresses provided from the branch predictor. They are queued in the FTQ until they are consumed by the instruction fetch unit, which in turn produces instructions as in an ordinary pipeline. The FTQ allows the branch predictor to continue predicting in the face of an instruction cache miss. It also provides the opportunity for a number of optimizations, including multilevel branch predictor designs and fetch directed cache prefetching and predictor lookup.</p><p>table to predict data addresses in order to perform data cache prefetching. Since the LA-PC provided the address stream farther in advance of the normal fetch engine, they were able to initiate data cache prefetches farther in advance than if they had used the normal PC to do the address prediction. This allowed them to mask more of the data cache miss penalty. Chen and Baer only looked at using the LA-PC for data prefetching <ref type="bibr" target="#b8">[9]</ref>.</p><p>Chen et al. <ref type="bibr" target="#b6">[7]</ref> examined applying the approach of Chen and Baer to instruction prefetching. They examined adding a separate branch predictor to the normal processor, so, the processor would have two branch predictors, one to guide prefetching and one to guide the fetch engine. The separate branch predictor uses a LA-PC to try and speed ahead of the processor, producing potential fetch addresses on the predicted path. This separate branch predictor was designed to minimize any extra cost to the architecture. It only included 1) a global history register, 2) return address stack, and 3) an adder to calculate the target address.</p><p>In their design, each cycle the cache block pointed to by the LA-PC is fetched from the instruction cache in parallel with the normal cache fetch. If it is not a miss, the cache block is decoded to find the branch instructions and the target addresses are also calculated. When a branch instruction is found in the cache block, it is predicted using the separate branch prediction structures, the LA-PC is updated, and the process is repeated. This whole process is supposed to speed ahead of the normal instruction fetch, but it is limited as to how far it can speed ahead because 1) the prefetch engine uses the instruction cache to find the branches to predict and to calculate their target addresses and 2) their prefetch engine has to stop following the predicted stream whenever the LA-PC gets a cache miss. When the LA-PC gets a cache miss, their prefetcher continues prefetching sequentially after the cache line that missed. In contrast, our prefetching architecture follows the fetch stream prefetching past cache blocks that miss in the cache and does not need to access the instruction cache to provide predicted branch target and prefetch addresses since we completely decouple the branch predictor from the instruction cache fetch via the FTQ. This is explained more thoroughly in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Branch Prediction</head><p>Branch Target Buffers (BTB) have been proposed and evaluated to provide branch and fetch prediction for wide issue architectures. A BTB entry holds the taken target address for a branch along with other information, such as the type of the branch, conditional branch prediction information, and possibly the fall-through address of the branch.</p><p>Perleberg and Smith <ref type="bibr" target="#b25">[26]</ref> conducted a detailed study into BTB design for single issue processors. They even looked at using a multilevel BTB design, where each level contains different amounts of prediction information. Because of the cycle time, area costs, and branch miss penalties they were considering at the time of their study, they found that the ?additional complexity of the multilevel BTB is not cost effective? <ref type="bibr" target="#b25">[26]</ref>. Technology has changed since then and, as we show in this paper, a multilevel branch prediction design is advantageous.</p><p>Yeh and Patt proposed using a Basic Block Target Buffer (BBTB) <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b42">[43]</ref>. The BBTB is indexed by the starting address of the basic block. Each entry contains a tag, type information, the taken target address of the basic block, and the fall-through address of the basic block. If the branch ending the basic block is predicted as taken, the taken address is used for the next cycle's fetch. If the branch is predicted as not-taken, the fall-through address is used for the next cycle's fetch. If there is a BBTB miss, then the current fetch address plus a fixed offset is fetched in the next cycle. In their design, the BBTB is coupled with the instruction cache, so there is no fetch target queue. If the current fetch basic block spans several cache blocks, the BBTB will not be used and will sit idle until the current basic block has finished being fetched.</p><p>Several architectures have been examined for efficient instruction throughput, including the two-block ahead predictor <ref type="bibr" target="#b32">[33]</ref>, the collapsing buffer <ref type="bibr" target="#b9">[10]</ref>, and the trace cache <ref type="bibr" target="#b30">[31]</ref>. Seznec et al. <ref type="bibr" target="#b32">[33]</ref> proposed a high-bandwidth design based on two-block ahead prediction. Rather than predicting the target of a branch, they predict the target of the basic block the branch will enter, which allows the critical next PC computation to be pipelined. Conte et al. <ref type="bibr" target="#b9">[10]</ref> proposed the collapsing buffer as a mechanism to fetch two basic blocks simultaneously. The design features a multiported instruction cache and instruction alignment network capable of replicating and aligning instructions for the processor core. Rotenberg et al. <ref type="bibr" target="#b30">[31]</ref> proposed the use of a trace cache to improve instruction fetch throughput. The trace cache holds traces of possibly noncontiguous basic blocks within a single trace cache line. A start trace address plus multiple branch predictions are used to access the trace cache. If the trace cache holds the trace of instructions, all instructions are delivered aligned to the processor core in a single access. Patel et al. <ref type="bibr" target="#b24">[25]</ref> extended the organization of the trace cache to include associativity, partial matching of trace cache lines, and path associativity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THE DECOUPLED FRONT-END</head><p>To provide a decoupled front-end, a Fetch Target Queue (FTQ) is used to bridge the gap between the branch predictor and the instruction cache. The FTQ stores predictions from the branch prediction architecture until these predictions are consumed by the instruction cache or are squashed. In this section, we examine some of the issues related to the operation of the FTQ, including the occupancy of the FTQ (number of fetch addresses stored in the FTQ) and the speculative recovery mechanisms that we use in coordination with the FTQ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">FTQ Occupancy</head><p>The occupancy of the FTQ significantly contributes to the amount of benefit obtained from the decoupled front-end architecture. We define the occupancy of the FTQ to be the total number of branch predictions contained in the FTQ. If there are a large number of cache blocks represented by the predictions in the FTQ, the instruction cache will have plenty of predictions to consume and we will have more flexibility in the branch predictor implementation (whether it be a multilevel design or a multicycle access design).</p><p>Moreover, the higher the FTQ occupancy, the further ahead cache prefetching mechanisms and PC-based predictors can look into the future fetch stream of the processor.</p><p>High levels of occupancy can be obtained through the prediction of large fetch blocks, multiple predictions per cycle, instruction cache misses, and as a result of full instruction window. Larger fetch blocks mean that each prediction will carry more instructions, fundamentally increasing FTQ occupancy. Instruction cache misses delay consumption of FTQ entries, but the decoupled branch predictor will continue to produce predictions and fill the FTQ. An instruction window that is full due to data dependencies or even limited resources can slow the instruction fetch unit as well, thereby allowing the FTQ to fill. While these two latter situations are by no means desirable, they still can be taken advantage of to provide more FTQ occupancy.</p><p>In our study, we look at an FTQ that stores fetch blocks. A fetch block is a sequence of instructions starting at a branch target and ending with a branch that has been taken in the past. Branches which are strongly biased not-taken may be embedded within fetch blocks. This type of block prediction was also examined by Michaud et al. <ref type="bibr" target="#b21">[22]</ref>. An FTQ could conceivably hold any form of branch prediction?though it is most useful when looking at larger prediction blocks, such as fetch blocks, as these will increase the occupancy of the FTQ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Speculative Recovery Structures</head><p>For good predictor performance, especially for machines with deep speculation and large instruction windows, it becomes beneficial to recover branch history in the event the processor detects a mispredicted branch. This is even more important in our scalable front-end architecture design because the branch predictor can get many predictions ahead of the instruction cache fetch. To facilitate the recovery of branch history, we proposed using a small Speculative History Queue (SHQ) in <ref type="bibr" target="#b26">[27]</ref> to hold the speculative history of branches. When branches are predicted, their updated global or local history is inserted into the SHQ. When predictions are made, the SHQ is searched in parallel with the L1 branch predictor?if a newer history is detected in the SHQ, it takes precedence over the current global history or the local history in the L1 branch predictor. When the branch at the end of a fetch block retires, its branch history is written into the global history register or the branch predictor for local history and its corresponding SHQ entry is removed. When a misprediction is detected, the entry in the SHQ at which the mispredicted branch occurred and all later allocated entries are released. The SHQ is kept small (32 entry) to keep it off the critical path of the L1 branch predictor. If the SHQ fills up, then the global history register and/or local history registers in the branch predictor are speculatively updated for the oldest entry in the SHQ. This allows new SHQ entries to be inserted, at the price of potentially updating the history incorrectly. Skadron et al. independently developed a similar approach for recovering branch history and they provide a detailed analysis of their design in <ref type="bibr" target="#b35">[36]</ref>. For our results, we found that there were around eight entries in the SHQ on average. Ninety-four percent of the time there were less than 32 entries in the SHQ on average for all benchmarks and 74 percent of the time there were less than 16. Fig. <ref type="figure" target="#fig_0">3</ref> gives an example of the operation of the SHQ for global history. The SHQ implementation, for other types of prediction history information (e.g., local history) is the same as what we describe in Fig. <ref type="figure" target="#fig_0">3</ref> for global history.</p><p>Since the branch predictor can make predictions far beyond the current PC, it can pollute the return address stack if it predicts multiple calls and returns. It is necessary to use sophisticated recovery mechanisms to return the stack to the correct state. Simply keeping track of the top of The current branch prediction is noted next, followed by the current state of the nonspeculative global history register, followed by the current state of the SHQ. In this example, the SHQ contains the speculative state of the global history register. The trace begins at cycle i, where the SHQ is currently empty. Here, the current branch prediction is not taken (NT) and the global history register contains the current branch history up until the current prediction. In cycle i I, the next prediction is taken (T) and the nonspeculative global history has remained the same as no new branches have committed. However, a new history entry has been added to the SHQ to reflect the speculatively modified global history (from the prediction in cycle i). Similarly, the SHQ in cycle i P contains a new entry that reflects the addition of branch prediction information from cycle i I.</p><p>In this example, the branch at cycle i is correctly predicted and the branch at cycle i I is mispredicted. Therefore, at cycle i P j, all SHQ entries corresponding to predictions made after cycle i are flushed due to the misprediction at cycle i I. As the mispredicted branch had never committed, the global history counter itself does not need recovery. Finally, in cycle i P j k, once the correctly predicted branch in cycle i has committed, the global history register is updated with the information stored in the SHQ, and the entry corresponding to that branch is removed from the tail of the SHQ.</p><p>the stack is not sufficient <ref type="bibr" target="#b34">[35]</ref>, as the predictor may encounter several returns or calls down a mispeculated path that will affect more than just the top of the stack. We use three return address stacks to solve this problem. One is speculative (S-RAS) and is updated by the branch predictor during prediction. The next (D-RAS) is also speculative and is updated in the decode stage. The third is nonspeculative (N-RAS) and is updated during the commit stage. The S-RAS can potentially be corrupted by branch misfetches and branch mispredictions. The D-RAS can potentially be corrupted by branch mispredictions?as misfetches will be detected in the decode stage. The N-RAS will not be corrupted by control hazards as it is updated in commit. When a misfetch is detected, the S-RAS will likely be polluted and can be recovered from the D-RAS. When a misprediction is detected, the S-RAS and D-RAS will likely be polluted and can be recovered from the N-RAS. After either situation, prediction can restart as normal, using the S-RAS. This provides accurate return address prediction for a deep pipeline. This is summarized in the simplified pipeline in Fig. <ref type="figure">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">FTQ ENABLED PC-INDEXED PREDICTORS</head><p>One of the main benefits of the FTQ is the ability to provide a glimpse into the future fetch stream of the processor. The stream of PCs contained in the FTQ can be used to access any PC-indexed predictor much earlier in the pipeline than in contemporary designs. The result of this prediction can be stored in the FTQ or in auxiliary structures until required.</p><p>In this section, we give an example of using the stream of predicted addresses stored in the FTQ to improve performance. Fetch-directed prefetching (FDP) follows the predicted fetch stream, enqueuing cache prefetches from the FTQ. We now describe our FDP architecture and the heuristics that were used to better select which fetch blocks to prefetch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A Fetch Directed Prefetching Architecture</head><p>Fig. <ref type="figure">5</ref> shows the FDP architecture. As described in Section 3, we use a decoupled branch predictor and instruction cache, where the FTQ contains the fetch blocks to be fetched from the instruction cache. The FDP architecture uses a Prefetch Instruction Queue (PIQ), which is a queue of prefetch addresses waiting to be prefetched. A prefetch from the PIQ will start when the L2 bus is free, after first giving priority to data cache and instruction cache misses.</p><p>For this architecture, we assume the use of a highbandwidth branch predictor that can provide large fetch blocks (as in our FTB design in Section 5). A fetch block from one prediction can potentially span five cache blocks in our design. Therefore, each FTQ entry can span five cache fetch blocks, providing the fetch addresses for up to five cache blocks. Each fetch block entry in the FTQ contains a valid bit, a candidate prefetch bit, and an enqueued prefetch bit, as well as the cache block address. The candidate bit indicates that the cache block is a candidate for being prefetched. The bit is set using filtration heuristics described below. The enqueued bit indicates that the cache block has already been enqueued to be prefetched in the PIQ. Candidate prefetches from FTQ entries are considered in FIFO order from the FTQ and are inserted into the PIQ when there is an available entry. The current FTQ entry, under consideration for inserting prefetch requests into the PIQ, is kept track of in a hardware-implemented pointer.</p><p>A fetch directed fully associative prefetch buffer is added to the FDP architecture to hold the prefetched cache blocks. This is very similar to a predictor-directed stream buffer <ref type="bibr" target="#b33">[34]</ref>, except that it gets its prefetch addresses from the FTQ. Entries from the PIQ that are prefetched are allocated entries in the prefetch buffer. If the prefetch buffer is full, Fig. <ref type="figure">4</ref>. Simplified view of the processor pipeline showing the location of the S-RAS, D-RAS, and N-RAS. The S-RAS is updated during the branch prediction phase of the pipeline. The D-RAS is updated during the decode stage and the N-RAS is updated during the commit stage. This means that the N-RAS will always have correct state, that the D-RAS could potentially be corrupted by a branch misprediction, and that the S-RAS could potentially be corrupted by a branch misfetch or misprediction. Therefore, the S-RAS can be recovered from the D-RAS in the case of a misfetch. And, S-RAS and D-RAS can be recovered from the N-RAS in the case of a misprediction. Fig. <ref type="figure">5</ref>. Fetch-directed prefetching architecture. The branch predictor provides a fetch stream to the FTQ, where it is consumed by the instruction fetch unit. While predictions are waiting in the FTQ, a prefetch enqueue mechanism can choose which cache blocks in the FTQ to predict. Cache blocks to be enqueued are stored in a prefetch instruction queue (PIQ), where they await prefetch from the L2 or main memory. Prefetches are performed into a 32 entry fully associative prefetch buffer. A variety of filtration techniques can be employed by the prefetch enqueue mechanism to limit the number of cache blocks prefetched. Both the instruction cache and prefetch buffer are searched in parallel for the cache block. An I-cache miss and prefetch hit will move the cache block from the prefetch buffer into the I-cache.</p><p>then no further cache blocks can be prefetched. When performing the instruction cache fetch, the prefetch buffer is searched in parallel with the instruction cache lookup for the cache block. If there is a hit in the prefetch buffer, it is removed from the buffer and inserted into the instruction cache. On a branch misprediction, entries in the fully associative prefetch buffer are designated as replaceable and removed only when no remaining free entries exist in the FTQ. This way, prefetches down a mispredicted path can still be useful?especially in the case of short, forward mispredicted branches. We have also explored the use of a FIFO prefetch buffer that is flushed on a misprediction as a cheaper hardware alternative in <ref type="bibr" target="#b28">[29]</ref>.</p><p>We examined several approaches for deciding which FTQ entries to prefetch and insert into the PIQ, but, in this paper, we will only look at Cache Probe Filtering. Other approaches are discussed in <ref type="bibr" target="#b28">[29]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Cache Probe Filtering</head><p>Prefetching blocks that are already contained in the instruction cache results in wasted bus bandwidth. When the instruction cache has an idle port, the port can be used to check whether or not a potential prefetch address is already present in the cache. We call this technique Cache Probe Filtering (CPF). If the address is found in the cache, the prefetch request can be cancelled, thereby saving bandwidth. If the address is not found in the cache, then, in the next cycle, the block can be prefetched if the L2 bus is free. Cache probe filtering only needs to access the instruction cache's tag array. Therefore, it may be beneficial to add an extra cache tag port for CPF since this would only affect the timing of the tag array access and not the data array.</p><p>An instruction cache port can become idle when</p><formula xml:id="formula_0">1.</formula><p>there is an instruction cache miss, 2. the current instruction window is full, 3. the decode width is exhausted and there are still available cache ports, or 4. there is insufficient fetch bandwidth. To use the idle cache ports to perform cache probe filtering during a cache miss, the cache needs to be lockup-free.</p><p>The first approach we examine, called Cache Probe Enqueuing (Enqueue CPF), will only enqueue a prefetch into the PIQ from the FTQ if it can first probe the instruction cache using an idle cache port to verify that the cache block does not exist in the first level cache. This is a very conservative form of prefetching.</p><p>The second approach, called Remove Cache Probe Filtering (Remove CPF), enqueues all cache blocks into the PIQ by default, but if there is an idle first level cache port, it will check the cache tags to see if the address is in the cache. If the prefetch is in the cache, the prefetch entry will be removed from the list of potential prefetch addresses. If there are no idle cache ports, then the request will be prefetched without first checking the cache.</p><p>In our simulations, we examine the performance with and without cache probe filtering. We model cache port usage in our simulations and only allow cache probe filtering to occur when there is an idle cache port.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Prior Hardware Prefetching Research</head><p>The following summarizes the prior hardware prefetching research, which we compare against our FDP architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Tagged Next Line Prefetching</head><p>Smith <ref type="bibr" target="#b36">[37]</ref> proposed tagging each cache block with a bit indicating when the next block should be prefetched. We call this Next Line Prefetching (NLP). When a block is prefetched, its tag bit is set to zero. When the block is accessed during a fetch and the bit is zero, a prefetch of the next sequential block is initiated and the bit is set to one. Smith and Hsu <ref type="bibr" target="#b37">[38]</ref> studied the effects of tagged next line prefetching and the benefits seen based upon how much of the cache line is used before initiating the prefetch request. In our study, we examine using cache probe filtering with NLP. When the next sequential block is queued to be prefetched, we check whether the block is already in the cache?if an idle cache port is available. If no port is available, we initiate the prefetch anyway.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Stream Buffers</head><p>Jouppi proposed stream buffers to improve the performance of directed mapped caches <ref type="bibr" target="#b15">[16]</ref>. If a cache miss occurs, sequential cache blocks, starting with the one that missed, are prefetched into a stream buffer until the buffer is filled. The stream buffer is searched in parallel with the instruction cache when performing a lookup. He also examined using multiple stream buffers at the same time.</p><p>Palacharla and Kessler <ref type="bibr" target="#b23">[24]</ref> improved on this design by adding a filtering predictor to the stream buffer. The filter only starts prefetching a stream if there are two sequential cache block misses in a row. This was shown to perform well for data prefetching. In addition, they examined using nonunit strides with the prefetch buffer.</p><p>Farkas et al. <ref type="bibr" target="#b10">[11]</ref> examined the performance of using a fully associative lookup on stream buffers. This was shown to be beneficial when using multiple stream buffers so that each of the streams do not overlap, saving bus bandwidth.</p><p>We will present results for using the FTQ to guide instruction prefetching in Section 7. Next, we will discuss other prediction techniques that could benefit from having the fetch PC stream in advance of instruction fetch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Other PC-Based Predictors</head><p>The stream of addresses stored in the FTQ could also be used to guide other PC-based predictors. Value and address prediction have been shown to be effective at reducing instruction latency in the processor pipeline <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b27">[28]</ref>.</p><p>A value predictor attempts to predict the result of or the inputs to a particular instruction. If the result of an operation is predicted, instructions that are currently waiting on the completion of the operation may speculatively execute. If the input to an instruction has predicted values, then the instruction can speculatively execute.</p><p>An address predictor attempts to predict the memory location that a load or store will access. The load or store will speculatively execute with the predicted address.</p><p>The predictor tables used for these types of predictors can be quite complex and fairly large. The fetch addresses stored in the FTQ can allow the predictor access to initiate earlier in the pipeline, even before the corresponding instruction cache blocks are fetched, storing the result with the fetch block in the FTQ.</p><p>One example of this is context prediction <ref type="bibr" target="#b31">[32]</ref>. In a context value predictor that predicts the results of an operation, the last n values of an instruction are stored in a first level table that is hashed by instruction PC. These values are used to create an index into a second level table that contains the actual value to be predicted. The table sizes used will likely require multiple cycles to access. But, with the fetch addresses stored in the FTQ, we could conceivably initiate the predictor access earlier in the pipeline?storing the result in the FTQ itself if the prediction has not yet been consumed. This could allow even larger and more accurate predictors to be used, potentially even allowing these predictors to be located off-chip.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">AN FTQ ENABLED BRANCH PREDICTOR</head><p>The use of a decoupled design provides us with some flexibility in branch predictor design. Because the FTQ buffers predictions made by the branch predictor, it is possible to hide the latency of a multilevel branch predictor. Any branch predictor could take advantage of the multilevel approach, especially since future process technologies may favor smaller, faster structures <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b22">[23]</ref>.</p><p>To fully take advantage of the FTQ, we want a branch predictor that is also capable of maintaining a high degree of FTQ occupancy. We chose to investigate a multilevel branch predictor hierarchy using our Fetch Target Buffer (FTB) <ref type="bibr" target="#b26">[27]</ref>.</p><p>Fig. <ref type="figure">6</ref> shows the FTB design, which is an extension of the BBTB design by Yeh and Patt <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b42">[43]</ref> with three changes to their design. The first change is that we store fetch blocks rather than basic blocks. As mentioned in Section 3, fetch blocks may encapsulate one or more strongly biased nottaken branches and, so, may contain multiple basic blocks. Therefore, an FTB entry is a form of a sequential trace, storing trace predictions with embedded fall-through branches.</p><p>The second change is that we do not store fetch blocks in our fetch target buffer that are fall-through fetch blocks, whereas the BBTB design stores an entry for all basic blocks, wasting some BBTB entries.</p><p>The third change we made to the BBTB design is that we do not store the full fall-through address in our FTB. The fall-through address is instead calculated using the fetch distance field in the FTB and the carry bit. The fetch distance really points to the instruction after the potential branch ending the FTB entry (fetch block). We store only the precomputed lower bits of the fall-through address in the fetch distance along with a carry bit used to calculate the rest of the fall-through address in parallel with the FTB lookup <ref type="bibr" target="#b3">[4]</ref>. This helps reduce the amount of storage for each Fig. <ref type="figure">6</ref>. The decoupled front-end architecture with fetch target buffer. This figure elaborates upon the high-level pipeline from Section 1. The branch prediction unit, which feeds into the FTQ, is composed of a two-level fetch target buffer (FTB), a gshare predictor with global history (Br Pred and Hist), a speculative history queue (SHQ), and a speculative return address stack (S-RAS). The fetch target buffer predicts fetch addresses using prediction data from the gshare predictor and global history. The various fields of the FTB are shown in the diagram and will be explained in detail in this section. Since the FTQ enables the FTB to predict far ahead of the current fetch stream, we use the SHQ and S-RAS to track and recover speculative state. Fetch addresses are stored in the FTQ, where they are then consumed by the instruction cache and decode hardware. Instructions are then supplied to the issue buffer, where they are executed and retired by the execution core.</p><p>FTB entry since the typical distance between the current fetch address and the fetch block's fall-through address is not large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">FTB Structure</head><p>Our Fetch Target Buffer (FTB) design is shown in Fig. <ref type="figure">6</ref>. The FTB table is accessed with the start address of a fetch target block. Each entry in the FTB contains a tag, taken address, fetch distance, fall-through carry bit, branch type, oversize bit, and conditional branch prediction information. The FTB entry represents the start of a fetch block. The fetch distance represents the precomputed lower bits of the address for the instruction following the branch that ends the fetch block. The goal is for fetch blocks to end only with branches that have been taken during execution. If the FTB entry is predicted as taken, the taken address is used as the next cycle's prediction address. Otherwise, the fall-through address (fetch distance and carry bit) are used as the next cycle's prediction address.</p><p>The size of the x bit fetch distance field determines the size of the sequential fetch blocks that can be represented in the fetch target buffer. If the fetch distance is farther than P x instructions away from the start address of the fetch block, the fetch block is broken into chunks of size P x and only the last chunk is inserted into the FTB. The other chunks will miss in the FTB, predict not-taken, and set the next PC equal to the current PC plus P x , which is the max fetch distance. Smaller sizes of x mean that fetch blocks will be smaller? thereby increasing the number of predictions that must be made and potentially decreasing the FTQ occupancy. Larger sizes of x will mean fewer predictions and potentially higher FTQ occupancy, but will also mean that FTB misses will result in large misfetch blocks which can potentially pollute the instruction cache.</p><p>An oversize bit is used to represent whether or not a fetch block spans a cache block <ref type="bibr" target="#b41">[42]</ref>. This is used by the instruction cache to determine how many predictions to consume from the FTQ in a given cycle. We simulated our results with two I-cache ports. The oversize bit is used to distinguish whether a prediction is contained within one cache block or if its fetch size spans two or more cache blocks. If the oversize bit is set, the predicted fetch block will span two cache blocks and the cache will use its two ports to fetch the first two sequential cache blocks. If the bit is not set, the prediction only requires a single cache block, so the second port can be used to start fetching the target address of the next FTQ entry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Branch Direction Predictor</head><p>The branch direction predictor shown in the FTB in Fig. <ref type="figure">6</ref> is a hybrid predictor composed of a meta-predictor that can select between a global history predictor and a bimodal predictor. Other combinations are certainly possible, as well as nonhybrid predictors. The global history is XORed with the fetch block address and used as an index into a global pattern history table. The meta-prediction is used to select between the various predictions available, depending on the specifics of the design. The meta-predictor is typically implemented as a counter to select between two predictions or as a per-predictor confidence mechanism to select among three or more predictors <ref type="bibr" target="#b27">[28]</ref>. The final prediction result is used to select either the target address of the branch at the end of the fetch block or the fetch block fall-through address.</p><p>The meta-predictor and bimodal predictor values are not updated speculatively since they are state machines and not history registers. The front-end can only assume it made the correct prediction and thus reinforce bimodal predictions. It has been shown in <ref type="bibr" target="#b17">[18]</ref> that better performance results when such predictor updates are delayed until the result of the branch outcome is known, i.e., at execution or retirement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Functionality of the 2-Level FTB</head><p>The FTQ helps enable the building of a multilevel branch predictor since the latency of the predictions from the L2 and higher predictors can be masked by the high occupancy of the FTQ. We will now describe the functionality of a 2-level FTB design.</p><p>The L1 FTB is accessed each cycle using the predicted fetch block target of the previous cycle. At the same time, the speculative return address stack (S-RAS) and the global history prediction table are accessed. If there is an L1 FTB hit, then the fetch block address, the oversize bit, the last address of the fetch block, and the target address of the fetch block are inserted into the next free FTQ entry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">L1 FTB Miss and L2 FTB Hit</head><p>If the L1 FTB misses, the L2 FTB needs to be probed for the referenced FTB entry. To speed this operation, the L2 FTB access begins in parallel with the L1 FTB access. If, at the end of the L1 FTB access cycle, a hit is detected, the L2 FTB access is ignored. If an L1 miss is detected, the L2 FTB information will return in x ? I cycles, where x is the access latency of the L2 FTB (in L1 FTB access cycles). On an L1 FTB miss, the predictor has the target fetch block address, but doesn't know the size of the fetch block. To make use of the target address, the predictor injects fallthrough fetch blocks starting at the miss fetch block address into the FTQ with a predetermined fixed length. Once the L2 FTB entry is returned, it is compared to the speculatively generated fetch blocks: If it is larger, another fetch block is generated and injected into the FTQ. If it is smaller, the L1 FTB initiates a pipeline squash at the end of the fetch block. If the fetch target has not made it out of the FTQ, then no penalty occurs. If the fetch target was being looked up in the instruction cache, those instructions are just ignored when the lookup finishes. The final step is to remove the LRU entry from the corresponding L1 FTB set and insert the entry brought in from the L2 FTB. The entry removed from the L1 FTB, is then inserted into the L2 FTB also using LRU replacement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">L1 FTB Miss and L2 FTB Miss</head><p>If the L2 FTB indicates the requested FTB entry is not in the L2 FTB, the L1 FTB enters a state where it continually injects sequential fetch blocks into the machine until a misfetch or misprediction is detected in the decode or writeback stage of the processor. Once a misfetch or misprediction is detected, the L1 FTB will be updated with the correct information regarding this new fetch block and then the L1 FTB will once again begin normal operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">METHODOLOGY</head><p>The simulators used in this study are derived from the SimpleScalar/Alpha 3.0 tool set <ref type="bibr" target="#b2">[3]</ref>, a suite of functional and timing simulation tools for the Alpha AXP ISA. The timing simulator executes only user-level instructions, performing a detailed timing simulation of an aggressive 8-way dynamically scheduled microprocessor with two levels of instruction and data cache memory. Simulation is execution-driven, including execution down any speculative path until the detection of a fault, TLB miss, or branch misprediction.</p><p>To perform our evaluation, we collected results for nine benchmarks. We examined six of the SPEC95 C benchmarks and three additional benchmarks. Groff is a text formatting program and deltablue is a constraint solving system. The programs were compiled on a DEC Alpha AXP-21164 processor using the DEC C and C++ compilers under OSF/1 V4.0 operating system using full compiler optimization (-O4 -ifo). Table <ref type="table" target="#tab_0">1</ref> shows the data set we used in gathering results for each program, the number of instructions executed (fast forwarded) before actual simulation (in millions) and the percent of executed branches in each program. Also shown is the miss rate and IPC for three different cache configurations. Each program was simulated for up to 200 million instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Baseline Architecture</head><p>Our baseline simulation configuration models a future generation out-of-order processor microarchitecture. We've selected the parameters to capture underlying trends in microarchitecture design. The processor has a large window of execution; it can fetch up to eight instructions per cycle (from up to two cache blocks) and issue up to 16 instructions per cycle. The instruction cache is dual ported, and each port can fetch from a single cache block each cycle. The architecture has a 128 entry reorder buffer with a 32 entry load/store buffer. Loads can only execute when all prior store addresses are known. In addition, all stores are issued in-order with respect to prior stores. To compensate for the added complexity of disambiguating loads and stores in a large execution window, we increased the store forward latency to three cycles.</p><p>There is an eight cycle minimum branch misprediction penalty. The processor has eight integer ALU units, 4-load/ store units, 2-FP adders, 2-integer MULT/DIV, and 2-FP MULT/DIV. The latencies are: ALU, one cycle; MULT, three cycles; Integer DIV, 12 cycles; FP Adder, two cycles; FP Mult, four cycles; and FP DIV, 12 cycles. All functional units, except the divide units, are fully pipelined, allowing a new instruction to initiate execution each cycle.</p><p>The processor we simulated has a dual ported 16K 2-way set-associative direct-mapped instruction cache and a 32K 4-way set-associative data cache. Both caches have block sizes of 32 bytes and have a three cycle hit latency. There is a unified second-level 1 MB 4-way set-associative cache with 64 byte blocks, with a 12 cycle cache hit latency. If there is a second-level cache miss, it takes a total of 120 cycles to make the round trip access to main memory. The L2 cache has only one port. The L2 bus is shared between instruction cache block requests and data cache block requests. We modified SimpleScalar to accurately model L1 and L2 bus utilization. We model a pipelined memory/bus, where a new request can occur every four cycles, so each bus can transfer eight bytes/cycle.</p><p>There is a 32 entry 8-way associative instruction TLB and a 32 entry 8-way associative data TLB, each with a 30 cycle miss penalty.</p><p>For this paper, we used the McFarling hybrid predictor <ref type="bibr" target="#b20">[21]</ref> for our conditional branch predictor. The predictor has a 2-bit meta-chooser and a 2-bit bimodal predictor, both stored in the branch predictor entry with their corresponding branch. In addition, a tagless gshare predictor is also available, accessed in parallel with the branch predictor. The meta-chooser is incremented/decremented if the bimodal/gshare predictors are correct. The most significant bit of the meta-chooser selects between the bimodal and gshare predictions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Timing Model</head><p>In order to get a complete picture of the impact of our front-end architecture, we also need to investigate the  cycle time of the architecture. IPC results obtained through SimpleScalar can be combined with timing analysis to provide results in Billion Instructions Per Second (BIPS). Architects need to consider the cycle time of the processor in addition to the number of instructions that can be performed in a single cycle (IPC). Since IPC is a relative measurement (as it is given in cycles), BIPS results are often more useful in determining the overall performance of an architecture?including the impact that large predictors and caches may have on the cycle time of the processor. A technique that provides a 10 percent improvement in IPC may not be worthwhile if it extends the processor cycle time and reduces the BIPS of the architecture. The BIPS results that we show are an upper bound on the instruction rate for the processor, as it is possible for other components of the pipeline that are not included in the front-end to influence the cycle time of the processor.</p><p>The timing data we need to generate results in BIPS is using the CACTI cache compiler version 2.0 <ref type="bibr" target="#b29">[30]</ref>. CACTI contains a detailed model of the wire and transistor structure of on-chip memories. We modified CACTI to model our FTB design. CACTI uses data from HXVH"m process technology and can then scale timing data by a constant factor to generate timings for other process technology sizes. We examine timings for the HXIH"m process technology size. However, this scaling assumes ideal interconnect scaling, unlike the model used in <ref type="bibr" target="#b26">[27]</ref>. This provides a lower bound on the performance improvement of our multilevel predictor.</p><p>Table <ref type="table" target="#tab_1">2</ref> contains the timing parameters for the FTB and cache configurations we examined for the HXIH"m technology size. Table <ref type="table" target="#tab_1">2a</ref> lists the FTB sizes (in number of entries) and the CACTI timing data in nanoseconds for each configuration, showing the access time in nanoseconds. All FTB organizations are 4-way set-associative. Table <ref type="table" target="#tab_1">2b</ref> lists the timing data for the instruction and data cache configurations we examined, showing the access time in nano-seconds.</p><p>In our study, we assume that the branch predictor would need to be accessed once per cycle. Therefore, we set the cycle time of the processor to the access time of the FTB. Then, the instruction and data caches are pipelined according to the cycle time of the processor. For example, a processor with a 1K entry FTB would have a cycle time around 0.9 ns at the HXIH"m feature size. A 16K 2-way associative dual-ported instruction cache would need to have two pipeline stages to accommodate this cycle time. To calculate BIPS, we simulate the particular architecture using SimpleScalar to provide an IPC value and then divide this by the cycle time derived from CACTI data for the HXIH"m feature size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RESULTS</head><p>In this section, we examine results for the FTQ-enabled optimizations we described. First, we examine the ability of the FTQ to fill up ahead of the fetch stream. Then, we provide results for our fetch directed prefetching (FDP) architecture enabled by having an FTQ. Finally, we compare single-level and multilevel FTB predictors. The metrics used and base architecture are as described in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">FTQ Occupancy</head><p>As discussed in Section 3.1, the greater the occupancy of the FTQ, the greater the potential benefit provided by the FTQ. Fig. <ref type="figure">7</ref> shows a breakdown of the occupancy of the FTQ for both a single level (Fig. <ref type="figure">7a</ref>) and a two level (Fig. <ref type="figure">7b</ref>) branch predictor. This figure demonstrates the percent of cycles that the FTQ held a given number of entries with predictions. For example, on average for the single level predictor, the FTQ only buffered a single prediction 25 percent of the time. It held a full 32 predictions 31 percent of the time. The two level results (Fig. <ref type="figure">7b</ref>) show slightly less occupancy due to the fact that the second level occasionally corrects the first level and squashes some predictions in the FTQ. However, the two level predictor is more accurate, as will be shown in Section 7.3.2. Also, the FTQ is completely flushed on a branch misprediction.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Fetch Directed Prefetching Results</head><p>In <ref type="bibr" target="#b28">[29]</ref>, we investigated the performance of our prefetching architecture with an accurate, single level branch predictor. In this study, we show that we can achieve the same high levels of performance with a 2-level branch predictor. We chose to simulate our prefetching architecture with a 128 entry first level FTB and an 8,192 entry second level FTB, as will be examined in Section 7.3. We will show how this configuration was one of the best BIPS performers and had a high average prediction accuracy. Unless otherwise indicated, we used a 32 entry FTQ for results in this section. This gave us a large window to perform instruction prefetch.</p><p>Fig. <ref type="figure" target="#fig_3">8</ref> shows the performance of our fetch-directed prefetching techniques and prior Next-Line and Stream Buffer (MSB) prefetching techniques for an architecture with an eight byte/cycle bus to the L2 cache. Unfiltered fetch-directed (NoFilt) prefetching provides a speedup of 13 percent due to contention for limited bandwidth. Tagged next line prefetching (NLP) with cache probe filtering performs slightly better. An architecture with one stream buffer (MSB1) using cache probe filtering provides a 14 percent speedup in IPC. The stream buffer architecture we implemented contained four entries and prefetched sequential cache blocks after a cache miss. The results show that adding a second eight entry stream buffer (MSB2) actually degraded performance in some instances. Fig. <ref type="figure">7</ref>. FTQ occupancy histograms. These graphs show the percent of executed cycles the 32 entry FTQ used in this study had a given number of predictions stored within it after instruction fetch. The disjoint categories of FTQ occupancy are shown in the legend at the top of the graphs. For example, the white section represents the percent of time that the FTQ held between four to seven FTQ entries. Graph (a) corresponds to a single level branch predictor and graph (b) corresponds to a two level branch predictor. Remove CPF performs the best on average with a speedup in IPC of 19 percent. Enqueue CPF achieves an IPC speedup of 18 percent on average. It would be expected that, as bandwidth becomes more and more scarce, a conservative prefetching approach like enqueue CPF would begin to outperform a more aggressive technique like remove CPF, especially if data prefetching is performed at the same time. Vortex achieves a large speedup due to a relatively high instruction cache miss rate (more room for improvement), a large amount of FTQ occupancy, and highly accurate branch prediction. Deltablue, while having accurate branch prediction and high occupancy, does not have a high instruction cache miss rate. Moreover, it has a relatively high amount of bus utilization (as shown in Table <ref type="table">3</ref>) due to a large number of data cache misses, so aggressive prefetching can degrade performance by interfering with demand data cache misses.</p><p>This data is further explained by the results in Table <ref type="table">3</ref>. This shows the amount of bus utilization that our prefetching techniques consume. FDP with remove CPF provides a small reduction in bus utilization over unfiltered fetch-directed prefetching, 69 percent on average down to 64 percent. Enqueue CPF provides a significant reduction, with an average 42 percent bus utilization, whereas an architecture with no prefetching has a bus utilization of 20 percent.</p><p>In Fig. <ref type="figure" target="#fig_4">9</ref>, we examine the performance of our prefetching architecture across three different cache configurations (16K 2-way, 16K 4-way, and 32K 2-way). The trends in performance are similar across all three configurations, but the magnitude of the benefit decreases for larger or more associative caches due to the decreased miss rate. Even so, for a 32K 2-way associative instruction cache with an eight byte/cycle bus to the L2 cache, we are able to obtain 10 percent speedup using remove CPF on average.</p><p>In Table <ref type="table" target="#tab_2">4</ref>, we show the range of speedups obtainable through prefetching when we vary the size of the FTQ between two and 64 entries. The larger the FTQ, the further ahead a prefetch can potentially be made, but the more inaccurate the prefetch may potentially be. This trade-off can be seen in the performance of the unfiltered fetchdirected prefetching approach. Performance improves when going from a two entry FTQ to a 16 entry FTQ, but drops slightly when the FTQ continues to grow in size. The performance of both CPF techniques continues to improve with increasing FTQ size, but the rate of performance increase drops for larger sized FTQs. Going to a 64 entry FTQ from an FTQ of size 32 only provides a minimal speedup for remove CPF and enqueue CPF. The additional complexity and size of the FTQ at 64 entries did not seem to justify this amount of speedup. We decided to use the 32 entry FTQ for our prefetching results, as it provided a significant amount of speedup, but still had a small enough structure that would not be likely to affect cycle times. Fig. <ref type="figure">7</ref> is also useful to explain the performance of our prefetching scheme on certain benchmarks. Vortex, which enjoys a considerable speedup with our prefetching scheme, has a significant amount of FTQ occupancy?it has a full FTQ around 55 percent of the time. This is due to both a high prediction accuracy and a large average fetch distance size. Programs like m88ksim tend toward lower FTQ occupancies due to smaller average fetch distance sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE 3 Bus Utilization for the Base Configuration for Fetch-Directed Prefetching</head><p>The first three columns show results for the base configuration. The next four columns show results for unfiltered fetch directed prefetching. The next four show results for remove CPF and the final four for enqueue CPF. Each set of results shows the total percent bus utilization, the percent bus utilization by the instruction cache (i$), and the percent bus utilization by the data cache (d$). In addition, the prefetching techniques have the percent bus utilization used by the prefetching architecture (% pref). Results shown are for an eight byte/cycle bus to the L2 cache. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Multilevel Predictor Results</head><p>We now examine the performance of a two-level FTB predictor, which benefits from having an FTQ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.1">Single-Level Predictor Results</head><p>We first will motivate the potential benefit from pipelining the instruction cache for future processors. Fig. <ref type="figure" target="#fig_6">10</ref> shows the Billion Instructions per Second (BIPS) results for three FTB configurations with pipelined (two cycle) instruction cache and an FTB configuration with a single cycle instruction cache. The first three FTB designs with a pipelined I-cache use a cycle time equal to the FTB access time and the nonpipelined I-cache uses a cycle time equal to the I-cache access time as shown in Fig. <ref type="figure">2</ref>. The 512 entry FTB with the pipelined I-cache has an average BIPS of 0.28 and is the best single level performer as it balances a moderate cycle time with a high IPC. The 4,096 entry FTB with the single cycle instruction cache avoids lengthening the branch misprediction penalty by a cycle (pipelining the instruction cache in these experiments extends the pipeline by one stage). However, as can be seen, the increase in cycle time has more of an impact on BIPS, and the average BIPS for the single cycle instruction cache case is 0.22.</p><p>Next, we examine the ability of the FTB to encapsulate never taken branches. Fig. <ref type="figure">11</ref> shows that, on average, 14 percent of predictions include two basic blocks (i.e., include a single never taken branch) and an additional 3.2 percent of predictions include more than two basic blocks (i.e., include two or more never taken branches). Predictions in vortex span multiple basic blocks nearly 40 percent of the time. Michaud et al. <ref type="bibr" target="#b21">[22]</ref> also examined predictors that are capable of bypassing a single not-taken branch and found an average fetch rate of 1.3 basic blocks per cycle for an ordinary BTB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.2">Two-Level Predictor Results</head><p>Fig. <ref type="figure" target="#fig_7">12</ref> shows results in instructions per cycle (IPC), varying the size of the FTB for single and dual level FTBs, for the benchmarks we examined. For most benchmarks, the increase in predictor size results in increased performance. Benchmarks like perl and m88ksim are more affected by FTB size. For most, the difference between a 1K and a 4K entry FTB is minimal. The results for ijpeg show that this benchmark does not contain a significant amount of branch state. It has few taken branches encountered (only 4.7 percent of instructions are branches at all) and therefore    <ref type="table" target="#tab_1">2</ref> for timing data). The final bar represents an FTB with 4,096 entries that does not have a pipelined instruction cache. In this case, the cycle time is set to the cycle time of the instruction cache.</p><p>requires very little space in the FTB. This, in addition to its low instruction cache miss rate, helps to explain the relatively high IPC obtained with this benchmark. The two level results demonstrate that the second level FTB is improving the prediction accuracy of the first level FTB.</p><p>Fig. <ref type="figure" target="#fig_8">13</ref> shows results in Billion Instructions per Second (BIPS) for single level (64 entry to 4K entry) and two level FTB designs (64 to 512 entry first level table with an 8K entry second level table) assuming perfect scaling. For most benchmarks, the 512 entry FTB is the best single level performer, with a cycle time of 0.28ns. The exception is the performance of ijpeg for the above-mentioned reasons. The second level results are very closely clustered on average. The best performer on average was the configuration with a 128 entry first level FTB and 8K entry second level FTB. But, for some benchmarks, the best performance was seen with a 512 entry first level FTB. The most dramatic of these was m88ksim. This benchmark has a relatively low FTQ occupancy (due to a small average fetch distance) and therefore is not able to tolerate the latency to the second level FTB as well as other benchmarks. These results show that the two level FTB performs slightly better on average than a single level design in the absence of the interconnect scaling bottleneck (i.e., assuming ideal technology scaling).</p><p>When taking into consideration the interconnect scaling bottleneck, we found that the best performing two level FTB design provided a 14.6 percent improvement in BIPS over the best performing single level design. Fig. <ref type="figure" target="#fig_9">14</ref> also shows results in Billion Instructions per Second (BIPS), but uses the technology scaling calculations from <ref type="bibr" target="#b26">[27]</ref>, as shown in Table <ref type="table" target="#tab_3">5</ref>. These results show the potential effects of the interconnect scaling bottleneck. This scaling assumes that wire latency scales at a rate less than the processor feature size due to the effects of parasitic capacitance. These results Fig. <ref type="figure">11</ref>. Percent of predictions from the FTB that span multiple basic blocks. The x-axis shows the benchmarks we examined, and the y-axis shows the percent of predictions that contain one or more never taken branches. The black bar shows the percent of predictions that contain a single nevertaken branch and the gray bar shows the percent of predictions that contain two or more never-taken branches. show an even more substantial difference in BIPS between single and two level FTB designs.</p><p>These results show that IPC does not provide the full picture of processor performance. The BIPS results in Fig. <ref type="figure" target="#fig_6">10</ref> and Fig. <ref type="figure" target="#fig_8">13</ref> show that if the FTB access time determines the cycle time of the processor, then a 512 entry FTB provides the best average performance of the single level FTB designs and the 128 entry first level and 8K entry second level FTB provides the best average performance of the 2-level FTB designs. If one were only to look at IPC, it would appear that the bigger the table is, the better the performance looks, even though the access time for a given cycle would not be realistic.</p><p>Table <ref type="table">6</ref> shows prediction accuracy data for the best single and dual level FTB configurations (from the BIPS data). On average, the results show that 11.2 percent of predictions from the second level FTB are correctly predicted in the two-level configuration. Ijpeg again proves interesting as 31 percent of predictions in the single level FTB configuration are correctly predicted and come from misses in the FTB (which would use the default FTB fetch distance and a fall-through prediction). This is due to the nature of the benchmark which contains very few taken branches. Table <ref type="table">6</ref> shows that the average FTB prediction size for the single level FTB is around eight instructions and five predictions occur in a row before reaching a misprediction. This means that, on average, a single level FTB can supply around 43 instructions between mispredictions. The 2-level FTB is able to supply slightly more instructions between mispredictions?around 46 instructions on average. The exception is m88ksim, again due to the frequency of taken branches in this benchmark. Without sufficient FTQ occupancy, m88ksim is unable to tolerate second level  FTB accesses and a single level configuration is able to outperform two-level configurations. Fig. <ref type="figure" target="#fig_10">15</ref> shows the performance of a 2-level FTB with and without FTQ and demonstrates how the FTQ enables the 2-level FTB. Using a 32 entry FTQ provides a 16 percent improvement on average in IPC over a design without an FTQ. Results shown are for a 128 entry first level FTB with an 8,192 entry second level FTB. Without an FTQ, there is limited opportunity for the second level FTB to correct a miss in the first level FTB. The occupancy in the FTQ helps tolerate the latency of the second level FTB access.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS</head><p>In this paper, we have investigated a decoupled front-end architecture that uses a fetch target queue (FTQ), which is a small FIFO queue used to store predicted fetch addresses from the branch prediction unit. The FTQ provides a decoupled front-end?allowing the branch predictor and instruction cache to run more independently. The FTQ enables a number of optimizations and we demonstrated two of these in this study?effective instruction cache  <ref type="bibr" target="#b26">[27]</ref> This data is only used for the BIPS results in Fig. <ref type="figure" target="#fig_9">14</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE 6</head><p>Two FTB Configurations: A Single Level FTB with 512 Entries and a 128 Entry FTB with a Second Level with 8,192 Entries</p><p>For both configurations, we list the percent of FTB predictions with valid fetch distances and correct branch predictions, shown in columns 2 and 6. Columns 3 and 9 show the percent of correct predictions that resulted from an FTB miss. In this case, the default fetch distance is predicted. In addition, for the two level configuration, we show the percent of correct predictions that were from the first level FTB (column 7) and the percent of correct predictions that were from the second level FTB (column 8). For both configurations, we show the average number of instructions in each fetch block that are predicted in a single cycle (columns 4 and 10). Also, we show the number of predictions in a row that were produced, on average, before a misprediction (columns 5 and 11). The product of these two numbers provides the average number of instructions between mispredictions. prefetching and the construction of a multilevel branch predictor. To better evaluate our architecture, we made use of results in both IPC and BIPS (billion instructions per nanosecond). While IPC provides some notion of performance, BIPS gives a complete picture as it takes into account the cycle time of the processor. It is essential for architects to study both the improvement in performance obtained through a particular technique and the impact the technique (table sizes) will have on the cycle time of the processor.</p><p>The FTQ enables a number of optimizations based on the predicted fetch stream it contains. We first examined using the FTQ to direct instruction cache prefetching. With this technique, we were able to provide a speedup in IPC of 19 percent for an eight byte/cycle bus to the L2 cache. We showed how cache probe filtering could be an effective technique for reducing bus utilization and attaining higher levels of performance. However, the performance of fetchdirected prefetching is essentially tied to the accuracy of the prediction stream and the occupancy of the FTQ.</p><p>Next, we showed that a multilevel branch predictor can be an effective technique to achieve high prediction accuracy while retaining small cycle times. In our results, we saw that the best performing two level branch predictor (a 128 entry first level fetch target buffer with an 8,192 entry second level) achieved a 2.5 percent speedup on average in BIPS over the best performing single level FTB configuration (a 512 entry FTB). These results assume no interconnect scaling bottleneck. In the event of poor interconnect scaling, the gap in cycle times between the single level tables and the multilevel tables can be significant, as we showed in <ref type="bibr" target="#b26">[27]</ref>. We found that the best performing two level FTB design provided a 14.6 percent improvement in BIPS over the best performing single level design when taking into consideration the interconnect scaling bottleneck.</p><p>There are a number of other optimizations which could be enabled by the FTQ design. In addition to instruction cache prefetching, the FTQ could be used to direct data cache prefetch in a manner similar to that proposed in <ref type="bibr" target="#b7">[8]</ref>. The FTQ could also be used to index into other PC-based predictors (such as value or address predictors) further ahead in the pipeline. This would allow these predictors to be large without compromising processor cycle times.</p><p>Additionally, the use of a multilevel branch predictor, like the FTB, provides us with a significant amount of instruction state. Extra bits could be stored in the branch predictor to help guide later stages of the pipeline. For example, we used extra state in the multilevel branch predictor to perform eviction prefetching in <ref type="bibr" target="#b28">[29]</ref>. The state can be used to help guide cache replacement policies and to track branch confidence, value predictability, or any other useful metric.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Speculative History Queue (SHQ) example for global history branch predictors. This figure shows the state of the nonspeculative global history register (GHR) and the SHQ over several cycles of program execution. Cycles are delineated by vertical dotted lines and are labeled at the top of the figure.The current branch prediction is noted next, followed by the current state of the nonspeculative global history register, followed by the current state of the SHQ. In this example, the SHQ contains the speculative state of the global history register. The trace begins at cycle i, where the SHQ is currently empty. Here, the current branch prediction is not taken (NT) and the global history register contains the current branch history up until the current prediction. In cycle i I, the next prediction is taken (T) and the nonspeculative global history has remained the same as no new branches have committed. However, a new history entry has been added to the SHQ to reflect the speculatively modified global history (from the prediction in cycle i). Similarly, the SHQ in cycle i P contains a new entry that reflects the addition of branch prediction information from cycle i I.In this example, the branch at cycle i is correctly predicted and the branch at cycle i I is mispredicted. Therefore, at cycle i P j, all SHQ entries corresponding to predictions made after cycle i are flushed due to the misprediction at cycle i I. As the mispredicted branch had never committed, the global history counter itself does not need recovery. Finally, in cycle i P j k, once the correctly predicted branch in cycle i has committed, the global history register is updated with the information stored in the SHQ, and the entry corresponding to that branch is removed from the tail of the SHQ.</figDesc><graphic url="image-3.png" coords="4,102.84,69.17,360.79,137.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Each program is shown, along with the data set used, number of instructions fast forwarded millions) to avoid initialization effects, and the dynamic percentage of branches executed. The next eight columns show the miss rate and IPC for the different cache configurations we investigated. Columns 5 and 6 show the miss rate and IPC for our default configuration?a 16K 2-way associative instruction cache with two read/ write ports. Columns 7 and 8 show the miss rate and IPC for a cache with a higher associativity?a 16K 4-way associative cache with two read/write ports. Columns 9 and 10 show the miss rate and IPC for a larger cache?a 32K 2-way associative cache with two read/write ports. The final two columns show the miss rate and IPC for a single ported instruction cache?a 16K 2-way associative cache with one read/write port.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(a) Shows timing data for various first level FTB configurations. For each FTB specification (shown as the number of entries in a 4-way associative FTB), the cycle time in nanoseconds computed with CACTI is shown. (b) Shows the cycle times for a variety of cache configurations. The first column specifies the size of the cache. The second column specifies the associativity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. The performance of our prefetching techniques compared to prior work for an architecture with an eight byte/cycle bus to the L2 cache. Results are shown as percent speedup in IPC over a baseline architecture. The first bar represents next line prefetching (NLP) with cache probe filtering. The second two bars represent multiple stream buffers (MSB1 and MSB2?single and dual stream buffer configurations) with cache probe filtering. The fourth bar represents FDP with no cache probe filtering. The fifth bar represents FDP with remove CPF. The final bar represents FDP approach with enqueue CPF.</figDesc><graphic url="image-10.png" coords="11,53.57,328.20,459.33,198.99" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. This figure depicts a comparison of three different dual ported cache configurations. The first bar in each cluster represents the average speedup obtained for fetch-directed prefetching without filtration. The second bar shows results for remove CPF. The third shows results for enqueue CPF.</figDesc><graphic url="image-12.png" coords="12,292.14,509.95,245.14,198.43" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Results are given as the percent speedup in IPC over the base configuration. The first set of three columns shows the performance of unfiltered fetch directed prefetching, remove CPF, and enqueue CPF, respectively?all for a two entry FTQ. The next set of three columns represents the same prefetching techniques for a four entry FTQ. The remaining clusters of four columns represent eight, 16, 32, and 64 entry FTQs, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Billion Instructions per Second (BIPS) comparison across four FTB configurations. BIPS results were calculated using IPC values from SimpleScalar simulations and CACTI timing data. The first three bars for each benchmark represent single level FTB configurations with 64, 512, and 4,096 entries, respectively. These configurations have two cycle pipelined instruction cache and the cycle time for each is set according to the cycle time of the FTB (see Table2for timing data). The final bar represents an FTB with 4,096 entries that does not have a pipelined instruction cache. In this case, the cycle time is set to the cycle time of the instruction cache.</figDesc><graphic url="image-14.png" coords="13,54.54,226.89,457.40,201.15" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Instructions per cycle (IPC) comparison across a variety of FTB configurations. The first five bars represent single level FTB configurations: 64, 256, 512, 1,024, and 4,096 entry first level FTBs. The next four bars represent dual level FTB configurations: 64, 128, 256, and 512 entry first level FTBs, each with an 8,192 entry second level FTB.</figDesc><graphic url="image-16.png" coords="14,53.74,319.35,458.99,199.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Billion Instructions per Second (BIPS) comparison across a variety of FTB configurations. BIPS results were calculated using IPC values from SimpleScalar simulations and CACTI timing data. The bars for each benchmark represent different FTB configurations. The first five bars represent single level FTB configuations: 64, 256, 512, 1,024, and 4,096 entry first level FTBs. The next four bars represent dual level FTB configurations: 64, 128, 256, and 512 entry first level FTBs, each with an 8,192 entry second level FTB.</figDesc><graphic url="image-18.png" coords="15,55.11,320.54,456.21,198.43" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 14 .</head><label>14</label><figDesc>Fig.14. Fetch Target Buffer performance for HXIH"m feature size using technology scaling calculations from<ref type="bibr" target="#b26">[27]</ref> modeling the potential effect of the interconnect scaling bottleneck.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. This figure shows IPC results for a two level FTB (128 entry first level, 8,192 entry second level) without an FTQ and with a 32 entry FTQ. The x-axis shows the benchmarks we examined and an average.</figDesc><graphic url="image-21.png" coords="16,54.14,533.99,458.14,199.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic url="image-6.png" coords="7,101.76,69.17,362.95,289.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE 1 Program</head><label>1</label><figDesc>Statistics for the Baseline Architecture</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 2 Timing</head><label>2</label><figDesc>Data from CACTI Version 2.0</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 4</head><label>4</label><figDesc>Performance of the Three FDP Architectures for a Variety of FTQ Sizes</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 5 Timing</head><label>5</label><figDesc>Data from</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>We would like to thank the anonymous reviewers for providing useful comments on this paper. This work was funded in part by <rs type="funder">US National Science Foundation (NSF) CAREER</rs> grant No. <rs type="grantNumber">CCR-9733278</rs>, <rs type="funder">NSF</rs> grant No. <rs type="grantNumber">CCR-9808697</rs>, and a grant from <rs type="funder">Compaq Computer Corporation</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_KPTzz5b">
					<idno type="grant-number">CCR-9733278</idno>
				</org>
				<org type="funding" xml:id="_QTPhXwT">
					<idno type="grant-number">CCR-9808697</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Glenn Reinman received a BS degree from the Massachusetts Institute of Technology in computer science and engineering in 1996. He is a graduate student in the PhD program at the University of California, San Diego. He is currently researching low-power techniques to improve processor performance in the face of future technology scaling problems. Aside from exploring optimizations enabled by the decoupled front-end, he is working on cache modeling, speculative fetch architectures, and value prediction. He has also worked in the area of parallel computation, exploring Process migration.</p><p>Brad Calder received his PhD degree in computer science from the University of Colorado, Boulder in 1995. He obtained a BS degree in computer science and a BS degree in mathematics from the University of Washington in 1991. He is an associate professor of computer science and engineering at the University of California, San Diego (UCSD). Before joining UCSD in January of 1997, he cofounded a startup called Tracepoint, which built performance analysis tools using x86 binary modification technology. In addition, he has worked as a principal engineer at Digital Equipment Corporation's Western Research Lab in Palo Alto, California. His research focuses on the interaction between computer architecture and compilers. His current work focuses on optimizations for reducing memory latency, fetch prediction architectures, adaptive power optimizations, value prediction, predicated execution, and multiple path execution. He is a recipient of a US National Science Foundation CAREER Award. He is a member of the IEEE.</p><p>Todd Austin received his PhD degree in computer science from the University of Wisconsin in 1996. He is an assistant professor of computer science and engineering at the University of Michigan, Ann Arbor. His research interests include computer architecture, compilers, computer system verification, and performance analysis tools and techniques. Prior to joining academia, he was a senior computer architect in Intel's Microcomputer Research Labs, a product-oriented research laboratory in Hillsboro, Oregon. He is the first to take credit (but the last to accept blame) for creating the SimpleScalar tool set, a popular collection of computer architecture performance analysis tools. He is a member of the IEEE.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName><forename type="first">V</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hrishikesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">?Clock Rate versus IPC: The End of the Road for Conventional Microarchitectures,? Proc. 27th Ann. Int&apos;l Symp</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">?Integrating a Misprediction Recovery Cache (MRC) into a Superscalar Pipeline</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">O</forename><surname>Bondi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Nanda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dutta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th Ann. Int&apos;l Symp. Microarchitecture</title>
		<meeting>29th Ann. Int&apos;l Symp. Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1996-12">Dec. 1996</date>
			<biblScope unit="page" from="14" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Austin</surname></persName>
		</author>
		<idno>CS-TR-97-1342</idno>
		<title level="m">?The Simplescalar Tool Set, Version 2.0,?</title>
		<meeting><address><addrLine>Madison</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
		<respStmt>
			<orgName>Univ. of Wisconsin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">?Fast and Accurate Instruction Fetch and Branch Prediction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grunwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st Int&apos;l Symp. Computer Architecture</title>
		<meeting>21st Int&apos;l Symp. Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1994-04">Apr. 1994</date>
			<biblScope unit="page" from="2" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">?Reducing Branch Costs via Branch Alignment</title>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grunwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Sixth Int&apos;l Conf. Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>Sixth Int&apos;l Conf. Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="1994-10">Oct. 1994</date>
			<biblScope unit="page" from="242" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">?Target Prediction for Indirect Jumps</title>
		<author>
			<persName><forename type="first">P</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Ann. Int&apos;l Symp. Computer Architecture</title>
		<meeting>24th Ann. Int&apos;l Symp. Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
			<biblScope unit="page" from="274" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">?Instruction Prefetching Using Branch Prediction Information</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Mudge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Computer Design</title>
		<meeting>Int&apos;l Conf. Computer Design</meeting>
		<imprint>
			<date type="published" when="1997-10">Oct. 1997</date>
			<biblScope unit="page" from="593" to="601" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">?Effective Hardware-Based Data Prefetching for High Performance Processors</title>
		<author>
			<persName><forename type="first">T.-F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-L</forename><surname>Baer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="609" to="623" />
			<date type="published" when="1995-05">May 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Baer</surname></persName>
		</author>
		<title level="m">?Reducing Memory Latency via Non-Blocking and Prefetching Caches,? Proc. Fourth Int&apos;l Conf. Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV)</title>
		<imprint>
			<date type="published" when="1992-10">Oct. 1992</date>
			<biblScope unit="page" from="51" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Conte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">N</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Mills</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">?Optimization of Instruction Fetch Mechanisms for High Issue Rates,? Proc. 22nd Ann. Int&apos;l Symp</title>
		<title level="s">Computer Architecture</title>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="333" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">I</forename><surname>Farkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chow</surname></persName>
		</author>
		<title level="m">?How Useful Are Non-Blocking Loads, Stream Buffers and Speculative Execution in Multiple Issue Processors?? Proc. First Int&apos;l Symp. High-Performance Computer Architecture</title>
		<imprint>
			<date type="published" when="1995-01">Jan. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">?Trace Scheduling: A Technique for Global Microcode Compaction</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Fisher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="478" to="490" />
			<date type="published" when="1981-07">July 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">?Speculative Execution Based on Value Prediction,? EE Dept</title>
		<author>
			<persName><forename type="first">F</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mendelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Technion-Israel Inst. of Technology</title>
		<imprint>
			<biblScope unit="volume">1080</biblScope>
			<date type="published" when="1996-11">Nov. 1996</date>
		</imprint>
	</monogr>
	<note>TR</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">?The Potential of Data Value Speculation to Boost ILP</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int&apos;l Conf. Supercomputing</title>
		<meeting>12th Int&apos;l Conf. Supercomputing</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">?Increasing the Instruction Fetch Rate via Block-Structured Instruction Set Architectures</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Evers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th Ann. Int&apos;l Symp. Microarchitecture</title>
		<meeting>29th Ann. Int&apos;l Symp. Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1996-12">Dec. 1996</date>
			<biblScope unit="page" from="191" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">?Improving Direct-Mapped Cache Performance by the Addition of a Small Fully Associative Cache and Prefetch Buffers,? Proc</title>
		<author>
			<persName><forename type="first">N</forename><surname>Jouppi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">17th Ann. Int&apos;l Symp. Computer Architecture</title>
		<imprint>
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J E</forename><surname>Wilton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">?Tradeoffs in Two-Level On-Chip Caching,? Proc. 21st Ann. Int&apos;l Symp</title>
		<imprint>
			<date type="published" when="1994-04">Apr. 1994</date>
			<biblScope unit="page" from="34" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">?The Effects of Mispredicted-Path Execution on Branch Prediction Structures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jourdan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hsing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Parallel Architectures and Compilation Techniques</title>
		<meeting>Int&apos;l Conf. Parallel Architectures and Compilation Techniques</meeting>
		<imprint>
			<date type="published" when="1996-10">Oct. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">?Value Locality and Load Value Prediction</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th Int&apos;l Conf. Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>17th Int&apos;l Conf. Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="1996-10">Oct. 1996</date>
			<biblScope unit="page" from="138" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">?Exceeding the Dataflow Limit via Value Prediction</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th Int&apos;l Symp. Microarchitecture</title>
		<meeting>29th Int&apos;l Symp. Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1996-12">Dec. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">?Combining Branch Predictors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mcfarling</surname></persName>
		</author>
		<idno>TN-36</idno>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
		</imprint>
		<respStmt>
			<orgName>Digital Equipment Corporation, Western Research Lab.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">?Exploring Instruction-Fetch Bandwidth Requirement in Wide-Issue Superscalar Processors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Michaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jourdan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Parallel Architectures and Compilation Techniques</title>
		<meeting>Int&apos;l Conf. Parallel Architectures and Compilation Techniques</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Palacharla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
		<title level="m">?Complexity-Effective Superscalar Processors,? Proc. 24th Ann. Int&apos;l Symp. Computer Architecture</title>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
			<biblScope unit="page" from="206" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Palacharla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kessler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">?Evaluating Stream Buffers as Secondary Cache Replacement,? Proc. 21st Ann. Int&apos;l Symp</title>
		<imprint>
			<date type="published" when="1994-04">Apr. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Friendly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Patt</surname></persName>
		</author>
		<title level="m">?Critical Issues Regarding the Trace Cache Fetch Mechanism,? CSE-TR-335-97</title>
		<imprint>
			<date type="published" when="1997-05">May 1997</date>
		</imprint>
		<respStmt>
			<orgName>Univ. of Michigan</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">?Branch Target Buffer Design and Optimization</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Perleberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="396" to="412" />
			<date type="published" when="1993-04">Apr. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<title level="m">?A Scalable Front-End Architecture for Fast Instruction Delivery,? Proc. 26th Ann. Int&apos;l Symp. Computer Architecture</title>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<title level="m">?Predictive Techniques for Aggressive Load Speculation,? Proc. 31st Int&apos;l Symp. Microarchitecture</title>
		<imprint>
			<date type="published" when="1998-12">Dec. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<title level="m">?Fetch Directed Instruction Prefetching,? Proc. 32nd Int&apos;l Symp. Microarchitecture</title>
		<imprint>
			<date type="published" when="1999-11">Nov. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">G</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jouppi</surname></persName>
		</author>
		<ptr target="http://www.research.digital.com/wrl/people/jouppi/CACTI.html" />
		<imprint>
			<date type="published" when="1999-06">June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Rotenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
		<title level="m">?Trace Cache: A Low Latency Approach to High Bandwidth Instruction Fetching,? Proc. 29th Ann. Int&apos;l Symp. Microarchitecture</title>
		<imprint>
			<date type="published" when="1996-12">Dec. 1996</date>
			<biblScope unit="page" from="24" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><forename type="first">Y</forename><surname>Sazeides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
		<title level="m">?The Predictability of Data Values,? Proc. 30th Int&apos;l Symp. Microarchitecture</title>
		<imprint>
			<date type="published" when="1997-12">Dec. 1997</date>
			<biblScope unit="page" from="248" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jourdan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sainrat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Michaud</surname></persName>
		</author>
		<title level="m">?Multiple-Block Ahead Branch Predictors,? Proc. Seventh Int&apos;l Conf. Architectural Support for Programming Languages and Operating Systems</title>
		<imprint>
			<date type="published" when="1996-10">Oct. 1996</date>
			<biblScope unit="page" from="116" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<title level="m">?Predictor-Directed Stream Buffers,? Proc. 33rd Int&apos;l Symp. Microarchitecture</title>
		<imprint>
			<date type="published" when="2000-12">Dec. 2000</date>
			<biblScope unit="page" from="42" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Skadron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ahuja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clark</surname></persName>
		</author>
		<title level="m">?Improving Prediction for Procedure Returns with Return-Address-Stack Repair Mechanisms,? Proc. 31st Ann. Int&apos;l Symp. Microarchitecture</title>
		<imprint>
			<date type="published" when="1998-12">Dec. 1998</date>
			<biblScope unit="page" from="259" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">?Speculative Updates of Local and Global branch History: A Quantitative Analysis</title>
		<author>
			<persName><forename type="first">K</forename><surname>Skadron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clark</surname></persName>
		</author>
		<idno>TR-589-98</idno>
		<imprint>
			<date type="published" when="1998-12">Dec. 1998</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, Princeton Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
		<title level="m">?Cache Memories,? Computing Surveys</title>
		<imprint>
			<date type="published" when="1982-09">Sept. 1982</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="473" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Hsu</surname></persName>
		</author>
		<title level="m">Supercomputer Instruction Caches,? Proc. Supercomputing</title>
		<imprint>
			<date type="published" when="1992-11">Nov. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">?Reducing the Performance Impact of Instruction Cache Misses by Writing Instructions into the Reservation Stations Out-of-Order</title>
		<author>
			<persName><forename type="first">J</forename><surname>Stark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Racunas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th Int&apos;l Symp. Microarchitecture</title>
		<meeting>30th Int&apos;l Symp. Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1997-12">Dec. 1997</date>
			<biblScope unit="page" from="34" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><surname>Uhlig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nagle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mudge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sechrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">?Instruction Fetching: Coping with Code Bloat,? Proc. 22nd Ann. Int&apos;l Symp</title>
		<title level="s">Computer Architecture</title>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="345" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">?Highly Accurate Data Value Prediction Using Hybrid Predictors,? Proc. 30th Ann</title>
		<author>
			<persName><forename type="first">K</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int&apos;l Symp. Microarchitecture</title>
		<imprint>
			<date type="published" when="1997-12">Dec. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Level Adpative Branch Prediction and Instruction Fetch Mechanisms for High Performance Superscalar Processors,? PhD dissertation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Yeh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Univ. of Michigan</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Patt</surname></persName>
		</author>
		<title level="m">?A Comprehensive Instruction Fetch Mechanism for a Processor Supporting Speculative Execution,? Proc. 25th Ann. Int&apos;l Symp. Microarchitecture</title>
		<imprint>
			<date type="published" when="1992-12">Dec. 1992</date>
			<biblScope unit="page" from="129" to="139" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
