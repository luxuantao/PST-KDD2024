<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Generalisation, a Simplification and some Applications of Paillier&apos;s Probabilistic Public-Key System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ivan</forename><surname>Damgård</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Aarhus</orgName>
								<orgName type="institution" key="instit2">BRICS</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mads</forename><surname>Jurik</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Aarhus</orgName>
								<orgName type="institution" key="instit2">BRICS</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Generalisation, a Simplification and some Applications of Paillier&apos;s Probabilistic Public-Key System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4E3C3CD6C44169FE14577EA1AB5E1813</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose a generalisation of Paillier's probabilistic public key system, in which the expansion factor is reduced and which allows to adjust the block length of the scheme even after the public key has been fixed, without loosing the homomorphic property. We show that the generalisation is as secure as Paillier's original system. We construct a threshold variant of the generalised scheme as well as zero-knowledge protocols to show that a given ciphertext encrypts one of a set of given plaintexts, and protocols to verify multiplicative relations on plaintexts. We then show how these building blocks can be used for applying the scheme to efficient electronic voting. This reduces dramatically the work needed to compute the final result of an election, compared to the previously best known schemes. We show how the basic scheme for a yes/no vote can be easily adapted to casting a vote for up to t out of L candidates. The same basic building blocks can also be adapted to provide receipt-free elections, under appropriate physical assumptions. The scheme for 1 out of L elections can be optimised such that for a certain range of parameter values, a ballot has size only O(log L) bits.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In <ref type="bibr" target="#b8">[9]</ref>, Paillier proposes a new probabilistic encryption scheme based on computations in the group Z * n 2 , where n is an RSA modulus. This scheme has some very attractive properties, in that it is homomorphic, allows encryption of many bits in one operation with a constant expansion factor, and allows efficient decryption. In this paper we propose a generalisation of Paillier's scheme using computations modulo n s+1 , for any s ≥ 1. We also show that the system can be simplified (without degrading security) such that the public key can consist of only the modulus n. This allows instantiating the system such that the block length for the encryption can be chosen freely for each encryption, independently of the size of the public key, and without loosing the homomorphic property. The generalisation also allows reducing the expansion factor from 2 for Paillier's original system to almost 1. We prove that the generalisation is as secure as Paillier's original scheme.</p><p>We propose a threshold variant of the generalised system, allowing a number of servers to share knowledge of the secret key, such that any large enough subset of them can decrypt a ciphertext, while smaller subsets have no useful information. We prove in the random oracle model that the scheme is as secure as a standard centralised implementation.</p><p>We also propose a zero-knowledge proof of knowledge allowing a prover to show that a given ciphertext encodes a given plaintext. From this we derive other tools, such as a protocol showing that a ciphertext encodes one out of a number of given plaintexts. Finally, we propose a protocol that allows verification of multiplicative relations among encrypted values without revealing extra information.</p><p>We look at applications of this to electronic voting schemes. A large number of such schemes is known, but the most efficient one, at least in terms of the work needed from voters, is by Cramer, Gennaro and Schoenmakers <ref type="bibr" target="#b3">[4]</ref>. This protocol provides in fact a general framework that allows usage of any probabilistic encryption scheme for encryption of votes, if the encryption scheme has a set of "nice" properties, in particular it must be homomorphic. The basic idea of this is straightforward: each voter broadcasts an encryption of his vote (by sending it to a bulletin board) together with a proof that the vote is valid. All the valid votes are then combined to produce an encryption of the result, using the homomorphic property of the encryption scheme. Finally, a set of trustees (who share the secret key of the scheme in a threshold fashion) can decrypt and publish the result.</p><p>Paillier pointed out already in <ref type="bibr" target="#b8">[9]</ref> that since his encryption scheme is homomorphic, it may be applicable to electronic voting. In order to apply it in the framework of <ref type="bibr" target="#b3">[4]</ref>, however, some important building blocks are missing: one needs an efficient proof of validity of a vote, and also an efficient threshold variant of the scheme, so that the result can be decrypted without allowing a single entity the possibility of learning how single voters voted.</p><p>These building blocks are precisely what we provide here. Thus we immediately get a voting protocol. In this protocol, the work needed from the voters is of the same order as in the original version of <ref type="bibr" target="#b3">[4]</ref>. However, the work needed to produce the result is reduced dramatically, as we now explain. With the El Gamal encryption used in <ref type="bibr" target="#b3">[4]</ref>, the decryption process after a yes/no election produces g R mod p, where p is prime, g is a generator and R is the desired result. Thus one needs to solve a discrete log problem in order to find the result. Since R is bounded by the number of voters M , this is feasible for moderate size M 's. But it requires Ω( √ M) exponentiations, and may certainly be something one wants to avoid for large scale elections. The problem becomes worse, if we consider an election where we choose between L candidates, L ≥ 2. The method given for this in <ref type="bibr" target="#b3">[4]</ref> is exponential in L in that it requires time Ω(</p><formula xml:id="formula_0">√ M L-1</formula><p>), and so is prohibitively expensive for elections with large L.</p><p>In the scheme we propose below, this work can be removed completely. Our decryption process produces the desired result directly. We also give ways to implement efficiently constraints on voting that occur in real elections, such as allowing to vote for precisely t out of the L candidates, or to vote for up to t of them. In each of these schemes, the size of a single ballot is O(k•L), where k is the bit length of the modulus used<ref type="foot" target="#foot_1">1</ref> . We propose a variant using a different technique where ballots have size O(max(k, L log M ) • log L). Thus for k ≥ L log M , this is much more efficient, and even optimal up to a constant factor, since with less than log L bits one cannot distinguish between the L candidates. Furthermore this scheme requires only 1 decryption operation, even when L &gt; 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>In work independent from, but earlier than ours, Fouque, Poupard and Stern <ref type="bibr" target="#b5">[6]</ref> proposed the first threshold version of Paillier's original scheme. Like our threshold scheme, <ref type="bibr" target="#b5">[6]</ref> uses an adaptation of Shoup's threshold RSA scheme <ref type="bibr" target="#b9">[10]</ref>, but beyond this the techniques are somewhat different, in particular because we construct a threshold version for our generalised crypto system (and not only Paillier's original scheme). In <ref type="bibr" target="#b5">[6]</ref> voting was also pointed out as a potential application, however, no suggestion was made there for protocols to prove that an encrypted vote is correctly formed, something that is of course necessary for a secure election in practice.</p><p>In work done concurrently with and independent from ours, Baudron, Fouque, Pointcheval, Poupard and Stern <ref type="bibr" target="#b0">[1]</ref> propose a voting scheme somewhat similar to ours. Their work can be seen as being complementary to ours in the sense that their proposal is more oriented towards the system architectural aspects of a large scale election, and less towards optimisation of the building blocks. To compare to their scheme, we first note that there the modulus length k must be chosen such that k &gt; L log M . The scheme produces ballots of size O(k • L). An estimate with explicit constants is given in <ref type="bibr" target="#b0">[1]</ref> in which the dominating term in our notation is 9kL.</p><p>Because our voting scheme uses the generalised Paillier crypto system, k can be chosen freely, and the voting scheme can still accommodate any values of L, M . If we choose k as in <ref type="bibr" target="#b0">[1]</ref>, i.e. k &gt; L log M , then the ballots we produce have size O(k • log L). Working out the concrete constants involved, one finds that our complexity is dominated by the term 11k log L. So for large scale elections we have gained a significant factor in complexity compared to <ref type="bibr" target="#b0">[1]</ref>.</p><p>In <ref type="bibr" target="#b7">[8]</ref>, Hirt and Sako propose a general method for building receipt-free election schemes, i.e. protocols where vote-buying or -coercing is not possible because voters cannot prove to others how they voted. Their method can be applied to make a receipt-free version of the scheme from <ref type="bibr" target="#b3">[4]</ref>. It can also be applied to our scheme, with the same efficiency gain as in the non-receipt free case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A Generalisation of Paillier's Probabilistic Encryption Scheme</head><p>The public-key crypto-system we describe here uses computations modulo n s+1 where n is an RSA modulus and s is a natural number. It contains Paillier's scheme <ref type="bibr" target="#b8">[9]</ref> as a special case by setting s = 1.</p><p>We start from the observation that if n = pq, p, q odd primes, then</p><formula xml:id="formula_1">Z * n s+1</formula><p>as a multiplicative group is a direct product G × H, where G is cyclic of order n s and H is isomorphic to Z * n , which follows directly from elementary number theory. Thus, the factor group Ḡ = Z * n s+1 /H is also cyclic of order n s . For an arbitrary element a ∈ Z * n s+1 , we let ā = aH denote the element represented by a in the factor group Ḡ.</p><p>Lemma 1. For any s &lt; p, q, the element n + 1 has order n s in Z * n s+1 .</p><p>Proof. Consider the integer (1 + n) i = i j=0 i j n j . This number is 1 modulo n s+1 for some i if and only if i j=1 i j n j-1 is 0 modulo n s . Clearly, this is the case if i = n s , so it follows that the order of 1 + n is a divisor in n s , i.e., it is a number of form p α q β , where α, β ≤ s. Set a = p α q β , and consider a term a j n j-1 in the sum a j=1 a j n j-1 . We claim that each such term is divisible by a: this is trivial if j &gt; s, and for j ≤ s, it follows because j! can then not have p or q as prime factors, and so a must divide a j . Now assume for contradiction that a = p α q β &lt; n s . Without loss of generality, we can assume that this means α &lt; s. We know that n s divides a j=1 a j n j-1 . Dividing both numbers by a, we see that p must divide the number a j=1 a j n j-1 /a. However, the first term in this sum after division by a is 1, and all the rest are divisible by p, so the number is in fact 1 modulo p, and we have a contradiction.</p><p>Since the order of H is relatively prime to n s this implies immediately that the element 1 + n := (1 + n)H ∈ Ḡ is a generator of Ḡ, except possibly for s ≥ p, q. So the cosets of H in Z * n s+1 are</p><formula xml:id="formula_2">H, (1 + n)H, (1 + n) 2 H, ..., (1 + n) n s -1 H,</formula><p>which leads to a natural numbering of these cosets.</p><p>The final technical observation we need is that it is easy to compute i from (1 + n) i mod n s+1 . We now show how to do this. If we define the function L() by L(b) = (b -1)/n then clearly we have</p><formula xml:id="formula_3">L((1 + n) i mod n s+1 ) = (i + i 2 n + ... + i s n s-1 ) mod n s</formula><p>We now describe an algorithm for computing i from this number. The general idea of the algorithm is to extract the value part by part, so that we first extract i 1 = i mod n, then i 2 = i mod n 2 and so forth. It is easy to extract i 1 = L((1 + n) i mod n 2 ) = i mod n. Now we can extract the rest by the following induction step: In the j'th step we know i j-1 . This means that i j = i j-1 + k * n j-1 for some 0 ≤ k &lt; n. If we use this in</p><formula xml:id="formula_4">L((1 + n) i mod n j+1 ) = (i j + i j 2 n + ... + i j j n j-1 ) mod n j</formula><p>We can notice that each term ij t+1 n t for j &gt; t &gt; 0 satisfies that ij t+1 n t = ij-1 t+1 n t mod n j . This is because the contributions from k * n j-1 vanish modulo n j after multiplication by n. This means that we get:</p><formula xml:id="formula_5">L((1 + n) i mod n j+1 ) = (i j-1 + k * n j-1 + i j-1 2 n + ...+ i j-1 j n j-1 ) mod n j</formula><p>Then we just rewrite that to get what we wanted</p><formula xml:id="formula_6">i j = i j-1 + k * n j-1 = i j-1 + L((1 + n) i mod n j+1 ) -(i j-1 + i j-1 2 n + ... + i j-1 j n j-1 ) mod n j = L((1 + n) i mod n j+1 ) -( i j-1 2 n + ... + i j-1 j n j-1 ) mod n j</formula><p>This equation leads to the following algorithm: i := 0; for j:= 1 to s do begin t 1 := L(a mod n j+1 ); t 2 := i; for k:= 2 to j do begin i := i -1;</p><formula xml:id="formula_7">t 2 := t 2 * i mod n j ; t 1 := t 1 -t2 * n k-1 k! mod n j ; end i := t 1 ; end</formula><p>We are now ready to describe our cryptosystem. In fact, for each natural number s, we can build a cryptosystem CS s , as follows: Key Generation On input the security parameter k, choose an RSA modulus n = pq of length k bits<ref type="foot" target="#foot_2">2</ref> . Also choose an element g ∈ Z * n s+1 such that g = (1 + n) j x mod n s+1 for a known j relatively prime to n and x ∈ H. This can be done, e.g., by choosing j, x at random first and computing g; some alternatives are described later. Let λ be the least common multiple of p -1 and q -1. By the Chinese Remainder Theorem, choose d such that d mod n ∈ Z * n and d = 0 mod λ. Any such choice of d will work in the following. In Paillier's original scheme d = λ was used, which is the smallest possible value. However, when making a threshold variant, other choices are better -we expand on this in the following section. Now the public key is n, g while the secret key is d. encryption The plaintext set is Z n s . Given a plaintext i, choose a random r ∈ Z * n s+1 , and let the ciphertext be</p><formula xml:id="formula_8">E(i, r) = g i r n s mod n s+1 . decryption Given a ciphertext c, first compute c d mod n s+1 . Clearly, if c = E(v, r), we get c d = (g i r n s ) d = ((1 + n) ji x i r n s ) d = (1 + n) jid mod n s (x i r n s ) d mod λ = (1 + n) jid mod n s</formula><p>Now apply the above algorithm to compute jid mod n s . Applying the same method with c replaced by g clearly produces the value jd mod n s , so this can either be computed on the fly or be saved as part of the secret key. In any case we obtain the cleartext by (jid)</p><formula xml:id="formula_9">• (jd) -1 = i mod n s .</formula><p>Clearly, this system is additively homomorphic over Z n s , that is, the product of encryptions of messages i, i is an encryption of i + i mod n s .</p><p>The security of the system is based on the following assumption, introduced by Paillier in <ref type="bibr" target="#b8">[9]</ref> the decisional composite residuosity assumption (DCRA): Conjecture 1. Let A be any probabilistic polynomial time algorithm, and assume A gets n, x as input. Here n has k bits, and is chosen as described above, and x is either random in Z * n 2 or it is a random n'th power in Z * n 2 (that is, a random element in the subgroup H defined earlier). A outputs a bit b.</p><formula xml:id="formula_10">Let p 0 (A, k) be the probability that b = 1 if x is random in Z * n 2 and p 1 (A, k) the probability that b = 1 if x is a random n'th power. Then | p 0 (A, k) -p 1 (A, k) | is negligible in k.</formula><p>Here, "negligible in k" as usual means smaller than 1/f (k) for any polynomial f () and all large enough k.</p><p>We now discuss the semantic security of CS s . There are several equivalent formulations of semantic security. We will use the following: Definition 1. An adversary A against a public-key cryptosystem gets the public key pk generated from secuity parameter k as input and outputs a message m. Then A is given an encryption under pk of either m or a message chosen uniformly in the message space, and outputs a bit. Let p 0 (A, k), respectively p 1 (A, k) be the probability that A outputs 1 when given an encryption of m, respectively a random encryption. Define the advantage of A to be</p><formula xml:id="formula_11">Adv(A, k) = |p 0 (A, k) -p 1 (A, k)|. The cryptosystem is semantically secure if for any probabilistic polynomial time adversary A, Adv(A, k) is negligible in k.</formula><p>In <ref type="bibr" target="#b8">[9]</ref>, Paillier showed that semantic security of his cryptosystem (which is the same as our CS 1 ) is equivalent to DCRA. This equivalence holds for any choice of g, and follows easily from the fact that given a ciphertext c that is either random or encrypts a message i, cg -i mod n 2 is either random in Z * n 2 or a random n'th power. In particular one may choose g = n + 1 always without degrading security. We do this in the following for simplicity, so that a public key consists only of the modulus n. We now show that in fact security of CS s is equivalent to DCRA: Theorem 1. For any s, the cryptosystem CS s is semantically secure if and only if the DCRA assumption is true.</p><p>Proof. From a ciphertext in CS s , one can obtain a ciphertext in CS 1 by reducing modulo n 2 , this implicitly reduces the message modulo n. It is therefore clear that if DCRA fails, then CS s cannot be secure for any s. For the converse, we show by induction on s that security of CS s follows from DCRA. For s = 1, this is exact.ly Paillier's result. So take any s &gt; 1 and assume that CS t for any t &lt; s is secure.</p><p>The message space of CS s is Z n s . Thus any message m can be written in n-adic notation as an s-tuple (m s , m s-1 , ..., m 1 ), where each m i ∈ Z n and m = s-1 i=0 m i+1 n i . Let D n (m s , ..., m 1 ) be the distribution obtained by encrypting the message (m s , ..., m 1 ) under public key n. If one or more of the m i are replaced by * 's, this means that the corresponding position in the message is chosen uniformly in Z n before encrypting. Now, assume for contradiction that CS s is insecure, thus there is an adversary A, such that for infinitely many k, Adv(A, k) ≥ 1/f (k) for some polynomial f (). Take such a k. Without loss of generality, assume we have p 0 (A, k)p 1 (A, k) ≥ 1/f (k). Suppose we make a public key n from security parameter k, show it to A, get a message (m s , ..., m 1 ) from A and show A a sample of D n ( * , m s-1 , ..., m 1 ). Let q(A, k) be the probability that A now outputs 1. Of course, we must have</p><formula xml:id="formula_12">( * ) p 0 (A, k) -q(A, k) ≥ 1 2f (k) or q(A, k) -p 1 (A, k) ≥ 1 2f (k)</formula><p>for infinitely many k.</p><p>In the first case in ( * ), we can make a successful adversary against CS 1 , as follows: we get the public key n, show it to A, get (m s , ..., m 1 ), and return m s as output. We will get a ciphertext c that either encrypts m s in CS 1 , or is a random ciphertext, i.e., a random element from Z * n 2 . If we consider c as an element in Z * n s+1 , we know it is an encryption of some plaintext, which must have either m s or a random element in its least significant position. Hence c n s-1 mod n s+1 is an encryption of (m s , 0, ..., 0) or ( * , 0, ..., 0). We then make a random encryption d of (0, m s-1 , ..., m 1 ), give c n s-1 d mod n s+1 to A and return the bit A outputs. Now, if c encrypts m s , we have shown to A a sample of D n (m s , ..., m 1 ), and otherwise a sample of D n ( * , m s-1 , ..., m 1 ). So by assumption on A, this breaks CS 1 with an advantage of 1/2f (k), and so contradicts the induction assumption.</p><p>In the second case of ( * ), we can make an adversary against CS s-1 , as follows: we get the public key n, show it to A, and get a message (m s , ..., m 1 ). We output (m s-1 , ..., m 1 ) and get back a ciphertext c that encrypts in CS s-1 either (m s-1 , ..., m 1 ) or something random. If we consider c as a number modulo n s+1 , we know that the corresponding plaintext in CS s has either (m s-1 , ..., m 1 ) or random elements in the least significant s -1 positions -and something unknown in the top position. We make a random encryption d of ( * , 0, ..., 0), show cd mod n s+1 to A and return the bit A outputs. If c encrypted (m s-1 , ..., m 1 ), we have shown A a sample from D n ( * , m s-1 , ...., m 1 ), and otherwise a sample from D n ( * , ..., * ). So by asumption on A, this breaks CS s-1 with an advantage of 1/2f (k) and again contradicts the induction assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Adjusting the Block length</head><p>To facilitate comparison with Paillier's original system, we have kept the above system description as close as possible to that of Paillier. In particular, the description allows choosing g in a variety of ways. However, as mentioned, we may choose g = n + 1 always without loosing security, and the public key may then consist only of the modulus n. This means that we can let the receiver decide on s when he encrypts a message. More concretely, the system will work as follows:</p><p>Key Generation Choose an RSA modulus n = pq. Now the public key is n while the secret key is λ, the least common multiple of (p -1) and (q -1). encryption Given a plaintext i ∈ Z n s , choose a random r ∈ Z * n s+1 , and let the ciphertext be E(i, r) = (1 + n) i r n s mod n s+1 . decryption Given a ciphertext c, first compute, by the Chinese Remainder Theorem d, such that d = 1 mod n s and d = 0 mod λ (note that the length of the ciphertext allows to decide on the right value of s, except with negligible probability). Then compute c d mod n s+1 . Clearly, if c = E(i, r), we get</p><formula xml:id="formula_13">c d = ((1 + n) i r n s ) d = (1 + n) id mod n s (x i r n s ) d mod λ = (1 + n) i mod n s+1</formula><p>Now apply the above algorithm to compute i mod n s .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Some Building Blocks</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A Threshold Variant of the Scheme</head><p>What we are after in this section is a way to distribute the secret key to a set of servers, such that any subset of at least t of them can do decryption efficiently, while less than t have no useful information. Of course this must be done without degrading the security of the system. In <ref type="bibr" target="#b9">[10]</ref>, Shoup proposes an efficient threshold variant of RSA signatures. The main part of this is a protocol that allows a set of servers to collectively and efficiently raise an input number to a secret exponent modulo an RSA modulus n. A little more precisely: on input a, each server returns a share of the result, together with a proof of correctness. Given sufficiently many correct shares, these can be efficiently combined to compute a d mod n, where d is the secret exponent.</p><p>As we explain below it is quite simple to transplant this method to our case, thus allowing the servers to raise an input number to our secret exponent d modulo n s+1 . So we can solve our problem by first letting the servers help us compute E(i, r) d mod n s+1 . Then if we use g = n + 1 and choose d such that d = 1 mod n s and d = 0 mod λ, the remaining part of the decryption is easy to do without knowledge of d.</p><p>We warn the reader that this is only secure for the particular choice of d we have made, for instance, if we had used Paillier's original choice d = λ, then seeing the value E(i, r) d mod n s+1 would allow an adversary to compute λ and break the system completely. However, in our case, the exponentiation result can safely be made public, since it contains no trace of the secret λ.</p><p>A more concrete description: Compared to <ref type="bibr" target="#b9">[10]</ref> we still have a secret exponent d, but there is no public exponent e, so we will have to do some things slightly differently. We will assume that there are l decryption servers, and a minimum of k &lt; n/2 of these are needed to make a correct decryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Key generation</head><p>Key generation starts out as in <ref type="bibr" target="#b9">[10]</ref>: we find 2 primes p and q, that satisfies p = 2p + 1 and q = 2q + 1, where p and q are primes and different from p and q. We set n = pq and m = p q . We decide on some s &gt; 0, thus the plaintext space will be Z n s . We pick d to satisfy d = 0 mod m and d = 1 mod n s . Now we make the polynomial f (X) = k-1 i=0 a i X i mod n s m, by picking a i (for 0 &lt; i &lt; k) as random values from {0, • • • , n s * m -1} and a 0 = d. The secret share of the i'th authority will be s i = f (i) for 1 ≤ i ≤ l and the public key will be n. For verification of the actions of the decryption servers, we need the following fixed public values: v, generating the cyclic group of squares in Z * n s+1 and for each decryption server a verification key v i = v ∆si mod n s+1 , where ∆ = l!.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Encryption</head><p>To encrypt a message M , a random r ∈ Z * n s+1 is picked and the cipher text is computed as c = g M r n s mod n s+1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Share decryption</head><p>The i'th authority will compute c i = c 2∆si , where c is the ciphertext. Along with this will be a zero-knowledge proof that log c 4 (c 2 i ) = log v (v i ), which will convince us, that he has indeed raised to his secret exponent s i</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Share combining</head><p>If we have the required k (or more) number of shares with a correct proof, we can combine them into the result by taking a subset S of k shares and combine them to</p><formula xml:id="formula_14">c = i∈S c 2λ S 0,i i mod n s+1 where λ S 0,i = ∆ i ∈S\i -i i -i ∈ Z</formula><p>The value of c will have the form</p><formula xml:id="formula_15">c = c 4∆ 2 f (0) = c 4∆ 2 d . Noting that 4∆ 2 d = 0 mod λ and 4∆ 2 d = 4∆ 2 mod n s , we can conclude that c = (1 + n) 4∆ 2 M mod n s+1</formula><p>, where M is the desired plaintext, so this means we can compute M by applying the algorithm from Section 3 and multiplying the result by (4∆ 2 ) -1 mod n s . Compared to the scheme proposed in <ref type="bibr" target="#b5">[6]</ref>, there are some technical differences, apart from the fact that <ref type="bibr" target="#b5">[6]</ref> only works for the original Paillier version modulo n 2 : in <ref type="bibr" target="#b5">[6]</ref>, an extra random value related to the public element g is part of the public key and is used in the Share combining algorithm. This is avoided in our scheme by the way we choose d, and thus we get a slightly shorter public key and a slightly simpler decryption algorithm.</p><p>The system as described requires a trusted party to set up the keys. This may be acceptable as this is a once and for all operation, and the trusted party can delete all secret information as soon as the keys have been distributed. However, using multi-party computation techniques it is also possible to do the key generation without a trusted party.</p><p>Note that the key generation phase requires that a value of the parameter s is fixed. This means that the system will be able to handle messages encrypted modulo n s +1 , for any s ≤ s, simply because the exponent d satisfies d = 1 mod n s , for any s ≤ s. But it will not work if s &gt; s. If a completely general decryption procedure is needed, this can be done as well: If we assume that λ is secret-shared in the key set-up phase, the servers can compute a suitable d by running a secure protocol that first inverts λ modulo n s to get some x as result, and then computes the product d = xλ (over the integers). This does not require generic multi-party computation techniques, but can be done quite efficiently using techniques from <ref type="bibr" target="#b4">[5]</ref>. Note that, while this does require communication between servers, it is not needed for every decryption, but only once for every value of s that is used.</p><p>We can now show in the random oracle model that this threshold version is as secure as a centralised scheme where one trusted player does the decryption <ref type="foot" target="#foot_4">4</ref> , in particular the threshold version is secure relative to the same complexity assumption as the basic scheme. This can be done in a model where a static adversary corrupts up to k -1 players from the start. Concretely, we have:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. Assume the random oracle model and a static adversary that corrupts up to k -1 players from the beginning. Then we have: Given any cipher-text, the decryption protocol outputs the correct plaintext, except with negligible probability. Given an oracle that on input a ciphertext returns the corresponding plaintext, the adversary's view of the decryption protocol can be efficiently simulated with a statistically indistinguishable distribution.</head><p>The full proof will be included in the final version of this paper. Here we only give the basic ideas: correctness of the scheme is immediate assuming that the adversary can contribute bad values for the c i 's with only negligible probability. This, in turn, is ensured by soundness of the zero-knowledge proofs given for each c i .</p><p>For the simulation, we start from the public key n. Then we can simulate the shares s i1 , ..., s i k-1 of the bad players by choosing them as random numbers in an appropriate interval. Since d is fixed by the choice of n, this means that the shares of uncorrupted players and the polynomial f are now fixed as well, but are not easy for the simulator to compute.</p><p>However, if we choose v as a ciphertext with known plaintext m 0 , we can also compute what v f (0) would be, namely v f (0) = v d mod n s+1 = (1 + n) m0 mod n s+1 . Then by doing Lagrange interpolation "in the exponent" as in <ref type="bibr" target="#b9">[10]</ref>, we can compute correct values of v i = v ∆si for the uncorrupted players. When we get a ciphertext c as input, we ask the oracle for the plaintext m. This allows us to compute c d = (1 + n) m mod n s-1 . Again this means we can interpolate and compute the contributions c i from the uncorrupted players. Finally, the zeroknowledge property is invoked to simulate the proofs that these c i are correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Some Auxiliary Protocols</head><p>Suppose a prover P presents a sceptical verifier V with a ciphertext c and claims that it encodes plaintext i. A trivial way to convince V would be to reveal also the random choice r, then V can verify himself that c = E(i, r). However, for use in the following, we need a solution where no extra useful information is revealed.</p><p>It is easy to see that that this is equivalent to convincing V that cg -i mod n s+1 is an n s 'th power. So we now propose a protocol for this which is a simple generalisation of the one from <ref type="bibr" target="#b6">[7]</ref>. We note that this and the following protocols are not zero-knowledge as they stand, only honest verifier zero-knowledge. However, first zero-knowledge protocols for the same problems can be constructed from them using standard methods and secondly, in our applications, we will always be using them in a non-interactive variant based on the Fiat-Shamir heuristic, which means that we cannot obtain zero-knowledge, we can, however, obtain security in the random oracle model. As for soundness, we prove that the protocols satisfy so called special soundness (see <ref type="bibr" target="#b1">[2]</ref>), which in particular implies that they satisfy standard knowledge soundness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Protocol for n s 'th powers</head><p>Input: n, u Private Input for P : v, such that u = v n s mod n s+1 1. P chooses r at random mod n s+1 and sends a = r n s mod n s+1 to V 2. V chooses e, a random k bit number, and sends e to P . 3. P sends z = rv e mod n s+1 to V , and V checks that z n s = au e mod n s+1 , and accepts if and only if this is the case.</p><p>It is now simple to show Lemma 2. The above protocol is complete, honest verifier zero-knowledge, and satisfies that from any pair of accepting conversations (between V and any prover) of form (a, e, z), (a, e , z ) with e = e , one can efficiently compute an n s 'th root of u, provided 2 t is smaller than the smallest prime factor of n.</p><p>Proof. Completeness is obvious from inspection of the protocol. For honest verifier simulation, the simulator chooses a random z ∈ Z * n s+1 , a random e, sets a = z n s u -e mod n s+1 and outputs (a, e, z). This is easily seen to be a perfect simulation.</p><p>For the last claim, observe that since the conversations are accepting, we have z n s = au e mod n s+1 and z n s = au e mod n s+1 , so we get</p><formula xml:id="formula_16">(z/z ) n s = u e-e mod n s+1</formula><p>Since ee is prime to n by the assumption on 2 t , choose α, β such that αn s + β(ee ) = 1. Then let v = u α (z/z ) β mod n s+1 . We then get</p><formula xml:id="formula_17">v n s = u αn s (z/z ) n s β = u αn s u β(e-e ) = u mod n s+1</formula><p>so that v is indeed the desired n s 'th root of u</p><p>In our application of this protocol, the modulus n will be chosen by a trusted party, or by a multi-party computation such that n has two prime factors of roughly the same size. Hence, if k is the bit length of n, we can set t = k/2 and be assured that a cheating prover can make the verifier accept with probability ≤ 2 -t .</p><p>The lemma immediately implies, using the techniques from <ref type="bibr" target="#b1">[2]</ref>, that we can build an efficient proof that an encryption contains one of two given values, without revealing which one it is: given the encryption C and the two candidate plaintexts i 1 , i 2 , prover and verifier compute u 1 = C/g i1 mod n s+1 , u 2 = C/g i2 mod n s+1 , and the prover shows that either u 1 or u 2 is an n s 'th power. This can be done using the following protocol, where we assume without loss of generality that the prover knows an n s 'th root u 1 , and where M denotes the honest-verifier simulator for the n s -power protocol above:</p><formula xml:id="formula_18">Protocol 1-out-of-2 n s 'th power Input: n, u 1 , u 2 Private Input for P : v 1 , such that u 1 = v n s 1 mod n s+1</formula><p>1. P chooses r 1 at random mod n s+1 . He invokes M on input n, u 2 to get a conversation a 2 , e 2 , z 2 . He sends a 1 = r n s 1 mod n s+1 , a 2 to V 2. V chooses s, a random t bit number, and sends s to P . 3. P computes e 1 = se 2 mod 2 t and z 1 = r 1 v e1 1 mod n s+1 . He then sends e 1 , z 1 , e 2 , z 2 to V . 4. V checks that s = e 1 + e 2 mod 2 t , z n s 1 = a 1 u e1 1 mod n s+1 and z n s 2 = a 2 u e2 2 mod n s+1 , and accepts if and only if this is the case.</p><p>The proof techniques from <ref type="bibr" target="#b1">[2]</ref> and Lemma 2 immediately imply Lemma 3. Protocol 1-out-of-2 n s 'th power is complete, honest verifier zeroknowledge, and satisfies that from any pair of accepting conversations (between V and any prover) of form (a 1 , a 2 , s, e 1 , z 1 , e 2 , z 2 ), (a 1 , a 2 , s , e 1 , z 1 , e 2 , z 2 ) with s = s , one can efficiently compute an n s 'th root of u 1 , and an n s 'th root of u 2 , provided 2 t is less than the smallest prime factor of n.</p><p>Our final building block allows a prover to convince a verifier that three encryptions contain values a, b and c such that ab = c mod n s . For this, we propose a protocol inspired by a similar construction found in <ref type="bibr" target="#b2">[3]</ref>. ) -1 mod n s+1 . 4. V verifies that the openings of encryptions in the previous step were correct, and accepts if and only if this was the case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Protocol Multiplication-mod-n</head><p>Lemma 4. Protocol Multiplication-mod-n s is complete, honest verifier zeroknowledge, and satisfies that from any pair of accepting conversations (between V and any prover) of form (e d , e db , e, f, z 1 , z 2 ), (e d , e db , e , f , z 1 , z 2 ) with e = e , one can efficiently compute the plaintext a, b, c corresponding to e a , e b , e c such that ab = c mod n s , provided 2 t is smaller than the smallest prime factor in n.</p><p>Proof. Completeness is clear by inspection of the protocol. For honest verifier zero-knowledge, observe that the equations checked by V are e e a e d = E(f, z 1 ) mod n s+1 and e f b (e db e e c ) -1 = E(0, z 2 ) mod n s+1 . From this it is clear that we can generate a conversation by choosing first f, z 1 , z 2 , e at random, and then computing e d , e db that will satisfy the equations. This only requires inversion modulo n s+1 , and generates the right distribution because the values f, z 1 , z 2 , e are also independent and random in the real conversation. The protocols from this section can be made non-interactive using the standard Fiat-Shamir heuristic of computing the challenge from the first message using a hash function. This can be proved secure in the random oracle model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Efficient Electronic Voting</head><p>In <ref type="bibr" target="#b3">[4]</ref>, a general model for elections was used, which we briefly recall here: we have a set of voters V 1 , ..., V M , a bulletin board B, and a set of tallying authorities A 1 , ..., A v . The bulletin board is assumed to function as follows: every player can write to B, and a message cannot be deleted once it is written. All players can access all messages written, and can identify which player each message comes from. This can all be implemented in a secure way using an already existing public key infrastructure and server replication to prevent denial of service attacks. We assume that the purpose of the vote is to elect a winner among L candidates, and that each voter is allowed to vote for t &lt; L candidates.</p><p>In the following, h will denote a fixed hash function used to make noninteractive proofs according to the Fiat-Shamir heuristic. Also, we will assume throughout that an instance of threshold version of Paillier's scheme with public key n, g has been set up, with the A i 's acting as decryption servers. We will assume that n s &gt; M, which can always be made true by choosing s or n large enough.</p><p>The notation P roof P (S), where S is some logical statement will denote a bit string created by player P as follows: P selects the appropriate protocol from the previous section that can be used to interactively prove S. He computes the first message a in this protocol, computes e = h(a, S, ID(P )) where ID(P ) is his user identity in the system and, taking the result of this as the challenge from the verifier, computes the answer z. Then P roof P (S) = (e, z). The inclusion of ID(P ) in the input to h is done in order to prevent vote duplication. To check such a proof, note that all the auxiliary protocols are such that from S, z, c one can easily compute what a should have been, had the proof been correct. For instance, for the protocol for n s powers, the statement consists of a single number u modulo n s+1 , and the verifier checks that z n s = au e mod n s+1 , so we have a = z n s u -e mod n s+1 . Once a is computed, one checks that e = h(a, S, ID(P )).</p><p>A protocol for the case L = 2 is now simple to describe. This is equivalent to a yes/no vote and so each vote can thought of as a number equal to 0 for no and 1 for yes: 1. Each voter V i decides on his vote v i , he calculates E i = E(v i , r i ), where r i is randomly chosen. He also creates P roof Vi (E i or E i /g is an n s 'th power modulo n s+1 ) based on the 1-out-of-2 n s 'th power protocol. He writes the encrypted vote and proof to B. 2. Each A j does the following: first set E = 1. Then for all i: check the proof written by V i on B and if is it valid, then E := E • E i mod n s+1 . Finally, A j executes his part of the threshold decryption protocol, using E as the input ciphertext, and writes his result to B. 3. From the messages written by the A j 's, anyone can now reconstruct the plaintext corresponding to E (possibly after discarding invalid messages).</p><p>Assuming for simplicity that all votes are valid, it is evident that</p><formula xml:id="formula_19">E = i E(v i , r i ) = E( i v i mod n s , i r i mod n s+1 ). So the decryption result is i v i mod n s which is i v i since n s &gt; M.</formula><p>Security of this protocol (in the random oracle model) follows easily from security of the sub-protocols used, and semantic security of Paillier's encryption scheme. Proofs will be included in the final version of this paper.</p><p>There are several ways to generalise this to L &gt; 2. Probably the simplest way is to hold L parallel yes/no votes as above. A voter votes 1 for the candidates he wants, and 0 for the others. This means that V i will send L votes of form (j = 1, .., L)</p><formula xml:id="formula_20">E ij =E(v ij , r ij ), P roof Vi (E ij or E ij /g is an n s 'th power modulo n s+1 )</formula><p>To prove that he voted for exactly t candidates, he also writes to B the number j r ij mod n s+1 . This allows the talliers to verify that j E(v ij , r ij ) is an encryption of t. This check is sufficient, since all individual votes are proved to be 0 or 1. It is immediate that decryption of the L results will immediately give the number of votes each candidate received.</p><p>We note that his easily generalises to cases where voters are allowed to vote for up to t candidates: one simply introduces t "dummy candidates" in addition to the actual L. We then execute the protocol as before, but with t+L candidates. Each voter places the votes he does not want to use on dummy candidates.</p><p>The size of a vote in this protocol is seen to be O(Lk), where k is the bit length of n, by simple inspection of the protocol. The protocol requires L decryption operations. As a numeric example, suppose we have k = 1000, M = 64000, L = 64, s = 1 and we use challenges of 80 bits in the proofs. Then a vote in the above system has size about 50 Kbyte.</p><p>If the parameters are such that L log 2 M &lt; k • s and t = 1, then we can do significantly better. These conditions will be satisfied in many realistic situations, such as for instance in the numeric example above.</p><p>The basic idea is the following: a vote for candidate j, where 0 ≤ j &lt; L is defined to be an encryption of the number M j . Each voter will create such an encryption and prove its correctness as detailed below. When all these encryptions are multiplied we get an encryption of a number of form a = L j=0 a j M j mod n s , where a j is the number of votes cast for candidate j. Since L log 2 M &lt; k • s, this relation also holds over the integers, so decrypting and writing a in M -ary notation will directly produce all the a j 's.</p><p>It remains to describe how to produce encryption hiding a number of form M j , for some 0 ≤ j &lt; L, and prove it was correctly formed. Let b 0 , ..., b l be the bits in the binary representation of j, i.e. j = b 0 2 0 + b 1 2 1 + ... + b l 2 l . Then clearly we have M j = (M 2 0 ) b0 • ... • (M 2 l ) b l . Each factor in this product is either 1 or a power of M. This is used in the following algorithm for producing the desired proof (where P denotes the prover):</p><p>1. P computes encryptions e 0 , ..., e l of (M 2 0 ) b0 , ..., (M 2 l ) b l . For each i = 0...l he also computes P roof P (e i /g or e i /g M 2 i is an n s 'th power). 2. Let F i = (M 2 0 ) b0 • ... • (M 2 i ) bi , for i = 0...l. P computes an encryption f i of F i , for i = 1..l. We set f 0 = e 0 . Now, for i = 1...l, P computes P roof P (Plaintexts corr. to f i-1 , e i , f i satisfy</p><formula xml:id="formula_21">F i-1 • (M 2 i ) bi = F i mod n s ),</formula><p>based on the multiplication-mod-n s protocol. The encryption f l is the desired encryption, it can be verified from the e i , f i and all the proofs computed.</p><p>It is straightforward to see that a vote in this system will have length O(k log L) bits (still assuming, of course, that L log 2 M ≤ k • s).</p><p>With parameter values as in the numeric example before, a vote will have size about 8.5 Kbyte, a factor of more than 5 better than the previous system. Moreover, we need only 1 decryption operation as opposed to L before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Efficiency and Implementation Aspects</head><p>An implementation of some of the teqniques discussed in this paper can be found at http://www.brics.dk/∼jurik/research.html. Key Generation. The primes p and q are made using the usual techniques, so that n will be as difficult as possible to factor. Since there is no difference in choosing a general g and (n + 1) as generator, we can just use (n + 1) and save some work for finding a suitable g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Encryption.</head><p>As mentioned in Paillier we can choose g = 2 (provided it satisfies the contraints) to get a speed-up in encryption. But since we can use (n + 1) as generator we can make it even more efficient since calculating (n + 1) i is the same as calculating:</p><formula xml:id="formula_22">1 + in + i 2 n 2 + ... + i s n s mod n s+1</formula><p>this means raising (n + 1) to i'th power takes about 5s multiplications. We can precompute the factors k! -1 n k mod n s+1 which reduces the number of multiplications to 2s. We can't get rid of the exponentiation r n s mod n s+1 , but the random value can be choosen in advance and the exponentiation calculated in advance. If r n s mod n s+1 is calculated in advance an encryption will take 2s multiplications which is approximately as efficient as RSA for small s.</p><p>Decryption. Decryption can be speeded up by calculating the different powers of n, and the k! -1 mod n j for 2 ≤ k ≤ j ≤ s. All this can be calculated modp j and modq j instead of modn j by using L p (x) = x -1 p and L q (x) =</p><p>x -1 q instead of the normal L. The decryption algorithm is then executed 2 times, once modp j 's instead of modn j and with L p instead of L and once with modq j and L q . Then after the 2 parts have been calculated they are combined using Chinese remaindering.</p><p>Performance Evaluations. We give here a comparison between the schemes presented in this paper, Paillier's original scheme, RSA with public exponent 2 16 + 1 and El-Gamal. There are 3 versions of our scheme, namely one without precomputation, one with, and one with s = 1 (and no precomputation), since this is equivalent to Paillier's scheme. It is assumed that all numbers has about the same number of 1's and 0's in their binary representation. In figure <ref type="figure" target="#fig_2">1</ref> we compare the different scheme using the same security parameter. It should be noted that it compares the number of multiplications, but these multiplications are made using different modulus size. It should be also be noted that the 2 first columns encrypt sk bits of plaintext instead of k bits in the other columns. The last 2 rows of the table shows the number of bits that are encrypted for each multiplication made. It only makes sense to compare the numbers in these 2 rows if the modulus size is the same and thus the security parameter k is different.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>s Input: n, g, e a , e b , e c Private Input for P : a, b, c, r a , r b , r c such that ab = c mod n and e a = E(a, r a ), e b = E(b, r b ), e c = E(c, r c ) 1. P chooses a random value d ∈ Z n s and sends to V encryptions e d = E(d, r d ), e db = E(db, r db ). 2. V chooses e, a random t-bit number, and sends it to P . 3. P opens the encryption e e a e d = E(ea + d, r e a r d mod n s+1 ) by sending f = ea + d mod n s and z 1 = r e a r d mod n s+1 . Finally, P opens the encryption e f b (e db e e c ) -1 = E(0, r f b (r db r e c ) -1 mod n s+1 ) by sending z 2 = r f b (r db r e c</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>For the last claim, note first that since encryptions uniquely determine plaintexts, there are fixed values a, b, c, d contained in e a , e b , e c , e d , and a value x contained in e db . The fact that the conversations given are accepting implies that f = ea + d mod n s , f = e a+d mod n s , f b-x-ec = 0 = f b-x-e c mod n s . Putting this together, we obtain (ff )b = (ee )c mod n s or (ee )ab = (ee )c mod n s . Now, since (ee ) is invertible modulo n s by assumption on 2 t , we can conclude that c = ab mod n s (and also compute a, b and c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Comparison with equal security parameter k Scheme General Scheme Scheme No Precomp. Precomp. s = 1 Paillier RSA El-Gamal n/p Size (k) k k k k k k Modulus Size (s + 1)k (s + 1)k 2k 2k k k Plaintext Size sk sk k k k k Multiplications for Encryption</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Basic Research in Computer Science, Centre of the Danish National Research Foundation.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>All complexities given here assume that the length of challenges for the zeroknowledge proofs is at most k. Also, strictly speaking, this complexity only holds if k &gt; log M , however, since k ≥ 1000 is needed for security anyway, this will always be satisfied in practice</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>strictly speaking, we also need that s &lt; p, q, but this is insignificant since s is a constant</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>A non interactive zero-knowledge proof for this using the Fiat-Shamir heuristic is easy to derive from the corresponding one in<ref type="bibr" target="#b9">[10]</ref> </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>In fact the random oracle will be needed only to ensure that the non-interactive proofs of correctness of shares will work. Doing these proofs interactively instead would allow us to dispense with the random oracle</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Recent BRICS Report Series Publications</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Poupard and Stern: Practical Multi-Candidate Election Scheme, manuscript</title>
		<author>
			<persName><forename type="first">Fouque</forename><surname>Baudron</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-05">May 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Damgård and Schoenmakers: Proofs of partial knowledge</title>
		<author>
			<persName><surname>Cramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Crypto 94</title>
		<meeting>of Crypto 94</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS series nr</publisher>
			<biblScope unit="volume">839</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient Multiparty Computations Secure against an Adaptive Adversary</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dziembowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hirt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EuroCrypt 99</title>
		<meeting>of EuroCrypt 99</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS series 1592</publisher>
			<biblScope unit="page" from="311" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Schoenmakers: A Secure and Optimally Efficient Multi-Authority Election Scheme</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt 97</title>
		<meeting>EuroCrypt 97</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS series</publisher>
			<biblScope unit="page" from="103" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">Mackenzie</forename><surname>Frankel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yung</forename></persName>
		</author>
		<title level="m">Robust Efficient Distributed RSA-key Generation, proceedings of STOC 98</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Sharing Decryption in the Context of Voting or Lotteries</title>
		<author>
			<persName><forename type="first">P</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Poupard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Financial Crypto</title>
		<meeting>Financial Crypto</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Practical Zero-Knowledge Protocol fitted to Security Microprocessor Minimizing both Transmission and Memory</title>
		<author>
			<persName><forename type="first">L</forename><surname>Guillou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-J</forename><surname>Quisquater</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Eu-roCrypt</title>
		<meeting>of Eu-roCrypt</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS series</publisher>
			<biblScope unit="volume">88</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient Receipt-Free Voting based on Homomorphic Encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hirt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt 2000</title>
		<meeting>EuroCrypt 2000</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS series</publisher>
			<biblScope unit="page" from="539" to="556" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Public-Key Cryptosystems based on Composite Degree Residue Classes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pallier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt 99</title>
		<meeting>EuroCrypt 99</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS series</publisher>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<title level="m">Practical Threshold Signatures, Proceedings of EuroCrypt 2000</title>
		<imprint>
			<publisher>Springer Verlag LNCS series</publisher>
			<biblScope unit="page" from="207" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Non-Cryptographic Fault-Tolerant Computing in a Constant Number of Rounds</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bar-Ilan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Principles of Distributed Computation</title>
		<meeting>the ACM Symposium on Principles of Distributed Computation</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="201" to="209" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
