<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">How the Design of JML Accommodates Both Runtime Assertion Checking and Formal Verification</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2003-03">March 2003, revised March 2004</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Gary</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
							<email>leavens@cs.iastate.edu</email>
						</author>
						<author>
							<persName><forename type="first">Yoonsik</forename><surname>Cheon</surname></persName>
							<email>cheon@cs.iastate.edu</email>
						</author>
						<author>
							<persName><forename type="first">Curtis</forename><surname>Clifton</surname></persName>
							<email>cclifton@cs.iastate.edu</email>
						</author>
						<author>
							<persName><forename type="first">Clyde</forename><surname>Ruby</surname></persName>
							<email>ruby@cs.iastate.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Iowa State University</orgName>
								<address>
									<addrLine>226 Atanasoff Hall</addrLine>
									<postCode>50011-1041</postCode>
									<settlement>Ames</settlement>
									<region>Iowa</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">R</forename><surname>Cok</surname></persName>
							<email>david.cok@kodak.com</email>
							<affiliation key="aff2">
								<orgName type="department">Eastman Kodak Company Research &amp; Development Laboratories</orgName>
								<address>
									<addrLine>1700 Dewey Avenue, Building 65</addrLine>
									<postCode>14650-1816</postCode>
									<settlement>Rochester</settlement>
									<region>New York</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Frank</forename><forename type="middle">S</forename><surname>De Boer</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Marcello</forename><forename type="middle">M</forename><surname>Bonsangue</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Susanne</forename><surname>Graf</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Willem-Paul</forename><surname>De Roever</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<addrLine>226 Atanasoff Hall Iowa State University Ames</addrLine>
									<postCode>50011-1041</postCode>
									<settlement>Iowa</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">How the Design of JML Accommodates Both Runtime Assertion Checking and Formal Verification</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2003-03">March 2003, revised March 2004</date>
						</imprint>
					</monogr>
					<idno type="MD5">448EBCC60EEC16EA2A0C35290594082C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>specification languages, runtime assertion checking, documentation, tools, formal methods, program verification, programming by contract, Java language, JML language, Eiffel language, Larch family of specification languages. 2001 CR Categories: D.2.1 [Software Engineering] Requirements/ Specifications -languages, tools, JML</term>
					<term>D.2.2 [Software Engineering] Design Tools and Techniques -modules and interfaces, object-oriented design methods</term>
					<term>D.2.4 [Software Engineering] Software/Program Verification -Assertion checkers, class invariants, correctness proofs, formal methods, programming by contract, reliability, tools, validation, JML</term>
					<term>D.3.2 [Programming Languages] Language Classifications -Object-oriented languages</term>
					<term>F.3.1 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs -Assertions, invariants, logics of programs, mechanical verification, pre-and post-conditions, specification techniques</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Specifications that are used in detailed design and in the documentation of existing code are primarily written and read by programmers. However, most formal specification languages either make heavy use of symbolic mathematical operators, which discourages use by programmers, or limit assertions to expressions of the underlying programming language, which makes it difficult to write complete specifications. Moreover, using assertions that are expressions in the underlying programming language can cause problems both in runtime assertion checking and in formal verification, because such expressions can potentially contain side effects. The Java Modeling Language, JML, avoids these problems. It uses a side-effect free subset of Java's expressions to which are added a few mathematical operators (such as the quantifiers \forall and \exists). JML also hides mathematical abstractions, such as sets and sequences, within a library of Java classes. The goal is to allow JML to serve as a common notation for both formal verification and runtime assertion checking; this gives users the benefit of several tools without the cost of changing notations.</p><p>1 Larman notes that the UML has some nonstandard ways to specify the exceptions that a method may throw, by either using Java's own syntax directly or by using a "property string". 2 Besides this runtime assertion checking work at Iowa State, which relies on adding instrumentation to compiled code, Steven Edwards's group at Virginia Tech is working on a wrapper-class based approach to runtime assertion checking that will allow instrumentation of programs for which source code is not available.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The Java Modeling Language, JML <ref type="bibr" target="#b55">[55,</ref><ref type="bibr" target="#b54">54]</ref>, is the result of a cooperative, international effort aimed at providing a common notation and semantics for the specification of Java code at the detailed-design level <ref type="bibr" target="#b58">[58]</ref>. JML is being designed cooperatively so that many different tools can use a common notation for Hoarestyle behavioral interface specifications. In this paper we explain the features of JML's design that make its assertions easily understandable by programmers and suitable for both runtime assertion checking and formal verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Background</head><p>By a Hoare-style specification we mean one that uses pre-and postconditions to specify the behavior of methods <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b44">44]</ref>. A behavioral interface specification language (BISL) is a specification language that specifies both the syntactic interface of a module and its behavior <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b48">48,</ref><ref type="bibr" target="#b52">52,</ref><ref type="bibr" target="#b85">85]</ref>. JML, the interface specification languages in the Larch family <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b48">48,</ref><ref type="bibr" target="#b52">52,</ref><ref type="bibr" target="#b85">85]</ref> and RESOLVE/C++ <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b73">73]</ref> are BISLs. Most design by contract languages and tools, such as Eiffel <ref type="bibr" target="#b70">[70,</ref><ref type="bibr" target="#b71">71]</ref> and APP <ref type="bibr" target="#b77">[77]</ref>, are also BISLs, because they place specifications inside programming language code. By contrast, neither Z <ref type="bibr" target="#b80">[80,</ref><ref type="bibr" target="#b79">79,</ref><ref type="bibr" target="#b87">87]</ref> nor VDM <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b74">74,</ref><ref type="bibr" target="#b43">43]</ref> is a BISL; they have no way to specify interface details for a particular programming language. OCL <ref type="bibr" target="#b82">[82,</ref><ref type="bibr" target="#b83">83]</ref> is a BISL for the UML, but the UML itself is languageindependent; this poses problems for a Java programmer, because the UML does not have standard notations for all details of Java method signatures. For example, the UML's syntax for specifying the signatures of operations has no standard notation for declaring that a Java method is strictfp or for declaring the exceptions that a method may throw <ref type="bibr">[7, pp. 128-129]</ref>  <ref type="bibr">[49, p. 516</ref>]. 1 Also the OCL has no standard constraints that correspond to JML's exceptional postconditions. Because BISLs like JML specify both interface and behavior, they are good at specifying detailed designs that include such Java details. This makes JML well suited to the task of documenting reusable components, libraries, and frameworks written in Java.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Tool Support</head><p>Because BISLs are easily integrated with code, they lend themselves to tool support for activities related to detailed design, coding, testing, and maintenance. An important goal of JML is to enable a wide spectrum of such tools. Besides tools that enforce JML's semantics (e.g., type checking), the most important JML tools help with the following tasks.</p><p>Runtime checking and testing. The Iowa State group provides (from www.</p><p>jmlspecs.org):</p><p>the jmlc runtime assertion checking compiler <ref type="bibr" target="#b12">[13]</ref>, which generates class files from JML-annotated Java sources, 2 and the jmlunit tool <ref type="bibr" target="#b13">[14]</ref>, which uses the runtime assertion checker to generate test oracle code for JUnit tests. Documentation. David Cok provides the jmldoc tool, also available through www.jmlspecs.org, which generates HTML documentation similar to that produced by javadoc <ref type="bibr" target="#b29">[29]</ref>, but containing specifications as well. The generated documentation is useful for browsing specifications or posting to the web. Static analysis and verification. The following tools are prepared by our partners at Compaq and the University of Nijmegen:</p><p>-The ESC/Java tool <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b65">65,</ref><ref type="bibr" target="#b66">66]</ref> statically checks Java code for likely errors. ESC/Java understands a subset of JML annotations. -The LOOP tool <ref type="bibr" target="#b37">[37,</ref><ref type="bibr" target="#b38">38,</ref><ref type="bibr" target="#b40">40,</ref><ref type="bibr" target="#b42">42]</ref> assists in the formal verification of the correctness of implementations from JML specifications, using the theorem prover PVS.</p><p>In addition, the Daikon dynamic invariant detector <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b72">72]</ref> outputs invariants for Java programs in a subset of JML, and the Korat automated testing tool <ref type="bibr" target="#b7">[8]</ref> uses the jmlunit tool to exercise the test data it derives.</p><p>In this paper, we discuss how JML meets the needs of tools for runtime assertion checking, documentation, static analysis, and verification. We focus on runtime assertion checking and formal verification, which we consider to be the extremes of the spectrum of tools that a BISL might support. The tasks of runtime assertion checking and formal verification have widely differing needs:</p><p>-Runtime assertion checking places a high premium on executability. Many specification languages intended for runtime assertion checking, such as Eiffel <ref type="bibr" target="#b70">[70,</ref><ref type="bibr" target="#b71">71]</ref> and APP <ref type="bibr" target="#b77">[77]</ref>, only allow assertions that are completely executable. This is sensible for a language that is intended only to support runtime assertion checking and not formal verification. -On the other hand, formal theorem proving and reasoning place a high premium on the use of standard mathematical notations. Thus, most specification languages intended for formal reasoning or verification, such as VDM, the members of the Larch family, and especially Z, feature a variety of symbolic mathematical notations. Many expressive mathematical notations, such as quantifiers, are impossible, in general, to execute at runtime. Again, including such notations is sensible for a language intended only to support formal theorem proving and reasoning and not runtime assertion checking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Problems</head><p>We begin by describing the problems that arise when addressing the needs of the range of tools exemplified by runtime assertion checking and formal verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.1">Notational Problem</head><p>It is often said that syntax does not matter; however, our experience with Larch/Smalltalk <ref type="bibr" target="#b10">[11]</ref> and Larch/C++ <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b50">50,</ref><ref type="bibr" target="#b51">51,</ref><ref type="bibr" target="#b53">53,</ref><ref type="bibr" target="#b56">56]</ref> showed that programmers object to learning a specialized mathematical notation (the Larch Shared Language). This is similar to the problems found by Finney <ref type="bibr" target="#b26">[26]</ref>, who did a preliminary experiment demonstrating that the symbolic notation in Z specifications may make them hard to read. Conversely, in executable languages like Eiffel and APP, programmers feel comfortable with the use of the programming language's expressions in assertions. Such an assertion language is therefore more appealing for purposes of documentation than highly symbolic mathematical notations.</p><p>To summarize, the first problem that we address in this paper is how to provide a good syntax for specification expressions. Specification expressions are the syntactic forms that are used to denote values in assertions. By a good syntax we mean one that is close enough to programming language expressions that programmers feel comfortable with it and yet has all of the features necessary to support both runtime assertion checking and formal verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.2">Undefinedness Problem</head><p>Expressions in a programming language may abruptly terminate (e.g., throw exceptions) and may go into infinite loops; consequently, they may have undefined values from a strictly mathematical point of view. Programming languages typically provide features to deal explicitly with such undefinedness. For example, Java provides short-circuit versions of boolean operators (such as &amp;&amp; and ||) that allow programmers to suppress evaluation of some subexpressions.</p><p>We want both programmers and mathematicians to use JML's notations; hence, JML's specification expressions should not only look like Java's expressions and use Java's semantics, but should also validate the standard laws of logic. However, because of a potential for undefinedness, Java expressions do not satisfy all the standard rules of logic; for example, in Java the conjunction E 1 &amp;&amp; E 2 is not equal to E 2 &amp;&amp; E 1 , although in logic they would be equal. To resolve this conflict, we are willing to accept a slightly different semantics for assertion evaluation as long as programmers are not too surprised by it.</p><p>Thus, the second problem we address in this paper is how to find a semantics for expressions used in assertions that validates standard laws of logic and yet does not surprise programmers and is still useful for runtime assertion checking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.3">Side Effects Problem</head><p>Another important semantic issue is that expressions in a programming language like Java (and most others, including Eiffel) can contain side effects. Side effects have a very practical problem related to runtime assertion checking. It is generally assumed that assertions may be evaluated or skipped with no change in the outcome of a computation, but an assertion with side effects has the potential to alter the computation's outcome. For example, an assertion with side effects might mask the presence of a bug that would otherwise be revealed or cause bugs that are not otherwise present. Because one of the principal uses of runtime assertion checking is debugging and isolating bugs, it is unacceptable for side effects from assertion checking to alter the outcome of a computation.</p><p>Thus, the third problem that we address in this paper is how to prevent side effects in assertions while still retaining as much of the syntax of normal programming language expressions as possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.4">Mathematical Library Problem</head><p>Most specification languages come with a library of mathematical concepts such as sets and sequences. Such concepts are especially helpful in specifying collection types. For example, to specify a Stack type, one would use a mathematical sequence to describe, abstractly, the states that a stack object may take <ref type="bibr" target="#b35">[35]</ref>. VDM, OCL, Z, and the interface specification languages of the Larch family all have libraries of such mathematical concepts. They also are standard in theorem provers such as PVS.</p><p>However, as discussed in Section 1.3.1, we want to limit the barriers that Java programmers must overcome to use JML. Thus, the fourth problem that we address in this paper is how to provide a library of mathematical concepts in a way that does not overwhelm programmers, and yet is useful for formal verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Other Goals of JML</head><p>In addition to providing solutions to the preceding four problems, the design of JML is guided and constrained by several other goals. One of the most important of these goals is to allow users to write specifications that document detailed designs of existing code. This motivates the choice of making JML a BISL, as described above. Moreover, we would like JML to be useful for documenting code regardless of whether it was designed according to any particular design method or discipline. This is important because the cost of specification is high enough that it is not always justified until one knows that the design and the code have stabilized enough to make the documentation potentially useful to other people.</p><p>In general, JML's design adheres to the goal of being able to document existing designs; however, there is one significant aspect of JML's design that departs from this goal-JML imposes the specifications of supertypes on subtypes, a property termed specification inheritance, in order to achieve behavioral subtyping <ref type="bibr" target="#b19">[19]</ref>.</p><p>JML's use of specification inheritance is justified by another of our goals: we want JML to support modular reasoning, that is, reasoning about the behavior of a compilation unit using just the specifications of the compilation units that it references (as opposed to the details of their implementations). Modular reasoning is important because without it, the difficulty of understanding an object-oriented program increases much more rapidly than the size of the program, and thus the benefits of the abstraction mechanisms in object-oriented languages are lost. Consequently, modular reasoning is also important for formal verification, because then the scope of the verification problem is limited.</p><p>Specification inheritance, and the resulting behavioral subtyping, allows modular reasoning to be sound, by allowing one to reason based on the static types of references. Subsumption in Java allows a reference to a subtype object to be substituted for a supertype reference. The requirements of behavioral subtyping <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b57">57,</ref><ref type="bibr" target="#b59">59,</ref><ref type="bibr" target="#b63">63,</ref><ref type="bibr" target="#b69">69]</ref> guarantee that all such substituted objects will obey the specifications inherited from the static type of the reference <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b60">60,</ref><ref type="bibr" target="#b61">61]</ref>.</p><p>Because of the benefits of modular reasoning to programmers and verifiers, we favor specification inheritance over the conflicting goal of being able to document existing designs that do not follow behavioral subtyping. In any case, it is possible to work around the requirements of behavioral subtyping for cases in which a subtype does not obey the inherited specifications of its supertype(s). One simply underspecifies each supertype enough to allow all of the subtypes that are desired <ref type="bibr" target="#b63">[63,</ref><ref type="bibr" target="#b69">69]</ref>. Note that this work-around does not involve changing the code or the design, but only the specification, so it does not interfere with the goal of documenting existing code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Outline</head><p>The remainder of this paper is organized as follows. The next section discusses our solution to the notational problem described above. Having described the notation in general terms, Section 3 provides more background on JML. The subsequent three sections treat the remaining problems discussed above. The paper ends with a discussion of related work and some conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Solving the Notational Problem</head><p>To solve the notational problem described in Section 1.3.1, JML generally follows Eiffel, basing the syntax of specification expressions on Java's expression syntax. However, because side effects are not desired in specification expressions, JML's specification expressions do not include Java expressions that can cause obvious side effects, i.e., assignment expressions and Java's increment and decrement operators (++ and --).</p><p>Furthermore, to make JML suitable for formal verification efforts, JML includes a number of operators that are not present in Java [55, <ref type="bibr">Section 3]</ref>. The syntax of these operators comes in two flavors: those that are symbolic and those that are textual.</p><p>We did not want to introduce excess notation that would cause difficulties for programmers when reading specifications, so JML adds just five symbolic operators. Four of these are logical operators: forward and reverse implication, written ==&gt; and &lt;==, respectively, and logical equivalence and inequivalence, written &lt;==&gt; and &lt;=!=&gt;, respectively. The inclusion of symbols for logical operators is inspired by the calculational approach to formal methods <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b31">31]</ref>. The other symbolic operator is &lt;:, which is used to compare types to see if they are in a subtype relationship <ref type="bibr" target="#b65">[65]</ref>.</p><p>All the other operators added to Java and available in JML's specification expressions use a textual notation consisting of a backslash (\) followed by an English word or phrase. For example, the logical quantifiers in JML are written as \forall and \exists <ref type="bibr" target="#b55">[55]</ref>.</p><p>Besides these quantifiers, JML also has several other operators using this backslash syntax. One of the most important is \old(), which is used in method postconditions to indicate an expression whose value is taken from the pre-state of a method call. For example, \old(i-1) denotes the value of i-1 evaluated in the pre-state of a method call. This notation is borrowed from the old operator in Eiffel. Other JML expressions using the backslash syntax include \fresh(o), which says that o was not allocated in the pre-state of a method call, but is allocated (and not null) in the post-state, and \result, which denotes the normal result returned by a method.</p><p>The backslashes in the syntax of these operators serve a very important purpose-they prevent the rest of the operator's name from being interpreted as a Java identifier. This allows JML to avoid reserving Java identifiers in specification expressions. For example, result can be used as a program variable and is distinguished from \result. This trick is useful in allowing JML to specify arbitrary Java programs. Indeed, because a goal of JML is to document existing code, it cannot add new reserved words to Java.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Background on JML</head><p>In this section we provide additional background on JML that will be useful in understanding our solutions to the remaining problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Semantics Of Specification Expressions</head><p>Just as JML adopts much of Java's expression syntax, it attempts to keep JML's semantics similar to Java's. In particular, the semantics of specification expressions is a reference semantics. That is, when the name of a variable or field is used in an expression, it denotes either a primitive value (such as an integer) or a reference to an object. References themselves are values in the semantics, which allows one to directly express aliasing or the lack of it. For example, the expression arg != fieldVal says that arg and fieldVal are not aliased. Java also allows one to compare the states of objects using the equals method. For example, in the postcondition of a clone method, one might write the following to say that the result returned by clone is a newly allocated object that has the same state as the receiver (this): \fresh(\result) &amp;&amp; this.equals(\result); Note that the exact meaning of the equals method for a given type is left to the designer of that type, as in Java. Thus, if one only knows that o is an Object, it is hard to conclude much about x from o.equals(x).</p><p>Because JML uses this reference semantics, specifiers must show the same care as Java programmers when choosing between the == and equals equality tests. And like Eiffel, but unlike Larch-style interface specification languages, JML does not need "state functions" to be applied to extract the value of an expression from a reference. Values are implicitly extracted as needed by methods and operators. Besides being easier for programmers, this lends some succinctness to the notation.</p><p>Currently, JML adopts all of the Java semantics for integer arithmetic. Thus types such as int use two's complement arithmetic and are finite. Although Java programmers are, in theory, aware of the nature of integer arithmetic, it seems that JML's adoption of Java's semantics causes some misunderstandings; for example, some published JML specifications are inconsistent because of this semantics <ref type="bibr" target="#b9">[10]</ref>. Chalin has suggested adding new primitive value types for infinite precision arithmetic to JML; in particular, he suggests a type \bigint for infinite precision integers <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. He is currently implementing and experimenting with this idea.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Method and Type Specifications</head><p>To explain JML's semantics for method specifications, we use the example in Figure <ref type="figure">1</ref>. JML uses special comments, called annotations, to hold the specification of behavior; these are added to the interface information contained in the Java code. A specifier writes these annotation comments by inserting an at-sign (@) following the usual characters that signify the start of a comment. In multi-line annotation comments, at-signs at the beginnings of lines are ignored.</p><p>Figure <ref type="figure">1</ref> starts with a "model import" directive, which says that JML will consider all types in the named package, org.jmlspecs.models, to be imported for purposes of the specification. This allows the JML tools to find the type JMLObjectSequence (see the third line) in that package.</p><p>The type JMLObjectSequence is used as the type of the model instance field, named absVal. In this declaration, the model keyword says that the field is not part of the Java code, but is used solely for purposes of specification. The instance keyword says that the field is imagined, for purposes of specification, to be a non-static field in every class that implements this interface. <ref type="foot" target="#foot_0">3</ref>Following the declaration of the two model instance fields is an invariant. It says that the field absVal is never null.</p><p>Following the invariant are the declarations and specifications of three methods. In JML, a method's specifications are typically written, as they are in Figure <ref type="figure">1</ref>, before the header of the method they specify. This makes the scope of the formal parameters of a method a bit strange, because it extends backward into the method's specification. However, it works best with Java tools, which expect comments related to a method, such as javadoc comments, to precede the method's header.</p><p>Consider the specification of the first method, push. This shows the general form of a "normal behavior" specification case. A specification case includes a precondition, indicated by the keyword requires, and some other specification clauses. A specification case is satisfied if, whenever the precondition is satisfied, the other clauses are also satisfied. Additionally, in a normal behavior specification case, the method must not throw an exception when the precondition is satisfied. The specification case given for push includes, besides the requires clause, a frame axiom, introduced by the keyword assignable, and a normal postcondition, following the keyword ensures.</p><p>//@ model import org.jmlspecs.models.*; public interface Stack { //@ public model instance JMLObjectSequence absVal;</p><p>//@ public instance invariant absVal != null; /*@ public normal_behavior @ requires true; @ assignable absVal; @ ensures absVal.equals(\old(absVal.insertFront(x))); @*/ void push(Object x); /*@ public normal_behavior @ requires !absVal.isEmpty(); @ assignable absVal; @ ensures absVal.equals(\old(absVal.trailer())) @ &amp;&amp; \result == \old(absVal.first()); @ also @ public exceptional_behavior @ requires absVal.isEmpty(); @ assignable \nothing; @ signals (Exception e) @ e instanceof IllegalStateException; @*/ Object pop(); //@ ensures \result &lt;==&gt; absVal.isEmpty(); /*@ pure @*/ boolean isEmpty(); } Fig. <ref type="figure">1</ref>. The specification and code for the interface Stack.</p><p>As with specification languages in the Larch family, a precondition that is just true can be omitted. In the Larch family, an omitted frame axiom means "assignable \nothing;", which is a very strong specification that says that the method has no side effects. Following a suggestion of Erik Poll, we decided that such a specification was too strong for a default. So in JML, an omitted frame axiom allows assignment to all locations. This agrees with most of the defaults for omitted clauses in JML, which impose no restrictions.</p><p>JML also allows specifiers to write "exceptional behavior" specification cases, which say that, when the precondition is satisfied, the method must not return normally but must instead throw an exception. An example appears in the specification of the pop method. This specification has two specification cases connected with also. The meaning of the also is that the method must satisfy both of these specification cases <ref type="bibr" target="#b84">[84,</ref><ref type="bibr" target="#b86">86]</ref>. Thus, when the value of the model instance field absVal is not empty, a call to pop must return normally and must satisfy the given ensures clause. But when the value of the model instance field absVal is empty, a call to pop must throw an IllegalStateException. This kind of case analysis can be desugared into a single specification case, which can be given a semantics in the usual way <ref type="bibr" target="#b38">[38,</ref><ref type="bibr" target="#b41">41,</ref><ref type="bibr" target="#b53">53,</ref><ref type="bibr" target="#b76">76]</ref>.</p><p>The specification cases given for push and pop are heavyweight specification cases [55, <ref type="bibr">Section 1]</ref>. Such specification cases are useful when one wants to give a relatively complete specification, especially for purposes of formal verification. For runtime assertion checking or documentation, one may want to specify only part of the behavior of a method. This can be done using JML's lightweight specification cases, which are indicated by the absence of a behavior keyword (like normal behavior). Figure <ref type="figure">1</ref> gives an example of a lightweight specification case in the specification of the method isEmpty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Dealing with Undefinedness</head><p>As discussed in Section 1.3.2, a fundamental problem in using the underlying language for specification expressions is dealing with expressions whose value is undefined. In Java, undefinedness in expressions is typically signaled by the expression throwing an exception. For example, when one divides an integer by 0, the expression throws an ArithmeticException. Exceptions may also be thrown by methods called from within specification expressions.</p><p>Specification languages have adopted several different approaches to dealing with undefinedness in expressions <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b32">32]</ref>. We wanted a semantics that would not be surprising to either Java programmers or to those doing formal verification. Typically, a Java programmer would try to write the specification in a way that "protects" the meaning of the expression against any source of undefinedness <ref type="bibr" target="#b62">[62]</ref>. This can be accomplished by using the short-circuit boolean operators; for example, a specifier might write denom &gt; 0 &amp;&amp; num/denom &gt; 1 to be sure that the division would be defined whenever it was carried out.</p><p>However, we would like specifications to be meaningful even if they are not protective. Hence, the semantics of JML does not rely on the programmer writing protective specifications but, instead, ensures that every expression has some value. To do this, we adopted the "underspecified total functions" approach favored in the calculational style of formal methods <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b32">32]</ref>. That is, an expression that would not have a value in Java is given an arbitrary, but unspecified, value. For example, num/0 has some integer value, although this approach does not say what the value is, only that it must be uniformly substituted in any surrounding expression. In JML all expressions have an implicit argument of the program's state; thus, the uniform substitution of values need only be carried out within a given assertion.</p><p>An advantage of this substitution approach is that it validates the rules for standard logic. For example, in JML,</p><formula xml:id="formula_0">E 1 &amp;&amp; E 2 is equivalent to E 2 &amp;&amp; E 1 .</formula><p>Consider what happens if E 1 throws an exception; in that case, one may chose some unspecified boolean value for E 1 , say b. This means that E 1 &amp;&amp; E 2 equals b &amp;&amp; E 2 , which is equal to E 2 &amp;&amp; b, as can be seen by a simple case analysis on E 2 's value. The case where E 2 throws an exception is similar. Furthermore, if programmers write protective specifications, they will never be surprised by the details of this semantics.</p><p>The JML assertion checking compiler takes advantage of the semantics of undefinedness to attempt, as much as possible, to detect possible assertion violations <ref type="bibr" target="#b12">[13]</ref>. That is, assertion checking attempts to use a value that will make the overall assertion false, whenever the undefinedness of some subexpression allows it to do so. In this way, the assertion checker can both follow the rules of standard logic and detect places where specifications are not sufficiently protective. This is a good example of how JML caters to the needs of both runtime assertion checking and formal verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Preventing Side Effects in Assertions</head><p>As discussed in Section 1.3.3, it is important to prevent side effects in assertions, for both practical and theoretical reasons. JML is designed to prevent such side effects statically. It does this using an effect-checking type system <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b81">81]</ref>. This type system is designed to be as simple as possible. Although it allows specification expressions to call Java methods and constructors, it only allows such calls if the called method or constructor is declared with the modifier pure. The semantics of JML must thus assure that pure methods and constructors are side-effect free.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">JML's Purity Restrictions</head><p>JML's semantic restrictions on pure methods and constructors are as follows:</p><p>-A pure method implicitly has a specification that includes the following specification case [55, Section 2.3.1]:</p><p>assignable \nothing;</p><p>This ensures that a correct implementation of the method has no side effects. -"A pure constructor implicitly has a specification that only allows it to assign to the instance fields of the class in which it appears" (including inherited instance fields) <ref type="bibr" target="#b55">[55,</ref><ref type="bibr">Section 2.3.1]</ref>. This ensures that, if the constructor is correctly implemented, then a new expression that calls it has no side effects. -Pure methods and pure constructors may only invoke other methods and constructors that are pure. This makes the type system modular, as it allows the purity of a method or a constructor to be checked based only on its code and the specifications of the other methods and constructors that it calls. -All methods and constructors that override a pure method or constructor must also be pure. This inheritance of purity is a consequence of specification inheritance and is necessary to make the type system modular in the presence of subtyping.</p><p>The first restriction implies that a pure method may not perform any input or output, nor may it assign to any non-local variables. Similarly, by the second restriction, a pure constructor may not do any I/O and may not assign to non-local storage other than the instance fields of the object the constructor is initializing. Note that, in JML, saying that a method may not assign to non-local storage means precisely that-even benevolent side effects are prohibited <ref type="bibr" target="#b55">[55,</ref><ref type="bibr">Section 2.1.3.1]</ref>. This seems necessary for sound modular reasoning <ref type="bibr" target="#b64">[64]</ref>. It is also a useful restriction for reasoning about supertypes from their specifications <ref type="bibr" target="#b78">[78]</ref> and for reasoning about concurrent programs.</p><p>The last two restrictions are also motivated by modularity considerations. Inheritance of purity has as a consequence that a method cannot be pure if any overriding method has side effects. In particular, a method in Object can be specified as pure only if every override of that method, in any Java class, obeys JML's purity restrictions.</p><p>The type system of JML is an important advance over languages like Eiffel, which trust programmers to avoid side effects in assertions rather than statically checking this property. However, as we will see in the following subsection, JML's purity restrictions give rise to some practical problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Practical Problems with JML's Purity Restrictions</head><p>An initial practical problem is how to decide which methods in Java's libraries should be specified as pure. One way to start to answer this question is to use a static analysis to conservatively estimate which methods in Java's libraries have side effects. A conservative analysis could count a method as having side effects if it assigns to non-local storage or calls native methods (which may do I/O), either directly or indirectly. All other methods can safely be specified as pure, provided they are not overridden by methods that the analysis says have side effects. Researchers from Purdue have provided a list of such methods to us, using their tools from the Open Virtual Machine project. <ref type="foot" target="#foot_1">4</ref> We hope to integrate this technology into the JML tools eventually.</p><p>Declaring a method to be pure entails a very strong specification, namely that the method and all possible overriding methods have no side effects. Thus, finding that a method, and all known methods that override it, obey JML's purity restrictions is not the same as deciding that the method should be specified as pure. Such a decision affects not just all existing overrides of the method, but all future implementations and overrides. How is one to make such a decision?</p><p>This problem is particularly vexing because there are many methods that seem intuitively to be side-effect free, but that do not obey JML's purity restrictions. Methods with benevolent side effects are common examples. A benevolent side effect is a change in the internal state of an object in a way that is not externally visible. Two examples from the protocol of Object will illustrate the importance of this problem.</p><p>First, consider computing a hash code for an instance of a class. Because this may be computationally costly, an implementation may desire to compute the hash code the first time it is asked for and then cache the result in a private field of the object. When the hash code is requested on subsequent occasions, the cached result is returned without further computation. For example, this is done in the hashCode method of Java's String class. However, in JML, storing the computed hash code into the cache is considered to be a side effect. So String's hashCode method cannot be specified as pure.</p><p>Second, consider computing object equality. In some implementations, an object's fields might be lazily initialized or computed only on first access. If the equals method happens to be the first such method to be called on such an object, it will trigger the delayed computation. We found such an example in our work on the MultiJava compiler <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>; in this compiler, the class CClassType has such delayed computations, and its override of Object's equals method can trigger a previously delayed computation with side effects. It seems very difficult to rewrite this method to be side-effect free, because to do so one would probably need to change the compiler's architecture. (Similar kinds of lazy initialization of fields occur in implementations of the Singleton pattern, although these usually do not affect the equals method.)</p><p>We have shown two cases where methods in the protocol of Object are overridden by methods that cannot be pure. By purity and specification inheritance, these examples imply that neither hashCode nor equals can be specified as pure in Object. Object is typically used in Java as the type of the elements in a collection. Hence, in the specification of a collection type, such as a hash table, one cannot use the hashCode or equals methods on elements. Without changes, this would make JML unsuitable for specifying collection types.</p><p>(This problem is mostly a problem for collection types, because one can specify many subclasses of Object with pure hashCode and equals methods. Specifications operating on instances of such subclasses can use these methods without violating JML's type system.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Solving the Problems</head><p>The desire to use intuitively side-effect free methods in specifications, even if they are not pure according to JML's semantics, is strong enough that we considered changing the semantics of the assignable clause in order to allow benevolent side effects. However, we do not know how to do that and still retain sound modular reasoning <ref type="bibr" target="#b64">[64]</ref>. In any case, the use of such methods in runtime assertion checking would still be problematic because of the side effects they might cause. In addition, we would like to prevent problems when a programmer wrongly believes that side effects are benevolent; it is not clear whether an automatic static analysis could prevent such problems, and even if so, whether such a tool could be modular.</p><p>Thus far, the only viable solution we have identified is to refactor specifications by adding pure model (i.e., specification-only) methods that are to be used in specifications in place of program methods that cannot be pure. That is, whenever one has an intuitively side-effect free program method, m, that is not pure according to JML's semantics, one should create a pure model method m ′ , which returns the same result as m but without its side effects. Then one replaces calls to m by calls to m ′ in assertions.</p><p>We are currently experimenting with this solution. The most important part of this experiment is to replace uses of Object's equals method, which cannot be pure, with calls to a new pure model method in Object, called isEqualTo. The specifications of these methods are shown in Figure <ref type="figure">2</ref>. The assignable clause in the specification of the equals method permits benevolent side effects; it is also specified to return the same result as would a call to isEqualTo. Thus, whenever someone overrides equals, they should also override the isEqualTo method. When an override of equals is specified as pure, then an override of isEqualTo in the same class can be specified in terms of this pure equals method, and the implementation of the model isEqualTo method can simply call equals as well. However, an implementation of equals can never call isEqualTo, because program code cannot call model methods (since model methods can only be used in specifications). Therefore, to avoid code duplication when equals is not declared to be pure but the two methods share some common implementation code, one can introduce a (non-model) pure, private method that both equals and isEqualTo can call.</p><p>We have also applied this refactoring to all the collection classes in java.util (and in other packages) that we had previously specified, in order to check that the solution is viable. So far the results seem satisfactory. However, as of May 2003, this restructuring is not part of the JML release, because the JML tools are not yet able to handle some of the details of this approach. In particular, the runtime assertion checker is not yet able to compile the model methods added to Object without having all of Object's source code available. (And we cannot legally ship Sun's source code for Object in the JML release.) However, we working on solutions to this problem that will allow us to obtain more experience with this approach and to do more case studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Future Work on Synchronized Methods and Purity</head><p>JML currently permits synchronized methods to be declared pure if they meet all the criteria described in Section 5.1. Given that obtaining a lock is a side effect that can affect control flow in a program, does allowing synchronized methods to be pure violate the intent of JML's purity restrictions? On the surface it would seem so, because when a synchronized method gains a lock, it may change the outcome of other concurrent threads. Furthermore, execution of such a method might block, conceivably even causing a deadlock between concurrent threads that would not occur if one was not doing assertion checking. However, since we have largely ignored concurrency thus far in JML's design, we leave resolution of this issue for future work.</p><p>/*@ public normal_behavior @ assignable objectState; @ ensures \result &lt;==&gt; this.isEqualTo(obj); @*/ public boolean equals(Object obj); /*@ public normal_behavior @ requires obj != null; @ assignable \nothing; @ ensures (* \result is true when obj is equal to this object *); @ also @ public normal_behavior @ requires obj != null &amp;&amp; \typeof(this) == \type(Object); @ assignable \nothing; @ ensures \result &lt;==&gt; this == obj; @ also @ public normal_behavior @ requires obj == null; @ assignable \nothing; @ ensures \result &lt;==&gt; false; public pure model boolean isEqualTo(Object obj) { return this == obj; } @*/ Fig. <ref type="figure">2</ref>. The refactored specification for Object's equals method and the pure model method isEqualTo. The text between (* and *) in the specification case of isEqualTo's specification is an "informal description", which formally is equivalent to writing true <ref type="bibr" target="#b53">[53]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Mathematical Libraries</head><p>As described in Section 1.3.4, we need to provide a library of mathematical concepts with JML in a way that does not overwhelm programmers, and yet is useful for formal verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Hiding the Mathematics</head><p>It is sometimes convenient to use mathematical concepts such as sets and sequences in specification, particularly for collection classes <ref type="bibr" target="#b36">[36,</ref><ref type="bibr" target="#b68">68,</ref><ref type="bibr" target="#b85">85]</ref>. For example, the specification of Stack in Figure <ref type="figure">1</ref> uses the type JMLObjectSequence, which is part of JML's org.jmlspecs.models package. This package contains types that are intended for such mathematical modeling. Besides sequences, these include sets, bags, relations, and maps, and a few other convenience types.</p><p>Most types in org.jmlspecs.models have only pure methods and constructors. <ref type="foot" target="#foot_2">5</ref> For example, JMLObjectSequence's insertFront method returns a sequence object that is like the receiver, but with its argument placed at the front; the receiver is not changed in any way. JMLObjectSequence's trailer method similarly returns a sequence containing all but the first element of the receiver, without changing the receiver. Because such methods are pure, they can be used during runtime assertion checking without changing the underlying computation.</p><p>JML gains two advantages from having these mathematical modeling types in a Java package, as opposed to having them be purely mathematical concepts. First, these types all have Java implementations and thus can be used during runtime assertion checking. Second, using these types in assertions avoids the introduction of special mathematical notation; instead, normal Java expressions (method calls) are used to do things like concatenating sequences or intersecting sets. This is an advantage for our main audience, which consists of programmers and not mathematicians.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Use by Theorem Provers</head><p>The second part of the mathematical libraries problem described in Section 1.3.4 is that the library of mathematical modeling types should be useful for formal verification. The types in the org.jmlspecs.models package are intended to correspond (loosely) to the libraries of mathematical concepts found in theorem provers, such as PVS. As we gain experience, we can add additional methods to these types to improve their correspondence to these mathematical concepts. It is also possible to add new packages of such types tailored to specific theorem provers or to other notations, such as OCL.</p><p>When translating specification expressions into theorem prover input, the Loop tool currently treats all methods in the same way -it does not make a special case for pure methods in the org.jmlspecs.models package. This makes the resulting proof obligations more complex than is desirable. Since the types in the models package are known, it seems that one should be able, as a special case, to replace the general semantics of such a method call with a call to some specific function from the theorem prover's library of mathematical concepts.</p><p>To facilitate this, it may be that these model types should all be declared to be final, which is currently not the case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>We have already discussed how JML differs from conventional formal specification languages, such as Z <ref type="bibr" target="#b80">[80,</ref><ref type="bibr" target="#b79">79,</ref><ref type="bibr" target="#b87">87]</ref>, VDM <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b74">74,</ref><ref type="bibr" target="#b43">43]</ref>, the Larch family <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b48">48,</ref><ref type="bibr" target="#b52">52,</ref><ref type="bibr" target="#b85">85]</ref> and RESOLVE <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b73">73]</ref>. To summarize, the main difference is that JML's specification expressions are based on a subset of the Java programming language, a design that is more congenial to Java programmers.</p><p>The Alloy Annotation Language (AAL) offers a syntax similar to JML for annotating Java programs <ref type="bibr" target="#b46">[46]</ref>. AAL supports extensive compile-time checking based on static analysis techniques. Unlike similar static analysis tools such as ESC/Java <ref type="bibr" target="#b17">[18]</ref>, AAL also supports method calls and relational expressions in assertions. However, AAL's assertion language is based on a simple first-order logic with relational operators <ref type="bibr" target="#b39">[39]</ref> and not on a subset of Java expressions. We believe that a Java-based syntax is more likely to gain acceptance among Java programmers. However, JML could adopt some of AAL's features for specifying sets of objects using regular expressions. These would be helpful in using JML's frame axioms, where they would allow JML to more precisely describe locations that can be assigned to in the method. (Another option that would have similar benefits would be to use the approach taken in DemeterJ <ref type="bibr" target="#b67">[67]</ref>.)</p><p>We have also discussed how JML differs from design by contract languages, such as Eiffel <ref type="bibr" target="#b70">[70,</ref><ref type="bibr" target="#b71">71]</ref>, and tools, such as APP <ref type="bibr" target="#b77">[77]</ref>. Summarizing, JML provides better support for complete specifications and formal verification by extending the set of specification expressions with more expressive mathematical constructs, such as quantifiers, -ensuring that specification expressions do not contain side effects, and providing a library of types corresponding to mathematical concepts. JML's specification-only (model) declarations and frame axioms also contribute to its ability to specify types more completely than is easily done with design by contract tools.</p><p>We know of several other design by contract tools for Java <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b45">45,</ref><ref type="bibr" target="#b47">47,</ref><ref type="bibr" target="#b75">75]</ref>. The approaches vary from a simple assertion mechanism similar to the assert macros of C and C++ to full-fledged contract enforcement capabilities. Jass <ref type="bibr" target="#b4">[5]</ref>, iContract <ref type="bibr" target="#b47">[47]</ref>, and JContract <ref type="bibr" target="#b75">[75]</ref> focus on the practical use of design by contract in Java. Handshake and jContractor focus on implementation techniques such as library-based on-the-fly instrumentation of contracts <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b45">45]</ref>. Contract Java focuses on properly blaming contract violations <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b25">25]</ref>. These notations and tools suffer from the same problems as Eiffel. That is, none of them guarantee the lack of side effects in assertions, handle undefinedness in a way that would facilitate formal verification and reasoning, support more expressive mathematical notations such as quantifiers, or provide a set of immutable types designed for use in specifications. In sum, they all focus on runtime checking, and thus it is difficult to write complete specifications for formal verification and reasoning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>JML synthesizes the best from the worlds of design by contract and more mathematical specification languages. Because of its expressive mathematical notations, its specification-only (model) declarations, and library of mathematical modeling types, one can more easily write complete specifications in JML than in a design by contract language, such as Eiffel. These more complete specifications, along with JML's purity checking, allow JML to be useful for formal verification. Thus, JML's synthesis of features allows it to serve many roles in the Java formal methods community.</p><p>Our experience so far is that this approach has had a modest impact. Release 3.7 of JML has been downloaded almost 400 times. JML has been used in at least 5 universities for teaching some aspects of formal methods. It is used somewhat extensively in the Java Smart Card industry and has been used in at least one company outside of that industry (Fulcrum).</p><p>In the future, we would like to extend the range of tools that JML supports to include tools for model checking and specification of concurrent Java programs <ref type="bibr" target="#b0">[1]</ref>. We invite others to join us in this effort to furnish Java programmers with a single notation that can be used by many tools.</p></div>			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>Omitting instance makes fields static and final, which is Java's default for fields declared in interfaces.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>See http://www.ovmj.org/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>The org.jmlspecs.models package does have some types that have non-pure methods. These are various kinds of iterators and enumerators. The methods of these iterators and enumerators that have side effects cannot be used in specification expressions.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The work of Leavens, Cheon, Clifton, and Ruby was supported in part by the US National Science Foundation, under grants CCR-0097907 and CCR-0113181.</p><p>Thanks to Robyn Lutz, Sharon Ryan, and Janet Leavens for comments on earlier drafts of this paper. Thanks to all who have contributed to the design and implementation of JML including Al Baker, Erik Poll, Bart Jacobs, Joe Kiniry, Rustan Leino, Raymie Stata, Michael Ernst, Gary Daugherty, Arnd Poetzsch-Heffter, Peter Müller, and others acknowledged in <ref type="bibr" target="#b55">[55]</ref>.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A toolsupported proof system for multithreaded java</title>
		<author>
			<persName><forename type="first">E</forename><surname>Abraham-Mumm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">S</forename><surname>De Boer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>De Roever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steffen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMCO 2002: Formal Methods for Component Objects, Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Marcello</forename><surname>Frank De Boer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Susanne</forename><surname>Bonsangue</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Willem-Paul</forename><surname>Graf</surname></persName>
		</editor>
		<editor>
			<persName><surname>De Roever</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Inheritance and subtyping in a parallel object-oriented language</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>America</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP &apos;87, European Conference on Object-Oriented Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Jean</forename><surname>Bezivin</surname></persName>
		</editor>
		<meeting><address><addrLine>Paris, France; New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1987-06">June 1987</date>
			<biblScope unit="volume">276</biblScope>
			<biblScope unit="page" from="234" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Designing an object-oriented programming language with behavioural subtyping</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>America</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>De Roever</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<meeting><address><addrLine>The Netherlands; New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1990-06">May/June 1990. 1991</date>
			<biblScope unit="volume">489</biblScope>
			<biblScope unit="page" from="60" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A logic covering undefinedness in program proofs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="251" to="269" />
			<date type="published" when="1984-10">October 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Published in Electronic Notes in Theoretical Computer</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bartetzko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wehrheim</surname></persName>
		</author>
		<ptr target="www.elsevier.nl" />
	</analytic>
	<monogr>
		<title level="m">Workshop on Runtime Verification held in conjunction with the 13th Conference on Computer Aided Verification, CAV&apos;01</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Science</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Havelund</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rosu</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">55</biblScope>
		</imprint>
	</monogr>
	<note>Jass -Java with assertions</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Proof in VDM: A Practitioner&apos;s Guide</title>
		<author>
			<persName><forename type="first">Juan</forename><surname>Bicarregui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">S</forename><surname>Fitgerald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">A</forename><surname>Lindsay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Ritchie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Unified Modeling Language User Guide</title>
		<author>
			<persName><forename type="first">Grady</forename><surname>Booch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Rumbaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivar</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Object Technology Series</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison Wesley Longman</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Korat: Automated testing based on Java predicates</title>
		<author>
			<persName><forename type="first">Chandrasekhar</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarfraz</forename><surname>Khurshid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Darko</forename><surname>Marinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings International Symposium on Software Testing and Analysis (ISSTA)</title>
		<meeting>International Symposium on Software Testing and Analysis (ISSTA)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002-07">July 2002</date>
			<biblScope unit="page" from="123" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Back to basics: Language support and semantics of basic infinite integer types in JML and Larch</title>
		<author>
			<persName><forename type="first">Patrice</forename><surname>Chalin</surname></persName>
		</author>
		<idno>CU-CS 2002-003.1</idno>
		<imprint>
			<date type="published" when="2002-10">October 2002</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, Concordia University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Improving JML: For a safer and more effective language</title>
		<author>
			<persName><forename type="first">Patrice</forename><surname>Chalin</surname></persName>
		</author>
		<idno>2003-001.1</idno>
		<imprint>
			<date type="published" when="2003-03">March 2003</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, Concordia University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The Larch/Smalltalk interface specification language</title>
		<author>
			<persName><forename type="first">Yoonsik</forename><surname>Cheon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="253" />
			<date type="published" when="1994-07">July 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A quick overview of Larch/C++</title>
		<author>
			<persName><forename type="first">Yoonsik</forename><surname>Cheon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object-Oriented Programming</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="39" to="49" />
			<date type="published" when="1994-10">October 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A runtime assertion checker for the Java Modeling Language (JML)</title>
		<author>
			<persName><forename type="first">Yoonsik</forename><surname>Cheon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering Research and Practice (SERP &apos;02)</title>
		<editor>
			<persName><forename type="first">Hamid</forename><forename type="middle">R</forename><surname>Arabnia</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Youngsong</forename><surname>Mun</surname></persName>
		</editor>
		<meeting>the International Conference on Software Engineering Research and Practice (SERP &apos;02)<address><addrLine>Las Vegas, Nevada, USA</addrLine></address></meeting>
		<imprint>
			<publisher>CSREA Press</publisher>
			<date type="published" when="2002-06-27">June 24-27, 2002. June 2002</date>
			<biblScope unit="page" from="322" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A simple and practical approach to unit testing: The JML and JUnit way</title>
		<author>
			<persName><forename type="first">Yoonsik</forename><surname>Cheon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP 2002 -Object-Oriented Programming, 16th European Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Boris</forename><surname>Magnusson</surname></persName>
		</editor>
		<meeting><address><addrLine>Máalaga, Spain, Proceedings; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="volume">2374</biblScope>
			<biblScope unit="page" from="231" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">MultiJava: Design, implementation, and evaluation of a Javacompatible language supporting modular open classes and symmetric multiple dispatch</title>
		<author>
			<persName><forename type="first">Curtis</forename><surname>Clifton</surname></persName>
		</author>
		<idno>01-10</idno>
		<ptr target="www.multijava.org" />
		<imprint>
			<date type="published" when="2001-11">November 2001</date>
			<biblScope unit="page">50011</biblScope>
			<pubPlace>Ames, Iowa</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Iowa State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">MultiJava: Modular open classes and symmetric multiple dispatch for Java</title>
		<author>
			<persName><forename type="first">Curtis</forename><surname>Clifton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Millstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA 2000 Conference on Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000-10">October 2000</date>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="130" to="145" />
		</imprint>
	</monogr>
	<note>ACM SIGPLAN Notices</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Programming in the 1990s: An Introduction to the Calculation of Programs</title>
		<author>
			<persName><forename type="first">Edward</forename><surname>Cohen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Extended static checking</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">L</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SRC Research Report</title>
		<imprint>
			<biblScope unit="volume">159</biblScope>
			<biblScope unit="page">130</biblScope>
		</imprint>
		<respStmt>
			<orgName>Compaq Systems Research Center</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Lytton</forename><surname>Ave</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-12">Dec 1998</date>
			<pubPlace>Palo Alto</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Forcing behavioral subtyping through specification inheritance</title>
		<author>
			<persName><forename type="first">Krishna</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Kishore</forename><surname>Dhara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
		<idno>TR #95-20c</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Software Engineering</title>
		<meeting>the 18th International Conference on Software Engineering<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996-03">March 1996</date>
			<biblScope unit="page" from="258" to="267" />
		</imprint>
		<respStmt>
			<orgName>Iowa State University, Dept. of Computer Science</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Predicate Calculus and program semantics</title>
		<author>
			<persName><forename type="first">W</forename><surname>Edsger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carel</forename><forename type="middle">S</forename><surname>Dijkstra</surname></persName>
		</author>
		<author>
			<persName><surname>Scholten</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Adding contracts to Java with Handshake</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Duncan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Urs</forename><surname>Holzle</surname></persName>
		</author>
		<idno>TRCS98-32</idno>
		<imprint>
			<date type="published" when="1998-12">December 1998</date>
			<pubPlace>Santa Barbara, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Part II: Specifying components in RESOLVE</title>
		<author>
			<persName><forename type="first">H</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wayne</forename><forename type="middle">D</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timothy</forename><forename type="middle">J</forename><surname>Heym</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Murali</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><forename type="middle">W</forename><surname>Sitaraman</surname></persName>
		</author>
		<author>
			<persName><surname>Weide</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGSOFT Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="29" to="39" />
			<date type="published" when="1994-10">Oct 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Dynamically discovering likely program invariants to support program evolution</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jake</forename><surname>Cockrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">G</forename><surname>Griswold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Notkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="25" />
			<date type="published" when="2001-02">February 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Contract soundness for objectoriented languages</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Findler</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA &apos;01 Conference Proceedings, Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting><address><addrLine>Tampa Bay, Florida, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-10-18">October 14-18, 2001. October 2001</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Behavioral contracts and behavioral subtyping</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Bruce Findler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Latendresse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Joint 8th European Software Engineering Conference (ESEC) and 9th ACM SIGSOFT International Symposium on the Foundations of Software Engineering (FSE)</title>
		<meeting>Joint 8th European Software Engineering Conference (ESEC) and 9th ACM SIGSOFT International Symposium on the Foundations of Software Engineering (FSE)<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-09-14">September 10-14, 2001. September 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Mathematical notation in formal specification: Too difficult for the masses?</title>
		<author>
			<persName><forename type="first">Kate</forename><surname>Finney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="158" to="159" />
			<date type="published" when="1996-02">February 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">John</forename><surname>Fitzgerald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Gorm Larsen</surname></persName>
		</author>
		<title level="m">Modelling Systems: Practical Tools in Software Development</title>
		<meeting><address><addrLine>Cambridge, Cambridge, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Extended static checking for Java</title>
		<author>
			<persName><forename type="first">K</forename><surname>Cormac Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Lillibridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">B</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raymie</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><surname>Stata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI&apos;02)</title>
		<meeting>the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI&apos;02)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">June 17-19 2002</date>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="234" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The design of distributed hyperlinked programming documentation</title>
		<author>
			<persName><forename type="first">Lisa</forename><surname>Friendly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Hypermedia Design (IWHD&apos;95)</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Fraïssè</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Garzotto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Isakowitz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Nanard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Nanard</surname></persName>
		</editor>
		<meeting>the International Workshop on Hypermedia Design (IWHD&apos;95)<address><addrLine>France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995-06-02">1-2 June 1995. 1995</date>
			<biblScope unit="page" from="151" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Integrating functional and imperative programming</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">K</forename><surname>Gifford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">M</forename><surname>Lucassen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on LISP and Functional Programming</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986-08">August 1986</date>
			<biblScope unit="page" from="28" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">A Logical Approach to Discrete Math. Texts and Monographs in Computer Science</title>
		<author>
			<persName><forename type="first">David</forename><surname>Gries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Avoiding the undefined by underspecification</title>
		<author>
			<persName><forename type="first">David</forename><surname>Gries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Science Today: Recent Trends and Developments</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="366" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Larch: Languages and Tools for Formal Specification</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">V</forename><surname>Guttag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">J</forename><surname>Horning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Modet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">An axiomatic basis for computer programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="576" to="583" />
			<date type="published" when="1969-10">October 1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Notes on data structuring</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Structured Programming</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Dijkstra Ole</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">-J</forename><surname>Dahl</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</editor>
		<meeting><address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press, Inc</publisher>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="83" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Proof of correctness of data representations</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="271" to="281" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Reasoning about Java Programs in higher order logic with PVS and Isabelle</title>
		<author>
			<persName><forename type="first">Marieke</forename><surname>Huisman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-02">February 2001</date>
		</imprint>
		<respStmt>
			<orgName>University of Nijmegen, Holland</orgName>
		</respStmt>
	</monogr>
	<note>Ipa dissertation series, 2001-03</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Java program verification via a Hoare logic with abrupt termination</title>
		<author>
			<persName><forename type="first">Marieke</forename><surname>Huisman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<idno>CSI-R9912</idno>
	</analytic>
	<monogr>
		<title level="m">Fundamental Approaches to Software Engineering (FASE 2000), volume 1783 of LNCS</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Maibaum</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="284" to="303" />
		</imprint>
	</monogr>
	<note>An earlier version is technical report</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Alloy: A lightweight object modeling notation</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="256" to="290" />
			<date type="published" when="2002-04">April 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Java program verification challenges</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Kiniry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Warnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMCO 2002: Formal Methods for Component Objects, Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Frank</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marcello</forename><forename type="middle">M</forename><surname>De Boer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Susanne</forename><surname>Bonsangue</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Willem-Paul</forename><surname>Graf</surname></persName>
		</editor>
		<editor>
			<persName><surname>De Roever</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2852</biblScope>
			<biblScope unit="page" from="202" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A logic for the Java modeling language JML</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Poll</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fundamental Approaches to Software Engineering (FASE&apos;2001)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">2029</biblScope>
			<biblScope unit="page" from="284" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Reasoning about Java classes (preliminary report)</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Van Den</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marieke</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martijn</forename><surname>Huisman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulrich</forename><surname>Van Berkum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hendrik</forename><surname>Hensel</surname></persName>
		</author>
		<author>
			<persName><surname>Tews</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA &apos;98 Conference Proceedings</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998-10">October 1998</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="329" to="340" />
		</imprint>
	</monogr>
	<note>ACM SIGPLAN Notices</note>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName><forename type="first">Cliff</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
		<title level="m">Systematic Software Development Using VDM. International Series in Computer Science</title>
		<meeting><address><addrLine>Englewood Cliffs, N.J.</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Upgrading the pre-and postcondition technique</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B M</forename><surname>Jonkers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VDM &apos;91 Formal Software Development Methods 4th International Symposium of VDM Europe Noordwijkerhout</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Prehn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Toetenel</surname></persName>
		</editor>
		<meeting><address><addrLine>The Netherlands; New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991-10">October 1991</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="428" to="456" />
		</imprint>
	</monogr>
	<note>Conference Contributions</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">jContractor: A reflective Java library to support design by contract</title>
		<author>
			<persName><forename type="first">Urs</forename><surname>Murat Karaorman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Holzle</surname></persName>
		</author>
		<author>
			<persName><surname>Bruno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Meta-Level Architectures and Reflection, Second International Conference on Reflection &apos;99</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Pierre</forename><surname>Cointe</surname></persName>
		</editor>
		<meeting><address><addrLine>Saint-Malo, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999-07-21">July 19-21, 1999. July 1999</date>
			<biblScope unit="volume">1616</biblScope>
			<biblScope unit="page" from="175" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">An analyzable annotation language</title>
		<author>
			<persName><forename type="first">Sarfraz</forename><surname>Khurshid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Darko</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of OOPSLA &apos;02 Conference on Object-Oriented Programming, Languages, Systems, and Applications</title>
		<meeting>OOPSLA &apos;02 Conference on Object-Oriented Programming, Languages, Systems, and Applications<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002-11">November 2002</date>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="231" to="245" />
		</imprint>
	</monogr>
	<note>SIGPLAN Notices</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Technology of Object-Oriented Languages and Systems</title>
		<author>
			<persName><forename type="first">Reto</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOOLS</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="295" to="307" />
			<date type="published" when="1998">1998</date>
			<pubPlace>Los Alamitos, California</pubPlace>
		</imprint>
	</monogr>
	<note>iContract -the Java design by contract tool</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A simple approach to specifying concurrent systems</title>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communications of the ACM</title>
		<imprint>
			<date type="published" when="1989-01">January 1989</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="32" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and the Unified Process</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Larman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Prentice Hall PTR</publisher>
			<pubPlace>Upper Saddle River, NJ</pubPlace>
		</imprint>
	</monogr>
	<note>second edition edition</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">An overview of Larch/C++: Behavioral specifications for C++ modules</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><surname>Leavens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Specification of Behavioral Semantics in Object-Oriented Information Modeling</title>
		<editor>
			<persName><forename type="first">Haim</forename><surname>Kilov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">William</forename><surname>Harvey</surname></persName>
		</editor>
		<meeting><address><addrLine>Boston; Ames, Iowa</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page">50011</biblScope>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Iowa State University</orgName>
		</respStmt>
	</monogr>
	<note>An extended version is TR #96-01d</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Larch/C++ Reference Manual. Version 5.41</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><surname>Leavens</surname></persName>
		</author>
		<ptr target="http://www.cs.iastate.edu/~leavens/larchc++.html" />
	</analytic>
	<monogr>
		<title level="m">or on the World Wide</title>
		<imprint>
			<date type="published" when="1999-04">April 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Larch frequently asked questions. Version 1.110</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><surname>Leavens</surname></persName>
		</author>
		<ptr target="http://www.cs.iastate.edu/~leavens/larch-faq.html" />
		<imprint>
			<date type="published" when="2000-05">May 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Enhancing the pre-and postcondition technique for more expressive specifications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><forename type="middle">L</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FM&apos;99 -Formal Methods: World Congress on Formal Methods in the Development of Computing Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Jeannette</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jim</forename><surname>Woodcock</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jim</forename><surname>Davies</surname></persName>
		</editor>
		<meeting><address><addrLine>Toulouse, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999-09">September 1999. 1999</date>
			<biblScope unit="volume">1709</biblScope>
			<biblScope unit="page" from="1087" to="1106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">JML: A notation for detailed design</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><forename type="middle">L</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clyde</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><surname>Ruby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Behavioral Specifications of Businesses and Systems</title>
		<editor>
			<persName><forename type="first">Haim</forename><surname>Kilov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Bernhard</forename><surname>Rumpe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ian</forename><surname>Simmonds</surname></persName>
		</editor>
		<meeting><address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="175" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Preliminary design of JML: A behavioral interface specification language for Java</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><forename type="middle">L</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clyde</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><surname>Ruby</surname></persName>
		</author>
		<idno>98-06v</idno>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
		<respStmt>
			<orgName>Iowa State University, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>See www.jmlspecs. org</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Preliminary design of Larch/C++</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoonsik</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><surname>Cheon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workshop on Larch</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Martin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Wing</surname></persName>
		</editor>
		<meeting>the First International Workshop on Larch<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992-07">July, 1992. 1993</date>
			<biblScope unit="page" from="159" to="184" />
		</imprint>
	</monogr>
	<note>Workshops in Computing</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Concepts of behavioral subtyping and a sketch of their extension to component-based systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krishna</forename><forename type="middle">Kishore</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><surname>Dhara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Component-Based Systems, chapter 6</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Murali</forename><surname>Leavens</surname></persName>
		</editor>
		<editor>
			<persName><surname>Sitaraman</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="113" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">JML: notations and tools supporting detailed design in Java</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erik</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clyde</forename><surname>Poll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Ruby</surname></persName>
		</author>
		<author>
			<persName><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA 2000 Companion</title>
		<meeting><address><addrLine>Minneapolis, Minnesota</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000-10">October 2000</date>
			<biblScope unit="page" from="105" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">A complete algebraic characterization of behavioral subtyping</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Don</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><surname>Pigozzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="617" to="663" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Reasoning about object-oriented programs that use subtypes (extended abstract)</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">E</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><surname>Weihl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA ECOOP &apos;90 Proceedings</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Meyrowitz</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1990-10">October 1990</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="212" to="223" />
		</imprint>
	</monogr>
	<note>ACM SIGPLAN Notices</note>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Specification and verification of objectoriented programs using supertype abstraction</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">E</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><surname>Weihl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="705" to="778" />
			<date type="published" when="1995-11">November 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Protective interface specifications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeannette</forename><forename type="middle">M</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="59" to="75" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">Verifying object-oriented programs that use subtypes</title>
		<author>
			<persName><forename type="first">Gary</forename><surname>Todd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leavens</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1989-02">February 1989</date>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology, Laboratory for Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report 439</note>
	<note>The author&apos;s Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">A myth in the modular specification of programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<idno>KRML 63</idno>
		<imprint>
			<date type="published" when="1995-11">November 1995</date>
			<biblScope unit="volume">130</biblScope>
			<pubPlace>Lytton Avenue Palo Alto, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Digital Equipment Corporation, Systems Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Obtain from the author. at leino@microsoft.com</note>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">ESC/Java user&apos;s manual</title>
		<author>
			<persName><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-10">October 2000</date>
		</imprint>
		<respStmt>
			<orgName>Compaq Systems Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical note</note>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Checking Java programs via guarded commands</title>
		<author>
			<persName><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raymie</forename><surname>Stata</surname></persName>
		</author>
		<idno>1999-002</idno>
	</analytic>
	<monogr>
		<title level="s">Compaq Systems Research Center</title>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
			<pubPlace>Palo Alto, CA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Note</note>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Aspect-oriented programming with adaptive methods</title>
		<author>
			<persName><forename type="first">Karl</forename><surname>Lieberherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Doug</forename><surname>Orleans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johan</forename><surname>Ovlinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="39" to="41" />
			<date type="published" when="2001-10">October 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">Abstraction and Specification in Program Development</title>
		<author>
			<persName><forename type="first">Barbara</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Guttag</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">A behavioral notion of subtyping</title>
		<author>
			<persName><forename type="first">Barbara</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeannette</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1811" to="1841" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Eiffel: The Language. Object-Oriented Series</title>
		<author>
			<persName><forename type="first">Bertrand</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Prentice Hall</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
		<title level="m" type="main">Object-oriented Software Construction</title>
		<author>
			<persName><forename type="first">Bertrand</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Prentice Hall</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Static verification of dynamically detected program invariants: Integrating Daikon and ESC/Java</title>
		<author>
			<persName><forename type="first">Jeremy</forename><forename type="middle">W</forename><surname>Nimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of RV&apos;01, First Workshop on Runtime Verification</title>
		<meeting>RV&apos;01, First Workshop on Runtime Verification</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001-07">July 2001</date>
		</imprint>
	</monogr>
	<note>To appear in Electronic Notes in Theoretical Computer Science</note>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Part I: The RESOLVE framework and discipline -a research synopsis</title>
		<author>
			<persName><forename type="first">F</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Murali</forename><surname>Ogden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><forename type="middle">W</forename><surname>Sitaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stuart</forename><forename type="middle">H</forename><surname>Weide</surname></persName>
		</author>
		<author>
			<persName><surname>Zweben</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGSOFT Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="23" to="28" />
			<date type="published" when="1994-10">October 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<title level="m" type="main">Information technology -programming languages, their environments and system software interfaces -Vienna Development Method -specification language -part 1: Base language</title>
		<idno>ISO/IEC 13817-1</idno>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>December</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<monogr>
		<title level="m" type="main">Using design by contract TM to automate Java TM software and component testing</title>
		<ptr target="http://www.parasoft.com/jsp/products/tech_papers.jsp?product=Jcontract" />
		<imprint>
			<date type="published" when="2003-02">Feb. 2003</date>
			<publisher>Parasoft Corporation</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<monogr>
		<title level="m" type="main">Desugaring JML method specifications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Arun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><forename type="middle">T</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><surname>Leavens</surname></persName>
		</author>
		<idno>00-03</idno>
		<imprint>
			<date type="published" when="2001-08">August 2001</date>
		</imprint>
		<respStmt>
			<orgName>Iowa State University, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Towards a method of programming with assertions</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Software Engineering</title>
		<meeting>the 14th International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="1992-05">May 1992</date>
			<biblScope unit="page" from="92" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Safely creating correct subclasses without seeing superclass code</title>
		<author>
			<persName><forename type="first">Clyde</forename><surname>Ruby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA 2000 Conference on Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting><address><addrLine>Minneapolis, Minnesota</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-10">October 2000</date>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="208" to="228" />
		</imprint>
	</monogr>
	<note>ACM SIGPLAN Notices</note>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">An introduction to Z and formal specifications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Spivey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Engineering Journal</title>
		<imprint>
			<date type="published" when="1989-01">January 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Michael</forename><surname>Spivey</surname></persName>
		</author>
		<title level="m">The Z Notation: A Reference Manual. International Series in Computer Science</title>
		<meeting><address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">The type and effect discipline</title>
		<author>
			<persName><forename type="first">Jean-Pierre</forename><surname>Talpin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Jouvelot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">111</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="245" to="296" />
			<date type="published" when="1994-06">June 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<monogr>
		<title level="m" type="main">The Object Constraint Language: Precise Modeling with UML</title>
		<author>
			<persName><forename type="first">Jos</forename><surname>Warmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anneke</forename><surname>Kleppe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison Wesley Longman</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">OCL: The constraint language of the UML</title>
		<author>
			<persName><forename type="first">Jos</forename><surname>Warmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anneke</forename><surname>Kleppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object-Oriented Programming</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="10" to="13" />
			<date type="published" when="1999-03">March 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Capsules and types in Fresco: Program validation in Smalltalk</title>
		<author>
			<persName><forename type="first">Alan</forename><surname>Wills</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP &apos;91: European Conference on Object Oriented Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>America</surname></persName>
		</editor>
		<meeting><address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">512</biblScope>
			<biblScope unit="page" from="59" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Writing Larch interface language specifications</title>
		<author>
			<persName><forename type="first">Jeannette</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="1987-01">January 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<monogr>
		<title level="m" type="main">A two-tiered approach to specifying programs</title>
		<author>
			<persName><forename type="first">Jeannette Marie</forename><surname>Wing</surname></persName>
		</author>
		<idno>TR-299</idno>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology, Laboratory for Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Using Z: Specification, Refinement, and Proof</title>
		<author>
			<persName><forename type="first">Jim</forename><surname>Woodcock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jim</forename><surname>Davies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Prentice Hall International Series in Computer Science</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
