<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Variational Reasoning for Question Answering with Knowledge Graph</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yuyu</forename><surname>Zhang</surname></persName>
							<email>yuyu.zhang@cc.gatech.edu</email>
						</author>
						<author>
							<persName><forename type="first">Hanjun</forename><surname>Dai</surname></persName>
							<email>hanjun.dai@cc.gatech.edu</email>
						</author>
						<author>
							<persName><forename type="first">Zornitsa</forename><surname>Kozareva</surname></persName>
							<email>kozareva@amazon.com</email>
						</author>
						<author>
							<persName><forename type="first">Alexander</forename><forename type="middle">J</forename><surname>Smola</surname></persName>
							<email>smola@amazon.com</email>
						</author>
						<author>
							<persName><forename type="first">Le</forename><surname>Song</surname></persName>
							<email>lsong@cc.gatech.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Variational Reasoning for Question Answering with Knowledge Graph</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Knowledge graph (KG) is known to be helpful for the task of question answering (QA), since it provides well-structured relational information between entities, and allows one to further infer indirect facts. However, it is challenging to build QA systems which can learn to reason over knowledge graphs based on question-answer pairs alone. First, when people ask questions, their expressions are noisy (for example, typos in texts, or variations in pronunciations), which is non-trivial for the QA system to match those mentioned entities to the knowledge graph. Second, many questions require multi-hop logic reasoning over the knowledge graph to retrieve the answers. To address these challenges, we propose a novel and unified deep learning architecture, and an end-to-end variational learning algorithm which can handle noise in questions, and learn multi-hop reasoning simultaneously. Our method achieves state-of-the-art performance on a recent benchmark dataset in the literature. We also derive a series of new benchmark datasets, including questions for multi-hop reasoning, questions paraphrased by neural translation model, and questions in human voice. Our method yields very promising results on all these challenging datasets.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Question answering (QA) has been a long-standing research problem in Machine Learning and Artificial Intelligence. Thanks to the creation of large-scale knowledge graphs such as DBPedia <ref type="bibr" target="#b1">(Auer et al. 2007</ref>) and Freebase <ref type="bibr" target="#b3">(Bollacker et al. 2008)</ref>, QA systems can be armed with well-structured knowledge on specific and open domains. Many traditional approaches for KG-powered QA are based on semantic parsers <ref type="bibr" target="#b5">(Clarke et al. 2010;</ref><ref type="bibr" target="#b13">Liang, Jordan, and Klein 2011;</ref><ref type="bibr" target="#b2">Berant et al. 2013;</ref><ref type="bibr" target="#b19">Yih et al. 2015)</ref>, which first map a question to formal meaning representation (e.g. logical form) and then translate it to a KG query. The answer to the question can be retrieved by executing the query. One of the disadvantages of these approaches is that the model is not trained end-to-end and errors may be cascaded.</p><p>With the recent success of deep learning, some end-to-end solutions based on neural networks have been proposed and show very promising performance on benchmark datasets, such as Memory Networks <ref type="bibr" target="#b18">(Weston, Chopra, and Bordes 2014)</ref>, <ref type="bibr">Key-Value Memory Networks (Miller, Fisch, and et. al. 2016)</ref> and Gated Graph Sequence Neural Networks <ref type="bibr" target="#b12">(Li et al. 2015)</ref>. However, these neural approaches treat the KG as a flattened big table of itemized knowledge records, making it hard to exploit the structure information in the graph and thus weak on logic reasoning. When the answer is not a direct neighbor of the topic entity in question (i.e. there are multiple hops between question and answer entities in the KG), which requires logic reasoning over the KG, the neural approaches usually perform poorly. For instance, it is easy to handle single-hop questions like "Who wrote the paper titled ...?" by querying itemized knowledge records in triples (paper_title, authored_by, author_name). However, logic reasoning on the KG is required for multi-hop questions such as "Who have co-authored papers with ...?". With the KG, we start from the mentioned author, and follow author authored − −−−−− → paper authored_by − −−−−−−− → author to find answers. A common remedy is the so-called knowledge graph completion: create new relations for non-neighbor entity pairs in the KG <ref type="bibr" target="#b16">(Socher et al. 2013a;</ref><ref type="bibr" target="#b8">Dong et al. 2014;</ref><ref type="bibr">Guu, Miller, and Liang 2015)</ref>. However, multi-hop reasoning is combinatorial in nature, i.e. the number of multi-hop relations grow explosively with the increase of hops. For example, if we create new relation types like friend-of-friend and friend-of-friend-of-friend, the number of edges in the KG will explode, which is intractable for both storage and computation.</p><p>Another key challenge is how to locate topic entities in the KG. Most existing works assume that the topic entity in question can be located by simple string matching <ref type="bibr" target="#b14">(Miller, Fisch, and et. al. 2016;</ref><ref type="bibr" target="#b7">Dodge et al. 2015;</ref><ref type="bibr" target="#b12">Li et al. 2015;</ref><ref type="bibr" target="#b2">Berant et al. 2013)</ref>, which is often not true. When people ask questions, either in text or speech, various noise can be introduced in the expressions. For example, people are likely to make typos or name ambiguity in question. In even harder case, audio questions, people may pronounce the same entity differently in different questions, even for the same person. Due to these noises, it is hard to do exact matching to locate topic entities. For text questions, broad matching techniques (e.g. hand-craft rules, regular expressions, edit distance, etc.) are.g.e widely used for entity recognition <ref type="bibr" target="#b16">(Rao, McNamee, and Dredze 2013)</ref>. However, they require domain experts and lots of human effort. For speech questions, it is even harder to match topic entities directly. Most existing QA systems first do speech recognition, converting the audio to text, and then match entities in text. Unfortunately, the error rate is typically high for speech recognition system to recognize entities in voice, such as human names or street addresses. Since it is not end-to-end, the error of the speech recognition system may cascade to affect the downstream QA system.</p><p>Typically, the training data for QA system is provided as question-answer pairs, where fine-grained annotation of these pairs are not available, or only available for a few. More specifically, there are very few explicit annotations of the exact entity present in the question, the type of the questions, and the exact logic reasoning steps along the knowledge graph leading to the answer. Thus it is challenging to simultaneously learn to locate the topic KG entity in the question, and figure out the unknown reasoning steps pointing to the answer based on training question-answer pairs alone.</p><p>To address the challenges mentioned above, we propose an end-to-end learning framework for question answering with knowledge graph named variational reasoning network (VRN), which have the following new features:</p><p>• We build a probabilistic modeling framework for end-toend QA system, which can simultaneously handle uncertain topic entity and multi-hop reasoning. • We propose a novel propagation-like deep learning architecture over the knowledge graph to perform logic inference in the probabilistic model. • We apply the REINFORCE algorithm with variance reduction technique to make the system end-to-end trainable. • We derive a series of new challenging benchmark datasets METAQA<ref type="foot" target="#foot_1">1</ref> (MoviE Text Audio QA) intended for research on question-answering systems. These datasets contain over 400K questions for both single-and multi-hop reasoning. To test QA systems in more realistic (and more difficult) scenarios, METAQA also provides neural-translationmodel-paraphrased datasets, and text-to-speech-based audio datasets.</p><p>Extensive experiments show that our method achieves state-of-the-art performance on both single-and multi-hop datasets, demonstrating the capability of multi-hop reasoning. Moreover, we obtain promising results on the challenging audio QA datasets, showing the effectiveness of end-to-end learning framework. With the rise of virtual assistant tools (e.g. Alexa, Cortana, Google Assistant and Siri), QA systems are now even closer to our daily life. This paper is one step towards more realistic QA systems, which can handle noisy question input in both text and speech, and learn from examples to reason over the knowledge graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>QA with semantic parser: Most traditional approaches for KG-powered QA are based on semantic parsers, which map the question to a certain meaning representation or logical form <ref type="bibr" target="#b5">(Clarke et al. 2010;</ref><ref type="bibr" target="#b13">Liang, Jordan, and Klein 2011;</ref><ref type="bibr" target="#b12">Kwiatkowski et al. 2013;</ref><ref type="bibr" target="#b2">Berant et al. 2013;</ref><ref type="bibr" target="#b19">Yih et al. 2015;</ref><ref type="bibr" target="#b14">Marx et al. 2014;</ref><ref type="bibr" target="#b9">Höffner et al. 2016)</ref>, or directly map the question to an executable program <ref type="bibr">(Liang et al. 2016)</ref>. These approaches require domain-specific grammars, rules, or finegrained annotations. Also, they are not designed to handle noisy questions, and do not support end-to-end training since they use separate stages for question parsing and logic reasoning.</p><p>Neural approaches for QA: The family of memory networks achieves state-of-the-art performance in various kinds of QA tasks. Some of them are able to do reasoning within local context (Kumar, <ref type="bibr" target="#b11">Irsoy, and et. al. 2015;</ref><ref type="bibr">Sukhbaatar et al. 2015)</ref> using attention mechanism <ref type="bibr" target="#b19">(Yang et al. 2015)</ref>. For QA with <ref type="bibr">KG, Miller, Fisch, and et. al.</ref> achieves state-of-the-art performance, outperforming previous works <ref type="bibr" target="#b4">(Bordes, Chopra, and Weston 2014;</ref><ref type="bibr" target="#b18">Weston, Chopra, and Bordes 2014</ref>) on benchmark datasets. Recent work <ref type="bibr">(Neelakantan et al. 2016</ref>) uses neural programmer model for QA with single knowledge table. However, the multi-hop reasoning capability of these approaches depends on recurrent attentions and there is no explicit traversal over the KG. Graph embedding: Recently, researchers have built deep architectures to embed structured data, such as trees <ref type="bibr" target="#b16">(Socher et al. 2013b;</ref><ref type="bibr" target="#b10">Irsoy and Cardie 2014;</ref><ref type="bibr" target="#b14">Mou et al. 2016)</ref> or graphs <ref type="bibr" target="#b8">(Duvenaud et al. 2015;</ref><ref type="bibr" target="#b6">Dai, Dai, and Song 2016;</ref><ref type="bibr" target="#b0">Atwood and Towsley 2016)</ref>. Also some works <ref type="bibr" target="#b12">(Li et al. 2015;</ref><ref type="bibr" target="#b11">Johnson 2017</ref>) extend it to sequential case like multi-step reasoning. However, these approaches only work on small instances like sentences or molecules. Instead, our work embeds the reasoning-graph from source entity to every target entity in large-scale knowledge graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Multi-hop reasoning:</head><p>There are some other works on knowledge graph completion with traversal, which requires path sampling <ref type="bibr">(Guu, Miller, and Liang 2015;</ref><ref type="bibr" target="#b15">Neelakantan, Roth, and McCallum 2015)</ref> or dynamic programming <ref type="bibr" target="#b17">(Toutanova et al. 2016)</ref>. Our work can handle QA with natural language or human speech, and the reasoning-graph embeddings can represent complicated reasoning rules.</p><p>In summary, most of the existing approaches have separate stages for entity locating, such as keyword matching, frequency-based method, and domain-specific methods <ref type="bibr" target="#b18">(Yang and Chang 2016)</ref>. Since they are not jointly trained with the reasoning part, the errors in entity locating (e.g. incorrectly recognized name entity from speech recognition system) will be cascaded to the downstream QA system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Model</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Problem definition</head><p>Knowledge base/graph (KG): A knowledge graph is a directed graph where the entities and their relations are represented by nodes and edges, respectively, i.e.</p><formula xml:id="formula_0">G = (V (G), E(G)). Furthermore, each edge from E(G) is a triplet (a 1 i , r i , a 2 i )</formula><p>, representing a directed relation r i between subject entity a 1 i and object entity a 2 i both from the node set V (G). Each entity in the knowledge graph can also contain additional information such as type and text description. For instance, entity a 1 i is described as actor Jennifer Lawrence, and entity a 2 i is movie Passengers. Then a relation in the knowledge graph can be (Jennifer Lawrence, acted_in, Passengers), where the corresponding r i is acted_in. Question answering with KG: Given a question q, the algorithm is asked to output an entity in the knowledge graph which properly answers the question. For example, q can be a question like "who acted in the movie Passengers?", and one possible answer is Jennifer Lawrence, which is an entity in the KG. In a more challenging setting, q can even be an audio segment reading the same question. The training set D train = {(q i , a i )} N i=1 contains N pairs of question and answers. Note that fine-grained annotation is not present, such as the exact entity present in the question, question type, or the exact logic reasoning steps along the knowledge graph leading to the answer. Thus, a QA system with KG should be able to handle noisy entity in questions and learn multi-hop reasoning directly from question-answer pairs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Overall formulation</head><p>To address both key challenges in a unified probabilistic framework, we propose the variational reasoning network (VRN). The overall architecture is shown in Fig 1 <ref type="figure">.</ref> VRN consists of two probabilistic modules, as described below. Module for topic entity recognition: Recognizing the topic entity y (or the entity mentioned in the question) is the first step in performing logic reasoning over the knowledge graph<ref type="foot" target="#foot_2">2</ref> . For example, the topic entity mentioned in Sec 3.1 is the movie Passenger. We denote the topic entity as y, and model the compatibility of this entity with the question q i as a probabilistic model P θ1 (y|q i ), which shows the probability of the KG entity y being mentioned in the question q i . Depending on the question form (text or audio), the parameterization of P θ1 (y|q i ) may be different and details can be found in Sec 3.3. Module for logic reasoning over knowledge graph: Given the topic entity y in question q i , one need to reason over the knowledge graph to find out the answer a i . As described in Sec 3.1, the algorithm should learn to use the reasoning rule (y, acted_by, a i ) for that question. Since there is no annotations for such reasoning step, the QA system has to learn it only from question-answer pairs. Thus we model the likelihood of an answer a i being correct given entity y and question q i as P θ2 (a i |y, q i ). The parameterization of P θ2 (a i |y, q i ) need to capture traversal or reasoning over knowledge graph, which is explained in detail in Sec 3.4.</p><p>Since the topic entity in question is not annotated, it is natural to formulate the problem by treating the topic entity y as a latent variable. With the two probabilistic components above, we model the probability of answer a i being correct given question q i as y∈V (G) P θ1 (y|q i )P θ2 (a i |y, q i ), which sums out all possibilities of the latent variable. Given a training set D train of N question-answer pairs, the set of parameters θ 1 and θ 2 can be estimated by maximizing the log-likelihood of this latent variable model:</p><formula xml:id="formula_1">max θ1,θ2 1 N N i=1 log ⎛ ⎝ y∈V (G) P θ1 (y|q i )P θ2 (a i |y, q i ) ⎞ ⎠ . (1)</formula><p>Next we will describe our parametrization of P θ1 (y|q i ) and P θ2 (a i |y, q i ), and the algorithms for learning and inference based on that.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Probabilistic module for topic entity recognition</head><p>Most existing QA approaches assume that topic entities are annotated, or can be simply found via string matching. However, for more realistic questions or even audio questions, a more general approach is to build a recognizer that can be trained jointly with the logic reasoning engine.</p><p>To handle unlabeled topic entities, we notice that the full context of the question can be helpful. For example, Michael could either be the name of a movie or an actor. It is hard to tell which one relates to the question by merely looking Smoothing μ, σ with {A(y j , q i , a i )} M j=1 6:</p><p>Update the baseline b(•) using least square 7:</p><p>ψ ← ψ − η∇ ψ L using (10) 8:</p><formula xml:id="formula_2">θ 1 ← θ 1 − η∇ θ1 L, θ 2 ← θ 2 − η∇ θ2 L 9:</formula><p>end for at this entity name. However, we should be able to resolve the unique entity by checking the surrounding words in the question. Similarly, in the knowledge graph there could be multiple entities with the same name, but the connected edges (relations) of the entity nodes are different, which helps to resolve the unique entity. For example, as a movie name, Michael may be connected with a directed_by edge pointing to an entity of director; while as an actor name, Michael may be connected with birthday and height edges.</p><p>Specifically, we use a neural network f ent (•) : q → R d which can represent the question q in a d dimensional vector. Depending on the question form (text or audio), this neural network can be a simple embedding network mapping bagof-words to a vector, or a recurrent neural network to embed sentences, or a convolution neural network to embed audio questions. Thus the probability of having y in q is</p><formula xml:id="formula_3">P θ1 (y|q) = softmax W y f ent (q) (2) = exp(W y f ent (q)) y ∈V (G) exp(W y f ent (q)) , (<label>3</label></formula><formula xml:id="formula_4">)</formula><p>where W y ∈ R d , ∀y ∈ V (G) are the weights in the last classification layer. This parameterization avoids heuristic keyword matching for the entity as is done in previous work <ref type="bibr" target="#b14">(Miller, Fisch, and et. al. 2016;</ref><ref type="bibr" target="#b4">Bordes, Chopra, and Weston 2014)</ref>, and makes the entity recognition process differentiable and end-to-end trainable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Probabilistic module for logic reasoning over knowledge graph</head><p>Parameterizing the reasoning model P θ2 (a|y, q) is challenging, since 1) knowledge graph can be very large; 2) the required logic reasoning is unknown and can be multi-step. In other words, retrieving the answer requires multi-step traversal over a gigantic graph. Thus in this paper, we propose a reasoning-graph embedding architecture, where all the inference rules and their complex combinations are represented as nonlinear embeddings in vector space and will be learned. Scope of y. More specifically, we assume the maximum number of steps (or hops), T , of the logic reasoning is known to the algorithm. Starting from a topic entity y, we perform topological sort (ignoring the original edge direction) for all entities within T hops according to the knowledge graph. After that, we get an ordered list of entities a 1 , a 2 , . . . , a m and their relations from the knowledge graph. We call this subgraph G y with ordered nodes as the scope of y.  an example of a 2-hop scope, where entities are labeled with their topological distance to the source entity. Reasoning graph to a. Given a potential answer a in the scope G y , we denote G y→a to be the minimum subgraph that contains all the paths from y to a in G y . The actual logic reasoning leading to answer a for question q is unknown but hidden in the reasoning graph. Thus we will learn a vector representation (or embedding) for G y→a , denoted as g(G y→a ) ∈ R d , for scoring the compatibility of the question type and the hidden path in the reasoning graph.</p><p>More specifically, suppose the question is embedded using a neural network f qt (•) : q → R d , which captures the question type and implies the type of logic reasoning we need to perform over knowledge graph. Then the compatibility (or likelihood) of answer a being correct can be computed using the embedded reasoning graph G y→a and the scope G y as P θ2 (a|y, q) = softmax f qt (q) g(G y→a )</p><p>(4)</p><formula xml:id="formula_5">= exp(f qt (q) g(G y→a ))</formula><p>a ∈V (Gy) exp(f qt (q) g(G y→a ))</p><p>.</p><p>(5)</p><p>We note that the normalization in the likelihood requires the embedding of the reasoning graphs for all entities a in the scope G y . This may involve thousands of or even more reasoning graphs depending on the KG and the number of hops. Computing these embeddings separately can be very computationally expensive. Instead, we develop a neural architecture which can compute these embeddings jointly and share intermediate computations.</p><p>Joint embedding reasoning graphs. More specifically, we propose a "forward graph embedding" architecture, which is analogous to forward filtering in Hidden Markov Model or Bayesian Network. The embedding of the reasoning graph for a is computed recursively using its parents' embeddings:</p><formula xml:id="formula_6">g(Gy→a) = 1 #Parent(a)</formula><p>a j ∈Parent(a),(a j ,r,a) or (a,r,a j )∈Gy</p><formula xml:id="formula_7">σ(V × [g(Gy→a j ), er]), (<label>6</label></formula><formula xml:id="formula_8">)</formula><p>where e r is the one-hot encoding of relation type r ∈ R, V ∈ R d× (d+|R|)  This formulation is able to capture various reasoning rules. Take Fig 2 as an example: the embedding of the entity Killing Them Softly sums up the two embeddings propagated from its parents. Thus it tends to match the reasoning paths from the parent entities. Note that this formulation is significantly different from the work in <ref type="bibr" target="#b8">(Duvenaud et al. 2015;</ref><ref type="bibr" target="#b6">Dai, Dai, and Song 2016;</ref><ref type="bibr" target="#b0">Atwood and Towsley 2016)</ref>, where embedding is computed for each small molecular graph separately. Furthermore, those graph embedding methods often contain iterative processes which visit each nodes multiple times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">End-to-end Learning</head><p>In this section, we describe the algorithm for learning the parameters in P θ1 (y|q) and P θ2 (a|y, q). The overall learning algorithm is described in Algorithm 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Variational method with inverse reasoning-graph embedding</head><p>EM algorithm is often used to learn latent variable models. However, performing exact EM updates for the objective in ( <ref type="formula">1</ref>) is intractable since the posterior cannot be computed in closed form. Instead, we use variational inference and optimize the evidence lower bound:</p><formula xml:id="formula_9">max ψ,θ1,θ2 L(ψ, θ 1 , θ 2 ) = 1 N N i=1 E Q ψ (y|qi,ai) [ log P θ1 (y|q i ) + log P θ2 (a i |y, q i ) − log Q ψ (y|q i , a i )],<label>(7)</label></formula><p>where the variational posterior Q ψ (y|q, a) is jointly learned with the model. Note that ( <ref type="formula" target="#formula_9">7</ref>) is essentially optimizing the lower bound of (1). Thus to reduce the approximation error, a powerful set of posterior distributions is necessary. Variational posterior. Q ψ computes the likelihood of the topic entity y for a question q, with additional information of answer a. Thus besides the direct text or acoustic compatibility of y and q, we can also introduce logic match with the help of a. Similar to the forward propagation architecture used in Sec 3.4, here we can define the scope G a for answer a, the inverse reasoning graph G a→y , and the inverse embedding architecture to efficiently compute the embedding g(G a→y ).</p><p>Finally, the variational posterior consists of two parts:</p><formula xml:id="formula_10">Q ψ (y|q, a) ∝ exp W y fent (q) + fqt (q) g(G a→y ) , (<label>8</label></formula><formula xml:id="formula_11">)</formula><p>where the normalization is done over all entities y in the scope G a . Furthermore, the embedding operators fent , fqt and parameters { Wy } y∈V (G) are defined in the same way as ( <ref type="formula">4</ref>) and ( <ref type="formula" target="#formula_7">6</ref>) but with different set of parameters. One can also share the parameter to obtain a more compact model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">REINFORCE with variance reduction</head><p>Since the latent variable y in the variational objective (7) takes discrete values, which is not differentiable with respect to ψ, we use the REINFORCE algorithm (Williams 1992) with variance reduction (Mnih and Gregor 2014) to tackle this problem. First, using the likelihood ratio trick, the gradient of L with respect to posterior parameters ψ can be computed as (for simplicity of notation, we assume that there is only one training instance, i.e., N = 1):</p><formula xml:id="formula_12">∇ ψ L = E Q ψ (y|q,a) ∇ ψ log Q ψ (y|q, a) A(y, q, a) , (<label>9</label></formula><formula xml:id="formula_13">)</formula><p>where A(y, q, a) = logP θ1 (y|q) + log P θ2 (a|y, q) − log Q ψ (y|q, a) can be treated as the learning signal in policy gradient.</p><p>Second, to reduce the variance of gradient, we center and normalize the signal A(y, q, a) and also subtract a baseline function b(q, a) (Mnih and Gregor 2014). Finally, the gradient in ( <ref type="formula" target="#formula_12">9</ref>) can be approximated by the Monte Carlo method using K samples of the latent variable from Q ψ :</p><formula xml:id="formula_14">∇ ψ L ≈ 1 K K j=1 ∇ ψ log Q ψ (y j |q, a) (A(yj ,q,a)−μ) σ − b(q, a) , (<label>10</label></formula><formula xml:id="formula_15">)</formula><p>where μ and σ estimate the mean and standard deviation of A(y j , q, a) with moving average. b(q, a) is another neural network that fits the expected normalized learning signal.</p><p>In our experiments, we simply build a two-layer perceptron with concatenated one-hot answer and question features. Here b(q, a) tries to fit Ã(y j , q, a) = (A(yj ,q,a)−μ) σ by minimizing the square loss. For other parameters θ 1 and θ 2 in P θ1 (y|q) and P (θ2) (a|y, q) respectively, the gradients are computed in the normal way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Inference</head><p>During inference, we are only given the question q, and ideally we want to find the answer by computing arg max y,a log (P θ1 (y|q)P θ2 (a|y, q)). However, this computation is quadratic in the number of entities and thus too expensive. Alternatively, we can approximate it via beam search. So we select k candidate entities y 1 , y 2 , . . . , y k with top scores from P θ1 (y|q), and then the answer is given by</p><formula xml:id="formula_16">a * = argmax a∈Gy,y∈{y1,y2,...,y k } log P θ2 (a|y, q). (<label>11</label></formula><formula xml:id="formula_17">)</formula><p>In our experiments, we found that k = 1 (equivalent as greedy inference) can already achieve good performance.</p><p>6 Experiments</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">The METAQA benchmark</head><p>There is an existing public QA dataset named Wiki-Movies<ref type="foot" target="#foot_3">3</ref> , which consists of question-answer pairs in the domain of movies and provides a medium-sized knowledge graph <ref type="bibr" target="#b14">(Miller, Fisch, and et. al. 2016</ref>). However, it has several limitations: 1) all questions in it are single-hop, thus it is not able to evaluate the ability of reasoning; 2) there is no noise on the topic entity in question, so it can be easily located in the knowledge graph; 3) it is generated from very limited number of text templates, which is easy to be exploited by models and of limited practical value. Some small datasets like WebQuestions <ref type="bibr" target="#b2">(Berant et al. 2013</ref>) are mostly for single-hop questions; while WikiTableQuestions (Pasupat and Liang 2015) involves tiny knowledge table for each question, instead of one large-scale knowledge graph shared among all questions.</p><p>Thus in this paper, we introduce a new challenging question-answer benchmark: METAQA (MoviE Text Audio QA). It contains more than 400K questions for both single and multi-hop reasoning, and provides more realistic text and audio versions. METAQA serves as a comprehensive extension of WikiMovies. Due to the page limit, we briefly list the datasets included in METAQA below, and put more details in Appendix A<ref type="foot" target="#foot_4">4</ref> . • Audio: To make it even more practical and challenging, we generate audio datasets with the help of text-to-speech (TTS) system. We use Google TTS service to read all the questions in Vanilla. We also provide extracted MFCC features for each question. The Audio dataset also contains 1-hop, 2-hop and 3-hop categories. Note that although the audio is machine-generated, it is still much less regulated compared to text-template-generated data, and have a lot of variations in waveforms. For example, even for the same word, the TTS system can have different intonations depending on the word position in question and other context words. Visualization of the audio data can be found in Appendix C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Competitor methods</head><p>We have three competitor methods: 1) as discussed in Sec 2, <ref type="bibr">Miller, Fisch, and et. al.</ref> proposed Key-Value Memory Networks (KV-MemNN), and reported state-of-the-art results at that time on WikiMovies; 2) Bordes, Chopra, and Weston's QA system also tries to embed the inference subgraph for reasoning <ref type="bibr" target="#b4">(Bordes, Chopra, and Weston 2014)</ref>, but the representation is simply an unordered bag-of-relationships and neighbor entities; 3) the "supervised embedding" is considered as yet another baseline method, which is a simple approach but often works surprisingly well as reported in <ref type="bibr" target="#b7">(Dodge et al. 2015)</ref>.</p><p>We implement baseline methods with Tensorflow. Our results on Vanilla 1-hop are consistent with the reported performance in <ref type="bibr" target="#b14">(Miller, Fisch, and et. al. 2016)</ref>. We take whichever higher and report it in Table <ref type="table" target="#tab_1">1</ref>. For example, our KV-MemNN obtains 95.8% test accuracy, while the original paper reports 93.9% on the same dataset, so we just report 95.8% in table.</p><p>When training KV-MemNN, we use the same number of "internal hops" as the hop number of that dataset. We also try to use more "internal hops" than the dataset hop number, but it is not helpful. Also, we insert knowledge items within 3 hops of the located topic entity to the memory slots, which ensures that if the topic entity is correctly matched, the answer is existing somewhere in the memory array.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Experimental settings</head><p>We use all the datasets in METAQA for experiments. We follow the same split of train/validation/test for all datasets. The number of questions in each part is listed in Appendix (Table <ref type="table">3</ref>). We tune hyperparameters on validation set for all methods. In both Vanilla and NTM, we use bag-of-words representation for entity name to parameterize W y in (3).</p><p>For Vanilla, we have two different settings: 1) provide the entity labels in all questions, so that we can compare with KV-MemNN under the same setting of Miller, Fisch, and et. al. on Vanilla 1-hop dataset; 2) only provide 5% entity labels among all questions, named as Vanilla-EU (EU stands for topic entity unlabeled). We make all the methods use bag-ofwords representation of the question, and avoid hard entity matching. This setting is more of a sanity check of how much the method is dependent on labeled topic entities. In practice, hard matching can always be an option on text data, but it is not feasible for audio data.</p><p>To make task more realistic and challenging, we experiment with EU setting for NTM and Audio datasets. For NTM-EU, only 5% topic entity labels among all questions are provided. For Audio-EU, a higher labeled ratio 20% since it is much more difficult than text data. To handle the variant length of audio questions, we use a simple convolutional neural network (CNN) with three convolutional layers and three max-pooling layers to embed the audio questions into fixed-dimension vectors. We put more details about CNN embedding in Appendix D.</p><p>For all the EU setting above, the small set of entity labeled questions are used to initialize a topic entity recognizer. After that, all methods train on entire dataset but without the entity labels. For VRN, we show that this pretrained recognizer will also get improved with variational joint training; for other baselines, the entity recognizer will be fixed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Results and discussions</head><p>The experimental results are listed in Table <ref type="table" target="#tab_2">1 and Table 2.</ref> Vanilla: Since all the topic entities are labeled, Vanilla mainly evaluates the ability of logic reasoning. Note that Vanilla 1hop is the same as WikiMovies, which is included for sanity check. All the baseline methods achieve similar performance as reported in the original papers <ref type="bibr" target="#b14">(Miller, Fisch, and et. al. 2016;</ref><ref type="bibr" target="#b4">Bordes, Chopra, and Weston 2014)</ref>, while our method performs the best. It is clear to see that 2-and 3-hop questions are harder, leading to significant accuracy drop on all methods. Nevertheless, our method still achieves promising results and lead competitors by a large margin. We notice that KV-MemNN is not performing well on multi-hop reasoning, perhaps due to explosion of relevant knowledge items. Vanilla-EU: Without topic entity labels, all reasoning-based methods are getting worse on multi-hop questions. However, supervised embedding gets better in this case, since it just learns to remember the pair of question and answer entities. According to the statistics in Appendix (Table <ref type="table">4</ref>), a big portion of questions can be answered by just memorizing the pairs in training data. That explains why supervised embedding behaves differently on this dataset. NTM-EU: The questions in this dataset are paraphrased by neural translation model, which increases the variety of wordings, and makes the task harder. It is reasonable that all methods are getting slightly worse results compared to Vanilla-EU. The same explanation applies to supervised embedding, which is not reasoning but memorizing all the pairs. This is indeed weak generalization and it takes advantage of the nature of this dataset, but it is not likely to perform well on new entity pairs. Audio-EU: This audio dataset is the most challenging one. As mentioned in Sec 6.1, even the same word can be pronounced in a variety of intonations. It is hard to recognize the entity in audio data, also hard to tell the question type. It is not surprising that all methods perform worse compared to text data. Our method achieves 37% on 1-hop audio questions, which is very promising. For 2-hop and 3-hop questions, our method still outperforms other methods. Clearly, there is large room for improvement on audio QA. We leave it as future work, and hopefully the METAQA benchmark can facilitate more researchers working on QA systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Model ablation</head><p>Since our framework uses variational method to jointly learn the entity recognizer and reasoning graph embedding, we here do the model ablation to answer the following two questions: 1) is the reasoning graph embedding approach necessary for inference? 2) is the variational method helpful for joint training? Importance of reasoning graph embedding: As the results shown in Table <ref type="table" target="#tab_1">1</ref>, our proposed VRN outperforms all the other baselines, especially in 3-hop setting. Since this experiment only compares the reasoning ability, it clearly shows that simply representing the inference rule as linear combination of reasoning graph entities is not enough. Improvement of entity recognition with joint training: In Fig <ref type="figure" target="#fig_4">3</ref> we show that using our joint training framework with variance reduction REINFORCE, we can improve the entity recognition performance further without the corresponding topic entity label supervision. For 1-hop and 2-hop questions, our model can improve greatly. While for 3-hop, since the inference task is much harder, we can only marginally improve the performance. For audio data, we've improved by 10% in 1-hop case, and it is hard to improve further for multi hops. In Table <ref type="table" target="#tab_1">1</ref>, the baselines perform significantly worse in the EU setting, due to the absence of joint training.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Inspection of learning and inference</head><p>We study the convergence of our learning algorithm in Appendix E.1. It shows variance reduction technique helps the convergence significantly, while simpler tasks converge better. Also we present an example inference path with highest score in the reasoning graph in Appendix E.2. To answer "What are the main languages in David Mandel films?", the model learns to find the movie EuroTrip first through directed or wrote relationships, then follow in_language to get the correct answer German. For visualizing general multi-hop reasoning, attention mechanism in the aggregation operator of each node would be helpful.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: End-to-end architecture of the variational reasoning network (VRN) for question-answering with knowledge graph. The model consists of two probabilistic modules for topic entity recognition (P (y|q)) and logic reasoning over knowledge graph (P (a|y, q)) respectively. Inside the knowledge base plate, the scope of entity Lost Christmas (colored red) is illustrated, and each colored ellipsoid plate corresponds to the reasoning graph leading to a potential answer colored in yellow. The reasoning graphs are efficiently embedded and scored against the question embeddings to retrieve the best answer. During training, to handle the non-differentiable sampling operation y ∼ P (y|q), we use variational posterior with the REINFORCE algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm 1</head><label>1</label><figDesc>Joint training of VRN 1: Initialize θ 1 , θ 2 , φ with small labeled set 2: for i = 1 to n do 3: Sample (q i , a i ) from the training data 4: Sample {y j } M j=1 using (8) 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Fig 2 shows</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A question like "movie sharing same genre and director" would require two reasoning paths y → Crime → a and y → Andrew Dominik → a. The vector representation should encode the information of the entire reasoning-graph, which can be computed recursively. Thus the embedding of Andrew Dominik can be reused by The assassination and Killing Them Softly.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Improvement of the entity recognizer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>counts the number of parents of a in G y . The only boundary case is g(G y→y ) = 0 when y = a. Overall, computing the embedding g(G y→a ) for all a takes O(|V (G y )| + |E(G y )|) time, which is proportional to the number of nodes and edges in the scope G y .</figDesc><table /><note>are the model parameters, σ(•) is a nonlinear function such as ReLU, and #Parent(a)</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Test results (% hits@1) on Vanilla and Vanilla-EU datasets. EU stands for entity unlabeled.</figDesc><table><row><cell></cell><cell>Vanilla</cell><cell>Vanilla</cell><cell>Vanilla</cell><cell>Vanilla-EU</cell><cell>Vanilla-EU</cell><cell>Vanilla-EU</cell></row><row><cell></cell><cell>1-hop</cell><cell>2-hop</cell><cell>3-hop</cell><cell>1-hop</cell><cell>2-hop</cell><cell>3-hop</cell></row><row><cell>VRN</cell><cell>97.5</cell><cell>89.9</cell><cell>62.5</cell><cell>82.0</cell><cell>75.6</cell><cell>38.3</cell></row><row><cell>Bordes, Chopra, and Weston's QA system</cell><cell>95.7</cell><cell>81.8</cell><cell>28.4</cell><cell>39.5</cell><cell>38.3</cell><cell>26.9</cell></row><row><cell>KV-MemNN</cell><cell>95.8</cell><cell>25.1</cell><cell>10.1</cell><cell>35.8</cell><cell>10.3</cell><cell>10.5</cell></row><row><cell>Supervised embedding</cell><cell>54.4</cell><cell>29.1</cell><cell>28.9</cell><cell>18.1</cell><cell>23.2</cell><cell>25.3</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Test results (% hits@1) on NTM-EU and Audio-EU datasets. EU stands for entity unlabeled.</figDesc><table><row><cell></cell><cell>NTM-EU</cell><cell>NTM-EU</cell><cell>NTM-EU</cell><cell>Audio-EU</cell><cell>Audio-EU</cell><cell>Audio-EU</cell></row><row><cell></cell><cell>1-hop</cell><cell>2-hop</cell><cell>3-hop</cell><cell>1-hop</cell><cell>2-hop</cell><cell>3-hop</cell></row><row><cell>VRN</cell><cell>81.3</cell><cell>69.7</cell><cell>38.0</cell><cell>37.0</cell><cell>24.6</cell><cell>21.1</cell></row><row><cell>Bordes, Chopra, and Weston's QA system</cell><cell>32.5</cell><cell>32.3</cell><cell>25.3</cell><cell>18.5</cell><cell>19.3</cell><cell>15.3</cell></row><row><cell>KV-MemNN</cell><cell>33.9</cell><cell>8.7</cell><cell>10.2</cell><cell>4.3</cell><cell>7.0</cell><cell>15.3</cell></row><row><cell>Supervised embedding</cell><cell>16.1</cell><cell>22.8</cell><cell>24.2</cell><cell>4.1</cell><cell>6.1</cell><cell>12.1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>•</head><label></label><figDesc>Vanilla: We have the original WikiMovies as the Vanilla 1-hop dataset. For multi-hop reasoning, we design 21 types of 2-hop questions and 15 types of 3-hop questions, and generate them by random sampling from a text template pool. Details and question examples are in Appendix B.</figDesc><table><row><cell>• NTM: Thanks to the recent breakthrough in neural trans-</cell></row><row><cell>lation models (NTM), we can introduce more variations</cell></row><row><cell>over the Vanilla datasets. We use a NTM trained by dual</cell></row><row><cell>learning techniques (He et al. 2016) to paraphrase ques-</cell></row><row><cell>tion by first translating it from English to French, and then</cell></row><row><cell>sample translations back to English with beam search. The</cell></row><row><cell>questions in the NTM dataset have different wordings but</cell></row><row><cell>keep the same meaning. This dataset also contains 1-hop,</cell></row><row><cell>2-hop and 3-hop categories.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0">The Thirty-Second AAAI Conference on Artificial Intelligence </note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1">Our new benchmark dataset collections METAQA are publicly available at https://goo.gl/f3AmcY.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2">In this paper, we consider the case with single topic entity in each question.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3">It is available at https://research.fb.com/downloads/babi.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4">For Appendix, refer to the full version of our paper at https://arxiv.org/abs/1709.04071.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments This project was supported in part by NSF IIS-1218749, NIH BIGDATA 1R01GM108341, NSF CAREER IIS-1350983, NSF IIS-1639792 EAGER, NSF CNS-1704701, ONR N00014-15-1-2340, Intel ISTC, NVIDIA and Amazon AWS.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Diffusion-convolutional neural networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Atwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>In NIPS</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Dbpedia: A nucleus for a web of open data. The semantic web</title>
		<author>
			<persName><forename type="first">S</forename><surname>Auer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kobilarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lehmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cyganiak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ives</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Semantic parsing on freebase from question-answer pairs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Berant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Frostig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
				<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Freebase: a collaboratively created graph database for structuring human knowledge</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bollacker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Paritosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sturge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1406.3676</idno>
		<title level="m">Question answering with subgraph embeddings</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Driving semantic parsing from the world&apos;s response</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-W</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fourteenth conference on computational natural language learning</title>
				<meeting>the fourteenth conference on computational natural language learning</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Discriminative embeddings of latent variable models for structured data</title>
		<author>
			<persName><forename type="first">H</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Dodge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Szlam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<idno>arXiv</idno>
		<title level="m">Evaluating prerequisite qualities for learning end-to-end dialog systems</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Knowledge vault: A web-scale approach to probabilistic knowledge fusion</title>
		<author>
			<persName><forename type="first">X</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gabrilovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Heitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Strohmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Duvenaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maclaurin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Iparraguirre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bombarell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hirzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aspuru-Guzik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-Y</forename></persName>
		</author>
		<idno type="arXiv">arXiv:1506.01094</idno>
	</analytic>
	<monogr>
		<title level="m">Traversing knowledge graphs in vector space</title>
				<imprint>
			<date type="published" when="2014">2014. 2015. 2015. 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>NIPS</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Survey on challenges of question answering in the semantic web</title>
		<author>
			<persName><forename type="first">K</forename><surname>Höffner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Walter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Marx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Usbeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lehmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-C</forename><surname>Ngomo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="26" />
		</imprint>
	</monogr>
	<note>Semantic Web. Preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Deep recursive neural networks for compositionality in language</title>
		<author>
			<persName><forename type="first">O</forename><surname>Irsoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cardie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Learning graphical state transitions</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><surname>Iclr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Irsoy</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1506.07285</idno>
	</analytic>
	<monogr>
		<title level="m">Ask me anything: Dynamic memory networks for natural language processing</title>
				<imprint>
			<date type="published" when="2015">2017. 2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Scaling semantic parsers with on-the-fly ontology matching</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kwiatkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tarlow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Brockschmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zemel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Berant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Forbus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lao</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.05493</idno>
		<idno>arXiv:1611.00020</idno>
	</analytic>
	<monogr>
		<title level="m">Neural symbolic machines: Learning semantic parsers on freebase with weak supervision</title>
				<imprint>
			<date type="published" when="2013">2013. 2015. 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>Gated graph sequence neural networks</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Learning dependencybased compositional semantics</title>
		<author>
			<persName><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Convolutional neural networks over tree structures for programming language processing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Marx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Usbeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-C</forename><forename type="middle">N</forename><surname>Ngomo</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1606.03126</idno>
		<idno>arXiv:1611.08945</idno>
	</analytic>
	<monogr>
		<title level="m">Neural variational inference and learning in belief networks</title>
				<editor>
			<persName><forename type="first">A</forename><surname>Aaai. Neelakantan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Q</forename><surname>Le</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2014">2014. 2016. 2014. 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>Key-value memory networks for directly reading documents. and Amodei, D. 2016. Learning a natural language interface with neural programmer</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Neelakantan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1504.06662</idno>
		<title level="m">Compositional vector space models for knowledge base completion</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Recursive deep models for semantic compositionality over a sentiment treebank</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pasupat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcnamee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dredze</surname></persName>
		</author>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perelygin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Potts</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1508.00305</idno>
	</analytic>
	<monogr>
		<title level="m">Compositional semantic parsing on semi-structured tables</title>
				<editor>
			<persName><surname>Emnlp</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Sukhbaatar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2013">2015. 2013. 2013a. 2013b</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>NIPS</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Compositional learning of embeddings for relation paths in knowledge bases and text</title>
		<author>
			<persName><forename type="first">K</forename><surname>Toutanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">V</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>-T.; Poon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Quirk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Simple statistical gradient-following algorithms for connectionist reinforcement learning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-W</forename><surname>Chang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1410.3916</idno>
		<idno>arXiv:1609.08075</idno>
	</analytic>
	<monogr>
		<title level="m">S-mart: Novel tree-based structured learning algorithms applied to tweet entity linking</title>
				<imprint>
			<date type="published" when="1992">2014. 1992. 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>Machine Learning</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Semantic parsing via staged query graph generation: Question answering with knowledge base</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-T</forename><surname>Yih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-W</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.02274</idno>
	</analytic>
	<monogr>
		<title level="m">ACL</title>
				<imprint>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>Stacked attention networks for image question answering</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
