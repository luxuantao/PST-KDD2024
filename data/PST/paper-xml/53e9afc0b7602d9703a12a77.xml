<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Correctness of Transactional Memory</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rachid</forename><surname>Guerraoui</surname></persName>
							<email>rachid.guerraoui@epfl.ch</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computer and Communication Sciences</orgName>
								<address>
									<region>EPFL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michał</forename><surname>Kapałka</surname></persName>
							<email>michal.kapalka@epfl.ch</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computer and Communication Sciences</orgName>
								<address>
									<region>EPFL</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On the Correctness of Transactional Memory</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">53B2C49710F97C5A3593B5BFFD41B194</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.1.3 [Programming Techniques]: Concurrent Programming</term>
					<term>D.2.4 [Software Engineering]: Software/Program Verification</term>
					<term>F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems General Terms Theory, Verification Transactional memory, model, correctness, lower bound</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Transactional memory (TM) is perceived as an appealing alternative to critical sections for general purpose concurrent programming. Despite the large amount of recent work on TM implementations, however, very little effort has been devoted to precisely defining what guarantees these implementations should provide. A formal description of such guarantees is necessary in order to check the correctness of TM systems, as well as to establish TM optimality results and inherent trade-offs.</p><p>This paper presents opacity, a candidate correctness criterion for TM implementations. We define opacity as a property of concurrent transaction histories and give its graph theoretical interpretation. Opacity captures precisely the correctness requirements that have been intuitively described by many TM designers. Most TM systems we know of do ensure opacity.</p><p>At a very first approximation, opacity can be viewed as an extension of the classical database serializability property with the additional requirement that even non-committed transactions are prevented from accessing inconsistent states. Capturing this requirement precisely, in the context of general objects, and without precluding pragmatic strategies that are often used by modern TM implementations, such as versioning, invisible reads, lazy updates, and open nesting, is not trivial.</p><p>As a use case of opacity, we prove the first lower bound on the complexity of TM implementations. Basically, we show that every single-version TM system that uses invisible reads and does not abort non-conflicting transactions requires, in the worst case, Ω(k) steps for an operation to terminate, where k is the total number of objects shared by transactions. This (tight) bound precisely captures an inherent trade-off in the design of TM systems. The bound also highlights a fundamental gap between systems in which transactions can be fully isolated from the outside environment, e.g., databases or certain specialized transactional languages, and systems that lack such isolation capabilities, e.g., general TM frameworks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Transactional memory (TM) <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b27">28]</ref> is a programming paradigm in which concurrent threads synchronize via in-memory transactions. A transaction is an explicitly delimited sequence of operations on shared objects. Transactions are atomic: programmers get the illusion that every transaction is executed instantaneously, at some single, unique point in time, and does not observe any concurrency from other transactions. The changes performed by a transaction on shared objects are immediately visible (to other transactions) if the transaction commits, and are completely discarded if the transaction aborts.</p><p>The TM paradigm has raised a lot of hope for mastering the complexity of concurrent programming. The aim is to provide the programmer with an abstraction, i.e., the transaction <ref type="bibr" target="#b7">[8]</ref>, that makes concurrency as easy as with coarse-grained critical sections, while exploiting the underlying multi-core architectures as well as handcrafted fine-grained locking, which is difficult and error-prone. It is thus not surprising to see a large body of work directed at experimenting with various kinds of TM implementation strategies, e.g. <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b24">25]</ref>. What might be surprising is the little formalization of the precise guarantees that TM implementations should provide. Without such formalization, it is impossible to check the correctness of these implementations, establish any optimality result, or determine whether TM design trade-offs are indeed fundamental or simply artifacts of certain environments.</p><p>From a user's perspective, a TM should provide the same semantics as critical sections: transactions should appear as if they were executed sequentially. However, a TM implementation would be inefficient if it never allowed different transactions to run concurrently. Reasoning about the correctness of a TM implementation goes through defining a way to state precisely whether a given execution in which a number of transactions execute steps in parallel "looks like" an execution in which these transactions proceed one after the other. The role of a correctness criterion in this context is precisely to capture what the very notion of "looks like" really means.</p><p>At first glance, it seems very likely that such a criterion would correspond to one of the numerous ones defined in the literature, e.g., linearizability <ref type="bibr" target="#b15">[16]</ref>, serializability <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b1">2]</ref>, rigorous scheduling <ref type="bibr" target="#b3">[4]</ref>, etc. We argue, however, that none of these criteria, nor any straightforward combination or extension thereof, is sufficient to describe the semantics of TM with its subtleties. In particular, none of them captures exactly the very requirement that every transaction, including a live (i.e., not yet completed) one, accesses a consistent state, i.e., a state produced by a sequence of previously committed transactions. While a live transaction that accesses an inconsistent state can be rendered harmless in database systems simply by being aborted, such a transaction might create significant dangers when executed within a general TM framework, as we illustrate later in this paper. It is thus not surprising that most TM implementations employ mechanisms that disallow such situations, sometimes at a big cost. At a very high level, disallowing transactions to access inconsistent states resembles, in the database terminology, preventing dirty reads or, more generally, the read skew phenomenon <ref type="bibr" target="#b0">[1]</ref>, when generalized to all transactions (not only committed ones as in <ref type="bibr" target="#b0">[1]</ref>) and arbitrary objects.</p><p>In this paper, we present opacity, a correctness criterion aimed at capturing the semantics of TM systems. The technical challenge in specifying opacity is the ability to reason about states accessed by live transactions, and to do so in a model (a) with arbitrary objects, beyond simple read/write variables, (b) possibly with multiple versions of each object, and (c) without precluding various TM strategies and optimization techniques, such as invisible reads, lazy updates, caching, or open nesting.</p><p>Most transactional memory systems we know of ensure opacity, including DSTM <ref type="bibr" target="#b13">[14]</ref>, ASTM <ref type="bibr" target="#b17">[18]</ref>, SXM <ref type="bibr" target="#b12">[13]</ref>, JVSTM <ref type="bibr" target="#b4">[5]</ref>, TL2 <ref type="bibr" target="#b5">[6]</ref>, LSA-STM <ref type="bibr" target="#b24">[25]</ref> and RSTM <ref type="bibr" target="#b18">[19]</ref>. They do so by combining classical database concurrency and recovery control schemes with additional validation strategies, which ensure that every return value of an operation executed by a transaction is consistent with the return values of all previous operations of the very same transaction. (This leads to aborting the transaction if there is any risk of accessing an inconsistent state.) These strategies are usually implemented using the single-writer multiple-readers pattern, with either explicit locks (e.g., TL2) or "virtual", revocable ones (e.g., obstruction-free TMs, such as DSTM, ASTM and SXM), sometimes with a multi-versioning scheme (e.g., LSA-STM and JVSTM) or specialized optimization strategies.</p><p>There are indeed TM implementations that do not ensure opacity; these, however, explicitly trade safety guarantees, while recognizing the resulting dangers, for improved performance. Examples are: a version of SI-STM <ref type="bibr" target="#b25">[26]</ref> and the TM described in <ref type="bibr" target="#b6">[7]</ref>. We believe that opacity can also be used as a reference point for expressing the semantics of such TM implementations and deriving other, possibly weaker, correctness criteria. This would enable fair comparison between TM algorithms and better recognition of their safety-performance trade-offs.</p><p>Besides defining opacity, we also present its graph characterization. Basically, we show how to build a graph that visualizes dependencies between transactions in a given execution, and how to express opacity in terms of acyclicity of such a graph. This interpretation helps proving correctness of TM implementations, highlighting opacity of a given execution, or visualizing opacity violations.</p><p>As a use case for opacity, we establish the first complexity bound for TM implementations. Roughly speaking, we prove that TM implementations that ensure opacity while (1) using invisible reads, <ref type="foot" target="#foot_0">1</ref> (2) ensuring that no transaction is aborted unless it conflicts with another live transaction, and (3) employing a single-version scheme, require, in the worst case, Ω(k) steps for per-operation validation, where k is the total number of objects shared by transactions.</p><p>This lower bound is tight: DSTM and ASTM ensure opacity and have the above three properties, and require, in the worst case, Θ(k) steps to complete a single operation (or, in other words, Θ(k<ref type="foot" target="#foot_1">2</ref> ) steps to execute a transaction that accesses k objects). On the other hand, TM implementations that use visible reads, e.g., SXM and RSTM, or abort transactions more often, e.g., TL2, can have a constant complexity. 2  Indirectly, the lower bound also highlights a gap between database transactions, or, more generally, systems that support full isolation of transactional code from the outside environment, for which serializability is sufficient, and memory transactions (in the sense of most TM frameworks). Indeed, our bound does not hold for serializability, even when considered in its strict form to account for real-time order and combined with recoverability <ref type="bibr" target="#b10">[11]</ref>. In this sense, requiring opacity is a key to establish our lower bound and hence capture the trade-off between implementations like DSTM and ASTM on one hand, and implementations like SXM, RSTM or TL2 on the other hand.</p><p>To summarize, this paper contributes to the study of transactional memory systems: we present (a) a candidate correctness criterion to measure the correctness of a TM implementation, together with its graph characterization, and (b) the first lower bound on the complexity of TM implementations.</p><p>The rest of the paper is organized as follows. We first give an intuitive description of what is generally expected from a TM and argue why a new correctness criterion is indeed necessary to capture this intuition. We then define our notion of opacity and describe its graph characterization. Next, we establish our complexity lower bound. We conclude by discussing complementary issues such as how one can deal with mixing transactional and non-transactional operations <ref type="bibr" target="#b2">[3]</ref>, encompass nested transactions <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b21">22]</ref>, or specify progress properties <ref type="bibr" target="#b26">[27]</ref>.</p><p>Due to space limitations, we give here only an intuition behind the lower bound result. A complete proof of the lower bound, precise definitions of the terms used thereof, as well as a proof of correctness of the graph characterization of opacity, can be found in the full version of this paper <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Expectations</head><p>Nearly every paper about TM gives some intuition about what a TM implementation should ensure. Clearly, committed transactions should appear as if they executed instantaneously, at some unique point in time, and aborted transactions, as if they did not execute at all. Additionally, the following two guarantees (both provided by critical sections) are considered (sometimes implicitly) as essential aspects of TM semantics.</p><p>Preserving real-time order. It is generally required from a TM that the point in time at which a transaction appears to occur lies somewhere within the lifespan of the transaction. This means that a transaction should not observe an outdated state of the system, which can be the case if extensive caching of object states is used. That is, if a transaction T1 modifies an object x and commits, and then another transaction T2 starts and reads x, then T2 should read the value written by T1 and not an older value. More generally, if a transaction Ti commits before a transaction Tj starts, then Ti should indeed appear as if it executed before Tj.</p><p>Violating real-time ordering may lead to counter-intuitive situations, as explained in <ref type="bibr" target="#b23">[24]</ref>, and mislead programmers typically used to critical sections that naturally enforce real-time ordering. Preserving real-time ordering is also particularly important when transactions can read from (or write to) devices that are not controlled by the TM, e.g., clocks or storage devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Precluding inconsistent views.</head><p>A more subtle issue is related to the state accessed by live transactions (i.e., transactions that did not commit or abort yet). Because a live transaction can always be later aborted, and its updates discarded, one might simply assume that the remedy to a transaction that accesses an inconsistent state is to abort it. This is the case for databases, in which transactions are executed in a fully controlled environment. However, memory transactions are autonomous programs. As argued in <ref type="bibr" target="#b28">[29]</ref>, a transaction that accesses an inconsistent state can cause various problems, even if it is later aborted.</p><p>To illustrate this, consider two shared objects, x and y. A programmer may assume that y is always equal to x 2 , and x ≥ 2. Clearly, the programmer will then take care that every transaction, when executed as a whole, preserves the assumed invariants. Assume the initial value of x and y is 4 and 16, respectively, and let T1 be a transaction that performs the following operations:</p><p>x := 2; y := 4; commit Now, if another transaction T2 executes concurrently with T1 and reads the old value of x (4) and the new value of y (also 4), the following problems may occur, even if T2 is to be aborted later: First, if T2 tries to compute the value of 1/(y -x), then a "divide by zero" exception will be thrown, which can crash the process executing the transaction or even the whole application. Second, if T2 enters the following loop: t := x do array[t] := 0; t := t + 1 until t = y then unexpected memory locations could be overwritten, not to mention that the loop would need to span the entire value domain. <ref type="foot" target="#foot_2">3</ref>Other examples <ref type="bibr" target="#b28">[29]</ref> include situations where a transaction that observes an inconsistent state performs direct (and unexpected) IO operations, which are difficult to undo and thus usually forbidden within transactions.</p><p>When programs are run in managed environments, these problems can be solved by carefully isolating transactions from the outside world (sandboxing), as in databases. However, it is commonly argued that sandboxing is expensive and applicable only to specific run-time environments <ref type="bibr" target="#b5">[6]</ref>. <ref type="foot" target="#foot_3">4</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Why a New Correctness Criterion for TM?</head><p>Given the large body of literature on concurrency control, it seems a priori very likely that the intuition behind TM semantics is already captured by some existing consistency criterion. We argue below that this is not the case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Linearizability</head><p>Linearizability <ref type="bibr" target="#b15">[16]</ref>, a safety property devised to describe shared objects, is sometimes used as a correctness criterion for TM. In the TM terminology, linearizability means that, intuitively, every transaction should appear as if it took place at some single, unique point in time during its lifespan. Clearly, aborted transactions have to be accounted for, e.g., through an extension of linearizability described in <ref type="bibr" target="#b30">[31]</ref>.</p><p>Linearizability would be an appropriate correctness criterion for TM if transactions were external to the application using them, i.e., if only the end result of a transaction counted. However, a TM transaction is not a black box operation on some complex shared object but an internal part of an application: the result of every operation performed inside a transaction is important and accessible to a user. As indicated in the original paper on linearizability <ref type="bibr" target="#b15">[16]</ref>, serializability and its derivatives are more suitable a base to reason about the correctness of transaction executions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Serializability</head><p>Serializability <ref type="bibr" target="#b23">[24]</ref> is one of the most commonly required properties of database transactions. Roughly speaking, a history H of transactions (i.e., the sequence of operations performed by all transactions in a given execution) is serializable if all committed transactions in H issue the same operations and receive the same responses as in some sequential history S that consists only of the transactions committed in H. (A sequential history is, intuitively, one with no concurrency between transactions.) Serializability, even considered in its strict form <ref type="bibr" target="#b23">[24]</ref> to account for real-time ordering, is not sufficient for modelling a TM for various reasons: (a) it relies on the implicit assumption that a read operation on a shared object x always returns the last value previously written to x; (b) it is restricted only to read and write operations, and (c) it does not say anything about the state accessed by live (or aborted) transactions. As we discuss below, variants of serializability tackle some of these issues but none of them, nor any clear combination thereof, does the entire job.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">1-Copy Serializability</head><p>Memory transactions may create local or shared copies of some shared objects and use them temporarily for their operations. Thus, a transaction Ti, when reading a shared object x, may be returned one of the many versions of x that are globally or locally accessible to Ti, not necessarily the most recent one.</p><p>1-copy serializability <ref type="bibr" target="#b1">[2]</ref> is similar to serializability, but allows for multiple versions of any shared object, while giving the user an illusion that, at any given time, only one copy of each shared object is accessible to transactions. Besides not requiring anything about the state accessed by live transactions, a major limitation of 1-copy serializability is the underlying model being restricted only to read and write operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Global Atomicity</head><p>It is usually argued that providing shared objects with richer semantics than simple read-write variables can decrease the probability of conflicts between transactions and thus increase throughput <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b22">23]</ref>. To illustrate this, consider several transactions concurrently increasing a counter x, without reading its value: T1: T2: ... Tk: x.inc()</p><p>x.inc() x.inc() commit commit commit</p><p>In a system that supports only read and write operations, each transaction has to first read x and then write a new value to x. Unfortunately, among the transactions that read the same value from x, only one can commit (otherwise, (1-copy) serializability is violated).</p><p>Clearly, when the system recognizes the semantics of the inc operation, there is no reason why the transactions could not proceed and commit concurrently. More generally, a TM implementation may exploit the benefits of operations that are idempotent, commutative, or write-only (see <ref type="bibr" target="#b21">[22]</ref> for more elaborate examples). Supporting arbitrary shared objects brings, however, additional significant difficulties in reasoning about correctness. We can no longer assume that each operation is either read-only or write-only, and that each shared object is historyless, or even deterministic (in the most general case). We need to consider a formal description of the semantics of the implemented shared objects as an input parameter to the TM correctness criterion, not as its integral part. A further complication comes from the fact that certain operations cannot be undone. Some TM implementations might allow such operations to be executed by a transaction, e.g., by buffering them until the transaction is guaranteed to commit and speculating on return values. Thus, we cannot include roll-back operations in a history to model aborted transactions. A history that satisfies global atomicity (with real-time ordering guarantees) and recoverability, but in which an aborted transaction (T2) accesses an inconsistent state of the system (x and y are simple variables/objects that implement read and write operations)</p><p>Global atomicity <ref type="bibr" target="#b29">[30]</ref> is a general form of serializability that addresses the above issue. It (a) is not restricted only to read-write objects, and (b) does not preclude several versions of the same shared object. Nevertheless, global atomicity restricts only the execution of committed transactions and does not require anything about the state accessed by live (or aborted) transactions. Therefore, it needs to be extended accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Recoverability</head><p>Recoverability <ref type="bibr" target="#b10">[11]</ref> puts restrictions on the state accessed by every transaction, including a live one. Intuitively, recoverability precludes certain undesirable effects, such as cascading aborts, which may occur when a live transaction observes changes done by another live transaction. In its strongest form, recoverability requires, intuitively, that if a transaction Ti updates a shared object x, then no other transaction can perform an operation on x until Ti commits or aborts. It may seem at first that recoverability, combined with global atomicity, and extended to account for real-time ordering of transactions, matches the TM requirements highlighted in Section 2. Unfortunately, this is not the case, as illustrated by the following example.</p><p>Consider a history H corresponding to the scenario depicted in Figure <ref type="figure" target="#fig_0">1</ref>. H satisfies global atomicity: transaction T2 aborts and transactions T1 and T3 are sequential. Moreover, H satisfies recoverability: T2 accesses x after T1 commits and before T3 starts, whilst T2 accesses y after T3 commits. Nevertheless, T2 accesses an inconsistent state: T2 could not have read x = 1 and y = 2 if T2 was executed between T1 and T3, or after T3.</p><p>On the other hand, recoverability restricts TM implementations too much in a general model with arbitrary shared objects. For instance, consider the example from Section 3.4 in which many transactions try to increment a shared counter. Recoverability does not allow them to proceed concurrently, for each modifies the same shared object. However, there is no reason why a TM implementation could not execute them in parallel: even if one of these transactions aborts, it has no influence on the others (at least as long as no transaction reads the value of the counter).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Rigorous Scheduling</head><p>At a high level, what seems to be required is a correctness criterion precluding any two transactions from concurrently accessing an object if one of them updates that object. Restricted to read-write objects (registers), this resembles the notion of rigorous scheduling <ref type="bibr" target="#b3">[4]</ref> in database systems. As we argue through the following example, however, this would be too strong and would preclude valid TM implementations.</p><p>Consider the following situation in which several transactions concurrently update overlapping sets of objects: T1: T2: ... Tk:</p><formula xml:id="formula_0">x := 1 x := 2 x := k y := 1 y := 2 y := k z := 1 z := 2 z := k commit commit commit</formula><p>Rigorous scheduling requires that all but one of the transactions get blocked or aborted. However, a user does not really care as long as the end result is consistent (i.e., reading x, y and z always gives x = y = z ∈ {1, . . . , k}). We can imagine a TM implementation that executes the write operations in a "smart" way (e.g., making sure that some transactions do not overwrite results of other ones) and thus allows for more concurrency. Such an implementation could be fine from a user's perspective, and so should not be considered incorrect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Towards Extending Global Atomicity</head><p>In short, formalizing the TM semantics goes through finding a way to extend global atomicity with the requirement that live (and aborted) transactions always access consistent state, but without limiting the generality of the model. This is not trivial, mostly for the following two reasons. First, because we consider arbitrary objects' operations, some of which cannot always be undone, we are not able to model aborted transactions by simply inserting "virtual" events that roll-back the changes done by these transactions. Second, a user's application commits a transaction by submitting a commit request to a TM implementation and waiting for the response. Thus, there is no single commit event, unlike in database models: the transaction gets committed somewhere between the request and the response events. Even TM implementations do not always commit transactions in a single step. While this looks like a minor detail, it has important implications. Basically, a live transaction for which a commit request has been issued can appear as committed or aborted depending on the context. Thus, expressing the semantics of live transactions is a challenging problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Model of Transactional Memory</head><p>Before describing our new correctness criterion, we introduce here a precise model of a TM as seen from a user's perspective. The formalism given here underlies our notion of opacity, but is general enough to be a base for other, possibly weaker, correctness criteria or alternative properties. In Section 6, we will extend the model given here to include operations (e.g., hardware instructions) used by software TM implementations. <ref type="foot" target="#foot_4">5</ref>Our model is similar to the one in <ref type="bibr" target="#b29">[30]</ref>. The main difference is the way we treat the termination of transactions, which is crucial in the TM context: We consider a pair of commit-try and commit events instead of a single atomic commit step (cf. Section 3.7). Besides, we define additional terms related to live transactions, which are used for specifying opacity.</p><p>Transactions and shared objects. A TM allows for threads of an application to communicate by executing transactions. A transaction may perform operations on shared objects, as well as local computations on objects inaccessible to other transactions. An operation (on a shared object) may take some arguments and return some value. We denote by Obj the set of objects shared by transactions.</p><p>Every shared object exports a certain set of operations. For example, a register object (which is often used in the examples in this paper) exports operations read and write. The read operation takes no arguments (or an empty argument ⊥) and returns the current state of the register. The write(v) operation sets the state of the register to the value v given as an argument and always returns ok. (Clearly, the domain of possible values of v will be restricted in most cases.)</p><p>Every transaction has a unique identifier from a set Trans = {T1, T2, . . .}. Every transaction is initially live and may eventually become either committed or aborted, as explained in detail in the following paragraphs. A transaction that is not live does no longer perform any actions. Retrying an aborted transaction (i.e., the computation the transaction intends to perform) is considered in our model as a new transaction, with a different transaction identifier.</p><p>Transactional events. In order to execute an operation op on a shared object ob, a transaction Ti (i.e., a transaction with identifier Ti) issues an operation invocation event invi(ob, op, args) and expects a matching operation response event reti(ob, op, val), where args are the arguments passed to the operation and val is the value returned by the operation. A transaction is sequential, in the sense that it does not invoke any operation until it receives a response from the last operation it invoked. An operation invocation event and an operation response event match if they are issued by/for the same transaction and refer to the same shared object and operation.</p><p>A transaction Ti might also issue two special events: a committry event tryC i or an abort-try event tryA i . After issuing tryC i or tryA i , transaction Ti waits for a commit event Ci or an abort event Ai. Intuitively, tryC i expresses the will of transaction Ti to commit. In response, the transaction can get either committed (event Ci) or aborted (event Ai). An event tryA i indicates that transaction Ti wants to be aborted and always results in an abort event Ai for Ti. <ref type="foot" target="#foot_5">6</ref>A commit-try/abort-try event and a commit/abort event match if they are issued by/for the same transaction.</p><p>An abort event might also be received by a transaction instead of an operation response event. This usually happens if the TM knows that the transaction will not be able to commit later (because of conflicts with other transactions), or if the TM cannot return an operation response event with no risk of violating opacity.</p><p>We divide events into two categories. Operation invocation, commit-try and abort-try events are called invocation events. Operation response, commit and abort events are called response events. Invocation events are initiated by transactions, and response events-by a TM. As every transaction is an integral part of an application, and is fully controlled by its application thread, a TM does not know in advance which invocation events will be issued by a transaction. That is, the TM does not know which operations on which shared objects a transaction will perform, and whether the transaction will request to be committed (commit-try event) or aborted (abort-try event).</p><p>An operation execution is a pair of an operation invocation event and a matching operation response event. That is, an operation execution execi(ob, op, args, val) is a sequence invi(ob, op, args), reti(ob, op, val) . <ref type="foot" target="#foot_6">7</ref> When there is no ambiguity, we will say operation and operation execution interchangeably.</p><p>When considering register objects, we use the following simplified notation. We denote by readi(r, v) a read operation execution on register r, by transaction Ti, returning value v, and by writei(r, v) a write operation execution on register r, by Ti, with value v given as an argument. More formally, readi(r, v) = execi(r, read, ⊥, v), and writei(r, v) = execi(r, write, v, ok).</p><p>Transaction histories. A (high-level) history is the sequence of all invocation and response events that were issued and received by transactions in a given execution. <ref type="foot" target="#foot_7">8</ref> Thus, we assume that all events of an execution can be totally ordered according to the time at which they were issued. Simultaneous events (e.g., on multiprocessor systems) can be ordered arbitrarily.</p><p>We use the following notations. Consider any history H:</p><p>• H|Ti denotes the longest subsequence of history H that contains only events executed by transaction Ti, • H|ob denotes the longest subsequence of history H that contains only operation invocation events and operation response events on shared object ob, and • H • H denotes the concatenation of histories H and H .</p><p>We say that a transaction Ti is in history H, and write Ti ∈ H, if H|Ti is a non-empty sequence, i.e., if there is at least one event of Ti in H.</p><p>We assume that every history H is well-formed. Intuitively, this means that the sequence of events at each individual transaction Ti (i.e., the history H|Ti) is of the form: an invocation event, a matching response event, an invocation event, and so on, where (1) no event follows a commit or abort event, (2) only a commit or abort event can follow a commit-try event, and (3) only an abort event can follow an abort-try event. More formally, for every transaction Ti ∈ Trans, history H|Ti is a prefix of a sequence O • F , where O is a sequence of operation executions issued by transaction Ti, and F is one of the following sequences: (1) invi(ob, op, args), Ai (for some shared object ob, an operation op of ob, and arguments args of op), (2) tryA i , Ai , (3) tryC i , Ci , or (4) tryC i , Ai .</p><p>Intuitively, we consider two histories to be equivalent, if they contain the same transactions, and every transaction issues the same invocation events and receives the same response events in both histories. Thus, equivalent histories differ only in the relative position of events of different transactions. More precisely, we say that histories H and H are equivalent, and write H ≡ H , if, for every transaction Ti ∈ Trans, H|Ti = H |Ti.</p><p>We say that an invocation event e issued by a transaction Ti is pending in a history H, if there is no response event matching e and following e in history H|Ti.</p><p>For example, the following (well-formed) history H1 corresponds to the execution depicted in Figure <ref type="figure" target="#fig_0">1</ref>:</p><formula xml:id="formula_1">H1 = write1(x, 1), tryC 1 , C1, read2(x, 1), write3(x, 2), write3(y, 2), tryC 3 , C3, read2(y, 2), tryC 2 , A2 .</formula><p>Clearly, there is no pending invocation event in H1. The following history H2 is one of the histories that are equivalent to H1: H2 = write1(x, 1), tryC 1 , C1, write3(x, 2), write3(y, 2), tryC 3 , C3, read2(x, 1), read2(y, 2), tryC 2 , A2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Status of transactions.</head><p>If the last event of a transaction Ti in a history H is Ci or Ai, then we say that Ti is, respectively, committed or aborted in H. A transaction that is committed or aborted is completed. A transaction that is not completed is called live. An aborted transaction that did not issue an abort-try event is said to be forcefully aborted. A live transaction that has issued a commit-try event is said to be commit-pending.</p><p>For example, in history H1 described before, all transactions are completed. Transactions T1 and T3 are committed in H1, while transaction T2 is forcefully aborted in H1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Real-time order of transactions.</head><p>There is a clear happen-before relation between a completed transaction Ti and every transaction that issues its first event after Ti becomes committed or aborted (in a given history H). This happen-before relation in a history H, which we denote by ≺H , defines what we call the real-time order of transactions in H. More precisely, for every history H, relation ≺H is the partial order on the transactions in H, such that, for any two transactions Ti, Tj ∈ H, if Ti is completed and the first event of Tj follows the last event of Ti in H, then Ti ≺H Tj.</p><p>We say that transactions Ti, Tj ∈ H are concurrent in history H if they are not ordered by the happen-before relation ≺H , i.e., if Ti ≺H Tj and Tj ≺H Ti.</p><p>We say that a history H preserves the real-time order of a history H, if ≺H ⊆ ≺ H . That is, if Ti ≺H Tj, then Ti ≺ H Tj, for any two transactions Ti and Tj in H.</p><p>For example, consider history H1 described before. In H1, transactions T2 and T3 are concurrent, T1 ≺H 1 T2, and T1 ≺H 1 T3. Any history H for which T1 ≺H T2 and T1 ≺H T3 (e.g., history H2) preserves the real time order of H1. Sequential histories. A (well-formed) history H is sequential if no two transactions in H are concurrent. Sequential histories are of special interest, because their correctness is trivial to verify, given a precise semantics of the shared objects and their operations.</p><p>For example, history H2 introduced before is sequential. On the contrary, history H1 (equivalent to H2) is not sequential, because transactions T2 and T3 are concurrent in H1.</p><p>Complete histories. We say that a history H is complete if H does not contain any live transaction. For example, histories H1 and H2 used in the previous examples are both complete.</p><p>If a history H is not complete, then we can transform it to a complete history H by aborting or committing the live transactions in H. More specifically, for every history H we define a set of (well-formed) histories Complete(H). Intuitively, every history H in Complete(H) is obtained from history H by committing or aborting every commit-pending transaction in H, and aborting every other live transaction in H. More precisely, a history H is in Complete(H), if (1) H is well-formed, (2) H is obtained from H by inserting a number of commit-try, commit and abort events for transactions that are live in H, (3) every transaction that is live and not commit-pending in H is aborted in H , and (4) every transaction that is commit-pending in H is either committed or aborted in H . Clearly, every history in a set Complete(H) is complete.</p><p>For example, consider the following history H3:</p><formula xml:id="formula_2">H3 = write1(x, 1), tryC 1 , read2(x, 1) .</formula><p>Then, in each history in set Complete(H3): (1) transaction T1 is either committed or aborted, and (2) transaction T2 is (forcefully) aborted. The following histories are some of the elements of Complete(H3):</p><formula xml:id="formula_3">H 3 = write1(x, 1), tryC 1 , C2, read2(x, 1), tryC 2 , A2 , H 3 = write1(x, 1), tryC 1 , read2(x, 1), tryC 2 , A2, C1 .</formula><p>Sequential specification of a shared object. We use the concept of a sequential specification to describe the semantics of shared objects, as in <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b15">16]</ref>. Intuitively, a sequential specification of a shared object ob lists all sequences of operation executions on ob that are considered correct when executed outside any transactional context, e.g., in a standard, single-threaded application. 9 For exam- 9 An operation execution specifies a transaction identifier, but the identifier can be treated as a part of the arguments of the executed operation. In fact, in ple, the sequential specification of a register x, denoted by Seq(x), is the set of all sequences of read and write operation executions on x, such that in each sequence that belongs to Seq(x), every read (operation execution) returns the value given as an argument to the latest preceding write (regardless transaction identifiers). (In fact, Seq(x) also contains sequences that end with a pending invocation of read or write, but this is a minor detail.) Such a set defines precisely the semantics of a read-write register in a single-threaded, non-transactional system. More formally, let an object-local history of a shared object ob be any prefix S of a sequence of operation executions, such that S|ob = S. Then, a sequential specification Seq(ob) of a shared object ob may be any prefix-closed set of object-local histories of that object. (A set Q of sequences is prefix-closed if, whenever a sequence S is in Q, every prefix of S is also in Q.)</p><p>Legal histories and transactions. Let S be any sequential history, such that every transaction in S, except possibly the last one, is committed. Intuitively, we will say that S is legal if S respects the sequential specifications of all the shared objects, operations on which are performed in S. Note that the meaning of the word "respects" is clear here, because in S no two transactions are concurrent and no transaction comes after a live or aborted transaction. More formally, a sequential history S is legal if, for every shared object ob ∈ Obj , subsequence S|ob is in set Seq(ob).</p><p>Let S be any complete sequential history. In general, for such a history the definition of a legal history does not necessarily apply, because there may be many aborted transactions in S. Thus, we will instead consider each transaction Ti in S separately (Ti being committed or aborted), together with all the committed transactions preceding Ti in S, and determine legality of so-constructed sequential history. More precisely, we say that a transaction Ti ∈ S is legal in S, if the largest subsequence S of S, such that, for every transaction T k ∈ S , either (1) k = i, or (2) T k is committed and T k ≺S Ti, history S is legal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Opacity</head><p>Opacity is a safety property that captures the intuitive requirements that (1) all operations performed by every committed transaction appear as if they happened at some single, indivisible point during the transaction lifetime, (2) no operation performed by any aborted transaction is ever visible to other transactions (including live ones), and (3) every transaction always observes a consistent state of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Intuition</head><p>The first requirement above is captured by the classical notion of global atomicity <ref type="bibr" target="#b29">[30]</ref>. This notion stipulates that after removing all non-committed transactions from any history H, the resulting history H is equivalent to some sequential history S that respects the sequential specification of every shared object (i.e., is legal). Additionally, we also require that S preserves the real-time ordering of transactions in H .</p><p>Global atomicity (even if combined with recoverability), however, does not guarantee the other two requirements, as explained in Section 3. Intuitively, when a transaction Ti accesses some shared object, Ti should observe the changes done to the shared object by all transactions that committed before Ti started, but should not see any modifications done by transactions that are still live (and not commit-pending) or aborted. Moreover, no transaction should observe the changes done by Ti until Ti commits, i.e., until some unique point in time, between commit-try and commit events of most cases, the semantics of an operation does not depend on the transaction that issues this operation. To see how we capture the second and third requirement, consider complete histories only. The key idea is to check, for every such history H, that every (aborted or committed) transaction T k in H observes a state of the system produced by a sequence of all committed transactions preceding T k , and some committed transactions concurrent with T k . More precisely, we require that there exists a sequential history S, such that (1) S is equivalent to H, (2) S preserves the real-time order of H, and (3) every transaction in S is legal in S. The requirement (3) means that, for every transaction T k in S, the longest subsequence of S made of (1) all committed transactions preceding T k in S, and (2) transaction T k itself, is a legal history, i.e., a history that respects the semantics of all operations on shared objects. In a sense, S corresponds to the (total) order in which transactions appeared to happen (instantaneously) in history H. As we already mentioned, legality is trivial to determine for complete sequential histories, in which no transaction (except possibly the last one) is aborted, given the semantics (i.e., the sequential specifications) of all shared objects accessed by transactions in S.</p><p>As for an incomplete history H, transform it into a complete history H by committing or aborting every live transaction in H. A transaction that is live and not commit-pending in H can only be aborted in H : before a transaction T k invokes a commit-try event, the semantics of T k is the same as of an aborted transaction, i.e, no changes made by T k to shared objects should be visible to other transactions. A transaction that is commit-pending in H can be either aborted or committed in H : all the changes made by a transaction to shared objects become visible at some single unique point in time between commit-try and commit events of the transaction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Definition DEFINITION 1.</head><p>A history H is opaque if there exists a sequential history S equivalent to some history in set Complete(H), such that (1) S preserves the real-time order of H, and (2) every transaction Ti ∈ S is legal in S.</p><p>Two points of the definition contain subtleties that need further explanation. Firstly, the step of transforming a given history H into a complete history results in a set of histories Complete(H). The reason why this set may contain many elements is the dual semantic of commit-pending transactions that may be considered as either committed or aborted. Basically, the exact point in time at which a commit-pending transaction Ti begins to appear as committed to other transactions is not visible to a user, and thus not expressed as an event in a history. While in many TM implementations there is a single instruction at which a commit-pending transaction commits, the safety guarantees that a TM provides to a user should be expressed only with the events that the user can observe. Thus, in a sense, a TM should be treated as a black box the properties of which are defined using its external interface.</p><p>There is, however, a subtlety in the way we treat commitpending transactions. Basically, if a transaction is commit-pending, its changes to shared objects may be already visible to some trans-actions and, at the same time, not yet visible to other ones. For example, consider the following history H4 (x and y are registers with initial value of 0):</p><formula xml:id="formula_4">H4 = read1(x, 0), write2(x,<label>5</label></formula><p>), write2(y, 5), tryC 2 , read3(y, 5), read1(y, 0) .</p><p>In H4, transaction T1 appears to happen before T2, because T1 reads the initial values of registers x and y that are modified by T2.</p><p>Transaction T3, on the other hand, appears to happen after T2, because it reads the value of y written by T2. Because the three transactions in H4 are pairwise concurrent, sequential history</p><formula xml:id="formula_5">S = H4|T1 • tryC 1 , A1 • H4|T2 • C2 • H4|T3 • tryC 3 , A3</formula><p>, equivalent to some history in Complete(H4), trivially preserves the real-time order of H4. Because every transaction is legal in S, history H4 is opaque. However, at first, it may seem wrong that the read operation of transaction T3 returns the value written to y by the commit-pending transaction T2 while the following read operation, by transaction T1, returns the old value of y. But if T1 read value 5 from y, then opacity would be violated, because T1 would observe an inconsistent state of the system (x = 0 and y = 5). Thus, letting T1 read 0 from y is the only way to prevent T1 from being forcefully aborted without violating opacity. Multi-version TMs, like JVSTM and LSA-STM, indeed use such optimizations to allow long read-only transactions to commit despite concurrent updates performed by other transactions. In general, it seems that forcing the order between operation executions of different transactions to be preserved, in addition to the real-time order of transactions themselves, would be too strong a requirement.</p><p>The second subtlety in the definition of opacity is the fact that it does not require every prefix of an opaque history to be also opaque. Thus, the set of all opaque histories is not prefix-closed. However, a history of a TM is generated progressively and at each time the history of all events issued so far must be opaque. Hence, there is no need to enforce prefix-closeness in the definition of opacity, which should be as simple as possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Example</head><p>To illustrate our definition, consider the following history H5, of three transactions accessing two registers (x and y), corresponding to the execution depicted in Figure <ref type="figure" target="#fig_1">2</ref>:</p><formula xml:id="formula_6">H5 = write2(x, 1), write2(y, 2), tryC 2 , inv1(x, read, ⊥), C2<label>, inv3(y</label></formula><p>, write, 3), ret1(x, read, 1), inv1(x, write, 5), ret3(y, write, ok), ret1(x, write, ok), inv1(y, read, ⊥), inv3(x, read, ⊥), ret1(y, read, 2), tryC 1 , ret3(x, read, 1), tryC 3 , A1, C3 .</p><p>Clearly, Complete(H5) = {H5} and ≺H 5 = {(T2, T3)}: there is no live transaction in H5 and T1 is concurrent with T2 and T3 in H5. Therefore, we can find three sequential histories that are equivalent to H5 and preserve the relation ≺H 5 (thus satisfying real-time order). However, T1 reads from x the value that has been written by committed transaction T2. Thus, a sequential history in which T1 precedes T2 is not legal. Similarly, T3 cannot precede T1: T1 reads from y the value written by T2 and not the value written by the committed transaction T3. Consider the following sequential history S = H5|T2 • H5|T1 • H5|T3. Clearly, S is equivalent to H5 and preserves the real-time order of H5. Furthermore, every transaction is legal in S, because sequential histories H5|T2, H5|T2 • H5|T1, and H5|T2 • H5|T3 are legal. Therefore, history H5 is opaque. However, complete history H1 depicted in Figure <ref type="figure" target="#fig_0">1</ref> is not opaque for the following reason. Consider any sequential history S equivalent to H1 ∈ Complete(H1) = {H1}. Because T1 ≺H 1 T2 and T1 ≺H 1 T3, history S may only be one of the following:</p><p>(1) H1|T1 • H1|T2 • H1|T3, or (2) H1|T1 • H1|T3 • H1|T2. However, in both cases transaction T2 is not legal in S. That is because: (1) in the first case, the second read of T2 returns 2 instead of 0 (assuming the initial value of y is 0), and (2) in the second case, the first read of T2 returns 1 instead of 2 (the value written by T3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Graph Characterization</head><p>Representing transactions as graph nodes and the causal relation between them as edges helps visualize a given history. Expressing opacity in terms of the acyclicity of such a graph, on the other hand, makes it easier to prove that the corresponding history is, or is not, opaque (we use this in proving our complexity lower bound). In this section, we present a framework, inspired by the works on 1-copy serializability <ref type="bibr" target="#b1">[2]</ref>, that allows for such a graph-based interpretation of opacity.</p><p>We focus here on histories in which every shared object used by a transaction is a read-write register. To simplify the discussion (but without loss in generality), we assume that (1) no two write operations write the same value to the same object (say, some local timestamp and a unique writer's id is added to the value), and (2) each history starts with an initializing, committed transaction T0 that writes some values to every register.</p><p>Let H be a history and Ti be a transaction in H. A read operation (execution) readi(r, v) ∈ H|Ti is local if it is preceded in H|Ti by a write operation writei(r, v ). A write operation writei(r, v) is local if it is followed in H|Ti by a write operation writei(r, v ). A history H is the non-local subhistory of H, denoted nonlocal(H), if H is the longest subsequence of H that does not contain any local operation execution.</p><p>We say that Ti reads (value v from) register r in H, if H|Ti contains readi(r, v). We say that Ti writes (value v to) register r in H, if H|Ti contains invi(r, write, v). We say that a transaction T k reads (register r) from transaction Ti, if Ti writes a value v to r and T k reads value v from r.</p><p>A history H is locally-consistent if, for every transaction Ti and every local operation readi(r, v) ∈ H|Ti, the latest write operation in (H|Ti)|r that precedes readi(r, v) is writei(r, v). A history H is consistent if (1) H is locally-consistent, and (2) for every transaction Ti ∈ H, if Ti reads value v from register r in history nonlocal(H), then some transaction T k writes value v to r in nonlocal(H).</p><p>Let H be a history, -a total order on the set of transactions in H, and V -a subset of the set of commit-pending transactions in H. We call an opacity graph OPG(H, , V ) a directed, labeled graph constructed as follows. Every transaction Ti in H corresponds to a vertex in OPG(H, , V ), and the vertex is labelled Lvis if Ti is in set V or is committed, or L loc otherwise. For every two transactions Ti, T k ∈ H, there is an edge (Ti, T k ) in OPG(H, , V ) in any of the following cases:</p><p>1. If Ti ≺H T k ; then the edge is labelled Lrt;</p><p>2. If T k reads from Ti; then the edge is labelled L rf ;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">If Ti</head><p>T k and Ti reads some register r that is written by T k ; then the edge is labelled Lrw; 4. If Ti ∈ V or Ti is committed, and there exists a transaction Tm and a register r, such that Ti Tm, Ti writes to r, and Tm reads r from T k ; then the edge is labelled Lww.</p><p>We say that opacity graph OPG(H, , V ) is well-formed if the following condition is satisfied: if Ti is a vertex of OPG(H, , V ) labeled L loc , then there is no edge (Ti, T k ) labelled L rf , for any vertex T k of OPG(H, , V ).</p><p>The following theorem, proved in the extended version of this paper <ref type="bibr" target="#b9">[10]</ref>, establishes a formal relationship between the opacity of a given history H and the properties of the opacity graph of H. THEOREM 2. A history H is opaque if, and only if, (1) H is consistent, and (2) there exists a total order on the set of transactions in H and a subset V of the set of commit-pending transactions in H, such that OPG(nonlocal(H), , V ) is well-formed and acyclic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">A Complexity Lower Bound</head><p>A crucial choice in a TM implementation is that of visible vs. invisible read strategy <ref type="bibr" target="#b18">[19]</ref>. To illustrate this, consider a situation in which a transaction Ti invokes a read-only operation op on a shared object ob. The TM implementation that executes Ti, at some process p k , and receives the invocation event of op, must somehow get the current state of ob, apply op locally and return the resulting value to Ti. Additionally, p k may also write somewhere in base (hardware) shared objects the information that Ti is currently accessing ob, in which case the operation op becomes visible to other processes. If p k never modifies any base shared object when processing op, then the operation is always invisible to other processes.</p><p>A practical advantage of invisible reads is that p k , while executing op, does not invalidate any processor cache lines. For readdominated applications, the traffic on the bus between processors is thus greatly reduced, and so the overall throughput of operations is potentially larger. The problem, however, is that while Ti reads some shared objects, other transactions may at any time modify these objects, because read-only operations of Ti are visible only to p k . An additional cost of per-operation validation might thus be required to guarantee that Ti always observes a consistent state. <ref type="foot" target="#foot_8">10</ref>We make use of opacity to precisely determine when invisible reads indeed induce a high operation complexity. Basically, we prove a lower bound of Ω(k) (where k = |Obj |) on the worstcase operation complexity for every TM implementation that uses invisible reads, ( <ref type="formula">1</ref>) is single-version, and (2) does never abort a transaction unless it conflicts with some other live transaction. If any of the two conditions is not required, or if we allow visible reads, one can devise a TM implementation with operation complexity not bounded by Ω(k). That is, the lower bound does not hold for TMs that use visible reads (e.g., RSTM), are multi-version (e.g., JVSTM), or provide strictly weaker progress guarantees (e.g., TL2).</p><p>Opacity is crucial here. One can devise an algorithm that ensures a combination of global atomicity (with real-time ordering) and strict recoverability instead of opacity, uses invisible reads and satisfies properties (1) and ( <ref type="formula">2</ref>) above, and that has constant operation complexity (e.g., such algorithm is given in the extended version of this paper <ref type="bibr" target="#b9">[10]</ref>). In this sense, our bound highlights the complexity gap between systems that support full isolation of transactional code from the outside environment, e.g., databases or virtual machines for languages that can provide "sandboxing" of code blocks, and those that do not. The former systems can render aborted transactions completely harmless and so a correctness criterion weaker than opacity can be used.</p><p>Before giving the outline of the proof, we define certain elements that underly the very notion of a TM implementation, and give an intuition behind the properties used in the proof. (For details of the proof, as well as precise definitions of the elements introduced here, refer to <ref type="bibr" target="#b9">[10]</ref>.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">TM Implementations</head><p>A TM implementation is an algorithm that interprets the events issued by transactions and generates matching responses. The algorithm is executed by a number of processes that communicate by issuing instructions on base shared objects. In a single step, a process issues a single instruction on a single base shared object. We consider that each transaction is executed by a single process, and that each process executes transactions sequentially.</p><p>Roughly speaking, we also assume that every TM implementation satisfies the following conditions: it does not require information about more than a constant number of shared objects to be retrieved from a single base shared object (i.e., in a single step), and it does not force a process to execute steps of the TM algorithm if this process does not have any pending invocation event (i.e., it does not use any specific background services). All TM implementations we know of satisfy these properties.</p><p>Intuitively, we say that a TM implementation I:</p><p>1. Is progressive if I forcefully aborts a transaction Ti only when there is a time t at which Ti conflicts with another, concurrent transaction T k that is not committed or aborted by time t (i.e., T k is live at t); <ref type="foot" target="#foot_9">11</ref> we say that two transactions conflict if they access some common shared object. <ref type="foot" target="#foot_10">12</ref>2. Is single-version if I stores only the latest committed state of any given shared object in base shared objects (as opposed to multi-version TM implementations, e.g., <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b24">25]</ref>).</p><p>3. Uses invisible reads if no base shared object is modified when a transaction performs a read-only operation on a shared object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Complexity Result</head><p>Roughly speaking, the time complexity of a given TM implementation is the maximum possible number of steps that a process may execute while processing a single operation issued by a transaction, i.e., from the operation invocation event until the matching response event. We prove the following result. Proof. (Intuition; the full proof is in <ref type="bibr" target="#b9">[10]</ref>) Consider any progressive, single-version TM implementation that ensures opacity and uses invisible reads. Consider the following scenario: two transactions, T1 and T2, executed by two different processes, p1 and p2, respectively, are accessing only read/write objects. Transaction T1 reads some Θ(k) objects. Then, T2 writes some Θ(k) objects and commits. Now, if T1 invokes a read operation on an object r that has been modified by T2 (and that has not been read by T1 so far), then T1 will be returned the value written to r by T2 (because the TM implementation is single-version). However, p1 needs to determine whether any other object read by T1 has been updated by T2.</p><p>If yes, T1 has to be aborted (instead of returning from the read operation): otherwise opacity would be violated. Indeed, then T1 would read some values before T2 overwrote them with different ones, and some values written by T2. If no, p1 has to let T1 eventually commit; this is because the TM implementation is progressive (and we assume that T1 does not invoke tryA 1 ).</p><p>The key point is that because the TM implementation uses invisible reads, p2 does not know which objects were read by T1. Thus, p2 cannot help p1 detect a situation in which T2 has updated an object that has just been read by T1 before. Now, because only constant-size information can be obtained by p1 in each step, p1 needs to execute Ω(k) steps to be sure whether it has to abort T1 immediately or let T1 commit.</p><p>Even from the intuition of the proof, it should be clear that all the properties we require, i.e., invisible reads, progressiveness, and the single-version scheme, as well as the assumptions we make, are necessary for the lower bound to hold. This is confirmed by the already mentioned counterexample TM implementations that have the time complexity either constant or at least independent of k (e.g., RSTM, JVSTM, TL2, etc.).</p><p>The lower bound is tight because DSTM and ASTM are progressive and single-version, ensure opacity and use invisible reads, and have the time complexity of Θ(k) (with most contention managers). It is worth noting that TL2 has a constant time complexity, although it ensures opacity, uses invisible reads, and is singleversion. That is because TL2 is not progressive: it may forcefully abort a transaction Ti that conflicts with a concurrent transaction T k , even if Ti invokes a conflicting operation after T k commits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Concluding Remarks</head><p>This paper presents opacity: a correctness criterion for TM systems. Opacity constitutes a first step towards a theory of transactional memory. Such a theory is badly missing to reason about the correctness of TM algorithms and establish underlying optimality results and inherent trade-offs, as well as serve as a reference point for weaker models that would be more efficient to implement (cf. serializability vs. lower isolation levels in databases). Many related issues were, however, not addressed in this paper.</p><p>In particular, we considered a concurrency scheme where all accesses to shared objects are performed within transactions, and we focused on a flat transaction model.</p><p>It is often argued that, in practice, transactions might be mixed with non-transactional code <ref type="bibr" target="#b2">[3]</ref>, especially when coping with legacy components. A model where transactions would observe concurrent updates made by non-transactional code, and where changes made by live transactions would be visible to operations outside transactions is, clearly, imprecise. It is preferable to require that every non-transactional operation has the semantics of a single transaction. This preserves the illusion that transactions appear as if they were executed instantaneously and disallows race conditions between transactional and non-transactional code. We can encompass such a model in our context by encapsulating every nontransactional operation into a committed transaction. <ref type="foot" target="#foot_11">13</ref> Clearly, an actual transactional memory implementation may take advantage of the fact that such a transaction contains only a single operation and can thus be executed more efficiently (e.g., without logging changes).</p><p>The model within which we express the notion of opacity can also be extended to account for nested transactions (with either closed <ref type="bibr" target="#b20">[21]</ref> or open <ref type="bibr" target="#b21">[22]</ref> nesting semantics). Basically, we can treat events of each committed nested transaction as if they were executed directly by the parent transaction. Aborted and live nested transactions can be accounted for in a similar way as we deal with aborted and live (flat) transactions in the definition of opacity. The main difference here is that a nested transaction should observe the changes done by its parent transaction. We can capture this by always considering operations of a nested transaction together with all the preceding operations of its parent transaction.</p><p>Finally, it is also worthwhile noticing that opacity, by itself, does not say when transactions should commit. Our work is in this sense complementary to <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b26">27]</ref> which define progress properties and classify contention management strategies. It would be interesting to see which combinations with opacity are possible and at what cost.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure1. A history that satisfies global atomicity (with real-time ordering guarantees) and recoverability, but in which an aborted transaction (T2) accesses an inconsistent state of the system (x and y are simple variables/objects that implement read and write operations)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. An opaque history H5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>THEOREM 3 .</head><label>3</label><figDesc>Every progressive, single-version TM implementation that ensures opacity and uses invisible reads has the time complexity of Ω(k), where k = |Obj |.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>With invisible reads, no process knows about read operations issued by transactions executed by other processes. Several TM implementations optimize their performance with invisible reads, e.g. DSTM, ASTM, and TL2.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p><ref type="bibr" target="#b1">2</ref> For multi-version TM implementations, like LSA-STM or JVSTM, the complexity is not constant. However, it can be bounded by a function independent of k.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Note that this situation does not necessarily result in a "segmentation fault" signal that is usually easy to catch. Basically, the loop may overwrite memory locations of variables that belong to the application executing the loop but are outside control of the TM implementation.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Sandboxing would for instance be difficult to achieve for applications written in low-level languages (like C) and executed directly by an operating system.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Software TM implementations provide TM semantics to a user's application in systems that do not support memory transactions in hardware.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>We could alternatively let a transaction issue an abort event directly, but then it would be difficult to distinguish the case in which a transaction aborts itself voluntarily from the case in which the transaction is aborted by the TM implementation (e.g., upon an unresolvable conflict).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>We denote by e 1 , . . . , e k the sequence of events e 1 , . . . , e k .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>Note that a history includes only transactional events, i.e., the events described in the previous paragraphs of this section.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_8"><p>The problem of visible vs. invisible reads is similar to the "readers must write" issue in register implementations<ref type="bibr" target="#b16">[17]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_9"><p>The property resembles the concept of C-respecting in<ref type="bibr" target="#b26">[27]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_10"><p>For simplicity, we do not distinguish between read-only and update accesses here.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_11"><p>The ability to integrate transactional and non-transactional code would thus be expressed in our context in the form of a progress property stipulating that such single operation transactions are never forcefully aborted.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank Hagit Attiya, Pascal Felber, Christof Fetzer, Seth Gilbert, Tim Harris, Eshcar Hilel, and Nir Shavit for interesting discussions on the topic of this paper, as well as the anonymous reviewers for their helpful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A critique of ANSI SQL isolation levels</title>
		<author>
			<persName><forename type="first">H</forename><surname>Berenson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Melton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>O'neil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>O'neil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 ACM SIGMOD International Conference on Management of Data (SIGMOD&apos;95)</title>
		<meeting>the 1995 ACM SIGMOD International Conference on Management of Data (SIGMOD&apos;95)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Multiversion concurrency controltheory and algorithms</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="465" to="483" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Subtleties of transactional memory atomicity semantics</title>
		<author>
			<persName><forename type="first">C</forename><surname>Blundell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On rigorous transaction scheduling</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Breitbart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Georgakopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Silberschatz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="954" to="960" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Versioned boxes as the basis for memory transactions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cachopo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rito-Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Synchronization and Concurrency in Object-Oriented Languages (SCOOL); in conjunction with the ACM Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA&apos;05)</title>
		<meeting>the Workshop on Synchronization and Concurrency in Object-Oriented Languages (SCOOL); in conjunction with the ACM Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA&apos;05)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Transactional locking II</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Shalev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Symposium on Distributed Computing (DISC&apos;06)</title>
		<meeting>the 20th International Symposium on Distributed Computing (DISC&apos;06)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Software transactional memory should not be obstructionfree</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ennals</surname></persName>
		</author>
		<idno>IRC-TR-06-052</idno>
		<imprint>
			<date type="published" when="2006-01">Jan 2006</date>
		</imprint>
		<respStmt>
			<orgName>Intel Research Cambridge Tech</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Transaction Processing: Concepts and Techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Reuter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Toward a theory of transactional contention managers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pochon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Annual ACM Symposium on Principles of Distributed Computing (PODC&apos;05)</title>
		<meeting>the 24th Annual ACM Symposium on Principles of Distributed Computing (PODC&apos;05)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Opacity: A correctness condition for transactional memory</title>
		<author>
			<persName><forename type="first">R</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kapałka</surname></persName>
		</author>
		<idno>LPD-REPORT-2007- 004</idno>
		<ptr target="http://lpd.epfl.ch/kapalka/files/opacity-techreport07.pdf" />
	</analytic>
	<monogr>
		<title level="j">EPFL</title>
		<imprint>
			<date type="published" when="2007-05">May 2007</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A theory of reliability in database systems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hadzilacos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="121" to="145" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimizing memory transactions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Plesko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shinnar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tarditi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN 2006 Conference on Programming Language Design and Implementation (PLDI&apos;06)</title>
		<meeting>ACM SIGPLAN 2006 Conference on Programming Language Design and Implementation (PLDI&apos;06)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">SXM software transactional memory package for C#</title>
		<author>
			<persName><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<ptr target="http://www.cs.brown.edu/~mph" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Software transactional memory for dynamic-sized data structures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Luchangco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Scherer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22th Annual ACM Symposium on Principles of Distributed Computing (PODC&apos;03)</title>
		<meeting>the 22th Annual ACM Symposium on Principles of Distributed Computing (PODC&apos;03)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="92" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Transactional memory: Architectural support for lock-free data structures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Annual International Symposium on Computer Architecture</title>
		<meeting>the 20th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1993-05">May 1993</date>
			<biblScope unit="page" from="289" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Linearizability: a correctness condition for concurrent objects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="463" to="492" />
			<date type="published" when="1990-06">June 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On interprocess communication-part I: Basic formalism, part II</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms. Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="77" to="101" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Adaptive software transactional memory</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Maranthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Scherer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Symposium on Distributed Computing (DISC&apos;05)</title>
		<meeting>the 19th International Symposium on Distributed Computing (DISC&apos;05)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="354" to="368" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Lowering the overhead of software transactional memory</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Marathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Spear</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Heriot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Eisenstat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Scherer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT&apos;06)</title>
		<meeting>the 1st ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT&apos;06)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Nested transactions and reliable distributed computing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second IEEE Symposium on Reliability in Distributed Software and Database Systems</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="33" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Nested Transactions: An Approach to Reliable Distributed Computing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Open nested transactions: Semantics and support</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Poster presented at Workshop on Memory Performance Issues (WMPI&apos;06)</title>
		<imprint>
			<date type="published" when="2006-02">Feb. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Open nesting in software transactional memory</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Adl-Tabatabai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Hosking</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Hudson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shpeisman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2007 Symposium on Principles and Practice of Parallel Programming (PPoPP&apos;07)</title>
		<meeting>the ACM SIGPLAN 2007 Symposium on Principles and Practice of Parallel Programming (PPoPP&apos;07)</meeting>
		<imprint>
			<date type="published" when="2007-03">Mar. 2007</date>
			<biblScope unit="page" from="68" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The serializability of concurrent database updates</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="631" to="653" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A lazy snapshot algorithm with eager validation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Riegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Felber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fetzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Symposium on Distributed Computing (DISC&apos;06)</title>
		<meeting>the 20th International Symposium on Distributed Computing (DISC&apos;06)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Snapshot isolation for software transactional memory</title>
		<author>
			<persName><forename type="first">T</forename><surname>Riegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Felber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fetzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT&apos;06)</title>
		<meeting>the First ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT&apos;06)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Sequential specification of transactional memory semantics</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT&apos;06)</title>
		<meeting>the First ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT&apos;06)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Software transactional memory</title>
		<author>
			<persName><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Touitou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing (PODC&apos;95)</title>
		<meeting>the 14th Annual ACM Symposium on Principles of Distributed Computing (PODC&apos;95)</meeting>
		<imprint>
			<date type="published" when="1995-08">Aug 1995</date>
			<biblScope unit="page" from="204" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Conflict detection and validation strategies for software transactional memory</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Spear</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Marathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Scherer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Symposium on Distributed Computing (DISC&apos;06)</title>
		<meeting>the 20th International Symposium on Distributed Computing (DISC&apos;06)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Local atomicity properties: Modular concurrency control for abstract data types</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Weihl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="249" to="282" />
			<date type="published" when="1989-04">April 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Parallel and Distributed Computing Handbook</title>
		<editor>A. Y. Zomaya</editor>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>McGraw-Hill</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
