<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Cloud-Based Approximate Constrained Shortest Distance Queries over Encrypted Graphs with Privacy Protection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Meng</forename><surname>Shen</surname></persName>
							<email>shenmeng@bit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Baoli</forename><surname>Ma</surname></persName>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Liehuang</forename><surname>Zhu</surname></persName>
							<email>liehuangz@bit.edu</email>
						</author>
						<author>
							<persName><roleName>Member, IEEE, Xiaojiang Du, Senior Member, IEEE</roleName><forename type="first">Rashid</forename><surname>Mijumbi</surname></persName>
							<email>rashid.mijumbi@nokia.com</email>
						</author>
						<author>
							<persName><roleName>Senior Member, IEEE</roleName><forename type="first">Jiankun</forename><surname>Hu</surname></persName>
							<email>j.hu@adfa.edu.au.</email>
						</author>
						<author>
							<persName><roleName>Prof</roleName><surname>Liehuang Zhu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">X</forename><surname>Du</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">are with Beijing Engineering Research Center of High Volume Language Information Processing and Cloud Computing Applications</orgName>
								<orgName type="department" key="dep2">School of Computer Science</orgName>
								<orgName type="institution">Beijing Institute of Technology</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Bell Labs CTO</orgName>
								<address>
									<settlement>Nokia, Dublin</settlement>
									<country key="IE">Ireland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer and Information Sciences</orgName>
								<orgName type="institution">Temple University</orgName>
								<address>
									<settlement>Philadelphia</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">School of Engineering and IT</orgName>
								<orgName type="institution">University of New South Wales (UNSW)</orgName>
								<address>
									<settlement>Canberra</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Transactions on Information Forensics and Security</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Cloud-Based Approximate Constrained Shortest Distance Queries over Encrypted Graphs with Privacy Protection</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B28E718CABD8C1598FCFBE5274D6E11C</idno>
					<idno type="DOI">10.1109/TIFS.2017.2774451</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2017.2774451, IEEE Transactions on Information Forensics and Security 1</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Cloud Computing</term>
					<term>Privacy</term>
					<term>Graph Encryption</term>
					<term>Constrained Shortest Distance Querying</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Constrained shortest distance (CSD) querying is one of the fundamental graph query primitives, which finds the shortest distance from an origin to a destination in a graph with a constraint that the total cost does not exceed a given threshold. CSD querying has a wide range of applications, such as routing in telecommunications and transportation. With an increasing prevalence of cloud computing paradigm, graph owners desire to outsource their graphs to cloud servers. In order to protect sensitive information, these graphs are usually encrypted before being outsourced to the cloud. This, however, imposes a great challenge to CSD querying over encrypted graphs. Since performing constraint filtering is an intractable task, existing work mainly focuses on unconstrained shortest distance queries. CSD querying over encrypted graphs remains an open research problem.</p><p>In this paper, we propose Connor, a novel graph encryption scheme that enables approximate CSD querying. Connor is built based on an efficient, tree-based ciphertext comparison protocol, and makes use of symmetric-key primitives and the somewhat homomorphic encryption, making it computationally efficient. Using Connor, a graph owner can first encrypt privacy-sensitive graphs and then outsource them to the cloud server, achieving the necessary privacy without losing the ability of querying. Extensive experiments with real-world datasets demonstrate the effectiveness and efficiency of the proposed graph encryption scheme.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="bibr" target="#b5">[6]</ref><p>, Pregel <ref type="bibr" target="#b6">[7]</ref> and TurboGraph <ref type="bibr" target="#b7">[8]</ref>) and industry (e.g., Titan, DEX and GraphBase). With the prevalence of cloud computing, graph owners (e.g., enterprises and startups for graphbased services) desire to outsource their graph databases to a cloud server, which raises a great concern regarding privacy. An intuitive way to enhance data privacy is encrypting graphs before outsourcing them to the cloud. This, however, usually comes at the price of inefficiency, because it is quite difficult to perform operations over encrypted graphs.</p><p>Shortest distance querying is one of the most fundamental graph operations, which finds the shortest distance, according to a specific criterion, for a given pair of source and destination in a graph. In practice, however, users may consider multiple criteria when performing shortest distance queries <ref type="bibr" target="#b1">[2]</ref>. Taking the road network as an example, a user may want to know the shortest distance, in terms of travelling time, between two cities within a budget for total toll payment. This problem can be represented by a constrained shortest distance (CSD) query, which finds the shortest distance based on one criterion with one or more constraints on other criteria.</p><p>In this paper, we focus on single-constraint CSD queries. This is because most practical problems can be represented as a single-constraint CSD query. For instance, such a query on a communication network could return the minimum cost from a starting node to a terminus node, with a threshold on routing delay. In addition, multi-constraint CSD queries can usually be decomposed into a group of sub-queries, each of which can be abstracted as a single-constraint CSD query. Formally, a CSD query <ref type="foot" target="#foot_0">1</ref> is such that: given an origin s, a destination t, and a cost constraint θ, finding the shortest distance between s and t whose total cost c does not exceed θ.</p><p>Existing studies in this area can be roughly classified into two categories. The first category mainly focuses on the CSD query problem over unencrypted graphs <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref>. However, these methods cannot be easily applied in the encrypted graph environment, because many operations on plain graphs required in these methods (e.g., addition, multiplication, and comparison) cannot be carried out successfully without a special design for encrypted graphs. The second category aims at enabling the shortest distance (or shortest path) queries over encrypted graphs <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b12">13]</ref>. They usually adopt distance oracles such that the approximate distance between any two vertices can be efficiently computed, e.g., in a sublinear way. The main limitation of these approaches is that they are incapable of performing constraint filtering over the cloud-based encrypted graphs. Therefore, they cannot be directly applied to answering CSD queries.</p><p>Motivated by the limitations of existing schemes, our goal in this paper is to design a practical graph encryption scheme that enables CSD queries over encrypted graphs. As the CSD problem over plain graphs has been proved to be NP-hard <ref type="bibr" target="#b9">[10]</ref>, existing studies (e.g., <ref type="bibr" target="#b1">[2]</ref>) usually resort to approximate solutions, which guarantee that the resulting distance is no longer than α times of the shortest distance (where α is an approximation ratio predefined by graph owners), subject to the cost constraint θ. The encryption of graphs would make the CSD problem even more complicated. Hence, we also focus on devising an approximate solution.</p><p>Specifically, this paper presents Connor, a novel graph encryption scheme targeting the approximate CSD querying over encrypted graphs. Connor is built on a secure 2-hop cover labeling index (2HCLI), which is a type of distance oracle such that the approximate distance between any two vertices in a graph can be efficiently computed <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>. The vertices of the graph in the secure 2HCLI are encrypted by particular pseudo-random functions (PRFs). In order to protect real values of graph attributes while allowing for cost filtering, we encrypt costs and distances (between pairs of vertices) by the order-revealing encryption (ORE) <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref> and the somewhat homomorphic encryption (SWHE) <ref type="bibr" target="#b15">[16]</ref>, respectively. Based on the ORE, we design a simple but efficient tree-based ciphertexts comparison protocol, which can accelerate the constraint filtering process on the cloud side.</p><p>The main contributions of this paper are as follows.</p><p>1) We propose a novel graph encryption scheme, Connor, which enables the approximate CSD querying. It can answer an α-CSD query in milliseconds and thereby achieves computational efficiency. 2) We design a tree-based ciphertexts comparison protocol, which helps us to determine the relationship of the sum of two integers and another integer over their ciphertexts with controlled disclosure. This protocol can also serve as a building block in other relevant application scenarios. 3) We present a thorough security analysis of Connor and demonstrate that it achieves the latest security definition named CQA2-security <ref type="bibr" target="#b16">[17]</ref>. We also implement a prototype and conduct extensive experiments on real-world datasets. The evaluation results show the effectiveness and efficiency of the proposed scheme.</p><p>To the best of our knowledge, this is the first work that enables the approximate CSD querying over encrypted graphs.</p><p>The rest of this paper is organized as follows. We summarize the related work in Section II and describe the background of the approximate CSD querying in Section III. We formally define the privacy-preserving approximate CSD querying problem in Section IV. After that, the construction of Connor is presented in Section V, with a detailed description of the tree-based ciphertexts comparison protocol in Section VI. We exhibit the complexity and security analyses in Section VII, evaluate the proposed scheme through extensive experiments in Section VIII, and conclude this paper in Section IX.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>In an era of cloud computing, security and privacy become great concerns of cloud service users <ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref>. Here we briefly summarize the related work from two aspects, i.e., CSD querying over plain graphs and graph privacy protection.</p><p>Plain CSD queries. The constrained shortest distance/path querying over plain graphs has attracted many research attentions. Hansen <ref type="bibr" target="#b8">[9]</ref> proposed an augmented Dijkstra's algorithm for exact constrained shortest path queries without an index. This method, however, resulted in a significant computational burden. In order to improve the querying efficiency, another solution <ref type="bibr" target="#b10">[11]</ref> focused on approximate constrained shortest path queries, which were also index-free.</p><p>The state-of-the-art solution to the exact constrained shortest path querying with an index was proposed by Storandt <ref type="bibr" target="#b11">[12]</ref>, which accelerated query procedure with an indexing technique called contraction hierarchies. This approach still results in impractically high query processing cost. Wang et al. <ref type="bibr" target="#b1">[2]</ref> proposed a solution to the approximate constrained shortest path querying over large-scale road networks. This method took full advantage of overlay graph techniques to construct an overlay graph based on the original graph, whose size was much smaller than that of the original one. Consequently, they built a constrained labeling index structure over the overlay graph, which greatly reduced the query cost. Unfortunately, all these solutions are merely suitable to perform queries over unencrypted graphs.</p><p>Graph privacy protection. Increasing concerns about graph privacy have been raised with the wide adoption of the cloud computing paradigm over the past decade. Chase and Kamara <ref type="bibr" target="#b16">[17]</ref> first introduced the notion of graph encryption, where they proposed several constructions for graph operations, such as adjacency queries and neighboring queries. Cao et al. <ref type="bibr" target="#b23">[24]</ref> defined and solved the problem of privacypreserving query over encrypted graph data in cloud computing by utilizing the principle of "filtering-and-verification". They built the feature-based index of a graph in advance and then chose the efficient inner product to carry out the filtering procedure. Some approaches <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b25">26]</ref> utilized the differential privacy technique to query graphs privately, which might suffer from weak security. These studies, however, introduced prohibitively great storage costs and were not practical for large-scale graphs. Meng et al. <ref type="bibr" target="#b0">[1]</ref> proposed three computationally efficient constructions that supported the approximate shortest distance querying with distance oracles, which were provably secure against a semi-honest cloud server.</p><p>Secure multi-party computation (SMC) techniques have been widely applied to address the privacy-preserving shortest path problem <ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref><ref type="bibr" target="#b28">[29]</ref><ref type="bibr" target="#b29">[30]</ref>, as well as other secure computation problems <ref type="bibr" target="#b30">[31]</ref>. Aly et al. <ref type="bibr" target="#b27">[28]</ref> focused on the shortest path problem over traditional combinatorial graph in a general multi-party computation setting, and proposed two protocols for securely computing shortest paths in the graphs. Blanton  Maximum distance over all the sketches et al. <ref type="bibr" target="#b26">[27]</ref> designed data-oblivious algorithms to securely solve the single-source single-destination shortest path problem, which achieved the optimal or near-optimal performance on dense graphs. Keller and Scholl <ref type="bibr" target="#b28">[29]</ref> designed several oblivious data structures (e.g., priority queues) for SMC and utilized them to compute shortest paths on general graphs. Gupta et al. <ref type="bibr" target="#b29">[30]</ref> proposed an SMC-based approach for finding policy-compliant paths that have the least routing cost or satisfy bandwidth demands among different network domains. However, existing general-purpose SMC solutions for the shortest path problem may result in heavy communication overhead.</p><p>Although there are respectable studies on graph querying over encrypted graphs, the privacy-preserving CSD query remains unsolved. In this paper, we propose a novel and efficient graph encryption scheme for CSD queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. BACKGROUND</head><p>This section presents the formal definition of the CSD query problem and introduces the 2HCLI structure for graph queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Approximate CSD Query</head><p>Let G = (V, E) be a directed graph 2 with a vertex set V and an edge set E. Each edge e ∈ E is associated with a distance d(e) ≥ 0 and a cost c(e) ≥ 0. We regard the cost c(e) as the constraint. We denote the set of edges that connect two vertices as a path. For a path P = (e 1 , e 2 , . . . , e k ), its distance d(P ) is defined as d(P ) = k i=1 d(e i ), which indicates the distance from its origin to its destination. Similarly, we define the cost of P as c(P ) = k i=1 c(e i ). The notations throughout the paper are summarized in Table <ref type="table" target="#tab_0">I</ref>. 2 We refer to G as a directed graph in this paper, unless otherwise specified. Given a graph G, an origin vertex s ∈ V , a destination vertex t ∈ V , and a cost constraint θ, a CSD query is to find the the shortest distance d between s and t with the total cost no more than θ. Since the CSD query problem has been proved to be NP-hard <ref type="bibr" target="#b9">[10]</ref>, we keep in line with existing solutions <ref type="bibr" target="#b1">[2]</ref> and focus on proposing an approximate CSD solution in this paper.</p><p>Inspired by a common definition of the approximate shortest path query over plain graphs <ref type="bibr" target="#b1">[2]</ref>, we define the approximate CSD query (i.e., α-CSD query) as follows.</p><p>Definition 1. (α-CSD QUERY). Given an origin s, a destination t, a cost constraint θ and an approximation ratio α, an α-CSD query returns the distance d(P ) of a path P , such that c(P ) ≤ θ and d(P ) ≤ α • d opt , where d opt is the optimal answer to the exact CSD query with the origin s, destination t and cost constraint θ.</p><p>Fig. <ref type="figure" target="#fig_1">1</ref> shows a simple graph with five vertices, where the distance and cost of each edge are marked alongside it. Given an origin a, a destination c, a cost constraint θ = 4, the exact CSD query returns the optimal distance d opt = 6, where the corresponding path is (a, b, c). For an approximation ratio α = 1.5, a valid answer to the α-CSD query with the same parameters (e.g, the origin a, the destination c, and θ = 4) is 8, with the corresponding path P α = (a, e, b, c). That is because d(P α ) = 8 &lt; α • d opt = 9 and c(P α ) = 3 &lt; θ.</p><p>Based on the above definition, given two paths P 1 and P 2 with the same origin and destination, we say that P 1 αdominates P 2 iff c(P 1 ) ≤ c(P 2 ) and d(P 1 ) ≤ α • d(P 2 ). With this principle, we can reduce the construction complexity of graph index significantly, because a great deal of redundant entries in the index can be filtered out. We will make a further illustration in the following subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Constructing Labeling Index</head><p>The encrypted index designed in this paper is mainly constructed based on the well-known 2HCLI, which is a special data structure that supports the shortest distance query efficiently <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b32">33]</ref>. Here we briefly describe the basic idea of the 2HCLI, and illustrate its application in building a constrained labeling index.</p><p>Given a graph G = (V, E) with a vertex set V and an edge set E, each vertex v ∈ V is associated with an in-label set and an out-label set, which are denoted by ∆ in (v) and ∆ out (v), respectively. Each entity in ∆ in (v) corresponds to the shortest distance from a vertex u ∈ V to v. It implies that v is reachable from u by one or more paths, but is not necessarily  a neighbor, or 2-hop neighbour, of u. Similarly, each entity in ∆ out (v) corresponds to the shortest distance from v to another vertex u in V . To answer a shortest distance query from an origin s to a destination t, we first find the common vertices in the labels ∆ out (s) and ∆ in (t), and then select the shortest distance from s to t. Note that the entities in ∆ in (v) and ∆ out (v) are carefully selected <ref type="bibr" target="#b32">[33]</ref> so that the distance of any two vertices s and t can be computed by ∆ out (s) and ∆ in (t).</p><p>Considering the graph in Fig. <ref type="figure" target="#fig_1">1</ref>, if we ignore the cost criterion of edges, the basic unconstrained shortest distance query with an origin a and a destination c can be answered with the help of the 2HCLI, as shown in Fig. <ref type="figure" target="#fig_2">2</ref> Although it is simple and straightforward to construct the 2HCLI for a graph with only the distance criterion, constructing a labeling index based on the 2HCLI for the CSD query is much more complex. That is because in the CSD query setting with two types of edge criteria, there might be multiple combinations of distance and cost for each pair of vertices in the labels ∆ in (v) and ∆ out (v). For ease of illustration, we also take as an example the graph, as well as the CSD query, in Fig. <ref type="figure" target="#fig_1">1</ref>. The corresponding 2HCLI is shown in Fig. <ref type="figure" target="#fig_3">3</ref>, where the 2-tuple alongside each arrow represents the distance and cost from the starting vertex to the ending vertex. Note that in the shortest distance query in Fig. <ref type="figure" target="#fig_2">2</ref>, the shortest distance from a to c via e is unique. However, in the CSD query setting depicted in Fig. <ref type="figure" target="#fig_3">3</ref>, there are four possible distances with different costs from a to c via e. Due to the existence of the cost criterion, the number of possible distances for each pair of vertices could increase dramatically in large-scale graphs, which results in a higher complexity in constructing the 2HCLI and calculating the answers to a CSD query.  <ref type="figure">(u,</ref><ref type="figure">d,</ref><ref type="figure">c</ref>) in the 2HCLI indicates the vertex identifier, distance and cost, respectively. The answer to the approximate CSD query (i.e., the origin a, the destination c, α = 1.5, and θ = 4) is 6, which happens to be the answer to the exact CSD query.</p><p>In order to improve the querying efficiency, we adopt a methodology that combines an offline filtering operation and an online filtering operation.</p><p>The offline filtering aims at reducing the construction complexity of the 2HCLI and decreasing the number of entries in the in-label and out-label sets as many as possible. We adopt the method proposed in <ref type="bibr" target="#b1">[2]</ref>. The entities in the 2HCLI are carefully selected in such a way that for any CSD query from u to v with a cost constraint θ, the query can be answered correctly using only the 2HCLI. Since the construction of the 2HCLI should be independent of the cost constraint in specific CSD queries, we can use the definition of α-domination to filter out redundant entries in the in-and out-label sets.</p><p>Taking for example the two entries from e to c with α = 1.5 in Fig. <ref type="figure" target="#fig_3">3</ref>, the path P 1 ec = (e, b, c) with the (dis, cost)tuple of (3,2) α-dominates another path P 2 ec = (e, c) with the (dis, cost)-tuple of <ref type="bibr" target="#b1">(2,</ref><ref type="bibr" target="#b5">6)</ref>. Therefore, the entry corresponding to the path P 2 ec can be filtered out (as depicted by a dashed arrow), which helps to reduce the number of entries in ∆ in (c). The resulting 2HCLI is exhibited in Fig. <ref type="figure" target="#fig_5">4</ref>. We refer the reader to <ref type="bibr" target="#b1">[2]</ref> for more construction details.</p><p>The online filtering aims at selecting the possibly valid answers to a given CSD query, based on only the 2HCLI. For instance, given an α-CSD query from a to c with a cost constraint θ = 4, we can first find the common vertex set V between ∆ out (a) and ∆ in (c), and then return the minimum d(a, v) + d(v, c) with c(a, v) + c(v, c) ≤ θ for each v ∈ V . Since the above comparisons should be conducted with the corresponding ciphertexts, an efficient online filtering approach will be devised in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. PROBLEM FORMULATION</head><p>This section presents the system model and the security model of the privacy-preserving α-CSD querying, as well as the preliminaries of the proposed graph encryption scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. System Model</head><p>We adopt the general system model in the literature <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b16">17]</ref> for the privacy-preserving α-CSD querying, as illustrated in Fig. <ref type="figure" target="#fig_6">5</ref>, which mainly involves two types of entities, namely a user and a cloud server.</p><p>The user constructs the secure searchable index for the graph and outsources the encrypted index along with the encrypted graph to the cloud server. When the user, say Alice, performs an α-CSD query over her encrypted graph, she first generates a query token and then submits it to the cloud server. Upon receiving Alice's query token, the cloud server executes the pre-designed query algorithms to match entries in the secure index with the token. Finally, the cloud server replies the user with the answer to the α-CSD query.</p><p>The graph encryption scheme is formally defined as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2. (GRAPH ENCRYPTION).</head><p>A graph encryption scheme Π = (KeyGen, Setup, Query) consists of three polynomial-time algorithms that work as follows:</p><p>• (K, pk, sk) ← KeyGen(λ): is a probabilistic secret key generation algorithm that takes as input a security parameter λ and outputs a secret key K and a public/secret-key pair (pk, sk). • ∆ ← Setup(α, K, pk, sk, φ, G): is a graph encryption algorithm that takes as input an approximation ratio α, a secret keys K, a key pair (pk, sk), an amplification factor φ and a graph G, and outputs a secure index ∆. • (dist q , ⊥) ← Query((K, pk, sk, Φ, q), ∆): is a twoparty protocol between a user that holds a secret key K, a key pair (pk, sk) and a query q, and a cloud server that holds an encrypted graph index ∆. After executing this protocol, the user receives the distance dist q as the query result and the cloud server receives a terminator ⊥.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Security Model</head><p>Graph encryption is a generalization of symmetric searchable encryption (SSE) <ref type="bibr" target="#b33">[34]</ref><ref type="bibr" target="#b34">[35]</ref><ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref>. Thus, we adopt the security definition of SSE settings in our graph encryption scheme. This security definition is consistent with the latest proposed security definition in <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b38">39]</ref>, which is also known as CQA2-security (i.e., the chosen-query attack security). Now we present the formal CQA2-security definition as follows.</p><p>Definition 3. (CQA2-security model). Let Π = (KeyGen, Setup, Query) be a graph encryption scheme and consider the following probabilistic experiments where A is a semi-honest adversary, S is a simulator, and L Setup and L Query are (stateful) leakage functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Real Π,A (λ):</head><p>• A outputs a graph G, an approximation ratio α and an amplification factor φ. • The challenger begins by running Gen(1 λ ) to generate a secret key K and a public/secret-key pair (pk, sk), and then computes the encrypted index ∆ by Setup(α, K, pk, sk, φ, G). The challenger sends the encrypted index ∆ to A.</p><p>• A makes a polynomial number of adaptive queries, and for each query q, A and the challenger execute Query((K, pk, sk, Φ, q), ∆). • A computes a bit b ∈ {0, 1} as the output of the experiment. Ideal Π,A,S (λ):</p><p>• A outputs a graph G, an approximation ratio α and an amplification factor φ. • Given the leakage function L Setup (G), S simulates a secure graph index ∆ * and sends it to A. • A makes a polynomial number of adaptive queries.</p><p>For each query q, S is given the leakage function L Query (G, Q), and A and S execute a simulation of Query, where A is playing the role of the cloud server and S is playing the role of the user. • A computes a bit b ∈ {0, 1} as the output of the experiment.</p><p>We say that the graph encryption scheme Π = (KeyGen, Setup, Query) is (L Setup , L Query )-secure against the adaptive chosen-query attack, if for all PPT adversaries A, there exists a PPT simulator S such that</p><formula xml:id="formula_0">|Pr[Real Π,A (λ) = 1] -Pr[Ideal Π,A,S (λ) = 1]| ≤ negl(λ),</formula><p>where negl(λ) is a negligible function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Preliminaries</head><p>Now we briefly introduce an encryption technique employed in our design, i.e., the order-revealing encryption.</p><p>Order-revealing encryption (ORE) is a generalization of the order-preserving encryption (OPE) scheme, but provides stronger security guarantees. As pointed by Naveed et al. <ref type="bibr" target="#b39">[40]</ref>, the OPE-encrypted databases are extremely vulnerable to inference attacks. To address this limitation, the ORE scheme has been proposed <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>, which is a tuple of three algorithms Π = (ORE.Setup, ORE.Encrypt, ORE.Compare) described as follows:</p><p>• ORE.Setup(1 λ )→ sk: Input a security parameter λ, output the secret key sk. • ORE.Encrypt(sk, m)→ ct: Input a secret key sk and a message m, output a ciphertext ct.</p><formula xml:id="formula_1">• ORE.Compare(ct 1 , ct 2 )→ z: Input two ciphertexts ct 1</formula><p>and ct 2 , output a bit r ∈ {0, 1}, which indicates the greater-than or less-than relationship of the corresponding plaintexts m 1 and m 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONSTRUCTION OF CO N N O R</head><p>In this section, we introduce our graph encryption scheme Connor for the privacy-preserving α-CSD querying.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Construction Overview</head><p>The construction process is based on two particular pseudorandom functions h and g, and a somewhat homomorphic encryption (SWHE) scheme. In this paper, we adopt the concrete instantiation of a SWHE scheme in the literature <ref type="bibr" target="#b15">[16]</ref>. The parameters of h and g are illustrated in Equation (1),</p><formula xml:id="formula_2">h : {0, 1} λ × {0, 1} * → {0, 1} λ (1a) g : {0, 1} λ × {0, 1} * → {0, 1} λ+z+k (1b)</formula><p>where λ is the security parameter, and k and z are the output lengths of the ORE and SWHE encryptions, respectively. We start with a straightforward construction GraphEnc 1 = (KeyGen, Setup, Query) as follows, including:</p><p>• KeyGen: Given the security parameter λ, the user randomly generates a secret key K and a pair of public and secret keys (pk, sk) for SWHE. • Setup: Given an original graph G, an approximation ratio α, and an amplification factor φ, the user obtains the encrypted graph index by using Algorithm 1. The 2HCLI ∆ = {∆ out , ∆ in } of G can be generated by the method described in Section III-B. Let B be the maximum distance over all the sketches and N = 2B+1. Motivated by the literature <ref type="bibr" target="#b0">[1]</ref>, each distance d u,v is encrypted as 2 N -du,v by the SWHE to protect its real value (line 8). Considering that 2 x + 2 y is bounded by 2 max(x,y)-1 , the SWHE encryption of distance allows for obtaining the minimum sum over a certain number of distance pairs. Each cost c u,v , multiplied by the amplification factor φ, is encrypted by the ORE encryption (line 9). φ is a big integer and should be carefully selected to enlarge the plaintext space of c u,v . In practice, the product of φ and the maximum cost value over all the sketches should be sufficiently large (e.g., at least 2 80 ), which is used to provide a sufficient randomness to the inputs. Since φ is kept private by the user, the cloud server cannot learn the real values of c u,v . • Query: To perform an α-CSD query with an origin s, a destination t, and a cost constraint θ, the user generates query tokens τ s = h(K, s||1) and τ t = h(K, t||2), and sends them to the cloud server. </p><formula xml:id="formula_3">i = SWHE.Eval(×, D i s,v , D i v,t ) for each pair (D i s,v , D i v,t ) in Y .</formula><p>The correctness of the above calculation follows homomorphic properties of SWHE. We refer the readers to <ref type="bibr" target="#b0">[1]</ref> for more details. Finally, the cloud server returns d to the user, who, in turn, obtains the answer to the α-CSD query by decrypting d with its secret key sk.</p><p>Note that this straightforward approach does not only correctly answer the α-CSD query over encrypted graphs, but also protects the vertex identifier, distance, and cost information. Set Tout,u = h(K, u||1), T in,u = h(K, u||2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>for each (v, du,v, cu,v) ∈ ∆out(u) do 7:</p><p>Compute V = h(K, v||0).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8:</head><p>Compute Du,v = SWHE.Enc(pk, 2 N -du,v ). 9:</p><p>Compute Cu,v = ORE.Enc(K, φcu,v). 10:</p><p>Insert (V, Du,v, Cu,v) into the dictionary Iout[Tout,u].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11:</head><p>end for 12:</p><p>Repeat the above procedure for each sketch in ∆ in (u) and add entries into I in [T in,u ]. 13: end for 14: return ∆ = {Iout, I in } as the encrypted graph index.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Setup algorithm for GraphEnc 2</head><p>Input: A secret key K, a key pair (pk, sk), an approximation ratio α, an amplification factor φ, and an original graph G. Output: The encrypted graph index ∆.</p><p>1: Generate the 2HCLI ∆ = {∆out, ∆ in } of G.</p><p>2: Initialize two dictionary Iout and I in .</p><p>3: Let B be the maximum distance over the sketches and set N = 2B + 1. 4: for each u ∈ G do 5: Set Sout,u = h(K, u||1), Tout,u = h(K, u||2), S in,u = h(K, u||3), and T in,u = h(K, u||4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>Initialize a counter ω = 0 7:</p><p>for each (v, du,v, cu,v) ∈ ∆out(u) do 8:</p><p>Compute V = h(K, v||0). 9:</p><p>Compute Du,v = SWHE.Enc(pk, 2 N -du,v ). 10:</p><p>Compute Cu,v = ORE.Enc(K, φcu,v).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11:</head><p>Set Tout,u,v = h(Tout,u, ω) and Sout,u,v = g(Sout,u, ω). 12:</p><p>Compute Ψu,v = Sout,u,v ⊕ (V ||Du,v||Cu,v).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13:</head><p>Set Iout[Tout,u,v] = Ψu,v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>14:</head><p>Set ω = ω + 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>15:</head><p>end for 16:</p><p>Repeat the above procedure for each sketch in ∆ in (u) and obtain I in [T in,u,v ], except that: (i) set T in,u,v = h(T in,u , ω) and S in,u,v = g(S in,u , ω), and (ii) compute Ψu,v = S in,u,v ⊕ (V ||Du,v||Cu,v). 17: end for 18: return ∆ = {Iout, I in } as the encrypted graph index.</p><p>However, the encrypted graph index obtained from Algorithm 1, without performing any queries, still results in information leakage. On one hand, it reveals the length of each encrypted sketch, i.e., I out [u] and I in [u], as well as the order information of ORE-encrypted costs in all sketches. On the other hand, it also discloses the number of common vertices between I out [u] and I in <ref type="bibr">[v]</ref>, which indicates the number of vertices that connect u to v. In particular, if the cloud server knows that there is no common vertex between I out [u] and I in <ref type="bibr">[v]</ref>, it learns that u cannot reach v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Privacy-preserving α-CSD Querying</head><p>In order to enhance protection of sensitive information, we construct a privacy-preserving α-CSD querying scheme GraphEnc 2 = (KeyGen, Setup, Query), where the key generation procedure is the same as in GraphEnc 1 , with improved index construction and CSD query procedures as exhibited in Algorithms 2 and 3, respectively.</p><p>The Setup for GraphEnc 2 works as follows. The user first builds the 2HCLI ∆ of graph G, and then encrypts Algorithm 3 Query algorithm for GraphEnc 2 Input: The user's input are the secret key K, secret key pair (pk, sk), an amplification factor Φ, and the query q = (s, t, θ). The cloud server's input is the encrypted index ∆. Output: user's output is distq and cloud server's output is ⊥.</p><p>1: user generates Sout,s = h(K, s||1), Tout,s = h(K, s||2), S in,t = h(K, t||3) and T in,t = h(K, t||4). 2: user constructs a cost constraint tree T θ based on φ * θ using secret K as described in Section VI. 3: user sends τs,t = (Sout,s, Tout,s, S in,t , T in,t , T θ ) to cloud server. 4: cloud server parses τs,t as (Sout,s, Tout,s, S in,t , T in,t , T θ ). 5: cloud server initializes a set Ls and a counter ω = 0. 6: cloud server computes Tout,s,v = h(Tout,s, ω). 7: while Iout[Tout,s,v] = ⊥ do 8:</p><p>cloud server computes Sout,s,v = g(Sout,s, ω). 9:</p><p>cloud server performs (V ||Ds,v||Cs,v) = Ψs,v ⊕ Sout,s,v. 10:</p><p>cloud server add (V, Ds,v, Cs,v) into Ls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11:</head><p>Set ω = ω + 1. 12:</p><p>cloud server computes Tout,s,v = h(Tout,s, ω). sketches associated with u ∈ G (i.e., ∆ out (u) and ∆ in (u)), as described in lines 2-17.</p><p>Note that in order to prevent the leakage of the sketch size in the previous straightforward approach, we split each encrypted sketch I out (u) and I in (u), and ensure that they are stored in the dictionary separately, with a size of one. More precisely, we utilize a counter ω and generate the unique T out,u,v and S out,u,v for each entity in ∆ out (u) (line 11). Similarly, the unique T in,u,v and S in,u,v for each entity in ∆ in (u) can be generated (line 16). The T out,u,v (or T in,u,v ) indicates the position that this entity will be stored in I out (or I in ), which ensures each position in the dictionary I out (or I in ) having only one entity.</p><p>S out,u,v (or S in,u,v ) is used to make an XOR operation with (V ||D u,v ||C u,v ). Since S out,u,v (or S in,u,v ) is different for each sketch, the XOR operation makes the resulting Ψ u,v indistinguishable, which guarantees that the static encrypted graph index ∆ reveals neither the number of common vertices between I out (u) and I in (v), nor the order information of costs.</p><p>The Query in Algorithm 3 works as follows. Assume that the user asks for the shortest distance between s and t, whose total cost does not exceed θ. She first generates the query token τ s,t and sends it to the cloud server (lines 1-3). Upon receiving the token τ s,t , the cloud server searches in the index and obtains L s and L t (lines 5-22). That is, the cloud server iteratively judges whether the dictionary I out (I in ) contains the key T out,s,v (T in,v,t ) or not. If it exists, then it adds the corresponding entity into the set L s (L t ).</p><p>Once L s and L t are obtained, the cloud server performs the cost constraint filtering (line 23) and computes d (line 24), which are the same as described in the straightforward approach. Finally, the user gets the final answer by decrypting d, which is returned by the cloud server, using its sk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. TREE-BASED CIPHERTEXTS COMPARISON APPROACH</head><p>This section introduces a tree-based ciphertexts comparison approach, which is used for cost constraint filtering in the graph encryption scheme described in Section V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Scenarios</head><p>Assume that there is a user (i.e., U) and a server (i.e., R). U has many integers which are encrypted by a kind of cryptography algorithm and then outsourced to Now, U wants to ask for R to obtain integer pairs, e.g., (x, y), whose sum does not exceed θ. Note that the plaintexts of x, y and θ could not be disclosed to R, except for the greaterthan, equality, or less-than relationship. A naive approach is to download all the integers, calculate the summation locally, and choose the integer pairs satisfying the constraint. This method, however, is meaningless if one wants to offload the computation to the cloud. Hence, it is desirable to have a practical solution to this problem.</p><p>Note that this scenario is different from the well-known SMC scheme. In the setting of SMC <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b41">42]</ref>, a set of (two or more) parties with private inputs wish to compute a function of their inputs while revealing nothing but the result of the function, which is used for many practical applications, such as exchange markets. SMC is a collaborative computing problem that solves the privacy preserving problem among a group of mutually untrusted participants. The ciphertexts of all pairs of (x, y) and the cost constraint θ are outsourced to the cloud server, which is responsible for the inequality tests. Furthermore, we could reveal the relationship between the sum of two ciphertexts and another ciphertext to the server, which is referred to as controlled disclosure in the literature <ref type="bibr" target="#b16">[17]</ref>.</p><p>It seems that we might leverage the homomorphic encryption technique, since it supports a sum operation of calculating x + y. Nevertheless, as the homomorphic encryption is probabilistic, we are unable to determine the relationship between x + y and θ over their ciphertexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Main Idea</head><p>The main idea of the tree-based ciphertexts comparison protocol is to encode an integer with the ORE primitive. To the best of our knowledge, none of the existing approaches can support ORE and homomorphism properties simultaneously. Hence, we design a novel method to address this problem, which is motivated by the following facts.</p><p>If we want to compare x+y with θ, we can compare x with θ/2 and y with θ/2, respectively. Now, we result in 4 possible cases corresponding to combinations of the two relationships. If x &gt; θ/2 (x ≤ θ/2) and y &gt; θ/2 (y ≤ θ/2), we can know By iteratively performing such an operation, we can determine the relationship between x + y and θ with an increasing probability. Due to the ORE property, it is easy to perform the above operations over ciphertexts. Next, we will show how to implement this idea efficiently by utilizing a tree structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Details of Protocol</head><p>To implement the comparison of x + y and θ over their ciphertexts, we construct a cost constraint tree, whose nodes represent specific values that are related to θ. For clarity, we define E(m) as the ORE ciphertext of m.</p><p>An example of the tree structure is depicted in Fig. <ref type="figure" target="#fig_8">6</ref>. For each node, we assign 0 to its left child path, while 1 to the right child path. If an integer is not greater than the value of this node, we take the left child path for further comparison; otherwise, we take the right child path. Thus, for any path from the root node to a leaf node, we can obtain a path code, which is an effective representation of the comparison procedure. For instance, an incoming integer 5θ/16 would traverse Nodes E(θ/2), E(θ/4), and E(3θ/8), and thereby end with a path code of 010. We define the length (i.e., the number of bits) of a path code as β. Note that β is actually equal to the depth of the tree which is denoted by d θ .</p><p>Now the relationship between x+y and θ can be determined as follows. We first get the ORE ciphertexts of x and y, as well as their path codes c x and c y by traversing the tree separately. When computing c x +c y , if an overflow occurs (i.e., c x +c y ≥ 2 β ), we know that x+y &gt; θ with confidence. If c x +c y ≤ 2 β -2, we also know that x + y ≤ θ with confidence. Otherwise, we are unable to determine the relationship and end up with an uncertainty. We summarize this procedure in Algorithm 4.</p><p>Discussion. Observe that when we go through a cost constraint tree, one more step can further reduce the uncertainty of the relationship between x + y and θ by half. We denote the probability of uncertainty as</p><formula xml:id="formula_4">Pr[¬certainty] = ( 1 2 ) β .</formula><p>where β is the length of the path code. We can easily know the probability of certainty is</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4 Tree-Based Ciphertexts Comparison Algorithm</head><p>Input: Two ORE ciphertexts E(x), E(y) and a cost constraint tree whose depth is d θ . Output: The relationship between x + y and θ.</p><p>1: Initialize a counter ω = 1 and two empty strings cx and cy. 2: while ω ≤ d θ do 3:</p><p>Visit the ω-th level of the tree with E(x) and concatenate cx with corresponding 0 or 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>Visit the ω-th level of the tree with E(y) and concatenate cy with corresponding 0 or 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>Set ω = ω + 1. 6: end while 7: if cx + cy ≥ 2 ω then 8:</p><p>return &gt;. 9: end if 10: if cx + cy ≤ 2 ω -2 then 11:</p><p>return ≤. 12: end if 13: return uncertainty.</p><formula xml:id="formula_5">Pr[certainty] = 1-Pr[¬certainty] = 1 -( 1 2 ) β .</formula><p>When the tree depth is 6 (e.g., β = 6), the probability of certainty could reach about 0.9844. Another observation is the comparison procedure reveals the order information between x (or y) and θ. Thus, the server can infer the interval that x belongs to with precision of 2 -β . To prevent the server from inferring the real value of x, in Connor, the user randomly picks a big integer number φ that is applied to x, y, and θ simultaneously, which significantly enlarges the plaintext and ciphertext spaces (e.g., 128 ). The value of β is generally a small integer (e.g., 6 in our implementation) that is determined by the user, and both φ and θ are kept secret by the user. Therefore, the server cannot infer the real value of x (or y) from the order relationship among ciphertexts. We will formally analyze the leakage functions and security issues in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. COMPLEXITY AND SECURITY ANALYSES</head><p>This section presents the complexity and security analyses on the proposed graph encryption scheme Connor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Complexity Analysis</head><p>Connor mainly consists of the Setup and Query algorithms, as described in Algorithms 2 and 3.</p><p>The dominant component in determining the complexity of the Setup algorithm is the encryption of the plain 2HCLI generated from a graph G. Let µ be the total sketch for all vertices in G, then the time complexity and space complexity are both O(nµ), where n is the number of vertices in G.</p><p>The Query algorithm consists of a query token generation process on the user side and a CSD query process on the cloud server side. Let η be the maximum size of the sketch associated with each vertex in G. The complexity of the query token generation process is mainly determined by the construction a cost constraint tree, whose time complexity and space complexity are both O(2 d θ ). For the CSD querying process, the time complexity of getting L s and L t , performing cost constraint filtering, and performing distance computation are O(η), O(ηd θ ), and O(η), respectively. The space complexity of the above three components are O(η), O(η + 2 d θ ), and 1556-6013 (c) 2017 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information. This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2017.2774451, IEEE Transactions on Information Forensics and Security O(η), respectively. Therefore, the total time complexity and space complexity of the CSD querying process are O(ηd θ ) and O(η + 2 d θ ), respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Security Analysis</head><p>We now present the security analysis on Connor. For clarity, we first discuss the leakage functions, and then prove that Connor is secure under the CQA2-security model.</p><p>Setup Leakage. The leakage function L Setup of our construction reveals the information that can be deduced from the secure 2HCLI ∆ of graph G, including the total number of vertices in the graph n, the maximum distance over all the sketches B = max u∈V max {(v,du,v,cu,v)∈∆out,(v,du,v,cu,v)∈∆in} d u,v , and the size of ∆. More precisely, the size of ∆ consists of the total number of sketch entities in I out and I in , which are denoted by Ω out and Ω in , respectively. Thus, the leakage function</p><formula xml:id="formula_6">L Setup = (n, B, Ω out , Ω in ).</formula><p>Note that the order relationship of pairwise costs and the order relationship between the cost and cost constraint are not included in L Setup , because for each entity in sketches, we make an XOR operation using a unique integer value after we encrypt it, and this makes each entity in sketches are indistinguishable.</p><p>Query Leakage. The leakage function L Query of our construction consists of the query pattern leakage, the sketch pattern leakage, and the cost pattern leakage. Intuitively, the query pattern leakage reveals whether a query has appeared before. The sketch pattern leakage reveals the sketch associated to a queried vertex, the common vertices between two different sketches, and the size of the sketches of queried vertices. The cost pattern leakage reveals 1) the order relationship among costs, and 2) the order relationship between costs and the cost during the query procedure. We formalize these leakage functions as follows.</p><p>Definition 4. (QUERY PATTERN LEAKAGE). Let q = (q 1 , q 2 , . . . , q m ) be a non-empty sequence of queries. Each query q i specifies a tuple (u i , v i , θ i ). For any two queries q i and q j , define Sim(q i , q j ) = (u i = u j , v i = v j , θ i = θ j ), i.e., whether each element of q i = (u i , v i , θ i ) matches each element of q j = (u j , v j , θ j ), respectively. Then, the query pattern leakage function L QP (q) returns an m × m (symmetric) matrix, in which each entry (i, j) equals Sim(q i , q j ). Note that L QP (q) does not leak the identities of the query vertices. Definition 5. (SKETCH PATTERN LEAKAGE). Given a secure 2HCLI ∆ of a graph G and a query q = (u, v, θ), the sketch pattern leakage function L SP ( ∆, q) is defined as (Σ, Υ). Σ is a list, each element of which is the sketches associated to the queried vertices, and Υ is a pair (X, Z), where</p><formula xml:id="formula_7">X = h(v) : (v, d, c) ∈ I out and Z = h(v) : (v, d, c) ∈ I in are multi-sets and h : {0, 1} λ × {0, 1} * → {0, 1}</formula><p>λ is a particular pseudo-random function.</p><p>Definition 6. (COST PATTERN LEAKAGE). The cost constraint θ in a query q can essentially be represented by a certain number of uniform intervals. Let d θ be the depth of the cost constraint tree T θ (c.f. Section VI). The intervals associated with θ are</p><formula xml:id="formula_8">[(i -1)θ/2 d θ , iθ/2 d θ ], where 1 ≤ i ≤ 2 d θ .</formula><p>Assign each interval with a list µ, i.e., the i-th interval is associated with µ i , which stores all the cost values belong to this interval. The leaked interval information forms an array Arr, of which the i-th element is µ i (i.e., Arr[i] = µ i ). In addition, assume that z is the total number of entries in the sketches of the queried vertices. For each pair of costs c i and c j , its order relationship of the greater-than, equality, and less-than can be represented by 1, 0, and -1, respectively. The leaked order information of costs is a z × z (symmetric) matrix ∇ with each entry (i, j) being 1, 0, or -1. Therefore, the cost pattern leakage function L CP ( ∆, q) = (Arr, ∇).</p><p>Thus, L Query = (L QP (q), L SP ( ∆, q), L CP ( ∆, q)).</p><p>The leakage functions are defined over the 2HCLI rather than the original graph. In fact, the information leakage of the original graph is limited to the minimum number of paths for the queried source-destination vertices. It can be defined as an n × n (symmetric) matrix Λ, where n is the number of vertices in the graph. Each element in Λ is NULL, 0, or a positive integer, which indicates an uncertain status (i.e., topology is well protected), disconnection, or the minimum number of paths of the two queried vertices, respectively.</p><p>For the cost values in the 2HCLI, we introduce a user-held amplification factor φ to enlarge the plaintext and ciphertext spaces. Thus, the server cannot infer the real cost values just from their order information revealed by the leakage function CP ( ∆, q)). For the distance values in the 2HCLI, we use the SWHE encryption to protect their real values from the server. Theorem 1. If the cryptography primitives g, h, ORE, and the SWHE are secure, then the proposed graph encryption scheme Π = (KeyGen, Setup, Query) is (L Setup , L Query )secure against the adaptive chosen-query attack.</p><p>Proof. The key idea is constructing a simulator S. Given the leakage functions L Setup and L Query , S constructs a fake encrypted 2HCLI structure ∆ * = {I * out , I * in } and a list of query q * . If for all PPT adversaries A, they cannot distinguish between the two games Real and Ideal, we can say that our graph encryption scheme is (L Setup , L Query )-secure against the adaptive chosen-query attack.</p><p>Simulating ∆ * . S handles each vertex u i (1 ≤ i ≤ n) to generate a fake I * out in 2HCLI based on the leakage function L Setup . S randomly chooses w i for u i with n 1 w i = Ω out , and samples l i ← {0, 1}</p><p>λ and η i ← {0, 1} λ uniformly without repetition. For all 0 ≤ i &lt; w i , S takes the following steps to simulate each sketch: S computes l wi = h(l i , w i ) and η wi = h(η i , w i ), where h is a particular pseudo-random function. Then, it encrypts each vertex v in the sketch of u i by computing V * = h(K * , v||0), where K * is a fake secret key. out , I * in }. Simulating q * . Given the leakage function L Query = (L QP (q), L SP ( ∆, q), L CP ( ∆, q)), S simulates the query token as follows. S first checks if either of the queried vertices s and t has appeared in any previous query. If s appeared previously, S sets S * out,s and T * out,s to the values that were previously used. Otherwise, it sets T * out,s = l i and S * out,s = η i for some previously unused l i and η i . It then remembers the association among η i , l i , and s. S takes the same steps for the queried vertex t: setting S * in,t and T * in,t analogously and associating t with the selected η i and l i .</p><p>To simulate a fake cost constraint tree T * θ , S first checks if the queried θ appeared in any previous query. If θ appeared previously, S sets the T * θ to the value that was previously used. Otherwise, S constructs a full binary tree based θ and encrypts each tree node by using the ORE scheme with a randomly generated key. S returns this encrypted tree as T * θ . S simulates the query procedure as follows. <ref type="bibr">Given</ref>  Since the cryptography primitives g, h, ORE, and SWHE are secure, the fake 2HCLI structure ∆ * and the query sequence q * are indistinguishable from the real ones. Therefore, for all PPT adversaries A, they cannot distinguish between the two games Real and Ideal. Thus, we have</p><formula xml:id="formula_9">|Pr[Real Π,A (λ) = 1] -Pr[Ideal Π,A,S (λ) = 1]| ≤ negl(λ).</formula><p>where negl(λ) is a negligible function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. PERFORMANCE EVALUATION</head><p>This section presents the evaluation of our graph encryption scheme through experiments on real-world datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Setup</head><p>Testbed. implement the method introduced in <ref type="bibr" target="#b1">[2]</ref> for building the 2HCLI. The ORE and SWHE in our implementation follow the methods described in <ref type="bibr" target="#b14">[15]</ref> and <ref type="bibr" target="#b15">[16]</ref>, respectively. The GMP library is used for big integer arithmetic. We set the security parameter λ = 128 and use the OpenSSL library for all the basic cryptographic primitives. All the algorithms in our experiment are implemented in C++. The experiments are conducted on a desktop PC equipped with Intel Xeon processor at 2.6 GHz and 8 GB RAM.</p><p>Graph sets. The datesets used in our experiments are listed in Table <ref type="table" target="#tab_0">II</ref>. All these datasets are publicly available from the Standford SNAP website<ref type="foot" target="#foot_1">3</ref> and modeled as directed graphs. For the datasets soc-Epinions1 and Email-EuAll, we randomly select their subsets to make the index construction feasible with the limited computational resources. Since these graphs are unweighted, we generate a distance and a cost for each edge, the value of which follows a uniform distribution between 1 and 100. The cost criterion is used as the constraint. Methods to compare. Since this is the first work to address the CSD querying problem over encrypted graphs, we compare our method with the one over unencrypted graphs. We implement such a method following the state-of-the-art method over plaintext graphs introduced in <ref type="bibr" target="#b1">[2]</ref>. The only difference is that we construct 2HCLI over the original graph, instead of an overlay graph. As a result, our implementation has a higher query efficiency but leads to a higher complexity of the index construction.</p><p>Query sets. We randomly generate 200 queries over each dataset. The origin s and destination t in each query are also randomly selected. The cost constraint θ for each (s, t) pair is set as follows. We denote the lower bound c min as the minimum cost of all paths from s to t, and the upper bound c max as the minimum cost of the paths with the shortest distance from s to t. If the cost constraint θ &lt; c min , there will be no feasible answer to the query; and if the cost constraint θ &gt; c max , the shortest distance is always a valid answer to the query. To mitigate the impact of θ on the performance, we randomly choose 50 values of θ for each query, which falls in the interval [c min , c max ].</p><p>Another important parameter is α, which determines the approximation guarantees of α-CSD queries. Since α is a constant value for all queries, we view it as a system parameter rather than part of specific queries. In order to achieve a balance between query accuracy and system efficiency, we set the approximation ratio α = 1.5 for all queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Evaluation of Secure 2HCLI and Query Token</head><p>Index Size and Construction Time. The index construction of the graph is a one-time and offline computation. This process consists of two steps: one is constructing the plain 2HCLI, which is the same as the index construction process of the original plain CSD querying, and the other is encrypting the plain 2HCLI, which is the focus of this paper. Therefore, we consider the outputs of the first step as the index of unencrypted graph.</p><p>The index size and construction time are depicted in Table <ref type="table" target="#tab_0">III</ref>. Note that the index size and construction time of different datasets have a great difference, which is mainly caused by In general, the size of each encrypted index is roughly 6× larger than that of the corresponding plain index. The most important observation is that the index construction time of encrypted graphs is slightly higher than the one of unencrypted graphs. Thus, the key point of improving the index construction efficiency over an encrypted graph is accelerating the process of constructing the plain 2HCLI of that graph. We leave this attempt as the future work.</p><p>Query Generation. The construction of query tokens is independent of specific graphs, we now the size and generation time of a query token. The query token mainly consists of 5 elements, namely S out,s , T out,s , S in,t , T in,t , and T θ . Each of the first 4 elements has a length of 16 bytes. Since the size of each ORE ciphertext is 16 bytes, a cost tree T θ whose depth is d θ has a size of 16 × (2 d θ -1) bytes. Therefore, the total size of a query token is 16×(2 d θ +3) bytes. Since d θ is a relatively small value, the size of a query token is usually less than 1 KB. The query token generation time with varying d θ is depicted in Table <ref type="table" target="#tab_6">IV</ref>. Although the query token generation time increases significantly with d θ , the time cost is moderate for general cases (e.g., when d θ ≤ 6). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Evaluation of Query Efficiency and Accuracy</head><p>Query Efficiency. To evaluate the query efficiency, for each θ, we generate the cost constraint tree with a different depth d θ . The query time is defined as the time interval from the submission of a query token to the receival of its query results. We compute the average query time of 200 queries.</p><p>The average query time with varying d θ over the encrypted 2HCLI is depicted in Fig. <ref type="figure" target="#fig_10">7</ref>, where d θ increases from 1 to 6. We can see that the query time varies a lot for different graph datasets. For each dataset, increasing d θ can result in a decrease in the query time. This is because a larger d θ can filter out more distance pairs exceeding the cost constraint and thereby reduce the number of candidates for distance computation using SWHE, which is the dominant operation in time consumption. Fig. <ref type="figure" target="#fig_11">8</ref> presents the query time in the plain and encrypted scenarios for different datasets. The query time over the encrypted 2HCLI is higher than that over the plain 2HCLI because of the time-consuming operations on ciphertexts (e.g., the cost filtering and distance computation). Also, the time complexity of these operations is closely related to the size of a graph index listed in Table <ref type="table" target="#tab_0">III</ref>, which leads to the difference among four datasets in Fig. <ref type="figure" target="#fig_11">8</ref>.</p><p>Query Accuracy. In Connor, there are two components that affect the query accuracy, namely the tree-based ciphertexts comparison and the distance computation. The former may keep some distance pairs that do not satisfy the cost constraint in the candidate set Y , while the latter leverages the property of SWHE to obtain an approximate, but not exact, shortest distance based on all candidates in Y .</p><p>We use the well-known metric Precision (P) to evaluate the accuracy of the cost constraint filtering process. P = Tp Tp+Fp , where T p and F p represent the numbers of distance pairs in Y whose costs truly satisfy or exceed the cost constraint, respectively. We use the same query as introduced above, and compute the P for each query. Finally, we can obtain the average precision P for all the queries. Fig. <ref type="figure">9</ref> presents the relationship between the query precision P and the depth of the cost constraint tree d θ over different datasets. We can see that for all the datasets, P increases with d θ , because the cost constraint tree with a larger depth d θ helps us to detect constraint violations with a higher probability, as discussed in Section VI. In particular, P is more than 94% for all datasets when d θ = 6.</p><p>To evaluate the accuracy of the final query results, we propose a metric named the deviation rate. Let r e and r p be the query results returned by Connor and the algorithm over the corresponding plain graphs, respectively. Then, we define the deviation rate ξ = r e /r p , which indicates how far r e deviates from r p . Obviously, a deviation rate closer to 1 depicts more accurate query results. Fig. <ref type="figure" target="#fig_1">10</ref> presents the cumulative distribution functions (CDFs) of the deviation rate over the dataset p2p-Gnutella04. We can see that ξ is larger than 0.90 for over 80% of the query results, and larger than 0.73 in the worst cases. Therefore, Connor is capable of achieving a relatively high accuracy with moderate computation complexity.  IX. CONCLUSION In this paper, we have presented Connor, the first graph encryption scheme that enables the cloud-based approximate CSD queries. In particular, we proposed a tree-based ciphertexts comparison protocol for cost constraint filtering with controlled disclosure. The security analysis showed that Connor could achieve the CQA2-security. We implemented a prototype and evaluated the performance using the realworld graph datasets. The evaluation results demonstrated the effectiveness of Connor. In the future work, we plan to design techniques to support dynamic index updates.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Number of vertices and edges in G d(e), c(e) Distance and cost of an edge e d(u, v), c(u, v) Distance and cost of the edge from u to v s, t, α, φ, θ Origin, destination, approximation ratio, amplification factor and cost constraint in an α-CSD query ∆, ∆ Plain and encrypted graph index ∆ in (v), ∆out(v) In-and out-label set associated with vertex v d θ Depth of a cost constraint tree β Length of a path code E(m) ORE ciphertext of m λ Security parameter k Output length of ORE encryption z Input length of symmetric encryption algorithms τs,t Query token Y Candidate sets as the outputs of the cost constraint filtering B</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. An example illustrating the α-CSD query over a graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. A 2HCLI example of the basic shortest distance query. Each entity d in 2HCLI alongside the arrow indicates the shortest distance from the starting vertex to the ending vertex, e.g., the shortest distance from a to e is 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. A 2HCLI example of the exact CSD query. Each entity (dis, cost) in the 2HCLI alongside the arrow indicates the distance and cost, respectively. The shortest distance from a to e with a cost constraint θ = 4 is 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>. Given the labels ∆ out (a) and ∆ in (c), it is easy to obtain the set of common vertices, which consists of vertices b and e. The final answer to the basic shortest distance query should be 5, because d(a, e) + d(e, c) = 5 &lt; d(a, b) + d(b, c) = 6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. The resulting 2HCLI after performing the offline filtering on the original 2HCLI in Fig. 3. Each entity(u, d, c) in the 2HCLI indicates the vertex identifier, distance and cost, respectively. The answer to the approximate CSD query (i.e., the origin a, the destination c, α = 1.5, and θ = 4) is 6, which happens to be the answer to the exact CSD query.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. The system model of privacy-preserving CSD query scheme.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Algorithm 1 2 :</head><label>12</label><figDesc>Setup algorithm for GraphEnc 1Input: A secret key K, a key pair (pk, sk), an approximation ratio α, an amplification factor φ, and an original graph G. Output: The encrypted graph index ∆.1: Generate the 2-hop labeling index ∆ = {∆out, ∆ in } from G. Initialize two dictionaries Iout and I in .3: Let B be the maximum distance over all the sketches and set N = 2B+1. 4: for each u ∈ G do 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. An example of the cost constraint tree with a depth of 3, where circles represent nodes. The boxes in the dashed rectangle indicate path codes for all possible comparison results. Note that these boxes are not a part of the tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>It randomly generates two integers d and c and obtains ciphertexts D * and C * by encrypting 2 N -d (N = 2B+1) and c using the SWHE and ORE schemes. Let Ψ * i = η wi ⊕ (V * ||D * ||C * ). S stores Ψ * in the index I * out . That is, I * out [l wi ] = Ψ * i . Similarly, S generates a fake I * in and finally obtains the fake 2HCLI ∆ * = {I *</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The query time over encrypted 2HCLI with varying d θ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. The query time over the plain 2HCLI and the encrypted 2HCLI (d θ = 6).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 9 .Fig. 10 .</head><label>910</label><figDesc>Fig. 9. The query precision for different depth d θ of the cost tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I LIST</head><label>I</label><figDesc>OF NOTATIONS</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The cloud server obtains I out [τ s ] and I in [τ t ] from the index. For each encrypted vertex identifier v that appears in both I out [τ s ] and I in [τ t ], the cloud server performs a cost constraint filtering operation (which will be described in details in Section VI), and adds each pair (D s,v , D v,t ) which satisfies the cost constraint φθ into a candidate set Y . Note that the cost constraint is multiplied by φ because we encrypt the cost φc u,v , instead of c u,v . Then, the cloud server directly obtains d =</figDesc><table><row><cell>|Y | i=1 d i ,</cell></row><row><cell>where d</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>13: end while 14: cloud server initializes a set Lt and a counter ω = 0. 15: cloud server computes T in,v,t = h(T in,t , ω). 16: while I in [T in,v,t ] = ⊥ do 17:</figDesc><table /><note><p>cloud server computes S in,v,t = g(S in,t , ω). 18: cloud server performs (V ||Dv,t||Cv,t) = Ψv,t ⊕ S in,v,t . 19: cloud server add (V, Dv,t, Cv,t) into Lt. 20: Set ω = ω + 1. 21: cloud server computes T in,v,t = h(T in,t , ω). 22: end while 23: For each encrypted vertex identifier v that appears in both in Ls and Lt, the cloud server performs the cost constraint filtering operation through Algorithm 4, and add the pair (Ds,v, Dv,t) which satisfies the cost constraint φθ into a set Y . The pair that Algorithm 4 cannot verify is also added into Y . 24: For each pair in Y , the cloud server first computes d i = SWHE.Eval(×, D i s,v , D i v,t ), and then computes d = |Y | i=1 d i . 25: cloud server returns d to the user. 26: user decrypts d with sk. 27: return Decrypted value of d as distq.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>S first checks if the query has been queried before. If yes, S returns the value that was previously used as the query result. Otherwise, S checks the queried vertex s (or t) has been queried before. If the query vertex s has appeared in a previous query, S sets L * s to the values that were previously used from Σ of L SP ( f , q). Otherwise, for a newly appeared vertex s, S takes the following steps: To generate the sketches associated with s, S first initializes a set L * s and a counter ω * = 0, Then, it iteratively computes T * out,s,v = h(T * out,s , w ) and S * out,s,v = g(S * out,s , w * ), and adds the tuple (V * , D * ] ⊕ S * out,s,v . Similarly, S obtains the set L * t for vertex t. Upon obtaining L * s and L * t , S performs cost constraint filtering operation based on T * θ to get the candidate set Y * . The theorem then follows from the CPA-security of SWHE. That is, S performs the SWHE computation over Y * and returns the query result.</figDesc><table><row><cell>the query</cell></row><row><cell>token (S  *  out,s , T  *  out,s , S  *  in,t , T  *  in,t , T  *  θ ), s,v , C  *  s,v ) into L  *  s , until I  *  out [T  *  out,s,v ] does not exist, where (V  *  , D  *  s,v , C  *  s,v ) = I  *  out [T  *  out,s,v</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE IV THE</head><label>IV</label><figDesc>QUERY TOKEN GENERATION TIME FOR DIFFERENT d θ</figDesc><table><row><cell>d θ</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell>7</cell><cell>8</cell></row><row><cell>Time (ms)</cell><cell cols="8">0.15 0.31 0.65 1.22 2.46 4.95 9.88 19.77</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For simplicity, we refer to single-constraint CSD queries as CSD queries hereafter.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>http://snap.stanford.edu/data/</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported in part by the National Science Foundation of China under Grant 61602039, in part by the Beijing Natural Science Foundation under Grant 4164098, and in part by the China National Key Research and Development Program under Grant 2016YFB0800301.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Grecs: Graph encryption for approximate shortest distance queries</title>
		<author>
			<persName><forename type="first">Xianrui</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seny</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kobbi</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Kollios</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="504" to="517" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Effective indexing for approximate constrained shortest path queries on large road networks</title>
		<author>
			<persName><forename type="first">Sibo</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaokui</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yin</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenqing</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="61" to="72" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Classification of encrypted traffic with second-order markov chains and application attribute bigrams</title>
		<author>
			<persName><forename type="first">Meng</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingwei</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liehuang</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingzhong</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Forensics &amp; Security</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1830" to="1843" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Towards efficient virtual network embedding across multiple network domains</title>
		<author>
			<persName><forename type="first">Meng</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ke</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kun</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hsiao</forename><surname>Hwa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Quality of Service</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="61" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Achieving optimal traffic engineering using a generalized routing framework</title>
		<author>
			<persName><forename type="first">Ke</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meng</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongying</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiangchuan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tong</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel &amp; Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="51" to="65" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Graphlab: A new framework for parallel machine learning</title>
		<author>
			<persName><forename type="first">Yucheng</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aapo</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><forename type="middle">E</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Pregel: a system for large-scale graph processing</title>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Malewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aart</forename><forename type="middle">J C</forename><surname>Matthew H Austern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>Bik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilan</forename><surname>Dehnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naty</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Leiser</surname></persName>
		</author>
		<author>
			<persName><surname>Czajkowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Turbograph:a fast parallel graph engine handling billion-scale graphs in a single pc</title>
		<author>
			<persName><forename type="first">Wook</forename><surname>Shin Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sangyeon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyungyeol</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong</forename><surname>Hoon Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Min</forename><forename type="middle">Soo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinha</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hwanjo</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="77" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Bicriterion path problems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Multiple criteria decision making theory and application</title>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="109" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Approximation schemes for the restricted shortest path problem</title>
		<author>
			<persName><forename type="first">Refael</forename><surname>Hassin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Operations research</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="36" to="42" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Multiobjective optimization: Improved fptas for shortest paths and non-linear objectives with applications</title>
		<author>
			<persName><forename type="first">George</forename><surname>Tsaggouris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Zaroliagis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="162" to="186" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Route planning for bicycles-exact constrained shortest paths made practical via contraction hierarchy</title>
		<author>
			<persName><forename type="first">Sabine</forename><surname>Storandt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICAPS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">46</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Shortest paths and distances with differential privacy</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Sealfon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="29" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Order-revealing encryption: New constructions, applications, and lower bounds</title>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Lewi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;16</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1167" to="1178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Practical order-revealing encryption with limited leakage</title>
		<author>
			<persName><forename type="first">N</forename><surname>Chenette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lewi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Weis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IACR-FSE</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Evaluating 2-dnf formulas on ciphertexts</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-J</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="325" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Structured encryption and controlled disclosure</title>
		<author>
			<persName><forename type="first">Melissa</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seny</forename><surname>Kamara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="577" to="594" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An efficient privacy-preserving ranked keyword search method</title>
		<author>
			<persName><forename type="first">Chi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaojie</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peisong</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiankun</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Song</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zahir</forename><surname>Tari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><forename type="middle">Y</forename><surname>Zomaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TPDS</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="951" to="963" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Achieving big data privacy via hybrid cloud</title>
		<author>
			<persName><forename type="first">X</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Du</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 IEEE Conference on Computer Communications Workshops (INFOCOM WKSHPS)</title>
		<imprint>
			<date type="published" when="2014-04">April 2014</date>
			<biblScope unit="page" from="512" to="517" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Xiaojiang Du, Bin Luo, and Mohsen Guizani. A lightweight live memory forensic approach based on hardware virtualization</title>
		<author>
			<persName><forename type="first">Yingxin</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">379</biblScope>
			<biblScope unit="page" from="23" to="41" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mobifish: A lightweight antiphishing scheme for mobile phones</title>
		<author>
			<persName><forename type="first">Longfei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaojiang</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Communication and Networks</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Security threats to mobile multimedia applications: Camera-based attacks on mobile phones</title>
		<author>
			<persName><forename type="first">Longfei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaojiang</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xinwen</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications Magazine IEEE</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="80" to="87" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An effective key management scheme for heterogeneous sensor networks</title>
		<author>
			<persName><forename type="first">Xiaojiang</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohsen</forename><surname>Guizani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hsiao</forename><surname>Hwa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ad Hoc Networks</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="34" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Privacy-preserving query over encrypted graph-structured data in cloud computing</title>
		<author>
			<persName><forename type="first">N</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2011 31st International Conference on Distributed Computing Systems</title>
		<imprint>
			<date type="published" when="2011-06">June 2011</date>
			<biblScope unit="page" from="393" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Analyzing graphs with node differential privacy</title>
		<author>
			<persName><forename type="first">Shiva</forename><surname>Prasad Kasiviswanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kobbi</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sofya</forename><surname>Raskhodnikova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="457" to="476" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Mining frequent graph patterns with differential privacy</title>
		<author>
			<persName><forename type="first">Entong</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ting</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="545" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Data-oblivious graph algorithms for secure computation and outsourcing</title>
		<author>
			<persName><forename type="first">Marina</forename><surname>Blanton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Steele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehrdad</forename><surname>Alisagari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM SIGSAC Symposium on Information, Computer and Communications Security, ASIA CCS &apos;13</title>
		<meeting>the 8th ACM SIGSAC Symposium on Information, Computer and Communications Security, ASIA CCS &apos;13<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="207" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Securely Solving Simple Combinatorial Graph Problems</title>
		<author>
			<persName><forename type="first">Abdelrahaman</forename><surname>Aly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edouard</forename><surname>Cuvelier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sophie</forename><surname>Mawet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mathieu</forename><surname>Van Vyve</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Efficient, Oblivious Data Structures for MPC</title>
		<author>
			<persName><forename type="first">Marcel</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Scholl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A new approach to interdomain routing based on secure multi-party computation</title>
		<author>
			<persName><forename type="first">Debayan</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Segal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aurojit</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gil</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schapi-Joan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jenifer</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Workshop on Hot Topics in Networks</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="37" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">Fattaneh</forename><surname>Bayatbabolghani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marina</forename><surname>Blanton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehrdad</forename><surname>Aliasgari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Goodrich</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1702.03379</idno>
		<title level="m">Secure fingerprint alignment and matching protocols</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Reachability and distance queries via 2-hop labels</title>
		<author>
			<persName><forename type="first">Edith</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eran</forename><surname>Halperin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haim</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uri</forename><surname>Zwick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Siam Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="937" to="946" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Fast exact shortestpath distance queries on large networks by pruned landmark labeling. SIGMOD</title>
		<author>
			<persName><forename type="first">Takuya</forename><surname>Akiba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoichi</forename><surname>Iwata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuichi</forename><surname>Yoshida</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="349" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Practical techniques for searches on encrypted data</title>
		<author>
			<persName><forename type="first">Dawn Xiaoding</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security &amp; Privacy</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="44" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Searchable symmetric encryption: Improved definitions and efficient constructions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CCS</title>
		<meeting>of ACM CCS<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Dynamic searchable symmetric encryption</title>
		<author>
			<persName><forename type="first">Seny</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charalampos</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Roeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Acm Conference on Computer &amp; Communications Security</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="965" to="976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Dynamic searchable encryption in very-large databases: Data structures and implementation</title>
		<author>
			<persName><forename type="first">David</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stanislaw</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Charanjit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugo</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelcatalin</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Rosu</surname></persName>
		</author>
		<author>
			<persName><surname>Steiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Practical dynamic searchable encryption with small leakage</title>
		<author>
			<persName><forename type="first">Emil</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charalampos</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Searchable symmetric encryption: Improved definitions and efficient constructions</title>
		<author>
			<persName><forename type="first">Reza</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seny</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="895" to="934" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Inference attacks on property-preserving encrypted databases</title>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Naveed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seny</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">V</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22Nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15</title>
		<meeting>the 22Nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="644" to="655" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Optimizing semihonest secure multiparty computation for the internet</title>
		<author>
			<persName><forename type="first">Aner</forename><surname>Ben-Efraim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eran</forename><surname>Omri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigsac Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="578" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">China in 2014, both in computer science. Currently he serves in Beijing Institute of Technology, Beijing, China, as an assistant professor. His research interests include privacy protection of cloud-based services, network virtualization and traffic engineering. He received the Best Paper Runner-Up Award at IEEE IPCCC 2014. He is a member of the IEEE. Baoli Ma received the B.Eng degree in computer science from Beijing of Technology, Beijing, China in 2015. Currently he is a master student in the School of Computer Science, Beijing Institute of Technology. His research interest is secure searchable encryption. Liehuang Zhu is a professor in the School of Computer Science, Beijing Institute of Technology. He is selected into the Program for New Century Excellent Talents in University from Ministry of Education</title>
		<author>
			<persName><forename type="first">Assaf</forename><surname>Ben-David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noam</forename><surname>Nisan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">China in 2009, and the Ph</title>
		<meeting><address><addrLine>Alexandria, Virginia, Usa; Jinan; Beijing</addrLine></address></meeting>
		<imprint>
			<publisher>Cloud Computing Security</publisher>
			<date type="published" when="2008-10">2008. October. 2008</date>
			<biblScope unit="page" from="257" to="266" />
		</imprint>
		<respStmt>
			<orgName>D degree from Tsinghua University</orgName>
		</respStmt>
	</monogr>
	<note>Meng Shen received the B.Eng degree from Shandong University. Internet and Mobile Security</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">His research interest is in the field of cyber security covering intrusion detection, sensor key management, and biometrics authentication. He has many publications in top venues including IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<author>
			<persName><forename type="first">Rashid</forename><surname>Mijumbi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Du has been awarded more than $5 million US dollars research grants from the US National Science Foundation (NSF), Army Research Office, Air Force, NASA, the State of Pennsylvania, and Amazon. He won the best paper award at IEEE GLOBECOM 2014 and the best poster runner-up award at the ACM MobiHoc</title>
		<title level="s">where he participated in several Spanish national, European, and Irish National Research Projects</title>
		<editor>
			<persName><surname>Springer</surname></persName>
		</editor>
		<editor>
			<persName><surname>Dr</surname></persName>
		</editor>
		<meeting><address><addrLine>Barcelona, Spain; Waterford, Ireland; Nokia, Dublin, Ireland; Philadelphia, USA; Beijing; Canberra, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>UNSW@ADFA</publisher>
			<date type="published" when="2012">2014. 2012</date>
		</imprint>
		<respStmt>
			<orgName>Universitat Politecnica de Catalunya (UPC ; Computer and Information Sciences at Temple University ; University of New South Wales</orgName>
		</respStmt>
	</monogr>
	<note>IEEE Transactions on Information Forensics &amp; Security (TIFS), Pattern Recognition. and IEEE Transactions on Industrial Informatics. He is the associate editor of the IEEE Transactions on Information Forensics and Security</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
