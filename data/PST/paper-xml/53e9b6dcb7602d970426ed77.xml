<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Calculus for Orchestration of Web Services</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Alessandro</forename><surname>Lapadula</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Sistemi e Informatica Università degli Studi di Firenze</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rosario</forename><surname>Pugliese</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Sistemi e Informatica Università degli Studi di Firenze</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Francesco</forename><surname>Tiezzi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Sistemi e Informatica Università degli Studi di Firenze</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Calculus for Orchestration of Web Services</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B208F4DA7BD51C353417B79F6F98650E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce COWS (Calculus for Orchestration of Web Services), a new foundational language for SOC whose design has been influenced by WS-BPEL, the de facto standard language for orchestration of web services. COWS combines in an original way a number of ingredients borrowed from wellknown process calculi, e.g. asynchronous communication, polyadic synchronization, pattern matching, protection, delimited receiving and killing activities, while resulting di«erent from any of them. Several examples illustrates COWS peculiarities and show its expressiveness both for modelling imperative and orchestration constructs, e.g. web services, flow graphs, fault and compensation handlers, and for encoding other process and orchestration languages.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Web services are a successful instantiation of service-oriented computing (SOC), an emerging paradigm for developing loosely coupled, interoperable, evolvable systems and applications which exploits the pervasiveness of the Internet and its related technologies. Web services are autonomous, stateless, platform-independent and composable computational entities that can be published, located and invoked through the Web via XML messages. These very features foster a programming style based on service composition and reusability: new customized service-based applications can be developed on demand by appropriately assembling other existing, heterogeneous services.</p><p>Service definitions are used as templates for creating service instances that deliver application functionality to either end-user applications or other instances. The loosely coupled nature of SOC implies that the connection between communicating instances cannot be assumed to persist for the duration of a whole business activity. Therefore, there is no intrinsic mechanism for associating messages exchanged under a common context or as part of a common activity. Even the execution of a simple request-response message exchange pattern provides no built-in means of automatically associating the response message with the original request. It is up to each single message to provide a form of context thus enabling services to associate the message with others. This is achieved by embedding values in the message which, once located, can be used to correlate the message with others logically forming a same stateful interaction 'session'.</p><p>To support the web service approach, many new languages, most of which based on XML, have been designed, like e.g. business coordination languages (such as WS-BPEL, WSFL, WSCI, WS-CDL and XLANG), contract languages (such as WSDL and SWS), and query languages (such as XPath and XQuery). However, current software engineering technologies for development and composition of web services remain at the descriptive level and do not integrate such techniques as, e.g., those developed for component-based software development. Formal reasoning mechanisms and analytical tools are still lacking for checking that the web services resulting from a composition meet desirable correctness properties and do not manifest unexpected behaviors. The task of developing such verification methods is hindered also by the very nature of the languages used to program the services, which usually provide many redundant constructs and support quite liberal programming styles.</p><p>Recently, many researchers have exploited the studies on process calculi as a starting point to define a clean semantic model and lay rigorous methodological foundations for service-based applications and their composition. Process calculi, being defined algebraically, are inherently compositional and, therefore, convey in a distilled form the paradigm at the heart of SOC. This trend is witnessed by the many process calculi-like formalisms for orchestration and choreography, the two more common forms of web services composition. Most of these formalisms, however, do not suit for the analysis of currently available SOC technologies in their completeness because they only consider a few specific features separately, possibly by embedding ad hoc constructs within some well-studied process calculus (see, e.g., the variants of -calculus with transactions <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20]</ref> and of CSP with compensation <ref type="bibr" target="#b8">[9]</ref>).</p><p>Here, we follow a di«erent approach and exploit WS-BPEL <ref type="bibr" target="#b0">[1]</ref>, the de facto standard language for orchestration of web services, to drive the design of a new process calculus that we call COWS (Calculus for Orchestration of Web Services). Similarly to WS-BPEL, COWS supports shared states among service instances, allows a same process to play more than one partner role and permits programming stateful sessions by correlating di«erent service interactions. However, COWS intends to be a foundational model not specifically tight to web services' current technology. Thus, some WS-BPEL constructs, such as e.g. fault and compensation handlers and flow graphs, do not have a precise counterpart in COWS, rather they are expressed in terms of more primitive operators (see Section 3). Of course, COWS has taken advantage of previous work on process calculi. Its design combines in an original way a number of constructs and features borrowed from well-known process calculi, e.g. asynchronous communication, polyadic synchronization, pattern matching, protection, delimited receiving and killing activities, while however resulting di«erent from any of them.</p><p>The rest of the paper is organized as follows. Syntax and operational semantics of COWS are defined in Section 2 where we also show many illustrative examples. Section 3 presents the encodings of several imperative and orchestration constructs, while Section 4 presents the encoding of the orchestration language Orc <ref type="bibr" target="#b27">[28]</ref>. Finally, Section 5 touches upon comparisons with related work and directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">COWS: Calculus for Orchestration of Web Services</head><p>The basic elements of COWS are partners and operations. Alike channels in <ref type="bibr" target="#b9">[10]</ref>, a communication endpoint is not atomic but results from the composition of a partner name p and of an operation name o, which can also be interpreted as a specific implementation of o provided by p. This results in a very flexible naming mechanism that allows a same service to be identified by means of di«erent logic names (i.e. to play more than one partner role as in WS-BPEL). Additionally, it allows the names composing an endpoint to be dealt with separately, as in a request-response interaction, where usually the service provider knows the name of the response operation, but not the partner name of the service it has to reply to. This mechanisms is also suAEciently expressive to support implementation of explicit locations: a located service can be represented by using a same partner for all its receiving endpoints. Partner and operation names can be exchanged in communication, thus enabling many di«erent interaction patterns among service instances. However, as in <ref type="bibr" target="#b24">[25]</ref>, dynamically received names cannot form the communication endpoints used to receive further invocations.</p><p>COWS computational entities are called services. Typically, a service creates one specific instance to serve each received request. An instance is composed of concurrent threads that may o«er a choice among alternative receive activities. Services could be able to receive multiple messages in a statically unpredictable order and in such a way that the first incoming message triggers creation of a service instance which subsequent messages are routed to. Pattern-matching is the mechanism for correlating messages logically forming a same interaction 'session' by means of their same contents. It permits locating those data that are important to identify service instances for the routing of messages and is flexible enough for allowing a single message to participate in multiple interaction sessions, each identified by separate correlation values.</p><p>To model and update the shared state of concurrent threads within each service instance, receive activities in COWS bind neither names nor variables. This is di«erent from most process calculi and somewhat similar to <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b29">30]</ref>. In COWS, however, interservice communication give rise to substitutions of variables with values (alike <ref type="bibr" target="#b28">[29]</ref>), rather than to fusions of names (as in <ref type="bibr" target="#b29">[30]</ref>). The range of application of the substitution generated by a communication is regulated by the delimitation operator, that is the only binder of the calculus. Additionally, this operator permits to generate fresh names (as the restriction operator of the -calculus <ref type="bibr" target="#b26">[27]</ref>) and to delimit the field of action of the kill activity, that can be used to force termination of whole service instances. Sensitive code can however be protected from the e«ect of a forced termination by using the protection operator (inspired by <ref type="bibr" target="#b7">[8]</ref>).</p><p>Syntax. The syntax of COWS, given in Table <ref type="table" target="#tab_0">1</ref>, is parameterized by three countable and pairwise disjoint sets: the set of (killer) labels (ranged over by k k ¼</p><p>), the set of values (ranged over by v, v ¼ , . . . ) and the set of 'write once' variables (ranged over by x, y, . . . ). The set of values is left unspecified; however, we assume that it includes the set of names, ranged over by n, m, . . . , mainly used to represent partners and operations. The language is also parameterized by a set of expressions, ranged over by e, whose exact syntax is deliberately omitted; we just assume that expressions contain, at least, values and variables. Notably, killer labels are not (communicable) values. Notationally, we prefer letters p p ¼ when we want to stress the use of a name as a partner, o o ¼ when we want to stress the use of a name as an operation. We will use w to range over values and variables, u to range over names and variables, and d to range over killer labels, names and variables.</p><p>Services are structured activities built from basic activities, i.e. the empty activity 0, the kill activity kill( ) , the invoke activity ¡ ! and the receive activity ¡ ? , by means of prefixing , choice • , parallel composition , protection , delimitation [ ] and replication £ . Notably, as in the L <ref type="bibr" target="#b24">[25]</ref>, communication endpoints of receive </p><formula xml:id="formula_0">£ 0 0 £ s s £ s 0 0 s s [d] s [d] s [d] 0 0 [d 1 ] [d 2 ] s [d 2 ] [d 1 ] s s 1 [d] s 2 [d] (s 1 s 2 ) if d fd(s 1 ) fk(s 2 )</formula><p>activities are identified statically because their syntax only allows using names and not variables. The decreasing order of precedence among the operators is as follows: monadic operators, choice and parallel composition. Notation ¡ stands for tuples of objects, e.g. x is a compact notation for denoting the tuple of variables x 1</p><p>x n (with n 0). We assume that variables in the same tuple are pairwise distinct. All notations shall extend to tuples component-wise. In the sequel, we shall omit trailing occurrences of 0, writing e.g. p ¡ o? w instead of p ¡ o? w 0, and use</p><formula xml:id="formula_1">[d 1 d n ] s in place of [d 1 ] [d n ] s.</formula><p>The only binding construct is delimitation: [d] s binds d in the scope s. The occurrence of a name»variable»label is free if it is not under the scope of a binder. We denote by fd(t) the set of names, variables and killer labels that occur free in a term t, and by fk(t) the set of free killer labels in t. Two terms are alpha-equivalent if one can be obtained from the other by consistently renaming bound names»variables»labels. As usual, we identify terms up to alpha-equivalence.</p><p>Operational Semantics. COWS operational semantics is defined only for closed services, i.e. services without free variables»labels (similarly to many real compilers, we consider terms with free variables»labels as programming errors), but of course the rules also involve non-closed services (see e.g. the premises of rules (del )). Formally, the semantics is given in terms of a structural congruence and of a labelled transition relation.</p><p>The structural congruence identifies syntactically di«erent services that intuitively represent the same service. It is defined as the least congruence relation induced by a given set of equational laws. We explicitly show in Table <ref type="table" target="#tab_1">2</ref> the laws for replication, protection and delimitation, while omit the (standard) laws for the other operators stating that parallel composition is commutative, associative and has 0 as identity element, and that guarded choice enjoys the same properties and, additionally, is idempotent. All the presented laws are straightforward. In particular, commutativity of consecutive delimitations implies that the order among the d i in [ d 1</p><p>d n ] s is irrelevant, thus in the sequel we may use the simpler notation [d 1</p><p>d n ] s. Notably, the last law can be used to extend the scope of names (like a similar law in the -calculus), thus enabling communication of restricted names, except when the argument d of the delimitation is a free killer label of s 2 (this avoids involving s 1 in the e«ect of a kill activity inside s 2 ). </p><formula xml:id="formula_2">Å( x v) x v Å(v v) Å(w 1 v 1 ) 1 Å( w2 v2 ) 2 Å((w 1 w2 ) (v 1 v2 )) 1 2</formula><p>To define the labelled transition relation, we need a few auxiliary functions. First, we exploit a function [[ ]] for evaluating closed expressions (i.e. expressions without variables): it takes a closed expression and returns a value. However, [[ ]] cannot be explicitly defined because the exact syntax of expressions is deliberately not specified.</p><p>Then, through the rules in Table <ref type="table" target="#tab_2">3</ref>, we define the partial function Å( ) that permits performing pattern-matching on semi-structured data thus determining if a receive and an invoke over the same endpoint can synchronize. The rules state that two tuples match if they have the same number of fields and corresponding fields have matching values»variables. Variables match any value, and two values match only if they are identical. When tuples w and v do match, Å( w v) returns a substitution for the variables in w; otherwise, it is undefined. Substitutions (ranged over by ) are functions mapping variables to values and are written as collections of pairs of the form x v. Application of substitution to s, written s ¡ , has the e«ect of replacing every free occurrence of x in s with v, for each x v ¾ , by possibly using alpha conversion for avoiding v to be captured by name delimitations within s. We use to denote the number of pairs in and 1 2 to denote the union of 1 and 2 when they have disjoint domains. We also define a function, named halt( ), that takes a service s as an argument and returns the service obtained by only retaining the protected activities inside s. halt( ) is defined inductively on the syntax of services. The most significant case is halt( s ) s . In the other cases, halt( ) returns 0, except for parallel composition, delimitation and replication operators, for which it acts as an homomorphism.</p><p>Finally, we define a predicate, noc( ), that takes a service s, an endpoint p ¡ o, a tuple of receive parameters w and a matching tuple of values v as arguments and holds true if either there are no conflicting receives within s (namely, s cannot immediately perform a receive activity matching v over the endpoint p ¡ o), or p ¡ o? w is the most defined conflicting receive. The predicate exploits the notion of active context, namely a service with a 'hole' [[¡]] such that, once the hole is filled with a service s, if the resulting term [[s]] is a COWS service then it is capable of immediately performing an activity of s. Formally, active contexts are generated by the grammar:</p><formula xml:id="formula_3">:: [[¡]] • g g • s s [d] £</formula><p>Now, predicate noc(s p ¡ o w v) can be defined as follows:</p><p>( s</p><formula xml:id="formula_4">[[p ¡ o? w¼ s ¼ ]] Å( w¼ v) ) µ Å ( w v)</formula><p>where s [[p ¡ o? w¼ s ¼ ]] means that s can be written as p ¡ o? w¼ s ¼ filling the hole of some active context .</p><p>The labelled transition relation « is the least relation over services induced by the rules in Table <ref type="table">4</ref>, where label « is generated by the following grammar:  <ref type="figure">¸</ref> ) denotes execution of a communication over p ¡ o with receive parameters w and matching values v and with substitution to be still applied, Ý and p ¡ o w v denote computational steps corresponding to taking place of forced termination and communication (without pending substitutions), respectively. Hence, a computation from a closed service s 0 is a sequence of connected transitions of the form</p><formula xml:id="formula_5">« :: Ýk (p ¡ o) v (p ¡ o) w p ¡ o w v Ý Table 4. COWS operational semantics kill(k) Ýk 0 (kill) p ¡ o? w s (p¡o) w s (rec) [[ē]] v (inv) p ¡ o!ē (p¡o) v 0 g 1 « s (choice) g 1 • g 2 « s s p¡o x v ¼ w v s ¼ (del sub ) [x] s p¡o w v s ¼ ¡ x v ¼ s Ýk s ¼ (del kill ) [k] s Ý [k] s ¼ s « s ¼ d d(«) s [[kill(d)]] µ « Ý Ýk (del pass ) [d] s « [d] s ¼ s « s ¼ (prot) s « s ¼ s 1 (p¡o) w s ¼ 1 s 2 (p¡o) v s ¼ 2 Å( w v) noc(s 1 s 2 p ¡ o w v) (com) s 1 s 2 p¡o w v s ¼ 1 s ¼ 2 s 1 p¡o w v s ¼ 1 noc(s 2 p ¡ o w v) (par con f ) s 1 s 2 p¡o w v s ¼ 1 s 2 s 1 Ýk s ¼ 1 (par kill ) s 1 s 2 Ýk s ¼ 1 halt(s 2 )</formula><formula xml:id="formula_6">s 1 « s ¼ 1 « ¸(p ¡ o w v) Ýk (par pass ) s 1 s 2 « s ¼ 1 s 2 s s 1 s 1 « s 2 s 2 s ¼ (cong) s « s ¼ In the</formula><formula xml:id="formula_7">s 0 « 1 s 1 « 2 s 2 « 3 s 3</formula><p>where, for each i, « i is either Ý or p ¡ o w v (for some p o w and v); services s i , for each i, will be called reducts of s 0 .</p><p>We comment on salient points. Activity kill(k) forces termination of all unprotected parallel activities (rules (kill) and (par kill )) inside an enclosing <ref type="bibr">[k]</ref> , that stops the killing e«ect by turning the transition label Ýk into Ý (rule (del kill )). Existence of such delimitation is ensured by the assumption that the semantics is only defined for closed services.</p><p>Sensitive code can be protected from killing by putting it into a protection ; this way, s behaves like s (rule (prot)). Similarly, [d] s behaves like s, except when the transition label « contains d or when a kill activity for d is active in s and « does not correspond to a kill activity (rule (del pass )): in such cases the transition should be derived by using rules (del kill ) or (del sub ). In other words, kill activities are executed eagerly. A service invocation can proceed only if the expressions in the argument can be evaluated (rule (inv)). Receive activities can always proceed (rule (rec)) and can resolve choices (rule (choice)). Communication can take place when two parallel services perform matching receive and invoke activities (rule (com)). Communication generates a substitution that is recorded in the transition label (for subsequent application), rather than a silent transition as in most process calculi. If more than one matching receive activity is ready to process a given invoke, then only the more defined one (i.e. the receive that generates the 'smaller' substitution) progresses (rules (com) and (par con f )). This mechanism permits to correlate di«erent service communications thus implicitly creating interaction sessions and can be exploited to model the precedence of a service instance over the corresponding service specification when both can process the same request. When the delimitation of a variable x argument of a receive is encountered, i.e. the whole scope of the variable is determined, the delimitation is removed and the substitution for x is applied to the term (rule (del sub )). Variable x disappears from the term and cannot be reassigned a value. Execution of parallel services is interleaved (rule (par pass )), but when a kill activity or a communication is performed. Indeed, the former must trigger termination of all parallel services (according to rule (par kill )), while the latter must ensure that the receive activity with greater priority progresses (rules (com) and (par con f )). The last rule states that structurally congruent services have the same transitions.</p><p>Examples. We end this section with a few observations and examples aimed at clarifying the peculiarities of our formalism.</p><p>Communication of private names. Communication of private names is standard and exploits scope extension as in -calculus. <ref type="foot" target="#foot_0">1</ref> Receive and invoke activities can interact only if both are in the scopes of the delimitations that bind the variables argument of the receive. Thus, to enable communication of private names, besides their scopes, we must possibly extend the scopes of some variables, as in the following example:</p><formula xml:id="formula_8">[x] (p ¡ o? x s s ¼ ) [n] p ¡ o! n (n fresh) [n] [x] (p ¡ o? x s s ¼ p ¡ o! n ) p¡o x n [n] (s s ¼ ) ¡ x n</formula><p>Notice that the substitution x n is applied to all terms delimited by [x] , not only to the continuation s of the service performing the receive. This accounts for the global scope of variables and permits to easily model the delayed input of fusion calculus <ref type="bibr" target="#b29">[30]</ref>.</p><p>Protected kill activity. The following simple example illustrates the e«ect of executing a kill activity within a protection block:</p><formula xml:id="formula_9">[k] ( s 1 s 2 kill(k) s 3 ) s 4 Ý [k] s 2 s 4</formula><p>where, for simplicity, we assume that halt(s 1 ) halt(s 3 ) 0. In essence, kill(k) terminates all parallel services inside delimitation [k] (i.e. s 1 and s 3 ), except those that are protected at the same nesting level of the kill activity (i.e. s 2 ). Conflicting receive activities. This example shows a persistent service (implemented by mean of replication), that, once instantiated, enables two conflicting receives:</p><formula xml:id="formula_10">£ [x] ( p 1 ¡ o? x s 1 p 2 ¡ o? x s 2 ) p 1 ¡ o! v p 2 ¡ o! v p 1 ¡o x v £ [x] ( p 1 ¡ o? x s 1 p 2 ¡ o? x s 2 ) s 1 ¡ x v p 2 ¡ o? v s 2 ¡ x v p 2 ¡ o! v</formula><p>Now, the persistent service and the created instance, being both able to receive the same tuple v along the endpoint p 2 ¡ o, compete for the request p 2 ¡ o! v . However, our (prioritized) semantics, in particular rule (com) in combination with rule (par con f ), allows only the existing instance to evolve (and, thus, prevents creation of a new instance):</p><formula xml:id="formula_11">£ [x] ( p 1 ¡ o? x s 1 p 2 ¡ o? x s 2 ) s 1 ¡ x v s 2 ¡ x v</formula><p>Message correlation. Consider now uncorrelated receive activities executed by a same instance, like in the following service:</p><formula xml:id="formula_12">£ [x] p 1 ¡ o 1 ? x [y] p 2 ¡ o 2 ? y s</formula><p>The fact that the messages for operations o 1 and o 2 are uncorrelated implies that, e.g., if there are concurrent instances then successive invocations for a same instance can mix up and be delivered to di«erent instances. If one thinks it right, this behaviour can be avoided simply by correlating successive messages by means of some correlation data, e.g. the first received value as in the following service:</p><formula xml:id="formula_13">£ [x] p 1 ¡ o 1 ? x [y] p 2 ¡ o 2 ? y x s</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Modelling Imperative and Orchestration Constructs</head><p>In this section, we present the encoding of some higher level imperative and orchestration constructs (mainly inspired by WS-BPEL). The encodings illustrate flexibility of COWS and somehow demonstrate expressiveness of the chosen set of primitives.</p><p>In the sequel, we will write Z v ¸W to assign a symbolic name Z v to the term W and to indicate the values v occurring within W. Thus, Z v is a family of names, one for each tuple of values v. We use n to stand for the endpoint n p ¡ n o . Sometimes, we write n for the tuple n p n o and rely on the context to resolve any ambiguity.</p><p>Imperative constructs. Due to lack of space, we only present the encodings of those constructs that will be further exploited in the rest of the section. We refer the interested reader to <ref type="bibr" target="#b20">[21]</ref> for deeper explanations and additional encodings. We start adding matching with assignment [ w ē] to COWS basic activities. If w and ē do match, service [ w ē] s returns a substitution that will eventually assign to the variables in w the corresponding values of ē, and service s can proceed. In COWS, this meaning can be rendered through the following encoding (for m fresh)</p><formula xml:id="formula_14">[ w ē] s [ m] ( m!ē m? w s )</formula><p>Notably, the new construct di«ers from standard assignment both because values can occur on the left of , in which case it behaves as a matching mechanism, and because, like the receive activity, it does not bind the variables on the left of , thus it cannot reassign a value to them if a value has already been assigned (more details are in <ref type="bibr" target="#b20">[21]</ref>). Conditional choice is encoded similarly:</p><formula xml:id="formula_15">if (e) then s 1 else s 2 [ m] ( m! e ( m? true s 1 • m? false s 2 ) )</formula><p>where true and false are the values that can result from evaluation of e. Sequential composition can be encoded alike in CCS <ref type="bibr" target="#b25">[26,</ref><ref type="bibr">Chapter 8]</ref> however, due to the asynchrony of invoke and kill activities, the notion of well-termination must be relaxed wrt CCS. Firstly, we settle that services may indicate their termination by exploiting the invoke activity x done ¡ o done ! , where x done is a distinguished variable and o done is a distinguished name. Secondly, we say that a service s is well-terminating if, for every reduct s ¼ of s and partner p, s ¼ ¡ x done p</p><formula xml:id="formula_16">(p¡o done )</formula><p>implies that -either s ¼ « s ¼¼ for some « Ý or « Ýk and s ¼¼ is well-terminating -or s ¼ « s ¼¼ implies « (p ¡ o) v, for some s ¼¼ , p, o and v.</p><p>Notably, well-termination does not demand a service to terminate, but only that whenever the service can perform activity p ¡ o done ! and cannot perform any kill activities, then it terminates except for, possibly, some parallel pending invoke activities. As usual, the encoding relies on the assumption that all calculus operators themselves (in particular, parallel composition) can be rendered as to preserve well-termination. Finally, if we only consider well-terminating services, then, for a fresh p, we can let:</p><formula xml:id="formula_17">s 1 ; s 2 [p] ( s 1 ¡ x done p p ¡ o done ? s 2 )</formula><p>Fault and compensation handlers. Fault handling is strictly related to the notion of compensation, namely the execution of specific activities (attempting) to reverse the e«ects of previously executed activities. We consider here a minor variant of the WS-BPEL compensation protocol. To begin with, we extend COWS syntax as shown in the upper part of Table <ref type="table" target="#tab_4">5</ref>. The scope activity [s : catch( 1 ) s 1 : : catch( n ) s n : s c ] ß permits explicitly grouping activities together. The declaration of a scope activity contains a unique scope identifier ß, a service s representing the normal behaviour, an optional list of fault handlers, and a compensation handler s c . The fault generator activity throw( ) can be used by a service to rise a fault signal . This signal will trigger execution of activity s ¼ , if a construct of the form catch( ) s ¼ exists within the same scope. The compensate activity undo(ß) can be used to invoke a compensation handler of an inner scope named ß that has already completed normally (i.e. without faulting).</p><p>Compensation can only be invoked from within a fault or a compensation handler. As in WS-BPEL, we fix two syntactic constraints: handlers do not contain scope activities and for each undo(ß) occurring in a service there exists at least an inner scope ß.</p><p>In fact, it is not necessary to extend COWS syntax because fault and compensation handling can be easily encoded. The most interesting cases of the encoding are shown in the lower part of Table <ref type="table" target="#tab_4">5</ref> (in the remaining cases, the encoding acts as an homomorphism), where the killer labels used to identify scopes and the introduced partner :</p><formula xml:id="formula_18">catch( n ) s n : s c ] ß (scope) [s : catch( 1 ) s 1 : : catch( n ) s n : s c ] ß k [p 1 p n ] ( catch( 1 ) s 1 k catch( n ) s n k [k ß ] ( s kß ; ( x done ¡ o done ! p ß ¡ o comp ? s c kß ) ) ) catch( ) s k p ¡ o f ault ? [k ¼ ] s k ¼ undo(ß) k p ß ¡ o comp ! x done ¡ o done ! throw( ) k p ¡ o f ault ! x done ¡ o done ! kill(k)</formula><p>names are taken fresh for s, s 1 , . . . , s n and s c . The two distinguished names o f ault and o comp denote the operations for receiving fault and compensation signals, respectively. We are assuming that for each scope identifier or fault signal named n, the partner used to activate scope compensation or fault handling, respectively, is p n . The encoding ¡ k is parameterized by the identifier k of the closest enclosing scope, if any. The parameter is used when encoding a fault generator, to launch a kill activity that forces termination of all the remaining activities of the enclosing scope, and when encoding a scope, to delimit the field of action of inner kill activities. The compensation handler s c of scope ß is installed when the normal behaviour s successfully completes, but it is activated only when signal p ß ¡ o comp ! occurs. Similarly, if during normal execution a fault occurs, a signal p ¡ o f ault ! triggers execution of the corresponding fault handler (if any). Installed compensation handlers are protected from killing by means of . Notably, both the compensate activity and the fault generator activity can immediately terminate (thus enabling possible sequential compositions); this, of course, does not mean that the corresponding handler is terminated.</p><p>Flow graphs. Flow graphs provide a direct and intuitive way to structure workflow processes, where activities executed in parallel can be synchronized by settling dependencies, called (flow) links, among them. At the beginning of a parallel execution, all involved links are inactive and only those activities with no synchronization dependencies can execute. Once all incoming links of an activity are active (i.e., they have been assigned either a positive or negative state), a guard, called join condition, is evaluated. When an activity terminates, the status of the outgoing links, which can be positive, negative or undefined, is determined through evaluation of a transition condition. When an activity in the flow graph cannot execute (i.e., the join condition fails), a join failure fault is emitted to signal that some activities have not completed. An attribute called 'suppress join failure' can be set to yes to ensure that join condition failures do not throw the join failure fault (this e«ect is called Dead-Path Elimination <ref type="bibr" target="#b0">[1]</ref>).</p><p>To express the constructs above, we extend the syntax of COWS as illustrated in the upper part of Table <ref type="table" target="#tab_5">6</ref>. A flow graph activity [ f l] ls is a delimited linked service, where </p><formula xml:id="formula_19">[ f l] ls [ f l] ls ls 1 ls 2 ls 1 ls 2 s µ ( f l ē) s ; [ f l ē] ( jc) yes µ s µ ( f l ē) if ( jc) then s ; [ f l ē] else [outLinkO f (s) false] ( jc) no µ s µ ( f l ē) if ( jc) then s ; [ f l ē] else throw( join f ) È i¾ 1 n p i ¡ o i ? wi s i p 1 ¡ o 1 ? w1 [ Ë j¾ 2 n outLinkO f (s j ) false] s 1 • • p n ¡ o n ? wn [ Ë j¾ 1 n 1 outLinkO f (s j ) false] s n</formula><p>the activities within ls can synchronize by means of the flow links in f l, rendered as (boolean) variables. A linked service is a service equipped with a set of incoming flow links that forms the join condition, and a set of outgoing flow links that represents the transition condition. Incoming flow links and join condition are denoted by ( jc)</p><formula xml:id="formula_20">s j f µ.</formula><p>Outgoing links are represented by µ ( f l i¾I ēi¾I ) where each pair ( f l i e i ) is composed of a flow link f l i and the corresponding transition (boolean) condition e i . Attribute s j f permits suppressing possible join failures. Input-guarded summation replaces binary choice, because we want all the branches of a multiple choice to be considered at once. Again, we show that in fact it is not necessary to extend the syntax because flow graphs can be easily encoded by relying on the capability of COWS of modelling a state shared among a group of activities. The most interesting cases of the encoding are shown in the lower part of Table <ref type="table" target="#tab_5">6</ref>. The encoding exploits the auxiliary function outLinkO f (s), that returns the tuple of outgoing links in s. Flow graphs are rendered as delimited services, while flow links are rendered as variables. A join condition is encoded as a boolean condition within a conditional construct, where the transition conditions are rendered as the assignment [ f l ē]. In case attribute 'suppress join failure' is set to no, a join condition failure produces a fault signal that can be caught by a proper fault handler. Choice among (linked) services is implemented in such a way that, when a branch is selected, the links outgoing from the activities of the discarded branches are set to f alse (the encoding of conditional choice can be modified similarly).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Encoding the Orchestration Language Orc</head><p>We present here the encoding of Orc <ref type="bibr" target="#b27">[28]</ref>, a recently proposed task orchestration language with applications in workflow, business process management, and web service orchestration. Orc expressions are generated by the following grammar: f g :: 0 S (w) E(w) f x g f g g where x :¾ f where S ranges over site names, E over expression names, x over variables, and w over parameters, i.e. variables or values (ranged over by v). Each expression name E has a unique declaration of the form E(x) ¸f . Expressions f x g and g where x :¾ f bind variable x in g.</p><p>We now briefly describe the semantics of Orc expressions (and refer the interested reader to <ref type="bibr" target="#b20">[21]</ref> for a formal account). Evaluation of expressions may call a number of sites and returns a (possibly empty) stream of values. In <ref type="bibr" target="#b27">[28]</ref>, this is formalized through a labelled transition relation, where label indicates an internal event while label !v indicates publication of the value v resulting from evaluating an expression. A site call can progress only when the actual parameter is a value; it elicits one response. While site calls use a call-by-value mechanism, expression calls use a call-by-name mechanism, namely the actual parameter replaces the formal one and then the corresponding expression is evaluated. Symmetric parallel composition f g consists of concurrent evaluations of f and g. Sequential composition f</p><p>x g activates a concurrent copy of g with x replaced by v, for each value v returned by f . Asymmetric parallel composition g where x :¾ f starts in parallel both f and the part of g that does not need x. The first value returned by f is assigned to x and the continuation of f and all its descendants are then terminated.</p><p>The encoding of Orc expressions in COWS exploits function ¡ r shown in Table <ref type="table" target="#tab_6">7</ref>. The function is defined by induction on the syntax of expressions and is parameterized by the communication endpoint r used to return the result of expressions evaluation. Thus, a site call is rendered as an invoke activity that sends a pair made of the parameter of the invocation and the endpoint for the reply along the endpoint Ŝ corresponding to site name S . Expression call is rendered similarly, but we need two invoke activities: Ê! r r¼ activates a new instance of the body of the declaration, while z! w sends the value of the actual parameter (when this value will be available) to the created instance, by means of a private endpoint stored in z received from the encoding of the corresponding expression declaration along the private endpoint r¼ previously sent. Sequential composition is encoded as the parallel composition of the two components sharing a delimited endpoint, where a new instance of the component on the right is created every time that on the left returns a value along the shared endpoint. Symmetric parallel composition is encoded as parallel composition, where the values produced by the two components are sent along the same return endpoint. Finally, asymmetric parallel composition is encoded in terms of parallel composition in such a way that, whenever the encoding of f returns its first value, this is passed to the encoding of g and a kill activity is enabled. Due to its eager semantics, the kill will terminate what remains of the term corresponding to the encoding of f . Moreover, for each site S , we define the service:</p><formula xml:id="formula_21">£ [x y] Ŝ ? x y y! e S x (<label>1</label></formula><formula xml:id="formula_22">)</formula><p>that receives along the endpoint Ŝ a value (stored in x) and an endpoint (stored in y) to be used to send back the result, and returns the evaluation of e S x , an unspecified expression corresponding to S and depending on x.</p><p>Similarly, for each expression declaration E(x) ¸f we define the service: </p><formula xml:id="formula_23">£ [y z] Ê? y z [r] (z! r [x] (r? x f y ) )<label>(2)</label></formula><formula xml:id="formula_24">0 r 0 S (w) r Ŝ ! w r E(w) r [r ¼ ] ( Ê! r r¼ [z] r¼ ? z z! w ) f x g r [r f ] ( f r f £ [x] rf ? x g r ) f g r f r g r g where x :¾ f r [r f x] ( g r [k] ( f r f rf ? x kill(k) ) )</formula><p>Here, the received value (stored in x) is processed by the encoding of the body of the declaration, that is activated as soon as the expression is called. Finally, the encoding of an Orc expression f , written [[ f ]] r, is the parallel composition of f r , of a service of the form (1) or (2) for each site or expression called in f , in any of the expressions called in f , and so on recursively.</p><p>In <ref type="bibr" target="#b20">[21]</ref>, we prove that there is a formal correspondence, based on the operational semantics, between Orc expressions and the COWS services resulting from their encoding. This is another sign of COWS expressiveness because it is known that Orc can express the most common workflow patterns identified in <ref type="bibr" target="#b30">[31]</ref>. By letting s « µ s ¼ to mean that there exist two services, s 1 and s 2 , such that s 1 is a reduct of s, s 1 « s 2 and s ¼ is a reduct of s 2 , the above property can be stated as follows Theorem 1. Given an Orc expression f and an endpoint r,</p><formula xml:id="formula_25">f l ¸ f ¼ implies [[ f ]] r f r s « µ f ¼ r s, where « r v if l !v, and « (p ¡ o w v) if l .</formula><p>The proof (see <ref type="bibr" target="#b20">[21]</ref>) proceeds by induction on the length of the inference of f l ¸ f ¼ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Concluding Remarks</head><p>We have introduced COWS, a formalism for specifying and combining services, while modelling their dynamic behaviour (i.e. it deals with service orchestration rather than choreography). COWS borrows many constructs from well-known process calculi, e.g.</p><p>-calculus, update calculus, StAC i , and L , but combines them in an original way, thus being di«erent from all existing calculi. COWS permits modelling di«erent and typical aspects of (web) services technologies, such as multiple start activities, receive conflicts, routing of correlated messages, service instances and interactions among them.</p><p>The correlation mechanism was first exploited in <ref type="bibr" target="#b31">[32]</ref>, that, however, only considers interaction among di«erent instances of a single business process. Instead, to connect the interaction protocols of clients and of the respective service instances, the calculus introduced in <ref type="bibr" target="#b2">[3]</ref>, and called SCC, relies on explicit modelling of sessions and their dynamic creation (that exploits the mechanism of private names of -calculus). Interaction sessions are not explicitly modelled in COWS, instead they can be identified by tracing all those exchanged messages that are correlated each other through their same contents (as in <ref type="bibr" target="#b13">[14]</ref>). We believe that the mechanism based on correlation sets (also used by WS-BPEL), that exploits business data and communication protocol headers to correlate di«erent interactions, is more robust and fits the loosely coupled world of Web Services better than that based on explicit session references. Another notable di«erence with SCC is that in COWS services are not necessarily persistent.</p><p>Many works put forward enrichments of some well-known process calculus with constructs inspired by those of WS-BPEL. The most of them deal with issues of web transactions such as interruptible processes, failure handlers and time. This is, for example, the case of <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24]</ref> that present timed and untimed extensions of thecalculus, called Û and Û ½ , tailored to study a simplified version of the scope construct of WS-BPEL. Other proposals on the formalization of flow compensation are <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b3">4]</ref> that give a more compact and closer description of the Sagas mechanism <ref type="bibr" target="#b12">[13]</ref> for dealing with long running transactions.</p><p>We have focused on service orchestration rather than on service choreography. In <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref> both aspects are studied. Other approaches are based on the use of schema languages <ref type="bibr" target="#b10">[11]</ref> and Petri nets <ref type="bibr" target="#b14">[15]</ref>. In <ref type="bibr" target="#b17">[18]</ref> a sort of distributed input-guarded choice of join patterns, called smooth orchestrators, gives a simple and e«ective representation of synchronization constructs. The work closest to ours is <ref type="bibr" target="#b21">[22]</ref>, where Û×-Ð ÙÐÙ× is introduced to formalize the semantics of WS-BPEL. COWS represents a more foundational formalism than Û×-Ð ÙÐÙ× in that it does not rely on explicit notions of location and state, it is more manageable (e.g. has a simpler operational semantics) and, at least, equally expressive (as the encoding of Û×-Ð ÙÐÙ× in COWS shows, <ref type="bibr" target="#b20">[21]</ref>). This paper has focussed on showing the descriptive power of COWS. We leave as a future work the task of developing a formal account of its expressiveness. We also plan to develop analytical tools, such as e.g. behavioural equivalences and type systems, supporting services verification. Behavioural equivalences could provide a means to establish formal correspondences between di«erent views (abstraction levels) of a service, e.g. the contract it has to honour and its true implementation. Type systems, possibly based on behavioural types (see e.g. <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17]</ref>), could permit to express and enforce policies of interest for (web) services for, e.g., disciplining resources usage, constraining the sequences of messages accepted by services, ensuring service interoperability and compositionality, guaranteeing absence of deadlock in service composition, checking that interaction obeys a given protocol.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>COWS syntax</figDesc><table><row><cell>s :: kill(k)</cell><cell>u ¡ u ¼ !ē</cell><cell>g</cell><cell>s s</cell><cell>s</cell><cell>[d] s</cell><cell>£ s</cell><cell>(services)</cell></row><row><cell>g :: 0</cell><cell>p ¡ o? w s</cell><cell>g • g</cell><cell></cell><cell></cell><cell></cell><cell cols="2">(input-guarded choice)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>COWS structural congruence (excerpt of laws)</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 .</head><label>3</label><figDesc>Matching rules</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Ýk denotes execution of a request for terminating a term from within the delimitation [k] , (p ¡ o) v and (p ¡ o) w denote execution of invoke and receive activities over the endpoint p ¡ o, respectively, p ¡ o</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>w v for which we let d(p ¡ o</cell><cell>w v) d( ), where</cell></row><row><cell>d( x</cell><cell>v )</cell><cell>x v and d( 1</cell><cell>2 ) d( 1 ) d( w v (if</cell></row></table><note><p>sequel, we use d(«) to denote the set of names, variables and killer labels occurring in «, except for « p ¡ o 2 ). The meaning of labels is as follows:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 .</head><label>5</label><figDesc>Syntax and encoding of fault and compensation handling</figDesc><table><row><cell>s :: . . .</cell><cell>(services)</cell></row><row><cell>throw( )</cell><cell>(fault generator)</cell></row><row><cell>undo(ß)</cell><cell>(compensate)</cell></row><row><cell>[s : catch( 1 ) s 1 :</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6 .</head><label>6</label><figDesc>Syntax and encoding of flow graphs</figDesc><table><row><cell>s ::</cell><cell>[ f l] ls</cell><cell>È</cell><cell>i¾I p i ¡ o i ? wi s i</cell><cell></cell><cell></cell><cell>(services)</cell></row><row><cell>ls :: ( jc)</cell><cell>s j f µ s µ ( f l ē)</cell><cell></cell><cell>s µ ( f l ē)</cell><cell>ls ls</cell><cell></cell><cell>(linked services)</cell></row><row><cell>jc :: true</cell><cell>false</cell><cell>f l</cell><cell>jc</cell><cell>jc jc</cell><cell>jc jc</cell><cell>(join conditions)</cell></row><row><cell>s j f :: yes</cell><cell>no</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(supp. join failure)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 7 .</head><label>7</label><figDesc>Orc encoding</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The variant of -calculus closest to COWS is localised -calculus<ref type="bibr" target="#b24">[25]</ref> and, indeed, in<ref type="bibr" target="#b20">[21]</ref> we define an encoding that enjoys operational correspondence.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We thank the anonymous referees for their useful comments.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work has been supported by the EU project SENSORIA, IST-2 005-016004.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Web Services Business Process Execution Language Version 2.0</title>
		<author>
			<persName><forename type="first">A</forename><surname>Alves</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006-08">August 2006</date>
			<publisher>ØØÔ »»ÛÛÛºÓ × ×¹ÓÔ ÒºÓÖ</publisher>
		</imprint>
		<respStmt>
			<orgName>WS-BPEL TC OASIS</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A calculus for long-running transactions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Laneve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMOODS</title>
		<title level="s">LNCS 2884</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="124" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">SCC: a Service Centered Calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Boreale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bruni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Caires</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>De Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Loreti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ravara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Vasconcelos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WS-FM</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4184</biblScope>
			<biblScope unit="page" from="38" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Comparing two approaches to compensable flow composition</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bruni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Melgratti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3653</biblScope>
			<biblScope unit="page" from="383" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Theoretical foundations for compensations in flow composition languages</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bruni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Melgratti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="209" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Choreography and orchestration: A synergic approach for system design</title>
		<author>
			<persName><forename type="first">N</forename><surname>Busi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lucchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSOC</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3826</biblScope>
			<biblScope unit="page" from="228" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Choreography and orchestration conformance for system design</title>
		<author>
			<persName><forename type="first">N</forename><surname>Busi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lucchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">COORDINATION</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4038</biblScope>
			<biblScope unit="page" from="63" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An operational semantics for StAC, a language for modelling long-running business transactions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">COORDINATION</title>
		<title level="s">LNCS 2949</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="87" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A trace semantics for long-running transactions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25 Years Communicating Sequential Processes</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3525</biblScope>
			<biblScope unit="page" from="133" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the expressive power of polyadic synchronisation in -calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Carbone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma«eis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nordic J. of Computing</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="70" to="98" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A basic contract language for web services</title>
		<author>
			<persName><forename type="first">S</forename><surname>Carpineti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Laneve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3924</biblScope>
			<biblScope unit="page" from="197" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Types as models: model checking message-passing programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rehof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="45" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Salem</surname></persName>
		</author>
		<author>
			<persName><surname>Sagas</surname></persName>
		</author>
		<title level="m">SIGMOD</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="249" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SOCK: a calculus for service oriented computing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Guidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lucchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Busi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSOC</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4294</biblScope>
			<biblScope unit="page" from="327" to="338" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Transforming BPEL to petri nets</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Business Process Management</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3649</biblScope>
			<biblScope unit="page" from="220" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A generic type system for the pi-calculus</title>
		<author>
			<persName><forename type="first">A</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">311</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="121" to="163" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Resource usage analysis for the -calculus</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Suenaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wischik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">In VMCAI</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3855</biblScope>
			<biblScope unit="page" from="298" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Smooth orchestrators</title>
		<author>
			<persName><forename type="first">C</forename><surname>Laneve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Padovani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FoSSaCS</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3921</biblScope>
			<biblScope unit="page" from="32" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Foundations of web transactions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Laneve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FoSSaCS</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3441</biblScope>
			<biblScope unit="page" from="282" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">web-pi at work</title>
		<author>
			<persName><forename type="first">C</forename><surname>Laneve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TGC</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3705</biblScope>
			<biblScope unit="page" from="182" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">A calculus for orchestration of web services (full version)</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lapadula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tiezzi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>Dipartimento di Sistemi e Informatica, Univ. Firenze</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A WSDL-based type system for WS-BPEL</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lapadula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tiezzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">COORDINATION</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4038</biblScope>
			<biblScope unit="page" from="145" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Towards a unifying theory for web services composition</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mazzara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lanese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WS-FM</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4184</biblScope>
			<biblScope unit="page" from="257" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A pi-calculus based semantics for WS-BPEL</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mazzara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lucchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="96" to="118" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On asynchrony in name-passing calculi</title>
		<author>
			<persName><forename type="first">M</forename><surname>Merro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="715" to="767" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communication and concurrency</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A calculus of mobile processes, I and II</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="77" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Computation orchestration: A basis for wide-area computing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Software and Systems Modeling</title>
		<imprint>
			<date type="published" when="2006-05">May 2006</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The update calculus</title>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Victor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AMAST</title>
		<title level="s">LNCS 1349</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="409" to="423" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The fusion calculus: Expressiveness and symmetry in mobile processes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Victor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic in Computer Science</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="176" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Workflow patterns. Distributed and Parallel Databases</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H M</forename><surname>Ter Hofstede</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kiepuszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Barros</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Springer</publisher>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="5" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Towards a formal foundational to orchestration languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Viroli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ENTCS</title>
		<imprint>
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="51" to="71" />
			<date type="published" when="2004">2004</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
