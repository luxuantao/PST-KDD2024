<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Programmable Editor for Developing Structured Documents based on Bidirectional Transformations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zhenjiang</forename><surname>Hu</surname></persName>
							<email>hu@mist.i.u-tokyo.ac.jp</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Tokyo</orgName>
								<address>
									<addrLine>7-3-1 Hongo</addrLine>
									<postCode>113-8656</postCode>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Shin-Cheng</forename><surname>Mu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Tokyo</orgName>
								<address>
									<addrLine>7-3-1 Hongo</addrLine>
									<postCode>113-8656</postCode>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Masato</forename><surname>Takeichi</surname></persName>
							<email>takeichi@mist.i.u-tokyo.ac.jp</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Tokyo</orgName>
								<address>
									<addrLine>7-3-1 Hongo</addrLine>
									<postCode>113-8656</postCode>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Programmable Editor for Developing Structured Documents based on Bidirectional Transformations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8B9D5E7198C0FD1FE8C54E8826AC169F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.1.1 [Programming Techniques]: Applicative (Functional) Programming</term>
					<term>D.1.2 [Programming Techniques]: Automatic Programming-program transformation, program synthesis</term>
					<term>H.4.1 [Information Systems Applications]: Office Automation-spreadsheets, word processing Documentation, Languages View updating, Bidirectional transformation, Functional programming, Document Engineering, Editor</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents a novel editor supporting interactive refinement in the development of structured documents. The user performs a sequence of editing operations on the document view, and the editor automatically derives an efficient and reliable document source and a transformation that produces the document view. The editor is unique in its programmability, in the sense that the transformation can be obtained through editing operations. The main tricks behind are the utilization of the view-updating technique developed in the database community, and a new bidirectional transformation language that cannot only describe the relationship between the document source and its view, but also data dependency in the view.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>XML <ref type="bibr" target="#b5">[5]</ref> has been attracting a tremendous surge of interest as a universal, queryable representation for structured documents. Everyday, a countless number of structured documents in XML are constructed, and so many editors Figure <ref type="figure">1:</ref> A DTD for the Address Book &lt;addrbook&gt; &lt;person&gt; &lt;name&gt; Masato Takeichi &lt;/name&gt; &lt;email&gt; takeichi@acm.org &lt;/email&gt; &lt;tel&gt; +81-3-5841-7430 &lt;/tel&gt; &lt;/person&gt; &lt;person&gt; &lt;name&gt; Zhenjiang Hu &lt;/name&gt; &lt;email&gt; hu@mist.i.u-tokyo.ac.jp &lt;/email&gt; &lt;email&gt; hu@ipl.t.u-tokyo.ac.jp &lt;/email&gt; &lt;tel&gt; +81-3-5841-7411 &lt;/tel&gt; &lt;/person&gt; &lt;person&gt; &lt;name&gt; Shin-Cheng Mu &lt;/name&gt; &lt;email&gt; scm@mist.i.u-tokyo.ac.jp &lt;/email&gt; &lt;tel&gt; +81-3-5841-7411 &lt;/tel&gt; &lt;/person&gt; &lt;/addrbook&gt; Figure 2: An XML Document of the Address Book <ref type="bibr" target="#b23">[23]</ref> are designed and implemented to support the construction of XML documents. This has in part been stimulated by the growth of the Web and e-commerce, where XML has emerged as the de facto standard for representation of structured documents and information interchange. While the existing XML editors are helpful for the creation of the documents, they are rather weak to support development of structured documents in the sense they hardly provide powerful mechanism for dynamic refinement of the structured documents.</p><p>Let us take a close look at the process of using existing editors with an example of construction of an address book. It basically includes three steps: designing a suitable document type, constructing an XML document with the designed type for storing information, and defining a transformation for viewing the document. We may start by defining an address book type (Figure <ref type="figure">1</ref>), which allows an arbitrary number of people's addresses including a name, some email addresses if there are, and a telephone number. Then, we construct an XML document (Figure <ref type="figure" target="#fig_5">2</ref>) of this type to store address information. And finally, we define a transformation (Figure <ref type="figure" target="#fig_0">3</ref>) to display<ref type="foot" target="#foot_0">1</ref> the address book in a friendly way (Figure <ref type="figure">4</ref>), say by sorting persons according to the last names and adding an index of names. Notice the difference between the two XML documents, the original XML document in Figure <ref type="figure" target="#fig_5">2</ref> and the view in Figure <ref type="figure">4</ref>. Besides difference in their structures, the former has no redundant information, while the later does; e.g., the same names appear twice in the view. The result of this development is a structured document with three components: a data type definition, an XML document representing the source data, and a transformation for viewing the data.</p><p>During the development of a structured document, none of the three components is always fixed. Instead, they all keep evolving. It has been observed that document development follows a life-cycle similar to the development of computer programs, in which the document is repeatedly refined. However, the existing editors do not support interactive refinement very well:</p><p>• First, they treat the three components of structured documents independently, which makes it hard to keep them consistent with each other. Take the address book example, if we want to make a change on the data type by splitting the telephone number (tel) into two parts, country code (ccode) and local code (tel), to share the country code, we may refine the document type definition in Figure <ref type="figure">1</ref> to that in Figure <ref type="figure">5</ref>. This refinement requires corresponding changes on the XML document and the transformation, which is difficult.</p><p>• Second, they expect the users to be XML experts knowing DTD, XML, and XSLT for the construction of the three components of structured documents. This may be rather disappointing to those who know very little about XML (for example, those possessing merely some basic knowledge of HTML), but still want to create structured documents in their daily work. In fact, more and more people nowadays want to be able to create their structured documents in a user-friendly manner, pretty much like how spreadsheets are created. The intuitive interface of the latter contributes a lot to its popularity.  In this paper, we propose a novel editor that supports interactive refinement during the development of structured documents. Given a sequence of editing operations on the view together with a data type definition for the final view, an efficient and reliable structured document with the three basic components can be obtained automatically.</p><p>One challenge in design and implementation of such editing system is to find an efficient way for maintaining consistency of the source document and its view even when there is local data dependency in the view. Consider the view in Figure <ref type="figure">4</ref>, we would wish that when the user, for example, adds or deletes a person, the original document in Figure <ref type="figure" target="#fig_5">2</ref> be updated correspondingly. Further more, the changes should also trigger an update of the index of names in Fig- <ref type="figure">ure 4</ref>. We may even wish that when an additional name is added to the index, a fresh, empty person will be added to the person bodies in both the source document and the view.</p><p>The main trick behind our editor is a new bidirectional transformation language describing the relationship among the source data, the view, and the transformation between the source data and the view.</p><p>Our main contributions can be summarized as follows.</p><p>• We, as far as we are aware, are the first to recognize the importance of the view-updating technique for interactive development of structured documents. The view-updating technique <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b1">1]</ref> has been intensively studied in the database community, where modification on the view can be reflected back to the original database. We borrow this technique and use it in the design of our editor with a significant extension not exploited before: editing operations can modify not only the view but also the transformation (from the database to the view).</p><p>• We have designed a powerful language for the specification of the relationship between the original data and the view. Our language is similar to that in <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b12">12]</ref>, extended with a special construct to duplicate data. Lots of efforts were put into handling data dependency within the view. The language is powerful enough to describe the editing operations (insert, delete, move, and copy) as well as other important transformations.</p><p>• We have successfully implemented our idea in a prototype editor. The editor is particularly interesting in its programmability and an unified, presentation-oriented interface for developing the three components through editing operations on the view.</p><p>-Presentation-oriented: we provide a uniform viewbased editing interface for users to construct and refine their documents. -Programmable: transformations can be constructed through interactive editing operations. In fact, thanks to the bidirectional language, the three basic components of structured documents can be automatically derived, after editing the view.</p><p>The rest of the paper is organized as follows. We start by giving a simple definition of structured documents in functional notations in Section 2. After defining the bidirectional transformation language that plays an important role in our editor in Section 3, we propose the design principle and implementation technique in Section 4, and demonstrate how our system can assist development of structured documents in Section 5. Related work and conclusions are given in Sections 6 and 7 respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">STRUCTURED DOCUMENTS</head><p>In this section, we introduce the notations in which we will describe structured documents in this paper. As in the introduction, we may formulate a structured document as a triple (T, D, X):</p><p>• T : the type of the source document;</p><p>• D: the source document;</p><p>• X: the transformation mapping the source document to another document for display. The document displayed to the user is called the view.</p><p>For instance, the structured document in the introduction specifies T using DTD, D using XML, and X using XSLT.</p><p>For conciseness, we choose a Haskell-like <ref type="bibr" target="#b4">[4]</ref> notation to represent structured documents. Other alternatives include HaXML <ref type="bibr" target="#b26">[26]</ref>, XDuce <ref type="bibr" target="#b13">[13]</ref> or CDuce <ref type="bibr" target="#b3">[3]</ref>, languages or libraries designed for specification of XML documents in a functional style.</p><p>For the sake of conciseness and simplicity, we talk about only a subset of XML. We omitted attributes, which should not be too difficult to cope with by some simple extension. We do not have node sharing, not allowing, for example, IDRef in XML for referring to other nodes through a unique identifier. These will be among our future work to do.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Document Types</head><p>We may use Haskell types to represent the types of documents. For instance, we may define the type of the address book in Figure <ref type="figure" target="#fig_5">2</ref>  Any tree so constructed is type-checked by the Haskell type system, which is a good thing for the final document. However, for the interactive refinement of the documents, we should allow inconsistency during document development.</p><p>To this end, we make use of the following generic tree data Tree = N String <ref type="bibr">[Tree]</ref> to represent contents of any XML document, independent of all DTDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Source Documents</head><p>The following gives an example of this representation of the the document source in Figure <ref type="figure" target="#fig_5">2</ref>.</p><formula xml:id="formula_0">addrbook = N "Addrbook" [N "Person" [N "Name" [N "Masato Takeichi" []], N "Email" [N "takeichi@acm.org" []], N "Tel" [N "+81-3-5841-7430" []]], N "Person" [N "Name" [N "Zhenjiang Hu" []],</formula><p>N "Email" [N "hu@mist.i.u-tokyo.ac.jp" [],</p><p>N "hu@ipl.t.u-tokyo.ac.jp" []], N "Tel" [N "+81-3-5841-7411" []]], N "Person"</p><p>[N "Name" [N "Shin-Cheng Mu" []], N "Email" [N "scm@mist.i.u-tokyo.ac.jp" []], N "Tel" [N "+81-3-5841-7430</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>" []]]]</head><p>The generic representation does not distinguish tag names from texts, since both of them are represented by strings. As a matter of fact, we can think of labels attached to inner nodes as tag names, and labels to leaves as text.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Transformation and Views</head><p>We will use the language in Section 3 to specify transformations mapping source documents to views. It is worth noting again that views allow local data dependency while source documents do not allow.</p><p>To give the whole expression of our formulation, we show an example of the transformation description below, which implement the same transformation in Figure <ref type="figure" target="#fig_0">3</ref>.</p><formula xml:id="formula_1">sortX ; applyX [ ] Dup ; applyX [1] (modifyRootX "Index" ; Map keepX) ; copyX [1] [2, 1] ; deleteX ; hoistX "Dup"</formula><p>We will return to explain this transformation after explaining our transformation language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A BIDIRECTIONAL TRANSFORMATION LANGUAGE</head><p>Our editor is view-oriented in that it allows users to develop their structured documents by editing the view. The editor then produces the three components of a structured document automatically. This view-oriented environment requires a mechanism to relate the three components with the view. We borrow the view-updating technique <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b1">1]</ref>, which has been intensively studied in the database community. Given a database and a query which produces a view from the database, the view-updating technique is to reflect view modification upon the database. Though the idea is very similar, there are two major difficulties in using this technique in our view-oriented editor.</p><p>• Our view may contain local data dependency as seen in Figure <ref type="figure">4</ref> where the same name appears twice in the view. This requires synchronization both between the view and the source document and between data and its dependence inside the view.</p><p>• Our view modification should be reflected not only on the source document, but also on the transformation. In other words, the transformation (query) part, which is assumed to be fixed in the existing view-updating technique, should be modifiable in our framework.</p><p>In this section, we present a language in which the document designer specifies the relationship between the source data and the view. The language is an extension to similar languages in <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b12">12]</ref>. It plays an important role in the design of our editor (see Section 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Bidirectionality</head><p>Before explaining our language, we clarify what we mean by being bidirectional. Following the convention in <ref type="bibr" target="#b12">[12]</ref>, we call the type of source documents C (concrete view) and that of target documents A (abstract view). They are both embedded in Tree but we nevertheless distinguish them for clarity. A transformation x defined in X is associated with two functions. The function φx :: C → A maps the concrete view to an abstract view, which is displayed and edited by the user. The function x:: C × A → C takes the original concrete view and the edited abstract view, and returns an updated concrete view. In <ref type="bibr" target="#b12">[12]</ref> they are called get and put respectively.</p><p>We call a transformation x bidirectional if the following two properties hold:</p><formula xml:id="formula_2">GET-PUT-GET : φx (c x a) = a where a = φx c PUT-GET-PUT : c x (φx c ) = c where c = c x a</formula><p>The PUT-GET-PUT property says that if c is a recently updated concrete view, mapping it to its abstract view and immediately performing the backward update does not change its value. Note that this property only needs to hold for those c in the range of x. For an arbitrary c we impose the GET-PUT-GET requirement instead. Let a be the abstract view of c. Updating c with a and taking the abstract view, we get a again.</p><p>In <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b12">12]</ref>, on the other hand, the GET-PUT and PUT-GET properties are required to hold for arbitrary a and c :</p><formula xml:id="formula_3">φx (c x a) = a</formula><p>for any abstract view a c x (φx c ) = c for any concrete view c However, as shown in <ref type="bibr" target="#b12">[12]</ref>, this would imply that φ is injective, which in turn imply that we would have difficulty dealing with duplication. A reasonable definition of φx where x duplicates data would not be injective, since modifying either of the duplicated data should yield the same source.</p><formula xml:id="formula_4">X ::= B { primitives } | X ; X { sequencing } | X ⊗ X { product } | If P X X { conditional branches } | Map X { apply to all children } | Fold X X { fold } B ::= GFun (f, g) { Galoi function pairs } | NFun f { a simple function } | Dup { duplication }</formula><p>Once we introduce duplication into our language, however, an editing action at one location of the abstract view may cause corresponding changes at other locations. Therefore we need an extra φx to perform the change in the abstract view. The two bidirectional properties above guarantees that no further updating is necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Language X</head><p>The syntax of the language X for specifying bidirectional transformation is given in Figure <ref type="figure" target="#fig_3">6</ref>. Primitive transformations are denoted by non-terminal B. They can be composed to form more complicated transformations by one of the combinators defined in X. The language looks very similar to the bidirectional languages proposed in <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b12">12]</ref>. The most important difference lies in the new language construct Dup, which enables description of data dependency inside the view.</p><p>In this section, we will focus on how to use the language to describe transformation of our interest. An important property of the language X is the following theorem, whose proof is omitted due to space limitation.</p><p>Theorem 1 (Bidirectionality of X). Any transformation described in X is bidirectional.</p><p>2</p><p>We omit the proof of the theorem, but we can see its correctness from the explanation of the language below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Primitive Transformations</head><p>Rather than giving a fixed set of primitive transformations as in <ref type="bibr" target="#b12">[12]</ref>, we adopt a general way to define two classes of primitive transformations -the bidirectional primitives (GFun) and the unidirectional ones (NFun). Together with the special primitive Dup, they are described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Duplication</head><p>In the forward direction, the function φ Dup generates two copies of its input.</p><formula xml:id="formula_5">φ Dup c = N "Dup" [c, c]</formula><p>In the backward direction, Dup checks which of the two copies was touched by the user by comparing them with the original view c, and keeps only the changed one.</p><formula xml:id="formula_6">c Dup (N "Dup" [a1, a2]) = a2 if a1 = c = a1 if a2 = c = a1 otherwise</formula><p>Here we assume that the user performs only one editing action before an updating event is triggered. Therefore, if none of a1 and a2 equals c, it must be the case that a1 = a2, because they result from the same editing action. The Dup operator is the only means in X to specify value dependency among different parts of the view -when one of the copies is edited by the user, the other should change as well. This is achieved by a backward update Dup followed by a forward transform φ Dup . The backward phase updates the touched value. The forward phase then overwrites the copies in the abstract view with new values.</p><p>The presence of Dup makes φx, where x uses Dup, a nontotal and non-injective transformation. The function Dup does not satisfy the PUT-GET rule for views not in the range of φ Dup , and is therefore not a well-behaved transform in <ref type="bibr" target="#b12">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bidirectional Primitive Transformations</head><p>A bidirectional primitive GFun (f, g) consists of two functions f and g satisfying:</p><formula xml:id="formula_7">INV1 : f • g • f = f INV2 : g • f • g = g</formula><p>That is, g is the inverse of f in the range of f . The property is satisfied by all Galois-connected pairs of functions, thus the name GFun. The bidirectional semantics of GFun (f, g) is given by</p><formula xml:id="formula_8">φ GFun (f,g) c = f c c GFun (f,g) a = g a</formula><p>In words, the abstract view is obtained by applying f to the concrete view, while the concrete view can be obtained by applying g to the abstract view, ignoring the original concrete view. That φ GFun (f,g) and GFun (f,g) satisfy the bidirectional property is a direct consequence of INV1 and INV2.</p><p>Let us see some useful primitive transformations defined in this way. The simplest transformation is the identity transformation:</p><formula xml:id="formula_9">idX = GFun (id, id)</formula><p>which relates two identical data, and is defined by a pair of two identity functions. In this example, the pair of functions are inverse of each other.</p><p>Another interesting transformation is defined by</p><formula xml:id="formula_10">sortX = GFun (sortT, sortT)</formula><p>which relates the concrete data with the abstract data such that the children of the root in the abstract view are sorted. The function sortT sorts the subtrees of the root, according to the first child value of each subtree. It is clear that sortT is not invertible, but sortT and sortT do satisfy the properties of INV1 and INV2.</p><p>Similarly, we may define other primitive transformations that are useful for manipulating tree locally.</p><p>• swapX i j swaps the ith and jth subtrees of the root.</p><formula xml:id="formula_11">swapX i j = GFun (f, f) where f (N n ts) = N n (take (i -1) ts ++ ts!!j ++ take (j -i -1) (drop i ts) ++ ts!!i ++ drop j ts)</formula><p>• hoistX n: If the root has label n and a single child t, then the result is t.</p><formula xml:id="formula_12">hoistX n = GFun (f, g) where f (N m [t]) = t, if m = n g t = N n [t]</formula><p>Note that f is a partial function. If the input is not in its domain, an error message appears.</p><p>• newRoot n makes the current tree the single child of a new root with label n.</p><formula xml:id="formula_13">newRootX n = GFun (f, g) where f t = N n [t] g (N m [t]) = t, if m = n</formula><p>• exchangeX exchanges the root with the node of the leftmost child tree that has no child.</p><formula xml:id="formula_14">exchangeX = GFun (f, f) where f (N n (N m [ ] : ts)) = N m (N n [ ] : ts)</formula><p>• insertHoleX inserts Ω, a special tree denoting a hole, as the leftmost child of the root.</p><formula xml:id="formula_15">insertHoleX = GFun (f, g) where f (N n ts) = N n (Ω : ts) g (N n (Ω : ts)) = N n ts</formula><p>• deleteHoleX deletes the hole appearing as the leftmost child of the root.</p><formula xml:id="formula_16">deleteHoleX = GFun (f, g) where f (N n (Ω : ts)) = N n ts g (N n ts) = N n (Ω : ts)</formula><p>• replaceHoleX t replaces the hole with tree t.</p><formula xml:id="formula_17">replaceHoleX t = GFun (f, g) where f Ω = t g t = Ω, if t = t</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Restrictive Primitive Transformations</head><p>Not all primitive transformations we wish to have satisfy the properties INV1 and INV2. One example is the constX transformation that does not care about the concrete view but only requires the abstract view to be a constant tree.</p><p>Another example is the numberX transformation that relates the concrete view with the abstract view such that the abstract view shows the number of the children of the root in the concrete view. We specify these transformations using a single function</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>NFun f</head><p>only showing how to map the concrete view to the abstract view. The bidirectional semantics of this kind of transformation can be defined as follows.</p><formula xml:id="formula_18">φ NFun f c = f c c NFun f a = c</formula><p>Notice that c NFun f always returns the original concrete view c, and ignores any change on the abstract view a. Notice also that NFun f does satisfy both the GET-PUT-GET and the PUT-GET-PUT properties, as seen in the following calculations.</p><formula xml:id="formula_19">φ NFun f (c NFun f a) = { Def. of NFun f } φ NFun f c = { by the condition of a } a c x (φx c ) = { Def. of NFun f } c</formula><p>Below are the definitions of the two transformations mentioned above.</p><formula xml:id="formula_20">constX t = NFun (λx. t) numberX = NFun (length • children)</formula><p>One can turn any function f to be a transformation NFun f , though its ability to update the source by editing the view will be hindered. In a sense, transformations defined by NFun f are not really "bidirectional", since all changes on the abstract view are simply ignored. However, it is still very helpful when used together with Dup, which we will see in Section 3.3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Transformation Combinators</head><p>The set of transformation combinators is useful to construct bigger transformations. An informal explanation of these combinators is given in Figure <ref type="figure" target="#fig_4">7</ref>. Most of the combinators are essentially the same as those in <ref type="bibr" target="#b12">[12]</ref>. There are three new combinators, namely duplication, condition, and fold. The duplication combinator is to introduce data dependency inside a document. Different from the reference structure for sharing data, the duplication transformation treats duplicated data and the original in the same way. The condition combinator is used to apply different transformations according to the context or information of the local tree, and the fold combinator is useful for specifying interactive processing of documents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Sequencing</head><p>Given two bidirectional transformations x1 and x2, the transformation x1; x2 informally means "do x1, then do x2". Its bidirectional semantics is given by</p><formula xml:id="formula_21">φx 1 ;x 2 = φx 2 • φx 1 c x 1 ;x 2 a = c x 1 ((φx 1 c) x 2 a)</formula><p>The forward transform φx 1 ;x 2 is simply the sequential composition of φx 1 and φx 2 . To update the concrete view c with a modified abstract view a, we need to know what the intermediate concrete view was. It is computed by φx 1 c. The expression (φx 1 c) x 2 a then computes an intermediate abstract view, which is used to update c with x 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Product</head><p>The product construct x1 ⊗ x2 behaves similar to products in ordinary functional languages, apart from that we are working on trees rather than pairs. The forward transformation is defined by</p><formula xml:id="formula_22">φx 1 ⊗x 2 (N c (c1 : cs)) = N a (a1 : as) where a1 = φx 1 c1 N a as = φx 2 (N c cs).</formula><p>The input tree is sliced into two parts: the left-most child, and the root plus the other children. The transform x1 is applied to the left-most child, while x2 is applied to the rest. The result is then combined together. The backward updating is defined by updating the two slices separately.</p><formula xml:id="formula_23">(N c (c1 : cs)) x 1 ⊗x 2 (N a (a1 : as)) = N c (c 1 : cs )</formula><p>where</p><formula xml:id="formula_24">c 1 = c1 x 1 a1 N c cs = (N c cs) x 2 (N a as).</formula><p>As an example, consider the following transformation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dup ; (numberX ⊗ idX)</head><p>It maps a tree to another such that the new tree consists of not only the original tree but also the number of children of the root in the original tree. Notice the use of Dup together with the primitive transformation numberX. Although the number shown in the new tree is not editable because the transformation numberX is defined in terms of Nfun before, its value can be automatically changed if we remove or add a child to the root of the original tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Conditional Branches</head><p>In the forward direction, the combinator If p x1 x2 applies the transform x1 to the input if the input satisfies the predicate p. Otherwise x2 is applied.</p><formula xml:id="formula_25">φ If p x 1 x 2 c = φx 1 c if p c = φx 2 c otherwise</formula><p>In the backward direction, we check the root label to determine whether to apply x 1 or x 2 to the modified view.</p><formula xml:id="formula_26">c If p x 1 x 2 a = c x 1 a if p c = c x 2 a otherwise</formula><p>For instance, we may write</p><formula xml:id="formula_27">If (λc. sumtree c &gt; 10) Dup idX</formula><p>to duplicate the source tree if the sum of the all the node values is greater than 10, and keep it unchanged otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4">Map</head><p>We define two (higher order) transformation combinators, Map and Fold to recursively transform trees.</p><p>The well-known function map on lists is defined by</p><formula xml:id="formula_28">map f [ ] = [ ] map f (a : x) = f a : map f x</formula><p>The forward transform of Map x simply applies the transformation x to all subtrees of the given tree, leaving the root label unchanged. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.5">Fold</head><p>The transform Fold x1 x2 is defined like a fold on rose trees. The transform x2 is applied to leaves, x1 to internal nodes. Its forward transform is defined by</p><formula xml:id="formula_29">φ Fold x 1 x 2 (N c [ ]) = φx 2 (N c [ ]) φ Fold x 1 x 2 (N c cs) = φ (Map (Fold x 1 x 2 ));x 1 (N c cs)</formula><p>In the base case, we simply apply x2 to the leaf. In the recursive case, Fold x1 x2 is applied to all subtrees of the input tree, before x1 is applied to the result, thus the use of sequencing.</p><p>In the backward direction, we use the cached copy of the concrete view to determine the depth of recursion to go into. Being able to reuse Map and sequencing significantly simplifies the definition.</p><formula xml:id="formula_30">(N c [ ]) Fold x 1 x 2 a = (N c [ ]) x 2 a c Fold x 1 x 2 a = c (Map (Fold x 1 x 2 ));x 1 a</formula><p>If we expand the second clause of the definition, we get (N c cs) Fold Like in sequencing, we need an application of map φ Fold x 1 x 2 to create an intermediate value in order to perform x 1 . The subtrees are then updated using zip Fold x 1 x 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Programming in X</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Editing as Bidirectional Transformation</head><p>With the language X, we are able to define the important editing operations as bidirectional transformations.</p><formula xml:id="formula_31">insertX v = insertHoleX ; (replaceHoleX v) ⊗ idX deleteX = (constX Ω) ⊗ idX ; deleteHoleX modifyRootX n = insertX (N n []) ; exchangeX ; deleteX</formula><p>We may insert some document v as the leftmost child of the root using insertX v, or delete the leftmost child using deleteX, or modify the root node information with a new name n using modifyRootX n.</p><p>Other editing operations like moveX and copyX can be defined via a combination of insertX and deleteX.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Efficiency</head><p>Our formulation of the most important editing operations is very efficient. By efficiency we mean two things. First, we are able to define efficient editing operations. For example, another useful editing operation, keepX, which returns the leftmost subtree, could be naively realized by a sequence of deletion operations. Our language, however, allows the following more efficient definition:</p><formula xml:id="formula_32">keepX = idX ⊗ (constX Ω) ; hoistX (RootΩ)</formula><p>where RootΩ denotes the root node of the Ω tree. Note that the Ω tree is tree with just a single node acting as a hole to be filled. Second, and more important in implementation of our presentation-oriented editors, we can produce as much editable data as possible in the view. There are many ways to define a source-to-view transformation; one may go extremely to define them just as basic transformations in terms of NFun with a non-invertible function. Consider the editing operation insertX defined in Section 3.4.1. One could have defined it as</p><formula xml:id="formula_33">insertX' v = NFun f where f (N n ts) = N n (v : ts)</formula><p>which forbids any modification on the view. The definition of insertX in in Section 3.4.1, on the other hand, imposes no restriction at all on editing of the view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3">An Example</head><p>We consider the specification of the transformation mapping the source document in Figure <ref type="figure" target="#fig_5">2</ref> to the view in Figure <ref type="figure">4</ref>. The major difference between the view and the source document is that the entries in the view are sorted, and the view has an additional index of names. The transformation in XSLT has been given in Figure <ref type="figure" target="#fig_0">3</ref>.</p><p>First, we consider specification of the transformation which applies transformation x to the subtree at path p but leave other parts of the tree unchanged. A path is a sequence of positive integers [a1, a2, . . . , an], denoting the subtree obtained by going into the a1-th child of the root, then into the a2-th child, and so on. For example, [ ] denotes the root node (or the entire tree), and <ref type="bibr" target="#b1">[1]</ref> denotes the first child of the root.</p><formula xml:id="formula_34">applyX [ ] x = x applyX (i : p) x = swapX 1 i ; applyX p x ⊗ idX ; swapX 1 i</formula><p>Note that the applyX behaves as a higher order transformation; it accepts a transformation and returns a new transformation as the result. Now we can code our transformation in X as follows.</p><formula xml:id="formula_35">sortX ; applyX [ ] Dup ; applyX [1] (modifyRootX "Index" ; Map keepX) ; copyX [1] [2, 1] ; deleteX ; hoistX "Dup"</formula><p>We sort the address book according to person's names, duplicate the address book, keep only the name (first child) for each person in the duplicated address book and change the root name to be "Index", copy the list of names to the sorted address book and then delete it, and remove the label of "Dup" due to the duplication operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE PROGRAMMABLE EDITOR</head><p>Our editor serves as a presentation-oriented (view-oriented) environment supporting interactive development of structured documents. It allows users to develop structured documents in a WYSIWYG (what you see is what you get) manner, and automatically produces the three components of a structured document.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Editing Operations</head><p>We consider the following editing operations.</p><formula xml:id="formula_36">E ::= InsertE p v | DeleteE p | CopyE p1 p2 | MoveE p1 p2 | FieldEditE p l | DuplicateE p | TransformE p x</formula><p>They are standard except for the last two operators. For instance, InsertE p v inserts a tree v as the first child of the node at path p, and FieldEditE p l modifies the label of the node at path p to l. The last two new editing operators, DuplicateE p and TransformE p x, are the special features in our editor: DuplicateE p duplicates the tree at path p and the two trees should be kept identical, and TransformE p x applies a bidirectional transformation x to the tree at path p.</p><p>The state of the editor is a triple</p><formula xml:id="formula_37">S = (c, x, a)</formula><p>where c and a denote the internal data and the view respectively, and x denotes a bidirectional transformation. Each state S = (c, x, a) holds the following SYNC property.</p><formula xml:id="formula_38">a = φx c c = c x a</formula><p>This SYNC property expresses the relationship among the three elements in a state, and the bidirectionality of x ensures an automatic adjustment among the three elements in case some of them is modified. To be precise, let (c, x, a) be a given state.</p><p>• If c changes to c , the new state is (c , x, φx c);</p><p>• If x changes to x , the new state is (c, x , φ x c);</p><p>• If a changes to a , the new state is (c x a , x, φx (c x a )).</p><p>We define the following functions for the above adjustments.</p><formula xml:id="formula_39">Acx (c, x, a) = (c, x, φx c) Aa (c, x, a) = Acx (c x a, x, a)</formula><p>Acx adjust the editor state when c or x changes, while Aa adjust the editor state when a changes. The operational semantics of the editing operations is given in Figure <ref type="figure" target="#fig_6">8</ref>. Each editing operation is a state transformer with two steps; transforming some components of the editor state and then adjusting the state to meet the SYNC property. Given the state (c, x, a), the operator InsertE p v is (1) to insert a tree v to the view a by a general tree insertion function insert and accordingly to change the path expressions in the transformation x so that the nodes at these paths refer to the same ones, and then (2) to adjust the state by Aa. Here, insP x p is a function to "increase" some node number in some paths in x. Let p = p1 ++ [a], and p be a path expression in x satisfying p = p1 + + [b]+ + p2 and b &gt; a, then p will be changed to p1 + + [b + 1] + + p2. Other editing operations like deleteE, copyE, moveE, and fieldEditE are defined similarly. The duplicateE and transformE are two editing operations that change the transformation x. Thanks Note the difference between the two forms of editing operations in our editor: editing operations directly manipulating views and editing operations formalized as bidirectional transformations between views. Considering the insertion operator, we have two forms:</p><formula xml:id="formula_40">(InsertE p v) (c, x, a) → Aa (c, incP x p, insert p v a) (DeleteE p) (c, x, a) → Aa (c, decP x p, delete p a) (CopyE p1 p2) (c, x, a) → Aa (c, incP x p2, copy p1 p2 a) (MoveE p1 p2) (c, x, a) → Aa (c, incP (decP x p1) p2, move p1 p2 a) (FieldEditE p l) (c, x, a) → Aa (c, x, fieldEdit p l a) (DuplicateE p) (c, x, a) → Acx (c, (x; applyX p Dup), a) (TransformE p x ) (c, x, a) → Acx (c, (x; applyX p x )), a)</formula><formula xml:id="formula_41">InsertE p v TransformE p (insertX v)</formula><p>The former inserts a tree to the view and propagates this change to other places of the view, while the latter performs an independent insertion on the view, causing no changes elsewhere. Note also that not any editing sequence is valid in our system. For example, the view produced by a restrictive primitive transformation is not editable by InsertE. However, it can be modified by an independent editing operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Deriving Structured Documents</head><p>This section explains how to produce the three components for a structured document after a sequence of editing operations. Recall that in Section 2 the three components of a structured document are the document type, the document source, and the transformation.</p><p>The first two elements of the editor state (c, x, a) almost give the source document and the transformation we want to have. What is remained to do is to find a suitable document type to structure c and to make x a transformation accepting typed document sources. The difficult lies in finding the document type. One possible solution is to use the automatic extraction techniques <ref type="bibr" target="#b6">[6,</ref><ref type="bibr">9]</ref> to extract the document type information from c, however this approach is effective only when there is large amount of sample documents, which is not really suitable in our situation.</p><p>We adopt another approach. We ask the users to provide a type for the view (see our example in Section 5), and we infer types for the document source and the transformation. To do so, we borrow the idea from <ref type="bibr" target="#b20">[20]</ref>, where given a DTD for the XML source data and a query, an inference system derives a tight DTD for the view. Since our transformations are built up upon primitive transformations in terms of GFun (f, g) and NFun f , we can utilize the inference algorithms in <ref type="bibr" target="#b20">[20]</ref>, provided the types for functions used in the primitive transformations are given. We hope to design a language to define the functions used in primitive transformations and derive their types automatically in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Infinite Undo</head><p>Another advantage of bidirectional transformations in our editor is the ability to implement infinite numbers of oper-ations of undo. The following set of equations indicate that for any editing operations, there always exists another editing operation to recover the state.</p><formula xml:id="formula_42">(DeleteE p) ((Insert p v) s) = s (InsertE p (s|p)) ((DeleteE p) s) = s (DeleteE p2) ((CopyE p1 p2) s = s (InsertE p1 (s|p1)) ((DeleteE p2) ((MoveE p1 p2) s)) = s (FieldEditE p (root(s|p))) ((FieldEditE p n) s) = s (undoX) ((DuplicateE p) s) = s (undoX) ((TransformE p) s) = s</formula><p>Here s|p denotes the subtree in the view s at the path p, and root v returns the label of the root node of the tree v. undoX is a new editing operation for undoing the last transformation. Its semantics can be defined by</p><formula xml:id="formula_43">(undoX) (c, x, a) = Acx(c, deleLast x, a)</formula><p>where deleLast is to delete the last added transformation.</p><p>These equations enable us to implement a sequence of undo operations by remembering a sequence of editing operations (for recovering the editor states) rather than a sequence of editor states. This saves much space, making it possible to implement infinite numbers of undo operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EDITING = DEVELOPING</head><p>We view the development of structured documents as the process of constructing a triple (T, D, X) meeting the requirements the designer had in mind. We have implemented in Haskell a prototype editing system for supporting this development. The main purpose of this prototype system is for testing the idea, and the editor has a simple user interface: the system waits for the user to input an editing command, and updates the view upon accepting a command.</p><p>We demonstrate how our editor works by going through the development of the address book in the introduction. From scratch, we start with an empty view with only one node labeled "Root":</p><formula xml:id="formula_44">N "Root" []</formula><p>In the demonstration to follow, we will construct, via interaction with the editor, the triple (T, D, X) like those (but in different notations) in Figures <ref type="figure">1,</ref><ref type="figure" target="#fig_5">2</ref>, and 3, such that the resulting view looks like that in Figure <ref type="figure">4</ref>.</p><p>The node or subtree in focus, on which the user performs editing operations, is selected by a cursor. Here, for simplicity, we use a path to denote the subtree we select.</p><p>The complete list of operations the user can perform on the focused subtrees has been given in Section 4. We will show how all these editing operations are used for developing our address book.</p><p>We first change the label "Root" to "Addrbook" by the FieldEditE operation, N "Addrbook" [] and, by the InsertE operation, we insert a name and some contacts information as a subtree of the root (the node at position [ ]), which could be done by inserting nodes one by one.</p><p>N "Addrbook" [N "Person"</p><p>[N "Name" [N "Masato Takeichi" []], N "Email" [N "takeichi@acm.org" []], N "Tel" [N "+81-3-5841-7430" []]]]</p><p>We may continue to add another person's contacts by copying the subtree rooted at the path <ref type="bibr" target="#b1">[1]</ref> using the CopyE operation. The copied tree becomes a sibling of the original:</p><formula xml:id="formula_45">N "Addrbook" [N "Person" [N "Name" [N "Masato Takeichi" []], N "Email" [N "takeichi@acm.org" []], N "Tel" [N "+81-3-5841-7430" []]], N "Person" [N "Name" [N "Masato Takeichi" []], N "Email" [N "takeichi@acm.org" []], N "Tel" [N "+81-3-5841-7430" []]]]</formula><p>We then change values at the nodes to the second person's name and contacts: It should be noted that we are editing both the source document and the view, though we are not quite aware of this fact so far. The transformation X, is currently simply the identity transformation idX. Now suppose we want to sort persons according to their names, by selecting all the persons and apply the sortX transformation on it via the editing operation TransformE. The result looks like</p><formula xml:id="formula_46">N "Addrbook" [N "Person" [N "Name" [N "Zhenjiang Hu" []], N "Email" [N "hu@mist.i.u-tokyo.ac.jp" []], N "Tel" [N "+81-3-5841-7430" []]], N "Person" [N "Name" [N "Masato Takeichi" []], N "Email" [N "takeichi@acm.org" []], N "Tel" [N "+81-3-5841-7430" []]]]</formula><p>What is sorted is the view. The source remains the same, while the transformation sortX now looks like the function that performs the sorting.</p><p>Next, we want to make an index of names of people in the address book. To do so, we first make a copy of the address book by the DuplicateE operation:</p><formula xml:id="formula_47">N "Dup" [N "Addrbook" [N "Person" [N "Name" [N "Zhenjiang Hu" []], ... ], N "Person" [N "Name" [N "Masato Takeichi" []], ...]], N "Addrbook" [N "Person" [N "Name" [N "Zhenjiang Hu" []], ... ], N "Person" [N "Name" [N "Masato Takeichi" []], ...]]]</formula><p>and then apply the transformation keepX via TransformE to keep only the names from the duplicated address book (and change the tag "Addrbook" to "Index"):</p><formula xml:id="formula_48">N "Dup" [N "Index" [N "Name" [N "Zhenjiang Hu" []], N "Name" [N "Masato Takeichi" []]] N "Addrbook" [N "Person" [N "Name" [N "Zhenjiang Hu" []], ... ], N "Person" [N "Name" [N "Masato Takeichi" []], ...]]]</formula><p>It should be remarked again that the duplication is one of the most important features of our system. It is different from the copy operation, which we performed just now to add a new person in the address book. Copied data are independent from each other. On the other hand, the duplicate operation indicates that the subtree and its duplicate should be synchronized. In this example, deletion, insertion, or modification of a person's information at one side causes corresponding change on the other side, unless we explicitly inform the editor to perform the editing operations independently.</p><p>The keepX transformation used in the TransformE operation in the above, for example, is such an independent transformation. When it was applied to the subtree at <ref type="bibr" target="#b1">[1]</ref> to extract the names, the main address book at <ref type="bibr" target="#b2">[2]</ref> remains unchanged. On the other hand, if we insert the following entry (by the InsertE operation)</p><formula xml:id="formula_49">N "Person" [N "Name" [N "Shin-Cheng Mu" []], N "Email" [N "scm@mist.i.u-tokyo.ac.jp" []], N "Tel" [N "+81-3-5841-7411" []]]</formula><p>to the "Addrbook" subtree at the path <ref type="bibr" target="#b2">[2]</ref> as its last child, the name "Shin-Cheng Mu" will automatically appear in the index of names, resulting in:</p><formula xml:id="formula_50">N "Dup" [N "Index" [N "Name" [N "Zhenjiang Hu" []], N "Name" [N "Shin-Cheng Mu" []]], N "Name" [N "Masato Takeichi" []] N "Addrbook" [N "Person" [N "Name" [N "Zhenjiang Hu" []], ... ], N "Person" [N "Name" [N "Shin-Cheng Mu" []], ...]], N "Person" [N "Name" [N "Masato Takeichi" []], ...]]]</formula><p>Note also that although the entry is inserted (by the user) as the last child of the "Addrbook" in the view, the resulting view has both the entries under the "Addrbook" and the names under the "Index" sorted.</p><p>Finally, we tell the system that the type of the view should be the following We summarize the important features of our programmable editor as follows.</p><p>• Our editor is presentation-oriented (view-oriented), with which the developer can directly edit the view, the exact display of the document. This WYSIWYG style is more friendly than existing editors. Those with little knowledge about XML will feel easy to use this system to develop their structured documents.</p><p>• Our editor allows simple description of data dependency in the view by the DuplicateE operation, and provides an efficient solution to keep consistency of the data in the view. As far as we are aware, this is the first structured document editor with local data synchronization.</p><p>• Our editor integrates the three components of a structured document in the view displayed to the user. The source data and the transformation are gradually built while the user edits the view, before the user finally imposes a type on the view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>There are plenty of XML editors <ref type="bibr" target="#b23">[23]</ref>, which have been designed and implemented for supporting development of structured documents in XML. Most of them, such as XML-Spy <ref type="bibr" target="#b15">[15]</ref>, develop structured documents in the order of DTD, document content, and presentation. These kinds of tools cannot effectively support interactive document development, as strongly argued by researchers <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b25">25]</ref> in the field of document engineering. Moreover, these tools require developers to have much knowledge about DTD, XML and XSLT. In contrary, our editor provides a single integrated WYSIWYG interface, and requires less knowledge about XML. The most related system to ours is Proxima <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b14">14]</ref>, a single presentation-oriented generic editor designed for all kinds of XML-documents and presentations. It is very similar to our system; it is also presentation orient and allows description of transformation and computation over view through editing operations. However, for each transformation and computation, users must prepare two functions to explicitly express the two-way transformation. In contrast, we provide a bidirectional language with the view-updating technique, facilitating bidirectional transformation. Another similar system is the TreeCalc system <ref type="bibr" target="#b24">[24]</ref>, a simple tree version of the spreadsheet system, but it does not support structure modification on the view.</p><p>Our representation of the editor state by a triple (the document source, and transformation, and the view) is inspired by the work on view-updating <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b1">1]</ref> in the database community, where modification on the view can be reflected back to the original database. We borrow this technique with a significant extension that editing operations can modify not only the view but also the query, which is not exploited before. Since our transformation language does not have the JOIN operator, the problem of the costive propagation of deletion and annotation through views <ref type="bibr" target="#b21">[21]</ref> does not happen in our case.</p><p>During the design of the bidirectional transformation language X, much was learnt from the lenses combinators in <ref type="bibr" target="#b12">[12]</ref>, where a semantic foundation and a core programming language for bidirectional transformations on tree-structured data are given. The current lens combinators can clearly specify dependency between a source data and a view, but cannot describe dependency inside a view. This is not the problem in the context of data synchronization, but has to be remedied in our view-oriented editor. It would be interesting to see whether the lens combinators can be enriched with duplication by relaxing the requirement in the "PUT-GET" and "GET-PUT" properties. In contrast, our language with duplication makes dependency clearly described. Another very much related language is that given by Meertens <ref type="bibr" target="#b16">[16]</ref>, which is designed for specification of constraints in the design of user-interfaces. Again the language cannot deal with dependency inside a view.</p><p>Our idea of duplication in X is greatly influenced by the invertible language in <ref type="bibr" target="#b10">[10]</ref>, where duplication is considered as the inverse of equality check and vice versa. In inverse computation, an inverse function computes an input merely from an output, but in bidirectional transformation, a backward updating can use both the output and the old input to compute a new input. Therefore adding duplication to a bidirectional language needs a more involved equality check mechanism. It should be interesting to see if inverse transformation with duplication can implement the view updating, and to compare these two approaches. Some attempt has been made in <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b17">17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>In this paper, we proposed a presentation-oriented editor suitable for interactive development of structured documents. A novel use of the view updating technique in the editor, the duplication construct in our bidirectional language, and the mechanism of changing the transformation through editing operations, play a key role in the design of our editor. The prototyped system with automatic view updating and infinite undos shows the promise of this approach.</p><p>This work is still in an early stage, and there is much work to do. Particularly, rather than designing a new bidirectional language, we are interested to look into the possi-bility of making the existing transformation languages like XSLT to be efficiently bidirectional.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: A Transformation in XSLT</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: A View of the Address Book in XML &lt;!ELEMENT addrbook (ccode, person*)&gt; &lt;!ELEMENT ccode (#PCDATA)&gt; &lt;!ELEMENT person (name, email*, tel)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT email (#PCDATA)&gt; &lt;!ELEMENT tel (#PCDATA)&gt;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>as follows. data Addrbook = Addrbook [Person] data Person = Person (Name, [Email], Tel) data Name = Name String data Email = Email String data Tel = Tel String</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The Language X for Specifying Bidirectional Transformations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>φFigure 7 :</head><label>7</label><figDesc>Figure 7: Intuitive Explanation of Transformation Combinators</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>x 1 x 2 a</head><label>2</label><figDesc>= N c cs where (N c as ) = (N c as) x 1 a as = map φ Fold x 1 x 2 cs cs = zip Fold x 1 x 2 cs as .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: The Operational Semantics of the Editing Operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Name" [N "Masato Takeichi" []], N "Email" [N "takeichi@acm.org" []], N "Tel" [N "+81-3-5841-7430" []]], N "Person" [N "Name" [N "Zhenjiang Hu" []], N "Email" [N "hu@mist.i.u-tokyo.ac.jp" []], N "Tel" [N "+81-3-5841-7430" []]]]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>data</head><label></label><figDesc>Addrbook = Addrbook (Index, [Person]) data Index = Index [Name] data Person = Person (Name, [Email], Tel) data Name = Name String data Email = Email String data Tel = Tel String and our system automatically returns the triple (T, D, X) (written in our notation) similar to those in Figures 1, 2 and 3.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>To simplify our presentation, we consider the view as another XML data. It should be very straightforward to present this XML data in another format with a suitable style-sheet description.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We wish to thank Atsushi Ohori for introducing us the work on the view updating technique, which actually motivated this work. We thank Tetsuo Yokoyama for his remarks on an earlier draft of this paper, to the PSD project members in University of Tokyo for stimulating discussions on the design and implementation of this editor, and to Kento Emoto, Kazutaka Matsuda, and Akimasa Morihata for helping us to implement the prototype system. We are grateful to the referees, who provided detailed and helpful comments.</p><p>This work was partially supported by Comprehensive Development of e-Society Foundation Software Program of the Ministry of Education, Culture, Sports, Science and Technology, Japan.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On views and XML</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM SIGPLAN-SIGACT symposium on Principles of Database Systems</title>
		<meeting>the 18th ACM SIGPLAN-SIGACT symposium on Principles of Database Systems</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Updating semantics of relational views</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bancilhon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Spyratos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="557" to="575" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">CDuce: An XML-centric general-purpose language</title>
		<author>
			<persName><forename type="first">V</forename><surname>Benzaken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Castagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Frisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2003 ACM SIGPLAN International Conference on Functional Programming</title>
		<meeting>2003 ACM SIGPLAN International Conference on Functional Programming</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Introduction to Functional Programming using Haskell</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Bird</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">Tim</forename><surname>Bray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean</forename><surname>Paoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Sperberg-Mcqueen</surname></persName>
		</author>
		<title level="m">Extensible markup language (XML) 1.0</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Schema extraction from XML collections</title>
		<author>
			<persName><forename type="first">Boris</forename><surname>Chidlovskii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the second ACM/IEEE-CS joint conference on Digital libraries</title>
		<meeting>the second ACM/IEEE-CS joint conference on Digital libraries</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="291" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the correct translation of update operations on relational views</title>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="381" to="416" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Interactively editing structured documents</title>
		<author>
			<persName><forename type="first">R</forename><surname>Furuta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Quint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>André</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dissemination, and Design</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="19" to="44" />
			<date type="published" when="1988">1988</date>
			<publisher>Electronic Publishing Origination</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Xtract: a system for extracting document type descriptors from XML documents</title>
		<author>
			<persName><forename type="first">Minos</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aristides</forename><surname>Gionis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyuseok</forename><surname>Shim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2000 ACM SIGMOD international conference on Management of data</title>
		<meeting>the 2000 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="165" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A program inverter for a functional language with equality and constructors</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Glück</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masahiko</forename><surname>Kawabe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Programming Languages and Systems. Proceedings</title>
		<editor>
			<persName><forename type="first">Atsushi</forename><surname>Ohori</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2895</biblScope>
			<biblScope unit="page" from="246" to="264" />
			<date type="published" when="2003">2003</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>Lecture Notes in Computer Science</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Properties and update semantics of consistent views</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Paolini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zicari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="486" to="524" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">A language for bi-directional tree transformations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><forename type="middle">T</forename><surname>Greenwald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">C</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Pierc</surname></persName>
		</author>
		<author>
			<persName><surname>Schmitt</surname></persName>
		</author>
		<idno>MS-CIS-03-08</idno>
		<imprint>
			<date type="published" when="2003-08">August 2003</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer and Information Science University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Regular expression types for XML</title>
		<author>
			<persName><forename type="first">Haruo</forename><surname>Hosoya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jerome</forename><surname>Vouilon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2000 ACM SIGPLAN International Conference on Functional Programming</title>
		<meeting>2000 ACM SIGPLAN International Conference on Functional Programming</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="11" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Implementing a generic editor</title>
		<author>
			<persName><forename type="first">Johan</forename><surname>Jeuring</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd Workshop on Programmable Structured Documents</title>
		<imprint>
			<date type="published" when="2004-02">February 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The Official XMLSPY Handbook</title>
		<author>
			<persName><forename type="first">Larry</forename><surname>Kim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Designing constraint maintainers for user interaction</title>
		<author>
			<persName><forename type="first">Lambert</forename><surname>Meertens</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl/~lambert" />
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">An algebraic approach to bi-directional updating</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Takeichi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004-06">June 2004</date>
		</imprint>
	</monogr>
	<note>submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An injective language for reversible computation</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Takeichi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seventh International Conference on Mathematics of Program Construction (MPC 2004)</title>
		<meeting><address><addrLine>Stirling, Scotland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2004-07">July 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A polymorphic calculus for views and object sharing</title>
		<author>
			<persName><forename type="first">Atsushi</forename><surname>Ohori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keishi</forename><surname>Tajima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM PODS&apos;94</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="255" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">DTD inference for views of XML data</title>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the nineteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</title>
		<meeting>the nineteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="35" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On Propagation of Deletion and Annotation Through Views</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjeev</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang-Chiew</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Symposium on Principles of Database Systems (PODS)</title>
		<meeting>ACM Symposium on Principles of Database Systems (PODS)<address><addrLine>Wisconsin, Madison</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Xprez: A declarative presentation language for XML</title>
		<author>
			<persName><forename type="first">M</forename><surname>Martijn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johan</forename><surname>Schrage</surname></persName>
		</author>
		<author>
			<persName><surname>Jeuring</surname></persName>
		</author>
		<ptr target="http://www.cs.uu.nl/research/projects/proxima/" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">A list of</title>
		<author>
			<persName><surname>Xml Software</surname></persName>
		</author>
		<ptr target="http://www.xmlsoftware.com/editors.html" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Treecalc : Towards programmable structured documents</title>
		<author>
			<persName><forename type="first">Masato</forename><surname>Takeichi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhenjiang</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kazuhiko</forename><surname>Kakehi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yasushi</forename><surname>Hayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shin-Cheng</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keisuke</forename><surname>Nakano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">JSSST Conference on Software Science and Technology</title>
		<imprint>
			<date type="published" when="2003-09">September 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A XML-based multimedia document processing model for content adaptation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Villard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Roisin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Layada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th International Conference on Digital Documents and Electronic Publishing</title>
		<imprint>
			<date type="published" when="2000-09">September 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Haskell and XML: Generic combinators or type-based translation?</title>
		<author>
			<persName><forename type="first">Malcolm</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Runciman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN International Conference on Functional Programming</title>
		<meeting><address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="148" to="159" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
