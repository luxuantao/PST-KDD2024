<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DYNAMIC TYPING WITH DEPENDENT TYPES</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xinming</forename><surname>Ou</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gang</forename><surname>Tan</surname></persName>
							<email>gtan@cs.princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yitzhak</forename><surname>Mandelbaum</surname></persName>
							<email>yitzhakm@cs.princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Walker</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">DYNAMIC TYPING WITH DEPENDENT TYPES</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">10D3306CD3FE876325E6E3F589C4887F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Dependent type systems are promising tools programmers can use to increase the reliability and security of their programs. Unfortunately, dependently-typed programming languages require programmers to annotate their programs with many typing specifications to help guide the type checker. This paper shows how to make the process of programming with dependent types more palatable by defining a language in which programmers have fine-grained control over the trade-off between the number of dependent typing annotations they must place on programs and the degree of compile-time safety. More specifically, certain program fragments are marked dependent, in which case the programmer annotates them in detail and a dependent type checker verifies them at compile time. Other fragments are marked simple, in which case they may be annotationfree and dependent constraints are verified at run time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Dependent type systems are powerful tools that allow programmers to specify and enforce rich data invariants and guarantee that dangerous or unwanted program behaviors never happen. Consequently, dependently-typed programming languages are important tools in global computing environments where users must certify and check deep properties of mobile programs.</p><p>While the theory of dependent types has been studied for several decades, researchers have only recently begun to be able to integrate these rich specification mechanisms into modern programming languages. The major stumbling block in this enterprise is how to avoid a design in which programmers must place so many typing annotations on their programs that the dependent types become more trouble than they are worth. In other words, how do we avoid a situation in which programmers spend so much time writing specifications to guide the type checker that they cannot make any progress coding up the computation they wish to execute?</p><p>The main solution to this problem has been to explicitly avoid any attempt at full verification of program correctness and to instead focus on verification of safety properties in limited but important domains. Hence, Xi and Pfenning <ref type="bibr" target="#b11">[12]</ref> and Zenger <ref type="bibr" target="#b12">[13]</ref> have focused on integer reasoning to check the safety of array-based code and also on simple symbolic constraints for checking properties of data types. Similarly, in their language Vault <ref type="bibr" target="#b4">[5]</ref>, DeLine and Fahndrich use a form of linear type together with dependency to verify properties of state and improve the robustness of Windows device drivers.</p><p>These projects have been very successful, but the annotations required by programming languages involving dependent types can still be a burden to programmers, particularly in functional languages, where programmers are accustomed to using complete type reconstruction algorithms. For instance, one set of benchmarks analyzed by <ref type="bibr">Xi and</ref> Pfenning indicates that programmers can often expect that 10-20 percent of their code will be typing annotations 1 .</p><p>In order to encourage programmers to use dependent specifications in their programs, we propose a language design and type system that allows programmers to add dependent specifications to program fragments bit by bit. More specifically, certain program components are marked dependent, in which case the type checker verifies statically that the programmer has properly maintained dependent typing annotations. Other portions of the program are marked simple and in these sections, programmers are free to write code as they would in any ordinary simply-typed programming language. When control passes between dependent and simple fragments, data flowing from simply-typed code into dependently-typed code is checked dynamically to ensure that the dependent invariants hold.</p><p>This strategy allows programmers to employ a pay-as-you-go approach when it comes to using dependent types. For instance, when first prototyping their system, programmers may avoid dependent types since their invariants and code structure may be in greater flux at that time or they simply need to get the project off the ground as quickly as possible. Later, they may add dependent types piece by piece until they are satisfied with the level of static verification. More generally, our strategy allows programmers to achieve better compile-time safety assurance in a gradual and typesafe way.</p><p>The main contributions of our paper are the following: First, we formalize a sourcelevel dependently-typed functional language with a syntax-directed type checking algorithm. The language admits programs that freely mix both dependently-typed and simply-typed program fragments.</p><p>Second, we formalize the procedure for inserting coercions between higher-order dependently-typed and simply-typed code sections and the generation of intermediatelanguage programs. In these intermediate-language programs, all dynamic checks are explicit and the code is completely dependently typed. We have proven that the translation always produces wellformed dependently-typed code. In other words, we formalize the first stage of a certifying compiler for our language. Our translation is also total under an admissibility requirement on the dependently-typed interface. Any simply-typed code fragment can be linked with a dependently-typed fragment that satisfies this requirement, and the compiler is able to insert sufficient coercions to guarantee safety at run-time. 1 Table <ref type="table">1</ref> from Xi and Pfenning <ref type="bibr" target="#b11">[12]</ref> shows ratios of total lines of type annotations/lines of code for eight array-based benchmarks to be 50/281, 2/33, 3/37, 10/50, 9/81, 40/200, 10/45 and 3/18. Finally, we extend our system with references. We ensure that references and dependency interact safely and prove the correctness of the strategy for mixing simplytyped and dependently-typed code. Proof outlines for all our theorems can be found in our companion technical report <ref type="bibr" target="#b8">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Language Syntax and Overview</head><p>At the core of our system is a dependently-typed lambda calculus with recursive functions, pairs and a set of pre-defined constant symbols. At a minimum, the constants must include booleans true and false as well as conjunction (∧), negation (¬),and equality(=). We use λx : τ 1 . e to denote the function fix f (x : τ 1 ) : τ 2 .e when f does not appear free in e and let x = e 1 in e to denote (λx : τ. e) e 1 .<ref type="foot" target="#foot_0">2</ref>  To specify interesting properties of values programmers can use set types with the form {x : τ b | e}, where e is a boolean term involving x. Intuitively, the type contains all values v with base type τ b such that [v/x]e is equivalent to true. We use {e} as a shorthand for the set type {x : unit | e} when x does not appear free in e. The essential type of τ , τ , is defined below.</p><formula xml:id="formula_0">τ : : = τ b | Πx : τ.τ | τ × τ | {x : τ b | e} e : : = c | x | fix f (x : τ1) : τ2.e |</formula><p>{x :</p><formula xml:id="formula_1">τ b | e} = τ b τ = τ (τ is not a set type)</formula><p>The type-checking algorithm for our language, like other dependently-typed languages, involves deciding equivalence of expressions that appear in types. Therefore, in order for our type system to be both sound and tractable, we cannot allow just any lambda calculus term to appear inside types. In particular, allowing recursive functions inside types makes equivalence decision undecidable, and allowing effectful operations such as access to mutable storage within types makes the type system unsound. To avoid these difficulties, we categorize a subset of the expressions as pure terms. For the purposes of this paper, we limit the pure terms to variables whose essential type is a base type, constants with simple type τ b1 → • • • → τ bn , and application of pure terms to pure terms. Only a pure term can appear in a valid type. Note this effectively limits dependent functions to the form Πx : τ 1 .τ 2 where τ 1 = τ b 3 . A pure term in our system is also a valid run-time expression, as opposed to a compile-time only object.</p><p>As an example of the basic elements of the language, consider the following typing context, which gives types to a collection of operations for manipulating integers (type int) and integer vectors (type intvec).</p><p>.</p><formula xml:id="formula_2">.. -1, 0, 1, ... : int +, -, * : int -&gt; int -&gt; int &lt;, &lt;= : int -&gt; int -&gt; bool type nat = {x:int | 0 &lt;= x} length : intvec -&gt; nat newvec : Πn:nat.{v:intvec | length v = n} sub : Πi:nat.({v:intvec | i &lt; length v} -&gt; int)</formula><p>The newvec takes a natural number n and returns a new integer vector whose length is equal to n, as specified by the set type. The subscript operation sub takes two arguments: a natural number i and an integer vector, and returns the component of the vector at index i. Its type requires i must be within the vector's bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Simple and Dependent Typing.</head><p>To allow programmers to control the precision of the type checker for the language, we add three special commands to the surface language:</p><formula xml:id="formula_3">e : : = • • • | simple{e} | dependent{e} | assert(e, τ )</formula><p>Informally, simple{e} means expression e is only simply well-typed and there is no sufficient annotation for statically verifying all dependent constraints. The type checker must insert dynamic checks to ensure dependent constraints when control passes to a dependent section. For instance, suppose f is a variable that stands for a function defined in a dependently-typed section that requires its argument to have set type {x : int | x ≥ 0}. At application site simple{f e} the type checker must verify e is an integer, but may not be able to verify that it is nonnegative. To guarantee run-time safety, the compiler automatically inserts a dynamic check for e ≥ 0 when it cannot verify this fact statically. At higher types, these simple checks become more general coercions from data of one type to another. On the other hand, dependent{e} directs the type checker to verify e is well-typed taking all of the dependent constraints into consideration. If the type checker cannot verify all dependent constraints statically, it fails and alerts the user. We also provide a convenient utility function assert(e, τ ) that checks at run time that expression e produces a value with type τ .</p><p>Together these commands allow users to tightly control the trade-off between the degree of compile-time guarantee and the ease of programming. The fewer simple or assert commands, the greater the compile-time guarantee, although the greater the burden to the programmer in terms of type annotations. Also, programmers have good control over where potential failures may happen -they can only occur inside a simple scope or at an assert expression.</p><p>For instance, consider the following function that computes dot-product:</p><formula xml:id="formula_4">simple{ let dotprod = λv1.λv2. let f = fix loop n i sum if (i = n) then sum else loop n (i+1) (sum + (sub i v1) * (sub i v2)) in f (length v1) 0 0 in dotprod vec1 vec2 }</formula><p>Function dotprod takes two vectors as arguments and returns the sum of multiplication of corresponding components of the vectors. The entire function is defined within a simple scope so programmers need not add any typing annotations. However, the cost is that the type checker infers only that i is some integer and v1 and v2 are integer vectors. Without information concerning the length of the vectors and size of the integer, the checker cannot verify that the sub operations are in bound. As a result, the compiler will insert dynamic checks at these points.</p><p>As a matter of fact, without these checks the above program would crash if the length of vec1 is greater than that of vec2! To prevent clients of the dotprod function from calling it with such illegal arguments, a programmer can give dotprod a dependent type while leaving the body of the function simply-typed:</p><formula xml:id="formula_5">dependent { let dotprod = λv1:intvec, v2:{v2:intvec | length v1 = length v2}. simple { ... } in dotprod vec1 vec2 }</formula><p>The advantage of adding this typing annotation is that the programmer has formally documented the condition for correct use of the dotprod function. Now the type checker has to prove that the length of vec1 is equal to that of vec2. If this is not the case the error will be detected at compile time.</p><p>Even though the compiler can verify the function is called with valid arguments, it still needs to insert run-time checks for the vector accesses because they are inside a simple scope. To add an extra degree of compile-time confidence, the programmer can verify the function body by placing it completely in the dependent scope and adding the appropriate loop invariant annotation as shown below. With the new typing annotations and some simple integer arithmetic reasoning, our type checker can verify that all the dependent function applications within the function body are well-typed. Once the above code type checks, there can be no failure at run time.</p><p>As illustrated by the example, the compiler has the freedom to insert dynamic checks to explicitly verify dependent constraints at run-time. While the kind of run-TSelf Γ e : τ Γ τ ≤ τ Γ e : τ TSub Figure <ref type="figure">1</ref>. Type rules for the internal language time checks in this example are simple, one has to be careful if the objects passed between dependent and simple sections involve functions, because the dependent constraints may appear at both covariant and contravariant positions. We formalize the process of inserting dynamic checks in the type coercion judgment discussed in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Formal Language Semantics</head><p>We give a formal semantics to our language in two main steps. First, we define a type system for our internal dependently-typed language which contains no dependent{}, simple{} or assert commands. Second, we simultaneously define a syntax-directed type system and translation from the surface programming language into the internal language. We have proven that the translation always generates welltyped internal language terms. Since the latter proof is constructive, our translation always generates expressions with sufficient information for an intermediate language type checker to verify type correctness.</p><p>Internal Language Typing. The judgment Γ e : τ presented in Figure <ref type="figure">1</ref> defines the type system for the internal language. The context Γ maps variables to types and F maps constants to their types. Many of the rules are standard so we only highlight a few. First, the fail expression, which has not been mentioned before is used to safely terminate programs and may be given any type. Dependent function introduction is standard, but there are two elimination rules. In the first case, the function type may be dependent, so the argument must be a pure term (judged by Γ pure e), since only pure terms may appear inside types. In the second case, the argument may be impure so the function must have non-dependent type. When type checking an if statement, the primary argument of the if must be a pure boolean term and this argument (or its negation) is added to the context when checking each branch <ref type="foot" target="#foot_3">4</ref> .</p><p>The type system has a selfification rule (TSelf), which is inspired by dependent type systems developed to reason about modules <ref type="bibr" target="#b6">[7]</ref>. The rule applies a "selfification" function, which returns the most precise possible type for the term, its singleton type. For instance, though x might have type int in the context, self(int, x) produces the type {y : int | y = x}, the type of values exactly equal to x. Also, the constant + might have type int → int → int, but through selfification, it will be given the more precise type Πx : int.Πy : int.{z : int | z = x + y}, the type of functions that add their arguments. Without selfification, the type system would be too weak to do any sophisticated reasoning about variables and values. The selfification function is defined below. Notice that the definition is only upon types that a pure term may have.</p><p>self(τ b , e) = {x :</p><formula xml:id="formula_6">τ b | x = e} self({x : τ b | e }, e) = {x : τ b | e ∧ x = e} self(τ b → τ, e) = Πx : τ b .self(τ, e x)</formula><p>Finally, the type system includes a notion of subtyping, where all reasoning about dependent constraints occur. The technical report <ref type="bibr" target="#b8">[9]</ref> gives the complete subtyping rules. The interesting case is the subtype relation between set types. As stated below, {x :</p><formula xml:id="formula_7">τ b | e 1 } is a subtype of {x : τ b | e 2 }</formula><p>provided that e 1 ⊃ e 2 is true under assumptions in Γ. Term e 1 ⊃ e 2 stands for the implication between two boolean terms.</p><formula xml:id="formula_8">Γ {x : τ b | e1} valid Γ {x : τ b | e2} valid Γ, x : τ b |= e1 ⊃ e2 Γ {x : τ b | e1} ≤ {x : τ b | e2}</formula><p>Here, Γ |= e is a logical entailment judgment that infers truth about the application domains. For example it may infer that n : int |= n ≤ n + 1. We do not want to limit our language to a particular set of application domains so we leave this judgment unspecified but it must obey the axioms of standard classical logic. A precise set of requirements on the logical entailment judgment may be found in the technical report <ref type="bibr" target="#b8">[9]</ref>.</p><p>Surface Language Typing and Translation. We give a formal semantics to the surface language via a type-directed translation into the internal language. The translation has the form Γ w e ; e : τ where e is a surface language expression and e is the resulting internal language expression with type τ . w is a type checking mode which is either dep or sim. In mode dep every dependent constraint must be statically verified, whereas in mode sim if the type checker cannot infer dependent constraints statically it will generate dynamic checks. It is important to note that this judgment is a syntax-directed function with Γ, w and e as inputs and e and τ uniquely determined outputs (if the translation succeeds). In other words, the rules in Figure <ref type="figure">2</ref> defines the type checking and translation algorithm for the surface language.</p><p>Constants and variables are given singleton types if they are pure via the selfification function (ATConstSelf and ATVarSelf), but they are given less precise types otherwise (ATConst and ATVar). To translate a function definition (ATFun), the function body e is first translated into e with type τ 2 . Since this type may not match the annotated result type τ 2 , the type coercion judgment is called to coerce e to τ 2 , possibly inserting run-time checks if the type checking mode is sim.</p><p>The type coercion judgment has the form Γ w e : τ -→ e : τ . It is a function, which given type checking mode w, context Γ, expression e with type τ , and a target type τ , generates a new expression e with type τ . The output expression is equivalent to the input expression aside from the possible presence of run-time checks. We will discuss the details of this judgment in a moment.</p><p>There are two function application rules, distinguished based on whether the argument expression is judged pure or not. If it is pure, rule ATAppPure applies and the argument expression is substituted into the result type. If the argument expression is impure, rule ATAppImpure first coerces the function expression that has a potentially dependent type Πx : τ 1 .τ 2 , to an expression that has a non-dependent function type</p><formula xml:id="formula_9">τ 1 → [τ 2 ] x . [τ ]</formula><p>x returns the type with all occurrences of variable x removed. It is defined on set types as follows and recursively defined according to the type structures for the other types.</p><p>[{y :</p><formula xml:id="formula_10">τ b | e}]x = τ b (x ∈ F V (e)) [{y : τ b | e}]x = {y : τ b | e} (x ∈ F V (e))</formula><p>Note that in both application rules the argument expression's type τ 1 may not match the function's argument type so it is coerced to an expression e 2 with the right type.</p><p>In type checking an if expression, the two branches may be given different types. So they are coerced to a common type τ 1 τ 2 (ATIfPure). Informally, τ 1 τ 2 recursively applies disjunction operation on boolean expressions in set types that appear in covariant positions and applies conjunction operation on those on contravariant positions. For example,</p><formula xml:id="formula_11">{x : int | x &lt; 3} {x : int | x &gt; 10} = {x : int | x &lt; 3 ∨ x &gt; 10} and ({x : int | x &gt; 3} → int) ({x : int | x &lt; 10} → int) = {x : int | x &gt; 3 ∧ x &lt; 10} → int</formula><p>The precise definition for τ 1 τ 2 can be found in the technical report <ref type="bibr" target="#b8">[9]</ref>. The rules for checking and translating dependent{e} and simple{e} expressions simply switch the type checking mode from sim to dep and vice versa. The rule for assert(e, τ ) uses the type coercion judgment to coerce expression e to type τ . Note that the coercion is called with sim mode to allow insertion of run-time checks. Coercion for the base-type case (CBase) is straightforward. An if expression ensures that the invariant expressed by the target set type holds. Otherwise a runtime failure will occur. With the help of the logical entailment judgment, our type system is able to infer that the resulting if expression has the set type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type coercion judgment. The complete rules for the type coercion judgment</head><p>In general, one cannot directly check at run-time that a function's code precisely obeys some behavioral specification expressed by a dependent type. What we can do is ensure that every time the function is called, the function's argument meets the dependent type's requirement, and its body produces a value that satisfies the promised result type. This strategy is sufficient for ensuring run-time safety. The coercion rules for functions are designed to coerce a function from one type to a function with another type, deferring checks on arguments and results until the function is called.</p><p>There are three coercion rules for function types. In all cases the expression that generates the function is evaluated first to preserve the order of effects. Next a new function is constructed with checks on argument and result inserted when necessary. In the case where the new argument type is a subtype of the old one (CFunCo), we only need to convert the function body to the appropriate result type. Otherwise checks must be inserted to make sure the argument has the type the old function expects. This can be done by recursively calling the coercion judgment on the argument x to convert it to a term e x with type τ 1 . When the function's type is not dependent, it can receive e x as an argument (CFunContNonDep). But when it is a dependent function, it cannot receive e x as an argument since e x contains dynamic checks and is impure <ref type="foot" target="#foot_5">5</ref> . Consequently rule CFunContDep uses an if statement to directly check the constraint on the dependent argument x. This is possible because x must be a pure term and hence has a base type. If the check succeeds, x is directly passed to the function. For all the three cases, our type system is able to prove the resulting expression has the target function type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Mutable References</head><p>The addition of mutable references to our language presents a significant challenge. When sharing a reference between simple and dependent code, it is natural to wish to assign the reference a simple type in the simple code and a dependent type in the dependent code, for example int ref and {x:int|x &gt;= 0} ref. However, the inequivalence of these types can lead to unsoundness. Therefore, in our surface language, we define two classes of references, τ ref and τ dref. The former is invariant in its typing, thereby disallowing the transfer of such references between one piece of code and another unless the supplied and assumed types are equal. The latter is more flexible in its typing, but is dynamically checked according to the following two principles: First, the recipient of such a reference is responsible for writing data that maintains the invariants of the reference's donor. Second, the recipient must protect itself by ensuring that data it reads indeed respects its own invariants.</p><p>In the internal language, the τ dref is implemented as a pair of functions:</p><formula xml:id="formula_12">(unit → τ ) × (τ → unit)</formula><p>Intuitively, the first function reads an underlying reference and coerces the value to the right type; the second one coerces the input value to the type of the underlying reference and writes the coerced value into it. We define a type translation (|τ |) to translate surface language types to internal language types. It recursively traverses the type structure of τ and translates any appearance of dynamic references as shown above.</p><p>The coercion rules for references allow translation from an expression of τ ref to an expression of τ dref, or from τ dref to τ dref. But there is no coercion rule from τ dref to τ ref, because an expression with τ dref will potentially incur runtime failures, while an expression with type τ ref will not. Further details of our solution can be found in our companion technical report <ref type="bibr" target="#b8">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Language Properties</head><p>In this section, we present theorems that state formal properties of our language. We leave details of the proofs and precise definitions to the technical report <ref type="bibr" target="#b8">[9]</ref>. First, we proved type safety for the internal language based on a standard dynamic semantics with mutable references:</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>dependent { let dotprod = λv1:intvec, v2:{v2:intvec | length v1 = length v2}. let f = fix loop (n:{n:nat|n = length(v1)}) (i:{i:nat|i &lt;= n}) (sum:int). if (i = n) then sum else loop n (i+1) (sum + (sub i v1) * (sub i v2)) in f (length v1) 0 0 in dotprod vec1 vec2 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Γ 2 Γ 2 Γ 2 Figure 3 .</head><label>2223</label><figDesc>Figure 3. Type coercion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>e e | e, e | π1e | π2e | if e then e else e The language of types includes a collection of base types (τ b ), which must include boolean type and unit type, but may also include other types (like integer) that are important for the application under consideration. Function types have the form Πx : τ 1 .τ 2 and x, the function argument, may appear in τ 2 . If x does not appear in τ 2 , we abbreviate the function type as τ 1 → τ 2 . Note that unlike much recent work on dependent types for practical programming languages, here x is a valid run-time object rather than a purely compile-time index. The reason for this choice is that the compiler will need to generate run-time tests based on types. If the types contain constraints involving abstract compile-time only indices, generation of the run-time tests may be impossible.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The typing annotations τ 2 and τ are unnecessary in these cases.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Non-dependent function τ 1 → τ 2 can still have arbitrary domain type.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>F (c) = τ Γ c : τ TConst Γ(x) = τ Γ x : τ TVar Γ τvalid Γ fail : τ TFail Γ Πx : τ1.τ2 valid Γ, f : Πx : τ1.τ2, x : τ1 e : τ2 Γ fix f (x : τ1) : τ2.e : Πx : τ1.τ2 TFun Γ e1 : Πx : τ1.τ2 Γ e2 : τ1 Γ pure e2 Γ e1 e2 : [e2/x]τ2 TAppPure Γ e1 : τ1 → τ2 Γ e2 : τ1 Γ e1 e2 : τ2 TAppImPure Γ e1 : τ1 Γ e2 : τ2 Γ e1, e2 : τ1 × τ2 TP Γ e : τ1 × τ2 Γ π1e : τ1 TPL Γ e : τ1 × τ2 Γ π2e : τ2 TPR Γ pure e : bool Γ, u : {e} e1 : τ Γ, u : {¬e} e2 : τ Γ if e then e1 else e2 : τ TIf Γ e : τ Γ pure e Γ e : self(τ, e)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Γ pure e : τ is the same as Γ pure e except that it also returns the simple type of the pure termΓ pure c F (c) = τ Γ w c ; c : self(τ, c) ATConstSelf Γ pure c F (c) = τ Γ w c ; c : τ ATConst Γ pure x Γ(x) = τ Γ w x ; x : self(τ, x) ATVarSelf Γ pure x Γ(x) = τ Γ w x ; x : τ ATVar Γ Πx : τ1.τ2 valid Γ = Γ, f : Πx : τ1.τ2, x : τ1 Γ w e ; e : τ 2 Γ w e : τ 2 -→ e : τ2 Γ w fix f (x : τ1) : τ2.e ; fix f (x : τ1) : τ2.e : Πx : τ1.τ2 ATFun Γ w e1 ; e 1 : Πx : τ1.τ2 Γ w e2 ; e 2 : τ 1 Γ w e 2 : τ 1 -→ e 2 : τ1 Γ pure e 2 Γ w e1 e2 ; e 1 e 2 : [e 2 /x]τ2 ATAppPure Γ w e1 ; e 1 : Πx : τ1.τ2 Γ w e 1 : Πx : τ1.τ2 -→ e 1 : τ1 → [τ2]x Γ w e2 ; e 2 : τ 1 Γ w e 2 : τ 1 -→ e 2 : τ1 Γ pure e 2 Γ w e1 e2 ; e 1 e 2 : [τ2]x ATAppImPure Γ w e1 ; e 1 : τ1 Γ w e2 ; e 2 : τ2 Γ w e1, e2 ; e 1 , e 2 : τ1 × τ2 ATProd Γ w e ; e : τ1 × τ2 Γ w π1e ; π1e : τ1 ATProjL Γ w e ; e : τ1 × τ2 Γ w π2e ; π2e : τ2 ATProjR Γ pure e : bool Γ, u : {e} w e1 ; e 1 : τ1 Γ, u : {e} w e 1 : τ1 -→ e 1 : τ1 τ2 Γ, u : {¬e} w e2 ; e 2 : τ2 Γ, u : {¬e} w e 2 : τ2 -→ e 2 : τ1 τ2 Γ w if e then e1 else e2 ; if e then e 1 else e 2 : τ1 τ2 ATIfPure Γ pure e Γ w let x = e in if x then e1 else e2 ; e : τ Γ w if e then e1 else e2 ; e : τ ATIfImPure Γ dep e ; e : τ Γ τ valid Γ sim e : τ -→ e : τ Γ dep assert(e, τ ) ; e : τ ATAssert Γ sim e ; e : τ Γ dep simple{e} ; e : τ ATDynamic Γ dep e ; e : τ Γ sim dependent{e} ; e : τ ATStatic Figure 2. Surface language type checking and translation</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>can be found in Figure3. When the source type is a subtype of the target type, no conversion is necessary (CSub). The remaining coercion rules implicitly assume the subtype relation does not hold, hence dynamic checks must be inserted at appropriate places. Note that those rules require the checking mode be sim; when called with mode dep the coercion judgment is just the subtyping judgment and the type checker is designed to signal a compile-time error when it cannot statically prove the source is a subtype of the target.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>We also cannot simply write let z = ex in y z since the effects in ex do not allow the type system to maintain the proper dependency between x and z in this case.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We are grateful to Daniel Wang for his comments on an earlier version of this work. ARDA grant NBCHC030106, and NSF grants CCR-0238328, and CCR-0306313 have provided support for this research. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of ARDA or the NSF.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Theorem 1 (Type safety) If • e : τ , then e won't get stuck in evaluation.</p><p>The proof is by induction on the length of execution sequence, using standard progress and preservation theorems.</p><p>The soundness of the type-directed translation for the surface language is formalized as the following theorem. For all source programs that are simply well-typed (judged by Γ 0 e : τ ), if the dependent interface Γ satisfies an admissibility requirement co ref(Γ), the translation is total in sim mode:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3 (Completeness of translation) Assuming co ref(Γ) and co ref(F), if</head><p>Γ 0 e : τ , then there exist e and τ such that Γ sim e ; e : τ .</p><p>Informally, co ref(Γ) states that in Γ, unchecked reference type (τ ref) can only appear in covariant positions. The reason for this restriction is that we cannot coerce a checked reference (τ dref) to an unchecked one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>In this paper, we have shown how to include fragments of simply-typed code within the context of a dependently-typed language. In the past, many researchers have examined techniques for including uni-typed code (code with one type such as Scheme code) within the context of a simply-typed language by means of soft typing ( <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b3">4]</ref>). Soft typing infers simple or polymorphic types for programs but not general dependent types.</p><p>Necula et al. <ref type="bibr" target="#b7">[8]</ref> have developed a soft typing system for C, with the goal of ensuring that C programs do not contain memory errors. Necula et al. focus on the problem of inferring the status of C pointers in the presence of casts and pointer arithmetic, which are either safe (well-typed and requiring no checks), seq (well-typed and requiring bounds checking) or dynamic (about which nothing is known). In contrast, we always know the simple type of an object that is pointed to, but may not know about its dependent refinements.</p><p>When dependent types mix with references, one has to be very careful to ensure the system remains sound. Xi and Pfenning <ref type="bibr" target="#b11">[12]</ref> shows how to maintain soundness by using singleton types, and restricting the language of indices that appear in the singleton types. Our approach is similar in that we have designated a subset of terms as pure terms, but different in that we accommodate true dependent types. However, the distinction is minor, and the main contribution of this work is the interaction between the dependently-typed world and the simply-typed world.</p><p>Walker <ref type="bibr" target="#b10">[11]</ref> shows how to compile a simply-typed lambda calculus into a dependentlytyped intermediate language that enforces safety policies specified by simple state ma-chines. However, he does not consider mixing a general dependently-typed language with a simply-typed language or the problems concerning mutable references.</p><p>In earlier work, Abadi et al. <ref type="bibr" target="#b0">[1]</ref> showed how to add a special type dynamic to represent values of completely unknown type and a typecase operation to the simplytyped lambda calculus. Abadi et al. use type dynamic when the simple static type of data is unknown, such as when accessing objects from persistent storage or exchanging data with other programs. Thatte <ref type="bibr" target="#b9">[10]</ref> demonstrates how to relieve the programmer from having to explicitly write Abadi et al.'s typecase operations themselves by having the compiler automatically insert them as we do. In contrast to our work, Thatte does not consider dependent types or how to instrument with mutable references.</p><p>In contract checking systems such as Findler and Felleisen's work <ref type="bibr" target="#b5">[6]</ref>, programmers can place assertions at well-defined program points, such as procedure entries and exits. Findler and Felleisen have specifically looked at how to enforce properties of higher-order code dynamically by wrapping functions to verify function inputs conform to function expectations and function outputs satisfy promised invariants. Our strategy for handling higher-order code is similar. However, Finder and Felleisen's contracts enforce all properties dynamically whereas we show how to blend dynamic mechanisms with static verification.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Dynamic typing in a statically typed language</title>
		<author>
			<persName><forename type="first">Martín</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gordon</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="237" to="268" />
			<date type="published" when="1991-04">April 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Soft typing with conditional types</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><forename type="middle">L</forename><surname>Wimmers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">K</forename><surname>Lakshman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twenty-First ACM Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1994-01">January 1994</date>
			<biblScope unit="page" from="163" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Soft typing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cartwright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="278" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A practical soft type system for Scheme</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cartwright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM transactions on programming languages and systems</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="87" to="152" />
			<date type="published" when="1997-01">January 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Enforcing high-level protocols in low-level software</title>
		<author>
			<persName><forename type="first">Rob</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Fähndrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Programming Language Design and Implementation</title>
		<meeting><address><addrLine>Snowbird, Utah</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="59" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Contracts for higher-order functions</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Findler</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Conference on Functional Programming</title>
		<meeting><address><addrLine>Pittsburgh</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002-10">October 2002</date>
			<biblScope unit="page" from="48" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A type-theoretic approach to higher-order modules with sharing</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Lillibridge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twenty-First ACM Symposium on Principles of Programming Languages</title>
		<meeting><address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-01">January 1994</date>
			<biblScope unit="page" from="123" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Ccured: Type-safe retrofitting of legacy code</title>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Westley</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Programming Languages</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Dynamic typing with dependent types</title>
		<author>
			<persName><forename type="first">Xinming</forename><surname>Ou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gang</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yitzhak</forename><surname>Mandelbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Walker</surname></persName>
		</author>
		<idno>TR-695-04</idno>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Princeton University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Quasi-static typing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thatte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seventeenth ACM Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1990-01">January 1990</date>
			<biblScope unit="page" from="367" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A type system for expressive security policies</title>
		<author>
			<persName><forename type="first">David</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twenty-Seventh ACM Symposium on Principles of Programming Languages</title>
		<meeting><address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-01">January 2000</date>
			<biblScope unit="page" from="254" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Eliminating array bound checking through dependent types</title>
		<author>
			<persName><forename type="first">Hongwei</forename><surname>Xi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Programming Language Design and Implementation</title>
		<meeting><address><addrLine>Montreal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
			<biblScope unit="page" from="249" to="257" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Indexed types</title>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Zenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theoretical Computer Science</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1997-11">November 1997</date>
			<biblScope unit="volume">187</biblScope>
			<biblScope unit="page" from="147" to="165" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
