<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">939E23DA706C6CA638EBAF38AFD3950B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Adaptive Real-Time Level-of-detail-based Rendering for Polygonal Models Julie C. Xia, Jihad El-Sana, Amitabh Varshney</p><p>Abstract-We present an algorithm for performing adaptive real-time level-of-detail-based rendering for triangulated polygonal models. The simplifications are dependent on viewing direction, lighting, and visibility and are performed by taking advantage of image-space, object-space, and frame-to-frame coherences. In contrast to the traditional approaches of precomputing a fixed number of level-of-detail representations for a given object our approach involves statically generating a continuous level-ofdetail representation for the object. This representation is then used at run-time to guide the selection of appropriate triangles for display. The list of displayed triangles is updated incrementally from one frame to the next. Our approach is more effective than the current level-of-detail-based rendering approaches for most scientific visualization applications where there are a limited number of highly complex objects that stay relatively close to the viewer. Our approach is applicable for scalar (such as distance from the viewer) as well as vector (such as normal direction) attributes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The scientific visualization and virtual reality communities have always faced the problem that their "desirable" visualization dataset sizes are one or more orders of magnitude larger than what the hardware can display at interactive rates. Recent research on graphics acceleration for the navigation of such three-dimensional environments has been motivated by attempts to bridge the gap between the desired and the actual hardware performance, through algorithmic and software techniques. This research has involved reducing the geometric and rendering complexities of the scene by using ¯statically computed level-of-detail hierarchies <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b35">[35]</ref>,</p><p>¯visibility-based culling that is statically computed <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b34">[34]</ref> and dynamically computed <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b26">[27]</ref>,</p><p>¯various levels of complexity in shading and illumination models <ref type="bibr" target="#b3">[4]</ref>,</p><p>¯texture mapping <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, and ¯image-based rendering <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b32">[33]</ref>.</p><p>In this paper we will focus on reducing the geometric complexity of a three-dimensional environment by using dynamically computed level-of-detail hierarchies. Research on simplification of general three-dimensional polygonal objects (nonconvex, non-terrain, possibly high genus) has spanned the entire gamut of highly local to global algorithms, with several approaches in between that have both local and global steps.</p><p>Local algorithms work by applying a set of local rules, which primarily work under some definition of a local neighborhood, for simplifying an object. The local rules are iteratively applied under a set of constraints and the algorithm terminates when it is no longer possible to apply the local rule without violating some constraint. The global algorithms optimize the simplification process over the whole object, and are not necessarily limited to Contact Address: Department of Computer Science, State University of New York at Stony Brook, Stony Brook, NY 11794-4400, Email: chaoyu jihad varshney@cs.sunysb.edu the small neighborhood regions on the object. Some of the local approaches have been -vertex deletion by Schroeder et al <ref type="bibr" target="#b31">[32]</ref>, vertex collapsing by Rossignac and Borrel <ref type="bibr" target="#b30">[31]</ref>, edge collapsing by Hoppe et al <ref type="bibr" target="#b25">[26]</ref> and Guéziec <ref type="bibr" target="#b19">[20]</ref>, triangle collapsing by Hamann <ref type="bibr" target="#b20">[21]</ref>, and polygon merging by Hinker and Hansen <ref type="bibr" target="#b23">[24]</ref>. Some of the global approaches have been -redistributing vertices over the surface by Turk <ref type="bibr" target="#b35">[35]</ref>, minimizing global energy functions by Hoppe et al <ref type="bibr" target="#b25">[26]</ref>, using simplification envelopes by Varshney <ref type="bibr" target="#b36">[36]</ref> and Cohen et al <ref type="bibr" target="#b9">[10]</ref>, and wavelets by DeRose et al <ref type="bibr" target="#b13">[14]</ref>. The issue of preservation or simplification of the genus of the object is independent of whether an algorithm uses local rules, or global rules, or both, to simplify. Recent work by He et al <ref type="bibr" target="#b21">[22]</ref> provides a method to perform a controlled simplification of the genus of an object.</p><p>Simplification algorithms such as those mentioned above are iteratively applied to obtain a hierarchy of successively coarser approximations to the input object. Such multiresolution hierarchies have been used in level-of-detail-based rendering schemes to achieve higher frame update rates while maintaining good visual realism. These hierarchies usually have a number of distinct levels of detail, usually to ½¼, for a given object. At run time, the perceptual importance of a given object in the scene is used to select its appropriate level of representation from the hierarchy <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b29">[30]</ref>. Thus, higher detail representations are used when the object is perceptually more important and lower detail representations are used when the object is perceptually less significant. Transitions from one level of detail to the next are typically based on simple image-space metrics such as the ratio of the image-space area of the object (usually implemented by using the projected area of the bounding box of the object) to the distance of the object from the viewer.</p><p>Previous work, as outlined above, is well-suited for virtual reality walkthroughs and flythroughs of large and complex structures with several thousands of objects. Examples of such environments include architectural buildings, airplane and submarine interiors, and factory layouts. However, for scientific visualization applications where the goal often is to visualize one or two highly detailed objects at close range, most of the previous work is not directly applicable. For instance, consider a biochemist visualizing the surface of a molecule or a physician inspecting the iso-surface of a human head extracted from a volume dataset. It is very likely during such a visualization session, that the object being visualized will not move adequately far away from the viewer to allow the rendering algorithm to switch to a lower level of detail. What is desirable in such a scenario is an algorithm that can allow several different levels of details to co-exist across different regions of the same object. Such a scheme needs to satisfy the following two important criteria: 1. It should be possible to select the appropriate levels of detail across different regions of the same object in real time. 2. Different levels of detail in different regions across an object should merge seamlessly with one another without introducing any cracks and other discontinuities.</p><p>In this paper we present a general scheme that can construct such seamless and adaptive level-of-detail representations onthe-fly for polygonal objects. Since these representations are view-dependent, they take advantage of view-dependent illumination, visibility, and frame-to-frame coherence to maximize visual realism and minimize the time taken to construct and draw such objects. Our approach shows how one can adaptively define such levels of detail based on (a) scalar attributes such as distance from the viewpoint and (b) vector attributes such as the direction of vertex normals. An example using our approach is shown in Figure <ref type="figure" target="#fig_1">1</ref>.   <ref type="bibr" target="#b18">[19]</ref> by using a wavelet decomposition of the input data samples. They define wavelet space filters that allow changes to the quality of the surface approximations in locally-defined regions. Thus, the level of detail around any region can adaptively refine in real-time. This work provides a very elegant solution for terrains and other datasets that are defined on a regular grid. Some of the previous work in the area of general surface simplification has addressed the issue of adaptive approximation of general polygonal objects. Turk <ref type="bibr" target="#b35">[35]</ref> and Hamann <ref type="bibr" target="#b20">[21]</ref> have proposed curvature-guided adaptive simplification with lesser simplification in the areas of higher surface curvature. In <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b36">[36]</ref>, adaptive surface approximation is proposed with different amounts of approximation over different regions of the object. Guéziec <ref type="bibr" target="#b19">[20]</ref> proposes adaptive approximation by changing the tolerance volume in different regions of the object. However in all of these cases, once the level of approximation has been fixed for a given region of the object, a discrete level of detail corresponding to such an approximation is statically generated. No methods have been proposed there that allow free intermixing of different levels of detail across an object in real time in response to changing viewing directions.</p><p>Work on surface simplification using wavelets <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref> and progressive meshes <ref type="bibr" target="#b24">[25]</ref> goes a step further. These methods produce a continuous level-of-detail representation for an object in contrast to a set of discrete number of levels of detail. In particular, Hoppe <ref type="bibr" target="#b24">[25]</ref> outlines a method for selective refinementi.e. refinement of a particular region of the object based upon view frustum, silhouette edges, and projected screen-space area of the faces. Since the work on progressive meshes by Hoppe <ref type="bibr" target="#b24">[25]</ref> is somewhat similar to our work we overview his method next and discuss how our method extends it.</p><p>Progressive meshes offer an elegant solution for a continuous resolution representation of polygonal meshes. A polygonal mesh Å Å is simplified into successively coarser meshes Å by applying a sequence of edge collapses. An edge collapse transformation and its dual, the vertex split transformation, is shown in Figure <ref type="figure" target="#fig_2">2</ref>. Thus, a sequence of successive edge collapse transformations yields a sequence of successively simpler meshes:</p><formula xml:id="formula_0">Å ÓÐÐ Ô× ½ Å ½ ÓÐÐ Ô× ¾ Å ½ ÓÐÐ Ô× ¼ Å ¼ (1)</formula><p>We can retrieve the successively higher detail meshes from the simplest mesh Å ¼ by using a sequence of vertex-split transformations that are dual to the corresponding edge collapse transformations:</p><formula xml:id="formula_1">Å ¼ ×ÔÐ Ø¼ Å ½ ×ÔÐ Ø½ Å ½ ×ÔÐ Ø ½ ´ Å Å µ (2)</formula><p>Hoppe <ref type="bibr" target="#b24">[25]</ref> refers to ´Å ¼ ×ÔÐ Ø ¼ ×ÔÐ Ø ½ × Ô Ð Ø ½ µ as a progressive mesh representation. Progressive meshes present a novel approach to storing, rendering, and transmitting meshes by using a continuous-resolution representation. However we feel that there is some room for improvement in adapting them for performing selective refinement in an efficient manner. In particular, following issues have not yet been addressed by progressive meshes: 1. The sequence of edge collapses is aimed at providing good approximations Å to ´ Å Å µ. However, if a sequence of meshes Å are good approximations to Å under some distance metric, it does not necessarily mean that they also provide a "good" sequence of edge collapse transformations for selective refinement. Let us consider a two-dimensional analogy of a simple polygon as shown in Figure <ref type="figure" target="#fig_3">3</ref>. Assume that vertices Ú ¼ Ú Ú and Ú are "important" vertices (under say some perceptual criteria) and can not be deleted. An approach that generates approximations based on minimizing distances to the original polygon will collapse vertices in the order</p><formula xml:id="formula_2">Ú ½ Ú ¾ Ú ¾ Ú ¿ Ú ¿ Ú Ú Ú Ú Ú</formula><p>to get a coarse polygon ´Ú¼ Ú Ú Ú µ . Then if selective refinement is desired around vertex Ú ½ , vertices Ú Ú Ú Ú ¿ Ú ¾ will need to be split in that order before one can get to vertex Ú ½ . An approach that was more oriented towards selective refinement might have col-</p><formula xml:id="formula_3">lapsed Ú ½ Ú ¾ Ú ¿ Ú Ú Ú Ú ¾ Ú Ú</formula><p>Ú for better adaptive results, even though the successive approximations are not as good as the previous ones under the distance metric. 2. Since the edge collapses are defined in a linear sequence, the total number of child links to be traversed before reaching the desired node is Ç´Òµ. 3. No efficient method for incrementally updating the selective refinements from one frame to the next is given. The reverse problem of selective refinement -selective simplification too is not dealt with.</p><p>In this paper we provide a solution to the above issues with the aim of performing real-time adaptive simplifications and refinements. We define a criterion for performing edge collapses that permits adaptive refinement around any vertex. Instead of constructing a series of sequential edge collapses we construct a merge tree over the vertices of mesh Å so that one can reach any child vertex in Ç´ÐÓ Òµ links. We then describe how one can perform incremental updates within this tree to exploit frame-to-frame coherence, view-dependent illumination, and visibility computations using both scalar and vector attributes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. SIMPLIFICATION WITH IMAGE-SPACE FEEDBACK</head><p>Level-of-detail-based rendering has thus far emphasized object-space simplifications with minimal feedback from the image space. The feedback from the image space has been in the form of very crude heuristics such as the ratio of the screenspace area of the bounding box of the object to the distance of the object from the viewer. As a result, one witnesses coarse image-space artifacts such as the distracting "popping" effect when the object representation changes from one level of detail to the next <ref type="bibr" target="#b22">[23]</ref>. Attempts such as alpha-blending between the old and the new levels of detail during such transitions serve to minimize the distraction at the cost of rendering two representations. However alpha blending is not the solution to this problem since it does not address the real cause -lack of sufficient image-space feedback to select the appropriate local level of detail in the object space; it merely tries to cover-up the distracting artifacts.</p><p>Increasing the feedback from the image space allows one to make better choices regarding the level of detail selection in the object-space. We next outline some of the ways in which imagespace feedback can influence the level of detail selection in the object-space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Local Illumination</head><p>Increasing detail in a direction perpendicular to, and proportional to, the illumination gradient across the surface is a good heuristic <ref type="bibr" target="#b1">[2]</ref>. This allows one to have more detail in the regions where the illumination changes sharply and therefore one can represent the highlights and the sharp shadows well. Since surface normals play an important role in local illumination one can take advantage of the coherence in the surface normals to build a hierarchy over a continuous resolution model that allows one to capture the local illumination effects well. We outline in Section IV-C how one can build such a hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Screen-Space Projections</head><p>Decision to keep or collapse an edge should depend upon the length of its screen-space projection instead of its object-space length. At a first glance this might seem very hard to accomplish in real-time since this could mean checking for the projected lengths of all edges at every frame. However, usually there is a significant coherence in the ratio of the image-space length to the object-space length of edges across the surface of an object and from one frame to the next. This makes it possible to take advantage of a hierarchy built upon the the object-space edge lengths for an object. We use an approximation to the screenspace projected edge length that is computed from the objectspace edge length. We outline in Section IV-B how one can build such a hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Visibility Culling</head><p>During interactive display of any model there is usually a significant coherence between the visible regions from one frame to the next. This is especially true of the back-facing polygons that account for almost half the total number of polygons and do not contribute anything to the visual realism. A hierarchy over a continuous resolution representation of an object allows one to significantly simplify the invisible regions of an object, especially the back-facing ones. This view-dependent visibility culling can be implemented in a straightforward manner using the hierarchy on vertex normals discussed in Section IV-C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Silhouette boundaries</head><p>Silhouettes play a very important role in perception of detail. Screen-space projected lengths of silhouette edges (i.e., edges for which one of the adjacent triangles is visible and the other is invisible), can be used to very precisely quantify the amount of smoothness of the silhouette boundaries. A hierarchy built upon a continuous-resolution representation of a object allows one to do this efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. CONSTRUCTION OF MERGE TREE</head><p>We would like to create a hierarchy that provides us a continuous-resolution representation of an object and allows us to perform real-time adaptive simplifications over the surface of an object based upon the image-space feedback mechanisms mentioned in Section III. Towards this end we implement a merge tree over the vertices of the original model. In our current implementation, the merge tree stores the edge collapses in a hierarchical manner. However, as we discuss in Section VII the concept of a merge tree is a very general one and it can be used with other local simplification approaches as well. Note that the merge tree construction is done as an off-line preprocessing step before the interactive visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Basic Approach</head><p>In Figure <ref type="figure" target="#fig_2">2</ref>, the vertex is merged with the vertex Ô as a result of collapsing the edge ´Ô µ. Conversely, during a vertex split the vertex is created from the vertex Ô. We shall henceforth refer to as the child vertex of the parent vertex Ô. The merge tree is constructed upwards from the high-detail mesh Å to a lowdetail mesh Å ¼ by storing these parent-child relationships in a hierarchical manner over the surface of an object.</p><p>At each level Ð of the tree we determine parent-child relationships amongst as many vertices at level Ð as possible. In other words, we try to determine all vertices that can be safely merged based on criterion defined in Section IV-D. The vertices that are determined to be the children remain at level Ð and all the other vertices at level Ð are promoted to level Ð • ½ . Note that the vertices promoted to level Ð • ½ are a proper superset of the parents of the children left behind at level Ð. This is because there are vertices at level Ð that are neither parents nor children. We discuss this in greater detail in the context of regions of influence later in this section. We apply the above procedure recursively at every level until either (a) we are left with a user-specified minimum number of vertices, or (b) we cannot establish any parent-child relationships amongst the vertices at a given level. Case (b) can arise because in determining a parent-child relationship we are essentially collapsing an edge and not all edge collapses are considered legal. For a detailed discussion on legality of edge collapses the interested reader can refer to <ref type="bibr" target="#b25">[26]</ref>.</p><p>Since in an edge collapse only one vertex merges with another, our merge tree is currently implemented as a binary tree.</p><p>To construct a balanced merge tree we note that the effects of an edge collapse are local. Let us define the region of influence of an edge ´Ú¼ Ú ½ µ to be the union of triangles that are adjacent to either Ú ¼ or Ú ½ or both. The region of influence of an edge is the set of triangles that can change as an edge is gradually collapsed to a vertex, for example, in a morphing. Thus, in Figure <ref type="figure" target="#fig_2">2</ref> as vertex merges to vertex Ô, (or Ô splits to ), the changes to the mesh are all limited to within the region of influence of edge ´Ô µ enclosed by Ò ¼ Ò ½ Ò . Note that all the triangles in region of influence will change if vertices Ô and are merged to form an intermediate vertex, say ´Ô • µ ¾. In our current implementation, the position of the intermediate vertex is the same as the position of the parent vertex Ô. However our datastructures can support other values of the intermediate vertex too. Such values could be used, for example, in creating intermediate morphs between two level-of-detail representations.</p><p>To create a reasonably balanced merge tree we try to collapse as many edges as possible at each level such that there are no common triangles in their respective regions of influence. Since this step involves only local checks, we can accomplish this step in time linear in the number of triangles at this level. If we assume that the average degree (i.e. the number of neighboring triangles) of a vertex is , we can expect the number of triangles in an edge's region of influence to be ½¼. After the collapse this number of triangles reduces to . Thus the number of triangles can be expected to reduce roughly by a factor of from a higher-detail level to a lower-detail level. Thus, in an ideal situation, the total time to build the tree will be given by</p><formula xml:id="formula_4">Ò • Ò • ½ Ò ¾ • Ç Ò µ .</formula><p>However, this assumes that we arbitrarily choose the edges to be collapsed. A better alternative is to sort the edges by their edge lengths and collapse the shortest edges first. Collapsing an edge causes the neighboring edges to change their lengths. However as mentioned above, since changes are local we can maintain the sorted edge lengths in a heap for efficient updates. With this strategy one can build the merge tree in time Ç´Ò ÐÓ Òµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Scalar Subtree Attributes</head><p>To allow real-time refinement and simplification we can store at every parent node (i.e. a node that splits off a child vertex) of the merge tree, a range of scalar attributes of the children in the subtree below it. Then image-space feedback can be used to determine if this range of scalar attributes merits a refinement of this node or not. We explain this process of incremental refinement and simplification in greater details in Section V-A.</p><p>In our current implementation every merge tree node Ú stores the Euclidean distances to its child and parent that determine when Ú's child will merge into Ú and when Ú will merge into its parent. The former is called the downswitch distance and the latter is called the upswitch distance. These distances are built up during the merge tree creation stage. If the maximum possible screen-space projection of the downswitch distance at the vertex Ú in the object space is greater than some pre-set threshold, we permit refinement at Ú. However, if the maximum possible screen-space projection of the upswitch distance at Ú in the object space is less than the threshold, it means that this region occupies very little screen space and can be simplified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Vector Subtree Attributes</head><p>Our implementation also allows incremental simplification and refinement based upon the coherences of the surface normals. This allows us to implement view-dependent real-time simplifications based on local illumination and visibility. The regions with low intensity gradients are drawn in lower detail, while the regions with high intensity gradients are drawn in higher detail. Similarly, regions of the object that are backfacing are drawn at a much lower detail then the front-facing regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 4. Bounding cone for normal vectors</head><p>Since we are using frame-to-frame coherences in computing the levels of detail we need to adopt a data-structure that represents the variation in the normal vectors amongst all the descendents of any given vertex. To identify a possible representation, let us consider the idea behind a Gauss map. A Gauss map is a mapping of the unit normals to the corresponding points on the surface of a unit sphere. Thus, all the normal variations in a subtree will be represented by a closed and connected region on the surface of a sphere using a Gauss map. To simplify the computations involved, we have decided to approximate such regions by circles on the surface of the unit sphere, i.e. bounding cones containing all the subtree normal vectors. This is demonstrated in Figure <ref type="figure">4</ref> where the normal vectors in the surface shown on the left are contained within the cone (i.e. a circle on the Gauss map) on the right.</p><p>At the leaf-level, each vertex is associated with a normal-cone whose axis is given by its normal vector and whose angle is zero. As two vertices merge, the cones of the child and parent vertices are combined into a new normal cone that belongs to the parent vertex at the higher level. The idea behind this merging of cones is shown in Figure <ref type="figure">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Merge Tree Dependencies</head><p>By using techniques outlined in Section V-A, one can determine which subset of vertices is sufficient to reconstruct an adaptive level-of-detail for a given object. However, it is not simple to define a triangulation over these vertices and guarantee that the triangulation will not "fold back" on itself or otherwise represent a non-manifold surface (even when the original was not so). Figure <ref type="figure" target="#fig_4">6</ref> shows an example of how an undesirable folding in the adaptive mesh can arise even though all the edge collapses that were determined statically were correct. shows the initial state of the mesh. While constructing the merge tree, b)Merged Parent Cone a) Child Cones Fig. <ref type="figure">5</ref>. Cone merging we first collapsed vertex Ú ¾ to Ú ½ to get mesh and then collapsed vertex Ú ¿ to Ú to get mesh . Now suppose at run-time we determined that we needed to display vertices Ú ½ Ú ¾ , and Ú and could possibly collapse vertex Ú ¿ to Ú . However, if we collapse Ú ¿ to Ú directly, as in mesh D, we get a mesh fold where there should have been none. One could devise elaborate procedures for checking and preventing such mesh fold-overs at run-time. However, such checks involve several floating-point operations and are too expensive to be performed on-the-fly. To solve the above problem we introduce the notion of dependencies amongst the nodes of a merge tree. Thus, the collapse of an edge is permitted only when all the vertices defining the boundary of the region of influence of the edge exist and are adjacent to the edge . As an example, consider Figure <ref type="figure" target="#fig_2">2</ref> Similarly, to make a safe split from Ô to Ô and , we determine the following vertex split dependency: 1. Ô can split to and Ô, only when Ò ¼ Ò ½ Ò are present as neighbors of Ô for display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Ò ¼ Ò ½</head><p>Ò can not split, unless Ô first splits to Ô and . The above dependencies are followed during each vertex-split or edge collapse during real-time simplification. These dependencies are easily identified and stored in the merge tree during its creation. Considering Figure <ref type="figure" target="#fig_4">6</ref> again, we can now see that collapse of vertex Ú ¿ to Ú depends upon the adjacency of vertex Ú ½ to Ú ¿ . If vertex Ú ¾ is present then Ú ½ will not be adjacent to Ú ¿ and therefore Ú ¿ will not collapse to Ú . Although having dependencies might sometimes give lesser simplification than otherwise, it does have the advantage of eliminating the expensive floating-point run-time checks entirely. The basic idea behind merge tree dependencies has a strong resemblance to creating balanced subdivisions of quad-trees as presented by Baum et al in <ref type="bibr" target="#b2">[3]</ref> where only a gradual change is permitted from regions of high simplifications to low simplifications. Details of how these merge tree dependencies are used during run-time are given in Section V-A.</p><p>The pseudocode outlining the data-structure for a merge tree node is given in Figure <ref type="figure">7</ref>. The pseudocode for building and traversing the merge tree is given in Figure <ref type="figure" target="#fig_5">8</ref>. We are representing the triangular mesh by the winged-edge data-structure to maintain the adjacency information.  Once the merge tree with dependencies has been constructed off-line it is easy to construct an adaptive level-of-detail mesh representation at run-time. Real-time adaptive mesh reconstruction involves two phases -determination of vertices that will be needed for reconstruction and determination of the triangulation amongst them. We shall refer to the vertices selected for display at a given frame as display vertices and triangles for display as display triangles. The phases for determination of display vertices and triangles are discussed next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Determination of display vertices</head><p>In this section we outline how we determine the display vertices using the scalar and vector attribute ranges stored with the nodes of the merge tree. We first determine the primary display vertices using the screen-space projections and the normal vector cones associated with merge tree nodes. These are the only vertices that would be displayed if there were no triangulation constraints or mesh-folding problems. Next, from these primary display vertices we determine the secondary display vertices that are the vertices that need to be displayed due to merge tree dependencies to avoid the mesh fold-overs in run-time triangulations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Primary Display Vertices</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Screen-Space Projection</head><p>As mentioned earlier, every merge tree node Ú stores a Euclidean distance for splitting a vertex to its child (downswitch distance) as well as the distance at which it will merge to its parent (upswitch distance). If the maximum possible screen-space projection of the downswitch distance at the vertex Ú in the object space is greater than some pre-set threshold Ì , we permit refinement at Ú and recursively check the children of Ú. However, if the maximum possible screen-space projection of the upswitch distance at Ú in the object space is less than the threshold Ì , it means that this region occupies very little screen space and can be simplified, so we mark Ú as inactive for display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Normal Vectors</head><p>We need to determine the direction and the extent of the normal vector orientation within the subtree rooted at a display vertex, with respect to the viewing direction as well as light source, to accomplish view-dependent local illumination and visibilitybased culling.</p><p>To determine silhouettes and the back-facing regions of an object, we check to see if the normal vector cone at a vertex lies entirely in a direction away from the viewer. If so, this vertex can be marked inactive for display. If not, this vertex is a display vertex and is a candidate for further refinement based on other criteria such as screen-space projection, illumination gradient, and silhouette smoothness. In such a case we recursively check its children. The three possible cases are shown in Figure <ref type="figure">9</ref>.</p><p>Similarly, for normal-based local illumination, such as Phong illumination, we use the range of the reflection vectors and determine whether they contain the view direction or not to determine whether to simplify or refine a given node of the merge tree.</p><p>We follow the procedures outlined above to select all those Silhouette Back-facing Front-facing Fig. <ref type="figure">9</ref>. Selective refinement and simplification using normal cones vertices for display that either (a) are leaf nodes and none of their parents have been marked as inactive, or (b) have their immediate child marked as inactive. This determines the list of primary display vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Secondary Display Vertices</head><p>We follow the merge dependencies from the list of primary display vertices to select the final set of display vertices in the following manner. If a vertex Ú is in the initial list of display vertices and for it to be created (via a vertex split), the vertices Ú ¼ Ú ½ Ú had to be present, we add the vertices</p><formula xml:id="formula_5">Ú ¼ Ú ½ Ú</formula><p>to the list of display vertices and recursively consider their dependencies. We continue this process until no new vertices are added.</p><p>When determining the vertices for display in frame • ½ we start from the vertex list for display used in frame . We have found a substantial frame-to-frame coherence and the vertex display list does not change substantially from one frame to the next. There are minor local changes in the display list on account of vertices either refining or merging with other vertices. These are easily captured by either traversing the merge tree up or down from the current vertex position. The scalar and vector attribute ranges stored in merge tree nodes can be used to guide refinements if the difference in the display vertex lists from one frame to the next becomes non-local for any reason. We compute the list of display vertices for first frame by initializing the list of display vertices for frame ¼ to be all the vertices in the model and then proceeding as above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Determination of display triangles</head><p>If the display triangles for frame are known, determination of the display triangles for frame • ½ proceeds in an interleaved fashion with the determination of display vertices for frame • ½ from frame . Every time a display vertex of frame merges in frame • ½ we simply delete and add appropriate triangles to the list of display triangles as shown in Figure <ref type="figure" target="#fig_6">10</ref>. The case where a display vertex in frame splits for frame • ½ is handled analogously. Incremental determination of display triangles in this manner is possible because of the dependency conditions mentioned in Section IV-D. The list of display triangles for the first frame is obtained by initializing the list for frame ¼ to be all the triangles in the model and then following the above procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RESULTS AND DISCUSSION</head><p>We have tried our implementation on several large triangulated models and have achieved encouraging results. These are summarized in Table <ref type="table" target="#tab_3">I</ref> The images of teapot, bunny, crambin, All of these timings are in milliseconds on a Silicon Graphics Onyx with RE2 graphics, a 194MHz R10000 processor, and 640MB RAM. It is easy to see that the time to traverse the merge tree and construct the list of triangles to be displayed from frame to frame is relatively small. This is because of our incremental computations that exploit image-space, object-space, and frame-to-frame coherences. The above times hold as the user moves through the model or moves the lights around. The triangulation of the model changes dynamically to track the highlights as well as the screen-space projections of the faces.   As can be seen from the merge tree depths, the trees are not perfectly balanced. However, they are still within a small factor of the optimal depths. This factor is the price that has to be paid to incorporate dependencies and avoid the expensive run-time floating-point checks for ensuring good triangulations. For each dataset, we continued the merge tree construction till or fewer vertices were left. As expected, the factor by which the number of vertices decreases from one level to the next tapers off as we reach lower-detail levels since there are now fewer alternatives left to counter the remaining dependency constraints. As an ex-ample, for sphere, only vertices were present at level ¿¼ and it took another ½¾ levels to bring down the number to . If the tree depth becomes a concern one can stop sooner, trading-off the tree traversal time for the display time.</p><p>An interesting aspect of allowing dependencies in the merge tree is that one can now influence the characteristics of the run-time triangulation based upon static edge-collapse decisions during pre-processing. As an example, we have implemented avoidance of slivery (long and thin) triangles in the run-time triangulation. As Guéziec <ref type="bibr" target="#b19">[20]</ref>, we quantify the quality of a triangle with area and lengths of the three sides Ð ¼ Ð ½ and Ð ¾ based on the following formula:</p><formula xml:id="formula_6">ÉÙ Ð ØÝ Ô ¿ Ð ¾ ¼ • Ð ¾ ½ • Ð ¾ ¾ (<label>3</label></formula><formula xml:id="formula_7">)</formula><p>Using Equation 3 the quality of a degenerate triangle evaluates to ¼ and that of an equilateral triangle to ½. We classify all edge collapses that result in slivery triangles to be invalid, trading-off quantity (amount of simplification) for quality. One of the advantages of using normal cones for back-face simplification and silhouette definition is that it allows the graphics to focus more on the regions of the object that are perceptually more important. Thus, for instance, for generating the given image of the molecule crambin, 8729 front-facing vertices were traversed as compared to 3361 backfacing vertices; 1372 were classified as silhouette vertices. Similarly, for the model of phone, our approach traversed 6552 front-facing vertices compared to only 1300 backfacing vertices; 900 were classified as silhouette vertices.</p><p>Clearly, there is a tradeoff here between image-quality and amount of simplification achieved. The results for our simplifications given in this section correspond to the images that we thought were comparable to the images from the original highest detail models. Higher levels of simplifications (that are faster to incrementally compute and display) with correspondingly lower quality images are obviously possible, allowing easy implementations of progressive refinement for display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSIONS AND FUTURE WORK</head><p>We have outlined a simple approach to maintain dynamically adaptive level of detail triangulations. Crucial to this approach Highest detail Simplified is the notion of merge trees that are computed statically and are used during run-time to take advantage of the incremental changes in the triangulation. In our current implementation we are using the method of edge collapses. However the idea behind merge trees is pretty general and can be used in conjunction with other local heuristics for simplification such as vertex deletion and vertex collapsing. We plan to study some of these other heuristics in the future and compare them with our current implementation that uses edge collapses. At present we do not store color ranges at the nodes of the merge tree. Storing and using these should improve the quality of the visualizations produced using merge trees even further. Also of some interest will be techniques that create better balanced merge trees while still incorporating dependencies. We plan to investigate these issues further.</p><p>Of course, our approach also makes dynamically-specified manual simplifications possible, where the user can interactively specify the amounts of approximation desired at various regions of the object. Using this, certain parts of the object can be rendered at lower or higher details than otherwise. However, in this paper we have only considered automatic object simplifications during interactive display.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>(a) Sphere with 8192 triangles (uniform LOD) (b) Sphere with 512 triangles (uniform LOD) (c) Sphere with 537 triangles (adaptive LOD)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Uniform and adaptive levels of detail</figDesc><graphic coords="2,53.40,522.44,107.23,108.70" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Edge collapse and vertex split</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Good versus efficient selective simplification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Mesh folding problem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Pseudocode for building and traversing the merge tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Display triangle determination</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Dynamic adaptive simplification for the head of the Dragon</figDesc><graphic coords="8,46.80,487.71,115.20,87.75" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Dynamic adaptive simplification for the Buddha</figDesc><graphic coords="9,77.76,65.83,216.47,323.99" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>. Vertex can merge with vertex Ô only when the vertices Ò ¼ Ò ½ Ò exist and are adjacent to Ô and . From this we determine the following edge collapse dependencies, restricting the level difference between adjacent vertices: 1. can collapse to Ô, only when Ò ¼ , Ò ½ , . . . , Ò are present as neighbors of Ô and for display. 2.</figDesc><table /><note><p>Ò ¼ Ò ½ Ò can not merge with other vertices, unless first merges with Ô.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE I ADAPTIVE</head><label>I</label><figDesc>LEVEL OF DETAIL GENERATION TIMES</figDesc><table /><note><p>Highest detail model -bottom light source Dynamic adaptive simplification -top light source Dynamic adaptive simplification -top light source</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to acknowledge several useful discussions with Arie Kaufman and Greg Turk. We should like to thank Greg Turk, Marc Levoy, and the Stanford University Computer Graphics laboratory for generously sharing models of the bunny, the phone, the dragon, and the happy Buddha. We should also like to acknowledge the several useful suggestions made by the anonymous reviewers that have helped improve the presentation of this paper. This work has been supported in part by the National Science Foundation CAREER award CCR-9502239 and a fellowship from the Fulbright/Israeli Arab Scholarship Program.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Increasing Update Rates in the Building Walkthrough System with Automatic Model-Space Subdivision and Potentially Visible Set Calculations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Airey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="27599" to="23175" />
			<pubPlace>Chapel Hill, NC</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of North Carolina at Chapel Hill, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Towards image realism with interactive update rates in complex virtual building environments</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Airey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Rohlf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Brooks</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (1990 Symposium on Interactive 3D Graphics)</title>
		<imprint>
			<date type="published" when="1990-03">March 1990</date>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
	<note>Rich Riesenfeld and Carlo Sequin</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Making radiosity usable: Automatic preprocessing and meshing techniques for the generation of accurate radiosity solutions</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Baum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Winget</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings of SIGGRAPH&apos;91</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="51" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Image rendering by adaptive refinement</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bergman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Grant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Spach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings of SIGGRAPH&apos;86</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="29" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Simulation of wrinkled surfaces</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Blinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;78</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="286" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Texture and reflection in computer generated images</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Blinn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Newell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="542" to="547" />
			<date type="published" when="1976-10">October 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Quicktime VR -an image-based approach to virtual environment navigation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Annual Conference Series (SIGGRAPH &apos;95)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="29" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">View interpolation for image synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;93 Proceedings)</title>
		<imprint>
			<date type="published" when="1993-08">August 1993</date>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="279" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Hierarchical geometric models for visible surface algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="547" to="554" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Simplification envelopes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jr</forename></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">V</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH, ACM Press</publisher>
			<date type="published" when="1996-08-09">August 4-9, 1996. August 1996</date>
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH &apos;96</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">System strategies to optimize CIG image content</title>
		<author>
			<persName><forename type="first">M</forename><surname>Cosman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schumacker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Image II Conference</title>
		<meeting>the Image II Conference<address><addrLine>Scottsdale, Arizona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981-12">June 10-12 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A more flexible image generation environment</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">C</forename><surname>Crow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings of SIGGRAPH&apos;82</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="9" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Navigating static environments using image-space simplification and morphing</title>
		<author>
			<persName><forename type="first">L</forename><surname>Darsa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, 1997 Symposium on Interactive 3D Graphics</title>
		<meeting>1997 Symposium on Interactive 3D Graphics</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Multiresolution analysis for surface of arbitrary topological type</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">D</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Warren</surname></persName>
		</author>
		<idno>93-10-05</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
			<pubPlace>Seattle, WA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Washington</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Multiresolution analysis of arbitrary meshes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Eck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1995-08-11">August 6-11, 1995. August 1995</date>
			<biblScope unit="page" from="173" to="182" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH 95</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Séquin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>Anaheim, California</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1993-08-06">August 1-6, 1993. August 1993</date>
			<biblScope unit="page" from="247" to="254" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH 93</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Hierarchical polygon tiling with coverage masks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Greene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Siggraph, ACM Press</publisher>
			<date type="published" when="1996-08-09">August 4-9, 1996. August 1996</date>
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH &apos;96</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Hierarchical Z-buffer visibility</title>
		<author>
			<persName><forename type="first">N</forename><surname>Greene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1993">1993. 1993</date>
			<biblScope unit="page" from="231" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fast multiresolution surface meshing</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Staadt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;95 Proceedings</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Silver</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Surface simplification with variable tolerance</title>
		<author>
			<persName><forename type="first">A</forename><surname>Guéziec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Symposium on Medical Robotics and Computer Assisted Surgery, MRCAS &apos;95</title>
		<meeting>the Second International Symposium on Medical Robotics and Computer Assisted Surgery, MRCAS &apos;95</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A data reduction scheme for triangulated surfaces</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="197" to="214" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Controlled topology simplification</title>
		<author>
			<persName><forename type="first">T</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="171" to="184" />
			<date type="published" when="1996-06">June 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Graphics techniques for walkthrough applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Helman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interactive Walkthrough of Large Geometric Databases</title>
		<title level="s">Course Notes</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1" to="B25" />
		</imprint>
	</monogr>
	<note>SIG-GRAPH &apos;95</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Geometric optimization</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hinker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;93</title>
		<editor>
			<persName><forename type="first">Gregory</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dan</forename><surname>Bergeron</surname></persName>
		</editor>
		<meeting>Visualization &apos;93</meeting>
		<imprint>
			<date type="published" when="1993-10">October 1993</date>
			<biblScope unit="page" from="189" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH, ACM Press</publisher>
			<date type="published" when="1996">August 4-9, 1996. 1996</date>
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH &apos;96</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Mesh optimization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>Anaheim, California</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1993-08-06">August 1-6, 1993. August 1993</date>
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH 93</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Portals and mirrors: Simple, fast evaluation of potentially visible sets</title>
		<author>
			<persName><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Georges</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, 1995 Symposium on Interactive 3D Graphics</title>
		<meeting>1995 Symposium on Interactive 3D Graphics</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="105" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Visual navigation of large environments using textured clusters</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W C</forename><surname>Maciel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 Symposium on Interactive 3D Computer Graphics</title>
		<meeting>the 1995 Symposium on Interactive 3D Computer Graphics</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Plenoptic modeling: An image-based rendering system</title>
		<author>
			<persName><forename type="first">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bishop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Annual Conference Series (SIGGRAPH &apos;95)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="39" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">IRIS performer: A high performance multiprocessing toolkit for real-Time 3D graphics</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rohlf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Helman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<editor>
			<persName><forename type="first">Andrew</forename><surname>Glassner</surname></persName>
		</editor>
		<meeting><address><addrLine>Orlando, Florida</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1994-07-29">July 24-29, 1994. July 1994</date>
			<biblScope unit="page" from="381" to="395" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH &apos;94</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Multi-resolution 3D approximations for rendering</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Borrel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modeling in Computer Graphics</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993-07">June-July 1993</date>
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings SIGGRAPH &apos;92</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Hierarchical image caching for accelerated walkthroughs of complex environments</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lischinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Salesin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-09">August 4-9, 1996</date>
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH &apos;96</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Acm</forename><surname>Siggraph</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-08">August 1996</date>
			<publisher>ACM Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Visibility preprocessing for interactive walkthroughs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Teller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Séquin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings of SIGGRAPH&apos;91</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="61" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Re-tiling polygonal surfaces</title>
		<author>
			<persName><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings SIGGRAPH &apos;92</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Hierarchical geometric approximations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<idno>TR- 050-1994</idno>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="27599" to="23175" />
			<pubPlace>Chapel Hill, NC</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of North Carolina</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
