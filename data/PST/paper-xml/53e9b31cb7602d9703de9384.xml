<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Indexing of the Historical, Present, and Future Positions of Moving Objects</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Dan</forename><surname>Lin</surname></persName>
							<email>lindan@comp.nus.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Aalborg University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Beng</forename><forename type="middle">Chin</forename><surname>Ooi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Simonas</forename><surname>Šaltenis</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Aalborg University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Indexing of the Historical, Present, and Future Positions of Moving Objects</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B928B08780BC55369DFFD8E5D0B001CD</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.2 [Database Management]: Physical Design-access methods; D.3.2 [Information Storage and Retrieval]: Information Storage-file organization Algorithms</term>
					<term>Performance Mobile objects</term>
					<term>indexing</term>
					<term>B-tree</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Although significant effort has been put into the development of efficient spatio-temporal indexing techniques for moving objects, little attention has been given to the development of techniques that efficiently support queries about the past, present, and future positions of objects. The provisioning of such techniques is challenging, both because of the nature of the data, which reflects continuous movement, and because of the types of queries to be supported. This paper proposes the BB x -index structure, which indexes the positions of moving objects, given as linear functions of time, at any time. The index stores linearized moving-object locations in a forest of B + -trees. The index supports queries that select objects based on temporal and spatial constraints, such as queries that retrieve all objects whose positions fall within a spatial range during a set of time intervals. Empirical experiments are reported that offer insight into the query and update performance of the proposed technique.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>We are approaching a situation where it is practical for individuals to be online always and everywhere. This situation is in large measure brought about by advances in consumer electronics and mobile communications. Further, relatively accurate positioning of mobile objects is becoming practical. An infrastructure for location-enabled services <ref type="bibr" target="#b15">[15]</ref> is thus emerging. Motivated in part by such advances, new spatio-temporal indexing techniques are being developed. Some techniques index the current and (anticipated) future positions of spatial objects <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b17">17]</ref>, while others aim to index the past, historical, positions of spatial objects <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b16">16]</ref>.</p><p>Techniques of the latter type support a variety of queries. Timeslice queries retrieve all objects that meet specified spatial constraints at a single point in time, while time range queries retrieve all objects that satisfy the spatial constraints at some time point during a specified time interval. The possibly most basic spatial constraint states that an object must belong to a rectangular region. Indexes that support these basic types of queries are often also useful for the processing of more complex queries.</p><p>However, we are not aware of any single index in the literature that is capable of indexing the historical, present, and future positions of moving objects. The closest technique, proposed recently by Sun et al. <ref type="bibr" target="#b14">[14]</ref>, is a summary structure that supports approximate aggregate queries.</p><p>Motivated by the absence of indexing support for the historical, present, and future positions of moving objects, we propose the Broad B x indexing technique (BB x -index), which is designed with storage and query efficiency in mind. More specifically, the BB x -index structure is based on the B x -tree <ref type="bibr" target="#b4">[4]</ref>, which applies a novel linearization technique to timestamped locations-so that the resulting values preserve spatial proximity and are also time-wise partitioned-and indexes the linearized positions using a B + -tree.</p><p>The BB x -index inherits the ability to index present and future positions from the B x -tree, and it extends this ability with support for also past positions. Three factors contribute to its storage efficiency. First, object positions are represented as linear functions (as is done by, e.g., the TPR-tree family). In comparison to constant functions, this representation reduces the number of updates and thus data volume to one third for data deriving from cars <ref type="bibr" target="#b3">[3]</ref>. Second, an object is usually indexed only once in the BB x -index. Third, being a B +tree based index, the index does not rely on bounding rectangles, rendering the internal directory relatively compact. The uses of linear functions and the B + -tree contribute to obtaining good update performance.</p><p>Having a single index for historical, present, and future positions not only results in indexing that is both space and query efficient; it also makes it possible to support some complex queries neatly and efficiently, with no need for complicated optimization strategies. For example, we demonstrate that it is possible to support a new time-and location-constrained set query that retrieves all objects whose positions fall within a spatial range during a set of time intervals.</p><p>We conducted the the performance study, and our experimental results demonstrate that the BB x -index significantly outperforms the latest existing method MV3R-tree <ref type="bibr" target="#b16">[16]</ref> with respect to storage and historical query efficiency, and performs similar to the B x -tree with respect to the predictive query efficiency. The rest of the paper is organized as follows. Section 2 reviews related work. Section 3 describes the structure of the proposed BB x -index. Section 4 presents the associated query and update operations. Section 5 covers comprehensive performance experiments. Finally, Section 6 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>As pointed out, indexing techniques for moving objects generally come in two variants: techniques for indexing the present and future positions of objects and techniques for indexing the historical positions of objects. Several recent surveys of moving-object indexing techniques exist that focus on different aspects <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b9">9]</ref>.</p><p>Representatives of the first variant of indices include the TPRtree (Time-Parameterized R-tree) family of indexes <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b17">17]</ref>. Next, Patel et al. <ref type="bibr" target="#b10">[10]</ref> have recently proposed a practical indexing technique, termed STRIPES, that supports efficient updates and queries at the expense of higher space requirements. STRIPES uses dual transformation <ref type="bibr" target="#b5">[5]</ref>, where the linear movement of a point object moving in d-dimensional space is represented as a point in a 2ddimensional space. Another recent index is the B x -tree <ref type="bibr" target="#b4">[4]</ref>, which uses the B + -tree to manage moving objects efficiently; we cover the B x -tree in more detail in the next section.</p><p>We proceed to cover the indexing of historical positions in more detail, since our proposed indexing technique aims to solve problems that are prevalent in existing index structures.</p><p>One of the earliest works is the Historical R-tree (HR-tree) <ref type="bibr" target="#b8">[8]</ref>, which logically constructs a "new" R-tree each time an update occurs. HR-trees are efficient for timeslice queries, as the search degenerates to a static query, for which R-trees are efficient. Their disadvantage is extensive duplication of objects, which leads to a very high space consumption. Consequently, the performance of the HR-tree on interval queries is very poor.</p><p>The historical movements of objects can be represented by trajectories composed of sequences of connected, spatio-temporal line segments. For example, an object moving in two-dimensional (x, y) space can be represented by such a trajectory in three-dimensional (x, y, t) space. Such trajectories can be indexed by an R-tree because they, as well as their individual, constituent line segments, can be enclosed by bounding boxes. Based on this idea, Pfoser et al. <ref type="bibr" target="#b11">[11]</ref> propose the Spatio-Temporal R-tree (STR-tree) and the Trajectory-Bundle tree (TB-tree). The former organizes line segments not only according to spatial proximity, but attempts also to group the segments according to their trajectory membership. The TB-tree aims only for trajectory preservation and basically ignores spatial proximity. These indices experience degrading performance as the length of the history increases.</p><p>Next, Tao and Papadias <ref type="bibr" target="#b16">[16]</ref> propose the Multi-Version 3D Rtree (MV3R-tree), which consists of a Multi-Version R-tree (MVRtree) and an auxiliary 3D R-tree. MVR-trees utilize the concepts of Multi-Version B-trees <ref type="bibr" target="#b2">[2]</ref>, which have good performance for timeslice queries. The auxiliary 3D R-tree compensates for the inefficiency of interval queries in MVR-trees. However, in order to offer good timeslice performance, the MV3R-tree uses so-called version splits that duplicate data during update operations, and the auxiliary structure requires extra storage space.</p><p>A recent proposal by Sun et al. <ref type="bibr" target="#b14">[14]</ref> supports queries about the past, present, and future. However, on approximate aggregate query results can be computed. In applications were accurate results are needed, other proposals are needed.</p><p>Despite the existence of several indexing techniques for historical positions and for present and future positions, no single movingobject index for the past, present, and future positions of moving objects has yet been reported in the literature that achieves the goals of storage efficiency and query and update efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">BB X -INDEX</head><p>As the BB x -index borrows from the B x -tree, we first introduce the B x -tree and then present the structure of the BB x -index. Section 4 covers the associated algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The B x -Tree</head><p>The B x -tree <ref type="bibr" target="#b4">[4]</ref> is a B + -tree index structure that indexes the current and future positions of moving objects. To be able to use the B + -tree, which is capable only of indexing data belonging to a totally ordered linear domain, moving-object positions are linearized.</p><p>The movement of an object is given by a linear function of time and a time when the function is valid. For movement in two dimensional space, such a movement O can be described by a two dimensional velocity vector -→ v and a two dimensional point -→ x , in addition to the time value tu, resulting in a point in a higher dimensional space. These points are mapped to a one-dimensional space by means of a space filling curve. The specifics are given shortly.</p><p>A space-filling curve is a function that enumerates every point in a discrete, multi-dimensional space. In our context, a space-filling curve is generally considered good if it preserves proximity, meaning that points close in multidimensional space tend to be close in the one-dimensional space obtained by the curve. The Peano curve and the Hilbert curve are prime examples of good spacefilling curves <ref type="bibr">[7]</ref>. The B x -tree may use any space-filling curve x (indicated by the superscript in its name), and we choose the Hilber curve which has better performance than other curves as reported in <ref type="bibr" target="#b4">[4]</ref>.</p><p>The motivation for representing the position of an object as a linear function of time is fourfold. First, it is possible to estimate such linear functions in prominent applications, e.g., applications that perform frequent sampling and applications that use GPS for positioning. Second, linear functions have quite compact descriptions, using only two more parameters than do the conventional, constant functions for two-dimensional movement. More complex functions are harder or impossible to obtain, and they are less compact. Third, linear functions offer better predictions of future positions than do constant functions. Fourth, the use of linear functions reduces the volume of updates. Intuitively, an update occurs when the position predicted by an existing function is deemed inaccurate. Studies of GPS data from cars indicate that for a range of accuracies, the use of linear functions reduces the number of updates to one third of the updates needed when using constant functions <ref type="bibr" target="#b3">[3]</ref>.</p><p>The B x -tree effectively "partitions" the positions it indexes, placing positions in so-called phases based on their update time. Specifically, the time axis is first partitioned into intervals of duration ∆t mu (the anticipated maximum duration in-between two updates of any object location), and each such interval is further partitioned into n equal-length sub-intervals, which are the phases. A value of n = 2 has been shown to yield an index with good query and storage efficiency <ref type="bibr" target="#b4">[4]</ref>. Figure <ref type="figure" target="#fig_0">1</ref> shows a B x -tree with n = 2.</p><p>For a moving object, the key value indexed by the B x -tree is the concatenation of a phase number and the result of applying the underlying space-filling curve to the position of the object as of the end time of the phase, termed the label timestamp of the phase. The phase used when computing the key value is the one that follows the phase that intersects with the insertion time of the object. Using </p><formula xml:id="formula_0">B x value(O, t u ) = [phase] 2 ⊕ [x rep] 2<label>(1)</label></formula><p>Here, [x] 2 denotes the binary representation of x, and ⊕ denotes concatenation. The two components of the function are defined as follows:</p><p>phase = (t lab /(∆t mu /n) -1) mod (n + 1)</p><formula xml:id="formula_1">x rep = x value( -→ x + -→ v • (t lab -t u ))</formula><p>Here, t lab = t u + ∆t mu /n l , where operation x l returns the nearest future label timestamp of x. Next, x value is obtained from the space-filling curve, -→ x , -→ v are the position and the velocity of the given object, and tu is the time when the object issues an update.</p><p>To handle queries occurring at timestamps other than the label timestamps, the B x -tree enlarge the query window to enclose objects that are not in the query window at the label timestamps, but may possibly be in the query window at the query timestamp. Because the B x -tree stores an object's location as of some time after its update time, the enlargement involves two cases: a location must either be brought back to an earlier time or forward to a later time. Consider the example in Figure <ref type="figure" target="#fig_1">2</ref>, where t ref denotes the label timestamp that four moving objects p 1 , p 2 , p 3 and p 4 are indexed in the tree, and where queries q 1 and q 2 (solid rectangle) have time parameters tq1 and tq2 respectively. The figure shows the locations of four moving objects at the query time as circles, from which we can see that these four objects are the answers of the two queries. In order to obtain these answers, the query windows are enlarged (dashed rectangles) using the expansion speed. The details of computation of the expansion speed can be found in <ref type="bibr" target="#b4">[4]</ref>.</p><formula xml:id="formula_2">3 t q 1 1 v u v 1 l u v 2 q 2 q 1 q 2 q' 1 q' 2 time current t 2 3 p' 4 1 p 1 v l 1 v 1 v 2 l</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">BB x -Index Structure</head><p>The BB x -index consists of nodes that in turn consist of entries, each of which is of the form x rep, t start , t end , pointer . For leaf nodes, pointer points to the objects with the corresponding x rep, where x rep is obtained from the space-filling curve; tstart denotes the time when the object was inserted into the database (corresponding to the t u in the description of the B x -tree), and t end denotes the time that the position was deleted, updated, or migrated (migration refers to the update of a position done by the system). For non-leaf nodes, pointer points to a (child) node at the next level of the index: tstart and t end are the minimum and maximum tstart and t end values of all the entries in the child node, respectively. In addition, each node contains a pointer to its right sibling to facilitate query processing.</p><p>Unlike the B x -tree, the BB x -index is a forest of trees, with each tree having an associated timestamp signature tsg and a lifespan (see Figure <ref type="figure" target="#fig_3">3</ref>). The timestamp signature parallels the value t lab from the B x -tree and is obtained by partitioning the time axis in the same way as for the B x -tree. The lifespan of each tree corresponds to the minimum and maximum lifespans of objects indexed in the tree. The roots of the trees are stored in an array, and they can be accessed efficiently according to their lifespan. This array is relatively small and can usually be stored in main memory.   Objects inserted during the same phase will be stored in the tree with the t sg that is equal to the end timestamp of that phase. In particular, an update with timestamp tstart is assigned a timestamp signature tsg = tstart l , where x l returns the smallest timestamp signature that does not precede x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>BB -Index</head><p>The position of an object is represented by a single-dimensional value x rep obtained from a space-filling curve. In order to retain the proximity-preserving property of the space-filling curve, we index objects within a time interval by their positions as of the time given by the timestamp signature of this interval. Hence, we need to determine an object's position at the timestamp signature according to its moving function.</p><p>An object's linear movement O = ( -→ x , -→ v ) is given by a position and a velocity at the time of update, t start . The transformation from the current position to the position -→ x ind that will be indexed is:</p><formula xml:id="formula_3">-→ x ind = -→ x + -→ v • (t sg -t start ) = -→ x + -→ v • ( t start l -t start ).</formula><p>We thus place the position x rep computed by applying the spacefilling curve to -→ x ind in the tree with timestamp signature tsg.</p><p>Note that we do not concatenate the timestamp signature and x rep as in the B x -tree. There are two reasons for this. First, our index aims to handle moving objects from the past to the future. Thus, the index must contend with timestamps that keep growing in value. Inclusion of such values in the key would poses an efficiency problem since we must then allocate substantial space for the key in order to cater to its growth. In contrast, the B x -tree only indexes current positions of moving objects and hence is able to fix the length of the key value (by using the modulo function). Second, without considering the timestamp, we obtain a shorter key and a simpler mapping function. Imagining that the index runs for one year, the accumulated timestamp value (≈ 2 24 minutes) would require a long key value representation, which will significantly reduce the node capacity and fanout, which increases index size and decreases query performance.</p><p>Let us illustrate the BB x -index with an example. Figure <ref type="figure" target="#fig_3">3</ref> shows a BB x -index with n = 2. Objects inserted between timestamps 0 and 0.5t mu are stored in tree T 1 with their positions as of time 0.5tmu; those inserted between timestamp 0.5tmu and tmu are stored in tree T2 with their positions as of time tmu; and so on. Each tree has a maximum lifespan: T 1 's lifespan is from 0 to 1.5t mu because objects are inserted starting at timestamp 0 and because those inserted at timestamp 0.5t mu may be alive throughout the maximum update interval tmu, which is thus until 1.5tmu; the same applies to the other trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">QUERY PROCESSING</head><p>In the following, we first unify historical and predictive queries, then consider the range query and the set query. Finally, updates are considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Unifying Historical and Predictive Queries</head><p>To understand how the BB x -index is able to support historical and predictive queries, consider Figure <ref type="figure" target="#fig_4">4</ref>. Figure <ref type="figure" target="#fig_4">4</ref> shows the possible queries that happen in the latest tree in a BB x -index: (i) historical queries refer to times between the start time of the lifespan and the current time; (ii) predictive queries refer to times between the current time and the maximum update interval from the current time.</p><p>Recall that object positions are indexed as of times equal to timestamp signatures. Thus, in order to answer queries as of other times than the timestamp signatures, the BB x -index enlarges query windows to capture those objects that are outside the query window at the timestamp signature, but may be inside the query window at the time specified by the query. Figure <ref type="figure" target="#fig_4">4</ref> illustrates the maximum query window enlargements for historical and predictive queries. The enlargements are similar for both kinds of queries. Consequently, the algorithms we propose in the following sections can answer queries on the historical as well as the future positions of moving objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Range Query</head><p>An interval range query retrieves all objects whose position falls within the rectangle q</p><formula xml:id="formula_4">= ([qx l 1 , qx u 1 ], [qx l 2 , qx u 2 ]</formula><p>) at some time during a time interval [t l , tu] ("l" denotes the lower bound, "u" denotes the upper bound).</p><p>Queries are handled separately for each tree whose lifespan intersects with the query interval. Figure <ref type="figure" target="#fig_5">5</ref> illustrates how three types of intersection may be discerned: (i) the query interval ends before the timestamp signature of the tree; (ii) the query interval intersects the timestamp signature; and (iii) the query interval starts after the timestamp signature.</p><p>Like the B x -tree, the BB x -index uses query window enlargement to counter the data transformation used. Different types of intersections are handled by different strategies for query window enlargement. For the first case, we use the maximum of the start time of the query interval and the start time of the lifespan to perform Having obtained an enlarged query window, we travel the index. In each tree of the index, a range query in the native, twodimensional space becomes a set of range queries in the transformed, one-dimensional space (due to the use of a space-filling curve).</p><p>The pseudo code of the algorithm is shown in Figure <ref type="figure" target="#fig_6">6</ref>. In line 7, function LeftmostIntersection calculates the leftmost interval of intersection between the sequence of intervals q and the interval that extends from low . Then the leaf node containing the start point of this interval is located, and all entries in this leaf node that are after the start point are checked. If the last entry is smaller than the end point, we continue traversing right siblings by the right link (lines 10-12). Otherwise, we compute the next leftmost intersection (line 7) and then continue searching. This process repeats until we can no longer find any intersections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm Range query(q, [t l , tu])</head><p>Input: q is the query range, and [t l , tu] is the query time interval 1.</p><p>for each tree in the BB x -index do 2.</p><p>if the tree's lifespan intersects with [t l , t u ] then 3.</p><p>enlarge q to q 4. compute q , the space filling curve representation of q 5. low ← 0 6. repeat 7.</p><p>[start, end] ← LeftmostIntersection(q , [low , ∞)) until LeftmostIntersection(q , [low , ∞)) = ∅ 15. for each object in L do <ref type="bibr" target="#b16">16</ref>.</p><p>if the object's position during [t l , tu] is inside q then 17.</p><p>add the object to the result set 18. return result set We note that this algorithm, in contrast to that of the B x -tree, is able to skip processing for some of the intervals in q . In particular, if an interval is contained in a leaf node that has already been accessed, the interval is skipped. Moreover, it is reasonable to assume that the query interval will not exceed the maximum update interval. Since there is only one copy of each object within the maximum update interval, the BB x -index avoids redundant accesses to the same objects when compared to the MV3R-tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Time and Location Constrained Set Query</head><p>Queries on historical data may relate to temporal patterns. This is exemplified by the following query: "Which taxis were in the vicinity of a given hotel between times 18.00 and 18.30 on a weekday during a certain past month?" In this section, we define a new type of query, the time and location constrained set query, that supports this type of querying. The query retrieves the objects whose position falls within the rectangular range q = ([qx l 1 , qx u 1 ], [qx l 2 , qx u 2 ]) at some time during a set of time intervals (tint1, tint2, . . . ,</p><formula xml:id="formula_5">t intk ) = ([t l 1 , t u 1 ], [t l 2 , t u 2 ], . . . , [t l k , t u k ]</formula><p>). A naive method (NM) to process this query is to treat it as a series of independent interval range queries and then combine the results obtained from these. For instance, in Figure <ref type="figure" target="#fig_7">7</ref>, query q is comprised of three sub-queries q1, q2, and q3. NM handles each single subquery as an independent range query. For q 1 , NM queries tree T 1 ; for q 2 , trees T 1 and T 2 are queried since both of their lifespans intersect with the query time interval; for q 3 , trees T 1 , T 2 , and T 3 are queried. As a result, tree T1 has been searched three times to answer set query q. As we shall see next, such repetitive search can be avoided. Figure <ref type="figure" target="#fig_8">8</ref> shows more details about the search in tree T1. Assuming that each query window enlargement has similar expansion speed, we obtain three ranges r 1 , r 2 , and r 3 for the sub-queries q 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 q1, q2, and q3, respectively, according to their query time interval. Then, for sub-query q 1 , we need to search the range r 1 , and for subquery q 2 , we need to search the range r 2 . We can see that r 2 covers r 1 , which means the objects inside r 1 are retrieved twice here due to the overlap of ranges. Similarly, to answer the sub-query q3, we need to search the range r3, where r3 covers r2 and objects inside r 2 will also be retrieved twice. Thus, region r 1 has been searched three times and r 2 has been searched twice.</p><p>Based on this observation, we propose a more efficient method for computing the set query, termed the grouping method (GM). The main idea is to group sub-queries for each tree and handle subqueries in the same group simultaneously, thus avoiding repetitive traversals of trees.</p><p>Given the example set query q from Figure <ref type="figure" target="#fig_7">7</ref>, GM first considers trees T 1 , T 2 , and T 3 because their lifespans intersect with time interval [t l 1 , t u 3 ], where t l 1 and t u 3 are the earliest and latest query times of the set queries, respectively. In each tree, GM identifies all sub-queries whose query intervals intersect with the lifespan of current tree and then computes the intersections of the time intervals. Using the resulting time intervals, GM enlarges the query window and obtains several candidate query ranges. For example, the query time intervals of three sub-queries all intersect with the lifespan of T 1 , and hence GM will compute the enlargements of these three sub-queries and obtain ranges r 1 , r 2 and r 3 . Then, GM will only search using the largest query range (in the example, r 3 ), and further distinguishes results for each sub-query. The pseudo code for GM is shown in Figure <ref type="figure" target="#fig_9">9</ref>.</p><p>Algorithm Set query(q, (t int1 , t int2 , . . . , t intk )) Input: q are the query range, and (tint1, tint2, . . . , t intk )</p><p>is the query time intervals 1. for each tree in the BB x -index do 2.</p><p>if the tree's lifespan intersects with</p><formula xml:id="formula_6">[t l 1 , t u k ] then 3. for i ← 1 to i ≤ k do 4.</formula><p>if the tree's lifespan intersects with tinti 5.</p><p>enlarge q to q 6. maxq stores the largest q 7. maxq ← space filling curve representation of maxq 8.</p><p>low ← 0 9. repeat 10.</p><p>[ is inside q then 20.</p><p>add the object to the result set 21. return result set </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Insertion, Deletion, and Migration</head><p>Insertion into the BB x -index is similar to insertion into the B xtree <ref type="bibr" target="#b4">[4]</ref>. To delete an object, we first find the tree where this object is stored. Rather than physically removing the object, we modify the end time of its lifespan, t end , to be the current time.</p><p>Objects in an old tree that have not been updated within the maximum update interval should be migrated, by means of a deletion and an insertion, to the current tree. This system-controlled migration is needed to maintain the index structure. Although migration introduces additional updates, the amortized cost is small in practice (as shown in the Section 5.5) and is controllable (by increasing the maximum update interval).</p><p>The algorithm outline is shown in Figure <ref type="figure" target="#fig_10">10</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PERFORMANCE STUDIES</head><p>In this section, we present the results of experimental performance studies conducted on the BB x -index. Following a description of the experimental setting, the section considers in turn storage requirements, range queries, time-and location-constrained set Algorithm Update(P o , P n ) Input: P o and P n are old and new objects respectively 1.</p><p>t index ← the time P o is indexed in the tree 2.</p><p>find tree T x whose lifespan contain t index 3.</p><p>pos index ← the position of P o at t index 4.</p><p>keyo ← the x-value of the pos index 5.</p><p>locate P o in T x according to key o 6.</p><p>modify the end time of P o 's lifespan to current time 7.</p><p>t index ← the time P n will be indexed 8.</p><p>pos index ← the position of Pn at t index 9.</p><p>keyn ← the x-value of the pos index 10.</p><p>insert P n into the latest tree according to key n </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Settings</head><p>In the experiments, we compare the historical and predictive query performance of the BB x -index to the MV3R-tree and the B x -tree, respectively. Query and update costs are measured in terms of node accesses. A page size of 1024 bytes is used, which results in fanouts of 36 in both the MV3R-tree and the BB x -index, and 50 in the B xtree. The MV3R-tree source code <ref type="bibr" target="#b16">[16]</ref> that we use in the experiments uses this page size; to be fair, we want to preserve whatever optimization may have been done to that code. Our other parameters are also similar to those used for the MV3R-tree <ref type="bibr" target="#b16">[16]</ref>. See For all experiments, both the initial positions and the movements of the objects are uniform. At each timestamp, the percentage of objects that will update their movement function is roughly the same and corresponds to the agility of the dataset, i.e., a dataset has agility p, if on average p% of the objects change their movement function at each timestamp <ref type="bibr" target="#b16">[16]</ref>.</p><p>Two parameters are used when generating interval range queries for the experiments, namely the spatial extent, expressed as a fraction of the spatial universe in Table <ref type="table" target="#tab_3">1</ref>, and the temporal length of the queries, expressed as a fraction of the recorded history <ref type="bibr" target="#b16">[16]</ref>. Queries are generated so that all timestamps are queried with the same probability.</p><p>The set query has two more parameters: the number of time intervals and the query frequency. Query frequency f q indicates how many intervals occur in one maximum update interval and is represented as the division of the maximum update interval tmu by the average length between each interval start time. Given a query q and its time intervals</p><formula xml:id="formula_7">([t l 1 , t u 1 ], [t l 2 , t u 2 ], . . . , [t l k , t u k ]</formula><p>), the query frequency is given as</p><formula xml:id="formula_8">f q = (k -1) • t mu / P i=k-1 i=1 (t l i+1 -t l i ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Storage Requirements</head><p>As the space efficiency is important when indexing historical data, we compare the sizes of the MV3R-tree and the BB x -index. We created datasets with cardinality 5K and agilities in the range <ref type="bibr" target="#b1">[1,</ref><ref type="bibr">25]</ref> (same as in reference <ref type="bibr" target="#b16">[16]</ref>). Figure <ref type="figure" target="#fig_11">11</ref> shows the size of each structure after 100 timestamps as a function of the agility. We observe that the BB x -index has the smaller size. This is because one object may be duplicated several times in the MV3R-tree due to the version splits. In the BB x -index, each object has only one copy, except those (few) objects that are not updated within the average update interval and need to be migrated. While it is possible to use a variety of settings for the parameters that offer some control over the replication done by the MV3R-tree, we note that we have used the settings in the MV3R-tree that were used in reference <ref type="bibr" target="#b16">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Range Queries</head><p>We proceed to consider the historical and predictive query performance of the BB x -index, the MV3R-tree, and the B x -tree, respectively. We evaluate range query performance over datasets of 50K objects that evolve for 200 timestamps. We use a workload with 3% agility and 2% query extents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Historical Queries</head><p>The historical queries have 3.75% query length and are distributed uniformly over the past 200 timestamps. As shown in Figure <ref type="figure" target="#fig_12">12</ref>, the BB x -index achieves significantly better performance than the MV3R-tree. This is due partly to the fact the BB x -index is smaller in size and simpler in structure. Next, we study the behavior of the MV3R-tree and the BB xindex as time passes. We executed the same query workloads (with 2%extents and 7.5% query length) after the dataset (3%agility) evolves for 200 and 500 timestamps. The results are shown in Figure <ref type="figure" target="#fig_13">13</ref>. In fact, when the query length is large, the effect of ratio of interval queries on the query performance is more profound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Predictive Queries</head><p>In this experiment, we evaluate the performance of the BB xindex for predictive queries. From this experiment and onwards, we can no longer use the MV3R-tree as the benchmark index since it does not support predictive queries. Instead, we compare the performance of the BB x -index against the more specialized (and smaller) B x -tree, which is now applicable.</p><p>In the experiment, the maximum update interval tmu is about 34 timestamps, as a result of a 3% agility. The predictive query time is randomly selected from [now , now + t mu ]. Figure <ref type="figure" target="#fig_14">14</ref> shows the predictive range query performance of the B x -tree and the BB xindex after every 50 timestamps. Observe that the two indices have comparable performance as time passes, though the query cost of the BB x -index is slightly larger than that of the B x -tree. This is because the BB x -index needs to store more information than the B x -tree, which results in a smaller fanout. Moreover, the difference between the mapping functions makes the average length of query window enlargement for the predictive query in the BB xindex larger than that of the B x -tree, because the BB x -index also has to guarantee efficient historical query performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Time-and Location-Constrained Set Query</head><p>In this set of experiments, we study the properties of the set query by testing various parameters including the number of time intervals, time interval length, and query frequency. The BB x -index is created with 50K objects and run for 500 timestamps before performing 100 set queries (number of intervals is 10, interval length is 1.375% and fq is 2 by default). We compare the efficiency of the algorithms NM and GM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1">Effect of Number of Time Intervals</head><p>In this experiment, we measure the effect of the number of time intervals by varying the number from 1 to 10. Figure <ref type="figure" target="#fig_15">15</ref> shows the set query performance of two algorithms. Note that when there is only one interval, algorithms NM and GM are the same. When the The query cost of NM increases linearly with the number of time intervals since it is essentially a sum of a series of range queries. In contrast GM can save the cost when several time intervals fall into the same lifespan of one tree of the BB x -index.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.2">Effect of Time Interval Length</head><p>Next, we evaluate the effect of the time interval length. prise that NM deteriorates very fast with an increase of the interval length. This is due to the accumulated effect of range queries with long time intervals. However, the query cost of GM first increases a little and then stays almost constant. This is because the performance of the GM is only affected by the sub-queries with the longest time interval inside each tree. When the time interval becomes longer, the query window enlargement may reach the maximum lifespan of the tree, and thus the performance will no longer degenerate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.3">Effect of Query Frequency</head><p>We now study the effect of query frequency. Figure <ref type="figure" target="#fig_17">17</ref> shows the query performance with the query frequency f q ranging from 0.5 to 8. It is interesting to observe that NM and GM achieve the same performance when fq is equal to 0.5 (i.e., each sub-query happens after 2tmu). At this time, no sub-queries fall into the same tree of the BB x -index, and hence GM also needs to handle all the subqueries separately. However, when the query frequency increases, GM starts to show its efficiency. The higher the frequency, the better GM performs since more sub-queries can be grouped and done together in one tree traversal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Update Cost</head><p>In order to investigate the performance degradation across time, we measure the update cost (amortized over insertion and deletion) of the BB x -index after every 20 timestamps over a 50K dataset. As shown in Figure <ref type="figure" target="#fig_8">18</ref>, the BB x -index retains almost constant performance and is not affected by time. This is because given the key value, each deletion or insertion only needs to traverse one path from the top to the bottom of the tree. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SUMMARY AND FUTURE RESEARCH</head><p>This paper presents a new indexing technique, the BB x -index, which can answer queries about the past, the present, and the future. The BB x -index is based on the concepts underlying the B x -tree. For the indexing of historical information, it avoids duplicating objects and thus achieves significant space saving and efficient query processing. For predictive queries, we improve the algorithms of the B x -tree. Moreover, we define and offer a technique for processing a new type of query, a spatio-temporal set query. Extensive performance studies were conducted that indicate that the BB x -index outperforms the existing state of-the-art method, the MV3R-tree, with respect of historical queries, and performs similarly to the B x -tree with respect to predictive queries.</p><p>Several promising directions for future work exist. One is to improve current algorithms after considering extreme cases. For example, one such case occurs when half objects are updated frequently while half are not, which results in relatively many forced updates. Another direction is to experiment with the proposed structure in new applications. One desirable application would be to predict possible traffic jams and to guide drivers based on historical and current information.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The B x -Tree the notation introduced above, the mapping function is:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Query Window Enlargement</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>mu</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The BB x -Index</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Historical Versus Predictive Query</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Lifespan Intersected with Query Interval</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Range Query Algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Example Time and Location Constrained Set Query</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Query Enlargements in Tree T1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Group Method (GM)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Update Algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Storage Requirements</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Historical Range Query Performance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Deterioration of MV3R-Trees and BB x -Indexes as Time Progresses</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Predictive Range Query Performance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: Effect of Number of Intervals number of intervals increases, GM performs much better than NM.The query cost of NM increases linearly with the number of time intervals since it is essentially a sum of a series of range queries. In contrast GM can save the cost when several time intervals fall into the same lifespan of one tree of the BB x -index.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 16 :</head><label>16</label><figDesc>Figure 16: Effect of Interval Length</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 17 :</head><label>17</label><figDesc>Figure 17: Effect of Query Frequency</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>Figure 18: Update Performance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 ,</head><label>1</label><figDesc>where values in bold denote the default values used.</figDesc><table><row><cell>Parameter</cell><cell>Setting</cell></row><row><cell>Page size</cell><cell>1K</cell></row><row><cell>Agility</cell><cell>1, ..., 3%,..., 25%</cell></row><row><cell>Spatial extent of queries</cell><cell>2%</cell></row><row><cell cols="2">Time interval length of queries 1.38%, 3.75%, 7.5%</cell></row><row><cell cols="2">Number of intervals in a query 2,4,6,8,10</cell></row><row><cell>Query frequency</cell><cell>0.5, 1, 2, 4, 8</cell></row><row><cell>Number of queries</cell><cell>100</cell></row><row><cell>Dataset size</cell><cell>5K, 50K</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 : Parameters and Their Settings</head><label>1</label><figDesc></figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported in part by grant 216 from the Danish National Center for IT Research. In addition to his primary affiliation, the second author is an adjunct professor at Agder University College, Norway.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Advances in Indexing for Mobile Objects</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Procopiuc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="25" to="34" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An Asymptotically Optimal Multiversion B-Tree</title>
		<author>
			<persName><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gschwind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Widmayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="264" to="275" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient Tracking of Moving Objects with Precision Guarantees</title>
		<author>
			<persName><forename type="first">A</forename><surname>Civilis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nenortaite</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pakalnis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MobiQuitous</title>
		<meeting>MobiQuitous</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="164" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Query and Update Efficient B+-Tree Based Indexing of Moving Objects</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="768" to="779" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On Indexing Mobile Objects</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kollios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gunopulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Tsotras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="261" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Spatio-Temporal Access Methods</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Mokbel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Ghanem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Aref</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="40" to="49" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Analysis of the Clustering Properties of the Hilbert Space-Filling Curve</title>
		<author>
			<persName><forename type="first">B</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Saltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="124" to="141" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Towards Historical R-trees</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Nascimento</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R O</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symposium on Applied Computing</title>
		<meeting>ACM Symposium on Applied Computing</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="235" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast Update and Efficient Retrieval: an Oxymoron on Moving Object Indexes</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Int. Web GIS Workshop</title>
		<meeting>of Int. Web GIS Workshop</meeting>
		<imprint>
			<publisher>Keynote</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">STRIPES: An Efficient Index for Predicted Trajectories</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">P</forename><surname>Chakka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="637" to="646" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Novel Approaches in Query Processing for Moving Objects</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pfoser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Theodoridis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="395" to="406" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Indexing of Moving Objects for Location-Based Services</title>
		<author>
			<persName><forename type="first">S</forename><surname>Šaltenis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="463" to="472" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Indexing the Positions of Continuously Moving Objects</title>
		<author>
			<persName><forename type="first">S</forename><surname>Šaltenis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Leutenegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Lopez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="331" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Querying about the Past, the Present, and the Future in Spatio-Temporal Databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="202" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m">Location-Based Services</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Schiller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voisard</surname></persName>
		</editor>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">MV3R-Tree: A Spatio-Temporal Access Method for Timestamp and Interval Queries</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="431" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The TPR*-Tree: An Optimized Spatio-Temporal Access Method for Predictive Queries</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="790" to="801" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
