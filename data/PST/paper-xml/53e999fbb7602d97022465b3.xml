<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Consistency in Dataflow Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Edward</forename><forename type="middle">Ashford</forename><surname>Lee</surname></persName>
						</author>
						<title level="a" type="main">Consistency in Dataflow Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CFAB75570428F0D090DD9CB577A90EFF</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Consistency</term>
					<term>dataflow</term>
					<term>functional languages</term>
					<term>graphical programming</term>
					<term>hybrid dynamical systems</term>
					<term>parallel processing</term>
					<term>signal processing</term>
					<term>token-flow model</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper explores analytical properties of programming languages with dataflow graph semantics. Such languages are currently used in certain application domains, such as digital signal processing, and a better analytical understanding of their properties may broaden their applicability. One of their most serious problems is that subtle inconsistencies between parts of the dataflow graph can be inadvertently created. These inconsistencies can lead to deadlock, or in the case of nonterminating programs, to unbounded memory requirements. Consistency is defined to mean that the same number of tokens is consumed as produced on any arc, in the long run. A token-flow model is developed for testing for consistency. The method is a generalization of consistency checks for synchronous dataflow (SDF) graphs 1171. Although inspired by the similar tests of Benveniste et al. 171, the method and the languages to which it applies are different.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>ffective general-purpose parallel computing paradigms re-E main elusive. Restricting the domain of applications, however, can yield considerable payoff in automation, hardware cost, or software efficiency. Architectures, languages, and compiler techniques specialized to regular iterative algorithms [ 161, neural networks, and signal processing (e.g., <ref type="bibr" target="#b18">[19]</ref> and <ref type="bibr" target="#b20">[21]</ref>), for example, have shown significant advances. Fortunately, each of these advances lends insight toward broader general purpose computing, and adds to a suite of techniques that may eventually be collected into a general, but heterogeneous, solution. Many of the methods that have been applied to signal processing and regular iterative algorithms are based on languages with dataflow graph semantics. For example, the techniques described in <ref type="bibr" target="#b15">[16]</ref> and <ref type="bibr" target="#b19">[20]</ref> use compile-time scheduling of a class of dataflow graphs to synthesize parallel implementations. Efforts to broaden the applicability of these methods, however, have been hampered by the breakdown of their analytical methods when the class of dataflow graphs is generalized.</p><p>One cause of this breakdown is that subtle inconsistencies between parts of the graph can be inadvertently created. These inconsistencies can lead to accumulation of tokens in memory. For nonterminating programs, which are common in signal processing, such inconsistencies imply either unbounded memory requirements or deadlock. These problems have been noted before by other researchers (see for example <ref type="bibr">[lo]</ref>), and have resulted for example in the exclusion of certain operators in the ID language <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b25">[26]</ref>. This paper describes a simple systematic method that can identify these inconsistencies, and does not have the excessive restrictions of "clean" dataflow graphs [ 101 or "well-behaved" dataflow graphs <ref type="bibr" target="#b2">[3]</ref>. The method would form a critical part of a compiler for languages with dataflow graph semantics. It also imposes precise theoretical constraints on the Manuscript received November <ref type="bibr" target="#b23">24,</ref><ref type="bibr">1990</ref> The analytical techniques in this paper apply to a class of languages where operators and functions (collectively called "actors") consume tokens from input streams and produce tokens on output streams. Once a token is produced, it remains in the system until it is consumed by its destination actor. Languages in this class include stream-oriented functional languages (such as Silage [ 14]), dataflow machine languages, and graphical signal-flow languages (such as Gabriel <ref type="bibr" target="#b19">[20]</ref>). Languages with nondeterminate actors [ 151 can also be modeled. A tagged-token dataflow model <ref type="bibr">[ l ]</ref> is not assumed, although these techniques may be applicable in that domain as well.</p><p>For illustrative purposes, we will use dataflow actors drawn from the traditional literature. Specifically, these include standard actors, such as arithmetic operators and comparators. These have the property that a single token on each input enables them to fire, and they produce a single token on each output when they fire. Actors in this class have been called homogeneous synchronous dataflow (SDF) actors <ref type="bibr" target="#b16">[17]</ref>. SDF means that for each input and output of each actor, the number of tokens produced and consumed when the actor fires is fixed and known at compile time. "Homogeneous" means that the number of tokens produced and consumed on all inputs and outputs is the same, unity. In addition, we include general SDF actors, which may produce or consume more than one token on each input or output. Two examples are shown at the top of Fig. <ref type="figure">1</ref>. These actors are not traditional in the dataflow literature, but have important advantages that will be elaborated shortly.</p><p>In addition to SDF actors, our examples include SWITCH and SELECT, which route tokens conditional on a Boolean input, as explained in Fig. <ref type="figure">1</ref>. These are minor variations of the original Dennis actors <ref type="bibr" target="#b11">[12]</ref>, also used in <ref type="bibr">[29]</ref>, <ref type="bibr">[28]</ref>, and <ref type="bibr" target="#b24">[25]</ref>, and are the same as the DISTRIBUTOR and SELECTOR in <ref type="bibr">[ll]</ref>. These are not SDF actors because the compiler cannot know a priori how many tokens are produced or consumed on each input and output when the actor fires, since it depends on a Boolean input. Finally, we will illustrate the handling of nondeterminism with two types of nondeterminate merge actors.</p><p>The intent of this paper is not to propose a particular language design, nor to advocate a particular choice of actors on which to base dataflow graphs. It is instead to develop an analytical technique that applies to a class of languages in which operators are described in terms of consumption and production of tokens.</p><p>The key property of these languages is that operators and functions operate on streams of tokens. There is more than traditional flexibility in managing the progression through successive tokens in a stream. In order to justify studying this class of languages, some examples of interesting programs are given in Section I11 below. Although we will use a graphical syntax to illustrate example programs, the method is not restricted to graphical languages. For some applications, particularly signal processing, graphical syntax has proven attractive (see <ref type="bibr" target="#b19">[20]</ref> for one example and references to dozens of others). For others it has not. To date, however, very few experiments have been done with graphical here. The UPSAMPLE and DOWNSAMPLE actors can be parameterized to produce any number of tokens given an input token.</p><p>The behavior of UPSAMPLE, DOWNSAMPLE, SWITCH, and SELECT actors for different input conditions is illustrated</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ENABLED FIRED</head><p>languages of the type discussed in this paper. A textual language with the same or related semantics could easily be created, but it would demand more of the reader without adding materially to the exposition in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">SEMANTIC INCONSISTENCIES</head><p>Some examples of the type of inconsistencies addressed by this paper are shown in Fig. <ref type="figure">2</ref>. The graph in Fig. <ref type="figure">2</ref>(a) is structurally similar to a conditional. Without the NOT actor, this graph would implement the functional expression: y = if ( e ) then f(z) else g(z) <ref type="bibr" target="#b0">(1)</ref> The NOT actor, a Boolean negation, creates a problem. To understand precisely the difficulty, observe that the firing rule for the SELECT is that it must have a Boolean token on its control input and a token on the data input corresponding to the value of the Boolean. The first time a control token arrives, the SELECT cannot fire, because it does not have a token on the proper data input. Some iterations later it may be able to fire. However, notice that unless the Boolean input stream consists of the same number of ''true'' and "false" tokens, then memory requirements for token storage will grow. If the program does not terminate, memory requirements could grow indefinitely.</p><p>A textual description in a functional language could use the following syntax:</p><formula xml:id="formula_0">yT = f (if (cl) then x) y~ = g (if ( n o t cl) then x) y = if ( n o t cl) then yT else yF<label>(2)</label></formula><p>where all symbols are assumed to represent streams. The elements of the streams are not explicitly indexed, but rather progression through a stream is regulated by consumption and production of tokens. In this syntax, the if-then construct is a function that may or may not return a value (produce a token), depending on its Boolean argument. Clearly, unrestricted use of this or similar constructs can lead to difficulties. But the very similarity of this syntax with traditional languages makes misinterpretation easy, so to avoid this confusion, we rely henceforth on a graphical representation. Implicit in our language model is the FIFO behavior of arcs connecting actors, with no particular size limit. This can be implemented using tagged tokens <ref type="bibr">[l]</ref> or in some cases static buffering <ref type="bibr" target="#b17">[18]</ref>. However, the language model can also subsume implementations with finite-size buffers by using feedback paths with delays. For example, the MIT static dataflow model <ref type="bibr" target="#b12">[13]</ref> prohibits more than one token on an arc at one time. The feedback path in Fig. <ref type="figure">3</ref> models this. A delay, indicated with a diamond, can be viewed simply as an initial token on the arc. In this case, a token on the feedback path represents an empty location in the buffer on the feedforward path. The total number of delays in the loop (one) is equal to the size of the buffer. The numbers adjacent to the inputs and outputs of actors indicate that actor B requires one token on the feedback path (indicating an empty location in the buffer) to fire. When actor C fires, it consumes one token from the forward path, freeing a buffer location, and indicating the free buffer location by putting one token on the feedback path. In Fig. <ref type="figure">2</ref>(b), an input token z is added to itself if the Boolean input c is true, but if it is false, then the addition actor cannot fire, and no output token is produced. Textually, w = if ( e ) then z y = w + z .</p><p>(3)</p><p>This may appear acceptable until we make the following observation. Dataflow semantics require that an arriving token x be copied to provide an input for the switch actor and a separate input for the adder.' When the c token has value false, the x the copy, but logically, the system must behave as if a copy occurred.</p><p>Note that an efficient implementation may not need to actually perform Fig. <ref type="figure">2</ref>. Some problematic configurations of dataflow actors. Fig. <ref type="figure">3</ref>. Finite token capacity on arcs can be modeled with feedback paths and delays.</p><p>token remains on the arc into the adder, unconsumed. If this system is fired again, and the arriving c token is true, then the arriving z token will be added to the previous z token, rather than to itself. If the inputs are semi-infinite streams, then memory requirements are unbounded because every false adds one more token to the queue at the adder input. In Fig. <ref type="figure">2</ref>(c), an UPSAMPLE actor produces two tokens for each one consumed, as shown in Fig. <ref type="figure">1</ref>. This is indicated in Fig. <ref type="figure">2(c</ref>) by the numbers adjacent to the input and output arcs. Such an actor can be used to implement manifest iteration <ref type="bibr" target="#b18">[19]</ref>,</p><p>and is consistent with the SDF model of computation [17], [MI.</p><p>In Fig. <ref type="figure">2(c</ref>), if the inputs are semi-infinite streams, then the memory requirements on the arc connecting the UPSAMPLE to the adder are unbounded.</p><p>In Fig. <ref type="figure">2(d</ref>) is an attempted implementation of a guarded count. Given an input z = 4, for example, a guarded counted produces a sequence of output tokens y = 4,3,2,1,0. Such a system could be used to implement data-dependent iteration, as we will see shortly. The initial token indicated by the delay has value F, for a Boolean false. On the arrival of a nonnegative integer z, the SELECT actor can fire, putting the integer z on its output. If 2 = 0, then the output of the test function is false, and the subsystem waits for the arrival of another z. If z &gt; 0, then it is decremented, selected, and tested again. However, the second time a token z arrives, the behavior deviates from that of a guarded count. Suppose the second z has value z = 2. It will be selected and tested, but the next firing of the select actor will consume the -1 token left over from the previous iteration. The output sequence will be y = 2, -1,1, -2,O. On the next firing, there will be a -1 and -3 left over on the T input to the select. With repeated firings, the output will get bizarre indeed, and memory requirements will again become unbounded.</p><p>In all four cases in Fig. <ref type="figure">2</ref>, the dataflow graphs do not express the intended behavior. Like type checking in strongly-typed languages, checking for consistency may reveal semantic errors.</p><p>Languages used to program dataflow machines, such as Val <ref type="bibr" target="#b23">[24]</ref> and ID <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b3">[4]</ref> do not have the same sort of semantics of the programs given above, although an early version of ID had some of thc. features. These languages impose syntactic constraints that prevent the type of inconsistencies found in Fig. <ref type="figure">2</ref>. Instead of actors that return multiple tokens, like UPSAMPLE, or actors that conditionally consume tokens, like SELECT, higher level constructs similar to familiar if-then-else, do-while, and forloops are provided in the languages. However, this strategy for avoiding inconsistencies may be overly restrictive. With a systematic method for identifying such inconsistencies, a new class of languages can be seriously explored.</p><p>Constructs in Val and Id such as if-then-else and de-while can be viewed as "graph constructors," since for execution on dataflow machines they are translated into dataflow graphs by a compiler. Consistency is maintained by construction. In some modern work with functional languages, an if-then-else is alternatively a function with arity three, the first argument of which is a Boolean, and the second two of which are functions. The value returned is a function, which can then applied to the data. The operation (1) could therefore be written y = if-then-else (c, f ( . ) . g ( . ) ) ( z ) .</p><p>(4)</p><p>The if-then-else function is first applied to a subset of its arguments, and the function returned is applied to z. The general form of such functions is said to be curried <ref type="bibr" target="#b4">[5]</ref>. Curried functions can be part of a dataflow graph language. The construct <ref type="bibr" target="#b3">(4)</ref> is more directly a dataflow graph description than (l), but dataflow tokens must now be able to carry functions. One way to view this innovation, therefore, is as a mechanism for getting closer to a dataflow graph description without the hazards of semantic inconsistencies. The if-then-else function in ( <ref type="formula">4</ref>) is a homogeneous SDF actor, meaning that it requires exactly one token on each input to fire, and it produces exactly one token on each output (the output of the if-then-else is a function). Homogeneous SDF actors are the best behaved of all, since they cannot lead to semantic inconsistencies of the type discussed in this paper. (This can be easily proven using the mathematics developed below.)</p><p>To distinguish our style of programming, we refer to a dataflow graph language as one with the semantics of a dataflow graph. Distinguishing features of a dataflow graph language are the use of streams as the essential data structure, the ability of actors to consume or produce multiple tokens, and a strict locality of semantics. The latter means that every operator in the language is a dataflow actor, and not a higher level construct (such as if-then-else) with semantics that can extend over a large part of a dataflow graph. Subsets of the class of dataflow graph languages Fig. <ref type="figure">4</ref>. A nested manifest iteration expressed using the SDF model have been explored before; a key reference that includes many pointers to the earlier literature is [ l l ] .</p><p>In the past, streams have been introduced to functional languages; for example, Weng defined operators first, rest, cons, and empty (a predicate) for building functions that operate on streams <ref type="bibr">[29]</ref>. The function first yields the first value in a stream, while rest yields the rest. The cons operator takes as arguments an elementary value and a stream and returns a stream with the elementary value prepended. This is identical to our delay. These functions would be familiar to Lisp programmers, but foreign to the signal processing community, for example. They do not reflect the notion of "flow" of values which is so natural when thinking of streams. Nonetheless, the method described in this paper applies equally well to programs written using such a language.</p><p>The method in this paper is inspired by the algebraic techniques of Benveniste et al. <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b21">[22]</ref>, which can accomplish some of the same objectives for a different class of languages. Fortunately, for dataflow semantics our method is usually simpler than an adaptation to dataflow of that in <ref type="bibr" target="#b6">[7]</ref>. This is discussed in more detail below in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">PROGRAM EXAMPLES</head><p>From the examples in Fig. <ref type="figure">2</ref>, the reader might conclude that SWITCH, SELECT, and UPSAMPLE actors are the culprits, and should therefore be excluded from any practical language. Equivalently, in a textual syntax, the culprit would be any function or operator that consumes or produces (returns) any nonunity number of tokens on a stream. We will see that nondeterminate actors cause similar difficulties. However, these actors or operators can lead to some elegant programs with important practical advantages.</p><p>Consider the program in Fig. <ref type="figure">4</ref>. The numbers adjacent to the inputs and outputs of the actors again indicate how many tokens are produced and consumed each time the actor fires. Consequently, the C actor fires 10 times for each firing of the B actor, which in turn fires 10 times for each firing of the A actor. Since there is nothing in this model to prevent simultaneous firing of the actors being iterated, this schema solves the first open problem listed by Dennis in <ref type="bibr" target="#b11">[12]</ref>, providing the semantics of a "parallel-for'' in a dataflow language. Dependencies across cycles of the iteration can be described using delays and feedback paths, as can history sensitivity, state, and recurrences. These dependencies may restrict concurrency, but these restrictions are immediately evident to the scheduler without need for subscript analysis. Furthermore, when the iteration is manifest, the numbers of tokens produced and consumed are fixed, as implied in Fig. <ref type="bibr" target="#b3">4</ref>. Iteration is manifest when the number of cycles to be computed is known at compile time. In this case, the graph is SDF. SDF graphs have an important practical advantage; they can be scheduled at compile time without any loss of concurrency. Hence, not only do we have a representation of a parallel for, but we have one that requires no run-time overhead to implement.</p><p>The key property of UPSAMPLE and DOWNSAMPLE actors</p><formula xml:id="formula_1">I n 6 SELECT lcount + Jcounting?</formula><p>integer input and counts down from that integer to zero.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T F T T T F T T F F T F</head><p>is the ability to consume (or produce) multiple tokens on the same logical input (or output). They lead to a truly data-driven representation of iteration. The motivation for introducing SWITCH and SELECT, or similar actors that conditionally consume (or produce) tokens, can be given by example. Consider the example shown in Fig. <ref type="figure" target="#fig_2">5</ref>. It is a corrected guarded count function [unlike Fig. <ref type="figure">2(d)</ref>] that takes an input token n, assumed to be a positive integer, and counts down from that integer to zero. Each new input token restarts the count, and is only consumed after the previous count has been completed, as illustrated in Table <ref type="table" target="#tab_0">I</ref>. The actor labeled "-1" simply decrements the value of its input token by one. The actor labeled "# O?" tests the value of the input token and outputs a Boolean. The diamond shape represents a delay, which is simply an initial token on the arc, as explained earlier. The label "F" indicates that the value of the initial token is a Boolean false. With these actors understood, it should be easy to see by inspection exactly how this function works. There is nothing difficult about constructing a counting function in any functional language. However, our function returns a token stream "count" and a Boolean stream "counting?," as shown in Table <ref type="table" target="#tab_0">I</ref>. Viewed as a macro dataflow actor, the guarded count consumes one input token when it fires, and produces a number of output tokens that depends on the data carried by the input token. In other words, it takes an input stream of any length and outputs a stream of finite streams. Viewed as a function in a textual language, the number of values returned depends on the value of its argument. This functionality would be difficult in most functional languages, and yet it proves quite useful. Note that the UPSAMPLE actor could be implemented using the guarded count, thus simplifying the language. Nonetheless, it is useful to maintain a distinction between these functions. Specifically, the UPSAMPLE produces a fixed number of output tokens, so the compiler can schedule downstream actors statically. To do the same with the guarded count would mandate that the compiler analyze the semantics of the subgraph supplying the input n to the guarded count. In general, this may be difficult.</p><p>The guarded count is used in Fig. <ref type="figure" target="#fig_3">6</ref>(a) to build a function, called "last of N," that takes an integer input N , consumes N input tokens from the x stream, and outputs only the last of the N tokens consumed, discarding the rest. This corresponds therefore to a function where the number of arguments taken depends on the value of the first argument. Again, this may be difficult to express cleanly in standard functional languages.</p><p>The "last of N" macro dataflow actor is used in Fig. <ref type="figure" target="#fig_3">6</ref>(b) to construct an iterative program to compute Fibonnacci numbers (a recursive version will be discussed later). A Fibonnacci number is the sum of the two previous Fibonnacci numbers. The two delays (initialized to one) remember the two previous Fibonnacci numbers. The "last of N" actor selects the desired Fibonnacci number from the stream of numbers supplied at its x input. The style of iteration here is similar to that in Fig. <ref type="figure">4</ref>, but the iteration is not manifest. Unfortunately, the function in Fig. <ref type="figure" target="#fig_3">6</ref>(b) can only be run once because once the initial tokens in the delays are consumed, there is no mechanism for resetting them to one after the Fibonnacci number has been produced. One possibility is to introduce the notion of context as in the tagged-token scheme [l]. Another possibility is shown in Fig. <ref type="figure" target="#fig_3">6(c</ref>). In that graph, the boxes labeled "1" put out a token with unity value whenever they fire.</p><p>The MUX (for multiplexer) actors are related to SELECT, but consume a token at both inputs, discarding one, and copying the other to the output. With the two delays in the feedback path initialized to unity, the Boolean delay can be initialized to true or false. It is shown initialized to false. It will be reinitialized to false after each computation of a Fibonnacci number because the counting? Boolean has value false when the guarded count has finished counting2 2There is a significant disadvantage to the program shown in Fig. <ref type="figure" target="#fig_3">6(c</ref>). Without a detailed analysis of the program semantics, it appears that there It would hard to claim that this Fibonnacci implementation is conventional. The control is truly data-driven, via the production and consumption of multiple tokens and not by manipulation of a loop counter. A more dramatic example, one that is more difficult to build using established functional languages, is the ordered merge shown in Fig. <ref type="figure">7</ref>. First, a macro actor called sort is explained in Fig. <ref type="figure">7(a)</ref>. This actor accepts two numerical inputs and outputs the maximum on one path and the minimum on the other. It also outputs a Boolean indicating whether or not the ordering of the two inputs was swapped on the outputs. Note that this macro actor is built entirely of homogeneous SDF actors, and is a homogeneous SDF macro actor itself. Hence, it can be statically scheduled. The same MUX actor as in Fig. <ref type="figure" target="#fig_3">6(c</ref>) is used.</p><p>The ordered merge program, shown in Fig. <ref type="figure">7</ref>(b), uses the sort macro actor to merge two monotonically increasing numerical streams into one monotonically increasing stream. The XOR actor is an Exclusive OR. The delay on the right is used to remember which input stream supplied the last token consumed. Whenever the Boolean swapped? is true, the next token consumed comes from the opposite stream. The delay on the left remembers the token that was not output the last time. In other words, the SELECT takes inputs from t2 until it gets a token with value exceeding the stored token. Then it stores the t2 token and takes inputs from the t , stream until it again gets a token exceeding the stored token. It continues alternating. The resulting output is the merged stream. Notice that the program is built of very few operations.</p><p>The first output of the ordered merge is -E. This output can be easily discarded if it is problematic to the downstream system. However, it may be useful. Note that if we design the sort actor so that max(+x. +x) = -x anti m i r i ( + x . +cc) = +x. ( 5 ) then the merge function can take streams of finite streams with marking the beginning and end of each stream.3 are data dependencies between successive Fibonnacci computations, while actually this is not true. One solution to this problem is a "resetting delay," introduced in 1191. These are delays that revert to their initial value each time a subgraph fires, where the name of the subgraph is a property of the delay. 3This solution was suggested by David Culler. As before, another way to do this may be with resetting delays, although there are still open problems with such a method <ref type="bibr" target="#b18">[19]</ref>. Although all of these examples can be implemented using more conventional techniques, there are some advantages to the representations given here in conciseness and implementation issues. Fundamentally, what is unique here is the use of actors that can conditionally or unconditionally produce or consume one or more tokens on each logical input or output. Control is truly data-driven. Again, a language with these properties could have a textual syntax. The major difficulty is the possibility of introducing sometimes subtle inconsistencies such as those in Fig. <ref type="figure">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. VERIFYING CONSISTENCY</head><p>In <ref type="bibr" target="#b16">[17]</ref> it is shown that consistency can be easily checked for SDF graphs. The test is generalized here to arbitrary dataflow graphs, thus identifying all the other inconsistencies in Fig. <ref type="figure">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The Token-Flow Model</head><p>Consider the actors in Fig. <ref type="figure">8</ref>. These are SDF actors plus control actors fashioned after those of Dennis <ref type="bibr" target="#b11">[12]</ref>. The first one consumes N and M tokens on each input when it fires and produces L tokens on the output. If these numbers are positive integer constants, the actor is an SDF actor. The SWITCH actor in Fig. <ref type="figure">8(b)</ref>, by contrast, is not an SDF actor. The numbers of tokens produced on the two outputs are not constant (they depend on the Boolean input). In Fig. <ref type="figure">8</ref>(b), the outputs are labeled with the long-term average number of tokens produced as a function of the proportion p , of Boolean input tokens c that are true. The SELECT actor is the complement, in that it consumes a token from one of two input streams depending on a Boolean input. The average number of tokens consumed and produced is similarly shown. The TRUE GATE outputs the token from its top input if the Boolean input is "true." The TRUE GATE and FALSE GATE are merely shorthand for the SWITCH when one of the two outputs is discarded. If a textual syntax is being used, these actors may be more convenient than the SWITCH because they return only one stream.</p><p>The proportions used in Fig. <ref type="figure">8</ref> can be interpreted as probabilities in the Bayesean sense, in that they model uncertainty about the value of the Boolean token. In other words, a program may be completely deterministic, but we can nonetheless use probabilities to model what the compiler cannot easily discern about the Boolean stream. The appropriate stochastic interpretation is as follows: if a Boolean stream c has proportion p , of true tokens, then a randomly selected token from the stream has probability p , of being true. This seemingly pedantic statement is necessary to avoid implying unjustifiable assumptions about independence of tokens in a stream.</p><p>A Boolean stream may be an input to the system, but more likely it is generated by testing non-Boolean data values. The actor performing the test is most likely an SDF actor, but without analyzing its semantics and those of the program that generate its input, the compiler cannot know the probability of "true" for the output of the test. Hence, each such output is given a unique name and the compiler assumes that the value of the output has some unknown probability p,,,,,, of being true. As we will see shortly, we need not be concerned with the value of p,,,,,, since all manipulations can be done symbolically. If two Boolean streams are produced by testing the same data, they are likely to be correlated. It may not be practical for a compiler to detect this correlation, so it is forced to make worst case assumptions. Sometimes, when Boolean streams are combined to produce new Boolean streams, a compiler may be able to detect correlations. This possibility will be addressed in Section V below. For now, we assume that the compiler knows nothing of correlation between Boolean streams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Consistency and Strong Consistency</head><p>We will call a dataflow graph consistent if on each arc, in the long run, the same number of tokens are consumed as produced. We will call it strongly consistent if it is consistent for all possible p , for each Boolean stream c in the graph.</p><p>First, a requirement for consistency or strong consistency is that the graph have the potential to be nonterminating. In other words, it must be free of deadlocks. Deadlocks would occur, for example, when the graph has insufficient delays on a cycle. In <ref type="bibr" target="#b16">[17]</ref>, a systematic method for checking for deadlocks is given for SDF graphs. A related method has been applied by Benveniste et al. to a language that includes conditional invocation and nondeterminism [8]. This method could perhaps be extended to dataflow graphs, but since detecting deadlocks can be decoupled from detecting inconsistencies, for the purposes of this paper, we will simply assume all graphs are free of deadlocks.</p><p>The path of cl and c2 tokens requires that YSW = 91 = @E.</p><p>Assuming f ( . ) and g(.) each consume and produce one token <ref type="bibr" target="#b6">( 7 )</ref> when they fire, then from Fig. <ref type="figure">8</ref> we have</p><formula xml:id="formula_2">PrlYs\$ = 4f (1 -P C l ) 4 S \ Z = Yr/ l-'c,YSE = qf (1 -pc,)qSE = 4s.</formula><p>Combining <ref type="bibr" target="#b6">(7)</ref> and <ref type="bibr" target="#b7">(8)</ref> we conclude that consistency requires that p,, = p , 2 = 0.5.</p><p>Hence, this graph is consistent subject to <ref type="bibr" target="#b8">(9)</ref>, and therefore not strongly consistent. Applying the same method to Fig. <ref type="figure">2(c</ref>  <ref type="bibr" target="#b11">(12)</ref> Collecting one such equation for each arc in the graph, we get a system of equations that can written compactly using matrix notation, rq = o (13) Some perfectly correct, albeit bizarre programs, are consistent, but not strongly consistent. For example, the graph in Fig. <ref type="figure">2(b</ref>) is consistent if c is known to be always true. To show this, we</p><p>The vector q specifies the proportion of times each actor fires, and should therefore be normalized, can perform a simple analysis using Fig. <ref type="figure">8</ref>. This analysis alludes to a more systematic method that will be developed below.</p><p>Since both actors in Fig. <ref type="figure">2</ref>(b) consume exactly one token from the z input stream, both actors should fire the same number of times, in the long run. However, the SWITCH only produces an expected p , tokens on its T output, implying that the add actor should fire p , times as often as the SWITCH. These two statements can be reconciled if and only if p , = 1. So we see that the graph in Fig. <ref type="figure">2(b</ref>) is consistent, subject to p , = 1, but not strongly consistent.</p><p>The remaining examples in Fig. <ref type="figure">2</ref> can be dispatched similarly. The example in Fig. <ref type="figure">2</ref>(a) has more actors than the one in Fig. <ref type="figure">2(b)</ref>, so we should be more systematic about its analysis. Define qsw to be the proportion of total firings that are firings of the SWITCH actor. Similarly, YSE is the proportion of SELECT firings, q,v of NOT firings, qf of f(.) firings, and qg of g ( . )</p><p>firings. Since these are all the actors under consideration,</p><formula xml:id="formula_4">qSW + qSE + 4V + qf + yq = 1 (6) l T q = 1,</formula><p>where 1 is a column vector full of 1's. The matrix r has one row for each arc in the graph and one column for each actor. Each row has two entries, the average number of tokens produced, and the negative of the average number of tokens consumed. Consistency requires that there be a solution to <ref type="bibr" target="#b12">(13)</ref> and ( <ref type="formula">14</ref>) for some set of Boolean proportions. Strong consistency requires that there be a solution to <ref type="bibr" target="#b12">(13)</ref> and ( <ref type="formula">14</ref>) for any set of Boolean proportions.</p><p>We first illustrate the systematic m6thod by proving that the attempted guarded count of Fig. <ref type="figure">2(d</ref>) is not consistent. The graph has been reduced to its essentials in Fig. <ref type="figure">9(a)</ref>, where the three actors have been numbered, as have the arcs connecting them (using triangular flags). To simplify things slightly, the select is shown duplicating its output, to avoid adding a "fork" actor to the analysis.</p><p>Notice that the delay in Fig. <ref type="figure">2(d</ref>) has been omitted in Fig. <ref type="figure">9</ref>(a). Recall that a delay is an initial token on an arc, with value "false" in this case. The delay is not an actor. In steady state, the r = Fig. <ref type="figure">9</ref> (a) The essentials of the example in Fig. <ref type="figure">2(d</ref>) with actors and arcs numbered for systematic analysis. (b) A similar representations of the guarded count in Fig. <ref type="figure" target="#fig_2">5</ref>.</p><p>--p&lt;</p><formula xml:id="formula_5">1 0 0 - 1 0 0 -1 -1 0 0 1 0 0 -1 1 1 0 -1 0 -0 -1 p , 0 -<label>(17)</label></formula><p>proportion p , of true's at the output of the delay is the same as the proportion at the input. Hence, if the initial token has value "false," this simply imposes the constraint that p , &lt; 1, while if it has value "true," the corresponding constraint is p,. &gt; 0. We will address this and related constraints in Section V below, so for now the delay will be omitted in the analysis. The topology matrix for Fig. <ref type="figure">9</ref>(a) is satisfies <ref type="bibr" target="#b12">(13)</ref> and ( <ref type="formula">14</ref>). This is true for any p,, so the graph is internally strongly consistent. The qualifier "internally" is used because we are ignoring the rest of the system, to which the guarded count is connected. To consider the behavior of the guarded count in a larger system we can consolidate its properties into macro "guarded count" actor, as shown in Fig. <ref type="figure" target="#fig_5">10</ref>. This approach is consistent with using hierarchy to control complexity. The labels in Fig. <ref type="figure">lO(a)</ref> indicate that for every 2 tokens consumed, there will be 1/(3 + p r ) "count" and "coiint%ng?" tokens produced. These expressions are obtained by multiplying the entry qr in ( <ref type="formula">18</ref>) by the average number of input (output) tokens consumed (produced) by each actor 5 connected to the outside. Notice, however, that the analysis of a system using the guarded count (or any other actor) is not affected by multiplying the average numbers of tokens produced and consumed by any constant. In other words, the token-flow model for any actor is not unique. Equivalently, any row of r can be scaled without affecting its rank. Multiplying the expressions in Fig. <ref type="figure">l0(a</ref>) by e, we get the more intuitive expressions in Fig. <ref type="figure" target="#fig_5">10(b)</ref>.</p><p>The same technique can be applied to the examples in Fig. <ref type="figure" target="#fig_3">6</ref> and Fig. <ref type="figure">7</ref>, getting the consolidated results shown in Fig. <ref type="figure">11</ref>.</p><p>The interpretation of the solution q to (13) and (14) as a vector of proportions of firings of each actor is useful for developing intuition. Consider Fig. <ref type="figure">12</ref>(a). The top arc implies qn = q ~, meaning that actors A and B should fire the same number of times. Furthermore, it is immediately evident that the program in Fig. <ref type="figure">12</ref>(a) is consistent if and only if p , = 0.5. By contrast, the program in Fig. <ref type="figure">12(b</ref>) is strongly consistent. Consistency can also be checked when recursion is used. Recursion in a dataflow graph can be represented using selfreferential hierarchy. In Fig. <ref type="figure" target="#fig_7">13</ref>, for example, the path of the c Boolean indicates that qslt-= qSE, so IC = y, where IC and y are the number of tokens consumed and produced by the Fibonnacci function. Since any z = y will yield the same consistency result, we can set z = y = 1. Showing that Fig. <ref type="figure" target="#fig_7">13</ref> is consistent then becomes trivial.</p><p>Finally, nondeterminate actors can also be accommodated in the analysis. It has been argued that nondeterminate actors should be added to dataflow languages in order for programs to interact with multiple external events, for example transaction processing, interprocess communication, or interaction with external hardware <ref type="bibr" target="#b14">[15]</ref>. A nondeterminate merge has been proposed by Arvind and Brock <ref type="bibr" target="#b1">[2]</ref>, and resource managers have been built using it. The nondeterminate merge is an "unordered" merge where token streams can be merged in unpredictable ways, depending on the time of arrival of tokens. By contrast, the ordered merge of Fig. token-flow model does not require knowledge of the expected number of tokens consumed. Fundamentally, nondeterminism means that there is not enough information in the program for this to be known. The token-flow model for the unordered merge is the same as that for the ordered merge shown in Fig. <ref type="figure">11</ref>.</p><p>The unordered merge of the previous paragraph will eventually pass all tokens that appear at its inputs to the output. Hence, the sum of the expected number number of tokens consumed on the two inputs is unity. Another type of nondeterminate merge might discard one input if two input tokens appear "simultaneously," where the meaning of ''simultaneously" depends on the implementation and/or the context. Such an actor would be a dataflow version of the "default" operator in the SIGNAL language [SI. The token-flow model for such an actor is only slightly more complicated, as shown in Fig. <ref type="figure">14</ref>. When the actor fires, it has probability p , of consuming a token from the upper input and probability p , of consuming a token from the lower path. Normally, p , + p , 2 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. MUTUALLY DEPENDENT BOOLEANS</head><p>The analysis so far ignores any possible relationship between values in separate Boolean streams. Each Boolean stream c gets a symbol p , associated with it, and the analysis reveals constraints on p , that may have to be satisfied for consistency. When a program is strongly consistent, there are no constraints, and no further analysis is required. Similarly, when a program is inconsistent, additional analysis will not help. However, when a program is conditionally consistent, further examination may be required. In particular, Boolean streams may be interrelated, and these interrelationships may either contradict or enforce the conditions for consistency. Some examples of Boolean operators are shown in Fig. <ref type="figure" target="#fig_9">16</ref>. These actors take Boolean inputs and produce Boolean outputs. In these cases, it is sometimes possible for a compiler (or a programmer) to make use of the joint statistics. The probabilities of the outputs being ''true'' can be expressed in terms of joint probabilities of the inputs being true, as shown in Fig. <ref type="figure" target="#fig_9">16</ref>. In the figure, the notation Pr[cl = T , c Z = F ] is the joint probability that c1 is true and c2 is false. However, care must be taken that this joint probability applies to tokens in the c, and c2 streams that are consumed by the same firing of the actor. When the compiler (or programmer) can analyze these joint statistics, these expressions can be used to determine consistency when Boolean streams are not independent.</p><p>None of the examples discussed so far require using the Boolean relationships in Fig. <ref type="figure" target="#fig_9">16</ref> to determine consistency. Even the ordered merge of Fig. <ref type="figure">7</ref>, which contains an Exclusive OR, is consistent for any Boolean stream coming out of the XOR, so the logical properties of the XOR are not important. Any logical operator in its place would also yield a strongly consistent graph. However, not all programs exhibit this property. For some programs, solving <ref type="bibr" target="#b12">(13)</ref> and ( <ref type="formula">14</ref>) may lead to a conclusion that a program is only conditionally consistent. Applying the relationships in Fig. <ref type="figure" target="#fig_9">16</ref> to this result may show that the program is strongly consistent, or not consistent at all. Hence, if an analysis ignoring the logical relationships between Booleans reveals conditional consistency, this result should be considered inconclusive. Further analysis can sometimes help.</p><p>Consider the example shown in Fig. <ref type="bibr" target="#b15">16</ref>. Only Fig. <ref type="figure" target="#fig_9">16(c</ref>) is strongly consistent. Solving ( <ref type="formula">13</ref>) and ( <ref type="formula">14</ref>) for Fig. <ref type="figure" target="#fig_9">16</ref>(a), we find that it is consistent if and only if p , , = 1. It is easy to verify by inspection that this situation leads to consistent graphs, but also to semantics that are probably not intended. The program in Fig. <ref type="figure" target="#fig_9">16(b</ref>) is an attempt to correct the problem. However, it also fails the strong consistency test because the AND actor synchronizes the c1 and c2 token streams, constraining the rates of tokens to be the same. Again we find consistency if and only if p,, = 1. There is no need to use the Boolean relationships of Fig. <ref type="figure" target="#fig_9">16</ref>. For Fig. <ref type="figure" target="#fig_9">16</ref>(c), however, solving ( <ref type="formula">13</ref>) and ( <ref type="formula">14</ref>), we get consistency if and only if p,q = pc,pc,.</p><p>From the relationships in Fig. <ref type="figure" target="#fig_9">16</ref>, which is always true by the multiplication rule in probability! Consequently, this graph is strongly consistent.</p><p>In summary, the system of equations given by ( <ref type="formula">13</ref>) and ( <ref type="formula">14</ref>) can be augmented with a set of relationships such as those in <ref type="bibr" target="#b19">(20)</ref>, which combined with the rules of probability may reveal strong consistency or inconsistency when ( <ref type="formula">13</ref>) and ( <ref type="formula">14</ref>) alone only reveal conditional consistency. The above analysis must be performed carefully, ensuring that when probabilities are combined at a logical operator, they are combined for tokens that are simultaneously consumed. If, for example, a delay were introduced in the path of one of the Boolean streams in Fig. <ref type="figure" target="#fig_9">16(c</ref>), the analysis might require knowledge about joint statistics of successive tokens on the streams. This knowledge may not be available to a compiler, or even to the programmer. Similarly, Boolean streams that are generated by testing non-Boolean streams may have joint statistics that are difficult or impossible for a compiler to discern. In principle, a compiler that does elaborate semantic analysis of the program and has complete information about the input streams could use this type of analysis to verify consistency (barring nondeterminate actors), but such a compiler is probably not practical. A practical compiler will only be able to completely analyze a subset of all programs. For this reason, a simple version of a compiler would solve ( <ref type="formula">13</ref>) and ( <ref type="formula">14</ref>), and if there are conditions for consistency, then it would alert the programmer to them, using for example the following output:</p><p>Warning: Consistency holds only if Boolean signals c1 and c2 satisfy the following relationship: p,, = 1 -p c 2 .</p><p>We then rely on the programmer's understanding of the program semantics to draw the final conclusion about consistency. A more elaborate compiler could use relationships like those in Fig. <ref type="figure" target="#fig_9">16</ref> to draw firm conclusions when possible, and again alert the programmer when firm conclusions are not attainable. A comparatively simple symbolic processing kernel could accomplish this task, and would avoid some unnecessary warnings.</p><p>It is worth noting that Benveniste et al. propose the use of finite-state machines to represent the dynamics of Boolean signals in a program containing delays <ref type="bibr" target="#b6">[7]</ref>. But ultimately the technique still relies on human interpretation of the conditions for consistency on at least some programs. For example, the technique does not help to establish interrelationships between Boolean streams that are generated from non-Booleans. Further study is warranted to identify the best method for automating the analysis of the class of programs that can be analyzed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. COMPARISON TO HDS THEORY</head><p>The method given in this paper was inspired by the algebraic techniques of Benveniste er al. <ref type="bibr" target="#b6">[7]</ref>- <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b21">[22]</ref>. These methods have been applied to a language called SIGNAL which is not a dataflow graph language, but is related. The SIGNAL language is used to describe systems in a class called Hybrid Dynamical Systems (HDS). Analytical methods in HDS theory identify inconsistencies similar to those found in dataflow graph languages.</p><p>HDS theory works as follows. A signal consists of a sequence of slots. Each slot is assigned an indicator -1, 0, or +1, where -1 refers to a Boolean false, 0 refers to the absence of a value (bottom), and +1 refers to a Boolean true. Any number of zeros can appear between two nonzeros without changing the meaning of a signal. Given this model, the input/output relationships of operators can be described algebraically, where the algebra is performed in a finite field (or Galois field) with three elements, -1,O, and $1. This simply means that modulo arithmetic is used. In this algebra, for example, the following statements are true:</p><p>x + x = -I I :</p><p>x,'J = II:</p><formula xml:id="formula_6">(22) x4 = x2.</formula><p>Non-Boolean values are simply assigned an indeterminate f 1.</p><p>Hence, a slot from the non-Boolean signal 2 either has a value (in which case 2' = l), or does not (2 = 0). In other words, only the signal clock is represented for non-Booleans.</p><p>Given this framework, functions similar to the dataflow actors we have been using can be described as shown in Fig. <ref type="figure">17</ref>. The relationships between the input and output signals within the algebra are shown. To understand these, consider the SELECT function, which has three relationships describing its behavior. Considering the first relationship, notice that if c = 0 (the control signal is absent) then II: = 0 (the output is absent). If c = -1 (the control signal is false) then x = z. If c = 1 (the control signal is true) then x = y, using <ref type="bibr" target="#b21">(22)</ref>. This is precisely the behavior we expect from the SELECT function. However, the description is still not complete. Suppose c = 1 and y = 0. The dataflow version of the SELECT does not fire if y is absent and c is true. To get similar behavior in the HDS function, we impose two more constraints on the input/output behavior of the SELECT. The second relationship shown in Fig. <ref type="figure">17</ref>   (say y2 = l), then the other input must be present 2 ' = 1, and the output will be present x2 = 1. Nonhomogeneous SDF actors cannot be described statically; a finite-state-machine model is introduced to model the dynamics. The reader may have already noticed the key difference between this model and the dataflow model. Specifically, it is not permitted for one input of f(.) to be present unless the other input is also present. In other words, the arcs connecting functions do not have implicit FIFO queues, as they do in the dataflow model. Expressed yet a third way, the production of a data value on an arc is simultaneous with its consumption at the destination. A consequence of this is that slots in different signals have a temporal relationship with one another. In principle, a dataflow model can be built using HDS by defining a function with the behavior of a FIFO queue, and inserting this function between every pair of dataflow actors. However, the FIFO queue introduces dynamics, considerably complicating the analysis.</p><p>Using HDS to represent dataflow semantics, therefore, is not very</p><formula xml:id="formula_7">+ C' UT( SELECT i X x = c ( r ( l -C ) -y ( l + c ) ) -(c + 1)c =y2 -(c -1)c = z 2</formula><p>Fig. <ref type="figure">17</ref>. The inputioutput relationships of certain functions in a hybrid dynamical system (HDS) are shown here. All relationships are expressed in a Galois field with three elements, -1, 0, and +1 attractive. Instead, we will use HDS in its simplest form, and we will use this model to identify inconsistencies that are similar in flavor to those we have previously identified in dataflow graphs. Unlike the dataflow inconsistencies, the HDS inconsistencies do not lead to unbounded token buildup, since there is no queueing of tokens on arcs. Instead, they lead to constraints on Boolean signals, or to absent outputs, or to contradictions in algebraic relationships.</p><p>Consider the example in Fig. <ref type="bibr" target="#b17">18</ref>. Under the dataflow model, this graph is inconsistent unless p , = 0. Applying the HDS model to this graph, we get the relationships shown in the figure. These four relationships can be solved to get a constraint on c, namely This constraint is satisfied if either c = 0 (nothing happens), or c = -1 (the control input is false). Hence, the conclusion is the same as for the corresponding dataflow graph.</p><p>For the graph in Fig. <ref type="figure">2</ref>(a), interpreted as an HDS program, the theory reveals that y = 0, or the output is always absent. This is not quite the same conclusion as for the corresponding dataflow program, which is consistent if p , = 0.5. The difference is entirely due to the FIFO behavior of arcs in the dataflow model.</p><p>For the graph in Fig. <ref type="figure">2</ref>(b), HDS theory reveals that when xz = 1 (the z input is present) then c = 1 (the control input is true). This is the same conclusion as that of the token-flow model, which requires that p , = 1.</p><p>The examples in Fig. <ref type="figure">2(c</ref>) and (d) are much more complicated to analyze using the HDS model. The reason is that the relationships shown in Fig. <ref type="figure">17</ref>  the FIFO queue implicit on every arc also introduces dynamics.</p><p>Although analysis is possible in this framework, it is not simple, and is beyond the scope of this paper. The reader is referred to <ref type="bibr" target="#b6">[7]</ref>. The comparative simplicity of the token-flow analysis of dataflow programs with dynamics should be viewed as one of its major advantages. The simplicity arises from performing a steady-state analysis. The steady-state analysis is made possible by the implicit queueing of tokens on arcs, absent in the language model in <ref type="bibr" target="#b6">[7]</ref>.</p><p>As mentioned before, neither the token-flow model nor HDS theory can always verify consistency. For some programs, both models yield inconclusive results when the relationships between Boolean streams cannot be known to the compiler. This occurs, for example, when two Boolean streams are derived by testing the same non-Boolean stream.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSIONS</head><p>Consistency and strong consistency in dataflow graphs has been defined, and a systematic test for them has been developed. The test uses a simple steady-state analysis of the flow of tokens, and yields one of three possible results. A program is either inconsistent, conditionally consistent, or strongly consistent. When a program is conditionally consistent, a compiler could simply alert the programmer of the conditions for consistency, and the programmer could use his or her understanding of the semantics of the program to draw the final conclusion. A more sophisticated compiler could symbolically manipulate Boolean relationships to attempt to draw a conclusion. For some programs, however, a compiler cannot draw a definitive conclusion without extensive semantic analysis of the program and information about the program inputs.</p><p>The token-flow model given here has been compared to similar tests applied to hybrid dynamical systems by Benveniste et al.</p><p>[7]- <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b21">[22]</ref>. It is argued that dataflow semantics make steadystate analysis possible, which leads to a simpler method in most cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>Numerous discussions helped solidify the arguments given in this paper. The author would like to especially thank A. Benveniste, who went well beyond the call of duty in carefully reading and commenting on the manuscript. In addition, other significant contributions of ideas and criticism were made by Arvind, D. Culler, S. Ha, A. Ranade, R. Righter, and V. Srini. In addition, P. LeGuernic of INRIA was kind enough and patient enough to explain to me the basics of HDS theory and the SIGNAL language, which inspired this work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>; revised May 21, 1990. This work The author is with the Department of Electrical Engineering and Computer IEEE Log Number 9042575. was supported by NSF (MIP-8657523)), and the Sony Corporation. Science, University of California, Berkeley, CA. design of related languages, such as functional languages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Fig. 1.here. The UPSAMPLE and DOWNSAMPLE actors can be parameterized to produce any number of tokens given an input token.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. A guarded count. This function takes a nonnegative</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. (a) The "last of -Y'' function consumes 3-tokens from its . r input path and outputs only the last token. (b) An iterative Fibonnacci number function that can only be run once without re-initializing the delays. (c) A Fibonnacci number function that can be run indefinitely.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .Fig. 8 .</head><label>78</label><figDesc>Fig. 7. (a) This sort macro dataflow actor takes two input tokens when it fires, and outputs the larger one on the maz output and the smaller one on the min output. It is built entirely of homogeneous SDF actors. (b)The sort actor is used to build an "ordered merge" system, which takes two monotonically increasing token streams and combines them into one monotonically increasing stream.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. The summarized token-flow model for the guarded count, shown with two equally valid sets of "average number tokens consumed and produced."</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>MERGEFig. 11 .Fig. 12 .</head><label>1112</label><figDesc>Fig. 11. Consolidations of the systems shown in Fig. 6 and Fig. 7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>13 .</head><label>13</label><figDesc>p,, = Pr[cl = T,c2 = T ] and pcB = Pr[c Hence, condition (19) is equivalent to Pr[cl = T , c2 = T ] = p,, Pr[q = T A recursive dataflow graph for computing Fibonnacci numbers. It can be analyzed using the token-flow model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 15 .</head><label>15</label><figDesc>Fig.<ref type="bibr" target="#b14">15</ref>. Boolean actors produce new Booleans as a function of input Booleans. The true probabilities of the outputs are related to the joint and conditional probabilities of the inputs, as shown here.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. The programs in (a) and (b) are consistent only for pc2 = 1. The program in (c) is strongly consistent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>YFig. 18 .</head><label>18</label><figDesc>Fig. 18. An example of a program that is inconsistent under either the HDS model or the dataflow model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I AN</head><label>I</label><figDesc>EXAMPLE OF AN INPUT STREAM n AND THE OUTPUT TOKENS ARE ALIGNED TO SHOW WHEN OUTPUT TOKENS STREAMS Count AND C O U n t Z n g ? ARE SHOWN HERE.THE ARE PRODUCED RELATIVE TO THE INPUT TOKENS CONSUMED</figDesc><table><row><cell>n</cell><cell>1</cell><cell></cell><cell>3</cell><cell></cell><cell></cell><cell></cell><cell>2</cell><cell></cell><cell></cell><cell>0</cell><cell>1</cell><cell></cell></row><row><cell>count</cell><cell>1</cell><cell>0</cell><cell>3</cell><cell>2</cell><cell>1</cell><cell>0</cell><cell>2</cell><cell>1</cell><cell>0</cell><cell>0</cell><cell>1</cell><cell>0</cell></row><row><cell>counling?</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P x</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PRIORITIZED NON-DETERMINATE MERGE</head><p>Edward Ashford <ref type="bibr">Lee</ref>  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The U-Interpreter</title>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Gostelow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput. Mag</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1982-02">Feb. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Resource managers in functional programming</title>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Brock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel Distributed Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="5" to="21" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Dataflow architectures</title>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computation Structures Group Memo TM-294, 1986, Lab. for Comput. Sci., MIT, 545 Technology Square</title>
		<meeting><address><addrLine>Cambridge, MA 02139</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">ID nouveau reference manual</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Arvind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Nikhil</surname></persName>
		</author>
		<author>
			<persName><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computation Structures Group Memo</title>
		<imprint>
			<date type="published" when="1987-04-24">Apr. 24, 1987</date>
			<pubPlace>Cambridge, MA 02139</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology, 545 Technology Square</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Executing a program on the MIT Tagged-Token Dataflow Architecture</title>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Nikhil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computation Structures Group Memo</title>
		<imprint>
			<biblScope unit="volume">271</biblScope>
			<date type="published" when="1988-06-20">June 20. 1988</date>
			<pubPlace>Cambridge, MA 02139</pubPlace>
		</imprint>
	</monogr>
	<note>Technology Square</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Parallel processing with large grain data flow techniques</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Babb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput. Mag</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="1984-07">July 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Hybrid dynamical systems theory and the language &apos;SIGNAL</title>
		<author>
			<persName><forename type="first">A</forename><surname>Benveniste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">Le</forename><surname>Goff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Le</forename><surname>Guernic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Institut National de Recherche en Informatique et en Automatique (INRIA)</title>
		<imprint>
			<biblScope unit="volume">838</biblScope>
			<date type="published" when="1988-04">Apr. 1988</date>
			<publisher>Domain de Voluceau</publisher>
			<pubPlace>Rocquencourt, B.P. 105, 78153 Le Chesnay Cedex, France</pubPlace>
		</imprint>
	</monogr>
	<note>Res. Rep.</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hybrid dynamical systems theory and the SIGANL language</title>
		<author>
			<persName><forename type="first">A</forename><surname>Benveniste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Le</forename><surname>Guernic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Automat. Contr</title>
		<imprint>
			<biblScope unit="page" from="535" to="546" />
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A denotational theory of synchronous reactive systems</title>
		<author>
			<persName><surname>__</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Computat</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Data driven nets: A maximally concurrent, procedural, parallel process representation for distributed control systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dep. Comput. Sci., Univ. of Utah</title>
		<imprint>
			<date type="published" when="1978">1978</date>
			<pubPlace>Salt Lake City, UT</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. UUCS-78-108</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Data flow program graphs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Keller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput. Mag</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1982-02">Feb. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">First version data flow procedure language</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Dennis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tech. Memo MAC TM</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<date type="published" when="1975-05">May 1975</date>
		</imprint>
		<respStmt>
			<orgName>MIT Laboratory for Computer Science</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Data flow supercomputers</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput. Mag</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">11</biblScope>
			<date type="published" when="1980-11">Nov. 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Silage Reference Manual, DRAFT Release 2.0</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Hilfinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science Division, EECS Dep</title>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="issue">720</biblScope>
			<date type="published" when="1989-07-08">July 8, 1989</date>
			<publisher>UC Berkeley</publisher>
			<pubPlace>Berkeley, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A straightforward denotational semantics for nondeterminate data flow programs</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Kosinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf Record 5th Annu. ACM Symp. Principles of Programming Languages</title>
		<meeting><address><addrLine>Tuscon, AZ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Y</forename><surname>Kung</surname></persName>
		</author>
		<title level="m">KSI Array Processors</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Static scheduling of synchronous data flow programs for digital signal processing</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Messerschmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1987-01">Jan. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Synchronous data flow</title>
		<author>
			<persName><forename type="first">~</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE, Sept</title>
		<meeting>IEEE, Sept</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Static scheduling of dataflow programs for DSP</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<editor>Dataflow Computation, L. Bic and J.-L. Gaudiot Eds</editor>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Gabriel: A design environment for DSP</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Goei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhattacharyya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Acoust., Speech, Signal Processing</title>
		<imprint>
			<date type="published" when="1989-11">Nov. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Architectures for statically scheduled dataflow</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel Distributed Comput</title>
		<imprint>
			<date type="published" when="1990-12">Dec. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Data-flow to von Neumann: the SIGNAL approach</title>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Le</forename><surname>Guernic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gautier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Dataflow Computation</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The VAL Language: Description and Analysis</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Mcgraw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="44" to="82" />
			<date type="published" when="1982-01">January 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Computation Structures Group Memo 284</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Nikhil</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">Aug. 29. 1988</date>
			<pubPlace>Cambridge, MA 02139</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology, 545 Technology Square</orgName>
		</respStmt>
	</monogr>
	<note>ID Reference Manual</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficient demand-driven evaluation. Part I</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Proerammine Laneuaees Svst</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The semantic elegance of applicative languages</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Conf Functional Programming Languages Comput</title>
		<meeting>ACM Conf Functional Programming Languages Comput</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Architecture</title>
		<imprint>
			<biblScope unit="volume">198</biblScope>
			<biblScope unit="page">85192</biblScope>
			<pubPlace>Portskouth, NH</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Stream-oriented computation in recursive data flow schemas</title>
		<author>
			<persName><forename type="first">K.-S</forename><surname>Weng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Lab. for Comput. Sci. (TM-68)</title>
		<meeting><address><addrLine>Cambridge, MA 02139</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1975-10">Oct. 1975</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
