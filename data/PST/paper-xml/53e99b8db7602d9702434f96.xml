<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Modular Verification of Software Components in C *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sagar</forename><surname>Chaki</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Edmund</forename><surname>Clarke</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Alex</forename><surname>Groce</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Somesh</forename><surname>Jha</surname></persName>
							<email>jha@cs.wisc.edu</email>
						</author>
						<author>
							<persName><forename type="first">Helmut</forename><surname>Veith</surname></persName>
							<email>veith@dbai.tuwien.ac.at</email>
						</author>
						<author>
							<persName><forename type="first">T</forename><forename type="middle">U</forename><surname>Vienna</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Univ of Wisconsin</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Modular Verification of Software Components in C *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4EC0AAD5A1B0743563C43E36F7216BAD</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a new methodology for automatic verification of C programs against finite state machine specifications. Our approach is compositional, naturally enabling us to decompose the verification of large software systems into subproblems of manageable complexity. The decomposition reflects the modularity in the software design. We use weak simulation as the notion of conformance between the program and its specification. Following the abstractverify-refine paradigm, our tool MAGIC first extracts a finite model from C source code using predicate abstraction and theorem proving. Subsequently, simulation is checked via a reduction to Boolean satisfiability. MAGIC is able to interface with several publicly available theorem provers and SAT solvers. We report experimental results with procedures from the Linux kernel and the OpenSSL toolkit.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>State machines have been recognized repeatedly as a cardinal point in the software development process; in fact, variants of state machines have been proposed for virtually all software engineering methodologies, including, most notably, Statecharts <ref type="bibr" target="#b24">[25]</ref> and the UML <ref type="bibr" target="#b8">[9]</ref>. The sustained success of state machines in software engineering derives from the fact that state machines provide for both a concise mathematical theory, and an intuitive semantics of system behavior which naturally allows for visualization, hierarchy, and abstraction.</p><p>Traditionally, state machines are mainly used in the design phase of the software life-cycle; they are intended to guide and constrain the implementation and the test phase, and may later be reused for documentation purposes. In most cases, however, the assertion that a state machine safely abstracts the existing implementation is kept implicit and informal.</p><p>With the rise of Internet-based technologies, the significance of state machines has only increased. In particular, security protocols and communication protocols are naturally specified in terms of state machines. Similar applications of state machines can be found in other safety-critical domains including medicine and aerospace.</p><p>Moreover, the dramatic change of focus from relatively monolithic systems to highly distributed and heterogeneous systems whose development cycles are interdependent, calls for new specification methodologies; for example, in August 2002, IBM, Microsoft, and BEA announced the publication of three specifications (WS-Coordination, WS-Specification, BPEL4WS <ref type="bibr" target="#b2">[3]</ref>) which "collectively describe how to reliably define, create and connect multiple business processes in a Web services environment". We foresee state machines being used for contracts describing software capabilities. In both cases -protocol specification and distributed computation -we observe that state machines are no longer just tools for internal use, but are increasingly introduced into the public domain.</p><p>In this paper, we describe our tool MAGIC (Modular Analysis of proGrams In C) which is capable of verifying whether a state machine (or, more precisely, a labeled transition system) is a safe abstraction of a C procedure; the C procedure in turn may invoke other procedures which are themselves specified in terms of state machines.</p><p>Our approach has a number of tangible benefits:</p><p>• Utility. The capability of MAGIC to verify formally the correctness of state-machine specifications closes an evident gap in many software development methodologies, most notably, but not only, for security-related system features. In the future we envision that tools based on ideas from MAGIC will assist the contracting process with third party software providers.</p><p>• Compositionality. MAGIC verification can be used early on during the development cycle, as specifica-tions can be plugged in for missing system components. Compositionality evidently fosters concurrent development by independent groups of developers.</p><p>• Complexity. State-space explosion <ref type="bibr" target="#b17">[18]</ref> remains the bottleneck of most automated verification tools. Due to compositionality, the size of the individual system parts to be verified by MAGIC remains manageable, as demonstrated by our experiments. Moreover, the verification process in MAGIC is reduced to computing a simulation relation between finite state systems, for which we can provide highly efficient algorithms.</p><p>• Flexibility. Internally, MAGIC uses several theorem provers and SAT solvers. The open design of MAGIC facilitates the easy integration of new and improved tools from this quickly developing area.</p><p>Consequently, we believe that MAGIC like tools have the potential to become indispensable in the software engineering process. In the rest of this section we describe the technical contributions of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Labeled Transition Systems as Specification Mechanism.</head><p>In the literature, several variants of state machines have been investigated; purely state-based formalisms such as Kripke structures <ref type="bibr" target="#b17">[18]</ref> are often used to model and specify systems. For the MAGIC framework, however, we employ labeled transition systems (LTS), which are similar to Kripke structures but for the fact that state transitions are labeled by actions.</p><p>From a theoretical point of view the presence of actions does not increase the expressive power of LTS. In our experience, however, it is more natural for designers and software engineers to express the desired behavior of systems using a combination of states and actions. For example, the fact that a lock has been acquired or released can be expressed naturally by lock and unlock actions. In the absence of actions, the natural alternative is to introduce a new variable indicating the status of the lock, and update it accordingly. The LTS approach certainly is more intuitive, and allows both for a simpler theory and for an easier specification process. A simple example of an LTS is shown in the left part of Figure <ref type="figure" target="#fig_0">1</ref>. A formal definition will be given in Section 2.</p><p>In the MAGIC framework, we use actions to denote externally visible behaviors of the system being analyzed, e.g. acquiring a lock. Actions are atomic, and are distinguished simply by their names. Often, the presence of an action indicates a certain behavior which is achieved by a subprocedure in the implementation. Since we shall analyze a procedural language, namely C, we will model the termination of a procedure (i.e., a return from the procedure) by a special class of actions called return actions. Every return action a is associated with a unique return value RetV al(a). Return values are either integers or void. All actions which are not return actions are called basic actions.</p><p>The use of LTSs is also motivated by work in concurrency. Process algebras like CCS <ref type="bibr" target="#b32">[33]</ref>, CSP <ref type="bibr" target="#b27">[28]</ref> and the π-calculus <ref type="bibr" target="#b33">[34]</ref> have been used widely to reason formally about message passing concurrent systems. In these formalisms, actions are crucial for modeling the sending and receiving of messages across channels. Process algebras lead very naturally to LTSs. Thus, even though we currently only analyze sequential programs, we believe that the use of LTSs will facilitate a smooth transition to concurrent message-passing programs in the future.</p><p>Procedure Abstractions. The goal of MAGIC is to verify whether the implementation of a system is safely abstracted by its specification. To this end, MAGIC verifies individual procedures against the respective LTS. In our implementation, it is possible to handle a group of procedures with a tree-like call graph as a single one by inlining; for simplicity, we speak only of single procedures in this paper. Figure <ref type="figure" target="#fig_0">1</ref> describes a simple case of a procedure proc and a corresponding LTS. We will use proc as a running example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Spec State Machine</head><p>Code to be analysed In practice, it often happens that single procedures perform quite different tasks for certain settings of their parameters. In our approach, this phenomenon is accounted for by allowing multiple LTSs to represent a single procedure. The selection among these LTSs is achieved by guards, i.e., formulas, which describe the conditions on the procedure parameters under which a certain LTS is applicable.</p><formula xml:id="formula_0">return 0; else return 1; } if(do_lock()) { int proc() MSpec STOP return{1} lock return{0}</formula><p>This gives rise to the notion of procedure abstraction (PA); formally a PA for a procedure proc is a tuple d, l where • d is the declaration for proc, as it appears in a C header file.</p><p>• l is a finite list g 1 , M 1 , . . . , g n , M n where each g i is a guard formula ranging over the parameters of proc, and each M i is an LTS with a single initial state.</p><p>The procedure abstraction expresses that proc conforms to one LTS chosen among the L i 's. More precisely, proc conforms to L i if the corresponding guard g i evaluates to true over the actual arguments passed to proc. We require that the guard formulas g i be mutually exclusive so that the choice of L i is unambiguous. The goal of MAGIC then is to prove that a user-defined PA for proc is valid. The role of PAs in this process is twofold:</p><p>1. A target PA is used to describe the desired behavior of the procedure proc.</p><p>2. To assist the verification process, we employ valid PAs (called the assumption PAs) for library routines used by proc.</p><p>Thus, PAs can be seen both as conclusions and as assumptions of the verification process. Consequently, our methodology yields a scalable and compositional approach for verifying large software systems. Figure <ref type="figure" target="#fig_1">2</ref> illustrates this by depicting the call graph of an implementation and the verification steps; note that due to compositionality no particular order of these steps is required.</p><p>Without loss of generality we will assume throughout this paper that the target PA contains only one guard G Spec and one LTS M Spec . To achieve the result in full generality, the described algorithm can be iterated for each guard of M Spec . Algorithms and Tool Description. The MAGIC tool follows the well-known abstract -verify -refine paradigm <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b26">27</ref>]:</p><p>• Step 1 : Model Creation. Extract an LTS M Imp from proc using the assumed PAs and the guard G Spec .</p><p>In MAGIC, the model is computed from the control flow graph (CFG) of the program in combination with an abstraction method called predicate abstraction <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b36">37]</ref>. To decide properties such as equivalence of predicates, we use theorem provers. The details of this step are described in Section 3.</p><p>• Step 2 : Verification. Check whether M Spec safely abstracts M Imp . If this is the case, the verification successfully terminates; otherwise, extract diagnostic feedback and perform step 3.</p><p>In MAGIC, the verification step amounts to checking whether a simulation relation holds between M Spec and M Imp , cf. Section 2. We reduce simulation to the satisfiability of a certain Boolean formula, thus deferring the solution to highly efficient SAT procedures. The details of this step are described in Section 2.</p><p>• Step 3 : Refinement. Use the diagnostic feedback to determine the reason behind the failure of the safe abstraction property. If the cause is a bug in proc we are done. Otherwise the property fails because M Imp is not a sufficiently precise model for proc. In this case return to step 1 to compute an improved M Imp .</p><p>At its current stage of development, MAGIC performs the first two of these steps automatically, while the third step is manually guided. The input to MAGIC consists of (i) a set of preprocessed ANSI-C files representing proc and (ii) a set of specification files containing textual descriptions of M Spec , G Spec and predicates for predicate abstraction. The textual descriptions of LTSs are given using an extended version of the FSP notation by Magee and Kramer <ref type="bibr" target="#b29">[30]</ref>. For example, the LTS shown in Figure <ref type="figure" target="#fig_0">1</ref> is described textually as follows:</p><formula xml:id="formula_1">MyLock = ( lock -&gt; return {$0 == 0} -&gt; STOP | return {$0 == 1} -&gt; STOP ).</formula><p>The schematic in Figure <ref type="figure" target="#fig_2">3</ref> explains the software architecture of MAGIC. Model Creation is handled by Stage I and II of the program. In Stage I the input files are parsed and the control flow graph (CFG) of the C program is constructed. Simplifications are made so that the resulting CFG only has simple statements and side-effect free expressions. Then relevant predicates at each control location are computed and the CFG is annotated with them. In Stage II, M Imp is extracted from the annotated CFG using the assumed PAs, G Spec and the predicates. As described later, this process requires the use of theorem provers. MAGIC can interact with several public domain theorem provers viz. Simplify <ref type="bibr" target="#b35">[36]</ref>, CVC <ref type="bibr" target="#b38">[39]</ref>, ICS <ref type="bibr" target="#b22">[23]</ref> and CPROVER <ref type="bibr" target="#b28">[29]</ref>.</p><p>Verification is performed in Stage III. As mentioned above, simulation here is reduced to Boolean satisfiability. MAGIC can interface with several publicly available SAT solvers viz. Chaff <ref type="bibr" target="#b34">[35]</ref>, FGRASP <ref type="bibr" target="#b30">[31]</ref> and SATO <ref type="bibr" target="#b39">[40]</ref>. We also have our own efficient SAT solver implementation which leverages the specific nature of SAT formulas that arise in this stage to deliver better performance than the public domain solvers. MAGIC does not generate diagnostic feedback yet, nor does it support automatic model refinement. We consider this a significant area for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work.</head><p>During the last years advances in verification methodology as well as in computing power have promoted renewed interest in software verification. The resulting systems -most notably Bandera <ref type="bibr" target="#b0">[1]</ref> and Java PathFinder <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b25">26]</ref>, ESC Java <ref type="bibr" target="#b3">[4]</ref>, SLAM <ref type="bibr" target="#b6">[7]</ref>, BLAST <ref type="bibr" target="#b1">[2]</ref> and MC <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b23">24]</ref> -are increasingly able to handle industrial software. Among the six mentioned systems, the former three focus on Java, while the latter three all deal with C. Java verification is quite different from C, because object orientation, garbage collection and the logical memory model require specific analysis methods. Among the C verification tools, MC (which stands for meta-compilation) has a distinguished place because it amounts to a form of pattern matching on the source code, with surprisingly good results for scanning relatively simple errors in large amounts of code. SLAM and BLAST are closely related tools, whose technical flavor is most akin to ours. SLAM is primarily optimized to analyse device drivers, and is going to be included in the Windows development cycle. In contrast to SLAM which uses symbolic algorithms, BLAST is an onthe-fly reachability analysis tool. MAGIC is the only tool which uses LTS as specification formalism, and simulation as the notion of conformance. This choice reflects the area of security currently being our primary application domain.</p><p>Except for MC, the mentioned tools are based on variations of model checking <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b17">18]</ref>, and they all require abstraction methods to alleviate the state explosion problem, most notably data abstraction <ref type="bibr" target="#b16">[17]</ref> and the more general predicate abstraction <ref type="bibr" target="#b36">[37]</ref>. The abstraction method used in SLAM and BLAST is closest to ours. However, due to compositionality, we can afford to invest more computing power into computing abstractions, and are therefore able to improve on Cartesian abstraction <ref type="bibr" target="#b11">[12]</ref>. Generally, we believe that the form of compositionality provided by MAGIC is unique among existing software verification systems.</p><p>Virtually all systems using abstraction interface with theorem provers for various purposes. The software architecture of MAGIC is designed as to facilitate the integration of various theorem provers. In addition, MAGIC is the only tool in this area which attempts to transfer the enormous success of SAT procedures in hardware verification <ref type="bibr" target="#b13">[14]</ref> to software.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Transition Systems and Simulation</head><p>A labeled transition system (LTS) M is a 4-tuple (S, S 0 , Act, T ), where (i) S is a finite non-empty set of states, (ii) S 0 ⊆ S is the set of initial states, (iii) Act is the set of actions, and (iv) T ⊆ S × Act × S is the transition relation.</p><p>We assume that there is a distinguished state STOP ∈ S which has no outgoing transitions, i.e., ∀s ∈ S, ∀a ∈ A, (STOP , a, s ) ∈ T . In addition we assume the presence of a distinguished action in the set Act, which we denote by . If (s, a, s ) ∈ T , then (s, s ) will be referred to as a a-transition and will be denoted by s a → s . If s is reachable from s via zero or more -transitions, we will denote this by s → s . The relation ⇒ is defined as follows:</p><formula xml:id="formula_2">s a ⇒ s iff there exist s 1 and s 2 such that s → s 1 a → s 2 → s .</formula><p>Conformance via Simulation. In the context of LTS, simulation <ref type="bibr" target="#b32">[33]</ref> is the natural notion of conformance between a specification LTS and an implementation LTS. We will therefore use simulation as our notion of conformance between the specification LTS and the program. Compared to conformance notions based on trace containment <ref type="bibr" target="#b12">[13]</ref>, simulation has the additional advantage that it is computationally less expensive to check. Among the many technical variants of simulation <ref type="bibr" target="#b32">[33]</ref>, we choose weak simulation because it allows for a limited form of asynchrony between the LTSs, i.e., one step of the specification LTS may simulate multiple steps of the implementation. This feature of weak simulation is crucial to our approach, because one step in M Spec typically corresponds to multiple steps in M Imp .</p><p>Weak Simulation. Let M = (S, S 0 , Act, T ) and M = (S , S 0 , Act, T ) be two LTSs. A relation E ⊆ S × S is called a weak simulation between M and M iff (i) for all s ∈ S 0 there exists s ∈ S 0 such that (s, s ) ∈ E, and (ii) (s, s ) ∈ E implies that for all actions a ∈ Act \ { } if s a ⇒ s 1 , then there exists s 1 ∈ S such that s a ⇒ s 1 and (s 1 , s 1 ) ∈ E. We say that LTS M weakly simulates M (denoted by M M ) if there exists a weak simulation relation E ⊆ S × S between M and M . In the rest of the paper, we use the convention that the terms simulation and simulates will always mean weak simulation and weakly simulates respectively.</p><p>Algorithm for Computing Weak Simulation. The existence of a simulation relation between M and M can be checked efficiently by reducing the problem to an instance of Boolean satisfiability <ref type="bibr" target="#b37">[38]</ref>. Interestingly the SAT instances produced by this method always belong to a restricted class of SAT formulas known as the weakly negated HORN formulas. In contrast to general SAT (which has no known polynomial time algorithm), satisfiability of weakly negated HORN formulas can be solved in linear time <ref type="bibr" target="#b19">[20]</ref>. As part of MAGIC, we have implemented an online linear time HORNSAT algorithm based on <ref type="bibr" target="#b9">[10]</ref>. MAGIC can also interface with public domain general SAT solvers like Chaff <ref type="bibr" target="#b34">[35]</ref>, FGRASP <ref type="bibr" target="#b30">[31]</ref> and SATO <ref type="bibr" target="#b39">[40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Model Creation</head><p>Let M Spec = (S Spec , S 0,Spec , Act Spec , T Spec ) and the assumption PAs be {PA 1 , . . . , PA k }. In this section we show how to extract M Imp from proc using the assumption PAs, the guard G Spec and the predicates. The extraction of M Imp relies on several principles:</p><p>• Every state of M Imp models a state during the execution of proc; consequently every state is composed of a control component and a data component.</p><p>• The control components intuitively represent values of the program counter, and are formally obtained from the CFG of proc.</p><p>• The data components are abstract representations of the memory state of proc. These abstract representations are obtained using predicate abstraction.</p><p>• The transitions between states in M Imp are derived from the transitions in the control flow graph, taking into account the assumption PAs and the predicate abstraction. This process involves reasoning about C expressions, and will therefore require the use of a theorem prover.</p><p>In the rest of this section, we will describe these steps in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Control Flow Graph.</head><p>The CFG of proc is a finite graph describing the flow of control in proc. The nodes of the CFG are called control locations, and intuitively correspond to the values of the program counter; the edges denote transfer of control. Ordinary C code however contains nested procedure calls, expressions with side-effects and other similar constructs that make it difficult to construct precise CFGs. In order to alleviate this problem, our tool first performs a set of natural simplifications on proc before constructing its CFG. The simplified procedure body contain only normal assignments (e.g. x = y + 5; or *x = *y + 10;), call assignments (e.g. x = foo(y + 5);), branches (e.g. if (x) { ... } else { ... }), gotos and returns (e.g. return (*y + 5); ). The left hand side of assignments must always be either a variable or a single address dereference (such as *v = 5;). Note that in the resulting program loop statements such as while and for are substituted by appropriate if and goto statements. Moreover, we can assume that each variable has a unique scope, and each procedure always terminates with explicit return statements. These preprocessing steps are not very complicated, and are omitted here. The CFG for our example proc is shown in Figure <ref type="figure" target="#fig_3">4</ref>. Control Locations. After this simplification, the definition of control locations becomes straightforward: Each normal assignment, call assignment, goto and return statement gives rise to a control location with a unique successor.</p><formula xml:id="formula_3">C B D return 0 FINAL E true false if(t != 0) return 1 Expanded CFG B D D E C C (t == 0) (t == 0) (t == 0) (t == 0) (t != 0) (t != 0) (t != 0) return{0} return{1} return{0} return{1} (t != 0) ε ε B E A t = do_lock() A (t == 0) (t != 0) A CFG</formula><p>In contrast, a branch yields a control location with exactly two successors. We assume that for each control location in the CFG, the associated conditions and statements are available. In addition, we introduce a unique final control location and make it the unique successor of all return control locations. Depending on the statement to which the control location is referring we speak of normal assignment locations, branch locations etc. Formally, C denotes the set of control locations of proc.</p><p>Expanding the Control Flow Graph. The CFG is the simplest reasonable finite model of proc. However, for verification purposes the CFG is too imprecise because it models only control flow, but ignores data (memory). On the other hand, it is computationally unfeasible to model the memory explicitly.</p><p>We will now show how to incorporate abstract memory state information into the CFG. To this end, we will consider a set of properties at each control location. These properties are described by C expressions similar to those used as branching conditions. Thus, if we have k data properties, each of which can be true or false, then each control location corresponds to 2 k possible states in our model, each of them corresponding to a particular valuation of the properties considered. Intuitively, the construction of the LTS M Imp proceeds stepwise:</p><p>1. Construct the CFG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Construct an expanded CFG M Exp</head><p>= (S Exp , S 0,Exp , Act Spec , T Exp ) as follows:</p><p>• For each control location c, we include 2 k states in S Exp ; each state thus is a combination of a control location and a valuation of the considered properties.</p><p>• Consider an edge (c 1 , c 2 ) in the CFG. Then c 1 and c 2 correspond to 2 k states in S Exp each. Consequently, (c 1 , c 2 ) may be correspond to up to 2 k × 2 k transitions in T Exp . However, not all of them will be included because not all transitions are consistent with the abstract memory state information. We will use a theorem prover to determine which of these transitions indeed are admissible. We will only rule out transitions whose admissibility can be disproved by the theorem prover.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">M</head><p>Exp is a more precise model of proc than the CFG. However it does not model the behavior of the library routines called by proc. To achieve this we incorporate the assumption PAs into M Exp . This step also requires the use of a theorem prover. The LTS obtained after incorporating the assumption PAs is M Imp .</p><p>In the following two sections, we will describe step 2 of this process in detail; in Section 3.4, we will explain step 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Predicate Abstraction</head><p>Predicate abstraction is an approach to model abstractly the state of a system by a set of logical predicates <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b36">37]</ref>. We use predicate abstraction techniques only to model the memory state. As we aim to verify C programs, it is natural to express these properties by pure (side-effect free) Boolean C expressions. Since we assumed the scope of each variable to be unique, this definition is unambiguous.</p><p>Thus, we shall use C expressions very much in the same way as quantifier-free first order formulas. Because of this conceptual proximity we will use logical connectives such as ∧, ∨ and ¬ instead of their C equivalents &amp;&amp;, || and !.</p><p>In order to describe abstract memory states, let us fix a certain set P = {P 1 , . . . P k } of expressions which we call the predicates. Note that we do not use float and string constants in predicates at the current stage of the implementation. Given a concrete memory state m and a predicate P , we say that m satisfies P iff P evaluates to true (i.e., a nonzero numerical value) during the execution of proc when the memory state is m. A valuation for P is a vector v 1 , . . . v k of Boolean values, such that v i expresses the Boolean value of P i . V denotes the set of all valuations, i.e., the set of abstract memory states. Intuitively, a concrete memory state m is modeled by v</p><formula xml:id="formula_4">1 , . . . v k if for 1 ≤ i ≤ k, m satisfies P i iff v i is true.</formula><p>A valuation v typically models many concrete memory states. This set is characterized by a formula (called the concretization of v) which expresses truth or falsity of the involved properties in the natural way: Given a valuation v = v 1 , . . . v k , the concretization γ(v) is defined as k i=1 P vi i where P vi i is equal to P i if v i is true, and equal to ¬P i if v i is false. Thus, γ(v) describes the property captured by the valuation v; all memory states which are modeled by v satisfy γ(v).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 1 In our example, P contains a single predicate (t == 0) and therefore has two valuations -[true] and [false]. Hence γ([true]) := (t == 0) and γ([f alse]) := ¬(t == 0). Thus [true] models all concrete memory states</head><p>where the variable t is equal to 0 and false models all concrete memory states where the variable t is not equal to 0.</p><p>State Space of M Exp . We combine the control flow graph and the predicate abstraction to obtain the state space S Exp := C × V of M Exp . Thus a state of M Exp is a pair c, v where c ∈ C and v ∈ V. It models all execution states of proc where the control location is c and where the memory state is modeled by v. In Section 3.3 we show how to compute the transitions between states in S Exp ; in Section 3.4 we show how to extend M Exp to incorporate the specification PAs. Before we can do this, we need to give some details about our use of theorem provers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Application of Theorem Provers</head><p>We will use theorem provers to reason about C expressions. Since these expressions may involve integer as well as Boolean arithmetic, and, importantly, pointer arithmetic, the logic involved is quite complicated, and certainly undecidable. <ref type="foot" target="#foot_0">1</ref> It is therefore important to our approach that we use the theorem prover conservatively, i.e., we only assume logical relationships which the theorem prover actually can prove.</p><p>In this section, we will describe the principles of our usage of theorem provers so as to give an intuition of our approach. The logical intricacies involved (including, for example, uninterpreted function symbols to model the heap) are handled by our tool, but would exceed the scope of this paper, and are therefore omitted.</p><p>For the construction of the abstract transition relation it will often be necessary to determine whether two C expressions e 1 and e 2 are mutually exclusive. To this end, we use the theorem prover to compute a meta-predicate A(e 1 , e 2 ) with the following properties:</p><p>• If A(e 1 , e 2 ) is false, then e 1 and e 2 are provably mutually exclusive.</p><p>• If A(e 1 , e 2 ) is true, then this indicates that the theorem prover could not prove that e 1 and e 2 are mutually exclusive, either because they indeed are not mutually exclusive, or because proving mutual exclusiveness was beyond the capabilities of the theorem prover.</p><p>The meta-predicate A has a crucial role in the definition of the transition relation. We will see that the definition of A ensures that the abstraction is safe. We illustrate the use of A by the following important example:</p><p>Given any C expression e 1 and a normal C assignment s, we define the weakest precondition of e 1 with respect to s in the same way as <ref type="bibr" target="#b10">[11]</ref> and denote it by WP(s, e 1 ). Intuitively, WP(s, e 1 ) is a C expression which denotes the weakest assumption that has to be true before the execution of s in order for e 1 to become true after the execution of s. Given s and e 1 , WP(s, e 1 ) can be computed as follows:</p><formula xml:id="formula_5">• If s is the assignment statement v = e 2 then WP(s, e 1 )</formula><p>is obtained from e 1 by replacing all occurrences of v in e 1 with e 2 .</p><p>• If s is an assignment statement of the form * v = e 2 , then we have to take into account aliasing possibilities as well. For example if e 1 is the expression a == 5 then WP(s, e 1 ) is</p><formula xml:id="formula_6">((v == &amp;a) ∧ (e 2 == 5)) ∨ ((v! = &amp;a) ∧ (a == 5)).</formula><p>Let Asgn be the set of normal C assignments in P . The relation Update ⊆ V × Asgn × V denotes how normal assignments affect the valuations, and is defined as follows.</p><formula xml:id="formula_7">Update = {(v 1 , s, v 2 ) | A(γ(v 1 ), WP(s, γ(v 2 )), v 1 , v 2 ∈ V, s ∈ Asgn} Intuitively Update(v 1 , s, v 2 )</formula><p>means that if proc is in a memory state modeled by v 1 , and the assignment statement s is executed, then we need to admit the possibility that a memory state abstracted by v 2 can be reached.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Transition Relation T Exp</head><p>We are now ready to define the transition relation</p><formula xml:id="formula_8">T Exp ⊆ S Exp × Act Spec × S Exp for M Exp .</formula><p>Consider any two states s and s of M Exp . We have already seen that state s = (c, v) models all concrete states of proc whose control component is c and whose data component is modeled by v. Let t and t denote two concrete states modeled by s and s respectively. If there is a concrete transition for any such t and t then we must include a transition (s, s ) in T Exp . This approach guarantees that M Exp is a sound model of proc.</p><p>The rest of this section describes a procedure to decide whether to include such a transition (s, s ) in T Exp or not. We will make a case distinction by the type of c. If c is a final location, then there are no outgoing transitions from s. Otherwise c can be of five different types and we consider each type separately.</p><p>Goto. Let c be the unique successor control location of c. Then we include ((c, v), , (c , v)) in T Exp . Thus we change the control state according to the program flow and keep the data state unaltered.</p><p>Normal Assignment. Let z be the assignment statement at c and c be the unique successor control location of c. For every valuation v such that Update(v, z, v ), we in- <ref type="figure">clude ((c,</ref><ref type="figure">v),</ref><ref type="figure">,</ref><ref type="figure">(c ,</ref><ref type="figure">v</ref> )) in T Exp . Thus we let the control state change according to the control flow of the program and allow any data state change not disproved by the theorem prover.</p><p>Branch. Recall that in the CFG, every branch has two successors. Let e be the branching condition, and let c T and c E be the true and false successors of c. If A(γ(v), e), then we include ((c, v), , (c T , v)) in T Exp . If A(γ(v), ¬e), then we include ((c, v), , (c E , v)) in T Exp . Thus we allow for any successor control state that is not provably impossible and we keep the data state unchanged.</p><p>Return. Let e be the return expression at the return location c in root and c be the unique successor location of c. Note that c must be the final location. For all return actions a ∈ Act Spec , if A(γ(v), (e == RetV al(a))) (i.e., if the return value described by the action is possibly equal to the value actually returned) then we include ((c, v), a, (c , v)) in T Exp . If there is no return action a ∈ Act Spec , then we include ((c, v), , (c , v)) in T Exp .</p><p>Call Assignment. Since we do not incorporate the specification PAs at this stage, we do not include any transitions originating at call assignment locations. These transitions will be explained in Section 3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initial States.</head><p>The initial states are those states which are consistent with the guard G Spec . Thus, S 0,ECFG is the set of states (c, v) where A(γ(v), G Spec ) and c is the initial location of CFG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2</head><p>The expanded CFG for our example is shown in Figure <ref type="figure" target="#fig_3">4</ref>. Since there are two valuations, there are two states corresponding to every control location in the actual CFG. The corresponding control locations and states in the M Exp have the same color and are marked with the same letter. In addition every state corresponding to valuation v is marked with γ(v) (¬(t == 0) is written (t! = 0).)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Inlining the Specification PAs</head><p>In this section, we show how to conclude the construction of M Imp by incorporating the assumption PAs into M Exp . Recall that the purpose of this step is to model calls made by proc to library routines. Intuitively, this is achieved by inline copies of appropriate LTSs between call assignment locations and their respective successors in the CFG.</p><p>M Imp is obtained from M Exp by adding new states and transitions: Consider a state (c, v) where c is a call assignment, and let c be the unique successor of c in the CFG. Let x = lib(. . .); be the call assignment statement at c. Assume that proc is not a function pointer; we will deal with this special case later. Let g 1 , P 1 , . . . , g n , P n be the guard and LTS list in the assumption PA for lib. For each i, we do the following:</p><p>1. Let g i be the guard obtained from g i by replacing every parameter of lib by the corresponding argument passed to it at c. If A(g i , γ(v)), then proceed, otherwise move on to the next guard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Let P i = (S i , Act i , {s 0,i }, T i ). For each state s ∈ S i which is not STOP, introduce a new state (c • s, v) into S Imp . These states represent the inlined states of P i .</p><p>3. Add a transition ((c, v), , (c • s 0,i , v)) into T Imp . This transition connects the call location state to the initial inlined state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>For each transition (s, a, t) ∈ T i where t is different from STOP, add a transition ((c • s, v), a, (c • t, v)) into T Imp .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>For each transition (s, a, STOP) ∈ T i where a is not a return action, and for each v such that A(γ(v), γ(v )) is true, add ((c • s, v), a, (c , v )) into T Imp .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.</head><p>For each transition (s, a, STOP) ∈ T i where a is a return action, and for each v such thatUpdate(v,</p><formula xml:id="formula_9">x = RetV al(a), v ) is true, add ((c • s, v), , (c , v )) into T Imp .</formula><p>If lib is a function pointer, then we repeat the construction described above for each possible target of lib listed by the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3</head><p>The assumption LTS for do lock is shown at the top of Figure <ref type="figure" target="#fig_4">5</ref>. The M Imp obtained by incorporating the LTS for do lock into M Exp of Figure <ref type="figure" target="#fig_3">4</ref> is shown at the bottom. The corresponding states in M Exp and M Imp are colored identically. Similarly the states of the LTS for do lock and the corresponding inlined states in M Imp have identical colors. It is clear that M Imp is simulated by the M Spec in Figure <ref type="figure" target="#fig_0">1</ref>. </p><formula xml:id="formula_10">B D D E C C (t == 0) (t == 0) (t == 0) (t == 0) (t != 0) (t != 0) (t != 0) return{0} return{1} return{0} return{1} (t != 0) ε ε B E A (t == 0) (t == 0) (t == 0) A (t != 0) (t != 0) (t != 0) ε ε ε ε ε ε lock lock S1 S2 lock</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Enhancements and Implementation Issues</head><p>We now describe several enhancements to the above described basic framework that we have implemented in MAGIC, but have been omitted to keep the presentation simple.</p><p>Making predicate abstraction more efficient. The set of valuations V is exponential in the number of predicates in P. MAGIC also uses the theorem prover to group together predicates that are mutually exclusive. Since at most one predicate in such a group can be true at any time the number of possible valuations of that group is equal to the size of the group. This reduces the size of the state space dramatically. For example suppose we had four predicates originally and we formed two groups of two predicates each. Then the number of possible valuations reduces from sixteen to four.</p><p>Even though we have assumed a fixed set of predicates P in the above discussion, MAGIC allows different sets of predicates. Since not all predicates are useful to be abstracted at all control locations, using them indiscriminately would be inefficient. A similar method has been used by BLAST <ref type="bibr" target="#b26">[27]</ref>.</p><p>Automatic predicate discovery. The effectiveness of predicate abstraction relies critically on the set of predicates. The model extraction process described above requires that the predicates be supplied externally. However, if directed, MAGIC can also try to discover suitable sets of predicates. We do not discuss the full details of this predicate discovery process in this paper. However in almost all of our experiments MAGIC manages to automatically discover good predicate sets and correctly prove/disprove the simulation property with them.</p><p>Interfacing with theorem provers. As explained before, during the construction of M Imp we use efficient theorem provers. We have integrated MAGIC with various publicly available theorem provers. In some cases, like Simplify <ref type="bibr" target="#b35">[36]</ref>, CVC <ref type="bibr" target="#b38">[39]</ref> and ICS <ref type="bibr" target="#b22">[23]</ref>, the version of the software available to us can only be used via command line arguments. We run them as separate processes and interface with them via their standard inputs and outputs. In other cases, like CPROVER <ref type="bibr" target="#b28">[29]</ref>, the software is available as libraries with well-defined APIs and we link them directly with MAGIC. Also in all the cases we cache results to avoid redundant calls to the theorem prover.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Case Studies</head><p>Our experiments were guided by three general goals: First, we wanted to assure the correctness of the tool by experimenting with examples where the correct outcome was already known. Second, we wanted to evaluate the relative performances of various publicly available software (theorem provers, SAT solvers) that were integrated into our sys-tem. Third, we wished to validate the usefulness of our tool in handling large real life examples. Regression Tests. The first two goals were achieved by a suite of 10 regression tests of small size. All these tests were derived from actual Linux kernel code. Figure <ref type="figure" target="#fig_5">6</ref> describes the source of each test briefly. LOC indicates the number of post-processed lines of C. The name of the procedure analysed is given in italics in the description. A modified procedure means that the source code was changed so that it would no longer be safely abstracted by the specification LTS. The library to which the procedure belongs is given in brackets after the procedure name.  Verifying OpenSSL. To achieve the third goal we opted to work with OpenSSL <ref type="bibr" target="#b5">[6]</ref>, an open source implementation of the publicly available SSL <ref type="bibr" target="#b7">[8]</ref> specification. This protocol is used by a client (typically a web browser) and a server to establish a secure socket connection over a malicious network using public and symmetric key cryptography. A critical component of the protocol is the handshake. First we verified that the openssl-0.9.6c implementation of the server side of the handshake conforms to its specification. This implementation is encapsulated in a single procedure of about 347 lines of C. We constructed the target LTS M Spec manually by reading the SSL specification <ref type="bibr" target="#b7">[8]</ref>. The LTS had 28 states and 67 transitions. A total of 19 predicates and PAs for 14 library routines were supplied externally. We carried out two experiments. The first was done with the correct target LTS. The second was done with a modified the target LTS (of same size) so that a correct implementation would no longer be simulated by it. Next we repeated identical experiments with the client side implementation. It was encapsulated within a single procedure of 345 lines. The target LTS had 28 states and 60 transitions. A total of 18 predicates and PAs for 12 library routines were supplied externally. Regression Test Results. All our experiments were done on a 1.4 GHz AMD Athlon machine with 1 GB of RAM running RedHat Linux 7.1. Figure <ref type="figure" target="#fig_6">7</ref> summarizes the performance results for various theorem provers obtained via the regression suite. The y-axis (drawn in log scale) shows the time needed to construct M Imp in milliseconds which is a clear indicator of the performance of the theorem prover. Similarly, Figure <ref type="figure" target="#fig_7">8</ref> summarizes the performance results for various SAT solvers obtained via the regression suite. The y-axis indicates the time in milliseconds needed to check simulation since this is the step where the SAT solver is used.</p><p>OpenSSL Results. In the case of the OpenSSL server experiments, the fact that the correct specification LTS safely abstracts the OpenSSL implementation was then proved by our tool in 255 seconds using about 130 MB of memory. The tool also successfully verified that the modified specification LTS does not safely abstract the implementation in 247 seconds using 115 MB of memory. For the client experiments the corresponding figures were 226 seconds, 107MB and 227 seconds, 111MB. Owing to compositionality we did not have to verify the validity of the assumption PAs used for these experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comparison of Theorem Provers and SAT Tools.</head><p>A closer look at the two bar graphs reveal several consistent trends. First, for the purposes of our tool, the theorem provers can be arranged in decreasing order of efficiency as follows: Simplify, ICS, CVC and CPROVER. The first three theorem provers have comparable efficiency and seem clearly superior to CPROVER. Second, the SAT solvers can also be arranged in decreasing order of efficiency as follows: Horn, Chaff, FGRASP and SATO. Of the external solvers we used Chaff seems to be easily the best, almost matching our own HORNSAT based implementation. FGRASP and SATO are less easily distinguishable. The difference in performance between general SAT solvers and the HORNSAT solver we implemented becomes prominent for the larger OpenSSL example. The time required for checking simulation for the first OpenSSL server experiment and the first OpenSSL client experiment were 42 seconds and 32 seconds respectively when using our HORNSAT solver. In comparison the same figures for Chaff were 386 seconds and 265 seconds respectively.</p><p>Negative Results. The reported figures were obtained using user supplied predicates. When we repeated the experiments using automatically discovered predicates, higher execution times were observed. The reason is that our automatic predicate discovery process yields more predicates than are necessary. This leads to a larger number of states in M Imp and hence to greater execution times. We believe that improving the predicate discovery technique is a good area for further research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Future Work</head><p>There is enormous potential for extending the basic framework implemented by MAGIC. In conclusion we list notable areas for future research: (i) generation of diagnostic feedback and automatic model refinement, (ii) abstraction techniques for more precise modeling of the heap, (iii) extending the MAGIC infrastructure to OO languages like Java and C++, (iv) handling concurrency, and (v) automatic predicate discovery.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The example M Spec and proc.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Compositional verification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Overall architecture of MAGIC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. CFG and expanded CFG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. LTS for do lock and M Imp .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Descriptions of regression tests.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Time to construct M Imp .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Time to check simulation.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>It follows from the famous negative solution to Hilbert's tenth problem<ref type="bibr" target="#b31">[32]</ref> that checking the equivalence of two C expressions is undecidable even for simple integer arithmetic; even when we restrict the range of the variables to 32 bit, the question is computationally very hard.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This research was supported by the NRL-ONR under Grant No. N00014-01-1-0796, by the NSF under Grant No. CCR-9803774, CCR-0121547 and CCR-0098072, by the Army-ARO under Grant No. DAAD 19-01-1-0485, the Austrian Science Fund Project NZ29-INF, the EU Research and Training Network GAMES and graduate student fellowships from Microsoft and NSF. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of NSF or the United States Government.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://www.cis.ksu.edu/santos/bandera" />
		<title level="m">Bandera</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www-cad.eecs.berkeley.edu/rupak/blast" />
		<title level="m">BLAST</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://www.oasis-open.org/cover/bpel4ws.html" />
		<title level="m">Business Process Execution Language for Web Services</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>Esc-Java</surname></persName>
		</author>
		<ptr target="http://www.research.compaq.com/SRC/esc" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Java</forename><surname>Pathfinder</surname></persName>
		</author>
		<ptr target="http://ase.arc.nasa.gov/visser/jpf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="http://www.openssl.org" />
		<title level="m">OpenSSL</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<ptr target="http://research.microsoft.com/slam" />
		<title level="m">SLAM</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<ptr target="http://wp.netscape.com/eng/ssl3" />
		<title level="m">SSL 3.0 Specification</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="http://www.uml.org" />
		<title level="m">Unified Modeling Language</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On-line algorithms for polynomially solvable satisfiability problems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ausiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Italiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1,2,3 &amp; 4</biblScope>
			<biblScope unit="page" from="69" to="90" />
			<date type="published" when="1991-01">January 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic predicate abstraction of c programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">D</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGPLAN Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="203" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Boolean and Cartesian abstraction for model checking C programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2031</biblScope>
			<biblScope unit="page">268</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Automatically validating temporal safety properties of interfaces</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2001">2057. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Symbolic model checking without BDDs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1579</biblScope>
			<biblScope unit="page" from="193" to="207" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Automatic verification of finite-state concurrent systems using temporal logic specifications</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and System (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="244" to="263" />
			<date type="published" when="1986-04">April 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Counterexample-guided abstraction refinement</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="154" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Model checking and abstraction</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and System (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1512" to="1542" />
			<date type="published" when="1994-09">September 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Model Checking</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Experience with predicate abstraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="160" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Linear time algorithms for testing the satisfiability of propositional horn formula</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">F</forename><surname>Dowling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Gallier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="267" to="284" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Tool-supported program abstraction for finite-state verification</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hatcliff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Joehanes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Laubach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software engineering</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="177" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Checking system rules using system-specific, programmer-written compiler extensions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">ICS: Integrated canonizer and solver</title>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Filliatre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ruess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A system and language for building system-specific, static analyses</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGPLAN Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Statecharts: A visual formalism for complex systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="231" to="274" />
			<date type="published" when="1987-06">June 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Model checking JAVA programs using JAVA pathfinder</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pressburger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="366" to="381" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Lazy abstraction</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sutre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="58" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Communicating sequential processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM (CACM)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="666" to="677" />
			<date type="published" when="1978-08">August 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Application specific higher order logic theorem proving</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Verification Workshop -VERIFY&apos;02</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Autexier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Mantel</surname></persName>
		</editor>
		<meeting>of the Verification Workshop -VERIFY&apos;02</meeting>
		<imprint>
			<date type="published" when="2002-07">July 2002</date>
			<biblScope unit="page" from="5" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Concurrency: State Models &amp; Java Programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Magee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">GRASP -a new search algorithm for satisfiability</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Marques-Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM International Conference on Computer-Aided Design</title>
		<imprint>
			<date type="published" when="1996-11">November 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Hilbert&apos;s Tenth Problem</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Matiyasevich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communication and Concurrency</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Communicating and Mobile Systems: the π-Calculus</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Engineering an efficient sat solver</title>
		<author>
			<persName><forename type="first">M</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Madigan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
		<author>
			<persName><surname>Chaff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference</title>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Techniques for Program Verification</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Construction of abstract state graphs with PVS</title>
		<author>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Saidi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1254</biblScope>
			<biblScope unit="page" from="72" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Uniform Approaches to the Verification of Finite State Systems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Shukla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SUNY</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Albany</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">CVC: A cooperating validity checker</title>
		<author>
			<persName><forename type="first">A</forename><surname>Stump</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Computer-Aided Verification</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">SATO: An efficient propositional prover</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Automated Deduction</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
