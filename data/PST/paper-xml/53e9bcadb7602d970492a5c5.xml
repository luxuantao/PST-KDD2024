<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Distributed Credential Chain Discovery in Trust Management (Extended Abstract) *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ninghui</forename><surname>Li</surname></persName>
							<email>ninghui.li@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<addrLine>Gates 4B Stanford University Stanford</addrLine>
									<postCode>94305-9045</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">William</forename><forename type="middle">H</forename><surname>Winsborough</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">NAI Labs Network Associates, Inc</orgName>
								<address>
									<addrLine>3060 Washington Road Glenwood</addrLine>
									<postCode>21738</postCode>
									<settlement>William Winsborough</settlement>
									<region>MD</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
							<email>mitchell@cs.stanford.edu</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<addrLine>Gates 4B Stanford University Stanford</addrLine>
									<postCode>94305-9045</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Distributed Credential Chain Discovery in Trust Management (Extended Abstract) *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CE283C9C9F1B555B47A9110670F3E1E6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We give goal-oriented algorithms for discovering credential chains in RT0, a role-based trust-management language introduced in this paper. The algorithms search credential graphs, a representation of RT0 credentials. We prove that evaluation based on reachability in credential graphs is sound and complete with respect to the set-theoretic semantics of RT0. RT0 is more expressive than SDSI 2.0, so our algorithms can perform chain discovery in SDSI 2.0, for which existing algorithms in the literature either are not goal-oriented or require using specialized logic-programming inferencing engines. Being goal-oriented enables our algorithms to be used when credential storage is distributed. We introduce a type system for credential storage that guarantees well-typed, distributed credential chains can be discovered.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Several trust-management systems have been proposed in recent years, e.g., SPKI/SDSI <ref type="bibr" target="#b10">[10]</ref>, PolicyMaker <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b4">4]</ref>, KeyNote <ref type="bibr" target="#b2">[2]</ref>, Delegation Logic <ref type="bibr" target="#b15">[15]</ref>. These systems are based on the notion of delegation, whereby one entity gives some of its authority to other entities. The process of making access control decisions involves finding a delegation chain from the source of authority to the requester. Thus, a central problem in trust management is to determine whether such a chain exists and, if so, to find it. We call this the credential chain discovery problem, by contrast with the certificate chain discovery problem, which is concerned with X.509 certificates <ref type="bibr" target="#b9">[9]</ref>. Credentials in trust management generally have more complex meanings than simply binding names to public keys, and a credential chain is often a graph, rather than a linear path. The goal of this paper is to address the credential chain discovery problem (the discovery problem for short) in such systems.</p><p>Almost all existing work addressing the discovery problem assumes that potentially relevant credentials are all gathered in one place. This is at odds with the tenet of trust management-decentralized control; systems that use trust management typically issue and often store credentials in a distributed manner. This raises some nontrivial questions.</p><p>Example 1. A fictitious Web publishing service, EPub, offers a discount to preferred customers of its parent organization, EOrg. EOrg issues a credential to the ACM stating that ACM members are preferred customers. Combining it with Alice's ACM membership credential yields a twocredential chain that proves Alice is a preferred customer. This is a linear chain; the subject of the credential issued by EOrg, ACM, is the issuer of the credential issued to Alice.</p><p>These two credentials must be collected to construct the chain. The question we take up is where they should be stored to enable that collection. We say an entity A stores a credential if we can find the credential once we know A. Some other entity, such as a directory, may actually house the credential on A's behalf. Also, by storing a credential, we mean storing and providing access to the credential.</p><p>Given this definition of storing, to be useful, a credential must be stored with its issuer or with its subject. If both credentials in example 1 are stored with their subject, we can find them by obtaining the first credential from Alice, and using the issuer of that credential, ACM, to obtain the second. A disadvantage of this strategy is that it requires the ACM to store all the credentials authorizing ACM members. This makes the ACM a bottleneck. Also, some issuers may not entrust credentials to their subjects. If instead both credentials are stored with their issuers, the ACM has to store and provide all membership ids, again making it a bottle neck, and potentially causing broad search fan-out.</p><p>In the example, the ideal arrangement is to store one credential with EOrg and the other with Alice. The chain can then be discovered by working from these two ends towards the chain's middle. No prior credential discovery system supports this, probably because subject-and issuer-storage cannot be intermixed arbitrarily: in our example, if both credentials are stored exclusively by the ACM, the chain cannot be found. This is because in many decentralized systems, it is impossible or prohibitively expensive for one entity to enumerate all other entities in the systems. For all practical purposes, in such a system, if one can't find a credential chain without contacting every entity, one can't find it at all. In this paper, we introduce a credential typing system that constrains storage enough to ensure chains can be found by starting at their two ends and working inward.</p><p>The credential chain introduced in example 1 illustrates only the simplest case that we address. Some trust management systems, such as SDSI and Delegation Logic, allow what we call attribute-based delegation, that is the delegation of attribute authority to entities having certain attributes.</p><p>Example 2. EPub offers another discount to university students, and delegates the authority over the identification of students to entities that are accredited universities.</p><p>Attribute-based delegation is achieved in SDSI through linked names, and in Delegation Logic through dynamic threshold structures and through conditional delegations. Systems that support attribute-based delegation promise high flexibility and scalability. However they significantly complicate the structure and discovery of credential chains.</p><p>Beyond storing credentials where they can be found, distributed discovery also requires an evaluation procedure that can drive credential collection. Such a procedure must be goal-oriented in the sense of expending effort only on chains that involve the requester and the access mediator, or its trusted authorities. In the Internet, with distributed storage of millions of credentials, most of them unrelated to one another, goal-oriented techniques will be crucial. The procedure must also be able to suspend evaluation, issue a request for credentials that could extend partial chains, and then resume evaluation when additional credentials are obtained. Existing evaluation procedures for SDSI and for Delegation Logic are either not goal-oriented, or do not support this alternation between collection and evaluation steps.</p><p>As a concrete foundation for discussing the discovery problem, we introduce a trust-management language, RT0, which supports attribute-based delegation and subsumes SDSI 2.0 (the "SDSI" part of SPKI/SDSI 2.0 <ref type="bibr" target="#b10">[10]</ref>). We provide goaloriented evaluation algorithms based on a graphical representation of RT0 credentials. This representation is ideal for driving credential collection because it makes it easy to suspend and resume, and to schedule work flexibly. Even in the centralized case, goal-orientation is an advantage when the credential pool is very large and contains many credentials that are unrelated. We also show how to use our algorithms to perform goal-oriented chain discovery for SDSI 2.0.</p><p>The rest of this paper is organized as follows. In section 2, we present the syntax and a set-theoretic semantics for RT0. In section 3, we present goal-oriented, graph-based algorithms for centralized chain discovery in RT0, and show how to apply them to SDSI as well. We prove that the graphbased notion of credential chains is sound and complete with respect to the semantics for RT0. In section 4, we study chain discovery in the distributed case. We present a notion of well-typed credentials and prove that chains of well-typed credentials can always be discovered. In section 5, we discuss future directions and some related work. We conclude in section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A ROLE-BASED TRUST-MANAGEMENT LANGUAGE</head><p>This section introduces RT0, the first (and the simplest) in a series of role-based trust-management languages we are developing. We present RT0's syntax, discuss its intended meaning, and compare it to SDSI. Then we give a formal semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Language RT0</head><p>The constructs of RT0 include entities, role names, and roles. Typically, an entity is a public key, but could also be, say, a user account. Entities can issue credentials and make requests. RT0 requires that each entity can be uniquely identified and that one can determine which entity issued a particular credential or a request. In this paper, we use A, B, and D to denote entities. A role name is an identifier, say, a string. We use r, r1, r2, etc., to denote role names. A role takes the form of an entity followed by a role name, separated by a dot, e.g., A.r and B.r1. The notion of roles is central in RT0. A role has a value that is a set of entities who are members of this role. Each entity A has the authority to define who are the members of each role of the form A.r. A role can also be viewed as an attribute. An entity is a member of a role if and only if it has the attribute identified by the role. In RT0, an access control permission is represented as a role as well. For example, the permission to shut down a computer can be represented by a role OS.shutdown.</p><p>There are four kinds of credentials in RT0, each corresponding to a different way of defining role membership:</p><formula xml:id="formula_0">• Type-1 : A.r ←-B</formula><p>A and B are (possibly the same) entities, and r is a role name.</p><p>This means that A defines B to be a member of A's r role. In the attribute-based view, this credential can be read as B has the attribute A.r, or equivalently, A says that B has the attribute r.</p><p>• Type-2 : A.r ←-B.r1</p><p>A and B are (possibly the same) entities, and r and r1 are (possibly the same) role names.</p><p>This means that A defines its r role to include all members of B's r1 role. In other words, A defines the role B.r1 to be more powerful than A.r, in the sense that a member of B.r1 can do anything that the role A.r is authorized to do. Such credentials can be used to define role-hierarchy in Role-Based Access Control (RBAC) <ref type="bibr" target="#b16">[16]</ref>. The attribute-based reading of this credential is: if B says that an entity has the attribute r1, then A says that it has the attribute r. In particular, if r and r1 are the same, this is a delegation from A to B of authority over r.</p><p>• Type-3 :</p><formula xml:id="formula_1">A.r ←-A.r1.r2</formula><p>A is an entity, and r, r1, and r2 are role names. We call A.r1.r2 a linked role.</p><p>This means that members(A.r) ⊇ members(A.r1.r2) = B∈members(A.r1) members(B.r2), where members(e) represents the set of entities that are members of e. The attribute-based reading of this credential is: if A says that an entity B has the attribute r1, and B says that an entity D has the attribute r2, then A says that D has the attribute r. This is attribute-based delegation: A identifies B as an authority on r2 not by using (or knowing) B's identity, but by another attribute of B (viz., r1). If r and r2 are the same, A is delegating its authority over r to anyone that A believes to have the attribute r1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>•</head><p>Type-4 :</p><formula xml:id="formula_2">A.r ←-f1 ∩ f2 ∩ • • • ∩ f k</formula><p>A is an entity, k is an integer greater than 1, and each fj, 1 ≤ j ≤ k, is an entity, a role, or a linked role starting with A. We call f1∩f2∩• • •∩f k an intersection.</p><p>This means that members(A.r) ⊇ (members(f1) ∩ • • • ∩ members(f k )). The attribute-based reading of this credential is: anyone who has all the attributes f1, . . . , f k also has the attribute A.r.</p><p>A role expression is an entity, a role, a linked role, or an intersection. We use e, e1, e2, etc, to denote role expressions. By contrast, we use f1, . . . , f k to denote the intersection-free expressions occurring in intersections. All credentials in RT0 take the form, A.r ←e, where e is a role expression. Such a credential means that members(A.r) ⊇ members(e), as we formalize in section 2.2 below. We say that this credential defines the role A.r. (This choice of terminology is motivated by analogy to name definitions in SDSI, as well as to predicate definitions in logic programming.) We call A the issuer, e the right-hand side, and each entity in base(e) a subject of this credential, where base(e) is defined as follows: base</p><formula xml:id="formula_3">(A) = {A}, base(A.r) = {A}, base(A.r1.r2) = {A}, base(f1 ∩ • • • ∩ f k ) = base(f1) ∪ • • • ∪ base(f k ). Example 3.</formula><p>Combining examples 1 and 2, EPub offers a special discount to anyone who is both a preferred customer of EOrg and a student. To identify legitimate universities, EPub accepts accrediting credentials issued by the fictitious Accrediting Board for Universities (ABU). The following credentials prove Alice is eligible for the special discount: </p><formula xml:id="formula_4">                 EPub.spdiscount ←-</formula><formula xml:id="formula_5">                </formula><p>Readers familiar with Simple Distributed Security Infrastructure (SDSI) <ref type="bibr">[8,</ref><ref type="bibr" target="#b10">10]</ref> may notice the similarity between RT0 and SDSI's name certificates. Indeed, our design is heavily influenced by existing trust-management systems, especially SDSI and Delegation Logic (DL) <ref type="bibr" target="#b15">[15]</ref>. RT0 can be viewed as an extension to SDSI 2.0 or a syntactically sugared version of a subset of DL. The arrows in RT0 credentials are the reverse direction of those in SPKI/SDSI. We choose to use this direction to be consistent with an underlying logic programming reading of credentials and with directed edges in credential graphs, introduced below in section 3. In addition, RT0 differs from SDSI 2.0 in the following two aspects.</p><p>First, SDSI allows arbitrarily long linked names, while we allow only length-2 linked roles. There are a couple of reasons for this design. We are not losing any expressive power; one can always break up a long chain by introducing additional roles and credentials. Moreover, it often makes sense to break long chains up, as doing so creates more modular policies. If A wants to use B.r1.r2. Second, SDSI doesn't have RT0's type-4 credentials, and so RT0 is more expressive than the current version of SDSI 2.0. Intersections and threshold structures (e.g., those in <ref type="bibr" target="#b10">[10]</ref>) can be used to implement one another. Threshold structures may appear in name certificates according to <ref type="bibr" target="#b10">[10]</ref> and earlier versions of <ref type="bibr" target="#b11">[11]</ref>. This is disallowed in <ref type="bibr">[8]</ref> and the most up-to-date version of <ref type="bibr" target="#b11">[11]</ref>, because threshold structures are viewed as too complex <ref type="bibr">[8]</ref>. Intersections provide similar functionality with simple and clear semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The Semantics of RT0</head><p>This section presents a non-operational semantics of RT0. Given a set C of RT0 credentials, we define a map SC : Roles → ℘(Entities), where ℘(Entities) is the power set of Entities. SC is given by the least solution to a system of set inequalities that is parameterized by a finite, set-valued function, rmem : Roles → ℘(Entities). That is, the semantics is the least such function that satisfies the system, where the ordering is pointwise subset. We use a least fixpoint so as to resolve circular role dependencies. To help construct the system of inequalities, we extend rmem to arbitrary role expressions (whose domain we denote by RoleExpressions) through the use of an auxiliary semantic function, expr rmem : RoleExpressions → ℘(Entities) defined as follows:</p><formula xml:id="formula_6">expr rmem (B) = {B} expr rmem (A.r) = rmem(A.r) expr rmem (A.r1.r2) = B∈rmem(A.r 1 ) rmem(B.r2) expr rmem (f1 ∩ • • • ∩ f k ) = 1≤j≤k expr rmem (fj)</formula><p>We now define SC to be the least value of rmem satisfying the following system of inequalities:</p><formula xml:id="formula_7">expr rmem (e) ⊆ rmem(A.r) A.r ←-e ∈ C .</formula><p>As with rmem, we use expr to extend SC to role expressions, writing expr S C (e) for the members of role expression e.</p><p>The least solution to such a system can be constructed as the limit of a sequence {rmemi}i∈N , where N is the set of natural numbers, and where for each i, rmemi : Roles → ℘(Entities). The sequence is defined inductively by taking rmem0(A.r) = ∅ for each role A.r and by defining rmemi+1 so that for each role A.r,</p><formula xml:id="formula_8">rmemi+1(A.r) = A.r ←-e ∈ C expr rmem i (e).</formula><p>The function that relates the values of {rmemi}i∈N is monotonic, because the operators used to construct it (∩ and ∪) are monotonic. Furthermore, Roles → ℘(Entities) is a complete lattice. So this sequence is known to converge to the function's least fixpoint, which is clearly also the least solution to the inequalities. (As the lattice is finite, convergence takes place finitely.) Thus, the least solution exists and is easily constructed. For instance, referring to example 3 and showing only changes in the function's value, successive values of rmemi have: for i = 1, ABU.accredited = {StateU}, StateU.stuID = {Alice}, ACM.member = {Alice}; for i = 2, EPub.university = {StateU}, EOrg.preferred = {Alice}; for i = 3, EPub.student = {Alice}; for i = 4, EPub.spdiscount = {Alice}, where they stabilize.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">CENTRALIZED CHAIN DISCOVERY</head><p>Given a set of credentials C in RT0, three important kinds of queries are:</p><p>1. Given a role A.r, determine its member set, SC(A.r); 2. Given an entity D, determine all the roles it belongs to, i.e., all role A.r's such that D ∈ SC(A.r);</p><p>3. Given a role A.r and an entity D, determine whether D ∈ SC(A.r).</p><p>In this section, we study credential chain discovery for RT0 when credentials are centralized. We give goal-oriented algorithms for answering the above three kinds of queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Algorithm Requirements</head><p>Chain discovery in RT0 shares two key problem characteristics with discovery in SDSI: linked names give credential chains a non-linear structure and role definitions can be cyclic. Cyclic dependencies must be managed to avoid nontermination. Clarke et al. <ref type="bibr">[8]</ref> have given an algorithm for chain discovery in SPKI/SDSI 2.0. Their algorithm views each certificate as a rewriting rule and views discovery as a term-rewriting problem. It manages cyclic dependency by using a bottom-up approach-it performs a closure operation over the set of all credentials before it finds one chain. This may be suitable when large numbers of queries are made about a slowly changing credential pool of modest size. However, as the frequency of changes to the credential pool (particularly deletions, such as credential expirations or revocations) approaches the frequency of queries against the pool, the efficiency of the bottom-up approach deteriorates rapidly, particularly when pool size is large.</p><p>Li <ref type="bibr" target="#b14">[14]</ref> gave a 4-rule logic program to calculate meanings of SDSI credentials. Cyclic dependencies are managed by using XSB <ref type="bibr" target="#b17">[17]</ref> to evaluate the program. XSB's extension table mechanism avoids non-termination problems to which other Prolog engines succumb. Yet, for many trustmanagement applications, this solution is excessively heavyweight. Moreover, in its current form, the resulting evaluation mechanism cannot be used to drive credential collection.</p><p>As discussed in section 1, because we seek techniques that work well when the credential pool is distributed or changes frequently, we require chain discovery algorithms that are goal-directed and that can drive the collection process. They also must support interleaving credential collection and chain construction (i.e., evaluation) steps.</p><p>We meet these requirements by providing graph-based evaluation algorithms. Credentials are represented by edges. Chain discovery is performed by starting at the node representing the requester, or the node representing the role (permission) to be proven, or both, and then traversing paths in the graph trying to build an appropriate chain. In addition to being goal-directed, this approach allows the elaboration of the graph to be scheduled flexibly. Also, the graphical representation of the evaluation state makes it relatively straightforward to manage cyclic dependencies. To our knowledge, our algorithms are the first to use a graphical representation to handle linked roles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A Graph Representation of Credentials</head><p>We define a directed graph, which we call a credential graph, to represent a set of credentials and their meanings. Each node in the graph represents a role expression occurring in a credential in C. Every credential A.r ←e ∈ C contributes an edge e → A.r. 1 (This holds for credentials of all types.) The destinations of these edges are roles. Edges are also added whose destinations are linked roles and intersections. We call these derived edges because their inclusion come from the existence of other, semantically related, paths in the graph.</p><p>Definition 1 (Credential Graph). For a set of credentials C, the corresponding credential graph is given by GC = NC, EC where NC and EC are defined as follows.</p><formula xml:id="formula_9">NC = A.r ←-e ∈ C {A.r, e}.</formula><p>EC is the least set of edges over NC that satisfies the following three closure properties: </p><formula xml:id="formula_10">Closure Property 1: If A.r ←-e ∈ C,</formula><formula xml:id="formula_11">If D, f1 ∩ • • • ∩ f k ∈ NC and for each j ∈ [1..k] there is a path D * → fj, then D → f1 ∩ • • • ∩ f k ∈ EC; we say that this edge is derived from the paths D * → fj, for j ∈ [1..k].</formula><p>This definition can be made effective by inductively constructing a sequence of edge sets {EC i }i∈N whose limit is EC. We take EC 0 = {e → A.r | A.r ←e ∈ C} and construct EC i+1 from EC i by adding one edge according to either closure property 2 or 3. Since C is finite, we do not have to worry about scheduling these additions. At some finite stage, no more edges will be added, and the sequence converges to EC. Proof. The proof is by induction on the steps of the construction of {EC i }i∈N shown above. We prove an induction hypothesis that is slightly stronger than the theorem: For each i ∈ N and for any role expressions e1 and e, if there is a path e1 * → e in EC i , then expr S C (e1) ⊆ expr S C (e). We show the base case by using a second, inner induction on the length of the path e1 * → e in EC 0 . The inner base case, in which e1 = e, is trivial; we consider the step. Suppose (e1 * We prove the step by again using an inner induction on the length of e1 * → e, which we now assume is in EC i+1 . Again the basis is trivial. For the step, we decompose e1 * → e into e1 * → e2 → e. There are three cases, depending on which closure property introduced the edge e2 → e. case 1: When e2 → e is introduced by closure property 1, the argument proceeds along the same lines as the base case, using the inner induction hypothesis on e1 * → e2 to derive expr S C (e1) ⊆ expr S C (e2).  The proofs for this and other theorems are omitted due to space limitation; they can be found in the full version of this paper.</p><p>Together, Theorems 1 and 2 tell us that we can answer each of the queries enumerated at the top of this section by consulting the credential graph. The rest of this section gives algorithms for constructing subgraphs that enable us to answer such questions without constructing the entire graph. As we have seen, constructing the path D * → A.r alone proves D is in role A.r. However, where D * → A.r contains derived edges, the paths they are derived from must be constructed first. The portion of the credential graph that must be constructed is what we call a credential chain: chain(D * → A.r) is the least set of edges in EC containing D * → A.r and also containing all the paths that the derived edges in the set are derived from.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The Backward Search Algorithm</head><p>The backward search algorithm determines the member set of a given role expression e0. In terms of the credential graph, it finds all the entity nodes that can reach the node e0. We call it backward because it follows edges in the reverse direction. This name is consistent with the terminology in X.509 <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b9">9]</ref>, in which forward means going from subjects to issuers and reverse means from issuers to subjects. This algorithm works by constructing proof graphs, which are equivalent to, but slightly different from, subgraphs of a credential graph. The minor difference is discussed after the presentation of the algorithm.</p><p>The backward search algorithm constructs a proof graph, maintaining a queue of nodes to be processed; both initially contain just one node, e0. Nodes are processed one by one until the queue is empty.</p><p>To process a role node A.r, the algorithm finds all credentials that define A.r. For each credential A.r ←e, it creates a node for e, if none exists, and adds the edge e → A.r. In the proof graph, there is only one node corresponding to each role expression and each edge is added only once. Each time the algorithm tries to create a node for a role expression e, it first checks whether such a node already exists; if not, it creates a new node, adds it into the queue, and returns it. Otherwise, it returns the existing node.</p><p>On each node e, the algorithm stores a children set, which is a set of nodes, e1, that e can reach directly (i.e., e → e1), and a solution set, which is the set of entity nodes, D, that can reach e (i.e., D * → e). Solutions are propagated from e to e's children in the following ways. When a node is notified to add a solution, it checks whether the solution exists in its solution set; if not, it adds the solution and then notifies all its children about this new solution. When a node e1 is first added as a child of e2 (as the result of adding e2 → e1), all existing solutions on e2 are copied to e1.</p><p>To process an entity node, the algorithm notifies the node to add itself to its own solution set.</p><p>To process a linked role node A.r1.r2, the algorithm creates a node for A.r1 and creates a linking monitor to observe the node. The monitor, on observing that A.r1 has received a new solution B, creates a node for B.r2 and adds the edge B.r2 → A.r1.r2, which we call a link-containment edge.</p><p>To process an intersection node e = f1 ∩ • • • ∩ f k , the algorithm creates one intersection monitor, for e, and k nodes, one for each fj, then makes the monitor observe each node fj. This monitor counts how many times it observes that an entity D is added. For a given entity D, each fj notifies e at most once. If the count reaches k, then the monitor adds the edge D → e. So, to summarize, in addition to the nodes and edges in the credential graph, the algorithm constructs monitors that implement closure properties 2 and 3.</p><p>Given a set of credentials C, the proof graph, G b(e0, C) , constructed by the backward search algorithm starting from e0, is closely related to the credential graph, GC. G b(e0, C) is almost identical to the smallest subgraph of GC whose node set, N 0 C , satisfies the following four closure properties and whose edge set consists of all edges of EC over nodes of</p><formula xml:id="formula_12">N 0 C : (i) e0 ∈ N 0 C ; (ii) e2 ∈ N 0 C &amp; e1 → e2 ∈ EC =⇒ e1 ∈ N 0 C ; (iii) A.r1.r2 ∈ N 0 C =⇒ A.r1 ∈ N 0 C ; and (iv) f1 ∩ • • • ∩ f k ∈ N 0 C &amp; j ∈ [1..k] =⇒ fj ∈ N 0 C</formula><p>. The only difference between G b(e0, C) and such a subgraph of GC is this: G b(e0, C) contains role nodes, created during the processing of linked roles, that don't appear in C. Specifically, when the algorithm processes a linked-role node A.r1.r2, the node B.r2 and the link-containment edge, B.r2 → A.r1.r2, are added, even when B.r2 does not appear in C, and will therefore receive no incoming edges and no solutions. It is not difficult to see that G b(e0, C) contains chain(D * → e0) for every D that can reach e0. To see that O(N 3 ) is a tight bound for the algorithm, consider the following example: C = {A0.r0 ←-Ai, A0.ri ←-A0.r i-1 mod n , Ai.r0 ←-A i-1 mod n .r0, A0.r ←-A0.ri.r0 | 0 ≤ i &lt; n} There are N = 4n credentials. When using backward search algorithm from A0.r , there are edges from each Aj.r0 to each A0.ri.r0, where 0 ≤ i, j &lt; n, so there are n 2 such edges. Each Aj.r0 gets n solutions, so the time complexity is n 3 . We can see that intersections do not increase the worst-case time complexity of this algorithm. O(N M ) is a tight space bound. Following is an example that reaches the bound:   The second part of a node lists each solution eventually associated with this node. Each of those solutions and each graph edge is labeled by the number of the node that was being processed when the solution or edge was added. The edge labeled with 1 is a linking monitor.</p><formula xml:id="formula_13">C = {A0.r0 ←-Ai, A0.ri ←-A0.r i-1 mod n , A0.r ←-A0.ri.r0 ∩ A0.ri.r1 ∩ • • • ∩ A0.ri.rK-1 | 0 ≤ i &lt; n} (0) Alice</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The Forward Search Algorithm</head><p>The forward search algorithm finds all roles that an entity is a member of. The direction of the search moves from the subject of a credential towards its issuer.</p><p>The forward algorithm has the same overall structure as the backward algorithm; however, there are some differences. First, each node stores its parents instead of its children. Second, each node e stores two kinds of solutions: full solutions and partial solutions. Each full solution on e is a role that e is a member of, i.e., a role node that is reachable from e. Each partial solution has the form (f1</p><formula xml:id="formula_14">∩ • • • ∩ f k , j), where 1 ≤ j ≤ k.</formula><p>The node e gets the solution (f1∩• • •∩f k , j) when fj is reachable from e. Such a partial solution is just one piece of a proof that e can reach f1 ∩• • •∩f k . It is passed through edges in the same way as is a full solution. When an entity node D gets the partial solution, it checks whether it has all k pieces; if it does, it creates a node for f1 ∩• • •∩f k , if none exists, and adds the edge</p><formula xml:id="formula_15">D → f1 ∩ • • • ∩ f k .</formula><p>The processing of each node is also different from that in the backward algorithm. For any role expression e, forward processing involves the following three steps. First, if e is a role B.r2, add itself as a solution to itself, then add a linking monitor observing B. This monitor, when B gets a full solution A.r1, creates the node A.r1.r2 and adds the edge B.r2 → A.r1.r2. The addition of such an edge results in B.r2 being added as a parent of A.r1.r2. Second, find all credentials of the form A.r ←e; for each such credential, create a node for A.r, if none exists, and add the edge e → A.r. Third, if e is not an intersection, find all credentials of the form A.r ←-f1 ∩ • • • ∩ f k such that some fj = e; then add (f1 ∩ • • • ∩ f k , j) as a partial solution on e.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows the result of doing forward search using a subset of the credentials in example 3.</p><p>Theorem 4. Under the same assumptions as in theorem 3, the time complexity for the forward search algorithm is O(N 2 M ), and the space complexity is O(N M ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Bi-direction Search Algorithms</head><p>When answering queries about whether a given entity, D, is a member of a given role, A.r, we have the flexibility of combining forward and backward algorithms into a search that proceeds from both D and A.r at once. In this bidirectional algorithm, a node e stores both its parents and its children, as well as both backward solutions (entities that are members of e) and forward solutions (roles that e is a member of).</p><p>In the centralized case, doing either forward search from D or backward search from A.r suffices to answer the query. However, using bi-directional search could improve search efficiency (where search space size is sometimes exponential in path length) by finding two shorter intersecting paths, rather than one longer one. A variety of search strategies bear consideration, and different algorithms can be developed based on them. The algorithms described above use queues to organize node processing, resulting in breadth-first search. If they used stacks, they would perform depth-first search. In general, when there are several nodes that can be explored (from either direction), they can be placed in a priority queue according to some heuristic criteria, e.g., fan-out. Note that these remarks also apply to the forward and backward algorithms.</p><p>In the distributed case, the ability to locate credentials can become a limiting factor. This is the main issue we address in section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Implementation, Generalization, and Application to SDSI</head><p>We have implemented the above algorithms in Java. Our program can be configured to store the parent or child node from which each solution arrives. Using this information, one can easily trace paths, and compute the set of credentials being used in any proof graph.</p><p>Our algorithms can be generalized to search for paths between two arbitrary role expressions. One way to do this is to generalize the solution set to collect all reachable nodes, not just entity and role nodes. Then, one knows that a path e1 * → e2 exists when e1 is added as a backward solution on e2 or when e2 is added as a forward solution on e1. Of course, such a change would affect the algorithm's complexity.</p><p>Our algorithms can also be used to do chain discovery in SDSI. To allow their construction in RT0, long linked names can be broken up. Instead of using A.r ←-B.r1.r2. This O(N 3 L) worst-case complexity is the same as that of the algorithm in Clarke et al. <ref type="bibr">[8]</ref>.</p><formula xml:id="formula_16">• • • .r k , one can use {A.r ←-A.r k-1 .r k , A.r k-1 ←-A.r k-2 .r k-1 , • • • , A.r 2 ←-A.</formula><p>Instead of breaking up long linked names, one can extend our algorithms to handle them directly. It is also not difficult to extend our algorithms to handle SPKI delegation certificates. In particular, it is straightforward to extend our techniques for handling intersections to handle threshold structures as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DISTRIBUTED CHAIN DISCOVERY</head><p>The algorithms given in the previous section can be used when credential storage is not centralized, but distributed among credentials' subjects and issuers. As discussed in section 1, it is impractical to require either that all credentials be stored by their issuers or that all be stored by their subjects. Yet if no constraint is imposed on where credentials are stored, some chains cannot be found without broadcast, which we assume is unavailable.</p><p>Example 4. Consider the following credentials from example 3: ABU .accredited ←-StateU and StateU .stuID ←-Alice. If both of these are stored exclusively with StateU , none of our search procedures can find the chain that authorizes Alice. Arriving at ABU and at Alice, the procedure is unable to locate either of these two key credentials.</p><p>This section presents a type system for credential storage that ensures chains of well-typed credentials can be found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Traversability</head><p>We introduce notions of path traversability to formalize the three different directions in which distributed chains can be located and assembled, depending on the storage characteristics of their constituent credentials. We call the three notions, forward traversability, backward traversability, and confluence, respectively. Working from one end or the other, or from both simultaneously, a search agent needs to be able to find the credential defining each edge in a path, D * → A.r, as well as in the other paths of chain(D * → A.r), which prove the existence of derived edges in D * → A.r. Suppose that D * → A.r consists entirely of edges that represent credentials that are stored by their subjects. (In this case, (D</p><formula xml:id="formula_17">* → A.r) = chain(D * → A.r).) We call D * → A.r</formula><p>forward traversable because forward search can drive its distributed discovery, as follows. Obtain from D the first credential of the path and, with it, the identity (and hence the location) of the issuer of that credential. That issuer is the subject of the next credential. By visiting each successive entity in the path and requesting their credentials, each credential in the path can be obtained, without broadcast.</p><p>A backward traversable path is analogous to a forward traversable path, except the credentials involved are held by issuers. A path D * → A.r that is backward traversable can be discovered by doing backward search starting from A.r. Credentials involved in the path can be collected from entities starting with A and working from issuers to subjects.</p><p>Roughly speaking, a confluent path can be decomposed into two subpaths, one forward traversable and the other backward traversable. When both ends are known, a confluent path can be collected and assembled by starting at both ends and working inwards.</p><p>We define these notions of traversability for both edges and paths in credential graphs. Following the definition, we discuss the intuition behind traversability of derived edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Traversibility and Confluence ).</head><p>Let GC = NC, EC be the credential graph for a given set of credentials, C. An edge added by closure property 1 is:  </p><formula xml:id="formula_18">Forward traversable if</formula><formula xml:id="formula_19">for each j ∈ [1..k], D * → fj is confluent; Confluent if for each j ∈ [1..k], D * → fj is con- fluent;</formula><p>Here is why a derived edge of the form B.r2 → A.r1.r2 has the same traversability as the path that it is derived from. Suppose there is a forward traversable path D * </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">A Credential Type System</head><p>If all credentials are stored by their issuers, all paths are backward traversable. Similarly, if all credentials are stored by their subjects, all paths are forward traversable. As we argued in section 1, neither arrangement by itself is satisfactory-greater flexibility is required in practice. Yet some constraints must be imposed on credential storage, or else many paths cannot be discovered. One way to organize those constraints is by requiring that all credentials defining a given role name have the same storage characteristics. Capitalizing on this observation to support distributed discovery, we introduce a type system for credential storage, the important feature of which is that, given a set of well-typed credentials, every path in its credential graph is confluent.</p><p>In our type system, each role name has two types: an issuer-side type specifies whether a search agent can trace credentials that define the role name by starting from the credentials' issuers; the other, a subject-side type, specifies these credentials' traceability from their subjects.</p><p>The possible issuer-side type values are issuer-traces-none, issuer-traces-def, and issuer-traces-all. If a role name r is issuer-traces-def, then from any entity A one can find all credentials defining A.r. In other words, A must store all credentials defining A.r. However, this does not guarantee that one can find all members of A.r. For instance, we might have A.r ←-B.r1, with r1 issuer-traces-none. This motivates the stronger type: issuer-traces-all. A role name r being issuer-traces-all implies not only that r is issuertraces-def, but also that, for any entity A, using backward searching, one can find all the members of the role A.r.</p><p>The possible subject-side type values are subject-tracesnone and subject-traces-all. If a role name r is subjecttraces-all, then for any entity B, by using forward search, one can find all roles A.r such that B is a member of A.r.</p><p>There are three values for the issuer-side type and two values for the subject-side type, yielding six combinations; however, a role name that is both issuer-traces-none and subject-traces-none is useless, so it is forbidden. This is captured by the notion of well-typedness.</p><p>We now extend this type system to role expressions and then define the notion of well-typed credentials. As we show in the next section, together these two definitions guarantee that when credentials are well-typed, the following three conditions hold. If a role expression e is issuer-traces-all, one can find all members of e by doing backward search from e. If e is subject-traces-all, then from any of its members, D, one can find a chain to e by doing forward search. If e is issuer-traces-def, then from any of its members, D, one can find a chain from D to e by doing bi-directional search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Types of role expressions).</head><p>• A role expression is well-typed if it is not both issuertraces-none and subject-traces-none.</p><p>• An entity A is both issuer-traces-all and subject-tracesall.</p><p>• A role A.r has the same type as r.</p><p>• A linked role A.r1.r2 is</p><formula xml:id="formula_20">                </formula><p>issuer-traces-all when both r1 and r2 are issuertraces-all issuer-traces-def when r1 is issuer-traces-all and r2 is issuer-traces-def, or r1 is issuer-traces-def and r2 is subject-traces-all issuer-traces-none otherwise    subject-traces-all when both r1 and r2 are subject-traces-all subject-traces-none otherwise</p><formula xml:id="formula_21">• An intersection f1 ∩ • • • ∩ f k is          issuer-traces-all</formula><p>when there exists an f that is issuer-traces-all, and all fj's are well-typed issuer-traces-def when all fj's are well-typed issuer-traces-none otherwise</p><formula xml:id="formula_22">       subject-traces-all</formula><p>when there exists an f that is subject-traces-all, and all fj's are well-typed subject-traces-none otherwise</p><p>The typing rule for a linked role A.r1.r2 may need some explanation. If both r1 and r2 are issuer-traces-all, then from A.r1.r2, one can find all members of A.r1, and then, for each such member, B, find all members of B.r2. If both r1 and r2 are subject-traces-all, then from any member, D, of A.r1.r2, one can first find that D is a member of B.r2, and then find that B is a member of A.r1, thereby determining that D is a member of A.r1.r2. Knowing both ends, D and A.r1.r2, one needs to find a middle point, B.r2, using forward or backward search from one side. Then the other side can be handled by bi-direction search. If r1 is issuer-tracesall, one can find all members of A.r1, then r2 only needs to be issuer-traces-def. Similarly, if r2 is subject-traces-all, then one can trace to B.r2 from D, and so r1 only needs to be issuer-traces-def.</p><p>Definition 4 (Well-typed Credentials). A credential A.r ←e is well-typed if all of the following conditions are satisfied:</p><p>1. Both A.r and e are well typed.</p><p>2. If A.r is issuer-traces-all, e must be issuer-traces-all.</p><p>3. If A.r is subject-traces-all, e must be subject-traces-all.</p><p>4. If A.r is issuer-traces-def or issuer-traces-all, A stores this credential.</p><p>5. If A.r is subject-traces-all, every subject of this credential stores this credential.</p><p>Consider credentials in example 3. One possible typing that makes all credentials well-typed is as follows: preferred, spdiscount, student, and university are issuer-traces-def, while accredited, stuID, and member are subject-traces-all.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Traversability with Well-typed Credentials</head><p>In this section we show that well-typed credentials whose storage is distributed can be located as needed to perform chain discovery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Agreeing on Types and Role Meanings</head><p>Our type system begs the following question: How can entities agree on the type of a role name? This is the problem of establishing a common ontology (vocabulary), and it arises for RT0 whether or not typing is introduced. Consider again the credentials in example 3. Given StateU.stuID ←-Alice, how does EPub know what StateU means by stuID? Is it issued to students registered in any class, or only to students enrolled in a degree program. This issue arises in all trust-management systems. Different entities need a common ontology before they can use each others' credentials. However, name agreement is particularly critical in systems, like RT0, that support linked roles. For instance, the expression EOrg.university.stuID only makes sense when univeristies use stuID for the same purpose.</p><p>We achieve name agreement through a scheme inspired by XML namespaces <ref type="bibr" target="#b7">[7]</ref>. One creates what we call application domain specification documents (ADSD), defining a suite of related role names. An ADSD gives the types of the role names it defines, as well as natural-language explanations of these role names, including the conditions under which credentials defining these role names should be issued. Credentials contain a preamble in which namespace identifiers are defined to refer to a particular ADSD, e.g., by giving its URI. Each use of a role name inside the credential then incorporates such a namespace identifier as a prefix. Thus, a relatively short role name specifies a globally unique role name. Each ADSD defines a namespace. Note that this is a different level of namespaces from the notion of namespaces in SDSI. The latter concerns itself with who has the authority to define the members of a role; the former is about establishing common understandings of role names.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">FUTURE AND RELATED WORK</head><p>In this section, we illustrate briefly the next step in our role-based trust-management language work. We then discuss other future directions and related work.</p><p>As mentioned in section 2, RT0 is the first step in a series of role-based trust-management languages. We are extending the algorithms presented here to RT1, where role names are terms with internal structure, including logical variables (whose notation starts with "?", as in ?file). For example, the credential OS.fileop(delete, ?file) ←-OS.owner(?file) can be used to express the policy that the operating system will let a file's owner delete the file. We are also working on defining an XML representation for RT1 credentials and application domain specification documents, as we discussed in section 4.4. RT1 will be reported in a forthcoming paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Typing and Complete Information</head><p>Inferencing based on distributed credentials is often limited by not knowing whether all relevant credentials are present. The standard solution to this problem is to limit the system to monotonic inference rules. This approach ensures that, even without access to all credentials, if the credentials that are present indicate D is a member of A.r, it is certainly true. Missing credentials could make you unable to prove D is a member of A.r, but cannot lead you to conclude D is a member of A.r erroneously.</p><p>When credentials are well-typed, as defined here, this restriction to monotonic inference rules could be relaxed. The type system ensures we know who to contact to request the relevant credentials. So assuming they respond and we trust that they give us the credentials we ask for, we can assume that we obtain all the credentials that are relevant. In this context, it may be safe to use non-monotonic inference rules. This would allow, for instance, granting role membership contingent on not already being a member of another role. This could form a basis for supporting RBAC-style separation of duties, as well as negation as failure. It will be necessary to manage the trust issue. For instance, we may trust that some issuers will give us all relevant credentials, while not trusting some subjects to do the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Credential Sensitivity</head><p>Like most prior trust-management work, we assume here that credentials are freely available to the agent responsible for making access control decisions. In general, credentials may themselves be sensitive resources. Techniques have been introduced <ref type="bibr" target="#b18">[18]</ref> that support credential exchange in a context where trust management is applied to credentials, as well as to more typical resources. (See <ref type="bibr" target="#b19">[19]</ref> for additional references.) That work assumes that credential storage is centralized in two locations: with the resource requester and with the access mediator. It remains open to manage disclosure of sensitive credentials whose storage is distributed among the credential issuers and subjects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Other Related Work</head><p>In section 2.1, we compared RT0 credentials with name definition certificates in SDSI 2.0. In section 3.1 we reviewed existing work to chain discovery in SDSI. Now, we discuss some other related work.</p><p>QCM (Query Certificate Managers) <ref type="bibr" target="#b12">[12]</ref> and QCM's variation SD3 <ref type="bibr" target="#b13">[13]</ref> also address distributed credential discovery. The approach in QCM and SD3 assumes that issuer stores all credentials and every query is answered by doing backward searching. As we discussed in the introduction, this is impractical for many applications, including the one illustrated in example 3. Using backward search to determine whether Alice should get the discount requires one to begin by finding all ACM members and all university students.</p><p>Graph-based approaches to chain discovery have been used before, e.g., by Aura <ref type="bibr" target="#b1">[1]</ref> for SPKI delegation certificates and by Clarke et al. <ref type="bibr">[8]</ref> for SDSI name certificates without linked names. Neither of them deals with linked names.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS</head><p>We have introduced a role-based trust-management language RT0 and a set-theoretic semantics for it. We have also introduced credential graphs as a searchable representation of credentials in RT0 and have proven that reachability in credential graphs is sound and complete with respect to the semantics of RT0. Based on credential graphs, we have given goal-oriented algorithms to do credential chain discovery in RT0. Because RT0 is more expressive than SDSI, our algorithms can be used for chain discovery in SDSI, where existing algorithms in the literature either are not goal-oriented or require using specialized logic programming inferencing engines. Because our algorithms are goal-oriented, they can be used whether or not credentials are stored centrally. We have also introduced a type system for credential storage that guarantees distributed, well-typed credential chains can be discovered. This typing approach can be used for other trust-management systems as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">ACKNOWLEDGEMENT</head><p>This work is supported by DARPA through AFRL/IF contract F30602-97-C-0336 and SPAWAR contracts N66001-00-C-8015 and N66001-01-C-8005. Sameer Ajmani made some helpful comments on an earlier version of this paper. We also thank anonymous reviewers for their helpful reports.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 1 (</head><label>1</label><figDesc>Soundness). Given an entity D and a role expression e, if there is a path D * → e in EC, then D ∈ expr S C (e).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>→ e) = (e1 * → e2 → e). Because each edge in EC 0 corresponds to a credential, we have e ←-e2 ∈ C. It follows that expr S C (e2) ⊆ expr S C (e), by definition of SC. The induction assumption gives us expr S C (e1) ⊆ expr S C (e2), so expr S C (e1) ⊆ expr S C (e).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1</head><label></label><figDesc>While long, lefthand arrows (←-) represent credentials, short, righthand arrows (→) represent edges, and short, righthand arrows with stars ( * →) represent paths, which consist of zero or more edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>case 2 :</head><label>2</label><figDesc>When e2 → e is introduced by closure property 2, e has the form A.r1.r2, e2 has the form B.r2, and there is a path B * → A.r1 in EC i . The outer induction hypothesis gives us expr S C (B) ⊆ expr S C (A.r1), i.e., B ∈ SC(A.r1). The inner induction hypothesis gives us expr S C (e1) ⊆ expr S C (B.r2). Together with the definition of expr for A.r1.r2, these imply expr S C (e1) ⊆ expr S C (e), as required. case 3: When e2 → e is introduced by closure property 3, e has the form f1 ∩ • • • ∩ f k , e2 = e1 is an entity D (because entity nodes have no incoming edges), and there are paths D * → fj in EC i for each j ∈ [1..k]. The outer induction hypothesis gives us D ∈ expr S C (fj) for j ∈ [1..k]; therefore, expr S C (e1) ⊆ expr S C (e). Theorem 2 (Completness). For any role, A.r, D ∈ SC(A.r) implies there exists a path D * → A.r in EC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 3 .</head><label>3</label><figDesc>Given a set of credentials C, let N be the number of credentials in C, and M be the total size of C:A.r←-e ∈ C |e|, where |A| = |A.r| = |A.r1.r2| = 1 and |f1 ∩ • • • ∩ f k | = k.Assuming that finding all credentials that define a role takes time linear in the number of such credentials (e.g., by using hashing), then the worst-case time complexity of the backward search algorithm is O(N 3 +N M ), and the space complexity is O(N M ). If each intersection in C has size O(N ), then the time complexity is O(N 3 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: G f (Alice, C) , the proof graph constructed by doing forward search from Alice with C = {EPub.student ←-EPub.university.student, EPub.university ←-ABU.accredited, ABU.accredited ←-StateU, StateU.stuID ←-Alice}. The first line of each node gives the node number in order of creation and the role expression represented by the node.The second part of a node lists each solution eventually associated with this node. Each of those solutions and each graph edge is labeled by the number of the node that was being processed when the solution or edge was added. The edge labeled with 1 is a linking monitor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>r 1 .r2, A.r 1 ←-B.r1}, in which the r i 's are newly introduced role names. Then one can use any of the algorithms to do goal-oriented chain discovery.Theorem 5. Given a set of "SDSI" credentials C, which have arbitrarily long linked roles and no intersection, let C be the result of breaking up long linked roles. Then the time complexity of the backward algorithm, applied to C , is O(N 3 L), where N is the number of credentials in C, and L is the length of the longest linked role in C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>An edge added by closure property 3, D → f1 ∩ • • • ∩ f k is : Forward traversable if (a) there exists an ∈ [1..k] with D * → f forward traversable, and (b) for each j ∈ [1..k], D * → fj is confluent; Backward traversable if (a) there exists an ∈ [1..k] with D * → fj backward traversable, and (b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>→</head><label></label><figDesc>B.r2 → A.r1.r2 * → A.r. Starting at D, a search agent can traverse to B.r2. From there, the agent knows B, which enables it to continue searching, traversing B → A.r. The edge f1 ∩ • • • ∩ f k → B.r1 is forward traversable, so it is stored by the entity base(fj), for each j ∈ [1..k]. If there is one f with D * → f forward traversable, a search agent can use it to get from D to f . From base(f ), the agent can obtain the credential B.r1 ←-f1 ∩ • • • ∩ f k , thereby identifying all other fj's. The search agent then finds a path from D to each fj, and continues its forward search from B.r1. Since both ends are known, each path D * → fj only needs to be confluent. The rationale for backward traversability of edges derived from backward traversible paths is similar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>• • • .r k in its credential, then B.r1.r2. • • • .r k-1 must mean something to A; otherwise, why would A delegate power to members of B.r1.r2. • • • .r k-1 ? Having to create a new role makes A think about what B.r1.r2. • • • .r k-1 means. Finally, restricting lengths of linked roles simplifies the design of algorithms for chain discovery.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>then e → A.r ∈ EC. Closure Property 2: If B.r2, A.r1.r2 ∈ NC and there is a path B * → A.r1 in EC, then B.r2 → A.r1.r2 ∈ EC; we say that this edge is derived from the path B * → A.r1.</figDesc><table><row><cell>Closure Property 3:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>the credential it represents is held by each subject of the credential; Backward traversable if the credential it represents is held by the issuer of the credential; Confluent if it is forward or backward traversable. → e2 is backward traversable, and e → e is confluent. Note that paths that are forward traversable or backward traversable are also confluent. An edge added by closure property 2, B.r2 → A.r1.r2 is: Forward traversable if the path it is derived from, B</figDesc><table><row><cell>A path e1</cell><cell>*  → e2 is:</cell></row><row><cell cols="3">Forward traversable if it is empty (e1 = e2), or it</cell></row><row><cell cols="3">consists entirely of forward traversable edges;</cell></row><row><cell cols="3">Backward traversable if it is empty, or it consists</cell></row><row><cell cols="3">entirely of backward traversable edges;</cell></row><row><cell cols="3">Confluent if it is empty, or it can be decomposed into e1  → A.r1 is backward</cell></row><row><cell cols="2">traversable; Confluent if B</cell><cell></cell></row></table><note><p>* → e → e * → e2 where e1 * → e is forward traversable, e * * → A.r1, is forward traversable; Backward traversable if B * * → A.r1 is confluent;</p></note></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This work is supported by DARPA through SPAWAR contracts N66001-00-C-8015 and N66001-01-C-8005, and AFRL/IF contract F30602-97-C-0336.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fast Access Control Decisions from Delegation Certificate Databases</title>
		<author>
			<persName><forename type="first">Tuomas</forename><surname>Aura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 3rd Australasian Conference on Information Security and Privacy (ACISP &apos;98), volume 1438 of Lecture Note in Computer Science</title>
		<meeting>3rd Australasian Conference on Information Security and Privacy (ACISP &apos;98), volume 1438 of Lecture Note in Computer Science</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="284" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The KeyNote Trust-Management System, Version 2. IETF RFC 2704</title>
		<author>
			<persName><forename type="first">Matt</forename><surname>Blaze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joan</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angelos</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-09">September 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Decentralized Trust Management</title>
		<author>
			<persName><forename type="first">Matt</forename><surname>Blaze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joan</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Lacy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1996 IEEE Symposium on Security and Privacy</title>
		<meeting>the 1996 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="164" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Compliance-Checking in the PolicyMaker Trust Management System</title>
		<author>
			<persName><forename type="first">Matt</forename><surname>Blaze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joan</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Strauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Second International Conference on Financial Cryptography (FC&apos;98), volume 1465 of Lecture Note in Computer Science</title>
		<meeting>Second International Conference on Financial Cryptography (FC&apos;98), volume 1465 of Lecture Note in Computer Science</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="254" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Internet X.509 Public Key Infrastructure LDAPc2 Schema. IETF RFC 2587</title>
		<author>
			<persName><forename type="first">Sharon</forename><surname>Boeyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Howes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Richard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-06">June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Regulating service access and information release on the web</title>
		<author>
			<persName><forename type="first">Piero</forename><surname>Bonatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierangela</forename><surname>Samarati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM Computer and Communication Security</title>
		<meeting>the 7th ACM Computer and Communication Security</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="134" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Namespaces in XML. W3C Recommendation</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Bray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dave</forename><surname>Hollander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Layman</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/REC-xml-names/" />
		<imprint>
			<date type="published" when="1999-01">January 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Certificate Chain Discovery in SPKI/SDSI. Manuscript submitted to</title>
		<author>
			<persName><forename type="first">Dwaine</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Emile</forename><surname>Elien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><surname>Ellison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matt</forename><surname>Fredette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Morcos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronald</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<ptr target="http://theory.lcs.mit.edu/˜rivest/publications.html" />
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<date type="published" when="2000-12">December 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Building Certificate Paths: Forward vs. Reverse</title>
		<author>
			<persName><forename type="first">Yassir</forename><surname>Elley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anne</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steve</forename><surname>Hanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Mullan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radia</forename><surname>Perlman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seth</forename><surname>Proctor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 Network and Distributed System Security Symposium (NDSS&apos;01)</title>
		<meeting>the 2001 Network and Distributed System Security Symposium (NDSS&apos;01)</meeting>
		<imprint>
			<publisher>Internet Society</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="153" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">Carl</forename><surname>Ellison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bill</forename><surname>Frantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Butler</forename><surname>Lampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ron</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tatu</forename><surname>Ylonen</surname></persName>
		</author>
		<title level="m">SPKI Certificate Theory. IETF RFC 2693</title>
		<imprint>
			<date type="published" when="1999-09">September 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Carl</forename><surname>Ellison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bill</forename><surname>Frantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Butler</forename><surname>Lampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ron</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tatu</forename><surname>Ylonen</surname></persName>
		</author>
		<ptr target="http://world.std.com/˜cme/spki.txt" />
		<imprint>
			<date type="published" when="1999-07">July 1999</date>
			<publisher>Simple Public Key Certificates</publisher>
		</imprint>
	</monogr>
	<note>Internet Draft (Work in Progress</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Policy-directed certificate retrieval</title>
		<author>
			<persName><forename type="first">Carl</forename><forename type="middle">A</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Jim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software: Practice &amp; Experience</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">15</biblScope>
			<biblScope unit="page" from="1609" to="1640" />
			<date type="published" when="2000-09">September 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SD3: a trust management system with certificate evaluation</title>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Jim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2001 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="106" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Local Names in SPKI/SDSI</title>
		<author>
			<persName><forename type="first">Ninghui</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th IEEE Computer Security Foundations Workshop (CSFW-13)</title>
		<meeting>the 13th IEEE Computer Security Foundations Workshop (CSFW-13)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="2" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Practically Implementable and Tractable Delegation Logic</title>
		<author>
			<persName><forename type="first">Ninghui</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">N</forename><surname>Grosof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joan</forename><surname>Feigenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2000 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2000 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="27" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Role-Based Access Control Models</title>
		<author>
			<persName><forename type="first">Ravi</forename><forename type="middle">S</forename><surname>Sandhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><forename type="middle">J</forename><surname>Coyne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hal</forename><forename type="middle">L</forename><surname>Feinstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">E</forename><surname>Youman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="38" to="47" />
			<date type="published" when="1996-02">February 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The XSB Programming System (Version 2.2)</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">S</forename><surname>Warren</surname></persName>
		</author>
		<ptr target="http://www.cs.sunysb.edu/˜sbprolog/xsb-page.html" />
		<imprint>
			<date type="published" when="2000-04">April 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Automated Trust Negotiation</title>
		<author>
			<persName><forename type="first">H</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kent</forename><forename type="middle">E</forename><surname>Winsborough</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vicki</forename><forename type="middle">E</forename><surname>Seamons</surname></persName>
		</author>
		<author>
			<persName><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DARPA Information Survivability Conference and Exposition</title>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2000-01">January 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Interoperable strategies in automated trust negotiation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winslett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Seamons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
