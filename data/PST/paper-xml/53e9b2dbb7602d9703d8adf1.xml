<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Degrees of Acyclicity for Hypergraphs and Relational Database Schemes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">IBM Research Laboratory</orgName>
								<address>
									<settlement>San Jose</settlement>
									<region>Cahfornia</region>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">IBM Research Laboratory</orgName>
								<address>
									<addrLine>K51/281, 5600 Cottle Road</addrLine>
									<postCode>95193</postCode>
									<settlement>San Jose</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Degrees of Acyclicity for Hypergraphs and Relational Database Schemes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">572667BD226B29D74EB1862F0B5C17E2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>G.2.2 [Discrete Mathematics]: Graph Theory--graph algorithms</term>
					<term>trees</term>
					<term>H.2.1 [Database Management]: Logical Design--normal forms</term>
					<term>, schema and subschema</term>
					<term>H 3.3 [Information Storage and Retrieval]&apos; Information Search and Retrieval--query formulation Algorithms, Design, Languages, Management, Theory Acyclicity, hypergraph, database scheme, relational database, join dependency, loop-free Bachman diagram</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Database schemes (winch, intuitively, are collecuons of table skeletons) can be wewed as hypergraphs (A hypergraph Is a generalization of an ordinary undirected graph, such that an edge need not contain exactly two nodes, but can instead contain an arbitrary nonzero number of nodes.) A class of "acychc" database schemes was recently introduced. A number of basic desirable propemes of database schemes have been shown to be equivalent to acyclicity This shows the naturalness of the concept. However, unlike the situation for ordinary, undirected graphs, there are several natural, noneqmvalent notions of acyclicity for hypergraphs (and hence for database schemes). Various desirable properties of database schemes are constdered and it is shown that they fall into several equivalence classes, each completely characterized by the degree of acycliclty of the scheme The results are also of interest from a purely graph-theoretic viewpomt. The original notion of aeyclicity has the countermtmtive property that a subhypergraph of an acychc hypergraph can be cyclic. This strange behavior does not occur for the new degrees of acyelicity that are considered.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>A hypergraph is a pair (./if,, 8), where Jffis a finite set of nodes and 8 is a set of edges (or hyperedges) which are arbitrary nonempty subsets of ~ An ordinary undirected graph (without self-loops) is, of course, a hypergraph where every edge has exactly two nodes. A special class of hypergraphs, called acyclic, has recently been introduced <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b6">8,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b21">23]</ref>. We shall call this class Â¢t-acyclic in this paper. There is a natural correspondence between database schemes, each of which can be thought of as a collection of table skeletons, as in Figure <ref type="figure">1</ref>, and hypergraphs. For example, the hypergraph of Figure <ref type="figure" target="#fig_6">2</ref> corresponds to the database scheme of Figure <ref type="figure">1</ref>. A database scheme is said to be a-acyclic precisely if the corresponding hypergraph is. Every ~t-acyclic database scheme enjoys a number of desirable properties, each of which is in fact equivalent to a-acyclicity <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b6">8,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b21">23,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b30">32]</ref>. Further <ref type="bibr" target="#b36">[38]</ref>, there are</p><formula xml:id="formula_0">SUPPLIER PART PROJECT PARTICOST I !1 FIGURE 1 FIGURE 2</formula><p>problems that are NP-complete in general, but which have polynomial-time algorithms under the assumption of a-acyclicity.</p><p>There are other, even nicer properties of database schemes that are too strong to be obeyed by all a-acyclic database schemes. We study some such properties and characterize graph-theoretically those database schemes which enjoy these properties. Once again, the properties fall into equivalence classes, which correspond to natural "degrees of acyclicity" for hypergraphs. For, unlike the situation for ordinary, undirected graphs, there are a number ofinequivalent, natural definitions of acyclicity for hypergraphs. It is appropriate to speak of "degrees of acydicity," rather than simply "types of acychcity," since it turns out that there is a linear ordering of the strengths of the types of acyclicity we consider; the weakest (least restrictive) is the previously studied notion of a-acyclicity.</p><p>Our new degrees of acychcity remedy a mathematically unnatural property of the earlier notion of a-acyclicity; namely, it is possible for a hypergraph to be a-acyclic but have an t~-cyclic subhypergraph. (A subhypergraph contains a subset of the edges of the original hypergraph.) This strange phenomenon does not occur for our new degrees of acyclicity.</p><p>Each of the degrees of hypergraph acyclicity that we consider is a generalization of the concept of acyclicity for ordinary undirected graphs; that is, an undirected graph is acyclic in the usual sense if and only if it is "acyclic," when viewed as a hypergraph, for any of our notions of "acyclic."</p><p>There is an analogy between degrees of acyclicity for database schemes and normal forms <ref type="bibr" target="#b13">[ 15,</ref><ref type="bibr" target="#b18">20]</ref> for relation schemata (a relation scheme along with its set of dependencies <ref type="bibr" target="#b19">[21]</ref>). For, there is a hierarchy of normal forms for relation schemata, each normal form being more restrictive than its predecessor. Codd has argued that we should not insist that a relation schema be in a given normal form. Rather, the database designer should be aware of the issues and have a warning flag that if the relation schema is not in a given normal form, then certain problems may arise. An identical comment applies to the question of whether a database scheme should obey a given degree of acyclicity. In practice, it might be reasonable to try to attain a given degree of acyclicity in a user's view (which involves only a portion of the database), rather than in the whole database scheme. This might be attainable, for example, by renaming attributes. An example is given in Section 8. We now give an example of a natural database property that is equivalent to one of our degrees of acyclicity ("y-acyclicity"). Assume that there are (among others) an EMP__INFO relation with attributes (column names) EMP (for "employee"), DEPT, and SALARY, and a DEPT___INFO relation with attributes DEPT, CITY, and MGR. An example of an "(EMP, CITY} relationship" is obtained by joining together the EMP__INFO and the DEPT__INFO relations on DEPT and projecting the result on EMP and CITY. It is conceivable that there could be other (EMP, CITY} relationships, obtained by taking one, two, or more other relations and joining them together in some manner and then projecting the result onto EMP and CITY. However, we show that a database scheme is y-acyclic if and only if for every set X of attributes (such as (EMP, CITY}) and every consistent database over the scheme, there is a unique X-relationship.</p><p>Thus, in the above example, if the database scheme is 7-acyclic and the database is consistent, then there is a unique {EMP, CITY} relationship. This fact has a number of useful corollaries. For example, an SQL query <ref type="bibr" target="#b11">[13]</ref> to fred all EMPs associated with the CITY San Jose would be SELECT EMP FROM EMP__INFO, DEPT__INFO WHERE EMP INFO.DEPT --DEPT__INFO.DEPT AND DEPT___INFO.CITY --'San Jose'.</p><p>However, by y-acyclicity it is possible instead to unambiguously pose the query SELECT EMP WHERE CITY = 'San Jose'.</p><p>(1.1)</p><p>The desirability of being able to pose queries such as (1.1), with such a simple syntax, has been discussed by UUman <ref type="bibr" target="#b35">[37]</ref>. Not only is the latter query easier to pose and simpler to understand than the SQL query, but also the system has a great deal of flexibility in optimizing how to f'md the result of the query. The system's choice of which relations to join might depend, for example, on which indices are present. Languages such as SQL are considered high-level, since it is not necessary to explicitly state the access paths (such as which indices to utilize). Similarly, in a y-acychc database scheme it is possible to make use of a still higher level language, in which it is not even necessary to specify which relations must be joined to obtain the answer the user desires.</p><p>We now discuss the organization of the paper. If all the reader cares about are the database properties (as opposed to graph-theoretic properties), then he can simply skim Sections 2-6; for example, such a reader need only note one of the various equivalent det'mitions of a given degree of acyclicity. In Section 2 we present some basic definitions and define a-acyclicity. In Section 3 we define Berge's <ref type="bibr" target="#b8">[10]</ref> noUon of acyclicity. In Section 4 we give several natural but different-looking definitions of one of our new degrees of acyclicity, namely, fl-acyclicity, and prove that the detrmitions are equivalent. We also discuss the desirability of ~-acyclic database schemes. In Section 5 we define -t-acyclicity and prove the equivalence of various definitions of y-acyclicity. In Section 6 we prove that Berge-acyclicity =* -t-acyclicity =* fl-acyclicity ~ o~-acyclicity but that none of the reverse implications hold. We also contrast features of the various degrees of acyclicity and discuss their naturalness. In Section 7 we define join expressions, which correspond to "programs" for taking joins, and discuss some of their properties (join expressions are useful for the discussion in <ref type="bibr">Section 8)</ref>. In Section 8 we describe a number of desirable properties of database schemes, involving monotone-increasing joins and unique relationships among attributes, such that each property is equivalent to the scheme being ~,-acyclic. In Section 9 we give polynomial-time algorithms for determining the degree of acyclicity. In Section 10 we present our conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">a-acyclicity</head><p>Let j~r be a finite set of distinct symbols, called attributes (or column names), and let Y be a subset of~VT. A Y-tuple (or simply a tuple, if Y is understood) is a function with domain Y. Thus a tuple is a mapping that associates a value with each attribute in Y. If X is a subset of Y and t is a Y-tuple, then t[X] denotes the X-tuple obtained by restricting the mapping to X. A Y-relation (or a relation over Y, or simply a relation, if Y is understood) is a finite set of Y-tuples. If r is a Y-relation and X is a subset of Y, then by r[X], the projection of r onto X, we mean the set of all tuples t[X], where t is in r. We shall often denote sets of attributes by uppercase letters and relations by lowercase letters. I f ~ r is a set of attributes, then we deirme a database scheme R ---(Rx . . . . . R,,) to be a set of subsets of ~. Intuitively, for each i, the set R, of attributes is considered the set of column names for a relation. We may call the R,'s relation schemes. If rl . . . . . r,, are relations, where r, is a relation over R, (1 ___ i ___ n), then we may say that r = (rl . . . . , rn} is a database over R. We may call r, the R, relation.</p><p>We have already defined a hypergraph to be a pair (~, g), where A/'is a set of nodes and 8 is a set of edges (or hyperedges) which are arbitrary nonempty subsets of We sometimes refer to the edges as "'full" edges, to distinguish them from "partial" edges, which we discuss later. The hypergraph of a database scheme (R~ . . . . , R,,) has as its set of nodes those attributes that appear in one or more of the R,'s, and as its set of edges R = (R~ . . . . . Rn). We shall often speak of the "hypergraph R" without mentioning the set jlr of nodes; then we tacitly assume that Y = I.J (R,: 1 &lt; i __-n}.</p><p>Let us give some terminology for hypergraphs. A path from node s to node t is a sequence of k ___ 1 edges E1 . . . . , Ek such that (i) s is in El, (ii) t is in Ek, and (iii) E, n E,+a is nonempty if I &lt;__ i &lt; k.</p><p>We also say that the above sequence of edges is a path from E1 to Ek.  Let ~ be a set of nodes of the hypergraph (..,V,, 8). The set of partial edgQs generated by ./g is defined to be obtained by intersecting the edges in 8 with J/, that is, takin 8 (E N J I : E ~ 8} -{0} and then taking the reduction of this set of edges. The set of partial edges generated from (JV, 8) by some set ~ is said to be a node,generated set of partial edges.</p><p>Let ~ be a connected, reduced set of partial edges, and let E and F be in ~. Let Q = E N F. We say that Q is an articulation set of~ -~ if the result of removing Q from every edge of ~, that is, {E -Q: E ~ ~} -{O}, is not a connected set of partial edges. It is clear that an articulation set in a hypergraph is a generalization of the concept of an articulation point in an ordinary graph.</p><p>A block of a reduced hypergraph is a connected, node-generated set of partial edges with no articulation set. A set is trivial if it contains less than two members. A reduced hypergraph is a-acyclic if all its blocks are trivial; otherwise, it is e~,cyÂ¢lic. A hypergraph is said to be a-cyclic or a-acyclic precisely if its reduction is.</p><p>Example 2.1. It is straightforward to verify that Figure <ref type="figure" target="#fig_8">3</ref> shows an 0l-aeyÂ¢liÂ¢ hypergraph. Its edges are ABC, CDE, EFA, and ACE. (We follow the usual database convention that {A, B, C} is abbreviated by ABC, etc.) An articulation set for the set of all edges is ABC N ACE = AC, since the result of removing A and C from each edge is to leave the set of edges B, DE, EF, and E, which is not connected (B is disconnected from the others). Note that the subset {ABC, CDE, EFA} of the ~dges (Figure <ref type="figure" target="#fig_1">4</ref>) has no articulation set. However, this set is not node-generated, so there is no contradiction of our assertion that the hypergraph of Figure <ref type="figure" target="#fig_8">3</ref> is a-acycliÂ¢. [2 Let (.A', 6 ~) be a hypergraph, and let ~ be a subset of 6 ~. Let . g be the set of nodes that is the union of members in ~. We say that ~ is closed if for each edge E of the hypergraph, there is an edge F in ~ such that E N . g __ F. For example, {G, H, 1} in Figure <ref type="figure" target="#fig_2">5</ref> is a closed set of edges. Thus the intersection of edge K with G O H U 1 is contained in edge H; similarly, the intersection of edge J with G O H LI I is contained in G, and the intersection of each of edges L and M with G O H LI I is contained in I. However, {L, M} is not a closed set of edges, if nodes x and y are present, as drawn in Figure <ref type="figure" target="#fig_2">5</ref>. For, the intersection of edge I with L t.J M is contained in neither L nor M. Note that every closed set of (full) edges is always a nodegenerated set of partial edges. Note also that every set of edges in an ordinary undirected graph is automatically closed.</p><p>Recall that a reduced hypergraph is a-acyclic if every nontrivial, connected, nodegenerated set of partial edges has an articulation set. It follows from results of Fagin</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hypergraphs and Relational Database Schemes</head><p>FIGr.~ 6 519 et al. <ref type="bibr" target="#b20">[22]</ref> that a reduced hypergraph is ct-acyclic if and only if every nontrivial, connected, closed set of (full) edges has an articulation set. We make use of this characterization later.</p><p>A database scheme R is said to a-acyclic (respectively, a-cyclic) precisely if the corresponding hypergraph is. Every a-acyclic database scheme has a number of desirable properties, each of which is equivalent to a-acyclicity <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b6">8,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b21">23,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b30">32]</ref>. We discuss some of these properties in later sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Berge-acyclicity</head><p>We now present Berge's <ref type="bibr" target="#b8">[10]</ref>   <ref type="bibr">Berge-acyclic.</ref> As an example, the hypergraph of Figure <ref type="figure">6</ref> is Berge-cyclic, because it contains the Berge cycle (ABC, C, BCD, B, AB...C), where, for clarity, the edges are underlined. We see from this example that if some pair of edges of a hypergraph have two or more nodes in common, then the hypergraph is Berge-cyclic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">fl-acyclicity</head><p>In this section we give various defmitions for another degree of acyclicity, called fl-acyclicity. We show that the definitions are equivalent. One of these definitions says that a hypergraph R is fl-acyclic if and only if every subhypergraph of R is ct-acyclic (if S ___ R is a subset, not necessarily proper, of the edges R, then S is a subhypergraph of R.) Thus, although the hypergraph in Figure <ref type="figure" target="#fig_8">3</ref> is a-aeyclic, it is not fl-acyclic, because the subhypergraph in Figure <ref type="figure" target="#fig_1">4</ref> is a-cychc.</p><p>Because of this characterization of fl-acyclic hypergraphs, and because of the importance of a-acyclic database schemes <ref type="bibr" target="#b2">[4,</ref><ref type="bibr" target="#b5">7,</ref><ref type="bibr" target="#b6">8,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b21">23,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b27">29,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b36">38]</ref>, it follows that fl-acyclic database schemes are also important. For it is very natural to deal with subschemes of a relational database scheme. Thus a database scheme is fl-acyclic if and only if every subscheme is o~-acyclic.</p><p>Properties of a-acyclic schemes "relativize" to fl-acyclic schemes, as we mentioned in the introduction. Thus, if ~ is one of the various desirable properties of database schemes that is equivalent to e~-acyclicity, then a database scheme is fl-acyelic if and only if every one of its subschemes enjoys property ~. It is informative to give an example.</p><p>A database scheme is a-acyclic if and only if there is a semijoin program that can assist a user who is interested in taking a join over all of the relations in the database.</p><p>By "assist a user" we mean that the semijom program converts the original database into a (globally) consistent database (for details and definitions, see <ref type="bibr" target="#b6">[8]</ref> or <ref type="bibr" target="#b9">[11]</ref>). pair. Furthermore, if m = 3, then we assume also that $1 t3 $2 tq $3 is empty. If m _ 4, then the comparable assumption (i.e., the assumption that S~ 13 ... N Sm is empty) is unnecessary, since it is a consequence of our other assumptions. A pure cycle with seven edges appears in Figure <ref type="figure">7</ref>, where two edges have nonempty intersection if and only if they are shown to intersect in Figure <ref type="figure">7</ref>. Of the types of cycles for hypergraphs which we discuss in this paper, a pure cycle is certainly the most natural and noncontroversial. (However, Kahn et al. <ref type="bibr" target="#b28">[30]</ref> have defined several notions of acyclicity for hypergraphs for which a pure cycle may be an acyclic hypergraph!) A B-cycle in a hypergraph ~ is a sequence (S~, ..., Sin, S,,,+1) of edges such that if X = S~ 13 .--13 Sin, and S,' is the set difference S, -X (1 _ i _ m), then (Si ..... S~, S~,+~) is a pure cycle. Thus every B-cycle is of the form (Si t.J X, .... S~ t.J X, S~+~ O X), where (Si ..... S~, S~+~) is a pure cycle. S: need not be an edge of the hypergraph, although S~ is (1 _&lt; i _ m + 1). Of course, every pure cycle of edges is also a B-cycle.</p><p>We are now ready to give our first three definitions of fl-cyclicity (we shall give five definitions altogether).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A hypergraph is B-cyclic if it has a B-cycle.</head><p>A hypergraph is B-cyclic if some subhypergraph is a-cyclic. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>of edges has no</head><p>A hypergraph is B-cyclic if some nontrivial, connected, reduced set articulation set.</p><p>In Definition 3 we can replace "nontrivial, connected, reduced set of edges" (which means "connected, reduced set of at least two edges") by "connected, reduced set of at least three edges" and get an equivalent def'mition. This is because every connected, Hypergraphs and Relational Database Schemes $1</p><formula xml:id="formula_1">$3 FIGURE 8</formula><p>521 reduced set of two edges clearly has an articulation set. Further, if we work only with reduced hypergraphs, as is often the case, then we can drop the word "reduced" in Definition 3. Now a hypergraph is a-cyclic precisely if some nontrivial, connected, reduced, closed set of edges has no articulation set (this statement follows immediately from results in <ref type="bibr" target="#b20">[22]</ref>). Note that the only difference between this characterization of a-cyclicity and the characterization of B-cyclicity in Definition 3 is that in Definition 3 the word "closed" does not appear. Thus B-cyclicity may be considered a more natural graph-theoretic concept than a-cyclicity, since the somewhat arbitrary concept of closedness is dropped. Further, a hypergraph is a-cyclic precisely if some nontrivial, connected, node-generated set of partial edges has no articulation set. This characterization of a-cyclicity is identical to the characterization of fl-cyclicity in Definition 3, except that Definition 3 deals with "reduced sets of edges" rather than with the more complex "node-generated sets of partial edges."</p><p>Our next definition of fl-cyclicity is given to provide an analogy with Bergeacyclicity and with two of our definitions of 3,-cyclicity (Section 5 (iii) m ~ 3, that is, there are at least 3 edges involved; and (iv) x, is in S~ and S,+~ (1 &lt;__ i ___ m) and in no other Sj.</p><p>It is sometimes convenient to refer to the sequence (S~,..., Sin, Sin+l) of edges alone of a weak B-cycle as a weak B-cycle. Under this notation, every B-cycle is clearly a weak B-cycle, but the converse is false, as we shall see. However, it is not hard to see that the shortest weak B-cycle in a hypergraph is a B-cycle (we shall prove a stronger result in the proof of Theorem 4.1). Note that if we change "Y' everywhere in (iii) to "2" and drop "and in no other Sj" in (iv), then we get the definition of a Berge cycle.</p><p>The sequence (St, xt, $2, x2, Sa, x3, $4, x4, $1) in Figure <ref type="figure">8</ref> is a weak B-cycle. However, it is not a B-cycle, because the node y is in S~, $3, and $4 but not in $2. Our final definition of fl-cyclicity is essentially due to Graham <ref type="bibr" target="#b24">[26]</ref>. Let (St, ..., S,n, Sm+~) be a sequence of edges, where $1, ..., Sm are distinct and S,~Ã·1 = St. Assume further that m &gt;_ 3 (i.e., that at least three edges are involved). Define &amp; --S, N Si+~ (1 ___ i _ m). We say that (S~ ..... Sin, Sin+l) is a Graham cycle if each A, is nonempty (1 _ i _.&lt; m) and whenever i ~ j, then A, and Aj are incomparable (i.e., A, ~ Aj and Aj ~ A,). Graham calls a hypergraph CAG-C if it has no Graham cycle. RONALD FAGIN PROOF. We show that (3) m (2) =* (3) =~ (4) =, (5) =* (1) =, <ref type="bibr" target="#b1">(3)</ref>. By "(i) =, (j)" we mean that every hypergraph that is fl-cyclic by definition (i) is fl-cyclic by definition (j).</p><p>(3) =, (2): Let ,~Wbe fl-cyclic by Definition 3. By Defmition 3, g h a s a nontrivial, connected, reduced set E of edges with no articulation set. Then E is an a-cyclic hypergraph, since the set E of edges is a node-generated set of partial edges in the hypergraph E. Hence oW is fl.cyclic by Defmition 2.</p><p>(2) =* (3): Let g be a fl-cyclic hypergraph by Det'mition 2; we shall show that it is fl-cyclic by Definition 3. By Definition 2, g has a subhypergraph ~,~ that is a-cyclic. Let ,~' be the reduction of ~. Then ~' is a reduced, a-cyclic subhypergraph of .,W (recall that a hypergraph is a-cyclic precisely if its reduction is). Thus ,~r, has a nontrivial, connected set E of edges with no articulation set (the set E is also closed in ~", although we do not need this fact). Clearly E is reduced, since ~-' is. Hence, ,YF is fl-cyclic, by Definition 3.</p><p>(3) =* (4): Let . g be fl-cyclic by Definition 3; we shall show that it is fl-cyclic by Definition 4. Since g is fl-cyclic by Definition 3, it has a connected, reduced set E of at least three edges and with no articulation set. (See the comment following Definition 3.) Find two distinct edges V and W in E such that the number of nodes in VN Wis as big as possible. Since E is connected, we know that some pair of edges in E has nonempty intersection, and so V and W also have nonempty intersection. Let us denote V f3 W by Q. We know that Q is a proper subset of each of V and W, because E is reduced. Since E has no articulation set, we know that the result of removing Q from every edge in E leaves a connected set of partial edges. Hence there is a sequence ($1 . . . . , Sk) of distinct edges in E for which</p><formula xml:id="formula_2">(i) &amp; = g, 0i) sk= w, ('fii) (S, f) S~+1) -Q is nonempty for 1 ___ i &lt; k.</formula><p>Let us choose the sequence ($1 . . . . . Sk) as above so that k is as small as possible.</p><p>Since (S, VI S,Ã·a) -Q is nonempty by (iii), it contains a node x, (1 &lt;_ i &lt; k). I f j is not i or i + 1, then x, is not in Sj; otherwise the sequence ($1 . . . . . Sk) could be shortened and still maintain properties (i)-(iii) above, and this would violate minimality of k. Hence, if we can t'md m with 3 _&lt; m _ k (and so, in particular, 3 -k) such that Sa and Sm contain a node v that is not in Sj for 1 &lt; j &lt; m, then ($1, xl, $2, x2 . . . . . $=, v, $1) is a weak r-cycle (where we are using the edge-node-edge notation for clarity), and we are done.</p><formula xml:id="formula_3">Now Q ~ $1 N $2. For if Q _ S~ vI $2, then $1 V) $2</formula><p>would have strictly more nodes than Q, since ($1 N S2) -Q is nonempty by (iii) above. However, this would contradict the maximality of Q (recall that V and W were chosen in E such that Q = V N I4 / is as big as possible).</p><p>Since ~ ~ S~ ~ $2, let v be a node in Q that is not in S~ f') S~. Now v ~ S~ (since ~ V = 81). Hence, since v ~ $1 N $2, it follows that v ~ $2. Let m be minimal such that 3 _&lt; m ~ k and v ~ $,,,. There is such an m, since v ~ Sk (because v ~ Q ~ W = Sk). Then $1 and S,~ contain the node v, which is not in S~ for 1 &lt; j &lt; m. This was to be shown. (5) =m (1): Let .gbe fl-cyclic by Definition 5; we shall show that it is fl-cyclic by Definition 1, Lot 6e = (S~, .... Sm, Sm+~) be a minimal Graham cycle, that is, a Graham oyele with m, the number of edges in the Graham cycle, as small as possible. We shall show that 6 a is a fl-cycle, which shows that .g is fl-cyclic by Definition 1. Let X = S~ t3 ... N Sin, and let S' be the set difference S= -X (1 _&lt; i _&lt; m). We must show that S~' -" (S~ ..... S', S~,+x) is a pure cycleâ¢ Let 4~ (respectively, 4/) be S, fl S,+a (respectively, S[ tq S~+O, for 1 _ i _&lt; m. Each 4[ (1 z; i -&lt; m) is nonempty. For if 4; were empty, then 4, _ 4j for each j, and in particular, for some j # i; this contradicts our assumption that 6a is a Graham cycle.</p><p>We have shown that each pair of neighbors in 6e' is nondisjoint (since each A[ is nonompty), By construction we know that S~ tq ... tq S~, is empty. To show that 6P' is a pure cycle, we need only show now that nonneighbors are disjoint. Assume not; we shall derive a contradictionâ¢ Let S~ and S~ be nonneighbors that are nondisjoint. Take a node v in S~ tq Sq. By construction of ~', we know that v~ S', for some r. By interchanging the roles of S~ and S~, if necessary, we can assume that proceeding "clockwise" on 6 a' from S~ to S~, we encounter S~ on the way. (The "clockwise" direction is from St to S~ to .. to Sg to S' ..</p><p>â¢ 1 to . .) Consider the following conditions on a pair (s, j) of indices:</p><p>(a) S' and S; are distinct and nonneighbors, and (b) there is a node w in S'~ N Sj that is not in some S;~ that lies on the clockwise path from S; to Sj.</p><p>These conditions can be fulfilled by letting w, s, j, and k be, respectively, v, p, q, and r. Select s and j such that (a) and (b) are satisfied, and such that the clockwise path from S; to S; is as short as possibleâ¢ By doing a cyclic shift of the subscripts, if necessary, we can assume that s = 1. Thus, 1 &lt; j &lt; m, and the node w ~ St 17 Sj, but w ~ S~ for some k, with 1 &lt; k &lt; j. Also, j --&gt; 3, since S1 and S; are not neighbors. We now show that for each p with i &lt; p &lt; j, necessarily w Â¢~ S~. For, assume w ~ S~ and 1 &lt; p &lt; j. There are two cases, depending on whether p &lt; k or k &lt; p, Assume p &lt; k; the other case is similar. Then there is a node (namely, w) in S~, and S; but not in S~, and also S~ is on the clockwise path from S~, to S; (see Figure <ref type="figure">9</ref>). Since the clockwise path from S~ to Sj is shorter than the clockwise path from S~ to $;, this contradicts our minimality assumption in the choice of s and j. Hence w ~ S~ whenever 1 &lt; p &lt; j. We now show that (s~ ..... s,, $1) (4.1) is a Graham cycle. Let A, and A; be as before (1 _ i &lt; j), let A be S~ N $1, and let A' be S~ N S~. We already know that A, and Aj are pairwise incomparable when i # j, since ($1 ..... Sin, SO is a Graham cycle and j &lt; m. Further, A and each A, are nonempty. Hence, to show that (4.1) is a Graham cycle, we need only show that A is incomparable with each of the A,'s. Now A contains w, which is not in any of the 4,'s, Thus, A ~ 4, (1 ___ i &lt; j). So, to show that (4.1) is a Graham cycle, we need only show that A, g: A (1 _&lt; i &lt; j). Assume not; we shah derive a contradiction. Find n (1 _ n ~:j) such that 4,= __C A. Therefore, since 4~ = 4, -Xand A' = A --X, it follows that a" __q A'.</p><formula xml:id="formula_4">(4.2) FIGURE 9 \ \ S~ \ \ \ sp 1 / i I s'./ / / / / / Sj Sj -</formula><p>FIGtrV.E 10</p><p>Let x be an arbitrary member of A'. By (4.2), we know that x ~ A'. We now show that</p><p>x E S[</p><formula xml:id="formula_5">for 1 5 i ~ j. (4.3)</formula><p>Assume not. Find t (1 &lt;_ t _ j) such that x ~ St. Since x ~ A" and x E /v, we know that t is not any of 1, n, n + 1, or j. There are now two cases, depending on whether t &lt; n or n + 1 &lt; t. Assume t &lt; n; the other case is similar. Then (see Figure <ref type="figure">10</ref>) (a) S~ and S" are distinct and normeighbors, and (b) node x is in S~ N S" but not in Sh and St lies on the clockwise path from S~ to S~.</p><p>But the clockwise path from S~ to S~ is strictly shorter than the clockwise path from Si to Sj. This contradicts our minimality assumption in our choice of s and j. This proves (4.3). Since S[ C_ S,, it follows from (4.3) that x E S,, for 1 _&lt; i _ j. Therefore,</p><p>x ~ A, (1 _&lt; i &lt; j). But x was an arbitrary member of A~. Hence, A~ _ Ai (1 _&lt; i &lt; j). Thus, A,, __C_ A, (1 &lt;_ i &lt; j), since the only nodes in A,~ that are not in A" are the nodes X that are in every S,. Let a be arbitrary such that 1 _&lt; a &lt; j and a # n. There is such an a, since j &gt; 3. Since A. C_ Aa, this contradicts the fact that the A,'s are pairwise incomparable. This contradiction establishes our claim that (4.1) is a Graham cycle. But (4.1) is a shorter Graham cycle than our allegedly smallest Graham cycle (Sx ..... Sin, SO. This contradiction shows that the smallest Graham cycle is indeed a/8-cycle, which was to be shown. (As a matter of interest, we note that although the smallest Graham cycle is always a fl-cycle, there may be a Graham cycle that is not even a weak/3-cycle.)</p><p>(1) =* (3): Let ~ be /8-cyclic by Definition 1. Therefore, it has a fl-cycle (Sa ..... S,,, Sin+0, where m &gt;_ 3. The set ($1 ..... Sin) of edges is clearly a nontrivial, connected, reduced set of edges with no articulation set. So .~ is/~-cyclic by Definition 3. [] We note that recently Graham <ref type="bibr" target="#b25">[27]</ref> has independently shown the equivalence of Definitions 2 and 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">y-acyclicity</head><p>As in the case offl-cyclicity, we shall give several equivalent definitions of ~,-cyclicity.</p><p>A hypergraph is y-acyclic if it is not y-cyclic. A database scheme is ,/-acyclic (respectively, y-cyclic) precisely if the corresponding hypergraph is.  (iii) m --&gt; 3, that is, there are at least 3 edges involved; (iv) x~ is in S, and S,+~ (1 _ i _ m); and (v) if 1 _ i &lt; m, then x, is in no Sj except S, and S,+1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A W-cycle</head><p>Note that the only difference between a y-cycle and a weak fl-cycle is that "1 _&lt; i &lt; m" in (v) is replaced by "1 &lt;_ i _&lt; m" to define a weak B-cycle. Thus every weak fl-cycle is a y-cycle. Note also that the only difference between a ,/-cycle and a Bergecycle is that to define a Berge cycle, "3" is replaced everywhere in (iii) by "2," and also (v) is dropped. As before, it is sometimes convenient to refer to the sequence ($1 . . . . . Sin, Sin+0 of edges alone of a y-cycle as a y-cycle. We say that this T-cycle, with m distinct edges, is of size m.</p><formula xml:id="formula_6">Definition 1. A hypergraph is `/-cyclic if it has a V-cycle.</formula><p>We define a weak y-cycle just as we defined a y-cycle, except that "1 _&lt; i &lt; m" in (v) is replaced by "i ---1 or i = 2" to define a weak y-cycle. Thus every T-cycle is a weak T-cycle. Although the converse is false, it is true that the shortest weak y-cycle in a hypergraph is a y-cycle (we shall prove a stronger result in the proof of Theorem 5.1 below). It is easy to see that a hypergraph is V-cyclic according to Definition 3 precisely if it contains at least one of two kinds of "forbidden configurations" of edges: either a pure cycle, as in Figure <ref type="figure">7</ref>, or a set of three edges that intersect at least as shown as in Figure <ref type="figure">11</ref>. (By the latter, we mean that in Figure <ref type="figure">11</ref> there is at least one node in E tq F N G, there is at least one node in (E tq G) -F, and there is at least one node in (F N G) -E. Other intersections involving combinations of E, F, and G may also occur.) For, if there is a y-cycle of size 3, then either there is a configuration as in Figure <ref type="figure">11</ref> or else there is a pure cycle of size 3.</p><p>Our next def'mition (Definition 4) of y-cyclicity is due to Goodman and Shmueli <ref type="bibr" target="#b22">[24]</ref>, who, after reading an early draft of this paper, pointed out to the author that Definition 4 is equivalent to the author's Definitions 1-3. There is a pretty algorithm (defined in <ref type="bibr" target="#b16">[18]</ref>) for determining T-acyclicity. It is very similar in flavor to "Graham's algorithm" for determining ~t-acyclicity. Both of these algorithms will be presented in Section 9. THEOREM 5.1. Definitions 1-4 of y-cyclicity are equivalent.</p><p>PROOF. We show that (1) =* (2) =* (3) =* (4) =* (1). By "(i) ~=~ (j)", we mean that every hypergraph that is y-cyclic by definition (i) is y-cyclic by definition (j).</p><p>(1) =* (2): This is immediate, since, as noted, every T-cycle is a weak y-cycle.</p><p>(2) =* (3): Let .Y~be T-cyclic by Definition 2; we shall show that .YtÂ°is y-cyclic by Definition 3. Let (5.1) above be a minimal weak T-cycle in .Y~ (by minimal we mean that m is as small as possible). If m ffi 3, then we are done (since a weak T-cycle of size 3 is clearly a T-cycle of size 3). So, assume that m &gt;-4. We shall show that (5. l) is a pure cycle. We already know that neighbors intersect, so we need only show that nonneighbors do not intersect.</p><p>We now show that $1 does not intersect a nonneighbor. Assume it does. Find k (3 &lt;_ k &lt; m) as small as possible so that $1 t3 Sk # @. Take v in S~ f3 Sk. Then (S~, xl . . . . . Sk-~, xk-1, Sk, v, Sx) is a smaller weak y-cycle than (5. 0. This is a contradiction.</p><p>We now show that $2 does not intersect a nonneighbor. For, assume that v E $2 f3 Sk, with 4 _&lt; k _&lt; m. There are now two cases.</p><p>Case I. v E So. We know that v ~ $1, since $1 does not intersect its nonneighbor $3. Find r as big as possible so that v E S,. It is then easy to see that ($1, x~, $2, v, S,, x . . . . . . Sin, Xm, St) is a smaller weak T-cycle than (5.1). This is a contradiction.</p><p>Case 2. v ~ $3. Find r as small as possible so that v ~ S,. It is then easy to see that (S,, v, $2, x2, $3, xa . . . . , S,) is a smaller weak V-cycle than (5.1). This is a contradiction.</p><p>We have shown that neither S~ nor S~ intersects a non.neighbor. Find j as small as possible so that S~ intersects a nonneighbor Sk; say v E $1 N Sk. Then 3 &lt;_ j, and j + 2 _&lt; k _&lt; m. It is easy to see that ($1, xx, $2, x2 . . . . . Sj, v, S~ . . . . . Sm+~) is a smaller weak T-cycle than (5.1). This contradiction completes the proof of (2) =* (3). Let us also assume that we have selected the S,'s so that (i)-(iii) above hold and m is as small as possible. If m = 2, then $2 = F by (ii), and so $1 n $2 --Q, which contradicts (iii) when i = 1. Hence m _&gt; 3. By (iii), we can find a node x, in (S~ n S~+1) -Q, for 1 _&lt; i ___ m -1. Define also Sm+l to be E (=St), and def'me xm to be a node in E n F (by assumption, E n F is nonempty). We now show that (S~, x~, $2, x2 . . . . . S=, xm, S,~+t) is a 7-cycle. The node xt is not in any of $3 . . . . . S,~-~, by minimality of m (thus, if xx E S,, where 3 _ i --&lt; m --1, then the sequence $1, S,, S,+~, . . . , Sm could be used in place of S1, $2, . . . , S~). Further, Later we shall identify some desirable properties of database schemes, involving monotone-increasing joins and unique relationships among attributes, such that each of these properties is equivalent to ~,-acyclicity.</p><formula xml:id="formula_7">x~ ~ Sm= F, since xa E E = $1 but xl ~ Q -E n F. So</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Relationships Among the Various Degrees of Acyclicity</head><p>We begin by proving the following simple theorem. Tm~OREM 6.1. Berge-acyclicity =* "[-acyclicity ==} fl-acyclicity =~, a-acyclicity. None of the reverse implications hold.</p><p>PROOF. Every a-cyclic hypergraph is fl-cyclic, since a hypergraph is fl-cyclic if and only if some subhypergraph (including the whole hypergraph itself) is a-cyclic. Also, it is clear from our definitions that every weak fl-cycle is a y-cycle and every 7-cycle is a Berge cycle. It follows that Berge-acyclicity =~ 7-acyclicity fl-acyclicity ~ a-acyclicity.</p><p>We now show that none of the reverse implications hold. The hypergraph of Figure <ref type="figure" target="#fig_8">3</ref>, with edges ABC, CDE, EFA, and ACE, is a-acyclic but fl-eycliÂ¢ (since the subhypergraph of Figure <ref type="figure" target="#fig_1">4</ref>, with edges ABC, CDE, and EFA, is a-cyclic). The hypergraph of Figure <ref type="figure" target="#fig_16">12</ref>, with edges AB, AC, and ABC, is fl-aeyclic. However, it is "t-cyclic, since (A__if_C, C, ABC, B, A__i f _B, A, A_.~C) is a V-cycle, where, for clarity, the edges are underlined. The hypergraph of Figure <ref type="figure" target="#fig_6">2</ref> is a reduced hypergraph that is fl-acyclic but y-cyclic.</p><p>Finally, the hypergraph of Figure <ref type="figure">6</ref>, with edges ABC and BCD, is -~-acyclic.</p><p>However, as we noted in Section 3, it is Berge-cyclic. [] We note that Zaniolo <ref type="bibr" target="#b39">[41]</ref> defined two other notions of acyclicity for hypergraphs, in a pioneering effort to find some hypergraph condition that is equivalent to a certain desirable database condition ("every pairwise consistent database is consistent"; see <ref type="bibr">Section 7)</ref>. Unfortunately, one of his conditions was sufficient but not necessary, and the other was necessary but not sufficient. Neither of his conditions is equivalent to any of our degrees of acyclicity. We also note that Batini et al. <ref type="bibr" target="#b4">[6]</ref> discuss the issue of generating various subclasses of a-acyclic hypergraphs by "hypergraph grammars." Further, Kahn et al. <ref type="bibr" target="#b28">[30]</ref> have defined several notions of acyclicity for hypergraphs by generalizing various properties of acyclic graphs.</p><p>We now discuss the naturalness of the various degrees of acyclicity, and then we make a few observations contrasting their features.</p><p>Berge-acyclicity is too restrictive an assumption to make about database schemes. For, if some pair of distinct relation schemes R,, R+ in the database scheme R = {R1 . . . . . Rn} have more than one attribute in common, then R is Berge-cyclic. For example, the hypergraph of Figure <ref type="figure">6</ref>, with edges ABC and BCD, is Berge-cyclic, as we noted earlier. A restriction that no two relation schemes can have more than one attribute in common is far too severe. We now show that there are "natural" database schemes that are a-acyclic but ~8-cyclic, and natural schemes that are ~8-acyclic but ~,-cychc.</p><p>Assume that there are six attributes SUPPLIER, PART, PROJECT, COUNT, DATE, and COST, where SUPPLIERs supply PARTs to PROJECTs; where for each PART and PROJECT, the COUNT tells how many of that PART have been supplied to that PROJECT; where the DATE tells when a given supplier first supplied a given PROJECT; and where the COST is what a given SUPPLIER charges for a given PART. The only constraints are the functional dependencies <ref type="bibr" target="#b13">[15]</ref> {PART, PROJECT} ~ COUNT, {SUPPLIER, PROJECT} --~ DATE, {SUPPLIER, PART} ~ COST, (and their logical consequences). The functional dependency {SUPPLIER, PART} COST says that there is only one COST that a given SUPPLIER charges for a given PART; the SUPPLIER does not, for example, charge different PROJECTs different COSTs for the same PART. By doing a standard decomposition to obtain Boyce-Codd normal form <ref type="bibr" target="#b14">[16]</ref>, the resulting database scheme has four relation schemes, with attributes, respectively, {SUPPLIER, PART, PROJECT), {SUPPLIER, PART, PROJECT}, {SUPPLIER, PART, COST}, {PART, PROJECT, COUNT}, {SUPPLIER, PROJECT, DATE}.</p><p>The hypergraph of this scheme is as in Figure <ref type="figure" target="#fig_9">13</ref>. But this is just an example of the hypergraph of Figure <ref type="figure" target="#fig_6">2</ref>, which is a-acyclic but/~-cyclic. To obtain a scheme that is fl-acyclic but ,/-cyclic, we simply drop the COUNT attribute (and the {PART, PROJECT, COUNT) relation scheme) to obtain the hypergraph of Although there are natural database schemes that are "y-cyclic (such as the example just shown), there are also a number of database schemes that are .y-acyclic. (An example appears later in this section, with a demonstration of-y-acyclicity.) Although we should not demand ~,-acyclicity, it is good to know when a given scheme is y-acyclic, so that we know that it enjoys the desirable properties discussed in Section 8. Similar comments apply, of course, to/%acyclicity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIGURE 13 529</head><p>As observed in other papers, it is natural to demand a-acyclicity; indeed, Fagin et al. <ref type="bibr" target="#b20">[22]</ref> and Maier and Ullman <ref type="bibr" target="#b30">[32]</ref> argue that a-cyclic schemes represent a possible error in database design. In Section 8 we shall discuss an example of an a-cyclic scheme (which is given in Figure <ref type="figure" target="#fig_12">20</ref>) and its "conversion" (by renaming attributes) into a scheme (given in Figure <ref type="figure" target="#fig_16">21</ref>) that is not only a-acyclic but even 7-aeyclic.</p><p>We now contrast some of the features of the various degrees of acyclicity. The proofs of the remarks we now make are straightforward and are left to the reader.</p><p>A hypergraph is a-acyclic if and only if its reduction is a-acyclie. However, the analogous statement is false for the other kinds of acyclicity. Thus, the hypergraph of Figure <ref type="figure" target="#fig_15">14</ref> (with edges AB, BC, AC, and ABC) is fl-cyclic, y-cyclic, and Bergecyclic, although its reduction (which consists of the single edge ABC) is of course acyclic in each of the four senses.</p><p>By an isolated node we mean as before a node that is in exactly one edge. If .~ is a hypergraph and .Â¢t ~' is the result of deleting an isolated node, then .~ is 0-acyclic if and only if ~e, is 0-acyclic, for 0 = c~, fl, or 7. Although it seems as though the same statement should be true for # --Berge, there is a subtlety that prevents this. Let be the Berge-cyclic hypergraph of Figure <ref type="figure">6</ref>, with edges ABC and BCD. The result of deleting the isolated nodes A and D is to leave us with two edges, both BC. Since a hypergraph is a set of edges (in which there are no duplicates), the resulting hypergraph has only one edge BC and is therefore Berge-acycliÂ¢. However, the original hypergraph ~ was Berge-cyclic.</p><p>By a singleton edge we mean an edge with exactly one node, which may or may not be isolated. By a global node we mean a node that is in every edge. If A~' is the result of deleting a singleton edge, then .,~ is 0-acyclic if and only if ~' is 0-acydic, for 0 = a, fl, Y, or Berge. If ~' is the result of deleting a global node, then .~ is 0-acyclic if and only if .,~' is 0-acyclic, for 0 = a or/3. The statement is false if 0 ---7 or Berge. Thus the hypergraph of Figure <ref type="figure" target="#fig_16">12</ref> with edges AB, A C, and ABC, is Bergecyclic and y-cyclic. However, the hypergraph of Figure <ref type="figure" target="#fig_2">15</ref>, which has edges B, C, and BC and is the result of deleting the global node A, is acyclic in each of the four senses.</p><p>We say that two nodes are edge-equivalent if they are in precisely the same edges. We shall deal extensively with edge-equivalence in Section 9, where we discuss a polynomial-time algorithm for determining 7-acyclicity. If ~,~' is the result of deleting a node that is edge-equivalent to another node, then .~ is 0-acyelic if and only if ~' is 0-acyclic, for 0 = a, fl, or 7. The statement is false if 0 =-Berge. Thus the F:GURE 14 F:otrg~ 15 FIGURE <ref type="figure">16</ref> hypergraph of Figure <ref type="figure">6</ref>, with edges ABC and BCD, is Berge-cyclic; however, the hypergraph of Figure <ref type="figure">16</ref>, which is the result of deleting node C (which is edgeequivalent to B), is Berge-acyclic.</p><p>We have just discussed various transformations of hypergraphs and considered whether or not the transformation preserves both O-acyclicity and 0-cyclicity. That is, we were concerned with the question of whether a hypergraph ~ is 0-acyclic if and only if its transform .,~' is 0-acyclic. Less restrictively, we might also consider whether or not certain transformations preserve 0-acyclicity (and not be concerned with whether the transformation preserves 0-cyclicity). As an important example, we say that a hypergraph ~' is the result of uniformly deleting nodes from .~if there is a set X of nodes of .,~ such that the edges of .~' are precisely {E -X: E is an edge of ~'~}. We note that Goodman and Shmueli <ref type="bibr" target="#b21">[23]</ref> characterize a-acyclicity in terms of this concept. If ~' is the result of uniformly deleting nodes from ~, and ,~ is 0-acyclic, then so is ~', for 0 = a, fl, or y. By the same example as we used in discussing the result of deleting isolated nodes, the statement is false for 0 --Berge.</p><p>It is easy to see that the result of uniformly deleting nodes from a 0-cyclic hypergraph may be 0-acyclic, for any 0. (For example, every node can be deleted, which leaves the empty hypergraph, a 0-acyclic hypergraph for every 0.) Another distinction among the various degrees of acyclicity is, as we observed earlier, that a subhypergraph of an a-acyclic hypergraph may be a-cyclic. However, each subhypergraph of a 0-acyclic hypergraph is 0-acyclic, for 0 = fl, y, or Berge.</p><p>As we noted earlier, an ordinary undirected graph is acyclic in the usual sense if and only if it is 0-acyclic when viewed as a hypergraph, for 0 = a, fl, y, or Berge. Thus, each of these four concepts of 0-acyclicity is a generalization, from graphs to hypergraphs, of the usual concept of acyclicity.</p><p>We close this section by considering the industrial database scheme of <ref type="bibr" target="#b17">[19]</ref> and showing that it is y-acyclic. There are six relation schemes, with attributes, respectively, {SUPPLIER, PART, PROJECT}, {SUPPLIER, PART, COST}, {EMPLOYEE, SALARY, HIREDATE}, {EMPLOYEE, PROJECT}, {PROJECT, MANAGER}, {SUPPLIER, LOCATION}. The semantics of this database scheme is explained in <ref type="bibr" target="#b17">[19]</ref>. The hypergraph is that of Figure <ref type="figure">17</ref>. It is easy to verify that by iteratively applying the rules that an isolated node or a singleton edge can be removed (without affecting y-acyclicity), we are left the empty set. Thus, by the rules of this section, we see that the hypergraph in Figure <ref type="figure">17</ref> is y-acyclic. (In Section 9 we shall give a general polynomial-time algorithm for deciding y-acyclicity.) However, note that this hypergraph is Berge-cyclic, because</p><note type="other">FIGURE 17 531 FIGURE 18</note><p>two edges (SUPPLIER, PART, PROJECT} and (SUPPLIER, PART, COST} share two nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Join Expressions</head><p>Consider the following scenario. A user desires to take the join of four relations rl, r2, r3, and r4. The following might happen. He might first form rl t~ r2, which might have, say, a thousand tuples. Then he might join the result with r3, to obtain rl t~ r2 t~ ,'3, a relation with, say, a million tuples. He might trmally join the result with r4, to obtain his desired answer rl ~ r2 t~ ra t~ r4, which might have only ten tuples. Thus, even though the result he was seeking had only ten tuples, he might have had an intermediate result with a million tuples. In this section we discuss "monotone join expressions," which prevent this unpleasant behavior. We first def'me the important concept of consistency.</p><p>Let r and s be relations, with attributes R and S, respectively. We say that r and s are consistent <ref type="bibr" target="#b6">[8]</ref> if r[R tq S] = sir N S], that is, if the projections of r and s onto their common attributes are the same.</p><p>Let r = {ri ..... rn} be an arbitrary database over R = (R1 ..... R,}. We say that r is pairwise consistent if r, and rj are consistent for each i and j. We say that r is globally consistent (or simply consistent) if there is a relation r over attributes ./ff = R1 L) ... URn such that r~[R,] = r[R,] for each i. Thus r is consistent if there is a "universal relation" r such that each r, is a projection of r.</p><p>It is clear that if r is consistent, then it is pairwise consistent. If n = 2, that is, ff only two relations are involved, then it is easy to see that the converse is true. However, in general, the converse is false. For example, let rl, r2, and ra be the three relations in Figure <ref type="figure">18</ref>, over attributes AB, BC, and AC, respectively. It is easy to verify that these relations are pairwise consistent but not consistent. Beeri et al. <ref type="bibr" target="#b6">[8]</ref> prove that if the database scheme is a-acyclic, then every pairwise consistent database is consistent.</p><p>A join expression is a well-formed expression formed out of relation schemes, the symbol t~, and parentheses, in which every join is binary. For example, if R1, R2, R3, and R4 are among the relation schemes, then ((R2 t~ Ra) t~ (R~ t~ R4)) is a join expression, which corresponds to joining the R2 and the R3 relations, joining the R1 and/~ relations, and then joining together the two results.</p><p>Certain join expressions, called sequential join expressions, are of special interest. Let O be a join expression over R. If0 is of the form (... ((R1 ~ R~) ~ Ra) ... t~ R,J, where R1 ..... Rn is an ordering of the distinct members of R, then we say that 0 is sequential. Intuitively, a sequential join expression (... ((R~ t~ R2) t~ Ra) ... t~ R,,) corresponds to first joining the R1 and the R2 relations, then joining the result with the R3 relation, then joining the result with the R4 relation, and so on.</p><p>Let 0 be a join expression whose relation schemes are all in R, and let r be a database over R. By 0(r), we mean the relation that results by replacing each relation scheme R in 0 by r, where r E r and r has attributes R. For example, ff r ffi {r~, r2, r3, &amp;} and 0 is the join expression (R2 t~ (R3 I~ R2)), where !"2 and ra have attributes R2 and R~, respectively, then 0(r) is the relation (r~ t~ (ra t~ r2)), that is, the relation r2 t~ ra.</p><p>A subexpression of a join expression is defined in the usual way. Let 0 be a join expression containing relation schemes R, and let r be a database over R, We say that 0 is monotone with respect to r if for every subexpression (01 t~ 02) of 0, the relations 01(r) and 02(r) are consistent. Intuitively, 0 is monotone with respect to r if no tuples are lost in taking any of the binary joins obtained by "executing" 0(r) as dictated by the parentheses. (We say that no tuples are lost in taking the join of relations r and s if r and s are each projections of r t~ s, i.e., if r and s are consistent.) As an example, ((R2 t~ R3) t~ (Ra t~ R4)) is monotone with respect to r ffi (rl, r2,/'3, r4}, where r, has attributes R, (1 _&lt; i ___ 4), if (a) r2 and ra are consistent, (b) rx and r4 are consistent, and (c) (r2 t~ ra) and (&amp; t~ 1"4) are consistent.</p><p>We say that 0 is monotone if it is monotone with respect to every pairwise consistent database over R. If 0 involves precisely the relation schemes R, then we say that R has a monotone join expression. Monotone join expressions provide an efficient (both space-efficient and time-efficient) manner for taking a join, in that no "intermediate" join has more tuples than the "fmar' join rl t~ ... t~ r,,.</p><p>Beeri et al. <ref type="bibr" target="#b6">[8]</ref> prove the following theorem.</p><p>TH~ORE~ 7.1 <ref type="bibr" target="#b6">[8]</ref>. The following are equivalent.</p><p>(1) R is a-acyclic.</p><p>(2) There is a monotone join expression over R.</p><p>(3) There is a monotone, sequential join expression over R.</p><p>Theorem 7.1(3) says that there is an ordering R1 ..... R,, of R such that if r = (rl .... , r,,} is a pairwise consistent database over R, then the join r~ ~ -.. ~ r, is consistent with r~+x (1 &lt; i &lt; n). Thus, ffwe first join rx with r2, join the result with ra, join the result with &amp;, and so on, then no tuples are lost in taking any of the joins; hence the number of tuples grows monotonically. Also, by taking the join in this manner, only one intermediate join needs to be maintained.</p><p>We say that a join expression 0 is connected ff for each of its subexpressions (01 t~ 0~), there is an attribute that appears in both 01 and 02. Intuitively, a join expression is connected ff none of the binary joins of which it is composed is actually a Cartesian product.</p><p>Let us now restrict our attention to database schemes R for which the corresponding hypergraph is connected. We close this section by showing that every monotone join expression over R is connected. In the next section we show (among other things) that R is ~,-acyclic if and only if the converse holds, that is, if and only if every connected join expression over R is monotone. THEOREM 7.2. Let R be a connected hypergraph. Then every monotone join expression over R is connected.</p><p>PROOF. Let 0 be a join expression over R that is not connected; we shall show that 0 is not monotone. Let r be a relation with attributes R1 U â¢ --t.J R,~ and with exactly two tuples: a tuple of all O's and a tuple of all l's. Let r --(rt, ..., rn} be a database over R = (R1 ..... Rn), where r, = r[Rd for each i. So, r is consistent (and hence pairwise consistent).</p><p>Since 0 is not a connected join expression, it has a subexpression 6 --01 t~ 02 such that the attributes of 01 are disjoint from the attributes of 0~. Now 01(r) and 02(r) each have at least two tuples, namely, a tuple of all O's and a tuple of all l's. Since 6(r) = 01(r) t~ 02(r) is the Cartesian product of 01(r) and 02(r), it follows that 6(r) has at least four tuples. We shall soon show that 0(r) = r. Hence, 0(r) has exactly two tuples, while 8(r) has at least four tuples. Since 8 is a subexpression of 0, it follows that 0 is not a monotone join expression, which was to be shown. Thus, we need only show that 0(r) --r. Now 0(r) = rl 1~ -.. I~ rn, since 0 is a join expression over R. So, the proof is complete once we show that r~ t~ ... t~ r,~ = r. Clearly r __C_ r~ t~ ... t~ rn, since each r, is a projection ofr. We now prove the opposite inclusion, that is, that rl ~ ... ~ rn C_ r.</p><p>(7.1)</p><p>Let u be a tuple in r~ ~ ... t~ rn; we must show that u is a tuple in r. Since u is in rl t~ ... t~ rn, we know that u</p><formula xml:id="formula_8">[R,] is in r, for 1 ___ i _ n. But ri = r[Ri], so u[R~] is in r[R~], for 1 --&lt; i ~ n.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This means that there is a tuple q~ of r such that u[R~] -~ q~[R~],</head><p>for 1 _&lt; i _&lt; n. We shall show that all of the q,'s are equal. It then follows that u equals their common value. This implies that u is in r, which proves (7.1).</p><p>So, to prove (7.1), we need only show that q~ --qj for each i and j. Since R = (R1 ..... Rn) is connected, there is a path from R~ to Rj. Therefore, to show that q, = qj, it is sufficient to show that whenever R, and Rt are nondisjoint, then q~ = qt. For then, by induction on the length of the path from R~ to Rj, we see that q~ = qj.</p><p>Assume now that/L and Rt are nondisjoint; say A E R~ f~ Rt. Then q~[A] = u[A] = qt <ref type="bibr">[A]</ref>. So q, and qt are two tuples of r that agree on an attribute, namely, A. It follows from the definition of r that q, and qt are therefore equal. This was to be shown. []</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Properties of ~,-acyclic Database Schemes</head><p>In this section we discuss several desirable properties for a relational database scheme R. Each of these properties is equivalent to the scheme R being T-acyclie. For simplicity, we restrict our attention in this section to database schemes R with a connected hypergraph. This restriction is not essential.</p><p>(1) R is y-acyclic. By this, of course, we mean that the hypergraph of the database scheme is 3,-acyclic.</p><p>(2) Every connected join expression over R Is monotone. Assume that R is connected. The equivalence of this property (call it property (2)) with -/-acyclicity is of interest because of the close analogy with Theorem 7.1. Thus, Theorem 7.1 says that R is a-aeyclic if and only if some join expression over R is monotone; the equivalence of 3,-acyclicity with property (2) (almost) says that R is y-acyclic if and only if every join expression over R is monotone. We must say "almost" in the previous sentence because we actually restrict our attention to connected join expressions. By Theorem 7,2, this is not really a restriction, since the only join expressions that can be monotone are connected. Property (2) guarantees a great deal of freedom in taking joins. Thus, let r be a pairwise consistent database over a scheme that obeys property <ref type="bibr" target="#b0">(2)</ref>. Assume that the user wishes to take a join of some subset of the relations in the database. Property (2) guarantees that he can take his join however he wishes (i.e., he can use whatever join expression he wishes that involves the right relations), and as long as he does not act "foolishly," then he is guaranteed that he is acting in an efficient manner. By "never acting foolishly" we mean that he never joins two relations together whose attributes are disjoint, that is, he never takes a Cartesian product. By "efficient" we mean, as before, that no intermediate join has more tuples than the final join. His choice of how to take the join, that is, which join expression to use, can be dictated by other performance considerations, such as the presence of indices that might speed up the process.</p><p>(3) Every connected, sequential join expression over R is monotone. Property ( <ref type="formula">3</ref>) is to property (2) as Theorem 7.1(3) is to Theorem 7.1( <ref type="formula">2</ref>).</p><p>(4) The Join dependency t~R implies that every connected subset of R has a lossless join. We say [1, 34] that a relation r with attributes R1 t.I â¢ â¢ â¢ t.J Rn obeys the join dependency t~{R1 ..... Rn} if r --t~{rl ..... rn}, where r, = r[R,], for 1 _&lt; i &lt;_ n. It follows that the join dependency ~{Rx ..... Rn} holds for the relation r if and only if r contains each tuple t for which there are tuples wl, ..., wn of r (not necessarily distinct) such that w,[R,] = t[R,] for each i (1 _&lt; i _&lt; n). As an example, the relation r in Figure <ref type="figure" target="#fig_10">19</ref> violates the join dependency t~{AB, ACD, BC}. For, let wl, w~, and w3 be, respectively, the tuples (0, 1, 0, 0), (0, 2, 3, 4), and (5, 1, 3, 0) of r; let R1, R2, and R8 be, respectively, AB, ACD, and BC; and let t be the tuple (0, 1, 3, 4); then w,[R,]</p><p>t <ref type="bibr">[R~]</ref> for each i (1 &lt; i &lt; n), although t is not a tuple in the relation r. However, it is straightforward to verify that the same relation r obeys, for example, the join dependency t~{ABC, BCD, ABD }.</p><p>Let S = {S~, ..., Sin}. If Sx U ... U Sm is a subset of the attributes of the relation r, then we say that r obeys the embedded join dependency t~S if the projection r[S~ O ... U Sin] obeys the join dependency t~S. When we say that a set {$1 ..... Sin} has a losslessjoin, we mean that the embedded join dependency t~S holds. Thus, property (4) says that every relation that obeys the join dependency t~R also obeys the embedded join dependency t~S whenever S is a connected subset of R.</p><p>If r is a database over R, if S _ R, if s _ r, and if s is a database over S, then we say that s is the subdatabase over S. It is not hard to see that property (4) says that for every connected subset S of R and every consistent database r over R, if s is the subdatabase over S, then Ms is a projection of t~r.</p><p>One of the motivations for this paper was the question of whether every a-acyclic hypergraph R enjoys property ( <ref type="formula">4</ref>). The answer is "no," since there are a-acyclic hypergraphs that are not y-acyclic, such as the hypergraph in Figure <ref type="figure" target="#fig_9">13</ref>. This  hypergraph is not 7-acyclic and so violates property (4). In the case of this hypergraph, the join of the {SUPPLIER, PROJECT, DATE} relation with the {PROJECT, PART, COUNT} relation might introduce a SUPPLIER, PART, PROJECT triple that does not appear in the SUPPLIER, PART, PROJECT relation (the "connection trap" <ref type="bibr" target="#b13">[ 15]</ref>).</p><p>(5) There is a unique relationship among each set of attributes, for each consistent database over R. Let r be a consistent database over R. By a relationship among a set X c U R of attributes, we mean a relation (r, 11&gt;&lt;3 . . . t~ r,,)[X], where X __ R~ 1 U â¢ .. U R~ k and {R,~ . . . . . R,k} is connected. Thus, some of the "base" relations r are combined, as usual, by taking joins (where none of these joins are Cartesian products), and the result is projected onto X. Property <ref type="bibr" target="#b3">(5)</ref> says that the resulting relation is unique. It is sometimes convenient to refer to a relationship among X as an X relationship. Atzeni and Parker <ref type="bibr" target="#b1">[3]</ref> discuss the power of assuming a unique relationship anaong each set of attributes (they call this the Relationship Uniqueness Assumption). They and others (e.g., Sagiv [35]) note that this assumption is made commonly, either explicitly or implicitly, in many papers on database design. Let us consider an example which is slightly more elaborate than the example in the introduction. Assume that the database scheme consists of three relation schemes: an EMP WORK relation scheme with attributes EMP (for "employee"), DEPT (for department), and SAL (for "salary"); a DEPT__INFO relation scheme with attributes DEPT, CITY, and MGR; and a EMP__HOME relation scheme with attributes EMP, STREET, CITY, and CHILD. See Figure <ref type="figure" target="#fig_12">20</ref> for an example of one tuple in each relation. In this example, there are two distinct {EMP, CITY} relationships. One, which has the tuple (Fagin, San Jose), relates an employee to the city where he works. The other, which has the tuple (Fagin, Los Gates), relates an employee to the city where he lives. The database scheme is y-cyclic (it is even acyclic).</p><p>However, assume that we were to rename the attribute CITY in the DEPT__INFO relation scheme to be WORK CITY, and the attribute CITY in the EMP__HOME relation scheme to be HOME CITY (see Figure <ref type="figure" target="#fig_16">21</ref>). There is now a unique {EMP, W O R L C I T Y } relationship, which includes the tuple (Fagin, San Jose), and a unique (EMP, HOME._CITY) relationship, which includes the tuple (Fagin, Los Gates). The database scheme of Figure <ref type="figure" target="#fig_16">21</ref> is 7-acyclic.</p><p>Knowing that relationships are unique make it possible to greatly simplify the form of" queries. Thus, the simplest SQL <ref type="bibr" target="#b11">[13]</ref> query to fred all EMPs associated with The result is obtained by t'mding the unique (EMP, WORK__CITY} relationship and then selecting out those tuples where the CITY entry is 'San Jose.' The desirability of being able to pose queries such as (8.1), with such a simple syntax, has been discussed by Ullman <ref type="bibr" target="#b35">[37]</ref>. Not only is the query (8.1) easier to pose and simpler to understand than the SQL query, but also the system has a great deal of flexibility in optimizing how to find the result of the query. The system's choice of which relations to join (if there are several possibilities) might depend, for example, on which indices are present. The system might be able to exploit the fact that whatever relations in the database are joined together, the join (i.e., the join expression, as def'med in Section 7) is guaranteed to be monotone, and so, efficient. For, we are only allowing joins over connected subsets S of R, which are themselves connected, 7-acyclic hypergraphs, since R is; and, because S is 7-acyclic, it follows from Theorem 8.1 below that every connected join expression over S is monotone. (However, when we project the result Of the join onto the desired attributes, the number of tuples might, of course, decrease.) Languages such as SQL are considered "high-level," since it is not necessary to state the access paths (such as which indices to utilize) explicitly. Similarly, we have seen that in a y-acyclic database scheme, it is possible to make use of a still higherlevel language, in which it is not even necessary to specify which relations must be joined to obtain the answer the user desires.</p><p>Aho and Kernighan <ref type="bibr" target="#b0">[2]</ref> have developed a query system called "q." Given a set X of attributes, q searches through a "rel file" to determine which relations to join to fred the X relationship. If the database scheme obeys property <ref type="bibr" target="#b3">(5)</ref>, that is, if it is -t-acyclic, then a rel file is unnecessary.</p><p>(6) R has a loop-free Bachman diagram. If R is a hypergraph, then we define Bachman(R) to be the hypergraph obtained by closing R under intersection. Thus, a set S is in Bachman01) if and only if either S E R or S is the intersection of two or more members of R. We note that both Lien <ref type="bibr" target="#b29">[31]</ref> and Yannakakis <ref type="bibr" target="#b36">[38]</ref> include also in Bachman(R) all singleton edges {A}, for each node A. We do not do so, since (as noted in <ref type="bibr" target="#b29">[31]</ref>), this is really unnecessary. We leave to the reader the exercise of showing that Bachman(R) is 7-acyclic if and only if R is.</p><p>For our purposes it is convenient to define the Bachman diagram of R <ref type="bibr" target="#b3">[5]</ref> to be an undirected graph, with nodes the members of Bachman(R), and with an edge between two nodes S and Tof Bachman(R) iff(i) S ~ T, and (ii) there is no Win Bachman(R) such that S ~ W ~ T. (The usual definition has a direction on these edges and thus yields a directed graph.) A loop-free Bachman diagram <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b36">38]</ref> is a Bachman diagram that is a tree. If Bachman(R) is loop-free, then we say that R has a loop-free Bachman diagram. Yannakakis <ref type="bibr" target="#b36">[38]</ref> discusses various properties of loop-free Bachman diagrams, and in particular shows the equivalence of properties ( <ref type="formula">4</ref>) and ( <ref type="formula">6</ref>). ( <ref type="formula">7</ref>) R has a unique minimal connection among each set X of nodes. Assume that the user wishes to obtain the projection onto X of the union of all lossless joins that involve (among others) attributes X. For motivation as to why a user would wish to obtain such a union, the reader is referred to <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b35">37,</ref><ref type="bibr" target="#b36">38]</ref>.</p><p>If the database is consistent, then every lossless join (projected onto X) gives the same answer, and so it is easy to take such a union. If we do not assume consistency, then in general it might be quite an undertaking computationally to obtain such a union. We now describe a situation where the union can be obtained via a single lossless join, even if the database is not consistent.</p><p>In ~/-acyclic schemes, lossless joins correspond to connected joins (see property (4)). Therefore we shall discuss connected, rather than lossless, joins.</p><p>Instead of assuming that the database is consistent, we shall make a weaker assumption, which we call the subset condition. The subset condition says that whenever R1 and R2 are relation schemes in the database scheme and R1 _C R2, then r2[R1] ~ rl, where r, is the R, relation in the database (i --1, 2). Yannakakis <ref type="bibr" target="#b36">[38]</ref> calls the individual assumptions in the subset condition existence constraints. Existence constraints are special cases of inclusion dependencies <ref type="bibr" target="#b10">[12]</ref>. We note that Codd <ref type="bibr" target="#b15">[17]</ref> assumed existence constraints involving his E-relations.</p><p>Let X be a subset of the nodes of R, and let V be a connected set of k distinct members II1 ..... Vk of Bachman(R). Following Yannakakis <ref type="bibr" target="#b37">[39]</ref>, we say that V is a unique minimal connection (among members of X, or simply, among X) if (i) X C_ 111 U ... U Vk, and (ii)whenever W = { Wx ..... Ire'p} is a connected subset of Bachman(R) with X _ 1Â¥1 U ... tJ Wp, then there are k distinct members ~ ...... Wi, of W (where k is the cardinality of V) such that Vj C_ W,~, for 1 ~_ j _&lt; k.</p><p>Yannakakis <ref type="bibr" target="#b37">[39]</ref> observed that if R has a loop-free Bachinan diagram (property (6) above), then this set V can be obtained by simply taking the maximal members of the smallest connected subgraph of the Bachman diagram of R that contains X. In other words, let R,, ..... R,q be a minimal (i.e., q is as small as possible) set of nodes of Bachman(R) such that X __. (R,~ U ... U R,q), and let V contain Ri, (1 _&lt; j ___ q) precisely if there is nop (1 ___p ___ q) such that R~ ~ R~p.</p><p>We now mention an application of the unique minimal connection, which is of important practical use when the database is not necessarily consistent. This application was noted by Yannakakis <ref type="bibr" target="#b36">[38]</ref>. (Yannakakis worked in the context of weak or containing instances <ref type="bibr" target="#b26">[28]</ref>, but the results are equivalent to what we shall state below.) Assume now that the user requests an X relationship in the database, where X is a set of attributes. At least in principle, the response of the system is as follows (we neglect the issue of optimization, and describe the result in operational terms):</p><p>(1) For each relation scheme S in Bachman(R) but not in R, the system forms a new relation s over S by letting s be LJ (r[S]:r ~ r and S is a subset of the relation scheme of r}. (Here r is the database over R.) The result is a new database s over Bachman(R), which contains all of the relations in the original database r, along with new relations over relation schemes in Bachman(R) -R. It is easy to see that since the original database r obeys the subset condition, so does the new database s over Bachman(R). (2) If V is the unique minimal connection among X, then the response of the system to the user's query is (~v)[X], where v is the subdatabase, over V, of s.</p><p>Let us denote by v this result (t~v)[X]. Let w --(t~w)[X] be another X relationship. That is, (a) W is a connected subset of Bachman(R), (b) X _C (3 W, and (c) w is the subdatabase over W. It follows easily from the definition of unique minimal connection that w _.C v.</p><p>Thus, not only does the system answer the query by taking a connected join, but furthermore, this result contains every tuple that can be obtained by taking any connected join (which contains the desired attributes). The philosophy is that this response is probably what the user intends. If the user wants something different, then he can explicitly spell out what he wants. Thus, in the usual case, the user can specify what he wants in a high-level manner, and the system gives him a meaningful response, which should correspond exactly to what he desires a large proportion of the time. For a more extensive discussion of this philosophy, see <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b35">37,</ref><ref type="bibr" target="#b36">38]</ref>.</p><p>Maier and Ullman <ref type="bibr" target="#b30">[32]</ref> demonstrate another sense in which there is a unique connection among each set of nodes in an o~-acyclic hypergraph. Yannakakis' notion of unique minimal connection is not only stronger, but, we believe, more natural. PROOF OF EQUIVALENCE. We now show that the properties (1)-( <ref type="formula">7</ref>) described above are equivalent. THEOREM 8.1. Let R be a connected hypergraph. The following are equivalent:</p><p>(1) R is 3,-acyclic.</p><p>(2) Every connected#in expression over R is monotone. O) Every connected, sequential join expression over R is monotone. <ref type="bibr" target="#b2">(4)</ref> The join dependency MR implies that every connected subset of R has a lossless join. <ref type="bibr" target="#b3">(5)</ref> There is a unique relationship among each set of attributes for each consistent database over R. <ref type="bibr" target="#b4">(6)</ref> R has a loop-free Bachman diagram. <ref type="bibr" target="#b5">(7)</ref> R has a unique minimal connection among each set X of nodes.</p><p>PROOF. It is convenient for us to introduce two new properties, which we shall call properties (2') and (4'). We shall prove that (1) =* (3) ,=~ (4') =0 (4) =0 (2') =0 (1), that (4') =0 (2) =* (2'), and that (4) =* (5) =0 <ref type="bibr" target="#b2">(4)</ref>. Yannakakis shows that (4) and <ref type="bibr" target="#b4">(6)</ref> are equivalent <ref type="bibr" target="#b36">[38]</ref> and that ( <ref type="formula">6</ref>) and <ref type="bibr" target="#b5">(7)</ref> are equivalent <ref type="bibr" target="#b37">[39]</ref> (we shall not show these equivalences). Taken together, these implications give us Theorem 8.1.</p><p>It is an instructive exercise (left to the reader) to prove directly the equivalence of (1) and <ref type="bibr" target="#b4">(6)</ref>. A helpful lemma is the fact (noted above) that R is T-acyclic if and only if Bachman(R) is "t-acyclic. It is also helpful to make use of Defmition 3 of't-cyclicity.</p><p>We now define properties (2') and (4').</p><p>(2') Let 0 be a connected join expression over R, let r be a conaistent database over R, and let (01 t~ 02) be a subexpression of 0. Then 01(r) and 02(0 are consistent.</p><p>If we replace "consistent database" in (2') by "pairwise consistent database," then it is not hard to see that the result is exactly what (2) says. In particular, (2)=* (2'), since every consistent database is pairwise consistent.</p><p>(4') Assume that S __C_ R is connected, that r is a pairwise consistent database over R, and that s is the subdatabase over S. Then Â¢&lt;s is a projection of t~r.</p><p>If we replace "pairwise consistent database" in (4') by "consistent database," then it is not hard to see that the result is exactly what (4) says. In particular, (4')=, (4), since every consistent database is pairwise consistent.</p><p>(l) --~ (3): Assume that (3) is false. We shall show that (1) is false, that is, that R is T-cyclic. Since (3) is false, there is an ordering Rx . . . . . Rn of R ffi {R~ . . . . , R~), a pairwise consistent database r ffi {r~ . . . . . r~} over R, and an integer j (1 ~; j &lt; n) such that (a) {Rt . . . . . R~} is connected for each i (1 _&lt; i _ n), and (b) rl t~ . . . t~ r~ is not consistent with r~Ã·l.</p><p>We assume t h a t j is minimal, so that (b) holds. Thus (r~ t~ . . . t~ r~) is consistent with r,+~, if i &lt; j.</p><p>Denote (R1 t9 . . . t.J Rj) N R~+~ by S. Thus S is the set of attributvs that rl H " ' " t~ rj has in common with rj+t. We know that (r~ t~ . , . t~ rj)[S] # r~+x[S], since r, .. â¢ M rj is not consistent with rj+l.</p><p>Select k (1 __ k _ j ) so that Rk Iq S is as big as possible (i.e., has as many nodes as possible). Thus R, N S is no bigger than Rk N S if 1 __ i _&lt; j. We now show that S ~ Rk. For, assume that S _c. Rk; we shall derive a contradiction. Since r is pairwise consistent, it follows that rk and rj-~a are consistent. Thus rk[S] ffi rj+a <ref type="bibr">[S]</ref>. By our mirtimality assumption on j, we know that rl t~ . . . ~ r, is consistent with r,+x, if I ___ i &lt; j . Thus no tuples are lost in taking the sequence following of joins: Since S ~ Rk, there is a node vl in S -R~. Since {R1 . . . . , Rj} is a connected set of edges, since Rk is an edge in this set, and since vl is a node that appears in this set, there are St . . . . . Sp such that (i) $1 = Rk, (ii) S, N S,+l ~ ~, for l &lt;_ i &lt; p, (iii) each St is one of R1, . . . , Rj (l _ i&lt;_p), (iv) vl ~ Sp, and (v) p is as small as possible.</p><p>Thus $1 . . . . . S~ is the shortest path (within (R1 . . . . , Rj}) from Rk to an edge containing vl. In particular, vl ~ S,, if 1 &lt;__ i &lt; p. Note that S~ . . . . . S~, are distinct, since Sx . . . . . S, is a shortest path. Now Sp 13 S has no more nodes than Rk t3 S, by maximality of R~ t3 S. Since Sp Â¢3 S contains v~, which is not in Rk t3 S, it follows that Rk f3 S contains a node v2 not in Sj, t3 S.</p><p>Find m (1 _&lt; m &lt; p ) as big as possible so that Sm contains 1,2. There is such an m, since $1 (=Rk) contains v2. By (ii) above, we can fred nodes x, (m &lt;_ i &lt; p) such that x, E S, f3 S,+v We now show that (Sp, â¢1, Rj+I, v2, am, Xrn, Sin+l, Xm+l . . . . Xp-1, Sp)</p><formula xml:id="formula_9">(8.2)</formula><p>is a weak q-cycle. Note that V1 and v2 are both in Rj+~, since they are both in S C Rj+x. By construction, vl is in Sp but not in S,, for m _ i &lt; p; similarly, v2 is in Sm but not in S,, for m &lt; i __ p. In particular, Rj+I, Sp, and S= are all distinct, and so (8.2) contains at least three distinct edges. The nodes x, (m _&lt; i &lt; p) are distinct, or else the path $1 . . . . , Sp could have been shorter. Further, vl does not equal any x,, since Vl is not in S, if m _&lt; i &lt; p. Similarly, v2 does not equal any x,. Since we see also that Vx # v2 (because Vl is in Sp and v2 is not), this shows that all of the nodes Vx, v2, Xm, x,~+l . . . . . Xp-~ of (8.2) are distinct. Similarly, the edges of (8.2) are distinct. It follows from what we have just shown that (8.2) is indeed a weak y-cycle. Thus R is V-cyclic, which was to be shown.</p><p>(3) =* (4'): Assume <ref type="bibr" target="#b1">(3)</ref>. Assume that S _ R is connected, that r is a pairwise consistent database over R, and that s is the subdatabase over S. We must show that Ms is a projection of Mr.</p><p>Since S and R are each connected, there is an ordering Rx . . . . . Rn of R such that (a) S = (RI . . . . . Rm), where m is the cardinality of S (thus the members of S form an "initial segment" of the ordering Rx . . . . , R,,); and ( b ) (R1 . . . . . R,} is connected for each i (1 ___ i _ n). Then ( . . . ((R1 M R2) M Ra) .--M Rn) is a connected, sequential join expression over R. By (3), it is monotone. It follows easily that rl M -. . t~ r, is a projection of rl M . . -M r,, for each i, and, in particular, for i ffi m. Thus, Ms is a projection of Mr, which was to be shown. (4) =* (2'): Assume (4). Let O be a connected join expression over R, let r be a consistent database over R, and let (81 M 02) be a subexpression of 8. To prove (2'), we must show that Ol(r) and 02(0 are consistent.</p><p>Assume that O~ is over S ___ R and that O~ is over T C__ R. By connectedness of O we know that S and T are each connected. Let s (respectively, t) be the subdatabase over S (respectively, T). By (4), each of Ms and Mt are projections of Mr. Hence, Ms and Mt are consistent. Now 0a(r) --Ms, and 02(0 ---Mt. So 01(r) and O2(r) are consistent. This was to be shown. It is easy to see that E is a connected set of edges, that Et and E2 are distinct edges in E, that F is an edge not in E, and that At and A2 are distinct nodes such that (i) A 1 is in Et but in no other edge of E, (ii) A2 is in E2 but in no other edge of E, and (iii) A1 and A2 are in F.</p><p>Let r be a relation with attributes RIO ... O R~, and with exactly two tuples. The first tuple has all O's, and the second tuple has all O's except in the At and A2 entries, where it has l's. Let r = {rl ..... r,,} be a database over R, where ri = r[Ri] for each i (1 _ i _&lt; n). So, r is consistent.</p><p>Assume that the distinct members of E are E1 ..... En. Let e = {et, ... en} be the subdatabase of r over E, and let f be the member of r that is over F.</p><p>Clearly, et t~ e2 is a relation with exactly four tuples: the (Ax, A2) entries of the four tuples are, respectively, (0, 0), (0, 1), (l, 0), and (1, 1). The remaining entries of all four tuples are all O's. Also, es t~ .. â¢ t~ en is a one-tuple relation, where the one tuple has all O's (recall that E3 0 ... 0 Era does not contain either At or A2). Thus, el t~ e2 t~ ... M em has exactly four tuples, where the (A1, A2) entries are as before and the other entries are all O's. However, there are only two (At, A2) entries in f, namely, (0, 0) and (1, 1). So el tm ... t~ en is not consistent with f. Since (E~ ..... En}, {Et .... , Era, F}, and R are each connected, there is an ordering R~ ..... Rn of R such that (a) E --(R1 ..... Rm) (i.e., E forms an initial segment), (b) F --Rm+l (that is, F is next after E), and (c) {R1, ..., R,} is connected for each i (1 _&lt; i _&lt; n).</p><p>For each k, with 1 _ k _ n, deFme the join expression 8~ to be (... ((Rt t~ R2) t~ R3) â¢ .. t~ Rk). Then 0~ is a connected join expression over R. Also, (On ~ RnÃ·l) is a subexpression of 0n. However, if r is the consistent database described earlier, then 0n(r) is not consistent with Rn+t(r), that is, (rl t~ ... ~ rm) is not consistent with rm+~, since r~ ~ ... ~ rm = el t~ ... t~ en, and rm+l --f. Thus (2') is false, which was to be shown.</p><p>(4') ~ (2): This is the same as the proof that (4)â¢* (2'), except that "pairwise consistent" is replaced by "consistent."</p><p>(2) =~ (2'): Already shown, in our comments after the defmition of property (2').</p><p>(4) ~ (5): Assume (4); we shall show <ref type="bibr" target="#b3">(5)</ref>. Let r be a consistent database over R. Let S = ( $1 ..... Sp} and T = ( T~ ..... Tq} be connected subsets of R. Assume that X __ O S and X __ (.J T. Let s (respectively, t) be the subdatabase of r over S (respectively, T). By (4), we know that t~s is a projection of t~r. Hence, (t~s)</p><formula xml:id="formula_10">[X] ffi (t, clr)[X]. Similarly, (t~t)[X] = (t~r)[X]. Hence, (~s)[X] --(t~t)[X]</formula><p>. This was to be shown. The algorithm clearly terminates. If the end result is the empty set of edges, then the original hypergraph is y-acyclic; otherwise, it is y-cyclic.</p><p>As in the case of Graham's algorithm, we note that it is not hard to show that this algorithm is Church-Rosser.</p><p>Remark. We shall often apply rule (d) implicitly, by simply dealing at all times with a set of edges (which has the effect of automatically removing duplicates). Also, it is natural to apply rule (c), the deletion of an empty edge, implicitly.</p><p>Let us apply this algorithm to the hypergraph of Figure <ref type="figure" target="#fig_17">22</ref>. The Let us say that a hypergraph is nonsingular if every edge has at least two nodes.</p><p>We shall prove the following.</p><p>FACT 2. Every ~/-acyclic, intersecting, nonsingular hypergraph has a bad pair of edges.</p><p>We now show that Fact 2 gives us a contradiction. As we showed, the hypergraph Y#' defined above is 3,-acydic and nonsingular and has no bad nodes. We now show that ~' is intersecting. Assume not. Then ~' is nesting. Let E be a minimal edge of YY'. Edge E (and every edge of .Yd') has at least two nodes. Let x and y be distinct nodes of E. By Fact 1, we know that x and y are edge-equivalent. But ~,~' has no pair of distinct edge-equivalent nodes. This contradiction shows that .,~' is intersecting. Since ~' is â¢-acyclic, intersecting, and nonsingular, it follows from Fact 2 that ~' has a bad pair of edges, and so ~' has a bad node. But ~' has no bad node. This is the desired contradiction. Thus we need only prove Fact 2 to prove the theorem.</p><p>We shall prove Fact 2 by induction on the number of edges in the hypergraph. The base case (of hypergraphs with only one edge) is immediate, since no hypergraph with only one edge is intersecting. Assume that Fact 2 holds for hypergraphs with less than n edges, and let â¢ be a hypergraph with n edges that is ~,-acyclic, intersecting, and nonsingular. We must show that ,,~ has a bad pair of edges.</p><p>Since a~ is intersecting, it has a pair (E, F) of edges that are incomparable and nondisjoint. Find such a pair (E, F) such that E n F is as small as possible. Thus, if E' and F' are incomparable and nondisjoint edges of ~, then IE' N F' I _ IE n F I. (Here [ X I is the eardinality of set X.)</p><p>Since Jis ~-acyclic, it follows from Definition 4 that in the hypergraph that results by removing E f3 F from every edge, what is left of E is not connected to what is left of F. Let us write E I"1 F as Q. Let f# be a hypergraph with the same nodes as J and whose edges are precisely those edges of J that are not subsets of Q. Note that E and F are each edges in ~, since they are incomparable and their intersection is Q. For @, too, it is the case that in the hypergraph that results by removing Q from every edge, what is left of E is not connected to what is left of F. We can thus partition the edges of .c#into two disjoint sets d~and ~such that E~ oaand FE ~, and such that whenever E' ~ 6' and F' ~ ~, then E' f3 F' C_ Q. (9.1)</p><p>Since we have several hypergraphs we are now dealing with (namely, 8, ~, fa, and J), it is convenient for us to subscript the notion of "bad" with the hypergraph we are discussing. For example, if we say that x is a bade node, we mean that either (i) x is in exactly one edge of 8, or else (ii)x is edge-equivalent (with respect to 8) to another node of 6', that is, x is in precisely the same edges of 6' as another node of ~f. Similarly, we can speak of a bade pair of edges, etc.</p><p>We now prove three simple facts, each of which we shall use several times. FACT 3. Each edge of e either contains Q or is disjoint from Q.</p><p>PROOF OF FACT 3. Assume that Fact 3 were false. Let E' be an edge of 8 that neither contains Q nor is disjoint from Q. Now Q (Z E', by assumption, and so Q E' Â£1 F. If we put this together with the fact that E' N F C_. Q (which we know by (9.1)), it follows that E' Â£1 F is strictly smaller than Q = E N F. Also, E' and F are nondisjoint, since by assumption E' and Q = E O F are nondisjoint. Now E' 6 ~f c_. f~, and by delrmition of f~ no edge of f~ is contained in Q. Therefore E' ~ Q. Hence there is a node e in E' -Q. But E' O F_ Q by (9.1), and so e ~ F. Since e E E' -F, we know that E' &lt;Z F. Further, F~ E': for, if F___ E', then F= E' n F__ Q __. E, where the next-to-the-last inclusion follows from (9.1); however, by our choice of E and F, we know that F ~ E. We have shown in this paragraph that E' and F are incomparable and nondisjoint, and that E' O F is strictly smaller than E O F. This contradicts our minimality assumption in the choice of (E, F). Therefore, Fact 3 is proved.</p><p>FACT 4. Assume that node a is in exactly one edge of 8, and that a f~ Q. Then a is bad:. PRoov or FACT 4. It is sufficient to show that a is in exactly one edge of J. Let E' be the edge of ~ that contains a. Assume that a is in another edge I of J other than E'. By assumption, we know that I ~ 8. If I E ~,, then by (9.1) we know a E Q, a contradiction. So I ~ f~. Therefore, I ~ J-f~. But then a E Q by definition of ~. This contradiction completes the proof of Fact 4. FACT 5. Assume that a and b are nodes in ~ that are edge-equivalent with respect to ~f. Assume also that neither a nor b is in Q. Then a is bad~.</p><p>PRoof or FACT 5. Let I be an edge of J that contains node a. Then 1 E ~, since otherwise a E 1 ___ Q, a contradiction. We now show that I ~ 8. For if not, then I E f~ -~ = ~, so a is a node in both #and ~, and so by (9.1) it follows that a ~ Q, a contradiction. We have shown that each edge of J that contains node a is an edge in d~. Similarly, the same is true about node b. Since a and b are edge-equivalent with respect to 8, it then follows immediately that a and b are edge-equivalent with respect to J. Thus a is bad:. This completes the proof of Fact 5. Now that Facts 3-5 are proved, we return to the proof of Fact 2 (which will complete the proof of the theorem).</p><p>We shall show that there is a bad:node e which is an edge E1 of 8but which is not in Q. Identically, it follows that there is a bad~,node fwhich is in an edge F1 of ,~ but which is not in Q. From (9.1), we see that E1 N F1 C Q. Since e E E1 and e ~ Q, it follows that e ~ F1. Thus e E E1 -F1. Similarly, f ~ F1 -El. So (El, F1) is a bad/ pair of edges. Hence, there is a bad: pair of edges, which is exactly what we wished to show to complete the proof.</p><p>Thus, we need only show that 8 contains an edge Ea that contains a bad~, node e where e ~ Q. There are two cases.</p><p>Case 1. 8is nesting. There are two subcases.</p><p>Case la. There is an edge of ethat is disjoint from F. Let G be a minimal edge of ~f. Since some edge of d~ is disjoint from F, and since ~ is nesting, it is clear that G is disjoint from F. Let a and b be two distinct nodes of G. By Fact 1, nodes a and b are edge-equivalent with respect to 8. Since G is disjoint from F, it follows that neither a nor b is in Q (because Q ___ F). By Fact 5, a is bad~,. Therefore, a is the desired bad/node which is in an edge of 8 but not in Q.</p><p>Case lb. No edge of 8 is disjoint from F. Let G be a maximal edge of ~. Then Q ~ E . . C_C G (where the last inclusion holds since G is maximal and 8 is nesting). Therefore, since G is maximal and g is nesting, it is clear that G contains a node e that is not in any other member of ~ and not in Q. By Fact 4, we know that e is bad/. Therefore, e is the desired bad/node which is in an edge of ~ but not in Q.</p><p>Case 2. 8 is intersecting. Since J is 7-acyclic and nonsingular and 6' __ ~ it follows that 6" is -t-acyclic and nonsingular. Therefore, by our inductive assumption about Fact 2, we know that 6" has a bade pair (Ea, E2) of edges. Let el be a bade node in E1 -E2, and let e2 be a bade node in E2 -EI. We now show that it is impossible for both ea and e2 to be in Q. For, assume that ex and e2 are both in Q. Since e~ E E1 f3 Q, we know that E1 is not disjoint from Q. So, by Fact 3, it follows that Q __ E~. Since e2 E Q, it follows that e~. ~ EI, which is a contradiction. Therefore, one of el or e2, say el, is not in Q. Since ex is bade, we know that either (i) el is in exactly one edge of 6", or else (ii) e~ is edge-equivaleut (with respect to 6") to another node el of 6". In case (i) it follows from Fact 4 that ex is the desired bad&gt;, node which is in an edge of 6" but not in Q. So we can assume that case (ii) holds. If e~ ~ Q, then it follows from Fact 5 that once again el is the desired bad&gt;, node which is in an edge of 6, but not in Q. Therefore, we can assume that e; ~ Q. since e~ ~ E2 and since e~ and el are edge-equivaleut (with respect to 6,), it follows that e~ ~ E2. So, since e~ E Q, it follows that Q ~ E~. Since Q ~= E2, it follows from Fact 3 that Q is disjoint from E2. Since e2 is bade, we know that either (i) e2 is in exactly one edge of 6,, or else (ii) e2 is edge-equivalent (with respect to 6,) to another node e[ of 6". Now e2 ~ Q, since Q is disjoint from E2. Therefore, in case (i) it follows from Fact 4 that e~ is the desired bad/node which is in an edge of 6,but not in Q. So we can assume that case (ii) holds. Now e~ ~ Q, since Q is disjoint from E2. Therefore, it follows from Fact 5 that once again, e2 is the desired bad&gt;` node which is in an edge of 6" but not in Q. This completes the proof. [] We note that the above proof was inspired by the proof in <ref type="bibr" target="#b6">[8]</ref> that Graham's algorithm recognizes precisely the ,-acyclic hypergraphs.</p><p>The algorithm clearly runs in polynomial time. We remark that Yannakakis <ref type="bibr" target="#b36">[38]</ref> shows that ifR has a loop-free Bachman diagram, then ] Bachman(R)[ _&lt; I RI + 21 UI, where U = L)R is the set of all attributes. This provides another polynomialtime algorithm for determining y-acyclicity, which we now describe. Start computing Bachman(R), but stop and announce -t-cyclicity if it becomes bigger than [R[ + 2] U]. Once Bachman(R) is computed (if we have not stopped and announced -t-cydicity already), form the Bachman diagram of R, and see if it is loop-free.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Conclusions</head><p>We have discussed the concepts of a-acyclicity, fl-acyclicity, and y-acyclicity for hypergraphs and for relational database schemes. These are all distinct, and each corresponds precisely to various desirable properties of relational database schemes. These concepts are also of interest from a graph-theoretic viewpoint, as natural generalizations of the notion of acyclicity from graphs to hypergraphs.</p><p>ACKNOWLEDGMENTS. The author is grateful to Shel Finkelstein and Jorma Rissanen for interesting discussions about Theorem 8.1(4) that led the author to consider the concept of-y-acyclicity. He is also grateful to Nat Goodman, Marc Graham, Dave Maier, Alberto Mendelzon, Oded Shmueli, Jeff Ullman, and Mihalis Yannakakis for helpful discussions. Special thanks go to Moshe Vardi for his careful reading of the paper and numerous suggestions, including a way to simplify the proof of Theorem 9.3. REFERENCES (Note. Reference <ref type="bibr" target="#b7">[9]</ref> is not cited m the text.) 1. AHO, A.V., BEERI, C., AND ULLMAN, J.D. Database Syst. 4, 3 (Sept. 1979), 297-314</p><p>The theory of joms in relational databases. A CM Trans.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 4 .</head><label>4</label><figDesc>A hypergraph is B-cyclic if it has a weak B-cycle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 5 .</head><label>5</label><figDesc>A hypergraph is fl-cyclic if it has a Graham cycle. It is clear that every weak fl-cyde is a Graham cycle. THEOr.EM 4.1. Definitions 1-5 of fl-cyclicity are equivalent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>( 4 )</head><label>4</label><figDesc>~ (5): Let ~ be fl-cyclic by Definition 4; it is then B-cyclic by Definition 5, since, as we noted, every weak fl-cycle is a Graham cycle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>in a hypergraph ~ is a sequence ($1, xl, $2, x~ ..... Sin, xm, Sin+0 (5.1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>FIGURE 11    </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Definition 2 .</head><label>2</label><figDesc>A hypergraph is ,/-cyclic if it has a weak y-cycle. To help prevent confusion, we note that in an earlier version of this paper we referred to what we are now calling a weak y-cycle as a T-cycle. The next definition gives us a nice characterization of y-cyclic hypergraphs. Definition 3. A hypergraph is T-cyclic if it has either a ,/-cycle of size 3 or a pure cycle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Definition 4. A hypergraph is y-cyclic if it has a pair E, F of incomparable, nondisjoint edges such that in the hypergraph that results by removing E f'l F from every edge, what is left of E is connected to what is left of F.Remark. We say that E and F are incomparable if E ~ F and F ~ E. Definition 4 says that hypergraph ~i s T-cyclic if it has a pair E, F of incomparable, nondisjoint edges such that if Q ffi E N F, if G' is G -Q for each edge G of ~, and if ~' ffi (G': G is an edge of ,,'if} -{ O}, then E' and F ' are connected in ~' .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>( 3 )</head><label>3</label><figDesc>=~ (4): Let g be y-cyclic by Definition 3; we shall show that .g~ is V-cyclic by Definition 4. Since . ~ is T-cyclic by Definition 3, it has either a T-cycle of size 3 or a pure cycle. Assume first that .,~ has a T-cycle of size 3, and let this y-cycle be (Sx, x~, $2, x2, $3, xa, S~). It is easy to verify that g i s V-cyclic by Definition 4, where we let E and F be, respectively, S~ and $3. Now assume that .~f has a pure cycle. By letting E and F be neighboring edges in the pure cycle, we see once again that . ~ is T-cyclic by Definition 4. (4) =* (1): Let . ~b e T-cyclic by Definition 4; we shall show that H is y-cyclic l~y Definition 1. Take E and F as in Definition 4, and let Q ffi E N F. We know that there is a sequence (S~ . . . . . Sin) of edges such that (i) S x f f i g , (ii) S,~ --F, and (iii) (S,O S,+x) -Q # O, for 1 _&lt; i &lt;_ m -1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig- ure 3 .</head><label>3</label><figDesc>This hypergraph is ~,-cyclic, since ({SUPPLIER, PART, COST}, PART, {SUPPLIER, PART, PROJECT), PROJECT, {SUPPLIER, PROJECT, DATE}, SUPPLIER, {SUPPLIER, PART, COST)) is a -~-cycle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>FIoOp.~ 19 '</head><label>19</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>FIGURE 20</head><label>20</label><figDesc>FIGURE 20    </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>FIGtmE 21    </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>rl M !" 2 ,</head><label>2</label><figDesc>(rl ~ r~) ~1 ra, (-.. ((rl t~ r2) N r3) ... ~ ,',). Since k _ j, it follows that rk is consistent with rt ~ -. . ~ rj. Thus r~[S] = (rl t~ . . . t~ rj)[S]. Since also rk[S] --rj+l[S], we have (rl t~ . . . t~ rj)[S] --rj+l[S]. This is a contradiction. So, S ~ Rk.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>( 4 '</head><label>4</label><figDesc>) =* (4): Already shown, in our comments after the definition of property (4').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>( 2 '</head><label>2</label><figDesc>) ~ (l): Assume that (1) is false, that is, that R = (R1 . . . . . Rn} is ~,-cyclic. We shall show that (2') is false. Since R is T-cychc, we know by Definition 2 of ~,-cyclicity that R has a weak 541 V-cycle (S1, xl, $2, x2 ..... Sm, Xm, Sn+l). Defme E --{$3, $4 ..... Sn, St},</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>FIOLmE 22</head><label>22</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>(</head><label></label><figDesc>For convenience, we have put common vertices in the same column.) Node A is isolated, and edge {C} is a singleton, so both are deleted, by rules (a) and (b). This F are edge-equivalent, and so, by rule (e), we delete F from both edges that contain it. Similarly, nodes C and D are edge-equivalent, and so we delete D from all three edges that contain it. We are left and fourth edges above are singletons, and so they are eliminated. This Let us say that a node in a hypergraph is bad if either (a) it is in exactly one edge, or (b) it is edge-equivalent to another node. If E1 and E2 are distinct edges, then let us say that the pair (El, E2) is a badpair of edges if there is a bad node in each of the set differences E~ -E~. and E2 -E~.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>concept of acyclicity. A Berge cycle in a hypergraph is a sequence ($1, xl, $2, x2 ..... Sr,, xm, Sin+l) such that (i) xl ..... xm are distinct nodes of ~,~; (ii) $1 ..... Sm are distinct edges of ~, and S,,+1 = S1; (iii) m .&gt;_ 2, that is, there are at least 2 edges involved; and (iv) x~ is in S~ and S~+~ (1 _&lt; i _&lt; m).</figDesc><table /><note><p>A hypergraph is Berge-cyclic if it has a Berge cycle; otherwise, it is</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>x~ is in Sa and $2 but in no other Sj. Similarly, x, is in S, and S,+~ but in no other S~, for 1 &lt;_. i &lt;_ m -1. In particular, xa . . . . . xm-~ are all distinct. Further, x,~ is distinct from any of xl . . . . . xm-~, since x= ~ Q but x, f~ Q, for 1 &lt;-i &lt;_ m. Thus the nodes xx . . . . . x,~ are all distinct. The edges $1 . . . . . Sm are all distinct by minimality of m. We have shown enough to prove that (Sa, x~, $2, x2, . . . , Sin, xm, S,~+1) is a -~-cyele. Hence ~ is -t-cyclic by Definition 1, which was to be shown. []</figDesc><table /></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Most of this research was conducted while the author was a Visiting Research Fellow at PontifiÂ¢la Universidade Catolica do Rio de Janeiro and was supported m part by a grant from IBM Brazd</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(5) =~ (4): Assume (5); we shaft show <ref type="bibr" target="#b2">(4)</ref>. Let r be a consistent database over R, let S be a connected subset of R, and let s be the subdatabase of r over S. Let X ~= U S. By <ref type="bibr" target="#b3">(5)</ref>, we know that (Ms)[X] = (Mr)[X], that is, Ms = (Mr)[X]. Hence, Ms is a projection of Mr. This proves <ref type="bibr" target="#b2">(4)</ref>. []</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Polynomial-Time Algorithms for Determining Degree of Acyclicity</head><p>We now show that there are polynomial-time algorithms for determining whether a hypergraph is Berge-acycfic, o~-acyclic, B-acycfic, and y-acycfic.</p><p>In the algorithms we now describe, we make no attempt at optimal efficiency, since we are concerned here only with the question of polynomial-time recognition. It is an interesting problem to fred more efficient recognition algorithms. 9.1 BERGE-ACYCLICITY. It is easy to see that the usual breadth-first search algorithm for determining acycficity of an ordinary undirected graph (in which we start with an edge and propagate the graph outward while watching to see if it "folds back on itself" by touching a previously used node) generalizes neatly and easily to determining Berge-acyclicity. The simple details are left to the reader. 9.2 ~-ACYCLICITY. Beeri et al. <ref type="bibr" target="#b6">[8]</ref> prove that the following simple algorithm, called Graham's algorithm <ref type="bibr" target="#b24">[26,</ref><ref type="bibr" target="#b38">40]</ref>, is a test for a-acyclicity. The algorithm applies the following two rules to R = {R1 ..... Rn} repeatedly until neither can be applied:</p><p>(a) IfA is ~n attribute that appears in exactly one R,, then delete A from Ri. (b) Delete one R, if there is an R1 with j # i such that R~ _C Rj.</p><p>Intuitively, rules of type (a) remove attributes that cannot have any effect on a-cyclicity or a-acyclicity, and rules of type (b) causes a hypergraph to be replaced by its reduction.</p><p>If the algorithm terminates with the empty set, then the hypergraph is a-acyclic; otherwise, the hypergraph is a-cyclic. We note that it is not hard to show that the algorithm is Church-Rosser. That is, the set that the algorithm terminates with is independent of the sequence of steps taken in executing the algorithm and depends only on the input.</p><p>Example 9.1. Let us apply Graham's algorithm to the hypergraph of Figure <ref type="figure">3</ref>, with edges ABC, CDE, EFA, and ACE, Nodes B, D, and Feach appear in only one edge, and so they are each deleted by applications of rule (a) of Graham's algorithm.</p><p>We are then left with edges A C, CE, EA, and ACE. Now edge A C is a subset of edge ACE, so by an application of rule (b) of the algorithm, this edge is deleted. This leaves us with edges CE, EA, and ACE. Similarly, edges CE and EA are deleted by applications of rule (b). We are then left with only one edge, namely ACE. Each of the nodes A, C, and E now appear in only one edge, and so by applications of rule (a), they are each deleted. We are left with the empty set, and so the hypergraph is a-acyclic. [] It is obvious that Graham's algorithm is a polynomial-time algorithm. Tarjan and Yannakakis <ref type="bibr" target="#b34">[36]</ref> have recently obtained a linear-time algorithm for determining a-acyclicity. 9.3 /3-ACYCLICtTY. We shall base our polynomial-time algorithm on Def'mition 1 of/~-acyclicity; that is, we shaft determine whether or not there is a E-cycle.</p><p>If ($1 ..... Sin, Sm+~) is a p-cycle (respectively, pure cycle), then we say that ($1, $2, $8) begins the p-cycle (respectively, pure cycle).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hypergraphs and Relational Database Schemes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>543</head><p>We now give a polynomial-time algorithm for determining whether S: ffi (SI, $2, Sa) begins some//-cycle of R, if S1, $2, and Sz are distinct edges in R. Let X= S~A $2 O $3, and let S~ = S, -X, for i ffi 1, 2, 3. If either S'I n S[or S[n S[ is empty, then 6: does not begin any//-cycle of R. Therefore, assume that S~ n S[ and S~ O S~ are both nonempty.</p><p>Let T --{E E R:(E ffi S1) or (E ffi $3) or (X~ E and E n S~ ffi ~3)}. Note in particular that $2 ~ T. Let T' = (E -X:E E T}. In particular, St and S~ are in T'. We now show that S~ and S~ are in the same connected component ofT' if and only if 5 a begins a f-cycle of R.</p><p>Assume first that Se begins a//-cycle ($1, $2, $3 .... , Sin+l) of R (where, of course, Sm+l ---S1). Then it is easy to see that S1 n ... n sm ffi St n Sz n $3, that is, S1 n ... n S,~ = x. It is clear that S~ and S~ are then in the same connected component of T'. Conversely, assume that S~ and S~ are in the same component of T'. Find E~, E' .... k in T' such that (i) El = S~, (ii) g~ = sL (iii) E~ o E',+I ~ 0, and (iv) k is as small as possibl~. It is th n easy ee that (~i, $2, $3, E2, E3, ..., Ek) is a pure cycle (m particular, by construction ofT', we kn~w that E', n S~ -~ O, for 2 &lt;_ i &lt; k). Define Ei ffi E', LI X, for 1 __. i _&lt; k. By constructiofl~ of T' we know that each E, is an edge in R. So (S~, Sz, $3, E2, E3 ..... Ek) is a//-cycle.</p><p>There is a polynomial-time algorithm for determining connected components of a hypergraph (such as T'). The algorithm is the obvious generalization of the usual algorithm in the case of ordinary undirected graphs for determining connected components. So, there is a polynomial-time algorithm for determining whether 6: begins a #-cycle.</p><p>Our polynomial-time algorithm for determining //-acyclicity goes as follows. Systematically cycle through all triples 6" --(S1, $2, $3) of three distinct edges of R to see if at least one such 6: begins a//-cycle. If so, then R is//-cyclic; otherwise, R is #-acyclic.</p><p>Graham <ref type="bibr" target="#b25">[27]</ref> states that he has found a polynomial-time algorithm for determining whether a hypergraph has a Graham cycle. Thus, by the equivalence of Definition 4 of//-cyclicity with the other defmitions, this gives another polynomial-time algorithm for determining//-acyclicity. 9.4 ,/-AC'CCLICIT'Â¢. The following algorithm for testing ,:-acyclicity is due to D'Atri and Moscarinl <ref type="bibr" target="#b16">[18]</ref>. It is similar in spirit to Graham's algorithm for determining a-cyclicity.</p><p>Apply the following rules repeatedly, in any order, until none can be applied:</p><p>(a) If a node is isolated (i.e., if it belongs to precisely one edge), then delete that node. (b) If an edge is a singleton (i.e., if it contains exactly one node), then delete that edge (but do not delete the node from other edges that might contain it). (c) If an edge is empty, then delete it. (d) If two edges contain precisely the same nodes, then delete one of these edges. (e) If two nodes are edge-equivalent, then delete one of them from every edge that contains it. (Recall that two nodes are edge-equivalent if they are in precisely the same edges.) Node E is isolated; after it is deleted, we are left with</p><p>These edges are identical, so we delete one by rule (d). We are left with B C</p><p>Both nodes are now isolated, and so they are deleted. We are left with a single empty edge, which is deleted by rule (c). The end result is the empty set of edges, and so the original hypergraph is `/-acyclic. [] THEOREM 9.3. The algorithm just described correctly determines whether or not a hypergraph is `/-acyclic.</p><p>PRoof. Assume first that the hypergraph is -/-cyclic. By Definition 1 we know that the hypergraph has a V-cycle ($1, xl, $2, x~ . . . . . S~, xm, Sm+0.-It is easy to verify inductively on the number of steps that have been applied so far in running the algorithm (where a step consists of one application of a rule) that for each i (1 &lt;__ i ___ m), whenever a rule of the algorithm is applied, then either xi or some node that is edge-equivalent to x, at the time the rule is applied remains undeleted. In particular, after each step a -/-cycle of size at least m remains. Therefore, when the algorithm terminates, there is a y-cycle of size at least m. Hence the algorithm does not terminate with the empty set, and so the algorithm correctly determines that the hypergraph is -/-cyclic.</p><p>Conversely, assume that the algorithm says that the hypergraph is ~,-cyclic. We must show that the hypergraph is indeed -/-cyclic. Assume that the hypergraph is -/-acyclic; we shall derive a contradiction. Since the hypergraph (call it .~) is -/-acyclic, we know by Definition 1 that ~ has no V-cycle. Let J~' be the hypergraph that is the end result of applying the algorithm to the hypergraph ,~. It is easy to see that when one of the rules in the algorithm is applied to a hypergraph with no ~,-cycle, then the result is a hypergraph with no -/-cycle. It follows inductively (on the number of steps) that since J~ has no V-cycle, neither does Jff'. Thus J~' is ,/-acyclic. Since none of the rules in the algorithm can be applied to g ' , it follows that each edge of .~' contains at least two nodes, each node is contained in at least two edges, and no two distinct nodes are edge-equivalent.</p><p>Let us say that a hypergraph is nesting if for each pair (El, Ez) of edges, either (a) Ea C_ E~, (b) E~ C_ Ea, or (c) E1 N E~ ffi ~. Thus every pair of edges is either comparable or disjoint. Let us call a hypergraph intersecting if it is not nesting. Thus a hypergraph is intersecting precisely if it has a pair of incomparable, nondisjoint edges.</p><p>We shall make use of the following simple fact several times.</p><p>FACT 1. Let J b e a nesting hypergraph, and let E be a minimal edge of J(i.e., there is no edge E' of J such that E' ~ E). Then the nodes of E are all edge-equivalent.</p><p>PROOF OF FACT 1. Let J be a nesting hypergraph, let E be a minimal edge of ~, and let x and y be distinct nodes of E. We must show that x and y are edgeequivalent. Assume not. Then there is an edge F that contains exactly one of x or y, say x. Since E is minimal, we know that F ~ E. Thus there is a node z in F but not E. Since also y is in E but not F, and since x is in E N F, it follows that E and F are incomparable and nondisjoint. This is a contradiction (since J is nesting), which proves Fact 1.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Kernighan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1981-11">Nov. 1981</date>
		</imprint>
	</monogr>
	<note>Private communication</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Assumptions m relaUonal database theory</title>
		<author>
			<persName><forename type="first">P</forename><surname>Atzeni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName><surname>Jr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st ACM SIGACT-SIGMOD Syrup on Principles of Database Systems</title>
		<meeting>1st ACM SIGACT-SIGMOD Syrup on Principles of Database Systems<address><addrLine>Los Angeles, Calif.; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1982">Mar. 29-31, 1982. 1982</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Minimal coverings of acyclic database schemata. Prec. ONERA-CERT Toulouse Workshop on Logical Bases for Data Bases</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ausiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D'</forename><surname>Atri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moscarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<pubPlace>Toulouse, France</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Data structure ehagrams</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Bacrtstan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Base</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="4" to="10" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">AND MOSCARINI, M Formal tools for top-down and bottom-up generation of acyclic relational schemata</title>
		<author>
			<persName><forename type="first">C</forename><surname>Batini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>D'atri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Prec 7th Int. Conf. on Graph-Theoretic Concepts in Computer Science, Lixhz, Ausma</title>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Properties of acyclic database schemes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Ann</title>
		<meeting>13th Ann<address><addrLine>Milwaukee, Wise; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1981">May 11-13, 1981. 1981</date>
			<biblScope unit="page" from="355" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On the desirability of acyclic database schemes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="479" to="513" />
			<date type="published" when="1983-07">July 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Equivalence of relational database schemes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAMJ Comput</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="352" to="370" />
			<date type="published" when="1981-06">June 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">C</forename><surname>Berge</surname></persName>
		</author>
		<author>
			<persName><surname>Graphs</surname></persName>
		</author>
		<author>
			<persName><surname>Hypergraphs</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<pubPlace>North-Holland, New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The power of natural semijoins</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAMJ. Comput</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="751" to="771" />
			<date type="published" when="1981-11">Nov. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Inclusion dependencies and their interacuon with functional dependencies</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Casanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>P~pad~triou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp on Principles of Database Systems</title>
		<meeting>ACM Symp on Principles of Database Systems<address><addrLine>Los Angeles, Cahf; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1982">Mar. 29-31, 1982. 1982</date>
			<biblScope unit="page" from="171" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">SEQUEL 2: A untried approach to data definition, manipulation, and control</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Astrahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Eswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Griffiths</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Mi~hl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rclsn~r</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Wade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM J Res. Dev</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="560" to="575" />
			<date type="published" when="1976-11">Nov. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Join graphs and acychc data base schemes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chase</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int. Conf. on Very Large Databases</title>
		<meeting>7th Int. Conf. on Very Large Databases<address><addrLine>Cannes, France; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1981">Sept 9-11, 1981. 1981</date>
			<biblScope unit="page" from="95" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Further normalization of the database relational model</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Base Systems, Courant Computer Science Symposm</title>
		<editor>
			<persName><forename type="first">Ed</forename><surname>Rustm</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Prentice-Hall</forename></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="65" to="98" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Recent investigations into relational database systems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP Congress</title>
		<meeting>IFIP Congress<address><addrLine>North-Holland, New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1974">1974</date>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="page" from="1017" to="1021" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Extending the database relational model to capture more meaning</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="397" to="434" />
			<date type="published" when="1979-12">Dec. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Acyclic hypergraphs&apos; Their recognition and top-down versus bottom-up generation</title>
		<author>
			<persName><forename type="first">D'atri</forename></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moscarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conslglio Nazlonale Delle Richerche, Istituto di Anahsl dei Sisteml ed Informauca</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="volume">29</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The decomposition versus the syntheUc approach to relational database design</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Conf. on Very Large Databases</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Larson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Freeman</surname></persName>
		</editor>
		<meeting>3rd Int. Conf. on Very Large Databases<address><addrLine>Tokyo, Japan; New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1977-06-08">Oct. 6-8, 1977. 1977. 1981</date>
			<biblScope unit="page" from="269" to="274" />
		</imprint>
	</monogr>
	<note>Also in Tutorial: Data Base Management m the 1980s</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A normal form for relaUonal databases that is based on domains and keys</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="387" to="415" />
			<date type="published" when="1981-09">Sept 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Horn clauses and database dependencies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 12th Ann. A CM Symp. on Theory of Computing</title>
		<meeting>12th Ann. A CM Symp. on Theory of Computing<address><addrLine>Los Angeles, Calif; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1980">Oct. 1982. Apr. 28-30, 1980. 1980</date>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="123" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A simphfied umversal relation assumption and its properties</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="343" to="360" />
			<date type="published" when="1982-09">Sept. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">AND SHMUELI, O Charactenzauons of tree database schemas</title>
		<author>
			<persName><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Harvard Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Shmueli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982-01">Jan 1982</date>
		</imprint>
	</monogr>
	<note>Private commumcauon</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Tree queries: A simple class of relaUonal queries</title>
		<author>
			<persName><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Shmlreh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="653" to="677" />
			<date type="published" when="1982-12">Dec. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On the universal relation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Gsasam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Univ. of Toronto</title>
		<imprint>
			<date type="published" when="1979-09">Sept. 1979</date>
			<pubPlace>Toronto, Ont., Can.</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech Pep</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Facts about CAG-C database schemas Unpubhshed manuscript</title>
		<author>
			<persName><forename type="first">M</forename><surname>Graham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981-09">Sept. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Testing satisfaction of functional dependencLes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Honeyman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J ACM</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="668" to="677" />
			<date type="published" when="1982-07">July 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Acychc jom dependency and database projections</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981-06">June 1981</date>
			<pubPlace>Los Angeles, Calif</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
	<note>Univ of Southern Calfforma</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">AND LINIAL, W Private commumcation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kleitman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982-08">Aug. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On the equivalence of database models</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. A CM</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="333" to="363" />
			<date type="published" when="1982-04">Apr. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Connections m acyclic hypergraphs</title>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Syrup. on Principles of Database Systems</title>
		<meeting>ACM Syrup. on Principles of Database Systems<address><addrLine>Los Angeles, Calif.; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1982">Mar. 29-31, 1982. 1982</date>
			<biblScope unit="page" from="34" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The revenge of the JD</title>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullmai~</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd ACM Symp. on Principles of Database Systems</title>
		<meeting>2nd ACM Symp. on Principles of Database Systems<address><addrLine>Atlanta, Ga.; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983">Mar 21-23, 1983. 1983</date>
			<biblScope unit="page" from="279" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Theory of relations for databases--A tutorial survey</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rissanen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Symp. on Mathematical Foundations of Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Winkowski</surname></persName>
		</editor>
		<meeting>7th Symp. on Mathematical Foundations of Computer Science<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Vedag</publisher>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="537" to="551" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Can we use the universal instance assumpuon without using nulls?</title>
		<author>
			<persName><forename type="first">Y</forename><surname>S^giv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. on Management of Data</title>
		<meeting>Int. Conf. on Management of Data<address><addrLine>Ann Arbor, Mich.; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1981-05-01">Apr. 29-May 1, 1981. 1981</date>
			<biblScope unit="page" from="108" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Simple hnear-time algonthms to test chordality of graphs, test acychcity of hypergraphs, and selecUvely reduce acyclic hypergraphs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Taioan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yai~nakakis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982-03">Mar. 1982</date>
			<pubPlace>Bell Labs, Murray Hill, N.J.</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The U.R. smkes back</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. on Principles of Database Systems</title>
		<meeting>ACM Symp. on Principles of Database Systems<address><addrLine>Los Angeles, Calif.; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1982">Mar. 29-31, 1982. 1982</date>
			<biblScope unit="page" from="10" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Algorithms for acyclic database schemes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yamaakaios</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 7th Int. Conf. on Very Large Databases</title>
		<meeting>7th Int. Conf. on Very Large Databases<address><addrLine>Cannes, France; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1982">Mar. 29-31, 1982. 1982</date>
			<biblScope unit="page" from="82" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Private commumcation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakards</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981-09">Sept. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">An algorithm for tree-query memberslnp of a distnbuted query</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">T</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Z</forename><surname>Ozsoyoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 1979 IEEE COMPSAC</title>
		<meeting>1979 IEEE COMPSAC<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="306" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Analysis and design of relational schemata for database systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976-07">July 1976</date>
			<pubPlace>Umv. of California, Los Angeles, Cahf</pubPlace>
		</imprint>
	</monogr>
	<note>Ph D. Dissertation. available as Tech. Rep UCLA ENG-7669</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">REVISED JULY 1982, ACCEPTED SEPTEMBER</title>
		<author>
			<persName><surname>Received December</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Assocmuon for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1981">1981. 1982. July 1983</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
