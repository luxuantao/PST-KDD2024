<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Checking and Inferring Local Non-Aliasing *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Alex</forename><surname>Aiken</surname></persName>
							<email>aiken@cs.berkeley.edu</email>
						</author>
						<author>
							<persName><forename type="first">Jeffrey</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
							<email>jfoster@cs.umd.edu</email>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Kodumal</surname></persName>
							<email>jkodumal@cs.berkeley.edu</email>
						</author>
						<author>
							<persName><forename type="first">Tachio</forename><surname>Terauchi</surname></persName>
							<email>tachio@cs.berkeley.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<settlement>College Park</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<address>
									<addrLine>June 9-11</addrLine>
									<postCode>2003</postCode>
									<settlement>San Diego</settlement>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Checking and Inferring Local Non-Aliasing *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BC198C98EE2ED11A52E5AE46373DAD97</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:08+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.1 [Software Engineering]: Requirements/Specifications</term>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features</term>
					<term>D.2.4 [Software Engineering]: Software/Program Verification</term>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs</term>
					<term>F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs Algorithms, Design, Reliability, Experimentation, Languages, Theory, Verification Restrict, confine, types, type qualifiers, alias analysis, effect inference, flow-sensitivity, constraints, locking, Linux kernel</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In prior work <ref type="bibr" target="#b14">[15]</ref> we studied a language construct restrict that allows programmers to specify that certain pointers are not aliased to other pointers used within a lexical scope. Among other applications, programming with these constructs helps program analysis tools locally recover strong updates, which can improve the tracking of state in flow-sensitive analyses. In this paper we continue the study of restrict and introduce the construct confine. We present a type and effect system for checking the correctness of these annotations, and we develop efficient constraint-based algorithms implementing these type checking systems. To make it easier to use restrict and confine in practice, we show how to automatically infer such annotations without programmer assistance. In experiments on locking in 589 Linux device drivers, confine inference can automatically recover strong updates to eliminate 95% of the type errors resulting from weak updates.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Almost all program analyses for languages with pointers must perform some form of alias analysis: when a program indirectly loads or stores through a pointer p, the analysis must determine to which location(s) p points. Alias analysis is a key ingredient in many program checking systems and compiler optimizations. The research literature abounds with proposed alias analysis techniques <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b29">30]</ref> (to name only a few), some of which scale to very large programs. Almost all of these techniques are fully automatic. That is, such an analysis takes a bare program and infers all possible aliasing.</p><p>This paper is about aliasing in programs, but the purpose is different from previous work on automatic alias analysis. Our motivation comes from experience developing and using CQUAL, a system for extending C with user-defined type qualifiers <ref type="bibr" target="#b14">[15]</ref>. Consider the partial program shown in Figure <ref type="figure" target="#fig_0">1</ref>. We use this example to tell a story, the moral of which is that we needed a new form of alias analysis to make CQUAL and similar analyses work in practice; that new form of alias analysis, previously sketched briefly <ref type="bibr" target="#b14">[15]</ref> and developed further here, is the topic of this paper.</p><p>One application of CQUAL is to verify properties of locking. CQUAL uses two non-standard, flow-sensitive (see below) type qualifiers locked and unlocked to refine the type lock. If all goes well in the example in Figure <ref type="figure" target="#fig_0">1</ref>, CQUAL infers that *l (the lock that l points to) has type unlocked lock at point 1 (i.e., the lock is not held), the type locked lock at point 2 (i.e., the lock is held), and the type unlocked lock at point 3. <ref type="foot" target="#foot_0">1</ref> In this way, CQUAL checks code for deadlocks caused by reacquiring a lock that is already held or releasing a lock that has not been acquired.</p><p>CQUAL models state by mapping every program variable v (or other concrete memory location) to an abstract location ρ. If two program quantities may alias each other (according to a particular alias analysis), they are mapped to the same abstract location. In the example, because our alias analysis cannot distinguish different elements of an array, all elements of the array reside at the same abstract location ρ. Similarly, l points to location ρ, meaning that *l is stored at location ρ, and thus both *l and all array elements may alias.</p><p>To analyze locking CQUAL performs a flow-sensitive analysis, which means that CQUAL must be able to assign *l different types at different points in the program. Assume that all locks in the array begin in the state unlocked lock. The call to spin lock(l) changes the state of *l to a locked lock. However, it is not *l's state that is changed, but the state of *l's abstract location ρ. But ρ stands for other locks, too-namely the other locks in the array, which are still in the unlocked state. Thus after the call to spin lock(l) the static information about ρ degrades to knowing only that any locks it represents may be either in the locked or the unlocked state, and the verification of any locking properties on any of these locks becomes impossible.</p><p>The difficulty is that the single abstract location ρ stands for multiple concrete locks, and the call to spin lock(l) only changes the state of a single lock. Thus the information about ρ after the call to spin lock(l) is the union of the old state (for the locks that did not change) and the new state (for the one lock that did change). In flow-sensitive analysis, this is known as a weak update. What we need for accurate analysis, though, is a strong update: we want to change the state of *l from unlocked to locked and not affect the status of any other lock. The need to perform strong updates is not specific to locks. This problem arises in any static analysis where there are both collections such as arrays or lists and we want to track state changes of values.</p><p>If we knew that do with lock could only access *l through its formal parameter l, and not through some alias it holds through, e.g., a global variable, then locally within do with lock we could ignore the aliases of *l external to do with lock and perform strong updates on *l's location <ref type="bibr" target="#b14">[15]</ref>.</p><p>The recent C99 standard for the C programming language <ref type="bibr" target="#b1">[2]</ref> provides a way to say almost exactly this. Change the definition of do with lock to void do_with_lock(lock *restrict l) At a high level, the restrict keyword means that no alias of *l defined outside of do with lock is used during the function's execution. Although there may be many aliases of l in the program, locally we know l is the only way for do with lock to access *l. This notion of locally unaliased pointers is missing from conventional flow-insensitive may-alias analysis, where pointers are either aliased or not and the only scope of interest is the entire program. Notice that while context-sensitive <ref type="bibr" target="#b23">[24]</ref> or parameterized <ref type="bibr" target="#b20">[21]</ref> alias analysis may help our do with lock example, we can also use restrict to indicate local non-aliasing within nested scopes smaller than function scopes. Indeed, we make use of this feature in our experiments (Section 7).</p><p>Another key feature of restrict is that it provides a form of program documentation: it allows the programmer to specify a particular kind of non-aliasing. Combined with a checking system such as we propose, we believe that restrict is not only beneficial for tools like CQUAL, but also for the programmer when writing their program.</p><p>In C, restrict is trusted and unchecked by the compiler-it amounts to a license for compilers to perform aggressive optimizations that would be unsound in the presence of aliases. We believe restrict is even more useful in program checking tools, and not just for C programs, but for programs written in any language with references. While there are important exceptions, such as functions that copy data or pointers, we believe many pointers in practice can be marked restricted.</p><p>The thesis of this paper is that restricted references are common in real programs, and that exploiting this (usually implicit) structure is important to software engineering tools such as CQUAL that need to reason about references. More specifically, the contributions of this paper are:</p><p>• We develop a formal semantics of restrict (Section 3.2) and also present an informal description and examples (Section 2).</p><p>• We give a type and effect system <ref type="bibr" target="#b21">[22]</ref> for checking that a restrict-annotated program is correct with respect to our semantics (Section 3).</p><p>• We give a O(kn) constraint-based algorithm for verifying restrict annotations, where n is the size of the typed program and k is the number of restrict annotations in the program. The type system for restrict is described briefly in prior work <ref type="bibr" target="#b14">[15]</ref>, but this is the first description of the type checking algorithm (Section 4).</p><p>• In using CQUAL we have found it necessary to add many more restrict annotations to programs than we would like to do by hand. This motivates the idea of restrict inference: not just checking user-supplied restrict annotations, but automatically inferring restricts in a program with no restrict annotations. We give an O(n 2 ) algorithm for restrict inference (Section 5).</p><p>• Furthermore, in many applications we wish to restrict not just a variable, but an expression. This extension of restrict introduces two new problems. First, to treat an arbitrary expression as a name, it must be referentially transparent, which introduces additional constraints beyond what is required for restrict. We call this stronger condition confining an expression and likewise name the associated construct confine. Second, for confine inference we have the additional problem of inferring in what scope an expression can be confined (Section 6).</p><p>• We present the results of experiments with confine inference, in which we use CQUAL to analyze the locking behavior of 589 Linux device drivers. In this experiment, confine is very effective at identifying the program points where strong updates can aid the analysis (Section 7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RESTRICT</head><p>This section gives an informal semantics of restrict and several examples. Section 3.2 sketches a precise, formal semantics of restrict. Let p be a pointer declared as int *restrict p; meaning that p is a restricted pointer to an integer, and suppose p points to object X. The simplest use of restrict is to bind a new name p for all accesses of X in a local scope. Here an access within a scope is either a direct access or an access that occurs during the execution of a function called within that scope. The following example demonstrates valid and invalid pointer dereferences within the scope of a restrict: { int *restrict p = q; *p; // valid *q; // invalid *a; // invalid if a and q may alias } Here p is initialized to q, and we attempt to dereference p, q, and a within the scope of p. Since p is annotated with restrict, we may dereference p but we may not dereference q or a (if a aliases q). In other words, within the scope of the restrict, the name p (and copies derived from p; see below) must be the sole access to the location p points to.</p><p>As another example, the following code shows that restrictqualified pointers may be re-bound in an inner scope: Here we are allowed to make copies of the restricted pointer p, which we can also dereference inside of the restrict.</p><formula xml:id="formula_0">{ int *</formula><p>Intuitively, annotating the definition of p with restrict splits the aliases of p into two groups:</p><p>• Aliases of p created outside scope of the restrict may be accessed outside the restrict but not inside.</p><p>• p and aliases of p created inside the scope of the restrict may be accessed within the scope of the restrict but not outside.</p><p>In most uses of restrict, only the restricted pointer itself is used to reference storage it points to inside the restrict construct. In this common case, restrict serves to create a local pointer that is known to be the sole access to its storage in a particular scope. However, there is no difficulty in supporting copies of restricted pointers as in the example above. The requirement that aliases created inside the restrict not be used outside of the restrict means that we must check that no aliases of the restricted pointer escape the scope of the restrict. Thus the assignment to x is illegal in the example above and would be flagged as an error by our system. References can also escape by being stored into the heap or global variables; our system disallows such operations on restricted pointers. While we have found that preventing restricted pointers from escaping sufficient so far, one can imagine applications where allowing restricted pointers to leave their original scope of definition might be useful. We plan to consider such an extension as future work.</p><p>As mentioned in the introduction, our version of restrict is inspired by the ANSI C keyword of the same name <ref type="bibr" target="#b1">[2]</ref>. The major difference between our version of restrict and ANSI C's is that in ANSI C restrict is not checked-the programmer is assumed to have added the restrict qualifier correctly. Another difference is that in ANSI C, a restrict annotation on a pointer p is ignored if the object pointed to by p is not written within the scope of the restrict. For a full discussion, see <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">LANGUAGE AND TYPE CHECKING</head><p>We present our type system for restrict using a small imperative language: For simplicity, we have omitted function definitions and calls from the language. The treatment of functions is standard and introduces no new issues; we omit it for brevity. Statement sequencing e1; e2 is also not present in the language, but is easily added with no complications. A discussion of the language extended with functions, as well as a detailed proof of soundness, can be found elsewhere <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>. Besides variables, integers, pointer allocation new e, dereference * e, and assignment, our language has two mechanisms for introducing local variables. The first is let x =e1 in e2, which simply initializes a new pointer variable x to e1 for use in e2. There is also a new scoping construct restrict x =e1 in e2 with the following meaning: like let, the pointer x is initialized to e1 and bound within the body e2. However, unlike let, within e2 the only access to the location x points to is through x or values derived from x.</p><formula xml:id="formula_1">e ::= x Variable | n</formula><p>To enforce the semantics of restrict, our type system needs two extensions of standard types. First, we need a way to keep track of program names that may be aliased to one another. We use the standard solution, which is to associate abstract memory locations ρ with pointer types. Names that have the same abstract location in their types may be aliased to the same concrete memory location. The grammar for types is:</p><formula xml:id="formula_2">τ ::= int | ref ρ (τ )</formula><p>Pointer types are ref ρ (τ ), meaning a pointer to a value of type τ where ρ is the abstract location pointed to.</p><p>Second, we need to enforce the rule that a location ρ0 may not be accessed within the body e of a restrict. To accomplish this, we calculate the set of abstract locations Le that e may read or write and check ρ0 ∈ Le. The set Le is called the effect of e <ref type="bibr" target="#b15">[16]</ref>. The grammar for effects is:</p><formula xml:id="formula_3">L ::= ∅ | {ρ} | L1 ∪ L2 | L1 ∩ L2 Γ e1 : ref ρ (τ1); L1 Γ[x → ref ρ (τ1)] e2 : τ2; L2 ρ ∈ L2 ρ ∈ locs(Γ, τ1, τ2) Γ restrict x =e1 in e2 : τ2; L1 ∪ L2 ∪ {ρ} (Restrict)</formula><p>Figure <ref type="figure">2</ref>: Type Checking Rules meaning that expression e has type τ in type environment Γ (a mapping of variables to types), and the evaluation of e may read or write the locations in L. We define locs(Γ) as x:τ ∈Γ locs(τ ).</p><p>Figure <ref type="figure">2</ref> gives the type checking rules for our language. We briefly discuss the rules, which except for restrict are all typical of effect systems.</p><p>• (Var) looks up the type of a variable in the type environment Γ. Looking up a pointer variable does not dereference that variable and thus has no effect.</p><p>• (Int) says an integer constant has type int. There is no effect.</p><p>• (Ref) constructs a pointer type; there is an effect on the allocated location.</p><p>• (Deref) deconstructs a pointer type. Since operationally a dereference reads a location, we add ρ, the abstract location pointed to by e, to the effect set.</p><p>• (Assign) updates a location. As with (Deref), we add ρ to the effect set, since the assignment updates e1. Notice we require that the type of e2 and the type pointed to by e1 match. Since those types may themselves contain abstract locations, this rule encodes a unification-based may-alias analysis Steensgaard <ref type="bibr" target="#b25">[26]</ref>.</p><p>• (Let) does two things. First, let introduces a local variable x. The type of x is required to be a pointer. This restriction just makes let parallel with restrict in our small language (restrict only makes sense for pointers). Second, let evaluates both e1 and e2; note that the effect of the let is the union of the effects of these two expressions.</p><p>The key rule in this system is (Restrict). The rule is written to highlight the similarities and differences with the rule for let, which introduces normal unrestricted pointers. There are four differences:</p><p>• Recall the semantics of restrict x =e1 in e2 states that x is a pointer to a copy of the location pointed to by e1 (Section 2). This naturally suggests giving x a type with a fresh abstract location ρ during the evaluation of e2. With this binding we can distinguish accesses through x or copies of x, which have an effect on location ρ , from accesses through other aliases of e1, which have an effect on location ρ.</p><p>• The constraint ρ ∈ L2 prevents other aliases of e1 from being accessed within e2.</p><p>• The constraint ρ ∈ locs(Γ, τ, τ2), prevents the new location for x from escaping the scope of e2. Consider:</p><formula xml:id="formula_4">let x = new 0 in let p = . . . in (restrict q = x in p := q; /* 1 */ restrict r = x in **p)</formula><p>Suppose x has type ref ρx (int). By (Restrict), the types of q and x can contain different abstract locations. Let q's type be ref ρq (int), where ρx = ρq. Now if the clause ρ ∈ locs(Γ, τ, τ2) were not included in (Restrict), the assignment p := q would type check. At program point 1, we would have two different names for the same location-ρq and ρxeven though neither is restricted. Thus the dereference **p would type check even though the program is incorrect. We forbid ρ from escaping in (Restrict) to prevent this problem.</p><p>• Finally, notice that the conclusion of (Restrict) contains the effect {ρ}, i.e., restricting a location is itself an effect. This forbids sneaky programs such as:</p><formula xml:id="formula_5">restrict y = x in restrict z = x in . . . *y . . . *z . . .</formula><p>If restricting a location had no effect on that location, it would be possible to restrict the same name twice and have both restricted names available for use in the same scope.</p><p>While the type and effect system presented here is built upon a unification-based alias analysis, restrict (and restrict checking) can also be combined with more precise alias analyses. We have not yet explored this possibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Removing Effects</head><p>This section details a kind of polymorphism that we have found to be important for effectively checking restrict annotations in programs. Consider a generic sentence in our logic Γ e : τ ; L. In practice, surprisingly often it happens that the effect L contains locations that are not mentioned either in the type τ or the environment Γ. The cause of this seemingly odd behavior is easy to see: e may have subexpressions that allocate temporary storage and have effects on that storage. No rule in Figure <ref type="figure">2</ref> removes locations from the effect of an expression, so effects simply grow as we move from the leaves to the root of the abstract syntax tree. This behavior is not benign. In recursive functions, these extra locations appear to be in both the effect of recursive calls and the effect of the body of the function, resulting in more locations being equated than should be and frequently causing restrict checking to fail.</p><p>We need a rule that removes effects:</p><formula xml:id="formula_6">Γ e : τ ; L Γ e : τ ; L ∩ locs(Γ, τ )<label>(Down)</label></formula><p>(Down) states that effects on locations that are no longer in useneither part of the result computed by an expression, nor accessible through the environment-can be removed from the effect set <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b21">22]</ref>. Note that the rule (Down) is the one non-syntactic rule in our system. We can construct a purely syntax-directed version of our system by observing that two applications of (Down) in a row always can be combined into one. Thus, we can assume there is one application of (Down) for each expression in the program. In fact, it is unprofitable to apply (Down) anywhere except before the rule for functions (which, again, we have not shown). Combining these observations yields a syntax-directed system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Semantics and Soundness</head><p>In this section we give a very brief sketch of the semantics and soundness of restrict. Our big-step operational semantics is formulated to prove judgments of the form S e → v; S , meaning that evaluating e starting in initial store S (a map from locations l to values, which may themselves be locations) yields a value v and a (possibly updated) final store S . Here a value v is either a location l or an integer n (or a function binding, if that were in our source language). We model restrict in our semantics using the following rule:</p><formula xml:id="formula_7">S e1 → l; S S [l → err, l → S (l)] e2[x → l ] → v, S l ∈ dom(S ) l ∈ dom(S ) S restrict x =e1 in e2 → v; S [l → S (l ), l → err]</formula><p>This rule uses copying to enforce restrict's semantics. To evaluate restrict x =e1 in e2, we first evaluate e1 normally, which must yield a pointer l. Within the body of e2, the only way to access what l points to should be via the particular value that resulted from evaluating e1. We enforce this by allocating a fresh location l initialized with the contents of l, and then binding l to err to forbid access through l. The remainder of our semantics (not shown) is strict in err, and any computation that goes wrong reduces to err (rather than becoming stuck). Thus, any program that tries to read or write l within e2 will reduce to err. The soundness of our checking system (see below) implies that no program evaluates to err, which in turn implies that an implementation can safely optimize restrict by eliding the copy of l. Instead, in an implementation restrict simply binds x to l.</p><p>Notice that it is not an error to use the value l within e2, but only to dereference it. After e2 has been evaluated, we re-initialize l to point to the value x points to, and then forbid accesses through l . Forbidding access through l corresponds to the requirement in the type rule (Restrict) that ρ not escape. (An alternative formulation, which we leave to future work, is to rename occurrences of l to l after e2 finishes.)</p><p>We can show soundness in the usual way via a subject reduction theorem that shows that the type of an expression is preserved by evaluation. Then since err has no type, a program that starts off well-typed can never reduce to err: THEOREM 1 (SOUNDNESS). If ∅ e : t; L and ∅ e → r; S , then r is not err.</p><p>Here r is either a value or err (all terminating programs reduce to one or the other). In other words, in a program that type checks, no use of restrict is found to be invalid at run time. </p><formula xml:id="formula_8">Γ, εΓ x : Γ(x); ∅ (Var) Γ, εΓ n : int; ∅ (Int) Γ, εΓ e : τ ; L ρ fresh ετ ∪ {ρ} ⊆ ε ref ρ (τ ) Γ, εΓ new e : ref ρ (τ ); L ∪ {ρ} (Ref) Γ, εΓ e : ref ρ (τ ); L Γ, εΓ * e : τ ; L ∪ {ρ} (Deref) Γ, εΓ e1 : ref ρ (τ1); L1 Γ, εΓ e2 : τ2; L2 τ1 = τ2 Γ, εΓ e1 := e2 : τ1; L1 ∪ L2 ∪ {ρ} (Assign) Γ, εΓ e : τ ; L Γ, εΓ e : τ ; L ∩ (εΓ ∪ ετ ) (Down) Γ, εΓ e1 : ref ρ (τ1); L1 Γ , ε Γ e2 : τ2; L2 Γ = Γ[x → ref ρ (τ1)] εΓ ∪ ε ref ρ (τ 1 ) ⊆ ε Γ Γ, εΓ let x =e1 in e2 : τ2; L1 ∪ L2 (Let) Γ, εΓ e1 : ref ρ (τ1); L1 Γ , ε Γ e2 : τ2; L2 Γ = Γ[x → ref ρ (τ1)] ετ 1 ∪ {ρ } ⊆ ε ref ρ (τ 1 ) εΓ ∪ ε ref ρ (τ 1 ) ⊆ ε Γ ρ ∈ L2 ρ ∈ εΓ ∪ ετ 1 ∪ ετ 2 Γ, εΓ restrict x =e1 in e2 : τ2; L1 ∪ L2 ∪ {ρ} (Restrict)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ALIAS AND EFFECT INFERENCE</head><p>We now give an algorithm for checking restrict annotations according to the type rules in Figure <ref type="figure">2</ref> together with the rule (Down). The algorithm we give is sound and complete; if there is a proof that a restrict-annotated program is correct according to Figure <ref type="figure">2</ref>, the algorithm finds it.</p><p>We assume that the programmer has written their program using restrict and that the program type checks according to the standard type rules of the language. Figure <ref type="figure" target="#fig_1">3</ref> gives inference rules that show how to compute the remaining missing elements, namely the locations and effects needed at each point. As is standard, for inference we transform the conditions in the type checking rules into a system of constraints that can be solved if and only if there is some proof according to the rules in Figure <ref type="figure">2</ref>. We first discuss the constraints and some details of the inference algorithm, and then we describe the individual type rules.</p><p>Our rules generate three kinds of constraints C: equality constraints between types, inclusion constraints between effects, and disinclusion constraints between locations and effects:</p><formula xml:id="formula_9">C ::= τ1 = τ2 | L ⊆ ε | ρ ∈ L τ ::= int | ref ρ (τ ) L ::= ∅ | {ρ} | ε | L1 ∪ L2 | L1 ∩ L2</formula><p>Here ε is an effect variable, which stands for an unknown set of locations. Notice that inclusion constraints between effects are of the special form L ⊆ ε, which makes these constraints particularly easy to solve.</p><p>An important algorithmic consideration is how we compute the sets of locations locs(τ ) and locs(Γ) required by the type checking rules (Restrict) and (Down). We want to avoid repeatedly traversing type structures τ and type environments Γ at each point in the program-a program with O(n) expressions may have (monomorphic) types of size O(n) and environments Γ with O(n) variables, and thus this part of the algorithm alone would likely be at least quadratic.</p><p>Our solution is to memoize the computation of locs(•). Recall that effects are sets of locations. We associate an effect variable ετ with each type τ , and we maintain this association with an implicit global mapping. As we construct new types, e.g., in (Ref), we generate constraints to represent the locations in the new types:</p><formula xml:id="formula_10">ετ ∪ {ρ} ⊆ ε ref ρ (τ )</formula><p>Then in the type inference rules, instead of locs(τ ), we use ετ , e.g., in (Down).</p><p>Similarly, we observe that the type environment is empty at the root of the proof tree and then is only incrementally modified for each subexpression. If we know the set of locations in an environment at an expression e, we can incrementally compute the set of locations in the environments at each of e's subexpressions. We use effect variables εΓ to contain the set of locations occurring in environment Γ. Where we extend environment Γ with a new binding x → τ in (Let) and (Restrict), we generate a constraint</p><formula xml:id="formula_11">εΓ ∪ ετ ⊆ ε Γ[x →τ ]</formula><p>Thus we succinctly capture locs(Γ[x → τ ]) without recomputing locs(Γ). Because the variables εΓ must be communicated between adjacent steps of the proof, they are included as part of the environment (to the left of the turnstile ) in the rules of Figure <ref type="figure" target="#fig_1">3</ref>.</p><p>We briefly discuss the type inference rules in Figure <ref type="figure" target="#fig_1">3</ref>. We assume that type checking has already been carried out for the underlying standard types of the language, and that these types are given to us. That is, we do not infer the standard types.</p><p>• (Var), (Int), and (Deref) are identical to the type checking rules except for the addition of εΓ to the left of the turnstile.</p><p>• (Ref) and (Assign) are written with explicit fresh variables and equality constraints between types where needed.</p><p>• (Down) is similar to its type checking rule, except we use the variable εΓ in place of locs(Γ) and ετ in place of locs(τ ).</p><p>Notice the use of our implicit global mapping of τ to ετ .</p><p>• (Let) differs in one significant way from its type checking rule. The set of locations ε Γ of Γ is taken to be the union of the locations of Γ (which is εΓ) and the locations in ref ρ (τ1).</p><p>• (Restrict) differs from (Let) in the following ways.</p><p>-The variable x is given a type with the new location ρ , and ρ instead of ρ is included in the set of locations ε Γ of environment Γ .</p><p>-A check ensures that ρ does not appear in the effect L2 of e2.</p><p>-A check ensures that ρ does not escape.</p><p>-There is an extra effect on ρ in the effect of the whole expression.</p><p>Let n be the size of the initial program with its standard types. Applying the inference rules in Figure <ref type="figure" target="#fig_1">3</ref> takes O(n) time and generates a system of constraints C of size O(n). We split the resolution of the side constraints C into two phases, shown as left-toright rewrite rules in Figure <ref type="figure" target="#fig_2">4</ref>. First, we solve the type equality constraints τ1 = τ2 using the rules in Figure <ref type="figure" target="#fig_2">4a</ref>. Because we assume checking of the standard types has already been done, the type equality rules can never discover an inconsistency. However, the type equalities must still be solved to discover all implied constraints between ρ and ε variables. This step requires O(n) time.</p><formula xml:id="formula_12">C ∪ {int = int} ⇒ C C ∪ {ref ρ 1 (τ1) = ref ρ 2 (τ2)} ⇒ C ∪ {ρ1 = ρ2} ∪ {τ1 = τ2} C ∪ {ρ1 = ρ2} ⇒ C[ρ1 → ρ2] C ∪ {ε1 = ε2} ⇒ C[ε1 → ε2] (a) Type Equality C ∪ {ρ ∈ L} ⇒ C ∪ {ρ ∈ ε} ∪ {L ⊆ ε} ε fresh C ∪ {∅ ⊆ ε} ⇒ C C ∪ {L1 ∪ L2 ⊆ ε} ⇒ C ∪ {L1 ⊆ ε} ∪ {L2 ⊆ ε} C ∪ {∅ ∩ L ⊆ ε} ⇒ C C ∪ {L ∩ ∅ ⊆ ε} ⇒ C C ∪ {(L1 ∪ L2) ∩ L ⊆ ε} ⇒ C ∪ {ε ∩ L ⊆ ε} ∪ {L1 ∪ L2 ⊆ ε } ε fresh C ∪ {L ∩ (L1 ∪ L2) ⊆ ε} ⇒ C ∪ {L ∩ ε ⊆ ε} ∪ {L1 ∪ L2 ⊆ ε } ε fresh (b) Constraint Normalization</formula><p>The resulting constraints are of the form L ⊆ ε and ρ ∈ L. We call such a system of constraints an effect constraint system. A solution to an effect constraint system C is a mapping σ from effect variables to sets of locations such that σ(L) ⊆ σ(ε) and ρ ∈ σ(L) for each constraint L ⊆ ε and ρ ∈ L in C, where we extend σ from effect variables to arbitrary effects in the natural way. An effect constraint system is satisfiable if it has a solution. Notice that abstract locations are not in the domain of σ-intuitively, after discovering all equalities between locations after applying the rules in Figure <ref type="figure" target="#fig_2">4a</ref>, we can treat abstract locations as constants.</p><p>We define a partial order on solutions, σ ≤ σ iff for every effect variable ε we have σ(ε) ⊆ σ (ε). The least solution to an effect constraint system is the solution σ such that σ ≤ σ for any other solution σ . If an effect constraint system C has any solution, then C has a least solution <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>.</p><p>To test satisfiability of an effect constraint system, we first apply the rules in Figure <ref type="figure" target="#fig_2">4b</ref> to translate the constraints into the following normal form:</p><formula xml:id="formula_13">C ::= L ⊆ ε | ρ ∈ ε L ::= M | M ∩ M M ::= {ρ} | ε</formula><p>Notice that the rules in Figure <ref type="figure" target="#fig_2">4b</ref> preserve least solutions but not arbitrary solutions. Also notice that in Figure <ref type="figure" target="#fig_2">4b</ref> we do not consider the case (L1 ∩ L2) ∩ L ⊆ ε or L ∩ (L1 ∩ L2) ⊆ ε. Such constraints are never generated once (Down) is merged into the rule for functions (not shown). Applying the rules in Figure <ref type="figure" target="#fig_2">4b</ref> takes time O(n).</p><p>We view the inclusion constraints in a normal form effect con-</p><formula xml:id="formula_14">CHECK-SAT(ρ ∈ ε): Associate Count(v) with each node v in the graph Initialize Count(v) = 0 for all v Let W = {ρ}, the set of nodes left to visit While W is not empty Remove some node v from W If v == ε return unsatisfiable For each edge v → ε If Count(ε ) == 0 then Count(ε ) = 1 Add ε to W For each edge v → I If Count(I) == 0 then Count(I) = 1 Else if Count(I) == 1 then Count(I) = 2</formula><p>Add I to W Return satisfiable Figure <ref type="figure">5</ref>: Checking satisfiability of ρ ∈ ε straint system as a directed graph:</p><formula xml:id="formula_15">Constraint Edge(s) {ρ} ⊆ ε ρ → ε ε1 ⊆ ε2 ε1 → ε2 M1 ∩ M2 ⊆ ε M1 → I M2 → I I → ε I fresh</formula><p>The nodes of the directed graph are abstract locations ρ (with indegree 0), effect variables ε (with arbitrary in-degree), and intersections I (with in-degree 2). We generate a fresh I node for each constraint M1 ∩ M2 ⊆ ε.</p><p>Given a normal form effect constraint system, we test satisfiability by checking, for each constraint ρ ∈ ε, whether ρ ∈ σ(ε) in the least solution σ. Figure <ref type="figure">5</ref> shows the modified depth-first search we use to check this condition. The algorithm in Figure <ref type="figure">5</ref> takes time O(n) for each ρ ∈ ε constraint. Given an initial program with k occurrences of restrict, the system considered in Figure <ref type="figure">5</ref> has O(k) constraints of the form ρ ∈ ε. Hence the time for this step is O(kn), which is also the total time for the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RESTRICT INFERENCE</head><p>The type checking algorithm of the previous section checks usersupplied restrict annotations. In practice, however, many such annotations may be necessary to give the quality of aliasing information needed for other analyses, and adding these annotations by hand can be very time-consuming. In this section we give an algorithm for automatically adding restrict to a program. More precisely, we show how to automatically decide whether a binding construct should be let or restrict. A bit surprisingly, our type rules always admit a unique maximum set of let expressions that can be restricted. Our inference algorithm computes this optimal annotation of the program.</p><p>As we have observed, let and restrict differ only in a few ways. Our approach is to combine the inference rules (Let) and (Restrict) into a single rule (Let-or-Restrict), corresponding to a new construct let-or-restrict x =e1 in e2, with two properties. First, in any solution of the constraints, (Let-or-Restrict) satisfies the requirements of exactly one of the (Let) or (Restrict) rules. Second, (Let-or-Restrict) "prefers" the (Restrict) solution: if the constraints have any solution satisfying the requirements of (Restrict), then that will be the least solution.</p><p>Recall that restrict has four differences from let. We consider each of these in turn. First, a restrict uses two locations ρ and ρ where let has only ρ. Thus, our inference rule should begin by assuming ρ and ρ are distinct (the restrict case), and if it turns out that the expression cannot be a restrict, the locations should be unified (ρ = ρ , the let case).</p><p>Second, there are two negative constraints</p><formula xml:id="formula_16">ρ ∈ L2 ρ ∈ εΓ ∪ ετ 1 ∪ ετ 2 in restrict.</formula><p>If either of these is unsatisfiable, then the expression must be a let. We can combine this with the reasoning above to yield the following constraints:</p><formula xml:id="formula_17">ρ ∈ L2 ⇒ ρ = ρ ρ ∈ (εΓ ∪ ετ 1 ∪ ετ 2 ) ⇒ ρ = ρ</formula><p>These constraints say that if either the old location ρ is used in the body of the construct, or the new location ρ escapes, then the locations must be equal and the construct is a let. We have not seen such conditional constraints before in this paper. These constraints are easy to solve, though we omit the details here.</p><p>Finally, there is the extra effect on ρ in the result of restrict. If the expression is a restrict we must have the effect, and if it is a let we must not. Given the semantics of restrict we have used so far, we do not know how to model this choice efficiently. However, if we interpret restrict a little more liberally, an efficient solution is straightforward.</p><p>Consider the construct let-or-restrict x =e1 in e2, which will behave either as restrict or let. If e2 has an effect on ρ , we are done: if it is a restrict there is an effect on ρ and if it is a let there is also an effect on ρ because ρ = ρ . What if e2 has no effect on ρ ? In that case, we do not need to require that restrict have an effect on ρ! Recall from the example in Section 3 that the extra effect is needed to prevent ρ from being restricted twice and both restricted pointers used simultaneously. If a restricted pointer is not used at all, there is no need to prevent it from being restricted a second time in the same scope. <ref type="foot" target="#foot_2">2</ref> These two cases (e2 does or does not have an effect on ρ ) can be combined in one additional conditional constraint</p><formula xml:id="formula_18">(ρ ∈ L2) ⇒ {ρ} ⊆ ε</formula><p>where L2 is the effect of e2 and ε is included in the effect of the entire expression.</p><p>Putting everything together, we have the following inference rule:</p><formula xml:id="formula_19">Γ, εΓ e1 : ref ρ (τ1); L1 Γ , ε Γ e2 : τ2; L2 Γ = Γ[x → ref ρ (τ1)] ετ 1 ∪ {ρ } ⊆ ε ref ρ (τ 1 ) εΓ ∪ ε ref ρ (τ 1 ) ⊆ ε Γ ρ ∈ (εΓ ∪ ετ 1 ∪ ετ 2 ) ⇒ ρ = ρ ρ ∈ L2 ⇒ ρ = ρ ρ ∈ L2 ⇒ {ρ} ⊆ ε ρ, ρ , ε fresh Γ, εΓ let-or-restrict x =e1 in e2 : τ2; L1 ∪ L2 ∪ ε</formula><p>This new rule, which replaces (Let) and (Restrict), allows us to infer restrict annotations. It is easy to check that these constraints have a least solution, which guarantees the existence of an optimal annotation of a program with restrict.</p><p>A straightforward implementation of this inference rule gives a quadratic time algorithm. Given a typed program of size n, there are O(n) possible locations and O(n) constraints. Computing initial reachability in the constraint graph (without the conditional constraints) for all O(n) locations using the algorithm in Figure <ref type="figure">5</ref> takes O(n 2 ) time. We maintain a work-list of conditional constraints whose left-hand side has become true. For each conditional constraint on our work-list, we perform O(n) extra work to recompute reachability for the unified locations (or to recompute reachability for the location ρ in the constraint {ρ} ⊆ ε). Since there are O(n) possible total unifications, and each may trigger O(n) work, the overall complexity is O(n 2 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONFINE</head><p>Recall that, as in the code in Figure <ref type="figure" target="#fig_0">1</ref>, many realistic examples where restrict-like functionality is useful involve values held in containers. Unlike Figure <ref type="figure" target="#fig_0">1</ref>, however, in practice programs often do not include an explicit variable to restrict. For example, consider</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>spin_lock(&amp;locks[i]); work(); spin_unlock(&amp;locks[i]);</head><p>Assuming that work() does not modify i or access any other elements of the array locks, we can rewrite this code using restrict to allow a checker like CQUAL to analyze this code:</p><formula xml:id="formula_20">restrict x = &amp;locks[i] in { spin_lock(x); work() spin_unlock(x); } (*)</formula><p>While this is effective, implementing this transformation by hand is tedious, not only because we must introduce a new name and manually perform a substitution, but also because we must discover the scope of the restrict and check that the restricted expression refers to the same object throughout the body. For instance, in this case, we must notice that there are two occurrences of &amp;locks[i] in the code that refer to the same object, and then we must put the scope of the new variable that names the lock around both uses. Note that in the system described in Section 5 we only infer restrict for variables, which come with an obvious scope.</p><p>Editing a program to add a few restrict annotations is not difficult; the problem is that in practice there are many restrict annotations to add, and many involve expressions. In our experience, the manual labor required to introduce local variables for all of those expressions is just too much. Our solution is to introduce a new construct, confine, that deals specifically with restricting the aliases of expressions. The syntax is confine e 1 in e2 meaning that aliases of the location e1 refers to are restricted in the scope e2. (Note that our use of the word confine is not related to the term as used in object-oriented alias control systems <ref type="bibr" target="#b27">[28]</ref>.) The expression e1 itself serves as the name for the restricted location. Assuming all program variables have been renamed to be distinct, we define confine syntactically by translation to restrict:</p><formula xml:id="formula_21">confine e 1 in(e2[e1/x]) = restrict x =e1 in e2</formula><p>where x is a fresh variable that is substituted for occurrences of e1 in e2. For nested confines, the translation must be done innermost-first. For instance, the example above would be written:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>confine (&amp;locks[i]) in { spin_lock(&amp;locks[i]); work(); spin_unlock(&amp;locks[i]); }</head><p>and this is defined to be equivalent to (*) above. Notice that with confine we do not need to rewrite the body of the restricted scope-we need only wrap an appropriate confine around it.</p><p>Our goal is to perform confine inference-to automatically place confines in the program. Intuitively, confine inference corresponds to performing a kind of common sub-expression elimination that handles aliasing and then applying restrict inference. There are two issues:</p><p>• Referential transparency. For the definition given above of confine in terms of restrict to make sense, an expression that is confined must truly behave like a name within the scope of the confine. An expression behaves like a name in a scope only if it is referentially transparent within that scope<ref type="foot" target="#foot_3">3</ref> -if it in fact always evaluates to the same value.</p><p>• Inferring scopes. As mentioned above, we must determine the scope for a confine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Referential Transparency</head><p>Consider an expression confine e 1 in e2. To enforce referential transparency of e1 within the scope of e2, we must first ensure that e1 terminates. Our solution is to simply forbid e1 from containing a function application, and indeed for the experiment described in Section 7 we are interested only in e1's that are composed of identifiers, field accesses, and pointer dereferences.</p><p>To enforce referential transparency, we must also be certain that neither e1 nor e2 modify any of the locations e1 needs during its evaluation-locations used by e1 must only be read within e1 and e2. To accomplish this we must extend our notion of effect. For a given location ρ, we now distinguish effects read(ρ) (reads of location ρ), write(ρ) (writes to location ρ), and alloc(ρ) (allocation of location ρ). Our rules now have two different kinds of sets: sets S of locations (as before) and sets L of read, write, and alloc effects on locations. For clarity, we separate these two kinds of sets and use variables π for sets of read, write, and alloc effects, and variables ε for sets of locations. The grammars for sets are now:</p><formula xml:id="formula_22">L ::= ∅ | {read(ρ)} | {write(ρ)} | {alloc(ρ)} | π | L1 ∪ L2 | L1 ∩ L2 S ::= ∅ | {ρ} | ε | S1 ∪ S2 | S1 ∩ S2</formula><p>All inference rules must be modified to correctly report read, write, and allocation effects on locations; we omit the details due to space constraints. We also need to introduce a new kind of effectful variable xL, which is typechecked just like a regular variable x, except that evaluating xL has effect L:</p><formula xml:id="formula_23">Γ, εΓ xL : Γ(x); L (VarL)</formula><p>Intuitively, we could also model xL as a thunk if the language used in this paper contained functions. We discuss the use of effectful variables xL below.</p><p>To perform type inference for confine e 1 in e2, we modify let-or-restrict for use with confine:</p><p>Γ, εΓ e1 :</p><formula xml:id="formula_24">ref ρ (τ1); L1 Γ , ε Γ e2[x π /x] : τ2; L2 Γ = Γ[x → ref ρ (τ1)] ετ 1 ∪ {ρ } ⊆ ε ref ρ (τ 1 ) εΓ ∪ ε ref ρ (τ 1 ) ⊆ ε Γ ρ ∈ (εΓ ∪ ετ 1 ∪ ετ 2 ) ⇒ (ρ = ρ ∧ L1 ⊆ π ) X(ρ) ∈ L2 ⇒ (ρ = ρ ∧ L1 ⊆ π ) X(ρ ) ∈ L2 ⇒ {X(ρ)} ⊆ π ∀ρ .write(ρ ) ∈ L1 ⇒ (ρ = ρ ∧ L1 ⊆ π ) ∀ρ .alloc(ρ ) ∈ L1 ⇒ (ρ = ρ ∧ L1 ⊆ π ) ∀ρ .read(ρ ) ∈ L1 ⇒ (write(ρ ) ∈ L2 ⇒ (ρ = ρ ∧ L1 ⊆ π )) ∀ρ .read(ρ ) ∈ L1 ⇒ (alloc(ρ ) ∈ L2 ⇒ (ρ = ρ ∧ L1 ⊆ π )) ρ, ρ , π, π fresh Γ, εΓ confine? e 1 in e2[e1/x] : τ2; L1 ∪ L2 ∪ π</formula><p>The name confine? is meant to be suggestive of an "optional confine." This rule chooses whether to insert confine based on the solution of the constraints (if ρ = ρ and L1 ⊆ π there is a confine, otherwise there is not). The easiest way to understand this rule is to compare it with the inference rule for let-or-restrict (Section 5). The first line of the two rules is identical. In the second line, we bind x as before, and we replace x in e2 with an effectful variable x π . Recall that in e2, occurrences of e1 have been replaced by x. If inserting confine succeeds, π = ∅ in the least solution of the constraints, so x π is equivalent to x. In other words, if inserting confine succeeds, then we replace occurrences of the common sub-expression e1 by x. But if inserting confine fails (for reason) then the constraint L1 ⊆ π will be generated, and therefore in this case when typechecking e2 we will give each occurrence of x both e1's type and e1's effect. Thus, if inserting confine fails, we do not eliminate common sub-expression e1.</p><p>The third and fourth line of our rule for confine? are as in our rule for let-or-restrict, with the addition of the constraint L1 ⊆ π . In the next two lines we have used a short-hand in the new rule: X is a wildcard constructor standing for any of read, write, or alloc. These constraints simply instantiate the requirements of the original rule for each of the three specific kinds of effects. The four lines beginning with universal quantifiers are the referential transparency constraints specific to confine. The first two lines of the premise require that the confined expression e1 have no side effects; the last two lines say that if a location ρ is read by e1 (i.e., the effect read(ρ ) is in L1) then ρ cannot be written or allocated by e2. In other words, the last two lines prevent e1 from being confined if the meaning of e1 may be changed by an assignment in e2.</p><p>It is important to understand that it is not necessary to actually introduce new program variables and carry out inverse substitutions to implement confine inference. Our reduction of confine inference to restrict inference allows us to rely on soundness results for restrict, but an efficient implementation is possible without explicit program transformations. For space reasons we have not given a type checking rule for confine. A confine rule is easily derived from the rule for confine? by requiring that ρ = ρ and simplifying.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Inferring Scopes</head><p>Our confine? rule gives us a method for inferring confine. This facility gives us a very simple way to automatically infer the best (largest) scope in which to confine a given expression e1. In Section 7, we use this technique to confine expressions corresponding to locks in the Linux kernel.</p><p>Briefly, the main idea is that to infer the scope of a confine of an expression e1, we add confine? e 1 in e2 to every possible scope e2 and pick the largest scope where inference succeeds (where "succeeds" means that the solutions of the constraints indicate that a confine can be added). The possible scopes where e1 can be confined are just those where the free variables of e1 are in scope. For example, if we have let x =e3 in(let y =e2 in . . . e1 . . .)</p><p>then confine inference for e1 adds confine? to the outer scopes:</p><p>confine? e1 in(let x = e3 in confine? e 1 in(let y =e2 in . . . e1 . . .))</p><p>assuming that e1 did not mention either x or y. Confine inference is then carried out. After the constraints are solved, we select the outermost confine? that succeeds, if indeed any succeed. Note that this method checks all confine? expressions simultaneously. Given a typed program of size n and a fixed expression e1, there are O(n) possible places to insert confine?. In our implementation, we use an algorithm with a higher worstcase running time but better performance in practice. Rather than computing reachability for every location in the constraint graph (which takes O(n 2 ) time), we do a backwards search from effects in constraints generated for confine? to find which locations reach them. Since this tends to be a small portion of the constraint graph, this is usually more efficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EXPERIMENTS</head><p>As discussed in Section 1, among other applications, we are interested in restrict and confine because they enable strong updates in flow-sensitive analyses. To assess the usefulness of our confine construct in practice, we have implemented confine inference in CQUAL and tested it in conjunction with CQUAL's flow-sensitive analysis. This section presents the results of that experience.</p><p>The flow-sensitive analysis we use is the analysis of locking behavior reported previously <ref type="bibr" target="#b14">[15]</ref>. The Linux kernel has two primitives spin lock(e) and spin unlock(e) for acquiring and releasing locks, respectively. By tracking the state (held or not held) of locks, we can detect when a lock is acquired or released twice in succession within a single thread. These particular programming errors are surprisingly common in Linux device drivers <ref type="bibr" target="#b10">[11]</ref>.</p><p>In previous experiments <ref type="bibr" target="#b14">[15]</ref>, we examined hundreds of device drivers and discovered numerous locking errors by inspecting the results of analyzing single files and a few entire device drivers. Potentially, more errors could be found by analyzing entire device driver modules (which typically consist of many files), but we discovered in analyzing many whole modules that the aliasing of locks became so pervasive that it was very difficult to separate true bugs from type errors reported due to spurious aliases, and it was sim-ply impractical to remove the spurious aliases by adding all of the needed restrict annotations by hand.</p><p>We have repeated our locking experiments, using confine inference as described in Section 6 to try to confine any arguments passed to change type(), a special state-changing statement built in to CQUAL <ref type="bibr" target="#b14">[15]</ref>-in particular, we try to confine any arguments to spin lock or spin unlock. There is one wrinkle in performing confine inference in a language with blocks of statements {e1; . . . ei; . . . ej; . . . en} such as C. Sometimes it is necessary to confine only a portion of the block with respect to an expression e; e.g., we may need to introduce a new scope to write {e1; . . . ; confine e in{ei; . . . ej; }; . . . en}</p><p>The problem is to discover to what portion of a block we can add confine. Observe that (confine e in e1; confine e in e2) = (confine e in{e1; e2})</p><p>That is, adjacent confines of the same expression can be combined. This suggests the following general algorithm: in a block e1; . . . en, for each i, add confine? e in ei and then greedily combine all adjacent confine?s that succeed. This algorithm discovers the largest possible confine sub-blocks within a block of statements.</p><p>To improve performance, our current implementation introduces new sub-blocks for confine? using a slightly different algorithm based on a syntactic heuristic. For each statement in the program (including statement blocks), we keep track of whether the statement contains change type. When two statements in the same block contain change type, and the arguments to change type match syntactically, we introduce the smallest possible sub-block around the two statements and report that the new sub-block does not contain a change type. Intuitively, this heuristic tries to put confine? around sets of statements that call spin lock and spin unlock with the same syntactic expression. The heuristic is weaker than the general strategy outlined above, but still works well in our experiment, as our results suggest. Also notice that although the introduction of confine? is a syntactic heuristic, our confine inference algorithm uses our type and effect system to decide whether introducing confine is safe.</p><p>We analyzed 589 whole device driver modules from the 2.4.9 Linux kernel. We used CQUAL in three different modes: without confine inference, with confine inference, and finally in a mode where all updates are assumed to be strong. In each case we measured the number of type errors reported by CQUAL in the flowsensitive pass-here the number of type errors is the number of syntactic calls to spin lock() and spin unlock() where CQUAL could not verify that locks are held in the correct state. Since one application of confine is to enable strong updates in a flowsensitive analysis, the last mode provides an upper bound on the number of spurious type errors that can be eliminated by adding confine annotations.</p><p>Of the 589 modules, 352 are free of type errors without the addition of any confine annotations. 85 of the remaining modules contain type errors, but not because of strong updates-using no confine at all yields the same type errors as assuming all updates are strong. Of the remaining 152 modules where CQUAL reports type errors, using confine inference produces the same type errors as assuming all updates are strong in 138 modules. That is, in 138 of 152 modules where confine inference could make a   difference, it removes all spurious type errors due to lack of strong updates. Figure <ref type="figure" target="#fig_3">6</ref> shows the distribution of type errors eliminated by confine inference for these modules. Summing the individual results for all modules, confine inference could potentially eliminate 3,277 type errors, and it succeeds in eliminating 3,116 type errors, or 95%. Note that the type error counts should be taken with a grain of salt, as multiple type errors often have a single root cause. Also, many modules share files, so even type errors reported in different modules are not independent. Of the 152 modules, 14 contain sites where confine inference cannot infer that a potentially useful strong update is possible. We give the type error counts for each of the three modes of usage for these modules in Figure <ref type="figure" target="#fig_4">7</ref>. We have examined the type error reports from several of these 14 modules to discover where confine inference fails. In some cases, our underlying may-alias analysis is unable to verify the addition of confine without programmer intervention (e.g., a type cast). In other cases, there is not a welldefined lexical scope for confine; these cases often involve quite tricky coding styles.</p><p>Although it is not the subject of this paper, as mentioned above even assuming that all updates are strong, CQUAL reports at least some type errors in 137 of the modules. The sources of these type errors are mostly the same as reported previously <ref type="bibr" target="#b14">[15]</ref>. In particular, there are a few places where a path sensitive analysis would be useful, and others where we need the ability to model the sequential acquiring or releasing of a set of aliased locks at once. There are also just plain program errors, including 4 apparently new bugs we have found since the results reported previously <ref type="bibr" target="#b14">[15]</ref>. These bugs were present in the code analyzed previously <ref type="bibr" target="#b14">[15]</ref> but escaped notice simply because the large number of spurious type errors caused by the lack of confine inference. Finally, so far we have found one place where the addition of location polymorphism would remove a CQUAL type error.</p><p>The performance impact of confine inference on CQUAL is modest, because in our experiments the pointer-valued expressions that are confined tend to be small and because we only try to confine arguments to spin lock or spin unlock. For example, in the largest module where confine inference eliminated some type errors (ide-tape) CQUAL ran in 28.5 seconds with confine inference and in 26.0 seconds without it. The running time of confine inference for other modules is a similarly small fraction of the overall time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>Effect systems were first described by Gifford and Lucassen for FX-87 <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b21">22]</ref>. FX-87 includes subtyping, polymorphism, and notation for declaring the effects of expressions <ref type="bibr" target="#b15">[16]</ref>. One of the best-known type and effect systems is the region type system proposed by Tofte and Talpin <ref type="bibr" target="#b26">[27]</ref>. Our type systems, and particularly the system for automatically inferring where to place restrict and confine annotations, is related to region inference. The ρ annotations can be thought of as regions, and we can apply the rule (Down) (which is borrowed from a region type system <ref type="bibr" target="#b3">[4]</ref>) whenever we discover that a location is purely local to a lexical scope of the computation <ref type="bibr" target="#b3">[4]</ref>. One important difference between restrict/confine inference and region inference is that introducing restrict and confine requires that certain locations not be accessed within their scope, whereas introducing a new region never decreases the set of accessible locations.</p><p>Wang and Appel <ref type="bibr" target="#b28">[29]</ref> use a technique very similar to restrict to check that covariant subtyping under reference types is safe. This can be seen as another application of restrict.</p><p>Automatic alias analysis has been heavily studied in recent years; a few of the many proposed analyses are <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b29">30]</ref>. Our type system incorporates may-alias analysis to check the correctness of restrict and confine. The may-alias analysis we use is very conservative, and it is possible that a more expressive (and expensive) may-alias analysis would be useful in practice to improve the precision of restrict and confine checking and inference.</p><p>One of the limitations of our approach is that restrict and confine must be lexically scoped. This assumption fits well with many, but not all, uses of restrict and confine in practice. Other type-based systems that model strong and weak updates and do not have lexical scoping restrictions <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b24">25]</ref> are more expressive, but also less suited to tractable automatic inference than our approach. For example, Boyland <ref type="bibr" target="#b2">[3]</ref> shows how to check several programming paradigms using non-lexically scoped linearities and flow-sensitive aliasing information.</p><p>There are several systems for modeling uniqueness in object oriented programming languages <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b2">3]</ref>. In these systems a unique object always has exactly one pointer pointing to it. In contrast, in our system a location pointed to by a restricted pointer may be pointed to by arbitrarily many pointers. However, some of the techniques from the literature on uniqueness may be applicable to restrict and confine. For example, a type system by Clarke and Wrigstad <ref type="bibr" target="#b5">[6]</ref> allows a unique object to have a non-unique view in a scope while leaving the unique pointer to the object alive by forbidding the escape of aliases created in the scope.</p><p>As discussed in the introduction, one of the most interesting properties of restrict and confine is that they allow us to locally recover the ability to treat a pointer as a reference to a unique value, which allows analyses that use restrict and confine information to perform strong updates <ref type="bibr" target="#b4">[5]</ref>. This idea is the subject of previous work <ref type="bibr" target="#b14">[15]</ref> that combines restrict with ideas from flow-sensitive type systems <ref type="bibr" target="#b24">[25]</ref>. The resulting system can be used to check flow-sensitive program properties.</p><p>Several other systems, such at Meta-level compilation <ref type="bibr" target="#b16">[17]</ref> and ESP <ref type="bibr" target="#b7">[8]</ref>, check flow-sensitive program properties using approaches more directly based on dataflow analysis. In these systems, arbitrary dataflow facts are associated with each program point. In contrast, our approach can be seen as associating a more restricted language of facts, i.e., the qualified type of each abstract location ρ, with each program point. This yields a quite different design tradeoff: Meta-level compilation and ESP support a richer language of facts that is correspondingly more complex to reason about. In CQUAL, the facts are easier to reason about but less expressive. The restrict and confine constructs regain some expressiveness by enriching the set of abstract locations, which correspondingly enriches the set of possible facts at each program point.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSION</head><p>In this paper we have presented restrict, a language construct that allows a programmer to specify that certain pointers are not aliased within a lexical scope. We have shown both how to automatically check the correctness of restrict annotations using an alias and effect system, and how to automatically infer which let bindings may be safely changed to restrict bindings.</p><p>We have also developed confine, which allows an expression to be restricted, and shown how to automatically add confine annotations to a program. We have shown that automatic confine inference can be used to recover nearly all important strong updates needed for a flow-sensitive analysis to check locking behavior in Linux kernel device drivers. Although our experiments to date have focused on using restrict and confine to aid CQUAL, we believe that restrict and confine can be profitably applied as programmer annotations in other systems.</p><p>In our view, the key benefit of our approach is that restrict and confine give the programmer a handle on an alias analysis and, by extension, any subsequent analyses (e.g., program verification tools) based on aliasing information. We feel that this exposure of aliasing information is important, especially to express critical aliasing invariants needed to verify flow-sensitive program properties. However, we also believe that many uses of restrict and confine are routine. Thus, we believe a workable approach is to support both automatic inference of restrict and confine as well as programmer restrict and possibly confine annotations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example program</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Type Inference Rules for Checking Restrict</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Constraint Resolution</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Spurious type errors eliminated by confine inference.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Modules for which confine inference does not infer all possible strong updates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>In our version of restrict (which differs from C99<ref type="bibr" target="#b1">[2]</ref> on a few points; see below), it is legal to create and use some aliases of restricted pointers. Consider the following example:</figDesc><table><row><cell cols="2">restrict p = ...;</cell></row><row><cell cols="2">{ int *restrict r = p;</cell></row><row><cell cols="2">*r; // valid</cell></row><row><cell cols="2">*p; // invalid</cell></row><row><cell>}</cell><cell></cell></row><row><cell cols="2">*p; // valid</cell></row><row><cell>}</cell><cell></cell></row><row><cell>int *x;</cell><cell></cell></row><row><cell cols="2">{ int *restrict p = ...;</cell></row><row><cell cols="2">int *r = p;</cell></row><row><cell>*r;</cell><cell>// valid: use of local copy</cell></row><row><cell cols="2">x = p; // invalid: copy escapes</cell></row><row><cell>}</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Finding syntactic occurrences of e1 takes O(n 2 ) time. Solving the constraints for O(n) confine?s takes O(n 2 ) time. To see this, note that our type inference rules generate O(n) locations, and computing reachability for a location in the constraint graph (using an algorithm similar to that in Figure5) takes O(n) time. Thus, computing an initial least solution of every location, before taking any conditional constraints into account, takes time O(n 2 ). Then for any conditional constraint whose left-hand side is true, we perform O(n) extra work to recompute reachability for the unified locations and to propagate the least solution of L1 to π . Since there are O(n) possible total unifications, and each may trigger O(n) work, the overall complexity is O(n 2 ).</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>To accomplish this, CQUAL also needs to know how the functions spin lock and spin unlock change the state of locks. This information is given as type signatures<ref type="bibr" target="#b14">[15]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>We need one auxiliary function for our type checking system. We write locs(τ ) for the set of locations occurring in the type τ , defined aslocs(int) = ∅ locs(ref ρ (τ )) = {ρ} ∪ locs(τ )Our type system proves judgments of the formΓ e : τ ; L Γ x : Γ(x); ∅ (Var) Γ n : int; ∅ (Int) Γ e : τ ; L Γ new e : ref ρ (τ ); L ∪ {ρ} (Ref) Γ e : ref ρ (τ ); L Γ * e : τ ; L ∪ {ρ} (Deref) Γ e1 : ref ρ (τ ); L1 Γ e2 : τ ; L2 Γ e1 := e2 : τ ; L1 ∪ L2 ∪ {ρ} (Assign) Γ e1 : ref ρ (τ1); L1 Γ[x → ref ρ (τ1)] e2 : τ2; L2 Γ let x =e1 in e2 : τ2; L1 ∪ L2 (Let)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>This is consistent with the semantics of restrict in C. We have not introduced this semantics before now because it is more complicated.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>Our usage is slightly non-standard; in the standard use of the term "referential transparency," the scope referred to is the whole program.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This research was supported in part by NSF CCR-0085949 and DARPA Contract No. F33615-00-C-1693.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Program Analysis and Specialization for the C Programming Language</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">O</forename><surname>Andersen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994-05">May 1994</date>
		</imprint>
		<respStmt>
			<orgName>DIKU, Department of Computer Science, University of Copenhagen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Programming languages -C</title>
		<author>
			<persName><surname>Ansi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEC</title>
		<imprint>
			<biblScope unit="volume">9899</biblScope>
			<date type="published" when="1999">1999. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Alias burying: Unique variables without destructive reads. Software-Practice and Experience</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boyland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-05">May 2001</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="533" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Stratified Operational Semantics for Safety and Correctness of The Region Calculus</title>
		<author>
			<persName><forename type="first">C</forename><surname>Calcagno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 28th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages<address><addrLine>London, United Kingdom</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-01">Jan. 2001</date>
			<biblScope unit="page" from="155" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Analysis of Pointers and Structures</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">K</forename><surname>Zadeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1990 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 1990 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>White Plains, New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="296" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">External Uniquness</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wrigstad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Workshop on Foundations of Object-Oriented Languages</title>
		<meeting>the 10th International Workshop on Foundations of Object-Oriented Languages</meeting>
		<imprint>
			<date type="published" when="2003-01">Jan. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Unification-based Pointer Analysis with Directional Assignments</title>
		<author>
			<persName><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2000 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 2000 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>Vancouver B.C., Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
			<biblScope unit="page" from="35" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">ESP: Path-Sensitive Program Verification in Polynomial Time</title>
		<author>
			<persName><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Seigle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="page" from="57" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Enforcing High-Level Protocols in Low-Level Software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 2001 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>Snowbird, Utah</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="59" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Context-Sensitive Interprocedural Points-to Analysis in the Presence of Function Pointers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Emami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ghiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Hendren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1994 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 1994 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>Orlando, Florida</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-06">June 1994</date>
			<biblScope unit="page" from="242" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code</title>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Symposium on Operating Systems Principles</title>
		<meeting>the 18th ACM Symposium on Operating Systems Principles<address><addrLine>Banff, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-10">Oct. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Adoption and Focus: Practical Linear Types for Imperative Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Type Qualifiers: Lightweight Specifications to Improve Software Quality</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-12">Dec. 2002</date>
		</imprint>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Checking Programmer-Specified Non-Aliasing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<idno>UCB//CSD-01-1160</idno>
		<imprint>
			<date type="published" when="2001-10">Oct. 2001</date>
		</imprint>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Flow-Sensitive Type Qualifiers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Terauchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">FX-87 Reference Manual</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Gifford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jouvelot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Lucassen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Sheldon</surname></persName>
		</author>
		<idno>MIT/LCS/TR-407</idno>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
		<respStmt>
			<orgName>MIT Laboratory for Computer Science, Sept</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A System and Language for Building System-Specific, Static Analyses</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="page" from="69" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Ultra-fast Aliasing Analysis using CLA: A Million Lines of C Code in a Second</title>
		<author>
			<persName><forename type="first">N</forename><surname>Heintze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Tardieu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 2001 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>Snowbird, Utah</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="254" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Islands: aliasing protection in object-oriented languages</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hog</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the sixth annual conference on Object-oriented programming systems, languages, and applications</title>
		<meeting>the sixth annual conference on Object-oriented programming systems, languages, and applications</meeting>
		<imprint>
			<date type="published" when="1991-10">Oct. 1991</date>
			<biblScope unit="page" from="271" to="285" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Safe Approximate Algorithm for Interprocedural Pointer Aliasing</title>
		<author>
			<persName><forename type="first">W</forename><surname>Landi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Ryder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1992 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 1992 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>San Francisco, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-06">June 1992</date>
			<biblScope unit="page" from="235" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient Computation of Parametrized Pointer Information for Interprocedural Analyses</title>
		<author>
			<persName><forename type="first">D</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Harrold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Static Analysis, Eighth International Symposium</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</editor>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001-07">July 2001</date>
			<biblScope unit="volume">2126</biblScope>
			<biblScope unit="page" from="279" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Polymorphic Effect Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Lucassen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Gifford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 15th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-01">Jan. 1988</date>
			<biblScope unit="page" from="47" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Towards Alias-Free Pointers</title>
		<author>
			<persName><forename type="first">N</forename><surname>Minsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the tenth European Conference on Object Oriented Programming</title>
		<meeting>the tenth European Conference on Object Oriented Programming</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Type-Based Flow Analysis: From Polymorphic Subtyping to CFL-Reachability</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rehof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 28th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages<address><addrLine>London, United Kingdom</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-01">Jan. 2001</date>
			<biblScope unit="page" from="54" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Alias Types</title>
		<author>
			<persName><forename type="first">F</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morrisett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th European Symposium on Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Smolka</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1782</biblScope>
			<biblScope unit="page" from="366" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Points-to Analysis in Almost Linear Time</title>
		<author>
			<persName><forename type="first">B</forename><surname>Steensgaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages<address><addrLine>St. Petersburg Beach, Florida</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-01">Jan. 1996</date>
			<biblScope unit="page" from="32" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Implementation of the Typed Call-by-Value λ-Calculus using a Stack of Regions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tofte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Talpin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages<address><addrLine>Portland, Oregon</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-01">Jan. 1994</date>
			<biblScope unit="page" from="188" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Confined Types</title>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bokowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fourteenth annual conference on Object-oriented programming systems, languages, and applications</title>
		<meeting>the fourteenth annual conference on Object-oriented programming systems, languages, and applications</meeting>
		<imprint>
			<date type="published" when="1999-10">Oct. 1999</date>
			<biblScope unit="page" from="82" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Type-Preserving Garbage Collectors</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Appel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 28th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages<address><addrLine>London, United Kingdom</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-01">Jan. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Efficient Context-Sensitive Pointer Analysis for C Programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 1995 ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>La Jolla, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
