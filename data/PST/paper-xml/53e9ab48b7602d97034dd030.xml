<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Single-Database Private Information Retrieval from Fully Homomorphic Encryption</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xun</forename><surname>Yi</surname></persName>
							<email>xun.yi@vu.edu.au</email>
						</author>
						<author>
							<persName><forename type="first">Mohammed</forename><surname>Golam Kaosar</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Russell</forename><surname>Paulet</surname></persName>
							<email>russell.paulet@live.vu.edu.au..</email>
						</author>
						<author>
							<persName><roleName>Fellow, IEEE</roleName><forename type="first">Elisa</forename><surname>Bertino</surname></persName>
							<email>bertino@cs.purdue.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Engineering and Science</orgName>
								<orgName type="institution">Victoria University</orgName>
								<address>
									<postBox>PO Box 14428</postBox>
									<settlement>Melbourne VIC 8001</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">School of Computer Science</orgName>
								<orgName type="department" key="dep3">Center for Education and Research in Information Assurance and Security (CERIAS), and Cyber Center (Discovery Park)</orgName>
								<orgName type="institution">Purdue University</orgName>
								<address>
									<postCode>47907</postCode>
									<settlement>West Lafayette</settlement>
									<region>IN</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Single-Database Private Information Retrieval from Fully Homomorphic Encryption</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3B296073E6D71D848BF00CB1FB1FDF66</idno>
					<idno type="DOI">10.1109/TKDE.2012.90</idno>
					<note type="submission">received 27 May 2011; revised 13 Jan. 2012; accepted 10 Apr. 2012; published online 19 Apr. 2012.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Private information retrieval</term>
					<term>private block retrieval</term>
					<term>fully homomorphic encryption</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Private Information Retrieval (PIR) allows a user to retrieve the ith bit of an n-bit database without revealing to the database server the value of i. In this paper, we present a PIR protocol with the communication complexity of Oð log nÞ bits, where is the ciphertext size. Furthermore, we extend the PIR protocol to a private block retrieval (PBR) protocol, a natural and more practical extension of PIR in which the user retrieves a block of bits, instead of retrieving single bit. Our protocols are built on the state-of-the-art fully homomorphic encryption (FHE) techniques and provide privacy for the user if the underlying FHE scheme is semantically secure. The total communication complexity of our PBR is Oð log m þ n=mÞ bits, where m is the number of blocks. The total computation complexity of our PBR is Oðm log mÞ modular multiplications plus Oðn=2Þ modular additions. In terms of total protocol execution time, our PBR protocol is more efficient than existing PBR protocols which usually require to compute Oðn=2Þ modular multiplications when the size of a block in the database is large and a high-speed network is available.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>P RIVATE information retrieval (PIR) protocol allows a user to retrieval the ith bit of an n-bit database, without revealing to the database server the value of i. A trivial solution is for the user to retrieve the entire database, but this approach may incur enormous communication cost. A good PIR protocol is expected to have considerably lower communication complexity. Private Block Retrieval (PBR) is a natural and more practical extension of PIR in which, instead of retrieving only a single bit, the user retrieves a block of bits from the database.</p><p>PIR was first introduced by Chor et al. <ref type="bibr" target="#b8">[9]</ref> in 1995 in a multiserver setting, where the user retrieves information from multiple database servers, each has a copy of the same database. To ensure user privacy in the multiserver setting, the servers must be trusted not to collude. In <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr">Chor et al.</ref> have shown that if only single database is used, n bits must be communicated in the information-theoretic sense, that is, the user's query gives absolutely no information about i. They have also shown that any PIR protocol can be converted to a PBR protocol.</p><p>In 1997, using the quadratic residuosity computational assumption, Kushilevitz and Ostrovsky <ref type="bibr" target="#b21">[23]</ref> constructed a single-database PIR with communication complexity of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Oð2</head><p>ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi ffi log n log log N p Þ which is less then Oðn Þ for any &gt; 0, where N is the composite modulus. Their basic idea is viewing the database as a matrix M ¼ ðx ij Þ sÂt of bits. To retrieve the (a; b) entry of the matrix, the user sends to the database server a composite (hard-to-factor) modulus N and t randomly chosen integers y 1 ; y 2 ; . . . ; y t such that only y a is not a quadratic residuosity modulo N, that is, y i 6 ¼</p><p>2 ðmod NÞ for any integer . The server sends back z i ¼ Q t j¼1 y 2Àxij j ðmod NÞ for 1 i s. The user concludes that x ij ¼ 0, if z a is a quadratic residuosity modulo N, and x ij ¼ 1, otherwise.</p><p>In 1999, Cachin et al. <ref type="bibr" target="#b6">[7]</ref> constructed the first singledatabase PIR with polylogarithmic communication complexity Oðlog 8 nÞ. The security of their protocol is based on the È-hiding number-theoretic assumption, that is, it is hard to distinguish which of two primes divide ðNÞ for the composite modulus N. Their basic idea is mapping each index i to a distinct prime p i . To retrieve bit b i from a database B ¼ b 1 b 2 . . . b n , the user sends to the database server a composite (hard-to-factor) modulus N such that p i divides ðNÞ and a generator g with order divisible by p i . The server sends back r ¼ g P ðmod NÞ where P ¼ Q j p bj j . The user concludes that b i ¼ 1 if r is a p i -residue modulo N, otherwise, b i ¼ 0.</p><p>In 2000, Kushilevitz and Ostrovsky <ref type="bibr" target="#b22">[24]</ref> constructed a PIR protocol with total communication complexity</p><formula xml:id="formula_0">n À cn 2k þ Oðk 2 Þ,</formula><p>where k is a security parameter and c is a constant. Their protocol is built on the Naor-Yung one-way 2-to-1 trapdoor permutations <ref type="bibr" target="#b25">[27]</ref> and the Goldreich-Levin hard-core predicates <ref type="bibr" target="#b19">[21]</ref>. Their basic idea is dividing an n-bit database into k-bit blocks and organizing the database into pairs of blocks, denoted by z i;L and z i;R , where i ¼ 1; 2; . . . ; n 2k . Suppose that the user wishes to retrieve z s;L . The user sends to the database server the descriptions of one-way trapdoor permutations f L and f R , to which the user has the trapdoors. The server computes f L ðz i;L Þ and f R ðz i;R Þ for all i and returns these values to the user. With trapdoors, the user computes two possible preimages ðz s;L ; z 0 s;L Þ. Next, the user sends to the server two hardcore predicates r L and r R , such that r L ðz s;L Þ 6 ¼ r L ðz 0 s;L Þ, but r R ðz s;R Þ ¼ r R ðz 0 s;R Þ. The server responds with r L ðz i;L Þ È r R ðz i;R Þ for all i. At the end, the user learns which preimage is z s;L from r L ðz s;L Þ.</p><p>In 2005, Gentry and Ramzan <ref type="bibr" target="#b13">[14]</ref> extended the singledatabase PIR of Cachin et al. <ref type="bibr" target="#b6">[7]</ref> to a PBR with communication complexity Oðlog 2 nÞ, the current best bound for communication complexity. The security of their protocol is also based on the È-hiding assumption. Assume that an n-bit database B is partitioned into m blocks, each has ' bits, denoted as B ¼ C 1 kC 2 k Á Á Á kC m . Their basic idea is associating C i with a distinct small prime p i , rather than associating a (largish) prime with each bit. The database server uses the Chinese Reminder Theorem to determine an integer e such that e ¼ C i ðmod p c i i Þ for 1 i m, where c i is the smallest integer such that p ci i ! 2 ' . To retrieve block C i , the user sends to the database server a composite (hard-to-factor) modulus N such that p c i i divides ðNÞ and a generator g with order divisible by p c i i . The server sends back r ¼ g e ðmod NÞ. Let q ¼ orderðgÞ=p ci i , then orderðg q Þ ¼ p ci i . Since p i is a small prime, the user can compute the discrete logarithm log ðg q Þ ðr q Þ ¼ eðmod p c i i Þ ¼ C i using the Pohlig-Hellman algorithm <ref type="bibr" target="#b30">[32]</ref>.</p><p>Like the original single-database PIR of Kushilevitz and Ostrovsky <ref type="bibr" target="#b21">[23]</ref>, Chang <ref type="bibr" target="#b7">[8]</ref> and Lipmaa <ref type="bibr" target="#b23">[25]</ref>, <ref type="bibr" target="#b24">[26]</ref> also constructed PIR protocols with communication complexity of Oðlog 2 nÞ. The difference is that the former is based on the Goldwasser-Micali homomorphic encryption <ref type="bibr" target="#b20">[22]</ref>, but the later is built on the Damgard-Jurik homomorphic encryption <ref type="bibr" target="#b10">[11]</ref>, a variant of the Paillier homomorphic encryption <ref type="bibr" target="#b29">[31]</ref>.</p><p>These single-database PIR protocols provide almost optimal communication cost, but require the database to use an enormous amount of computational power. In 2007, Aguilar-Melchor and Gaborit <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref> presented a lattice-based computationally-efficient PIR protocol, in which the computational cost is a few thousand bitoperations per bit in the database. In this protocol, the user, who wants to retrieve an element of index i from a database composed of n elements, generates a query formed of n matrices B 1 ; B 2 ; . . . ; B n , one for each database element. All matrices are soft disturbed matrices except B i , which is a hard disturbed matrix. The user sends the query to the database server which encodes the n elements to n matrices A 1 ; A 2 ; . . . ; A n and computes R ¼ ðA 1 ; A 2 ; . . . ; A n ÞðB 1 ; B 2 ; . . . ; B N Þ T , and responds to the user with R. At last, the user retrieves B i from R. Using analytical and experimental techniques, Olumofin and Goldberg <ref type="bibr" target="#b27">[29]</ref> analyzed the performance of the latticebased PIR protocol in 2010 and reported that the end-toend response time of the protocol is one to three orders of magnitude less than the trivial protocol for realistic computation power and network bandwidth.</p><p>In 2008, Aguilar-Melchor et al. <ref type="bibr" target="#b2">[3]</ref> provided a solution for securely evaluating multivariate polynomials of degree d with additively homomorphic encryption. This scheme, further improved in 2010, can be used in PIR which requires secure evaluation of low-degree multivariate polynomials with a large number of monomials. The basic idea is to build a compound ciphertext ¼ ð ð1Þ ; ð2Þ ; . . . ; ðtÞ Þ from two encryptions ¼ Eða; pkÞ ¼ ð ð1Þ ; ð2Þ ; . . . ; ðtÞ Þ and ¼ Eðb; pkÞ, where a; b 2 f0; 1g. To decrypt the compound ciphertext, one decrypts each coordinate at first and then reconstructs the inner ciphertext ¼ P i 2 iÀ1 ðiÞ and decrypts it again to ab. This allows to evaluate degree 2 polynomials over encrypted data. The idea can be generalized by iterating the construction to evaluate polynomials of degree d securely, at the price of an expansion factor for the length of the ciphertext which is exponential in d.</p><p>Single-database PIR has a close connection to the notion of Oblivious Transfer (OT), introduced by Rabin <ref type="bibr" target="#b31">[33]</ref> in 1981. A different variant of OT, called 1-out-of-2 OT, was introduced by Even et al. <ref type="bibr" target="#b12">[13]</ref> in 1985 and, more generally, 1-out-of-n OT was considered in Brassard et al. <ref type="bibr" target="#b5">[6]</ref> in 1987. Informally, OT is a two-party protocol, where a sender with n messages M 1 ; M 2 ; . . . ; M n and a receiver with an index i (1 i n) interact, and at the end of the protocol the receiver obtains M i without learning anything about other messages, while the sender does not learn anything about the index i. OT is different from PIR in that there is no communication complexity requirement (beyond being polynomially bounded) but, on the other hand, secrecy is required for both players, while for PIR it is required only for the user. Naor and Pinkas <ref type="bibr" target="#b26">[28]</ref> have shown how to turn any PIR protocol into 1-out-of-n OT protocol with one invocation of a single-database PIR protocol and logarithmic number of invocations of 1-out-of-2 OT. DiCrescenzo et al. <ref type="bibr" target="#b9">[10]</ref> showed that any single-database PIR protocol implies 1-out-of-n OT.</p><p>Contributions. Homomorphic encryption techniques are often very natural ways to construct a variety of privacypreserving protocols. For example, the PIR protocol of Kushilevitz and Ostrovsky <ref type="bibr" target="#b21">[23]</ref> is based on the Goldwasser-Micali homomorphic encryption E <ref type="bibr" target="#b20">[22]</ref>, in which</p><formula xml:id="formula_1">Eðb 1 ÞEðb 2 Þ ¼ Eðb 1 È b 2 Þ for any b 1 ; b 2<label>2</label></formula><p>f0; 1g, while the PIR protocol of Chang <ref type="bibr" target="#b7">[8]</ref> and Lipmaa <ref type="bibr" target="#b23">[25]</ref> are based on the Damgard-Jurik homomorphic encryption E 0 <ref type="bibr" target="#b10">[11]</ref>, in which</p><formula xml:id="formula_2">E 0 ðm 1 ÞE 0 ðm 2 Þ ¼ E 0 ðm 1 þ m 2 Þ for any m 1 ; m 2 2 Z Z N .</formula><p>A generic method to construct a single-database PIR from a homomorphic encryption scheme was given by Ostrovsky and Skeith <ref type="bibr" target="#b28">[30]</ref>. These underlying encryption schemes allows homomorphic computation of only one operation (either addition or multiplication) on plaintexts.</p><p>In 2009, Gentry <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref> constructed the first fully homomorphic encryption (FHE) scheme using latticebased cryptography. FHE allows homomorphic computation of two operations (both addition and multiplication) of plaintexts. In the same year, Dijk et al. <ref type="bibr" target="#b11">[12]</ref> presented the second FHE scheme, which uses many of the tools of Gentry's construction, but which does not require ideal lattices. The scheme is therefore conceptually simpler than Gentry's ideal lattice scheme, but has similar properties with regards to homomorphic operations and efficiency. In 2010, Smart and Vercauteren <ref type="bibr" target="#b33">[35]</ref> presented a refinement of Gentry's scheme giving smaller key and ciphertext sizes. In 2011, Brakerski et al. <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref> presented FHE schemes based on the learning with error assumption.</p><p>Motivated by recent breakthrough in FHE, we study single-database PIR and PBR protocols from FHE in this paper. In <ref type="bibr" target="#b14">[15]</ref>, Gentry briefly described a single-database PIR protocol with communication complexity Oð log nÞ. The basic idea is that the user, who wishes to retrieve the ith bit from a database with n bits, sends to the database server the encryption of the index i, and the server sends back the encryption of the ith bit computed by fully homomorphic properties.</p><p>We extend Gentry's basic idea to a PBR protocol, where the user, who wishes to retrieve the ith block from a database with m blocks, sends to the server the encryption of the index i, and the server sends back the encryption of the ith block computed by fully homomorphic properties, as if the user sends the index i and the server replies the ith block. It can be seen that this solution is conceptually simpler than any existing PBR protocols without FHE.</p><p>Based on the formal model for security of singledatabase PIR <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b13">[14]</ref>, we show that such PIR and PBR protocols from FHE provide privacy of the user as long as the underlying FHE scheme is semantically secure.</p><p>The performance of our protocols depends on the underlying FHE scheme. The user and the server need to exchange Oð log nÞ bits in our PIR protocol, and exchange Oð log m þ n=mÞ in our PBR protocol, where n is the size of the database, m is the number of blocks in the database, is the ciphertext size, and the base of the logarithm is 2.</p><p>So far, existing FHE schemes have not been practical. We give a variant of Dijk et al.'s somewhat homomorphic encryption scheme, from which we construct a practical PBR protocol. In addition, we have implemented the practical PBR protocol for a database composed of 10,000 elements of size of 200k bits. Our experiment shows that our PBR protocol is practical.</p><p>The remainder of the paper is as follows: Section 2 introduces the definitions of FHE and PIR; Sections 3 and 4 describes generic and practical PIR and PBR protocols from FHE; Sections 4 and 5 analyze security and performance of our protocols; Conclusions are in the last section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMARIES</head><p>In this section, we introduce the concepts of FHE scheme and single-database PIR protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Fully Homomorphic Encryption</head><p>Formally, a FHE scheme consists of five algorithms as follows:</p><p>1. Key generation (KG): The algorithm takes as an input a security parameter k and outputs a public and private key pair (pk; sk), where pk is public, while sk is kept secret.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Encryption (E):</head><p>The algorithm takes as input a plaintext m 2 f0; 1g and the public key pk, and output a ciphertext c, denoted as c ¼ Eðm; pkÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Decryption (D):</head><p>The algorithm takes as input a ciphertext c and the private key sk, and outputs a plaintext m 2 f0; 1g, denoted as m ¼ Dðc; skÞ. 4. Homomorphic addition (Add): The algorithm takes as input two ciphertexts c 1 ¼ Eðm 1 ; pkÞ, c 2 ¼ Eðm 2 ; pkÞ, and the public key pk, and outputs a ciphertext c, denoted as c ¼ Addðc 1 ; c 2 ; pkÞ</p><formula xml:id="formula_3">¼ c 1 t u þ c 2 , such that Dðc; skÞ ¼ m 1 È m 2 :</formula><p>5. Homomorphic multiplication (Mult): The algorithm takes as input two ciphertexts c 1 ¼ Eðm 1 ; pkÞ, c 2 ¼ Eðm 2 ; pkÞ and the public key, and outputs a ciphertext c ¼ Multðc 1 ; c 2 ; pkÞ</p><formula xml:id="formula_4">¼ c 1 t u Â c 2 , such that Dðc; skÞ ¼ m 1 Á m 2 :</formula><p>A FHE scheme (KG,E,D,Add,Mult) is semantically secure if, given any public key pk, no probabilistic polynomial-time (PPT) adversary has success probability greater than to distinguish Eð0; pkÞ and Eð1; pkÞ, where is negligible in k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">DGHV Somewhat Homomorphic Encryption</head><p>In this section, we instantiate "somewhat" homomorphic encryption scheme proposed by Dijk et al. <ref type="bibr" target="#b11">[12]</ref>, called DGHV somewhat scheme for brevity. The scheme does not require ideal lattices.</p><p>In <ref type="bibr" target="#b11">[12]</ref>, a symmetric homomorphic encryption scheme was proposed as follows:</p><p>1. KeyGen: The key is an odd integer, chosen from some interval p 2 ½2 À1 ; 2 Þ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Encryptðp; MÞ:</head><formula xml:id="formula_5">To encrypt a bit M 2 f0; 1g, set the ciphertext as an integer c ¼ M þ 2r þ qp,</formula><p>where the integers q, r are chosen at random in some other prescribed intervals, such that 2r is smaller than p=2 in absolute value. 3. Decryptðp; cÞ: Output ðc mod pÞ mod 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Given two ciphertexts c</head><formula xml:id="formula_6">1 ¼ m 1 þ 2r 1 þ q 1 p and c 2 ¼ m 2 þ 2r 2 þ q 2 p, we have c 1 þ c 2 ¼ ðm 1 þ m 2 Þ þ 2ðr 1 þ r 2 Þ þ ðq 1 þ q 2 Þp;<label>ð1Þ</label></formula><formula xml:id="formula_7">c 1 c 2 ¼ m 1 m 2 þ 2ð2r 1 r 2 þ r 1 m 2 þ m 1 r 2 Þ þ ðc 1 q 2 þ q 1 c 2 þ q 1 q 2 pÞp :<label>ð2Þ</label></formula><formula xml:id="formula_8">Furthermore, ðc 1 þ c 2 mod pÞ mod 2 ¼ m 1 È m 2 and ðc 1 c 2 mod pÞ mod 2Þ ¼ m 1 m 2 :</formula><p>Therefore, the symmetric encryption scheme supports both additional and multiplicative homomorphisms.</p><p>In <ref type="bibr" target="#b11">[12]</ref>, an asymmetric homomorphic encryption scheme was also proposed as follows:</p><p>1. KeyGenðkÞ: Takes a security parameter and determines a (convenient) parameter set</p><formula xml:id="formula_9">¼ ; 0 ¼ 2; ¼ Õð 2 Þ; ¼ Õð 5 Þ; ¼ þ</formula><p>, where is the bit-length of the ciphertext, is the bit-length of the secret key, is the bit-length of the noise, is the number of integers in the public key. Chooses a random odd -bit integer p from ð2Z Z þ 1Þ \ ð2 À1 ; 2 Þ as the secret key sk. Randomly chooses q 0 ; q 1 ; . . . ; q from ½1; 2 =pÞ subject to the condition that the largest q i is odd and relabels q 0 ; q 1 ; . . . ; q so that q 0 is the largest. Randomly chooses r 1 ; . . . ; r from Z Z \ ðÀ2 ; 2 Þ and sets x 0 ¼ q 0 p and x i ¼ q i p þ r i . The public key is pk ¼ &lt;x 0 ; x 1 ; . . . ; x &gt;.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Encryptðpk; MÞ:</head><p>To encrypt M 2 f0; 1g, chooses a random subset S &amp; f1; 2, . . . ; g and a random integer r from ðÀ2 0 ; 2 0 Þ and outputs the ciphertext</p><formula xml:id="formula_10">c ¼ EðM; pkÞ ¼ M þ 2r þ 2 X i2S x i ! x0 ;</formula><p>where ½z x0 stands for zðmod x 0 Þ. 3. Decryptðsk; cÞ: To decrypt c, outputs M 0 ¼ Dðc; skÞ ¼ ðc mod pÞmod 2:</p><p>4. Homomorphic addition (Add): Given two ciphertext c 1 ¼ Eðm 1 ; pkÞ, c 2 ¼ Eðm 2 ; pkÞ, and the public key pk, outputs a ciphertext</p><formula xml:id="formula_11">c ¼ Addðc 1 ; c 2 ; pkÞ ¼ ½Eðm 1 Þ þ Eðm 2 Þ x 0 ;</formula><p>5. Homomorphic multiplication (Mult): Given two ciphertext c 1 ¼ Eðm 1 ; pkÞ, c 2 ¼ Eðm 2 ; pkÞ, and the public key pk, and outputs a ciphertext</p><formula xml:id="formula_12">c ¼ Multðc 1 ; c 2 ; pkÞ ¼ ½Eðm 1 ÞEðm 2 Þ x0 :</formula><p>This asymmetric encryption scheme supports both additional and multiplicative homomorphisms, too.</p><p>The security of the DGHV somewhat scheme is based on the approximate-gcd problem, that is, for a randomly chosen -bit odd integer p, given polynomially many samples in the form qp þ r, where q is randomly chosen from ½1; 2 =pÞ and r is randomly chosen from Z Z \ ð2 À ; 2 Þ, determine p.</p><p>The DGHV somewhat scheme is semantically secure if the approximate-gcd problem is hard. The choice of parameters in the DGHV somewhat scheme achieves at least 2 security against all of known attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Single-Database PIR</head><p>Informally, a single-database PIR protocol is a two-party protocol, where a user retrieves the ith bit from an n-bit database DB ¼ b 1 b 2 . . . b n , without revealing to the database server the value of i. Formally, a single-database PIR protocol consists of three algorithms as in <ref type="bibr" target="#b6">[7]</ref> and <ref type="bibr" target="#b13">[14]</ref>.</p><p>1. Query generation (QG): Takes as input a security parameter k, the size n of the database, and the index i of a bit in the database, outputs a query Q and a secret s, denoted as ðQ; sÞ ¼ QGðn; i;</p><formula xml:id="formula_13">1 k Þ. 2.</formula><p>Response generation (RG): Takes as input the security parameter k, the query Q and the database DB, outputs a response R, denoted as R ¼ RGðDB; Q; 1 k Þ. 3. Response retrieval (RR): Takes as input the security parameter k, the response R, the index i of the bit, the size n of the database, the query Q, and the secret s, output a bit b 0 , denoted as b 0 ¼ RRðn; i; ðQ; sÞ; R; 1 k Þ. A single-database PIR protocol is correct if, for any security parameter k, any database DB with any size n, and any index i for 1 i n, b i ¼ RRðn; i; ðQ; sÞ; R; 1 k Þ holds, where ðQ; sÞ ¼ QGðn; i;</p><formula xml:id="formula_14">1 k Þ and R ¼ RGðDB; Q; 1 k Þ.</formula><p>The security of single-database PIR protocol can be defined with a game as follows:</p><p>Give an n-bit database DB ¼ b 1 b 2 . . . b n . Consider the following game between an adversary (the database server) A, and a challenger C. The game consists of the following steps: We define the adversary A's advantage in this game to be Adv A ðkÞ ¼ jPrðb 0 ¼ bÞ À 1=2j: Definition 1 (Security Definition). A single-database PIR protocol is semantically secure if for any PPT adversary A, we have that Adv A ðkÞ is a negligible function, where the probability is taken over coin-tosses of the challenger and the adversary.</p><p>Similarly, single-database PBR protocol can be defined by viewing the n-bit database as DB ¼ B 1 kB 2 k . . . kB m , where B i is a block with n=m bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">GENERIC SINGLE-DATABASE PRIVATE INFORMATION RETRIEVAL FROM FHE</head><p>In this section, we present a response generation circuit, from which we construct a generic single-database PIR protocol based on FHE and then extend it to a generic single-database PBR protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Response Generation Circuit</head><p>Without taking security into account, a response generation circuit can be described as follows:</p><p>Inputs: An index i 2 ½1; n and an n-bit database</p><formula xml:id="formula_15">DB ¼ b 1 b 2 . . . b n Output b i .</formula><p>Response Generation Circuit:</p><p>1. Write the index i in the binary representation, denoted as i ¼ 1 2 . . . ' , where ' ¼ dlog ne. 2. For each index j 2 ½1; n, write j in the binary representation, denoted as j ¼ j;1 j;2 . . . j;' . Compute</p><formula xml:id="formula_16">j ¼ Y ' t¼1 ð t È j;t È 1Þ;<label>ð3Þ</label></formula><p>where È stands for XOR operation. If j ¼ i, j ¼ 1, and 0 otherwise. This means only i ¼ 1.</p><formula xml:id="formula_17">3. Output R ¼ M b j ¼1 j :<label>ð4Þ</label></formula><formula xml:id="formula_18">If b i ¼ 1, then L bj¼1 j ¼ i ¼ 1. If b i ¼ 0, then L bj¼1 j ¼ 0. Therefore, R ¼ L b j ¼1 j ¼ b i .</formula><p>The response generation circuit is implemented with two simple operations, È and Á, where Á is equivalent to AND. It does not need IF-THEN statement.</p><p>The circuit requires the plain index i to generate the response R and thus cannot preserve user privacy. To do so, we make use of the FHE technique to evaluate the response generation circuit with the encrypted index as input in next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Generic Single-Database PIR from FHE</head><p>The generic single-database PIR protocol is built on a FHE scheme (KG, E, D, Add, Mult) and consists of three algorithms (Query Generation QG, Response Generation RG, and Response Retrieval RR).</p><p>At a high level, the user generates a public and private key pair (pk; sk) for the FHE scheme, sends the public key pk to the database server, but keeps the private key sk secret. Then the user chooses an index i, where 1 i n, and encrypts i with the public key pk, and sends the ciphertext as a query to the database server. Based on the response generation circuit and homomorphic properties, the server computes an encryption of the ith bit as a response based on the database, the query and the public key pk, and sends the response back. At the end, the user decrypts the response to obtain the ith bit.</p><p>Assume that the user and the database server have agreed upon a FHE scheme (KG, E, D, Add, Mult) in advance, our single-database PIR can be described as follows: Query generation QGðn; i;</p><formula xml:id="formula_19">1 k Þ.</formula><p>Inputs: The size n of the database DB, an index i 2 ½1; n, the key generation algorithm KG, the encryption algorithm E, and a security parameter k.</p><p>Outputs: A query Q ¼ ðpk; Eði; pkÞÞ and a secret s ¼ sk, where (pk; sk) is a public and private key pair for the FHE scheme and Eði; pkÞ is the encryption of i with the public key pk.</p><p>Algorithm QGðn; i;</p><formula xml:id="formula_20">1 k Þ:</formula><p>1. (The user) generates a public and private key pair (pk; sk) with the key generation algorithm (KG) and the security parameter k, i.e., ðpk; skÞ ¼ KGð1 k Þ. 2. Assume that the binary representation of i is 1 2 . . . ' , where i 2 f0; 1g and ' ¼ dlog ne. (The user) encrypts each a j with the public key pk, denoted as j ¼ Eð i ; pkÞ. Let Eði; pkÞ ¼ ð 1 ; 2 ; . . . ; ' Þ. 3. Output the query Q ¼ ðpk; Eði; pkÞÞ and a secret s ¼ sk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Response generation</head><formula xml:id="formula_21">RGðDB; Q; 1 k Þ Inputs: An n-bit database DB ¼ b 1 b 2 .</formula><p>. . b n , a query Q ¼ ðpk; Eði; pkÞÞ, E, Add, Mult, and a security parameter k.</p><p>Output: A response R.</p><formula xml:id="formula_22">Algorithm RGðDB; Q; 1 k Þ:</formula><p>1. For each index j 2 ½1; n, (the database server) writes j in the binary representation j;1 j;2 . . . j;' . (The database server) encrypts each bit j;t with the public key pk, denoted as j;t ¼ Eð j;t ; pkÞ for 1 t ', and computes</p><formula xml:id="formula_23">j ¼ t u Â ' t¼1 À t t u þ j;t t u þ 1Á ;<label>ð5Þ</label></formula><p>where 1 is an encryption of 1.</p><p>2. (The database server) computes</p><formula xml:id="formula_24">R ¼ t u þ bj¼1 j :<label>ð6Þ</label></formula><p>3. Output the response R. Response retrieval RRððQ; sÞ; R; 1 k Þ Inputs: s ¼ sk, an output of QGðn; i; 1 k Þ; R, an output of RGðDB; Q; 1 k Þ, and the decryption algorithm D.</p><p>Output: A bit b 0 ¼ DðR; skÞ.</p><p>Theorem 1 (Correctness). The generic single-database PIR from FHE is correct for any security parameter k, any database DB with any size n, and any index 1 i n.</p><p>Proof. By comparing our response generation circuit and our response generation algorithm (RG), we can see that j is an encryption of 1 when j ¼ i and an encryption of 0 otherwise, on the basis of fully homomorphic properties. Therefore,</p><formula xml:id="formula_25">if b i ¼ 1, R ¼ t u þ b j ¼1 j ¼ i ¼ 1, if b i ¼ 0, R ¼ t u þ bj¼1 j ¼ 0.</formula><p>This means R is an encryption of b i and thus b 0 ¼ DðR; skÞ ¼ b i . 4 t u</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Generic Single-Database PBR from FHE</head><p>Now, we extend the single-database PIR from FHE to a single-database PBR from FHE, which also consists of three algorithms (QG, RG, RR).</p><p>Assume that an n-bit database DB is equally partitioned into m blocks, denoted as DB ¼ B 1 kB 2 . . . kB m , our singledatabase PBR is described as follows: Query generation QGðm; i;</p><formula xml:id="formula_26">1 k Þ.</formula><p>Inputs: The number m of blocks in the database DB, an index i 2 ½1; m, KG, E, and a security parameter k.</p><p>Outputs: A query Q ¼ ðpk; Eði; pkÞÞ and a secret s ¼ sk, where (pk; sk) is a public and private key pair for the FHE scheme.</p><p>Algorithm QGðm; i;</p><formula xml:id="formula_27">1 k Þ:</formula><p>1. (The user) generates a public and private key pair (pk; sk) with the key generation algorithm (KG) and the security parameter k, i.e., ðpk; skÞ ¼ KGð1 k Þ. 2. Assume that the binary representation of i is 1 2 . . . ' , where i 2 f0; 1g and ' ¼ dlog me. (The user) encrypts each a j with the public key pk, denoted as j ¼ Eð i ; pkÞ. Let Eði; pkÞ ¼ ð 1 ; 2 ; . . . ; ' Þ. 3. Output the query Q ¼ ðpk; Eði; pkÞÞ and a secret s ¼ sk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Response generation</head><formula xml:id="formula_28">RGðDB; Q; 1 k Þ.</formula><p>Inputs: An n-bit database DB ¼ B 1 kB 2 . . . kB m , where B j ¼ ðb j;1 ; b j;2 ; . . . ; b j;L Þ and L ¼ n=m, a query Q ¼ ðpk; Eði; pkÞÞ, E, Add, Mult, and a security parameter k.</p><p>Output: A response R. Algorithm RGðDB; Q; 1 k Þ:</p><p>1. For each index j 2 ½1; m, (the database server) writes j in the binary representation j;1 j;2 . . . j;' . (The database server) encrypts each bit j;t with the public key pk, denoted as j;t ¼ Eð j;t ; pkÞ for 1 t ', and computes</p><formula xml:id="formula_29">j ¼ t u Â ' t¼1 À t t u þ j;t t u þ 1Á :<label>ð7Þ</label></formula><p>2. For each c 2 ½1; L, (the database server) computes</p><formula xml:id="formula_30">R c ¼ t u þ bj;c¼1 j :<label>ð8Þ</label></formula><p>3. Output the response R ¼ ðR 1 ; R 2 ; . . . ; R L Þ:</p><p>Response retrieval RRððQ; sÞ; RÞ. Inputs: s ¼ sk, an output of QGðn; i; </p><formula xml:id="formula_31">1 k Þ; R, an output of RGðDB; Q; 1 k Þ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PRACTICAL SINGLE-DATABASE PIR from FHE</head><p>So far, existing FHE schemes have not been practical for application in private information retrieval. In this section, we present a variant of DGHV somewhat scheme for PBR and then construct a practical PBR protocol from it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A Variant of DGHV Somewhat Scheme</head><p>An obstruct to make the DGHV somewhat scheme practical is the size of the public keys. For the purpose of PIR and PBR, the database server does not need to perform any encryption operation except from some addition and multiplication operations of ciphertexts which require x 0 only. In addition, the user, who generates the private key p, is able to encrypt the index of the interested bit or block directly by using the secret key p and x 0 . Therefore, the public keys x 1 ; x 2 ; . . . ; x become redundant in PIR and PBR. In view of this, we introduce a variant of the DGHV somewhat scheme (V-DGHV) for PBR with a database of m blocks as follows:</p><p>1. KeyGenðÞ: The user takes a security parameter and determines a parameter set ¼</p><formula xml:id="formula_32">; ¼ ð þ 3Þdlog me; ¼ 5ð þ 3Þdlog me=2.</formula><p>Chooses a random odd -bit integer p from ð2Z Z þ 1Þ \ ð2 À1 ; 2 Þ as the secret key sk. Randomly chooses q 0 from ð2Z Z þ 1Þ \ ½1; 2 =pÞ and sets x 0 ¼ q 0 p. The public key is pk ¼ x 0 . 2. Encryptðpk; MÞ: To encrypt M 2 f0; 1g, the user, who knows the secret key sk ¼ p, randomly chooses q from ½1; 2 =pÞ and an integer r from ðÀ2 ; 2 Þ and outputs the ciphertext</p><formula xml:id="formula_33">c ¼ EðM; pkÞ ¼ ðM þ 2 Á r þ q Á pÞ mod x 0 :</formula><p>3. Decryptðsk; cÞ: With the secret key p, the user decrypts a ciphertext as the DGHV somewhat scheme, that is, M ¼ Dðc; skÞ ¼ ðc mod pÞ mod 2:</p><p>4. Homomorphic addition (Add): Using the public key x 0 , the database server adds two ciphertexts c 1 and c 2 as the DGHV somewhat scheme, that is,</p><formula xml:id="formula_34">Addðc 1 ; c 2 Þ ¼ ðc 1 þ c 2 Þ mod x 0 :</formula><p>5. Homomorphic multiplication (Mult): Using the public key x 0 , the database server multiplies two ciphertexts c 1 and c 2 as the DGHVa somewhat scheme, that is,</p><formula xml:id="formula_35">Multðc 1 ; c 2 Þ ¼ ðc 1 Á c 2 Þ mod x 0 :</formula><p>Like the DGHV somewhat scheme, the choice of parameters in the variant scheme achieves at least 2 security against all of known attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Practical Single-Database PBR from V-DGHV Scheme</head><p>Assume that an n-bit database DB is equally partitioned into m blocks, denoted as DB ¼ B 1 kB 2 . . . kB m , the practical single-database PBR from the variant of DGHV scheme is described as follows: Query generation QGðm; i;</p><formula xml:id="formula_36">1 k Þ.</formula><p>Inputs: The number m of blocks in the database DB, an index i 2 ½1; m, KG, E, and a security parameter k.</p><p>Outputs: A query Q ¼ ðx 0 ; Eði; pkÞÞ and a secret sk ¼ p, where (x 0 ; pÞ is a public and private key pair for the V-DGHV scheme. Algorithm QGðm; i;</p><formula xml:id="formula_37">1 k Þ:</formula><p>1. (The user) generates a public and private key pair (x 0 ; p) with the key generation algorithm (KG) of the V-DGHV scheme and the security parameter k. 2. Assume that the binary representation of i is 1 2 . . . ' , where i 2 f0; 1g and ' ¼ dlog me. (The user) encrypts each a j with the public key x 0 , denoted as j ¼ Eð j ; x 0 Þ ¼ ð j þ 2 Á r j þ q j Á pÞ mod x 0 , where r j and q j are randomly chosen on the basis of V-DGHV scheme. Let Eði; x 0 Þ ¼ ð 1 ; 2 ; . . . ; ' Þ. 3. Output the query Q ¼ ðx 0 ; Eði; x 0 ÞÞ and a secret sk ¼ p. Response generation RGðDB; Q; 1 k Þ.</p><p>Inputs: An n-bit database DB ¼ B 1 kB 2 . . . kB m , where B j ¼ ðb j;1 ; b j;2 ; . . . ; b j;L Þ and L ¼ n=m, a query Q ¼ ðx 0 ; Eði; x 0 ÞÞ, E, Add, Mult, and a security parameter k.</p><p>Output: A response R.</p><formula xml:id="formula_38">Algorithm RGðDB; Q; 1 k Þ:</formula><p>1. For each index j 2 ½1; m, (the database server) writes j in the binary representation j;1 j;2 . . . j;' . (The database server) computes</p><formula xml:id="formula_39">j ¼ Y ' t¼1 ð t þ ð j;t È 1ÞÞ mod x 0 :<label>ð9Þ</label></formula><p>2. For each c 2 ½1; L, (the database server) computes</p><formula xml:id="formula_40">R c ¼ X bj;c¼1 j mod x 0 :<label>ð10Þ</label></formula><formula xml:id="formula_41">3. Output the response R ¼ ðR 1 ; R 2 ; . . . ; R L Þ:</formula><p>Response retrieval RRððQ; pÞ; RÞ. Inputs: sk ¼ p, an output of QGðn; i; <ref type="figure"></ref>and<ref type="figure">D</ref>.</p><formula xml:id="formula_42">1 k Þ; R, an output of RGðDB; Q; 1 k Þ,</formula><p>Output: A block B 0 ¼ ððR 1 mod pÞ mod 2, ðR 2 mod pÞ mod 2; . . . ; ðR L mod pÞ mod 2Þ.</p><p>Theorem 3. The V-DGHV scheme can correctly evaluate the response generation circuit of our practical PBR protocol.</p><p>Proof. Suppose that the size of the noise in</p><formula xml:id="formula_43">Q s t¼1 c i is N ðsÞ, where c t ¼ ðm t þ 2r t þ q t pÞ mod x 0 is a fresh ciphertext and r t 2 ðÀ2 ; 2 Þ. According to (2), the part of the noise in c 1 c 2 is 2r 1 r 2 þ r 1 m 2 þ r 2 m 1 and N ð2Þ 2 Á 2 Á 2 þ 2 þ 2 &lt; 2 2þ2 :<label>ð11Þ</label></formula><p>For any s &gt; 2, we have</p><formula xml:id="formula_44">N ðsÞ 2 Á N ðs À 1Þ Á 2 þ N ðs À 1Þ þ 2 &lt; 2 sþ2ðsÀ1Þ ¼ 2 ðþ2ÞsÀ2 :<label>ð12Þ</label></formula><p>Therefore, for each 1 j m, the size of the noise in</p><formula xml:id="formula_45">j ¼ Y ' t¼1 À t þ ð j;t È 1Þ Á mod x 0 ð' ¼ dlog meÞ</formula><p>is less than 2 ðþ2Þdlog meÀ2 and thus the size of the noise in R c ¼ t u þ bj;c¼1 j for each c is less than</p><formula xml:id="formula_46">2 ðþ2Þdlog meÀ2 m 2 ðþ3Þdlog me =4;</formula><p>which is less than p=2.</p><p>In view of it, the V-DGHV scheme can correctly decrypt R c for any 1 c n=m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>t u</head><p>Based on the correctness of the generic PBR from FHE (Theorem 2), we can see that our practical PBR protocol is correct as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SECURITY ANALYSIS</head><p>Since the single-database PBR protocol is a combination of the single-database PIR protocol and the practical PBR protocol from FHE is a special case of the generic PBR from FHE, we only need to analyze the security of the generic PIR protocol from FHE.</p><p>Based on the formal definition of security for singledatabase PIR protocol given in Section 2, we have Theorem 4. Assume that the underlying FHE scheme is semantically secure, then the generic single-database PIR protocol from FHE is semantically secure.</p><p>Proof. We denote by (KG, E, D, Add, Mult) the underlying FHE scheme. With reference to <ref type="bibr" target="#b32">[34]</ref>, suppose that there exists an adversary (a database server) A that can gain a nonnegligible advantage in the semantic security game for the generic single-database PIR protocol. We prove that there exists an adversary A 0 (built on A) who can gain a nonnegligible advantage in breaking the semantic security of the underlying FHE scheme as follows:</p><p>The adversary A 0 initiates the semantic security game for the FHE scheme with some challenger C 0 , which will send A 0 the public key pk for the challenge. For messages m 0 and m 1 , we choose m 0 ¼ 0 2 f0; 1g and m 1 ¼ 1 2 f0; 1g. After sending m 0 ; m 1 back to the challenger C 0 , the adversary A 0 will receive e b ¼ Eðm b Þ, an encryption of one of these two values. Next, A 0 , playing a challenger C, initiates the single-database PIR game with the adversary A with an n-bit database, who will give A 0 two different indices 1 i; j n.</p><p>Let x 0 ¼ i and x 1 ¼ j. The adversary A 0 picks a random bit q, and constructs a Q q as follows: Assume that the binary expression of x q is ð q;1 q;2 . . . q;' Þ where ' ¼ log n. The adversary A 0 constructs the encryption of x q by replacing all zeros with 0 and all ones with 0 t u þ e b . Note that 0 is the encryption of 0 with the public key pk and different randomness are chosen in 0 for different bits. We denote the result as Y q ¼ ð ŷ q;1 ; ŷ q;2 ; . . . ; ŷq' Þ. Now, the adversary A 0 gives a query Q q ¼ ðpk; Y q Þ to the adversary A, who then returns a guess q 0 . With probability 1/2, e b is the encryption of 0, and hence Y q is the encryption of all zeros, z ¼ t u Â ' t¼1 ð ŷ q;t t u þ z;t t u þ 1Þ ¼ 0 for all 1 z n, and</p><formula xml:id="formula_47">R ¼ t u þ b z ¼1 z ¼ 0.</formula><p>In this event, A's guess is independent of q, and hence the probability q 0 ¼ q is 1/2.</p><p>However, with probability 1/2, e b ¼ 1, hence Y q is the encryption of x q , constructed exactly as in the QG algorithm, and hence in this case with probability 1=2 þ , the adversary A will guess q correctly, as the behavior of A 0 was indistinguishable for an actual challenger C. The adversary A 0 determines his guess b 0 as follows: If A guesses q 0 ¼ q correctly, then A 0 will set b 0 ¼ 1, and otherwise A 0 will set b 0 ¼ 0. Putting it all together, we can now compute the probability that the guess of A 0 is correct:</p><formula xml:id="formula_48">Prðb 0 ¼ bÞ ¼ 1 2 1 2 þ 1 2 1 2 þ ¼ 1 2 þ 2 :</formula><p>Therefore, the adversary A 0 has obtained a nonnegligible advantage in the semantic security game for the underlying FHE scheme, a contradiction to our assumption in the theorem. Thus, the generic PIR protocol is semantically secure according to the security definition. t u</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">PERFORMANCE ANALYSIS</head><p>The PIR protocol is a special case of the PBR protocol when each block contains single bit. In this section, we only analyze the performance of our single-database PBR protocol and then compare it with some existing protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Theoretic Performance Analysis</head><p>In the generic single-database PBR from FHE, assume that the database DB has n bits, which are equally divided into m blocks, the user needs to encrypt log m bits and decrypt n=m ciphertexts, while the database server needs to perform about m log m Mult operations with reference to <ref type="bibr" target="#b6">(7)</ref>. and about n=2 Add operations in average with reference to <ref type="bibr" target="#b7">(8)</ref>.</p><p>The user and the database server need to exchange the public key pk and log m þ n=m ciphertexts. Assume that the ciphertext size is , then the communication complexity is Oð log m þ n=mÞ bits plus the public key size. The generic single-database PBR protocol is built on a FHE scheme. So far, several FHE schemes have been proposed, such as <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b33">[35]</ref>, <ref type="bibr" target="#b34">[36]</ref>. Recently, Gentry and Halevi implemented their lattice-based FHE scheme <ref type="bibr" target="#b18">[19]</ref>. To evaluate all kinds of circuits, all existing FHE schemes are impractical. However, FHE schemes are usually constructed from simple and practical somewhat homomorphic encryption schemes, which are able to evaluate some simple circuits.</p><p>In the generic single-database PBR protocol, the degree of the boolean function corresponding to the response generation circuit evaluated by the database server is about log m only. Therefore, it is possible for the PBR protocol to build on a somewhat homomorphic encryption scheme in appropriate setting.</p><p>In the practical single-database PBR protocol, the public key x 0 has the same size as a ciphertext, and the Add and Mult operations are modular addition and multiplication. Therefore, the total communication complexity is Oð log m þ n=mÞ bits and the computation complexity for the database server to generate a response is Oðm 2 log m þ n=2Þ bit operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Experiment</head><p>Assume that the database DB is equally partitioned into m ¼ 10,000 blocks, and the underlying encryption scheme is a variant of the DGHV somewhat homomorphic encryption scheme <ref type="bibr" target="#b11">[12]</ref> with parameters ¼ 60; ¼ 882; ¼ 2,205. In this setting, the somewhat encryption scheme is able to evaluate the response generation circuit of the practical PBR protocol without error and achieve the security level of 2 60 . Both the ciphertext size and the public key size are 2,205 bits. Therefore, the total communication complexities for the practical PBR are about 3,3075 þ 2,205n=10,000 bits. When n &gt; 42,431, the communication complexity of the practical PBR is less than the database size n. If the database server compresses the ciphertexts as in <ref type="bibr" target="#b11">[12]</ref>, where a compressed ciphertext has the same size as an RSA modulus, i.e., about 1,000 bits, our PBR protocol can reduce the communication complexity significantly.</p><p>To generate the response R, the database server needs to compute (including randomly generating r and q) takes about 0.00001 seconds, and the modular addition and multiplication of two ciphertexts take about 0.000001 and 0.00006 seconds, respectively. The addition of two ciphertext without modulo x 0 takes about 0.0000001 seconds. The total time for the user to generate a query Q is about 0.00015 second, the total time for the database server to generate a response R is about 2 minute, when the database size is 2 Â 10 9 bits (equally divided into 10,000 blocks, each of which has 200k bits). Our PBR protocol allows parallel computation. If the database server runs 20 processors in parallel, it takes about 6 seconds to generate a response. In addition, the total communication overhead is about ð15 þ 200,000Þ Â 2,205 bits. Over a line speed of 100-Mb/second, the transmission time is about 4.5 second, which is negligible in comparison with the computation time.</p><formula xml:id="formula_49">j ¼ Q ' t¼1 ½ t þ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Comparison</head><p>In our single-database PBR protocols, the user sends the encryption of the index of a block to the database server and then receives the encryption of the block. It can be seen that our solution is conceptually simpler than existing PIR and PBR protocols.</p><p>In the PIR and PBR protocols <ref type="bibr" target="#b21">[23]</ref>, <ref type="bibr" target="#b23">[25]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b13">[14]</ref>, the database server usually needs to compute about n=2 modular multiplications for a large modulus N in average. For example, the database server in the Gentry-Ramzan PBR protocol <ref type="bibr" target="#b13">[14]</ref> needs to compute g e ðmod NÞ, where e has the same size as the database, i.e., n bits. Computing the modular exponentiation requires about n=2 multiplications modulo N in average. In our practical PBR protocol, the database server needs to compute about m log m modular multiplications and n=2 modular additions. Based on the implementation of our practical PBR protocol where n ¼ 2 Â 10 9 and m ¼ 10 4 , it takes about 2 minute for the database server to generate a response (without parallel computation). In the same setting, the database server in the PBR protocols <ref type="bibr" target="#b21">[23]</ref>, <ref type="bibr" target="#b23">[25]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b13">[14]</ref>, needs about 17 hours to generate a response. In terms of computation complexity, our practical PBR protocol is more efficient than these PBR protocols when the block in the database has a relatively large size.</p><p>Our single-database PBR protocols are built on a FHE scheme, which can encrypt only one bit. We encrypt a block of bits in the database bit by bit and therefore our communication complexity Oð log m þ n=mÞ is higher than Oðlog 2 nÞ, the current best bound for communication complexity. With the deployment of 100-Gb Ethernet and the development of terabit Ethernet in the future, the transmission for a large amount of data over the Internet will take less and less time. In practice, the timing difference of transmitting Oð log m þ n=mÞ bits and Oðlog 2 nÞ bits over a high speed network is negligible in case when both transmissions take a few seconds, but the timing difference of generating a response is a few hours.</p><p>In the lattice-based PIR protocol <ref type="bibr" target="#b1">[2]</ref>, suppose that a database has n ¼ 1,000 elements of size 2 MB and the user generates a query composed of N Â 2N (N ¼ 50) matrices B 1 ; B 2 ; . . . ; B n over GF ðpÞ (p ¼ 2 60 þ 325) and sends it to the database server, which encodes the database to L Â N (L ¼ 16 Á 2 6 =3000) matrices A 1 ; A 2 ; . . . ; A n , and computes the response R ¼ ðA 1 ; A 2 ; . . . ; A n ÞðB 1 ; B 2 ; Á Á Á ; B n Þ T . The computation complexity for generating a response is Oð10 14 Þ bit operations. For the same database, the experiment on a server with a T7700 Core 2 Duo processor in <ref type="bibr" target="#b1">[2]</ref> showed that the response generation phases in Lipmaa <ref type="bibr" target="#b23">[25]</ref>, Gentry-Ramzan <ref type="bibr" target="#b13">[14]</ref>, and the lattice-based PIR <ref type="bibr" target="#b1">[2]</ref> protocols take 33 hours, 17 hours, and 10 minutes, respectively. If we run our practical PBR protocol for the same database, the computation complexity for the response generation is Oð10 13 Þ bit operations, one order of magnitude less than the latticed-based PIR protocol. Based on the same experimental results in <ref type="bibr" target="#b1">[2]</ref>, our practical PBR takes about 1 minute to generate a response.</p><p>In our single-database practical PBR protocol, the underlying FHE is the variant of DGHV somewhat scheme, whose security is based on the approximate-gcd problem (please refer to Section 2.2). Lipmaa <ref type="bibr" target="#b23">[25]</ref> and Gentry-Ramzan <ref type="bibr" target="#b13">[14]</ref> protocols are based on classic assumptions such as È-hiding or quadratic residuosity. The cryptographic assumption of our protocol is weaker than those of Lipmaa <ref type="bibr" target="#b23">[25]</ref> and Gentry-Ramzan <ref type="bibr" target="#b13">[14]</ref> protocols. However, our construction is much simpler than theirs.</p><p>The additively homomorphic encryption scheme with d-operand multiplications proposed by Aguilar-Melchor et al. <ref type="bibr" target="#b2">[3]</ref> can be used to evaluate our multivariate polynomials <ref type="bibr" target="#b6">(7)</ref> and <ref type="bibr" target="#b7">(8)</ref> for encrypted data in our PBR protocol. This scheme needs two chainable encryptions to compound two ciphertexts to one ciphertext and a series of chainable decryptions to decrypt a compound ciphertext. The variant of DGHV somewhat scheme needs only one modular operation to compound two ciphertext to one ciphertext and only one modular operation to decrypt a compound ciphertext. Our protocol built on the variant of DGHV somewhat scheme is much easier to be implemented than our protocol built on Aguilar-Melchor et al.'s scheme <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>In this paper, we have presented generic single-database PIR and PBR protocols from FHE, and a practical single-database PBR protocol from a variant of DGHV scheme. Our protocols work as if the user sends the index of a bit or a block to the database server and then receives the bit or the block from the database server. Security analysis has shown that the generic single-database PIR is semantically secure if the underlying FHE scheme is semantically secure.</p><p>We have implemented our practical PBR protocol based on a variant of the DGHV somewhat homomorphic encryption scheme for a database composed of 10,000 elements of size of 200k bits. On an Intel Core2 Duo CPU E4600 with clock speed of 2.40 GHz, our experiment has shown that our PBR protocol is practical.</p><p>Compared with existing PIR and PBR protocols, our PIR and PBR protocols are conceptually simpler. Our practical PBR protocol has lower computation complexity but higher communication complexity than existing PBR protocols. Overall, our practical PBR protocol is more efficient than existing PBR protocols in terms of total protocol execution time when a high-speed network is available.</p><p>Our future work will further improve efficiency of PIR and PBR protocols from variants of existing FHE schemes, such as <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1 .</head><label>1</label><figDesc>The adversary A chooses two different indices 1 i; j n and sends them to C. 2. Let 0 ¼ i and 1 ¼ j. The challenger C chooses a random bit b 2 f0; 1g, and executes QGðn; b ; 1 k Þ to obtain ðQ b ; sÞ, and then sends Q b back to A. 3. The adversary A can experiment with the code of Q b in an arbitrary nonblack-box way, and finally outputs b 0 2 f0; 1g. The adversary wins the game if b 0 ¼ b and loses otherwise.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>and D.</figDesc><table><row><cell>Output: A block</cell></row><row><cell>B 0 ¼ ðDðR 1 ; skÞ; DðR 2 ; skÞ; . . . ; DðR L ; skÞÞ:</cell></row><row><cell>Theorem 2 (Correctness). The generic single-database PBR</cell></row><row><cell>from FHE is correct for any security parameter k, any database</cell></row><row><cell>DB with any size n and any number m of blocks, and any</cell></row><row><cell>index 1 i m.</cell></row></table><note><p><p><p>Proof. The generic single-database PBR can be viewed as running L generic single-database PIR protocols in parallel. In each single-database PIR, the user retrieves the ith bit from an m-bit database</p>DB c ¼ b 1;c b 2;c . . . b m;c for 1 c L. t u</p>Based on Theorem 1, we know each of L single-database PIR protocol is correct, that is, DðR c ; skÞ ¼ b i;c for 1 c L. Therefore, we have B 0 ¼ ðDðR 1 ; skÞ; DðR 2 ; skÞ; . . . ; DðR L ; skÞÞ ¼ B i 4.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>ð j;t È 1Þ x0 and R c ¼ ½ P bj;c¼1 j x0 , where ' ¼ log m; 1 j m; 1 c n=m. The computation complexity is about 130,000 modular multiplications and n=2 modular additions in average, where the modulus x 0 has 2,205 bits.In this setting, we have implemented our PBR protocol (without compressing ciphertexts) with GMP version 5.0.2 [20], a highly optimized library for arbitrary precision arithmetic. In our implementation, we choose the private and public key pair (p; x 0 ) as follows: GHz, our encryption of one bit by c ¼ ½M þ 2r þ qp x0</figDesc><table><row><cell>p ¼ 17208191039508640929200576374999711030596601</cell></row><row><cell>29893779942568467253655521644657786345719504128</cell></row><row><cell>38051033305541156961429645296757557163794012509</cell></row><row><cell>14003744945293157980595942640451243898446460567</cell></row><row><cell>72770258422144622675796928192080365842783838721</cell></row><row><cell>1779871163793578332163909558303151,</cell></row><row><cell>x 0 ¼ 26995994051987058340696791927386621148530680</cell></row><row><cell>228785768115885185298822839356515844014594889340</cell></row><row><cell>872966884351285197639185885398279863800730476728</cell></row><row><cell>500299068286237357728208568513451075996848153990</cell></row><row><cell>688348444845602260155330522967623003731186027028</cell></row><row><cell>535988354635989225653431149930417553648090078778</cell></row><row><cell>840027799178806324435233078876516764950304624764</cell></row><row><cell>471258266695226539642564422402303542362725774410</cell></row><row><cell>839335882064377945737808337545320750967712766283</cell></row><row><cell>153865143838298357131422030563031417949370771316</cell></row><row><cell>488837892274387753389005582029398287713625948118</cell></row><row><cell>026786533890132497964987851958713620334994269130</cell></row><row><cell>133868714597009184901835011945026618675551476060</cell></row><row><cell>70523977230371667356941297787012675390603483.</cell></row><row><cell>On an Intel Core2 Duo CPU E4600 with clock speed of</cell></row><row><cell>2.40</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors would like to thank blind reviewers for their constructive comments on this work. This work reported in this paper has been partially supported by the Australian Research Council under grant DP0988411 and the US National Science Foundation under grant CNS-1016722.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>. For more information on this or any other computing topic, please visit our Digital Library at www.computer.org/publications/dlib.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Lattice-Based Computationally-Efficient Private Information Retrieval Protocol</title>
		<author>
			<persName><forename type="first">C</forename><surname>Aguilar-Melchor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gaborit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Western European Workshop Research in Cryptology (WEWORC &apos;07)</title>
		<meeting>Western European Workshop Research in Cryptology (WEWORC &apos;07)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Fast Private Information Retrieval Protocol</title>
		<author>
			<persName><forename type="first">C</forename><surname>Aguilar-Melchor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gaborit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int&apos;l Symp. Information Theory (ISIT &apos;08)</title>
		<meeting>IEEE Int&apos;l Symp. Information Theory (ISIT &apos;08)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Additively Homomorphic Encryption with D-Operand Multiplications</title>
		<author>
			<persName><forename type="first">C</forename><surname>Aguilar-Melchor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gaborit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Herranz</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2008/378" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Fully Homomorphic Encryption without Bootstrapping</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2011/277" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Efficient Fully Homomorphic Encryption from (Standard) LWE</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2011/344" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">All-or-Nothing Disclosure of Secrets</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crepeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Robert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Advances in Cryptology</title>
		<meeting>Advances in Cryptology</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="234" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Computationally Private Information Retrieval with Polylogarithmic Communication</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th Int&apos;l Conf. Theory and Application of Cryptographic Techniques (EUROCRYPT &apos;99)</title>
		<meeting>17th Int&apos;l Conf. Theory and Application of Cryptographic Techniques (EUROCRYPT &apos;99)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="402" to="414" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Single Database Private Information Retrieval with Logarithmic Communication</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Ninth Australasian Conf. Information Security and Privacy (ACISP &apos;04)</title>
		<meeting>Ninth Australasian Conf. Information Security and Privacy (ACISP &apos;04)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="50" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Private Information Retrieval</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 36th Ann. Conf. Foundations of Computer Science</title>
		<meeting>IEEE 36th Ann. Conf. Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Single-Database Private Information Retrieval Implies Oblivious Transfer</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Crescenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th Int&apos;l Conf. Theory and Application of Cryptographic Techniques (EUROCRYPT &apos;00)</title>
		<meeting>19th Int&apos;l Conf. Theory and Application of Cryptographic Techniques (EUROCRYPT &apos;00)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="122" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Generalisation, a Simplification and Some Applications of Paillier&apos;s Probabilistic Public-Key System</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jurik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fourth Int&apos;l Workshop Practice and Theory in Public Key Cryptography (PKC &apos;01)</title>
		<meeting>Fourth Int&apos;l Workshop Practice and Theory in Public Key Cryptography (PKC &apos;01)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="119" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fully Homomorphic Encryption over the Integers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th Ann. Int&apos;l Conf. Theory and Applications of Cryptographic Techniques (EURO-CRYPT &apos;10)</title>
		<meeting>29th Ann. Int&apos;l Conf. Theory and Applications of Cryptographic Techniques (EURO-CRYPT &apos;10)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="24" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Randomized Protocol for Signing Contracts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="637" to="647" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Single Database Private Information Retrieval with Constant Communication Rate</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ramzan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 32nd Int&apos;l Colloquium on Automata, Languages and Programming (ICALP &apos;05)</title>
		<meeting>32nd Int&apos;l Colloquium on Automata, Languages and Programming (ICALP &apos;05)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="803" to="815" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Fully Homomorphic Encryption Scheme</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<ptr target="http://crypto.stanford.edu/craig" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>Stanford Univ</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
	<note>manuscript</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fully Homomorphic Encryption Using Ideal Lattices</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 41st ACM Ann. Symp. Theory of Computing (STOC &apos;09)</title>
		<meeting>41st ACM Ann. Symp. Theory of Computing (STOC &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Computing Arbitrary Functions of Encrypted Data</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="97" to="105" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Toward Basing Fully Homomorphic Encryption on Worst-Case Hardness</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th Ann. Conf. Advances in Cryptology (CRYPTO &apos;10)</title>
		<meeting>30th Ann. Conf. Advances in Cryptology (CRYPTO &apos;10)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="116" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Implementing Gentry&apos;s Fully-Homomorphic Encryption Scheme</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th Ann. Int&apos;l Conf. Theory and Applications of Cryptographic Techniques (EUROCRYPT &apos;11)</title>
		<meeting>30th Ann. Int&apos;l Conf. Theory and Applications of Cryptographic Techniques (EUROCRYPT &apos;11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Hard Predicate for all One-Way Functions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM 21st Ann. Symp. Theory of Computing (STOC &apos;89)</title>
		<meeting>ACM 21st Ann. Symp. Theory of Computing (STOC &apos;89)</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="23" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Probabilistic Encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Computer and Systems Sciences</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="270" to="299" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Replication is Not Needed: Single Database, Computationally-Private Information Retrieval</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 38th Ann. Symp. the Foundations of Computer Science</title>
		<meeting>IEEE 38th Ann. Symp. the Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="364" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">One-Way Trapdoor Permutations Are Sufficient for Non-Trivial Single-Server Private Information Retrieval</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th Int&apos;l Conf. Theory and Application of Cryptographic Techniques (EUROCRYPT &apos;00)</title>
		<meeting>19th Int&apos;l Conf. Theory and Application of Cryptographic Techniques (EUROCRYPT &apos;00)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="104" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An Oblivious Transfer Protocol with Log-Squared Communication</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eighth Information Security Conf</title>
		<meeting>Eighth Information Security Conf</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="314" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">First CPIR Protocol with Data-Dependent Computation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int&apos;l Conf. Information Security and Cryptology (ICISC &apos;09)</title>
		<meeting>12th Int&apos;l Conf. Information Security and Cryptology (ICISC &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="193" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Universal One-Way Hash Functions and Their Cryptographic Applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM 21st Ann. Symp. Theory of Computing (STOC &apos;89)</title>
		<meeting>ACM 21st Ann. Symp. Theory of Computing (STOC &apos;89)</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="33" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Oblivious Transfer and Polynomial Evaluation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM 31st Ann. Symp. Theory of Computing (STOC &apos;99)</title>
		<meeting>ACM 31st Ann. Symp. Theory of Computing (STOC &apos;99)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="245" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Revisiting the Computational Practicality of Private Information Retrieval</title>
		<author>
			<persName><forename type="first">F</forename><surname>Olumofin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goldberg</surname></persName>
		</author>
		<idno>CACR 2010-17</idno>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
		<respStmt>
			<orgName>Univ. of Waterloo</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A Survey of Single-Database PIR: Techniques and Applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Skeith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th Int&apos;l Conf. Practice and Theory in Public (PKC &apos;07)</title>
		<meeting>10th Int&apos;l Conf. Practice and Theory in Public (PKC &apos;07)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="393" to="411" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Public Key Cryptosystems Based on Composite Degree Residue Classes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th Int&apos;l Conf. Theory and Application of Cryptographic Techniques (EUROCRYPT &apos;99)</title>
		<meeting>17th Int&apos;l Conf. Theory and Application of Cryptographic Techniques (EUROCRYPT &apos;99)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An Improved Algorithm for Computing Logarithms over GF(p) and Its Cryptographic Significance</title>
		<author>
			<persName><forename type="first">S</forename><surname>Pohlig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Information Theory</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="106" to="110" />
			<date type="published" when="1978-01">Jan. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">How to Exchange Secrets by Oblivious Transfer</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
		<idno>TR-81</idno>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>Aiken Computation Laboratory, Harvard Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Non-Interactive Cryptocomputing for NC1</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 40th Ann. Symp. Foundations of Computer Science</title>
		<meeting>40th Ann. Symp. Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="554" to="567" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Fully Homomorphic Encryption with Relatively Small Key and Ciphertext Sizes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vercauteren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Int&apos;l Conf. Practice and Theory in Public Key Cryptography (PKC &apos;10)</title>
		<meeting>13th Int&apos;l Conf. Practice and Theory in Public Key Cryptography (PKC &apos;10)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="420" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">His research interests include applied cryptography, computer and network security, mobile and wireless communication security, and privacy-preserving data mining. He has published more than 100 research papers in international journals, such as IEEE Trans. Knowledge and Data Engineering, IEEE Trans. Wireless Communication</title>
		<author>
			<persName><forename type="first">D</forename><surname>Stehle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Steinfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Advances in Cryptology (ASIACRYPT &apos;10)</title>
		<meeting>Advances in Cryptology (ASIACRYPT &apos;10)<address><addrLine>Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="377" to="394" />
		</imprint>
		<respStmt>
			<orgName>of Engineering and Science, Victoria University</orgName>
		</respStmt>
	</monogr>
	<note>He has been a program committee member for more than 20 international conferences. He is leading a few Australia Research Council (ARC) Discovery Projects</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
