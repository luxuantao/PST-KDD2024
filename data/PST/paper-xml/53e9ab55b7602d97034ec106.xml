<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Annotated XML: Queries and Provenance</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nathan</forename><surname>Foster</surname></persName>
							<email>jnfoster@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
							<email>tjgreen@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Annotated XML: Queries and Provenance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D6A752E42D2F7497637137D2243C3FDA</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.1 [Database Management]: Data Models Theory</term>
					<term>Algorithms</term>
					<term>Languages Data provenance</term>
					<term>semirings</term>
					<term>complex values</term>
					<term>XML</term>
					<term>XQuery</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a formal framework for capturing the provenance of data appearing in XQuery views of XML. Building on previous work on relations and their (positive) query languages, we decorate unordered XML with annotations from commutative semirings and show that these annotations suffice for a large positive fragment of XQuery applied to this data. In addition to tracking provenance metadata, the framework can be used to represent and process XML with repetitions, incomplete XML, and probabilistic XML, and provides a basis for enforcing access control policies in security applications.</p><p>Each of these applications builds on our semantics for XQuery, which we present in several steps: we generalize the semantics of the Nested Relational Calculus (NRC) to handle semiring-annotated complex values, we extend it with a recursive type and structural recursion operator for trees, and we define a semantics for XQuery on annotated XML by translation into this calculus.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Recent work has shown that many of the mechanisms for evaluating queries over annotated relations-e.g., incomplete and probabilistic databases, databases with multiplicities (bags), and those carrying provenance annotations-can be unified in a general framework based on commutative semirings (see definition in §2). Intuitively, one of the semiring operations models alternative uses of data while the other models its joint (or dependent) use. In <ref type="bibr" target="#b15">[16]</ref>, semantics for positive relational algebra (i.e., unions of conjunctive queries) and positive Datalog were defined for relations decorated with annotations from a semiring. The same paper identified a canonical notation for provenance annotations using semiring polynomials (and formal power series) that captures, abstractly, computations in arbitrary semirings and therefore serves as a good representation for implementations <ref type="bibr" target="#b14">[15]</ref>.</p><p>This work has opened up a number of interesting avenues for investigation but its restriction to the relational model is limiting. One of the main areas that motivates work on provenance is scientific data processing. In these applications, relational data sources are often combined with data extracted from hierarchical repositories of files. XML provides a natural model for tree-structured, heterogeneous sources, but current systems for managing XML data do not provide mechanisms for decorating XML with provenance annotations and for propagating annotated data through queries. A major goal of this work is to extend the framework for semiringannotated relations described in <ref type="bibr" target="#b15">[16]</ref> to handle annotated XML data.</p><p>Besides provenance, our work is also motivated by applications to incomplete and probabilistic XML data. Incomplete XML has not received much attention so far (see §8), but significant work has been done on probabilistic XML. For example, in <ref type="bibr" target="#b26">[27]</ref>, the uncertainty associated with data obtained by probing the "hidden web" (i.e., data hidden behind query forms and web services) is represented using XML trees whose nodes are annotated with boolean expressions composed of independent Bernoulli event variables.</p><p>Starting from these motivations, we develop an extension of the semiring annotation framework to XML and its premier query language, XQuery <ref type="bibr" target="#b10">[11]</ref>. Because dealing with lists and ordered XML does not seem to be related to the way we use semirings (see §8), we focus on an unordered variant of XML. Previous work <ref type="bibr" target="#b15">[16]</ref> provided strong evidence that the idea of using semirings to represent annotations is robust. In this work, we describe two new results that add to this body of evidence:</p><p>• We define the semantics for a large fragment of first-order, positive XQuery-practically all of the features that do not depend on order-on semiring-annotated XML in two different ways, and show that these agree. The first approach goes by translation to an extension of the nested relational calculus <ref type="bibr" target="#b7">[8]</ref> (NRC), <ref type="foot" target="#foot_0">1</ref> while the second uses an encoding that "shreds" XML data into a child relation between node identifiers, and a corresponding translation of XPath into Datalog.</p><p>• We prove a general theorem showing that the semantics of queries commutes with the applications of semiring homomorphisms.</p><p>By instantiating our semantics using annotations formulated as polynomials over a fixed set of variables with coefficients in N, we obtain our main contribution: a provenance framework for unordered XML data and a large class of XQuery views. We believe that this framework has practical potential: it captures an intuitive notion of provenance useful for scientific applications <ref type="bibr" target="#b14">[15]</ref>, and the size of the provenance polynomials is bounded by O(|D| |q| ) where D is the XML database and q is the XQuery program that defines the view.</p><p>Additionally, we illustrate two important applications of annotated XML: a security application that shows how to transfer confidentiality policies from a database to a view by organizing the clearance levels as a commutative semiring, and general strong representation systems for incomplete and probabilistic annotated databases that use the provenance polynomials themselves as annotations. The correctness of these systems follows from the commutation with homomorphisms theorem.</p><p>In outline, the paper is organized as follows. §2 reviews the notion of commutative semiring annotations. §3 introduces the unordered XML data model (UXML) and the corresponding fragment of XQuery (UXQuery), and describes our extension of these formalisms with semiring annotations. We defer a formal discussion of the semantics of UXQuery to §6, but illustrate its behavior on several examples. We describe applications to security and incomplete and probabilistic data in §4 and §5. The main technical results are collected in §6. There we review NRC, describe its extension to trees (6.1), define its semantics (6.2), give the compilation of UXQuery into this language (6.3), and state the commutation with homomorphism theorems (6.4). §7 presents an alternative definition for a fragment of UXQuery, via an encoding of UXML into relations and a translation of XPath into Datalog. §8 describes related work; we conclude with a brief discussion of ongoing and future work in §9. The long version of this abstract contains the complete definitions of each of these systems and is available as a technical report <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">SEMIRING ANNOTATIONS</head><p>A commutative semiring (K, +, •, 0, 1) is an algebraic structure consisting of a set K, operations + and •, and distinguished elements 0, 1 ∈ K such that:</p><p>1. (K, +, 0) and (K, •, 1) are commutative monoids;</p><formula xml:id="formula_0">2. k1 • (k2 + k3) = k1 • k2 + k1 • k3, and 0 • k = 0.</formula><p>As shown in <ref type="bibr" target="#b15">[16]</ref>, commutative semirings and relational data fit together naturally: when each tuple in a relation is tagged with an element of K, the semantics of standard query languages can be generalized to propagate the annotations in a way that captures bag semantics, probabilistic and incomplete relations, and standard notions of provenance. An (imperfect) intuition for the meaning of these annotations is as follows: 0 means that the tuple is not present or available; k1 + k2 means that the tuple can be produced from the data described by k1 or that described by k2; and the annotation k1 • k2 means that it requires both the data described by k1 and that described by k2. The annotation 1 means that exactly one copy of the tuple is available "without restrictions." In the relational setting, it was shown that the axioms of commutative semirings are forced by standard equivalences on the (positive) relational algebra <ref type="bibr" target="#b15">[16]</ref>. In this work, we show that commutative semirings also suffice for a variety of annotated nested data and their associated query languages.</p><p>We develop our theory for arbitrary commutative semirings, but use specific semirings in various applications:</p><p>• (B, ∨, ∧, false, true): set-based data;</p><p>• (N, +, •, 0, 1): bag-based data;</p><p>• Positive boolean expressions: incomplete/probabilistic data (see <ref type="bibr" target="#b15">[16]</ref> and §5);</p><p>• Confidentiality levels: see §4;</p><p>• Lineage and why-provenance (it turns out that these are different and correspond to different semirings, see <ref type="bibr" target="#b3">[4]</ref>);</p><p>• (N[X], +, •, 0, 1): a "universal" semiring of multivariate polynomials with coefficients in N and indeterminates in X.</p><p>The polynomials in N[X] provide a very general and informative notion of provenance<ref type="foot" target="#foot_1">2</ref> and, in fact, capture the generality of all commutative semiring calculations: any function X -→ K can be uniquely extended to a semiring homomorphism N[X] -→ K. This fact is relevant to querying since (as in <ref type="bibr" target="#b15">[16]</ref>) by Theorem 1 and Corollary 1 below, our semantics for query answering commutes with applying homomorphisms to annotated data. This yields the principal result of our framework: a comprehensive notion of provenance for unordered XML and a corresponding fragment of XQuery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ANNOTATED AND UNORDERED XML</head><p>We fix a commutative semiring K and consider XML data modified so that instead of lists of trees (sequences of elements) there are sets of trees. Moreover, each tree belonging to such a set is decorated with an annotation k ∈ K. Since bags of elements can be obtained by interpreting the annotations as multiplicities (by picking K to be (N, +, •, 0, 1)), the only difference compared to standard XML is the absence of ordering between siblings. <ref type="foot" target="#foot_2">3</ref> We call such data K-annotated unordered XML, or simply K-UXML. Given a domain L of labels, the usual mutually recursive definition of XML data naturally generalizes to K-UXML: <ref type="foot" target="#foot_3">4</ref>• A value is either a label in L, a tree, or a K-set of trees;</p><p>• A tree consists of a label together with a finite (possibly empty) K-set of trees as its "children";</p><p>• A finite K-set of trees is a function from trees to K such that all but finitely many trees map to 0.</p><p>In examples, we illustrate K-UXML data by adding annotations as a superscript notation on the label at the root of the (sub)tree. By convention omitted annotations correspond to the "neutral" element 1 ∈ K. <ref type="foot" target="#foot_4">5</ref> Note that a tree gets an annotation only as a member of a K-set. To annotate a single tree, we place it in a singleton K-set. When the semiring of annotations is (B, ∨, ∧, false, true) we have essentially unannotated unordered XML; we write UXML instead of B-UXML.</p><p>In Figure <ref type="figure" target="#fig_8">1</ref>, two K-UXML data values are displayed as trees. The source value can be written in document style as Source: </p><formula xml:id="formula_1">( a z b x 1 d y 1 c x 2 d y 2 e y 3 ) Answer: p d z•x 1 •y 1 +z•x 2 •y 2 e z•x 2 •y 3</formula><formula xml:id="formula_2">&lt;a z &gt; &lt;b x 1 &gt; d y 1 &lt;/&gt; &lt;c x 2 &gt; d y 2 e y 3 &lt;/&gt; &lt;/&gt;</formula><p>where we have abbreviated leaves &lt;l&gt;&lt;/&gt; as l.</p><p>We propose a query language for K-UXML called K-UXQuery. Its syntax, listed in Figure <ref type="figure">2</ref>, corresponds to a core fragment of XQuery <ref type="bibr" target="#b10">[11]</ref> with one exception: the new construct annot k p allows queries to modify the annotations on sets. With annot k p any K-UXML value can be built with the K-UXQuery constructs.</p><p>We use the following types for K-UXML and K-UXQuery:</p><formula xml:id="formula_3">t ::= label | tree | {tree}</formula><p>where label denotes L, tree denotes the set of all trees and {tree} denotes the set of all finite K-sets of trees. The typing rules for selected K-UXQuery operators are given in Figure <ref type="figure" target="#fig_1">3</ref>.</p><p>At the end of this section we discuss this syntax in more detail, and in §6.3 we present a formal semantics that uses the operations of the semiring to combine annotations. In the rest of this section, however, we illustrate the semantics informally on some simple examples to introduce the basic ideas. We start with very simple queries demonstrating how the individual operators work, and build up to a larger example corresponding to a translation of a relational algebra query.</p><p>As a first example, let pi = element ai {()} for i ∈ {1, 2}. That is, each pi constructs a tree with no children. The query (p1) produces the singleton K-set in which p1 is annotated with 1 ∈ K and the query annot k1 (p1) produces the singleton K-set in which p1 is annotated with k1 • 1 = k1. We can also construct a union of K-sets: let q be annot k1 (p1),annot k2 (p2). The result computed by q depends on whether a1 and a2 are the same label or different labels. If a1 = a2 = a, then p1 and p2 are the same tree and so the query then element b {q} produces the left tree below. If a1 = a2, then the same query produces the tree on the right. Source:</p><formula xml:id="formula_4">b a k 1 +k 2 b a k 1 1 a k 2 Γ p/ax ::nt : {tree} Γ k ∈ K Γ p : {tree} Γ annot k p : {tree}</formula><formula xml:id="formula_5">( a b x 1 a c y 3 d c y 1 d a c y 2 b x 2 ) Answer: r c q 1 c y 1 d a c y 2 b x 2</formula><p>where</p><formula xml:id="formula_6">q 1 = x 1 • y 3 + y 1 • y 2 Figure 4: XPath Example.</formula><p>If $S is the (source) set on the left side of Figure <ref type="figure" target="#fig_8">1</ref>, then the answer produced by p is the tree on the right in the same figure. <ref type="foot" target="#foot_8">6</ref> Operationally, the query works as follows. First, the outer for-clause iterates over the set given by $S. As $S is a singleton in our example, $t is bound to the tree whose root is labeled a and annotation in $S is z. Next, the inner for-clause iterates over the set of trees given by ($t)/*:</p><formula xml:id="formula_7">( b x 1 d y 1 , c x 2 d y 2 e y 3 )</formula><p>It binds $x to each of these trees, evaluates the return-clause in this extended context, and multiplies the resulting set by the annotation on $x. For example, when $x is bound to the b child, the return-clause produces the singleton set (d y 1 ). Multiplying this set by the annotation x1 yields (d x 1 •y 1 ). After combining all the sets returned by iterations of this inner for-clause, we obtain the set (d</p><formula xml:id="formula_8">x 1 •x 1 +x 2 •y 2 , e x 2 •y 3 )</formula><p>. The final answer for p is obtained by multiplying this set by z. Note that the annotation on each child in the answer is the sum, over all paths that lead to that child in $t, of the product of the annotations from the root of $t to that child, thus recording how it arises from subtrees of $S.</p><p>Next we illustrate the semantics of XPath descendant navigation (shorthand //). Consider the query r = element r { $T//c } which picks out the set of subtrees of elements of $T whose label is c. A sample source and corresponding answer computed by r are shown in Figure <ref type="figure">4</ref>. In §6.3 we define the semantics of the descendant operator using structural recursion and iteration. It </p><formula xml:id="formula_9">c x 4 g c x 5 Q A C a c x 2 1 + x 1 • x 4 a e x 1 • x 2 d c x 1 • x 2 + x 2 • x 4 d e x 2 2 f c x 3 • x 5 f e x 2 3</formula><p>Source as UXML:</p><formula xml:id="formula_10">D R t x 1 A a B b C c t x 2 A d B b C e t x 3 A f B g C e S t x 4 B b C c t x 5 B g C c</formula><p>Query: has the property that the annotation for each subtree in the answer is the sum of the products of annotations for each path from the root to an occurrence of that subtree in the source, like the answer shown here. Now we turn to a larger example, which demonstrates how K-UXQuery behaves on an encoding of a database of relations whose tuples are annotated with elements of K (called K-relations in <ref type="bibr" target="#b15">[16]</ref>). As a sanity check, we verify that our semantics for K-UXQuery on this data agrees agrees with the semantics given for the positive relational algebra given previously <ref type="bibr" target="#b15">[16]</ref>. Consider the following relational algebra query</p><formula xml:id="formula_11">let $r := $d/R/*, $rAB := for $t in $r return &lt;t&gt; { $t/A,$t/B } &lt;/&gt;, $rBC := for $t in $r return &lt;t&gt; { $t/B,$t/C } &lt;/&gt;, $s := $d/S/* return &lt;Q&gt; { for $x in $rAB,$y in ($rBC,$s) where $x/B=$y/B return &lt;t&gt; { $x/A,$y/C } &lt;/&gt; } &lt;/&gt; Answer as UXML: Q t x 2 1 +x 1 •x 4 A a C c t x 1 •x 2 A a C e t x 1 •x 2 +x 2 •x 4 A d C c t x 2 2 A d C e t x 3 •x 5 A f C c t x 2 3 A f C e</formula><formula xml:id="formula_12">Q = πAC (πAB(R) (πBC (R) ∪ S))</formula><p>and suppose that we evaluate it over K-relations R(A, B, C) and S(B, C) shown at the top of Figure <ref type="figure" target="#fig_3">5</ref>. The result, cf. <ref type="bibr" target="#b15">[16]</ref>, is the Krelation Q(A, C), also shown at the top of Figure <ref type="figure" target="#fig_3">5</ref>. For example, the annotation on d c in Q is a sum of products x1 • x2 + x2 • x4, which records that the tuple can be obtained by joining two Rtuples or, alternatively, by joining an R-tuple and an S-tuple.</p><p>The rest of Figure <ref type="figure" target="#fig_3">5</ref> shows the K-UXML tree that is obtained by encoding the relations R and S in an obvious way, the corresponding translation of the view definition into K-UXQuery, and the K-UXML view that is computed using K-UXQuery. Observe that the result is the encoding of the K-relation Q. The next proposition states that this equivalence holds in general. (Throughout the paper we abuse notation and conflate the syntax and semantics of expressions-i.e., we write e instead of [[e]].)</p><formula xml:id="formula_13">Source: D R w 1 t x 1 A y 1 a B y 2 b z 1 C y 3 c t x 2 A y 1 d B y 2 b z 2 C y 3 e z 3 t x 3 A y 1 f B y 2 g z 4 C y 3 e z 5 S t x 4 B y 5 b z 6 C y 6 c t x 5 B y 5 g z 7 C y 6 c Answer: Q t q 1 A y 1 a C y 6 c t q 2 A y 1 a C y 3 c t q 3 A y 1 a C y 3 e z 3 t q 4 A y 1 d C y 6 c t q 5 A y 1 d C y 3 c t q 6 A y 1 d C y 3 e z 3 t q 7 A y 1 f C y 6 c t q 8 A y 1 f C y 3 e z 5</formula><p>where PROPOSITION 1. Let Q be be a query in positive relational algebra, and I a K-relational database instance. Let v be the K-UXML encoding of I, and p be the translation of Q into K-UXQuery. Then p(v ), computed according to K-UXQuery, encodes Q(I), the K-relation computed according to the semantics in <ref type="bibr" target="#b15">[16]</ref>.</p><formula xml:id="formula_14">q 1 = w 1 • x 1 • x 4 • y 2 • y 5 • z 1 • z 6 q 2 = w 2 1 • x 2 1 • y 2 2 • z 2 1 q 3 = w 2 1 • x 1 • x 2 • y 2 2 • z 1 • z 2 q 4 = w 1 • x 2 • x 4 • y 2 • y 5 • z 2 • z 6 q 5 = w 2 1 • x 1 • x 2 • y 2 2 • z 1 • z 2 q 6 = w 2 1 • x 2 2 • y 2 2 • z 2 2 q 7 = w 1 • x 3 • x 5 • y 2 • y 5 • z 4 • z 7 q 8 = w 2 1 • x 2 3 • y 2 2 • z 2 4</formula><p>In a K-relation, annotations only appear on tuples. In our model for annotated UXML data, however, every internal node carries an annotation (recall that, according to our convention, every node in Figure <ref type="figure" target="#fig_3">5</ref> depicted with no annotation carries the "neutral" element 1 ∈ K). Therefore, we have more flexibility in how we annotate source values-besides tuples, we can place annotations on the values in individual fields, on attributes on the relations themselves, and even on the whole database! It is interesting to see how, even for a query that is essentially relational, these extra annotations participate in the calculations. We have worked this out in the final example of this section, see Figure <ref type="figure" target="#fig_4">6</ref>. The query is the same as in Figure <ref type="figure" target="#fig_3">5</ref> but the source data has additional annotations. Note how the expressions annotating the tuple nodes in the answer involve many non-tuple annotations from the source.</p><p>So far we have assumed that the annotations belong to an arbitrary commutative semiring K and we looked at the expressions that equate q1, . . . , q8 in Figure <ref type="figure" target="#fig_4">6</ref> as calculations in K. However, if we work with the semiring of polynomials K = (N[X], +, •, 0, 1) where we think of the source annotations as indeterminates ("provenance tokens") and take X := {w1, x1, . . . , x5, y1, . . . , y6, z1, . . . , z7} then the expressions that equate q1, . . . , q8 are the provenance polynomials that annotate the tuple nodes in the answer. This kind of provenance shows, for example, that some of the tuples in the answer use source data annotated with z1 or y5 although these do not appear explicitly in the annotations of the answer attributes or values in the tuples. The annotations in a particular semiring K can then be computed by evaluating these polynomials in K. Corollary 1 (commutation with homomorphisms) guarantees that the result will be the same as that obtained via the semantics on K-UXML values.</p><p>Note also that we can obtain the answer shown in Figure <ref type="figure" target="#fig_3">5</ref> simply by setting all the indeterminates except for x1, . . . , x5 to 1 and then simplifying using the semiring laws. When we set these indeterminates to 1, some subtrees which were distinguished by annotations become now identified (q1 and q2, q4 and q5); this explains the sums in the annotations of the answer in Figure <ref type="figure" target="#fig_3">5</ref>.</p><p>The semantics in §6 allows us to prove the following upper bound: PROPOSITION 2. If v is a UXML value annotated with indeterminates from a set X and p is a UXQuery, then computing p(v) according to the N[X]-UXQuery semantics produces an N[X]-UXML value such that the size of any of the provenance polynomials that annotate p(v) is O(|v| |p| ).</p><p>K-UXQuery vs. XQuery Although UXQuery only contains core operators, more complicated syntactic features such as whereclauses that we used in the examples above can be normalized into core queries using standard translations <ref type="bibr" target="#b10">[11]</ref>. For example, the where-clause where $x/B=$y/B from Figure <ref type="figure" target="#fig_3">5</ref> normalizes to:</p><formula xml:id="formula_15">for $a in $x/B/* return for $b in $y/B/* return if (name($a)=name($b)) then . . . else ()</formula><p>Our language includes only the downward XPath axes, since the other axes can be compiled into this fragment <ref type="bibr" target="#b23">[24]</ref>. To simplify our formal system, we also do not identify a value with the singleton set containing it. This is inessential but it simplifies the compilation in §6. <ref type="bibr" target="#b2">3</ref>. In examples we often elide the extra set constructor when it is clear from context-e.g., we wrote $x/A above, not ($x)/A.</p><p>Unlike these minor differences, we made two essential restrictions in the design of K-UXQuery. The first has to do with orderwe omit orderby and other operators whose semantics depends on position, since these do not make sense on unordered data. The second essential restriction is to positive queries-e.g., the conditional expression only tests the equality of labels; see §6.1 for further discussion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A SECURITY APPLICATION</head><p>We can model confidentiality policies using commutative semirings. For example, the total order C : P &lt; C &lt; S &lt; T &lt; 0 describes the following levels of "clearance": P = public, C = confidential, S = secret, and T = top-secret. It is easy to see that (C, min, max, 0, P) is a commutative semiring. 7 We add 0 as a separate element. It is needed because items in a K-UXML set with annotation 0 are interpreted as not belonging to the set (i.e., 0 is so secret, it isn't even there!), and we do not want to lose data tagged as T completely.</p><p>Our framework solves the following problem. Suppose that an XML database has been manually annotated with security information specifying what clearance one must have for each data subtree they wish to see. Now we use XQuery to produce views of this database. We would like to compute automatically clearance annotations for the data in a view, based on how that data was obtained from the already annotated data in the original database. The two operations of the clearance semiring correspond to alternatives in obtaining the view data, in which case the minimum clearance among them suffices, and to joint necessities, in which case the maximum clearance among them is needed.</p><p>We give an example that shows that our annotated XML model is a particularly flexible framework for such clearance specifications. Consider the source data in Figure <ref type="figure" target="#fig_4">6</ref>, which in fact encodes a relational database but where we have much more annotation flexibility than in the <ref type="bibr" target="#b15">[16]</ref> model where only tuples are annotated. We annotate with elements from C as follows w1 := C (the entire relation 7 Note that the natural order <ref type="bibr" target="#b15">[16]</ref> on this semiring is actually the opposite of the clearance order. The result of the view/query in Figure <ref type="figure" target="#fig_3">5</ref> when applied to this data is the C-UXML encoding of a relation in which only the annotations on the tuples are different from 1 = P (this is because the query projects out the attribute B, otherwise we could have had non-P annotations inside the tuples). We show this answer as an annotated relation in Figure <ref type="figure" target="#fig_5">7</ref>. We also show there the polynomials that would annotate the tuples if we would do the calculations in the provenance semiring N[w1, x2, y5]. These help understand how the resulting clearances are computed since it is a consequence of Corollary 1 (commutation with homomorphisms) that by evaluating the provenance polynomials in C under the valuation w1 := C, x2 := S, y5 := T we get the same result as the C-UXQuery semantics.</p><formula xml:id="formula_16">Q A C a c w 1 • y 5 + w 2 1 = C • T + C 2 = C a e w 2 1 • x 2 = C 2 • S = S d c w 1 • x 2 • y 5 + w 2 1 • x 2 = C • S • T + C 2 • S = S d e w 2 1 • x 2 2 = C 2 • S = S f c w 1 • y 5 = C • T = T f e w 2 1 = C 2 = C</formula><p>Going back to the security application, for the data in the view, confidential clearance gives access to the first and last tuple, secret clearance to all but the fifth tuple, etc. Note how the top-secret annotation of the attribute B in S affects just three of the tuples in the answer and how in two of those cases the tuples are still available to lower clearances because they can be also produced with data from R only.</p><p>In the example above the semiring of clearances is a total order but this can be generalized to non-total orderings, provided they form a distributive lattice. The distributivity ensures that views that we consider equivalent actually compute the same clearance for the results. This follows from the following proposition which generalizes a similar result in <ref type="bibr" target="#b15">[16]</ref> for relations and positive relational algebra. PROPOSITION 3. If two UXQueries are equivalent on all UXML inputs and K is a distributive lattice then the queries are equivalent on all K-annotated UXML inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">INCOMPLETE AND PROBABILISTIC K-UXML</head><p>Commutative semirings can also be used to model incomplete and probabilistic databases for unordered XML data, even with repetitions. An incomplete UXML database is a set of possible worlds, each of which is itself a UXML (i.e. a B-UXML) database. For repetitions (multiplicities) the possible worlds are N-UXML databases. More generally, we treat here incomplete K-UXML databases for arbitrary commutative semirings K. It turns out that by using provenance annotations we can construct a powerful system for representing and querying incomplete K-UXML databases.</p><p>Recall that provenance polynomials are elements of the commutative semiring (N[X], +, •, 0, 1)-i.e. polynomial expressions over variables X with natural number coefficients <ref type="bibr" target="#b15">[16]</ref>. For any commutative semiring K, provenance polynomials are "universal" in the sense that any function f : X → K (we call f a valuation) extends uniquely to a semiring homomorphism f : N[X] → K. We exploit this to construct a representation system for incomplete K-UXML data. We first fix a semiring K, and a set of variables X. We call a v in N[X]-UXML a representation. Next we define a function ModK that maps a representation v in N[X]-UXML to the set of K-UXML instances that can be obtained by applying K-valuations to the variables in X-i.e., ModK (v ) is {f (v ) : f : X → K}, the set of possible worlds v represents.</p><p>As an example, let v be the source tree in Figure 4. To streamline the example, we will set the x1 and x2 annotations to 1, leaving just the annotations y1, y2, y3 on the subtrees labeled c.</p><p>For K = B, the set of possible worlds represented by v is the following set of UXML values: Each tree in Mod B (v ) is obtained using a valuation from the yis to B-e.g., for the rightmost tree in this display, the valuation maps y1 to true and y2 and y3 to false.</p><formula xml:id="formula_17">Mod B (v ) = 8 &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; :</formula><p>Now consider querying such an incomplete UXML database. In general, given an XQuery p, we would like the answer to be (semantically) the set of all K-UXML instances obtained by evaluating p over each K-UXML instance in the set of possible worlds represented by v -i.e., p(ModK</p><formula xml:id="formula_18">(v )) is {p(v ) : v ∈ ModK (v )}.</formula><p>Returning to the representation v above and using p, the query in Figure <ref type="figure">4</ref>, we have:</p><formula xml:id="formula_19">p(Mod B (v)) = 8 &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; : Q c c d a c b , Q c , Q c c d a b , Q c d a c b , Q , Q c d a b 9 &gt; &gt; &gt; &gt; = &gt; &gt; &gt; &gt; ;</formula><p>As usual in incomplete databases, we do not wish to return this set, which may be large in general. Instead, we would like a representation of it. By Corollary 1 below, it turns out that such a representation is obtained by evaluating p over v with N[X]-UXQuery semantics. In general, we have that p(ModK (v )) = ModK (p(v )). Indeed, the specific answer for this example shown in Figure <ref type="figure">4</ref> is the representation of p(Mod B (v)). Using the terminology of incomplete databases, we say that N[X]-UXML is a strong representation system <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b0">1]</ref> for K-UXQuery and K-UXML data.</p><p>For simpler K, the full power of N[X] may not be needed. For example, when K = B, we can use annotations from the semiring (PosBool(B), ∨, ∧, false, true) of positive Boolean expressions over a set B of variables (i.e., the expressions involve only B, disjunction, conjunction, and constants for true and false). <ref type="foot" target="#foot_9">8</ref> This corresponds to an XML analogue of the Boolean c-tables <ref type="bibr" target="#b18">[19]</ref> used in incomplete databases. Valuations ν : B → B extend uniquely to homomorphisms ν : PosBool(B) → B, so the definition above of Mod B still makes sense. Indeed, it follows (again from the commutation with homomorphisms in § 6.4) that PosBool(B)-UXML is a strong representation system for UXQuery and B-UXML (i.e., ordinary UXML) and that we can transform an N[B]-UXML representation into PosBool(B)-UXML representation by applying the obvious homomorphism. It can be shown that PosBool works not just for B but for incomplete L-UXML for any distributive lattice L, in particular the ones used for the security application in §4.</p><p>Another instance of our general result is that N[X]-UXML also provides a strong representation system for UXML with repetitions. For example, if we let v be the same tree as above, and pick K = N, then the set of possible worlds is the following: Note that children may be repeated-e.g., the third tree in this display has a subtree with two children c; this is obtained from a valuation that maps y2 to 2.</p><formula xml:id="formula_20">Mod N (v ) = 8 &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; :</formula><p>Probabilistic data can also be modeled using semiring annotations. Again we use as representations N[X]-UXML values and all the worlds corresponding to valuations f : X → K. But now we consider such a valuation as the conjunction of independent events, {f (x) = k} one for each x. The probability of each independent event can be computed from some probability distribution on K. For example, if K = B we can use Bernoulli distributions, if K = N we can use Pr[f (x) = n] = 1/2 n for n &gt; 0, and 0 for f (x) = 0, etc. It follows again that we have a strong representation system this time for probability distributions on all the possible instances. For K = B, more generally for distributive lattices, it suffices again to use PosBool expressions. Since tree pattern queries are expressible in UXQuery, we get the query evaluation algorithm in <ref type="bibr" target="#b26">[27]</ref> as a particular case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SEMANTICS VIA COMPLEX VALUES</head><p>In this section we develop our formal semantics for K-UXQuery by translation into a data model and query language for complex values. Trees can be understood as data values built recursively using pairing and collection constructions (see e.g., <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b25">26]</ref>). For UXML trees, the collections are sets. This suggests defining trees as complex values, as data values built using pairing and sets, nested arbitrarily.</p><p>We develop our semantics in several steps. First, we generalize the semantics of NRC to handle semiring-annotated values. We then extend the calculus with a recursive tree type and structural recursion operator on trees. This operator is needed to express the descendant operator of K-UXQuery. <ref type="foot" target="#foot_10">9</ref> Finally, we use this calculus as a compilation target for K-UXQuery. At the end of the section, we prove a correctness theorem, stating that the semantics commutes with semiring homomorphisms, and explore some of its broader implications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Complex Values and Trees</head><p>We start from the (positive) Nested Relational Calculus <ref type="bibr" target="#b7">[8]</ref>. The types of NRC are:</p><formula xml:id="formula_21">t ::= label | t × t | {t}</formula><p>Complex values are built with the following constructors:</p><formula xml:id="formula_22">v ::= l | (v, v) | {v} | v ∪ v | {}</formula><p>We abbreviate {v1}∪• • •∪{vn} as {v1, . . . , vn}-e.g., (l1, {l2, l3}) is a complex value of type label × {label }. example,</p><formula xml:id="formula_23">flatten {{a p , b r } u , {b s } v } = {a u•p , b u•r+v•s } {a p , b r } × {c u } = {(a, c) p•u , (b, c) r•u } where R × S ∪(x ∈ R) ∪(y ∈ S) (x, y).</formula><p>We take the fact that the semantics of NRCK is an instance of the general approach to collection languages promoted in e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b8">9]</ref> as evidence for the robustness of our semantics. Appendix A gives a set of equational axioms for NRCK that follow from the general approach just mentioned. These axioms also form a foundation for query optimization for NRCK and K-UXQuery (e.g., see <ref type="bibr" target="#b24">[25]</ref>).</p><p>As positive NRC strictly extends the positive relational algebra (RA+), the following sanity check is also in order. PROPOSITION 4. Let NRC(RA+) be the usual encoding of projection, selection, cartesian product and union in (positive) NRC. The semantics of NRC(RA+) on K-complex values representing Krelations coincides with the semantics of RA+ on K-relations given in <ref type="bibr" target="#b15">[16]</ref>.</p><p>As another sanity check, observe that NRC N corresponds to the positive fragment of the Nested Bag Calculus <ref type="bibr" target="#b21">[22]</ref>.</p><p>Finally, we extend the semantics to NRCK + srt. The semantics, given with respect to an environment to variables ρ, is summarized by the equations in Figure <ref type="figure">8</ref>. The meaning of Tree(-, -), tag(-) and kids(-) are all straightforward (similar to pairing and projections). For srt, we require that Equation (1) continues to hold. Indeed, since K-collections have finite support, even in the presence of K-annotations, values of type tree have a finitary recursive structure. The semantics of ∪(-∈ -)and Equation (1) above uniquely determines the semantics of srt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Compiling UXQuery to NRC + srt</head><p>We define the semantics of K-UXQuery on K-UXML values by translation (compilation) to NRCK + srt. Since K-UXML values can be expressed with the constructors in K-UXQuery it suffices to translate K-UXQuery. The compilation function is written p e. Here we discuss some of the more interesting cases; more details can be found in the long version of this paper. Many of the operators in K-UXQuery have a direct analog in NRCK + src and therefore have a simple translation, for example if p1 e1 and p2 e2 then for $x in p1 return p2 ∪(x ∈ e1) e2. The most interesting compilation rules concern navigation steps. The compilation of a step ax ::nt, written e ax ::nt e , describes by e the set of trees that results from applying the given step to the set of trees described by e. Navigation compilation is then used in query compilation: if p e and e ax ::nt e then p/ax ::nt e . Here is an example of XPath compilation for the self axis combined with a node test a; it returns the trees whose root node is labeled by a: e self::a ∪(x ∈ e) if tag(x) = a then {x} else {} The compilation of the descendant axis is the only place where we make use of structural recursion: we use srt to recursively walk down the structure of the tree and build up a set containing all of the matching nodes. As an example, the compilation rule for descendant::* is:</p><formula xml:id="formula_24">e = ∪(x ∈ e) π1((srt(b, s). f ) x) where f = let self = Tree(b, ∪(x ∈ s) {π2(x)}) in let matches = ∪(x ∈ s) {π1(x)} in (matches ∪ {self }, self ) e descendant::* e</formula><p>The s argument accumulates a set of pairs whose first component is the set of descendants below the immediate subtree contained in the second component of the pair. At each step, the body of the srt expression constructs a new pair using the current node and the accumulator. The descendants are obtained by projecting the first component of the final result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Commutation with Homomorphisms</head><p>A semiring homomorphism h : K1 hom -→ K2 can be lifted to a transformation H from NRCK 1 + srt expressions to NRCK 2 + srt expressions by replacing every occurrence of a scalar k with h(k). Since every K-complex value can be expressed with the constructors of NRCK + srt, this gives us in particular a transformation from K1-complex values to K2-complex values.</p><p>A fundamental property of NRC +srt is that query evaluation on K-complex values commutes with such transformations induced by homomorphisms. THEOREM 1. If h : K1 hom -→ K2 is a homomorphism of semirings, denote by H its lifting as explained above. Then for any K1complex value v and NRCK 1 +srt query e, H(e(v)) = H(e)(H(v)).</p><p>The proof is by induction on e.</p><p>In the same way, a homomorphism h can be lifted to a transformation H from K1-UXQuery to K2-UXQuery (and from K1-UXML values to K2-UXML values). Based on our compilation semantics for K-UXQuery, we conclude from the theorem above that a similar commutation holds for K-UXML and K-UXQuery: We already mentioned several applications of the commutations with homomorphisms theorem (cf. §3, §4, and §5). Another simple but practically useful application involves the "duplicate elimination" homomorphism † : N → B defined as †(0) false and †(n + 1) true. Lifting † to K-complex values and trees or to K-UXML values we obtain that evaluation of ordinary values can be factored through that of values with multiplicities, with duplicate elimination deferred to a final step (in the style of commercial relational database systems).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">SEMANTICS VIA RELATIONS</head><p>We sketch in this section an encoding of K-UXML into Krelations and an accompanying compilation of XPath into Datalog (extended with Skolem functions) which has the important property that the answer to the Datalog program corresponds to the answer to the XPath query with identical annotations. This provides an alternative definition of the semantics of XPath on K-UXML which agrees with that of §6. The availability of such a compilation scheme is an important concern in practice, where XML data is often "shredded" into relations, with queries over the data compiled into SQL for execution by an RDBMS <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b27">28]</ref>. However, the focus here is not on practicality, but on demonstrating a basic proof-of-concept scheme.</p><p>We encode a (set of) K-UXML trees using a single K-relation E(pid, nid, label). Each tuple in E corresponds to a single K-UXML node, and carries the same annotation as the K-UXML node.</p><p>As opposed to UXML in which an item is an entire tree identified by its value, in this encoding an item is identified by its node id.</p><p>Thus pid is the identifier of the node's parent, nid is the identifier of the node itself, and label is the node's label. The special pid 0 is reserved and indicates that the node corresponds to a (top-level) root of a tree in the set.</p><p>Node ids are invented as needed during translation of the K-UXML into relational form. During subsequent query processing, additional node ids may be needed to represent nodes in the query result; we use Skolem functions for this purpose. Recursive Datalog rules are used to implement the XPath descendant operator. To give a flavor of the query translation, we show the rule for one important case, the descendant axis:</p><formula xml:id="formula_25">e descendant::a R(n, l) :-E(0, n, l) R(n, l) :-R(p, _), E(p, n, l) E (f (p), f (n), l) :-E(p, n, l) E (0, f (n), a) :-R(n, a)</formula><p>E encodes the set of input trees and E encodes the set of output trees. f is a Skolem function. To illustrate, the XPath query //c on the source tree in Figure <ref type="figure">4</ref> with x1 := 0 (to simplify the example) yields:</p><formula xml:id="formula_26">E = pid nid label 0 f (2) c y1 0 f (5) c y1 • y2 f (0) f (1) a 1 f (1) f (2) c y1 f (2) f (3) d 1 f (3) f (4) a 1 f (2) f (5) c y2 f (2) f (6) b x2</formula><p>The K-UXML tree which would have been produced by executing the query directly on the input tree is encoded by the tuples reachable from the root tuples (which have pid 0). Note that there are also some "garbage" tuples in the table that are unreachable from any root: e.g., (f (0), f (1), a). An additional step is required to remove these tuples; see <ref type="bibr" target="#b12">[13]</ref> for details. We summarize with the following theorem: THEOREM 2. There is a 1-1 translation φ of K-UXML to Krelations and a translation ψ of XPath to Datalog with Skolem functions, such that for every K-UXML value v and XPath query p, we have φ(p(v)) = ψ(φ(p)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>The original why/where provenance paper <ref type="bibr" target="#b6">[7]</ref> actually used an XML-related data model. However, the model was tag-deterministic and the annotations were in effect paths from the root. Its query language relies on a deep-union construct that seems incomparable with what we do. In addition, the related work in <ref type="bibr" target="#b15">[16]</ref> surveys work on semirings, other models of provenance, and probabilistic and incomplete relations that we do not repeat here.</p><p>Among proposed models for probabilistic and incomplete XML, closest to our work is <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b26">27]</ref>, which uses unordered XML decorated with Boolean combinations of probabilistic events. A model for incomplete XML was developed in <ref type="bibr" target="#b1">[2]</ref>. In both systems the query language is tree patterns, and the main focus is on handling updates and complexity results. By contrast, our goal is a general-purpose annotation framework with a richer query language in which probabilistic and incomplete XML are obtained as special cases. Other models for probabilistic XML include probabilistic interval annotations <ref type="bibr" target="#b17">[18]</ref>, probabilistic trees for data integration <ref type="bibr" target="#b28">[29]</ref>, and numeric probability annotations <ref type="bibr" target="#b22">[23]</ref>; for incomplete XML we add the maximal matchings approach of <ref type="bibr" target="#b19">[20]</ref>.</p><p>The focus of <ref type="bibr" target="#b4">[5]</ref> is to compare a semantics for NRC on annotated complex values to the semantics of an update language but the data model and the query semantics is different from ours. In particular, query-constructed values are annotated with "unknown." Another provenance model for NRC, tracing operational executions for scientific dataflows, is described in <ref type="bibr" target="#b16">[17]</ref>.</p><p>Semirings are used to provide semantics for regular path queries decorated with preference annotations over graph-structured data in <ref type="bibr" target="#b13">[14]</ref>. It is unclear whether there is any connection with our semiring-annotated data.</p><p>We note that, as in the conclusion to <ref type="bibr" target="#b15">[16]</ref>, we still don't know how to incorporate negative (more generally, non-monotonic) operations gracefully into this framework. Dealing with ordered XML is a separate but equally troublesome issue. Unlike sets and bags, lists are not immediately representable as the functions of finite support into some commutative (or even non-commutative) semiring. Still we believe that, based on our semantics for UXML, a practical, albeit somewhat ad-hoc, provenance semantics for ordered XQuery could be devised and then tested for user acceptance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSION AND FURTHER WORK</head><p>The framework for annotated XML we have described here seems to be flexible and potentially useful in practical applications. We are thinking in particular about using semirings of confidentiality levels in an RDBMS by hiding the out-of-model calculations from users and also about recording jointly provenance, security, and uncertainty (the product of several semirings is also a semiring!).</p><p>We have given very general strong representation systems in Section 5. This opens a whole set of questions about their (relative) completeness/expressive power. Another set of theoretical questions has to do with equivalence and perhaps containment wrt. annotated semantics, with applications to query optimization.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Figure 1: Simple for Example. l ∈ L k ∈ K p ::= l | $x | () | (p) | p,p | for $x in p return p | let $x := p return p | if (p=p) then p else p | element p {p} | name(p) | annot k p | p/s s ::= ax ::nt ax ::= self | child | descendant nt ::= l | *</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Selected K-UXQuery Typing Rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Relational (encoded) example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Extended Annotations Example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Security Clearance Example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>COROLLARY 1 .</head><label>1</label><figDesc>If h : K1 hom -→ K2 is a semiring homomorphism, denote by H its lifting to a transformation from K1-UXQuery to K2-UXQuery. Then for any K1-UXML value v and any K1-UXQuery query p, H(p(v)) = H(p)(H(v )).</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Since NRC is used by itself in various contexts<ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b16">17]</ref>, this semantics is of interest even without the connection to XML.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>These polynomials can be used, for example, to track provenance in systems for scientific data sharing, see<ref type="bibr" target="#b14">[15]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>For simplicity, we also omit attributes and model atomic values as the labels on trees having no children.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>In the XQuery data model, sets of labels are also values; it is straightforward to extend our formal treatment to include this.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Items annotated with 0 are allowed by the definition but are useless because our semantics interprets 0 as "not present/available".</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_5"><p>Next, let us examine a query that uses iteration:p = element p { for $t in $S return for $x in ($t)/*return ($x)/* } Γ p 1 : {tree} Γ p 2 : {tree} Γ p 1 ,p 2 : {tree} Γ p 1 : {tree} Γ, x : tree p 2 : {tree} Γ for $x in p 1 return p 2 : {tree} Γ p 1 : label Γ p 2 : label Γ p</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_6"><p>: t Γ p</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_7"><p>: t Γ if (p 1 =p 2 ) then p 3 else p 4 : t Γ p 1 : label G p 2 : {tree} Γ element p 1 {p 2 } : tree Γ p 1 : tree Γ name(p 1 ) : label Γ p : {tree}</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_8"><p>Actually this query is equivalent to the shorter "grandchildren" XPath query $S/*/*; we use the version with a for-clauses to illustrate the semantics of iteration.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_9"><p>We also identify those expressions which yield the same truth value for all Boolean assignments of the variables in B (to permit simplifications).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_10"><p>When the nesting depth of the XML documents is bounded, the structural recursion operator (and the recursive tree type) are not needed, see<ref type="bibr" target="#b9">[10]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_11"><p>It is not clear how to include finite lists in this semiring-based family of collection types</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements We are grateful to Tova Milo for suggesting that we compare our first semantics with the "shredding" one. We also thank Zack Ives, Greg Karvounarakis, James Cheney, Jérôme Siméon, Giorgio Ghelli, and Kristoffer Rose for useful discussions, and the anonymous referees for many helpful comments. Our work is supported by the NSF under grants IIS-0534592, IIS-0447972, IIS-0629846 and IIS-05137782.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The restriction to the positive fragment of the calculus is embodied in the typing rule for conditionals-we only compare label values. It is shown in <ref type="bibr" target="#b7">[8]</ref> that equality tests for arbitrary sets can be used to define non-monotonic operations (i.e., difference, intersection, membership, and nesting). This restriction is essential for the semantics of NRC on annotated complex values because semirings do not contain features for representing negation.</p><p>The crucial NRC operation is the big-union operator: ∪(x ∈ e1) e2. It computes the union of the family of sets defined by e2 indexed by x, where x takes each value in the set e1. For example, the first relational projection is expressed as follows</p><p>To represent trees, we extend the calculus with a constructor Tree(a, C) where a is the label and C the set of immediate subtrees. Trees of the form Tree(a, {}) are leaves. The typing rule for the tree constructor is given by:</p><p>where tree is a new type. It is easy to see that the values of type tree and label × {tree} are in a 1-1 correspondence. In one direction this isomorphism is witnessed by Tree(π1(P ), π2(P )), where P is a pair. To express the other direction, we extend the calculus with two new operations, tag(-) and kids(-) that return the root tag and the set of subtree children of the root, respectively. The mapping from trees to pairs is then given by (tag(T ), kids(T )), where T is a tree. Hence, semantically, the tree type is recursive. 10  In the spirit of <ref type="bibr" target="#b25">[26]</ref> we add an operation for structural recursion on trees: Γ, x : label , y : {t} e1 : t Γ e2 : tree Γ (srt(x, y). e1) e2 : t Its semantics obeys the equation</p><p>where the notation e[x := e ] denotes substitution of e for x in e. For example, the query (srt(x, y). {x} ∪ flatten y) t where flatten W ∪(w ∈ W ) w returns the set of atoms in t.</p><p>We denote this query language by NRC + srt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Semantics for NRC + srt</head><p>Next we show how to decorate complex values (and trees) with semiring annotations, and generalize NRC+srt to operate on annotated values. Again we fix a commutative semiring (K, +, •, 0, 1). Dealing with complex values annotated with elements from K requires a different semantics for the type {t}. The usual semantics is the set of finite subsets of</p><p>With K = B we obtain the usual semantics as finite subsets; with K = N we get bags.</p><p>K-complex values are obtained by arbitrarily nesting pairing and K-collections. We define new semantics for the NRC constructors: the singleton constructor [[{v}]]K is the function that maps [[v]]K to 1 and everything else to 0; [[{}]]K is the constant function that maps everything to 0; and [[v1 ∪ v2]]K is the pointwise K-addition 10 Tree(-, -), tag(-) and kids(-) are an instance of a standard technique for handling recursive types in functional languages.</p><p>In order to express all K-collections in the calculus, we extend NRC with an operation for multiplying the annotations on the elements of K-collections by the "scalar" k in K.</p><p>It is written k e and has the following typing rule:</p><p>We call the calculus extended with this operator NRCK . The set of K-complex values are constructed using:</p><p>and, as above, we abbreviate K-collections using the following notation:</p><p>Determining the right semantics for the ∪(x ∈ e1) e2 operation is more challenging. In Appendix A we explain this semantics in the context of a general theory of collection types <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b20">21]</ref>. Here we give the semantics semi-formally. Let e1 have type {t1} and e2 have type {t2} (whenever x has type t1).</p><p>In general e2 depends on x so for each xi we have a corresponding semantics for e2, i.e., a function gi : Y → K. Using this function we define for each y ∈ Y</p><p>Since each gi has finite support, so does</p><p>The semantics of the other operations inherited from positive NRC is straightforward (it is essential that the equality test does not involve K-collections and therefore additional annotations). For</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A. MONADS OF SEMIMODULES AS COL-LECTION TYPES</head><p>Let (K, +, •, 0, 1) be a commutative semiring. A semimodule over K (a K-semimodule) is an algebraic structure (M, +, 0, λ) where (M, +, 0) is a commutative monoid, and λ : K × M → M is a scalar multiplication operation, written (as usual) λ(k, x) = k x such that</p><p>K-semimodules and their homomorphisms form a category K-SMod. The forgetful functor U :K-SMod → Set has a left adjoint that is very easy to describe: the free K-semimodule generated by a set X is the set X K f of functions X → K that have finite support (see Section 6.2 and note that in</p><p>, with the obvious pointwise addition and pointwise multiplication K-semimodule structure. This adjunction yields a (strong) monad on Set, which can be enriched <ref type="bibr" target="#b20">[21]</ref> with a K-semimodule structure on each monad algebra. Therefore, we have a collection and aggregates query language, as in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b8">9]</ref>. In fact, it is easy to see that any commutative monoid is an N-semimodule and that the B-semimodules are exactly the commutative-idempotent monoids, so the finite sets and finite bags collections are included here 11 . Properties like the commutation with homomorphisms theorem (1) have a very general category-theoretic justification, based on the fact that all the query language constructs in such query languages come from functorial constructs and natural transformations.</p><p>We can also capture some of this theory through an equational axiomatization for NRCK PROPOSITION 5. The semantics of NRCK satisfies the following equational axioms:</p><p>• ∪, {} and multiplication with scalars from K satisfy the axioms of a semimodule over K. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Representing and querying xml with incomplete information</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Segoufin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="208" to="254" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Querying and updating probabilistic information in XML</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Curated databases</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vansummeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On the expressiveness of implicit provenance in query and update languages</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vansummeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">UnQL: A query language and algebra for semistructured data based on structural recursion</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="76" to="110" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Why and where: A characterization of data provenance</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Principles of programming with complex objects and collection types</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Naqvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">149</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="48" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A structural approach to query language design</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Functional Approach to Data Management Modeling, Analyzing, and Integrating Heterogenous Data</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Well-definedness and semantic type-checking in the nested relational calculus and XQuery</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Den Bussche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">V</forename><surname>Gucht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vansummeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">XQuery 1.0 and XPath 2.0 Formal Semantics. W3C</title>
		<author>
			<persName><forename type="first">D</forename><surname>Draper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fankhauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Fernández</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Malhotra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Siméon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-01">Jan. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Storing and querying XML data using an RDMBS</title>
		<author>
			<persName><forename type="first">D</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Engineering Bulletin</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Annotated XML: Queries and provenance</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
		<idno>TR-CIS-08-06</idno>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
		<respStmt>
			<orgName>University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Preferentially annotated regular path queries</title>
		<author>
			<persName><forename type="first">G</forename><surname>Grahne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Thomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Wadge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Update exchange with mappings and provenance</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Provenance semirings</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A formal model of dataflow repositories</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hidders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kwasnikowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sroka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tyszkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Den Bussche</surname></persName>
		</author>
		<editor>DILS</editor>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Probabilistic interval XML</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOCL</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Incomplete information in relational databases</title>
		<author>
			<persName><forename type="first">T</forename><surname>Imieliński</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lipski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Queries with incomplete answers over semistructured data</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kanza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Nutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A calculus for collections and aggregates</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Lellahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Category Theory and Computer Science</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Query languages for bags and aggregate functions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JCSS</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="241" to="272" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">ProTDB: Probabilistic data in XML</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nierman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">XPath: Looking forward</title>
		<author>
			<persName><forename type="first">D</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Meuss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Furche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT Workshops</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A complete and efficient algebraic compiler for xquery</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Simèon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fernández</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Structural recursion on ordered trees and list-based complex objects</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V</forename><surname>Saxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">V</forename><surname>Gucht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vansummeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On the complexity of managing probabilistic XML data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Senellart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Relational databases for querying XML documents: Limitations and opportunities</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shanmugasundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tufte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<editor>VLDB J.</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A probabilistic XML approach to data integration</title>
		<author>
			<persName><forename type="first">M</forename><surname>Van Keulen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>De Keijzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Alink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
