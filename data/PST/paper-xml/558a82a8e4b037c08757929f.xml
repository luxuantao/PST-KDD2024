<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Distributed Constraint Satisfaction Problem : Formalization and Algorithms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Makoto</forename><surname>Yokoo</surname></persName>
							<email>yokoo@cslab.kecl.ntt.co.jp.</email>
						</author>
						<author>
							<persName><roleName>Member, /€E€</roleName><forename type="first">Edmund</forename><forename type="middle">H</forename><surname>Durfee</surname></persName>
							<email>durfee@umich.edu</email>
						</author>
						<author>
							<persName><roleName>Member, /E€€</roleName><forename type="first">Toru</forename><surname>Ishida</surname></persName>
							<email>ishida@kuis.kyoto-u.ac.jp</email>
						</author>
						<author>
							<persName><forename type="first">Kazuhiro</forename><surname>Kuwabara</surname></persName>
							<email>kuwabara@rdh.ecl.ntt.co.jp</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">ISTRIBUTED Artificial Intelligence</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">NTT Communication Science Laboratories</orgName>
								<address>
									<addrLine>2-2 Hikaridai, Seika-cho, Soraku-gun</addrLine>
									<postCode>619-02</postCode>
									<settlement>Kyoto</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department oflnformation Science</orgName>
								<orgName type="institution">Kyoto University</orgName>
								<address>
									<addrLine>Yoshida-honmachi, Sakyo-ku</addrLine>
									<postCode>606-01</postCode>
									<settlement>Kyoto</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Department of Electrical Engineering</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">The Distributed Constraint Satisfaction Problem : Formalization and Algorithms</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2129F240B4C2D7670803BC8E00731655</idno>
					<note type="submission">received 21 Apr. 1996; revised 10June 1997. This paper is the extended version of the authors&apos; previous conference papers [Zl], [221.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Backtracking algorithms</term>
					<term>constraint satisfaction problem</term>
					<term>distributed artificial intelligence</term>
					<term>iterative improvement algorithm</term>
					<term>multiagent systems</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we develop a formalism called a distributed constraint satisfaction prob/em (distributed CSP) and algorithms for solving distributed CSPs. A distributed CSP is a constraint satisfaction problem in which variables and constraints are distributed among multiple agents. Various application problems in Distributed Artificial Intelligence can be formalized as distributed CSPs. We present our newly developed technique called asynchronous backtracking that allows agents to act asynchronously and concurrently without any global control, while guaranteeing the completeness of the algorithm. Furthermore, we describe how the asynchronous backtracking algorithm can be modified into a more efficient algorithm called an asynchronous weak-commitment search, which can revise a bad decision without exhaustive search by changing the priority order of agents dynamically. The experimental results on various example problems show that the asynchronous weak-commitment search algorithm is, by far more, efficient than the asynchronous backtracking algorithm and can solve fairly large-scale problems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>with finding a consistent combination of agent actions can be formalized as distributed CSPs.</p><p>For example, a multiagent truth maintenance system [2] is a distributed version of a truth maintenance system [31. In this system, there exist multiple agents, each of which has its own truth maintenance system. Each agent has uncertain data that can be IN or OUT, i.e., believed or not believed, and each shares some data with other agents. Each agent must determine the label of its data consistently, and shared data must have the same label. The multiagent truth maintenance task can be formalized as a distributed CSP, where each of uncertain data is a variable whose value can be IN or OUT.</p><p>Another example is a distributed resource allocation problem in a communication network, which is described in [41. In this problem, each agent has its own tasks, and there are several ways (plans) to perform each task. Since resources are shared among agents, there exist constraints / contention between plans. The goal is to find the combination of plans that enables all the tasks to be executed simultaneously. This problem can be formalized as a distributed CSP by representing each task as a variable, and possible plans as variable values.</p><p>Many other applicatiion problems that are concerned with finding a consistent combination of agent actions/decisions (e.g., distributed scheduling <ref type="bibr">[5]</ref> and distributed interpretation problems [61) can be formalized as distributed CSPs. Since a variety of DAI application problems can be formalized as distributed CSPs, we can consider distributed algorithms for solving distributed CSPs as an important infrastructure in DAI.</p><p>It must be noted that although algorithms for solving distributed CSPs seem to be similar to parallel/distributed processing methods for solving CSPs <ref type="bibr">[7]</ref>, <ref type="bibr">[8]</ref>, research motivations are fundamentally different. The primary concern in parallel/distributed processing is efficiency, and we can choose any type of parallel/distributed computer architecture for solving a given problem efficiently.</p><p>In contrast, in a distributed CSP there already exists a situation where knowledge about the problem (i.e., variables and constraints) is distributed among automated agents. Therefore, the main research issue is how to reach a solution from this given situation. If all knowledge about the problem can be gathered into one agent, this agent can solve the problem alone using normal centralized constraint satisfaction algorithms. However, collecting all information about a problem requires not only the communication costs but also the costs of translating one's knowledge into an exchangeable format. For example, a constraint might be stored as a very complicated specialized internal function within an agent. In order to communicate the knowledge of this constraint to other agent, which might be implemented on different computer architecture, the agent must translate the knowledge into an exchangeable format, such as a table of allowed (or not allowed) combinations of variable values. These costs of centralizing all information to one agent could be prohibitively high.</p><p>Furthermore, in some application problems, gathering all information to one agent is undesirable or impossible for security/privacy reasons. In such cases, multiple agents have to solve the problem without centralizing all information.</p><p>In this paper, we develop a basic algorithm for solving distributed CSPs called asynchronous backtracking. In this algorithm, agents act asynchronously and concurrently based on their local knowledge without any global control, while the completeness of the algorithm is guaranteed.</p><p>Furthermore, we describe how this asynchronous backtracking algorithm can be modified into a more efficient algorithm called asynchronous weak-commitment search, which is inspired by the weak-commitment search algorithm for solving CSPs <ref type="bibr">[9]</ref>. The main characteristic of this algorithm is as follows:</p><p>e Agents can revise a bad decision without an exhaustive search by changing the priority order of agents dynamically.</p><p>In the asynchronous backtracking algorithm, the priority order of agents is determined, and each agent tries to find a value satisfying the constraints with the variables of higher priority agents. When an agent sets a variable value, the agent is strongly committed to the selected value, i.e., the selected value will not be changed unless an exhaustive search is performed by lower priority agents. Therefore, in large-scale problems, a single mistake in the selection of values becomes fatal since such an exhaustive search is virtually impossible. This drawback is common to all backtracking algorithms. In the asynchronous weakcommitment search, when an agent cannot find a value consistent with the higher priority agents, the priority order is changed so that the agent has the highest priority. As a result, when an agent makes a mistake in selecting a value, the priority of another agent becomes higher; thus the agent that made the mistake will not commit to the bad decision, and the selected value is changed. We will show that the asynchronous weak-commitment search algorithm can solve various problems, such as the distributed 1,000-queens problem, the distributed graphcoloring problem, and the network resource allocation problem [lo] that the asynchronous backtracking algorithm fails to solve within a reasonable amount of time. These results are interesting since they imply that a flexible agent organization, in which the hierarchical order is changed dynamically, actually performs better than an organization in which the hierarchical order is static and rigid, if we assume that the priority order represents a hierarchy of agent authority, i.e., the priority order of decision making.</p><p>In the following sections, we describe the definition of a distributed CSP (Section 2). Then, we show two trivial algorithms for solving distributed CSPs (Section 3), and describe the asynchronous backtracking algorithm in detail (Section 4). We show how the asynchronous weakcommitment search algorithm is obtained by modifying the asynchronous backtracking algorithm (Section 5). Then, we present empirical results that compare the efficiency of these algorithms (Section 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DISTRIBUTED CONSTRAINT</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">CSP</head><p>A CSP consists of n variables xl, x2, ..., x,, whose values are taken from finite, discrete domains D,, D,, ..., D,, respectively, and a set of constraints on their values. A constraint is defined by a predicate. That is, the constraint pk(xkl, ..., xkl) is a predicate that is defined on the Cartesian product Dkl x ... x Dkl. This predicate is true iff the value assignment of these variables satisfies this constraint. Solving a CSP is equivalent to finding an assignment of values to all variables such that all constraints are satisfied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Distributed CSP</head><p>A distributed CSP is a CSP in which the variables and constraints are distributed among automated agents. We assume the following communication model: Agents communicate by sending messages. An agent can send messages to other agents iff the agent knows the addresses of the agents. The delay in delivering a message is finite, though random. For the transmission between any pair of agents, messages are received in the order in which they were sent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROBLEM</head><p>It must be noted that this model does not necessarily mean that the physical communication network must be fully connected (i.e., a complete graph). Unlike most parallel/distributed algorithm studies, in which the topology of the physical communication network plays an important role, we assume the existence of a reliable underlying communication structure among the agents and do not care about the implementation of the physical communication network. This is because our primary concern is cooperation among intelligent agents, rather than solving CSPs by certain multiprocessor architectures.</p><p>Each agent has some variables and tries to determine their values. However, there exist interagent constraints, and the value assignment must satisfy these interagent constraints. Formally, there exist m agents 1,2, . . ., m. Each variable xI belongs to one agent i (this relation is represented as belongs(xl, i ) ) . ' Constraints are also distributed among agents. The fact that an agent I knows a constraint predicate pk is represented as known (pk, I).</p><p>We say that a Distributed CSP is solved iff the following conditions are satisfied:</p><p>Vi, Vxl where belongs(xl, i), the value of xi is assigned to dl, and "1, Vpk where known(pk, I), pk is true under the assignment x1 = dl.</p><p>Without loss of generality, we make the following assumptions while describing our algorithms for simplicity. Relaxing these assumptions to general cases is relatively straightforward2:</p><p>Each agent has exactly one variable. All constraints are binary.</p><p>Each agent knows all constraint predicates relevant to its variable.</p><p>In the following, we use the same identifier x, to represent an agent and its variable. We assume that each agent (and its variable) has a unique identifier. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">TRIVIAL ALGORITHMS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Centralized Method</head><p>The most trivial algorithm for solving a distributed CSP is to select a leader agent among all agents, and gather all information about the variables, their domains, and their constraints, into the leader agent. The leader then solves the CSP alone using normal centralized constraint satisfaction algorithms. However, as discussed in Section 1, the cost of collecting all information about a problem can be prohibitively high. Furthermore, in some application problems, such as software agents in which each agent acts as a secretary of an individual, gathering all information to one agent is undesirable or impossible for security/privacy reasons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Synchronous Backtracking</head><p>The standard backtracking algorithm for CSP can be modified to yield the synchronous backtracking algorithm for distributed CSPs. Assume the agents agree on an instantiation order for their variables (such as agent x1 goes first, then agent x2, and so on). Each agent, receiving a partial solution (the instantiations of the preceding variables) from the previous agent, instantiates its variable based on the constraints that it knows about. If it finds such a value, it appends this to the partial solution and passes it on to the next agent. If no instantiation of its variable can satisfy the constraints, then it sends a backtracking message to the previous agent.</p><p>While this algorithm does not suffer from the same communication overhead as the centralized method, determining the instantiation order still requires certain communication costs. Furthermore, this algorithm cannot take advantage of parallelism. Because, at any given time, only one agent is receiving the partial solution and acting on it, the problem is solved sequentially. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ASYNCHRONOUS BACKTRACKING</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Overview</head><p>Our asynchronous backtracking algorithm removes the drawbacks of synchronous backtracking by allowing agents to run concurrently and asynchronously. Each agent instantiates its variable and communicates the variable value to the relevant agents.</p><p>We represent a distributed CSP in which all constraints are binary as a network, where variables are nodes and constraints are links between nodes.4 Since each agent has exactly one variable, a node also represents an agent. We use the same identifier for representing an agent and its variable. We also assume that every link (constraint) is directed. In other words, one of the two agents involved in a constraint is assigned that constraint, and receives the other agent's value. A link is directed from the valuesending agent to the constraint-evaluating agent. For example, in Fig. <ref type="figure" target="#fig_1">1</ref>   Each agent instantiates its variable concurrently and sends the value to the agents which are connected by outgoing links. After that, the agents wait for and respond to messages. Fig. <ref type="figure" target="#fig_3">2</ref> describes procedures executed by agent</p><p>x, for receiving two kinds of messages. One kind is an ok? message, that a constraint-evaluating agent receives from a value-sending agent asking whether the value chosen is acceptable (Fig. <ref type="figure" target="#fig_3">2i</ref>). The second kind is a nogood message that a value-sending agent receives, indicating that the constraint-evaluating agent has found a constraint violation (Fig. <ref type="figure" target="#fig_3">2ii</ref>).</p><p>Each agent has a set of values from the agents that are connected by incoming links. These values constitute the agent's agent-view. The fact that xl's value is 1 is represented by a pair of the agent identifier and the value, (xl, 1). Therefore, an agent-view is a set of these pairs, e.g., {(xl, l), (x2, 2)]. If an ok? message is sent on an incoming link, the evaluating agent adds the pair to its agent-view and checks whether its own value assignment (represented as (xi, current-value)) is consistent with its agent-view. Its own assignment is consistent with the agent-view if all constraints the agent evaluates are true under the value assignments described in the agent-view and (xz, current value), and if all communicated nogoods are not compatible with the agent-view and (x,, current-value). If its own assignment is not consistent with the agent-view, agent x, tries to change the current-value so that it will be consistent with the agent-view.</p><p>A subset of an agent-view is called a nogood if the agent is not able to find any consistent value with the subset. For example, in Fig. <ref type="figure" target="#fig_4">3a</ref>, if agents x1 and x2 instantiate their variables to 1 and 2, the agent-view of xg will be {(xl, l), (x2, 2)). Since there is no possible value for xg which is consistent with this agent-view, this agent-view is a nogood. If an agent finds a subset of its agent-view is a n ~g o o d , ~</p><p>the assignments of other agents must be changed. Therefore, the agent causes a backtvack (Fig. <ref type="figure" target="#fig_3">2iii</ref>)) and sends a nogood message to one of the other agents. 5. Although the following algorithm is described in a way such that an agent reacts to messages sequentially, an agent can in fact handle multiple messages concurrently, i.e., the agent first revises the agentview and nogood-list according to the messages, and performs check-agent-view only once.</p><p>6. A nogood is compatible with the agent-view and (xi, current-value) if all variables in the nogood have the same values in the agent-view and (xi, current_value).</p><p>7. Ideally, the nogoods detected in Fig. <ref type="figure" target="#fig_3">2iii</ref>-a should be minimal, i.e., no subset of them should be a nogood. However, since finding all minimal nogoods requires certain computation costs, an agent can make do with nonminimal nogoods. In the simplest case, it can use the whole agent-view as a nogood.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Avoiding Infinite Processing LOOPS</head><p>If agents change their values again and again and never reach a stable state, they are in an infinite processing loop. An infinite processing loop can occur if there exists a value changing loop of agents, such as if a change in x1 causes x2 to change, then this change in x2 causes xg to change, which then causes x1 to change again, and so on. In the network representation, such a loop is represented by a cycle of directed links.</p><p>One way to avoid cycles in a network is to use a total order relationship among nodes. If each node has an unique identifier, we can define a priority order among agents by using the alphabetical order of these identifiers (the preceding agent in the alphabetical order has higher priority). If a link is directed by using this priority order (from the higher priority agent to the lower priority agent), there will be no cycle in the network. This means that for each constraint, the lower priority agent will be an evaluator, and the higher priority agent will send an ok? message to the evaluator. Furthermore, if a nogood is found, a nogood message is sent to the lowest priority agent in the nogood (Fig. <ref type="figure" target="#fig_3">2iii-b</ref>). Similar techniques to this unique identifier method are used for avoiding deadlock in distributed database systems 1151.</p><p>The knowledge each agent requires for this unique identifier method is much more local than that needed for synchronous backtracking. In synchronous backtracking, agents must act in a predefined sequential order. Such a sequential order cannot be obtained easily just by giving an unique identifier to each agent. Each agent must know the previous and next agent, which means polling all of the other agents to find the closest identifiers above and below it. On the other hand, in the unique identifier method for asynchronous backtracking, each agent has to know only the identifiers of an agent with which it must establish a constraint in order to direct the constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Handling Asynchronous Changes</head><p>Because agents change their instantiations asynchronously, an agent-view is subject to incessant changes. This can lead to potential inconsistencies, because a constraint-evaluating agent might send a nogood message to an agent that has already changed the value of an offending variable as a result of other constraints. In essence, the nogood message may be based on obsolete information, and the value-sending agent should not necessarily change its value again.</p><p>We introduce the use of context attachment to deal with these potential inconsistencies. In context attachment, an agent couples its message with the nogood that triggered it. This nogood is the context of backtracking. After receiving this message, the recipient only changes its value if the nogood is compatible with its current agent-view and its own assignment (Fig. <ref type="figure" target="#fig_3">2ii-a</ref>). Since the nogood attached to a nogood message indicates the cause of the failure, asynchronous backtracking includes the function of dependencydirected backtracking in CSPs 1121.</p><p>A nogood can be viewed as a new constraint derived from the original constraints. By incorporating such a new constraint, agents can avoid repeating the same mistake.</p><p>For example, in Fig. <ref type="figure" target="#fig_4">3b</ref>, the nogood {(xl, l), (x2, 2)) represents when received (ok?, (zj, d 3 ) ) do ~ (i) add <ref type="bibr">(x3, d3)</ref>   - a constraint between x, and x2. Since there is no link between x1 and x2 originally, a new link must be added between them. Therefore, after receiving the nogood message, agent x2 asks x1 to add a link between them. In general, even if all the original constraints are binary, newly derived constraints can be among more than two variables.</p><formula xml:id="formula_0">is a nogmid (a) (b)</formula><p>In such a case, one of the agents, which has the lowest priority in the constraint, will be an evaluator and the links will be added between each of the nonevaluator agents and the evaluator. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Example</head><p>In Fig. <ref type="figure" target="#fig_4">3a</ref>, by receiving ok? messages from x1 and x2, the agent-view of xg will be {(q, l), (x2, 2 ) } . Since there is no possible value for x3 consistent with this agent-view, this agent-view is a nogood. Agent x3 chooses the lowest priority agent in the agent-view, i.e., agent x2, and sends a nogood message with the nogood. By receiving this nogood message, agent x2 records this nogood. This nogood, {(xl, l), (x2, 2 ) ) contains agent xl, which is not connected with x2 by a link. Therefore, a new link must be added between x1 and x2. Agent x2 requests x, to send xi's value to x2, and adds (x,, 1) to its agent-view (Fig. <ref type="figure" target="#fig_4">3b</ref>). Agent x, checks whether its value is consistent with the agent-view. Since the nogood received from agent xg is compatible with its assignment (x2, 2) and its agent-view {(q, 111, the assignment (x2, 2) is inconsistent with the agent-view. The agent-view {(xl, 1)) is a nogood because x2 has no other possible values. There is only one agent in this nogood, i.e., agent xl, so agent x2 sends a nogood message to agent x1 (Flg. 3c).</p><p>Furthermore, we illustrate the execution of the algorithm using a distributed version of the well-known n-queens problem (where n = 4). There exist four agents, each of which corresponds to a queen in each row. The goal of the agents is to find positions on a 4 x 4 chess board so that the queens do not threaten each other. It must be noted that the trace of the algorithm execution can vary significantly according to the timing/delay of the messages, and this example shows one possible trace of execution.</p><p>The initial values are shown in Fig. <ref type="figure" target="#fig_6">4a</ref>. Agents communicate these values with each other. The priority order is determined by the alphabetical order of identifiers. The agents except x1 change their value, so that the new value is consistent with its agent-view (Fig. <ref type="figure" target="#fig_6">4b</ref>), i.e., agent x2 changes its value to 3, which is consistent with xl's value. Agent x3 changes its value to 4, which is consistent with xi's and xis value (since x2 changes its value, xis value is no longer consistent with the new value.). Since there is no consistent value for agent x4, it sends a nogood message to xg, and changes its value so that the value is consistent with its agent-view, except the value of xg. Note that x3 will ignore this nogood message since it has changed its value before it receives this message. The agents send ok? messages to other agents. Then, x3 does not satisfy constraints with x1 and x2, and there is no consistent value, while other agents' values are consistent with their agent-view. Therefore, xg sends a nogood message to x2. After receiving this nogood message, x2 changes its value to 4 (Fig. <ref type="figure" target="#fig_6">4c</ref>). Then, x3 changes its value to 2. There is no consistent value for agent x4, it sends a nogood message to xg, and changes its value so that the value is consistent with its agent-mew, except the value of x3 (Fig. <ref type="figure" target="#fig_6">4d</ref>). Again, this nogood message is ignored. There is no consistent value for agent xq, it sends a nogood message to x3. After receiving this message, x3 has no other consistent value, so xg sends a nogood message to x2. After receiving this message, x2 also has no other consistent value, so x2 sends a nogood message to xl. Then, x1 changes its value to 2 (Fig. <ref type="figure" target="#fig_6">4e</ref>). Then, x3 changes its value to 1. There is no consistent value for agent x4, it sends a nogood message to x3, and changes its value so that the value is consistent with its agent-view, except the value of xg.</p><p>Again, this nogood message is ignored, and a solution is found (Fig. <ref type="figure" target="#fig_6">4f</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Algorithm Soundness and Completeness</head><p>We will show that if there exists a solution, this algorithm reaches a stable state where all the variable values satisfy all the constraints, and all agents are waiting for an incoming message,' and if no solution exists, this algorithm discovers this fact and terminates. For the agents to reach a stable state, all their variable values must perforce satisfy all the constraints. Thus, the soundness of the algorithm is clear.</p><p>Furthermore, the algorithm is complete, in that it finds a solution if one exists and terminates with failure when there is no solution.</p><p>A solution does not exist when the problem is overconstrained. In an overconstrained situation, our algorithm eventually generates a nogood corresponding to the empty set. Because a nogood logically represents a set of assignments that leads to a contradiction, an empty nogood means that any set of assignments leads to a contradiction. Thus, no solution is possible. Our algorithm thus terminates with failure if and only if an empty nogood is formed.</p><p>So far, we have shown that when the algorithm leads to a stable state, the problem is solved, and when it generates an empty nogood, the algorithm terminates with failure. What remains is to show that the algorithm reaches one of these conclusions in finite time. The only way that our algorithm might not reach a conclusion is when at least one agent is cycling among its possible values in an infinite processing loop. Given our algorithm, we can prove by induction that this cannot happen as follows.</p><p>In the base case, assume that the agent with the high- 9. We should mention that the way to determine that agents as a whole have reached a stable state is not contained in this algorithm. To detect the stable state, distributed termination detection algorithms such as 1161 are needed.</p><p>will change instantiation of its variable with a different value. Because its variable's domain is finite, xk will either eventually generate a value that does not cause it to receive a nogood (which contradicts the assumption that xk is in an infinite loop), or else it exhausts the possible values and sends a nogood to one of x1 . . . xkPl. However, this nogood would cause an agent, which we assumed as being in a stable state, to not be in a stable state. Thus, by contradiction, xk cannot be in an infinite processing loop.</p><p>Since constraint satisfaction is NP-complete in general, the worst-case time complexity of the asynchronous backtracking algorithm becomes exponential in the number of variables n. The worst-case space complexity of the algorithm is determined by the number of recorded nogoods. In the asynchronous backtracking algorithm, an agent can forget old nogoods after it creates a new nogood from them. Also, an agent does not need to keep the nogoods that are not compatible with the agent-view. Therefore, each agent x, needs to record at most I D, I nogoods, where I D, I is the number of possible values of x,.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ASYNCHRONOUS WEAK-COMMITMENT SEARCH</head><p>In this section, we briefly describe the weak-commitment search algorithm for solving CSPs [91 and describe how the asynchronous weak-commitment search algorithm is constructed by modifying the asynchronous backtracking algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Weak-Commitment Search Algorithm</head><p>In the weak-commitment search algorithm, all the variables have tentative initial values. A consistent partial solution is constructed for a subset of variables, and this partial solution is extended by adding variables one by one until a complete solution is found. When a variable is added to the partial solution, its tentative initial value is revised so that the new value satisfies all the constraints between the variables included in the partial solution, and satisfies as many constraints as possible between variables that are not included in the partial solution. This value ordering heuristic is called the min-conflict heuristic [171. When there exists no value for one variable that satisfies all the constraints between the variables included in the partial solution, this algorithm abandons the whole partial solution, and starts constructing a new partial solution from scratch, using the current value assignment as new tentative initial values.</p><p>This algorithm records the abandoned partial solutions as new constraints, and avoids creating the same partial solution that has been created and abandoned before. Therefore, the completeness of the algorithm (always finds a solution if one exists, and terminates if no solution exists) is guaranteed. Experimental results on various example problems in <ref type="bibr">[9]</ref> illustrate that this algorithm is three to 10 times more efficient than the min-conflict backtracking [ 171 or the breakout algorithm <ref type="bibr">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Basic Ideas</head><p>The main characteristics of the weak-commitment search algorithm described in the previous subsection are as follows:</p><p>1) The algorithm uses the min-conflict heuristic as a value ordering heuristic.</p><p>2) It abandons the partial solution and restarts the search process if there exists no consistent value with the partial solution.</p><p>Introducing the first characteristic into the asynchronous backtracking algorithm is relatively straightforward. When selecting a variable value, if there exist multiple values consistent with the agent-view (those that satisfy the constraints with variables of higher priority agents), the agent prefers the value that minimizes the number of constraint violations with variables of lower priority agents.</p><p>In contrast, introducing the second characteristic into the asynchronous backtracking is not straightforward, since agents act concurrently and asynchronously, and no agent has exact information about the partial solution. Furthermore, multiple agents may try to restart the search process simultaneously.</p><p>In the following, we show that a distributed constraint satisfaction algorithm that commits to the partial solution weakly can be constructed by changing the priority order dynamically. We define the way of establishing the priority order by introducing przority values, and change the priority values by the following rules:</p><p>For each variable/agent, a nonnegative integer value representing the priority order of the variable/agent is defined. We call this value the priority value.</p><p>The order is defined such that any variable/agent with a larger priority value has higher priority.</p><p>If the priority values of multiple agents are the same, the order is determined by the alphabetical order of the identifiers.</p><p>For each variable/agent, the initial priority value is 0.</p><p>If there exists no consistent value for xI, the priority value of x, is changed to k + 1, where k is the largest priority value of related agents.</p><p>It must be noted that the asynchronous weak-commitment search algorithm is fundamentally different from backtracking algorithms with dynamic variable ordering (e.g., dynamic backtracking [19] and dependency-directed backtracking [12]). In backtracking algorithms, a partial solution is never modified unless it is sure that the partial solution cannot be a part of any complete solution (dynamic backtracking or dependency-backtracking is a way for finding out the true cause of the failure/backtracking). In the asynchronous weak-commitment search algorithm, a partial solution is not modified but completely abandoned after one failure/backtracking. Furthermore, in the asynchronous backtracking algorithm, agents try to avoid situations previously found to be nogoods. However, due to the delay of messages, an agent-view of an agent can occasionally be identical to a previously found nogood In order to avoid reacting to such unstable situations, and performing unnecessary changes of priority values, each agent performs the following procedure:</p><p>Each agent records the nogoods that it has sent. When the agent-view is identical to a nogood that it has already sent, the agent will not change the priority value and waits for the next message.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Details of Algorithm</head><p>In the asynchronous weak-commitment search, each agent concurrently assigns a value to its variable, and sends the variable value to other agents. After that, agents wait for and respond to incoming messages. In Fig. <ref type="figure" target="#fig_7">5</ref>, the procedures executed at agent x, by receiving an ok? message and a nogood message are described." The differences between these procedures and the procedures for the asynchronous backtracking algorithm are as follows:</p><p>In the asynchronous backtracking algorithm, each agent sends its variable value only to related lower priority agents, while in the asynchronous weakcommitment search algorithm, each agent sends its 10 10 As in the asynchronous backtracking, although the following algorithm is described in a way that an agent reacts to messages sequentially, an agent can handle multiple messages concurrently, I e , the agent first revises the agent-vzew and nogood-list according to the messages, and performs check-agent-view only once 11 As in the asynchronous backtracking, the way to determine that agents as a whole have reached a stable state is not contained in this algorithm variable value to both lower and higher priority agents connected by constraints. We call these related agents neighbors.</p><p>The priority value, as well as the current value assignment, is communicated through the ok? message (Fig. <ref type="figure" target="#fig_7">5i</ref>). The priority order is determined using the communicated priority values. If the current value is not Consistent with the agent-view, i.e., some constraint with variables of higher priority agents is not satisfied, the agent changes its value so that the value is consistent with the agent-view, and also the value minimizes the number of constraint violations with variables of lower priority agents (Fig. <ref type="figure" target="#fig_7">5ii</ref>).</p><p>When x, cannot find a consistent value with its agent-view, x, sends nogood messages to other agents, and increments its priority value. If x, has already sent an identical nogood, x, will not change its priority value but will wait for the next message (Fig. <ref type="figure" target="#fig_7">5</ref> </p><formula xml:id="formula_1">1 ) . (0) (0) (2) x1 (0) x2 (0) x3 (0) (0) 0 x4 (0) ( 1 )<label>(1) (a) (b)</label></formula><p>(c) Fig. <ref type="figure">6</ref>. Example of algorithm execution (asynchronous weak-commitment search).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Example</head><p>We illustrate the execution of the algorithm using the distributed 4-queens problem described in Section 4.4.</p><p>The initial values are shown in Fig. <ref type="figure">6a</ref>. Agents communicate these values with each other. The values within parentheses represent the priority values. The initial priority values are 0. Since the priority values are equal, the priority order is determined by the alphabetical order of identifiers. Therefore, only the value of x4 is not consistent with its agent-view. Since there is no consistent value, agent x4 sends nogood messages and increments its priority value. In this case, the value minimizing the number of constraint violations is 3, since it conflicts with x3 only. Therefore, x4 selects 3 and sends ok? messages to the other agents (Fig. <ref type="figure">6b</ref>). Then, x3 tries to change its value. Since there is no consistent value, agent x3 sends nogood messages, and increments its priority value. In this case, the value that minimizes the number of constraint violations is 1 or 2. In this example, x3 selects 1 and sends ok? messages to the other agents (Fig. <ref type="figure">6c</ref>). After that, x1 changes its value to 2, and a solution is obtained (Fig. <ref type="figure">6d</ref>).</p><p>In the distributed 4-queens problem, there exists no solution when xl's value is 1. We can see that the bad decision of x1 (setting its value to 1) can be revised without an exhaustive search in the asynchronous weakcommitment search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Algorithm Completeness</head><p>The priority values are changed if and only if a new nogoo$ is found. Since the number of possible nogoods is finite, the priority values cannot be changed infinitely. Therefore, after a certain time point, the priority values will be stable. Then, we show that the situations described below will not occur when the priority values are stable:</p><p>1) There exist agents that do not satisfy some constraints, and all agents are waiting for incoming messages. 2 ) Messages are repeatedly sent/received, and the algorithm will not reach a stable state (infinite processing loop).</p><p>If situation 1) occurs, there exist at least two agents that do not satisfy the constraint between them. Let us assume that the agent ranking kth in the priority order does not satisfy the constraint between the agent ranking jth (where j &lt; k), and that all the agents ranking higher than kth satisfy all constraints within them. The only case that the kth agent waits for incoming messages even though the agent does not satisfy the constraint between the jth agent 12. The number of possible nogoods is exponential in the number of variables n.</p><p>is that the kth agent has sent nogood messages to higher priority agents. This fact contradicts the assumption that higher priority agents satisfy constraints within them. Therefore, situation 1) will not occur.</p><p>Also, if the priority values are stable, the asynchronous weak-commitment search algorithm is basically identical to the asynchronous backtracking algorithm. Since the asynchronous backtracking is guaranteed not to fall into an infinite processing loop, situation 2) will not occur.</p><p>From the fact that neither situation 1) nor 2) will occur, we can guarantee that the asynchronous weak-commitment search algorithm will always find a solution, or find the fact that no solution exists.</p><p>Since constraint satisfaction is NP-complete in general, the worst-case time complexity of the asynchronous weakcommitment search algorithm becomes exponential in the number of variables n. Furthermore, the worst-case space complexity is exponential in n. This result seems inevitable since this algorithm changes the search order flexibly while guaranteeing its completeness. We can restrict the number of recorded nogoods in the asynchronous weakcommitment search algorithm, i.e., each agent records only a fixed number of the most recently found nogoods. In this case, however, the theoretical completeness cannot be guaranteed (the algorithm may fall into an infinite processing loop in which agents repeatedly find identical nogoods). Yet, when the number of recorded nogoods is reasonably large, such an infinite processing loop rarely occurs. Actually, the asynchronous weak-commitment search can still find solutions for all example problems when the number of recorded nogoods is restricted to 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Security/Privacy of Agents</head><p>One reason for solving a distributed CSP in a distributed fashion is that agents might not want to communicate all the information to the centralized leader agent. Then, how much information do agents reveal using the asynchronous backtracking /weak-commitment search algorithm?</p><p>In both algorithms, agents communicate current value assignments and nogoods. By observing the value assignments of agent xl, other agents can gradually accumulate the information about the domain of x, However, other agents cannot tell whether the obtained information of x,'s domain is complete or not. There might be other values of xl, which are not selected because they violate some constraints with higher priority agents. Furthermore, agent x, never reveals the information about its constraints directly. A nogood message sent from</p><p>x, is a highly summarized information about its constraints and nogoods sent from other agents.</p><p>Therefore, we can see that the amount of information revealed by these algorithms are much smaller than the centralized methods, in which agents must declare precise information about their variable domains and constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VAL U AT1 Q N S</head><p>In this section, we evaluate the efficiency of algorithms by a discrete event simulation, where each agent maintains its own simulated clock. An agent's time is incremented by one simulated time unit whenever it performs one cycle of computation. One cycle consists of reading all incoming messages, performing local computation, and then sending messages. We assume that a message issued at time t is available to the recipient at time t + 1. We analyze the performance in terms of the number of cycles required to solve the pr0b1em.l~</p><p>One cycle corresponds to a series of agent actions, in which an agent recognizes the state of the world (the value assignments of other agents), then decides its response to that state (its own value assignment), and communicates its decisions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Comparison Between Synchronous and</head><p>Asynchronous Backtracking First, we are going to compare the synchronous backtracking algorithm and the asynchronous backtracking algorithm. Since agents can act concurrently in the asynchronous backtracking algorithm, we can expect that the asynchronous backtracking algorithm will be more efficient than the synchronous backtracking algorithm. However, the degree of speed-up is affected by the strength of the constraints among agents. If the constraints among agents are weak, we can expect that the agents can easily reach a solution, even if they concurrently set their values. On the other hand, if the constraints among agents are strong, we can assume that until higher priority agents set their values properly, the lower priority agents cannot choose consistent values; thus the overall performance of the asynchronous backtracking algorithm becomes close to the one for synchronous backtracking.</p><p>To verify these expectations, we performed experimental evaluations on the distributed n-queens problem explained in the previous section. Each agent corresponds to each queen in a row. Therefore, the distributed n-queens problem is solved by n agents. In the distributed n-queens problem, constraints among agents become weak as n increases. Our results are summarized in the graph shown in Fig. <ref type="figure" target="#fig_8">7</ref>. To make the comparisons fair, we included dependency-directed backtracking in the synchronous backtracking. Each agent randomly selects a value among the consistent values with higher priority agents. The graph shows the average of 100 trials.14 In the distributed n-queens problem, there exist constraints between any pair 13. One drawback of this model is that it does not take into account the costs of communication. However, introducing the communication costs into the model is difficult since we don't have any standard way for comparing communication costs and computation costs.</p><p>14. In this evaluation, we did not include the cost of determining the sequential order in the Synchronous backtracking, nor the cost of the termination detection in the asynchronous backtracking. of agents. Therefore, the synchronous backtracking algorithm is basically equivalent to the Network Consistency Protocol described in <ref type="bibr">[7]</ref>. As we expected, the obtained parallelism of the asynchronous backtracking becomes larger as n increases. When n &gt; 18, the asynchronous backtracking is approximately two times as fast as the synchronous backtracking.</p><p>Traditionally, distributed artificial intelligence applications involve having agents work on nearly independent, loosely coupled subproblems [ll. These results confirm that, if the local subproblems are loosely coupled, solving the problem asynchronously by multiple agents is worthwhile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Comparison Between Asynchronous</head><p>Backtracking and Asynchronous Weak-Commitment Search</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>15</head><p>We are going to compare the following three kinds of algorithms:</p><p>1) asynchronous backtracking, in which a variable value is selected randomly from consistent values, and the priority order is determined by alphabetical order, 2) asynchronous backtracking with min-conf7ict heuristic, in which the min-conflict heuristic is introduced, but the priority order is statically determined by alphabetical order, and</p><p>3) asynchronous weak-commitment search. We first applied these three algorithms to the distributed n-queens problem described in the previous section, varying n from 10 to 1,000. The results are summarized in Table <ref type="table" target="#tab_6">1</ref>.17 For each n, we generated 100 problems, each of 15 Since the asynchronous backtracking algorithm requires more messages than the synchronous backtraclang for each cycle, the synchronous backtracking might be as efficient as the asynchronous backtracking due to the communication overhead, even though it requires more cycles 16 The amount of communication overhead of these algorithms are almost equivalent The amounts of local computation performed in each cycle for 2) and 3) are equivalent The amount of local computation for 1) can be smaller since it does not use the min-conflict heuristic, but for the lowest priority agent, the amounts of local computation of these algorithms are equivalent 17 Since the the min-conflict heuristic is very effective when n is very large [9], 1171, we did not include the results for M &gt; 1,000  which had different randomly generated initial values, and averaged the results for these problems. For each problem, in order to conduct the experiments within a reasonable amount of time, we set the limit for the number of cycles at 1,000, and terminated the algorithm if this limit was exceeded. We show the average of the successful trials, and the ratio of problems completed successfully to the total number of problems in Table <ref type="table" target="#tab_6">1</ref>.</p><p>The second example problem is the distributed graphcoloring problem. This is a graph-coloring problem in which each node corresponds to an agent. The graphcoloring problem involves painting nodes in a graph by k different colors so that any two nodes connected by an arc do not have the same color. We randomly generated a problem with n nodes/agents and m arcs by the method described in <ref type="bibr">[17]</ref>, so that the graph is connected and the problem has a solution. We evaluated the problem for n = 60, 90, and 120, where m = n x 2 and k = 3. This parameter setting corresponds to the "sparse" problems for which <ref type="bibr">[17]</ref> reported poor performance of the minconflict heuristic. We generated 10 different problems, and for each problem, 10 trials with different initial values were performed (100 trials in all). As in the distributed n-queens problem, the initial values were set randomly. The results are summarized in Table <ref type="table">2</ref>.</p><p>Then, in order to examine the applicability of the asynchronous weak-commitment search to real-life problems rather than artificial random problems, we applied these algorithms to the distributed resource allocation problem in a communication network described in <ref type="bibr">[lo]</ref>. In this problem, there exist requests for allocating circuits between switching nodes of NTT's communication network in Japan (Fig. <ref type="figure" target="#fig_5">8</ref>). For each request, there exists an agent assigned to handle it, and the candidates for the circuits are given. The goal is to find a set of circuits that satisfies the resource constraints. This problem can be formalized as a distributed CSP by representing each request as a variable and each candidate as a possible value for the variable. We generated problems based on data from a 400 Mbps backbone network extracted from the network configuration management database developed in <ref type="bibr">NTT Optical Network Systems Laboratories [20]</ref>. In each problem, there exist 10 randomly generated circuit allocation requests, and for each request, 50 candidates are given. These candidates represent reasonably short circuits for satisfying the request. We assume that these candidates are calculated beforehand. The constraints between requests are that they do not assign the same circuits. We generated 10 different sets of randomly generated initial values for 10 different problems (100 trials in all), and averaged the results. As in the previous cycles ratio ' cycles 92.8 100% 17.3 problems, the limit for the required number of cycles was set at 1,000, The results are summarized in Table <ref type="table" target="#tab_7">3</ref>. We can see the following facts from these results: 0</p><p>The asynchronous weak-commitment search algorithm can solve problems that cannot be solved within a reasonable amount of computation time by asynchronous backtracking algorithms. By using only the min-conflict heuristic, although a certain amount of speed-up can be obtained, the algorithm fails to solve many problem instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>When the priority order is static, the efficiency of the algorithm is highly dependent on the selection of initial values, and the distribution of required cycles is quite large. For example, in the network resource allocation problem, when only the mix-conflict heuristic is used, the average number of required cycles for 63 successfully completed trials is only 92.8. However, the number of required cycles for 37 failed trials is more than 1,000. When the initial values of higher priority agents are good, the solution can easily be found. If some of these values are bad, however, an exhaustive search is required to revise these values;</p><p>this tends to make the number of required cycles exceed the limit. On the other hand, in the asynchronous weak-commitment search, the initial values are less critical, and a solution can be found even if the initial values are far from the final solution, since the variable values gradually come close to the final solution.</p><p>0</p><p>We can assume that the priority order represents a hierarchy of agent authority, i.e., the priority order of decision making. If this hierarchy is static, the misjudgments (bad value selections) of agents with higher priority are fatal to all agents. On the other hand, by changing the priority order dynamically and selecting values cooperatively, the misjudgments of specific agents do not have fatal effects, since bad decisions are weeded out, and only good decisions survive. These results are intuitively natural, since they imply that a flexible agent organization performs better than a static and rigid organization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS</head><p>In this paper, we develop the formalism for distributed constraint satisfaction problems, which can represent various application problems in Distributed Artificial Intelligence. We developed a basic algorithm for solving distributed CSPs, called asynchronous backtracking, in which agents act asynchronously and concurrently without any global control. Furthermore, we developed a more efficient algorithm called asynchvonous weak-commitment search, which can revise a bad decision without exhaustive search, just as the weak-commitment search algorithm does for CSPs. We presented a series of experimental results to compare the efficiency of these algorithms. These results show that the asynchronous weak-commitment search algorithm can solve fairly large-scale problems such as the distributed 1,000-queens problem, the distributed graph-coloring problem, and the network resource allocation problem, within a reasonable amount of time.</p><p>Our future work includes examining the effectiveness of the asynchronous weak-commitment search algorithm in more practical applications, introducing other heuristics (e.g., forward-checking) into the asynchronous weakcommitment search algorithm, and clarifying the appropriate agent/variable ordering heuristics when each agent has multiple variables. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Example of a constraint network</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Procedures for receiving messages (asynchronous backtracking).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Example of algorithm execution (asynchronous backtracking).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>8 8 .</head><label>8</label><figDesc>Since a link in the constraint network represents a logical relation between agents, adding a link does not mean adding a new physical communication path between agents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Example of algorithm execution (asynchronous backtracking).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig 5 .</head><label>5</label><figDesc>Fig 5. Procedures for receiving messages (asynchronous weak-commitment search).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Comparison between synchronous and asynchronous backtracking (distributed n-queens).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Example of the network resource allocation problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>FOR SOLVING DISTRIBUTED CSP</head><label></label><figDesc></figDesc><table><row><cell>The methods for solving CSPs can be divided into two</cell></row><row><cell>groups, namely search algorithms (e.g., backtracking algo-</cell></row><row><cell>rithms), and consistency algorithms [121. Consistency algo-</cell></row><row><cell>rithms are preprocessing procedures that are invoked be-</cell></row><row><cell>fore search. Consistency algorithms in the Assumption-</cell></row><row><cell>based Truth Maintenance System framework [131 are es-</cell></row><row><cell>sentially monotonic and can be applied straightfor-</cell></row><row><cell>wardly to distributed CSPs. Namely, if each agent has</cell></row><row><cell>its own Assumption-based Truth Maintenance System,</cell></row><row><cell>these agents can execute the consistency algorithm by ex-</cell></row><row><cell>changing their possible values, generating new constraints</cell></row><row><cell>(nogoods) using hyper-resolution rules, and further ex-</cell></row><row><cell>changing obtained nogoods [14]. Therefore, in this paper</cell></row><row><cell>hereafter, we focus on search algorithms for distributed</cell></row><row><cell>CSPs. We can consider two trivial algorithms for solving</cell></row><row><cell>distributed CSPs.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>x2 #x3. 3. In</head><label></label><figDesc>[7], a variation of the synchronous backtracking algorithm called the</figDesc><table><row><cell>there are three agents, xl, x2, x3, with vari-</cell></row><row><cell>able domains 11, 21, {21, 11, 21, respectively, and constraints</cell></row><row><cell>x1 #x3 and Network Consistency Protocol is presented. In this algorithm, agents construct</cell></row><row><cell>a depth-first search tree. Agents act synchronously by passing privilege, but</cell></row><row><cell>the agents that have the same parent in the search tree can act concurrently.</cell></row><row><cell>4. It must be emphasized that this constraint network has nothing to</cell></row><row><cell>do with the physical communication network. The link in the constraint</cell></row><row><cell>network is not a physical communication link, but a logical relation be-</cell></row><row><cell>tween agents.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>check-agent -view; end do: when received (nogood, x3, nogood</head><label></label><figDesc>to agent-view; ) do -(ii) add nogood to nogood-lzst; when(xk,dk)  where xk is not connected is contained in nogood do request xk to add a link from x k to 2,;</figDesc><table><row><cell cols="2">add (xk, d k ) to agent-vzew; end do;</cell></row><row><cell>old-value</cell><cell>current-value; check-agent-view; -(ii-a)</cell></row><row><cell cols="2">when old-value = current-value do</cell></row><row><cell cols="2">send (ok?, ( E ? , current-value)) to x3; end do; end do;</cell></row><row><cell cols="2">procedure check-agent-view</cell></row><row><cell cols="2">when agent-vzew and current-value are not consistent do</cell></row><row><cell cols="2">if no value in D, is consistent with agent-vzew then backtrack; -(iii)</cell></row><row><cell cols="2">else select d</cell></row></table><note><p>E D, where agent-vrew and d are consistent, current-value +-d; send (ok?, (z,, d ) ) to outgoing links; end if; end do; procedure backtrack nogoods when an empty set is an element of nogoods do terminate this algorithm; end do; {V I V= inconsistent subset of agent-vzew}; ~ (iii-a) broadcast to other agents that there is no solution, for each V E nogoods do; select (xJ,d3) where x3 has the lowest priority in V; ~ (iii-b) send (nogood. x,, V) to x3; remove (x3, d 3 ) from agent-vzew; end do; check-agent-view; end do:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>est priority, xl, is in an infinite loop. Because it has the highest priority, x1 only receives nogood messages. When it proposes a possible value, x1 either receives a nogood message back, or else gets no message back. If it receives nogood messages for all possible values of its variable, then it will generate an empty nogood (any choice leads to a constraint violation) and the algorithm will terminate. If it does not receive a nogood message for a proposed value, then it will not change that value. Either way, it cannot be in an infinite loop. Now, assume that agents x1 to xk-1 (k &gt; 2) are in a stable state, and agent x k is in an infinite processing loop. In this case, the only messages agent xk receives are nogood messages from agents whose priorities are lower than k, and these nogood messages contain only the agents x1 to xk Since</figDesc><table /><note><p>agents x1 to xk-1 are in a stable state, the nogoods agent xk receives must be compatible with its agent-view, and so xk</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE 1 ASYNCHRONOUS</head><label>1</label><figDesc></figDesc><table><row><cell>COMPARISON BETWEEN ASYNCHRONOUS BACKTRACKING AND</cell></row><row><cell>WEAK-COMMITMENT SEARCH (DISTRIBUTED N-QUEENS)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE 3 COMPARISON</head><label>3</label><figDesc>BETWEEN ASYNCHRONOUS BACKTRACKING AND ASYNCHRONOUS WEAK-COMMITMENT SEARCH (NETWORK RESOURCE ALLOCATION PROBLEM)</figDesc><table><row><cell>asynchronous</cell></row><row><cell>backtracking</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We can consider the case that several agents share a variable. However, such a case can be formalized as these agents have different variables, and there exist constraints that these variables must have the same value.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In [ill, an algorithm in which each agent has multiple variables is described.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors thank N. Fujii and I. Yoda for providing the network configuration management database, and Y. Nishibe for providing the example problems.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="bibr">1997)</ref><p>. He first proposed parallel rule firing and extended it to distributed rule firing. Organizational self-design was then introduced into distributed production systems for increasing adaptiveness. With colleagues in 1994, he initiated work on Communityware: Towards Global Collaboration (John Wiley and Sons, 1998). He is a member of the IEEE. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kazuhiro</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Multiagent Truth Maintenance</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Huhns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Bridgeland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><forename type="middle">J</forename><surname>Doyle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="231" to="272" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
	<note>Artificial Intelligence</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Multistage Negotiation for Distributed Constraint Satisfaction</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Conry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Lesser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">477</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Distributed Constrained Heuristic Search</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Sycara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">461</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">DATMS: A Framework for Distributed Assumption Based Reasoning</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distributed Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Gasser</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Huhns</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="293" to="318" />
			<date type="published" when="1989">1989</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On the Feasibility of Distributed Constraint Satisfaction</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Collin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22th Int&apos;l Joint Conf</title>
		<meeting>22th Int&apos;l Joint Conf</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="318" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Parallel and Distributed Algorithms for Finite Constraint Satisfaction Problems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mackworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third IEEE Symp. Parallel and Distributed Processing</title>
		<meeting>Third IEEE Symp. Parallel and Distributed essing</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="394" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Weak-Commitment Search for Solving Constraint Satisfaction Problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Nat&apos;l Conf</title>
		<meeting>12th Nat&apos;l Conf</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Speed-up of Distributed Constraint Satisfaction and Its Application to Communication Network Path Assignments</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Nishibe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ishida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Systems and Computers in lapan</title>
		<imprint>
			<date type="published" when="1991">1994. 1991</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page">445</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dynamic -&amp;riable/Value Ordering Heuristics for Solving Large-Scale Distributed Constraint Satisfaction Problems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mackworth</surname></persName>
		</author>
		<idno>1121 M: Yokoo</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. 22th Int&apos;l Workshop Distributed Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Shapiro</surname></persName>
		</editor>
		<meeting>22th Int&apos;l Workshop Distributed Artificial Intelligence</meeting>
		<imprint>
			<publisher>New York Wiley-Interscience</publisher>
			<date type="published" when="1992">1993. 1992</date>
			<biblScope unit="volume">407422</biblScope>
			<biblScope unit="page" from="285" to="293" />
		</imprint>
	</monogr>
	<note>Encyclopedia of Artificial Intelligence. second ed.</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Comparison of ATMS and CSP Techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kleer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Inf&apos;l Joint Conf</title>
		<meeting>11th Inf&apos;l Joint Conf</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="290" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Distributed Constraint Satisfaction for DAI Problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ishida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pvoc. 10th Int&apos;l Wovkshop Distributed Artificial Intelligence</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Distributed Snapshots: Determining Global States of Distributed Systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Rosenkrantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stearns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><forename type="middle">K</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="63" to="75" />
			<date type="published" when="1978">1978. 1985</date>
		</imprint>
	</monogr>
	<note>ACM Trans. Computer Systems</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Minimizing Conflicts: A Heuristic Repair Method for Constraint Satisfaction and Scheduling Problems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Minton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Johnston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Philips</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Laird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. 11th Nat&apos;l Conf. Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="40" to="45" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
	<note>Artificial Intelligence</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Dynamic Backtracking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ginsberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">2546</biblScope>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">H</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Fujii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yamanaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Yoda</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="161" to="205" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">figuration Management Database</title>
	</analytic>
	<monogr>
		<title level="j">NTT R&amp;D</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1" to="509" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Distributed Constraint Satisfaction for Formalizing Distributed Problem Solving</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Durfee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ishida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Puoc. 12th IEEE Int&apos;l Conf. Distributed Computing Systems</title>
		<imprint>
			<biblScope unit="page" from="1313" to="1614" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
