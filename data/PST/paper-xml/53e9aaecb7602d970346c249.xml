<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MANTIS: System Support for MultimodAl NeTworks of In-situ Sensors</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">H</forename><surname>Abrach</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Colorado at Boulder</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">S</forename><surname>Bhatti</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Colorado at Boulder</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">J</forename><surname>Carlson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Colorado at Boulder</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">H</forename><surname>Dai</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Colorado at Boulder</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">J</forename><surname>Rose</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Colorado at Boulder</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Colorado at Boulder</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">B</forename><surname>Shucker</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Colorado at Boulder</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">J</forename><surname>Deng</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Colorado at Boulder</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">R</forename><surname>Han</surname></persName>
							<email>rhan@cs.colorado.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Colorado at Boulder</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">MANTIS: System Support for MultimodAl NeTworks of In-situ Sensors</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0DA7DC40A0E3F9AAC57F195A6C13A0EC</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Design</term>
					<term>Experimentation</term>
					<term>Performance</term>
					<term>Security</term>
					<term>Human Factors Wireless sensor networks</term>
					<term>operating systems</term>
					<term>lightweight</term>
					<term>multimodal prototyping</term>
					<term>dynamic reprogramming</term>
					<term>GPS</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The MANTIS MultimodAl system for NeTworks of In-situ wireless Sensors provides a new multithreaded embedded operating system integrated with a general-purpose single-board hardware platform to enable flexible and rapid prototyping of wireless sensor networks. The key design goals of MANTIS are ease of use, i.e. a small learning curve that encourages novice programmers to rapidly prototype novel sensor networking applications in software and hardware, as well as flexibility, so that expert researchers can leverage or develop advanced software features and hardware extensions to suit the needs of advanced research in wireless sensor networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Categories and Subject Descriptors</head><p>D.4.7 [Operating Systems]: Organization and Design -real-time systems and embedded systems, interactive systems. C.3 [Computer Systems Organization] Special-purpose and Application-based Systems -real-time and embedded systems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The growing popularity of wireless sensor networks (WSNs) has placed increasing demands upon the infrastructure of today's general-purpose hardware/software sensor systems <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b4">4]</ref> to support improved flexibility, ease of use, and lower cost. The MANTIS MultimodAl system for NeTworks of In-situ wireless Sensors provides a new multithreaded embedded operating system integrated with a general-purpose single-board hardware platform to enable flexible and rapid prototyping of wireless sensor networks. The key design goals of MANTIS are ease of use, i.e. a small learning curve that encourages novice programmers to rapidly prototype novel sensor networking applications, as well as flexibility, so that expert researchers can continue to adapt and extend the hardware/software system to suit the needs of advanced research.</p><p>The first goal in the design of the MANTIS OS (MOS) was to meet the objective of ease of use or convenience while also adapting MOS to the resource constraints of wireless sensor networks, namely limited memory and power. To lower the barrier to entry into the field of sensor networks and encourage novice application developers, early design choices of MOS adhered to familiar themes in programming languages and operating systems design. For these reasons, MOS selected as its model the classical structure of layered multithreaded operating systems, which includes multithreading, pre-emptive scheduling with time slicing, I/O synchronization via mutual exclusion, a standard network stack, and device drivers. Familiarity with these classical structures lowers the learning curve for novice developers. A key challenge has been to adapt these classical structures to the limited memory of sensor nodes. At present, the MOS kernel is able to achieve multithreaded pre-emptively scheduled execution with standard I/O synchronization and a network protocol stack, all for less than 500 bytes of RAM, not including individual thread stack sizes.</p><p>Another means by which MOS achieves the goal of ease of use is via its choice of a standard programming language. In particular, the entire kernel and API are written in standard C. This design choice not only considerably flattens the learning curve, due to the vast number of programmers with prior experience in C, but also accrues many of the other benefits of a standard programming language, including cross-platform support and reuse of a vast legacy code base. For example, a standard stopand-wait reliable protocol as well as a standard RC5 security algorithm <ref type="bibr" target="#b5">[5]</ref> are both available in C, and have been ported into the MOS kernel. The choice of C also eases development of cross-platform multimodal prototyping environments on X86 PCs, as explained below. As a result, MOS has the potential to considerably shorten development cycles by enabling rapid prototyping of applications as well as rapid testing and debugging of additions and modifications to our MOS kernel. In the remainder of the paper, Section 2 describes the MOS architecture, how it offers a convenient environment for development of WSN applications., and how it achieves a lightweight implementation. Section 3 provides a detailed overview of advanced MOS features. Section 4 focuses on the hardware. Section 5 describes deployed applications, and Section 6 finishes with future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">LIGHTWEIGHT MANTIS OPERATING SYSTEM DESIGN</head><p>In this section, we describe the architecture of the MANTIS operating system, which adheres to a classical layered multithreaded design, as shown in Figure <ref type="figure" target="#fig_0">1</ref>. The top application and API layers provide an opportunity to observe how the choice of a simple C API promotes ease of use, cross-platform portability, and reuse of a large installed code base. In the lower layers of MOS, we describe our novel adaptation of classical OS structures to achieve a small memory footprint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M.</head><p>sense_and_forward Sample application C code, sense-andforward.c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Applications</head><p>MANTIS provides a convenient environment for creating WSN applications. Figure <ref type="figure">2</ref> illustrates a simple yet commonly used "sense_and_forward" application, which is available along with the complete MANTIS software release 0.1 at http://mantis.cs.colorado.edu/. This simple application, which runs on a sensor Nymph (see Section 4), toggles a yellow LED, reads a sensor value from an analog to digital converter (ADC) port and then transmits the value of the sensor over the radio.</p><p>All applications begin with start. Before transmitting, the network must be initialized first by calling net_init before any threads are spawned. Then two threads are spawned with thread_new. One call spawns the mos_inetd, which is provided, and the other call spawns the test_adc_send application, which has been developed by the user. Thus, an application may conveniently be built of more than one thread.</p><p>Within the test_adc_send thread, reading a sensor requires that an analog-to-digital converter (ADC) be opened with adc_open. The node address is set as well as the radio frequency power, by calling set_addr and set_radio_power, respectively. With these preliminaries completed, the application can now toggle an LED, read the sensor value from the ADC and send it over the radio, by calling the led_yellow_toggle, adc_convert_eight_polling and mos_send_to.</p><p>All of the function calls mentioned so far are part of the MANTIS System Application Programming Interface (API). The program is compact and requires a fairly shallow learning curve for C programmers. Early empirical experience with MOS suggests that application developers can rapidly prototype new applications in this environment. Applications such as a sensorenabled conductor's wand <ref type="bibr" target="#b6">[6]</ref> of Section 5 were prototyped in hours, while applications such as a frequency-hopping protocol and a port of the RC5 security standard were completed in less than two nights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">System APIs</head><p>MANTIS provides a comprehensive set of System APIs for I/O and system interaction. For a complete list and information on all the APIs please refer to http://mantis.cs.colorado.edu/. For the preceding sense_and_forward application example, the APIs that were used in the application can be categorized as:</p><p>Networking: net_init, set_addr, set_radio_power, mos_send_to</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>On board sensors (ADC): adc_convert_eight_polling, adc_open</head><p>Visual Feedback (LEDs): led_yellow_toggle</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scheduler: thread_new</head><p>The choice of a C language API simplifies cross-platform support and the development of a multimodal prototyping environment. The MANTIS System API is preserved across both physical sensor nodes as well as virtual sensor nodes running on X86 platforms. As a result, the same C code developed for MANTIS sensor Nymphs with ATMEL microcontrollers <ref type="bibr" target="#b8">[7]</ref> can be compiled to run on X86 PCs with little to no alteration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Kernel and Scheduler</head><p>The design of the MOS kernel resembles classical, UNIX-style schedulers. The services provided are a subset of POSIX threads <ref type="bibr">[8]</ref>, most notably priority-based thread scheduling with roundrobin semantics within a priority level. Binary (mutex) and counting semaphores are also supported. The goal of the MOS kernel design is to implement these familiar services in a manner efficient enough for the resource-constrained environment of a sensor node.</p><p>The most limited resource on a MANTIS node is the RAM. There are two logically distinct sections of RAM: the space for global variables that is allocated at compile time, and the rest of RAM that is managed as a heap. When a thread is created, stack space is allocated by the kernel out of the heap. The space is recovered when the thread exits. In the current implementation, the user is not able to dynamically allocate heap space, although that was an API decision and is not an inherent limitation of MOS. The kernel's main global data structure is a thread table, with one entry per thread. Since the thread table is allocated statically, there is a fixed maximum number of threads and a fixed level of memory overhead. The maximum thread count is adjustable at compile time (the default is 12). Each thread table entry is ten bytes and contains a current stack pointer, stack boundary information (base pointer and size), a pointer to the thread's starting function, the thread's priority level, and a next thread pointer for use in linked lists. Note that pointers on the AVR microcontroller are only two bytes. A thread's current context, including saved register values, is stored on its stack when the thread is suspended. This is significant, because the context is much larger than a thread table entry, and it only needs to be stored when the thread is allocated. Thus the static overhead of the thread table is only 120 bytes.</p><p>The kernel also maintains ready-list head and tail pointers for each priority level (5 by default, for 20 bytes total). Keeping both pointers allows for fast addition and deletion, which improves performance when manipulating thread lists. This is important because those manipulations are frequent and always occur with interrupts disabled. There is also a current thread pointer (2 bytes), an interrupt status byte, and one byte of flags. The total static overhead for the kernel is thus 144 bytes.</p><p>Semaphores in MOS are 5-byte structures that are declared as needed by applications; they contain a lock or count byte along with head and tail list pointers. At any given time, each allocated thread is a member of exactly one list; either one of the ready lists or a semaphore list. Semaphore operations move thread pointers between lists, and the scheduler cycles through the ready lists to locate the next thread to execute.</p><p>The scheduler receives a timer interrupt from the hardware to trigger context switches; switches may also be triggered by system calls or semaphore operations. The timer interrupt is the only one handled by the kernel--other hardware interrupts are sent directly to the associated device drivers. Upon an interrupt, a device driver typically posts a semaphore in order to activate a waiting thread, and this thread handles whatever event caused the interrupt. There are currently no 'soft' interrupts supported by the MOS kernel, although the design does not preclude adding them in the future.</p><p>In addition to driver threads and user threads, there is also an idle thread created by the kernel at startup. The idle thread has low priority and runs when all other threads are blocked. The idle thread is in a position to implement power-aware scheduling, as it may detect patterns in CPU utilization and adjust kernel parameters to conserve energy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Network Stack</head><p>Wireless networking is critical for the correct operation of a network of sensors. Such communication is typically realized as a layered network stack, not to be confused with the thread stack. The design of the MANTIS network stack is focused on efficient use of limited memory, flexibility, and convenience. The stack is implemented as one or more user-level threads. Different layers can be flexibly implemented in different threads, or all layers in the stack can be implemented in one thread. The tradeoff is between performance and flexibility. The stack is designed to minimize memory buffer allocation through layers. The data body for a packet is common through all layers within a thread. The headers for a packet are variably-sized and are pre-pended to the single data body. The stack is conveniently designed in a modular manner, with standard APIs between each layer, thereby allowing developers to easily modify or replace layer modules. The routing protocol is assigned on a per packet basis, so that different routing mechanisms can coexist, including flooding, multicast, and unicast. The stack flexibly supports multifrequency radio communication over 30 channels, enabling research into MAC protocol design, security and reliability. A flexible range of packet sizes is supported, from 12 bytes to 64 bytes, avoiding waste of scarce sensor network bandwidth.</p><p>The network stack consists of four layers, i.e. application layer, network layer, MAC layer and physical layer. At the bottom is the physical layer implementation that controls the hardware or virtual hardware (for XMOS). A set of standard APIs is provided on top of the physical implementation in order to mask the underlying hardware details from the MAC Layer. The MAC layer is responsible for controlling such aspects as network duty cycle, wherein the radio is adaptively slept to save on energy consumption.</p><p>Together, the MAC and physical layers are realized as one userlevel thread, as shown in Figure <ref type="figure" target="#fig_0">1</ref>, and is known as the base thread of the network stack. MANTIS extends the concept of user-level implementation of network stacks from such projects as ALPINE <ref type="bibr" target="#b10">[9]</ref> to the sensor networking domain, and outlines the advantages of this approach below. The base network stack thread blocks on a well-known semaphore. When a packet arrives at the radio interface, the interrupt is handled by a device driver, which places the data in a queue and then posts the semaphore where the base network stack thread is sleeping. This wakes the base network stack thread and activates the MAC layer within the base thread to fetch incoming bytes from the queue. The MAC fetches bytes from the queue and assembles them into a packet. If the destination address is a broadcast address or matches the local node's address, the MAC layer uses the destination port in the packet to find the local thread that is blocking waiting for this packet.</p><p>The network layer can either be implemented as part of the base network thread or can be implemented separately in another thread. In the latter case, the base thread will post the semaphore on which network layer thread is blocking, and then the packet will be copied from thread to thread. In general, if the upper layer is implemented outside of the lower layer's thread, then a packet will be copied between two user-level threads.</p><p>The advantage of a multi-threaded user-level network stack is that it promotes flexibility, at a cost in performance. In comparison, systems with a monolithic network stack implemented as part of the kernel are relatively inflexible. Suppose an application designer did not know in advance which features out of multicast, broadcast, or unicast are needed in a sensor network deployment. In systems with a monolithic network stack, the designer in the worst case is forced to load all three network layer modules at run time, leading to inefficient usage of highly limited RAM (less than 4 KB on ATMEL microprocessors <ref type="bibr" target="#b8">[7]</ref>).</p><p>The MANTIS decision to implement the network stack as one or more user-level threads allows a designer to activate or deactivate a particular routing protocol or reliable protocol on demand as a user-level thread. For example, if a routing protocol has been stored in flash, then that protocol can be activated by simply starting it in RAM. If needed, multiple routing protocol threads can coexist at the same time. Each packet is directed to the appropriate protocol thread on a per-packet basis. This flexible structure is especially useful for dynamic reprogramming in sensor networks, enabling application developers to dynamically reprogram network functionality such as routing in deployed sensor nodes by starting, stopping, and deleting user-level threads.</p><p>The decision to implement a network stack as a set of user-level threads is also useful for cross-platform prototyping of network stack functionality on X86 PCs prior to deployment in WSNs, as described in the next section.</p><p>The MANTIS system enables zero copies within a thread and single copies across threads. If a network stack is wholly implemented within the base network stack thread, then our approach begins to resemble the zero copy approach of TinyOS, SMAC <ref type="bibr" target="#b11">[10]</ref> and zero copy sockets <ref type="bibr" target="#b12">[11]</ref>. At present, we are investigating zero copies across multiple threads.</p><p>In MANTIS, the header and the data buffer for a packet are allocated separately. The MANTIS network stack allows each layer to define its own header structure. Each header consists of two parts, i.e. a common header and a protocol header. The structure of the common header is static while the structure and length of the protocol header could be varied.</p><p>The MANTIS network stack occupies about 200 bytes of RAM, when only the MAC and physical layers of the base network thread are considered. Two system data queues are required of 64 bytes each. The rest of the space is largely consumed by lowlevel configuration parameters for the CC1000 radio. Modules for a broadcast flooding routing protocol and a simple stop and wait protocol are provided in MOS as default examples for developing protocols at the network and application layers. Network layer broadcast flooding adds an additional thirty bytes of RAM.</p><p>The following APIs are provided for connectionless packet I/O: mos_send(char* header, char headerLen, char* data, char dataLen); mos_send_to(uint16_t addr, uint8_t port, char* data, char dataLen, uint8_t proto); mos_recv(Packet* pkt, uint8_t port, uint8_t proto);</p><p>The network stack also allows the application to specify the length of time that the thread is willing to be blocked on the mos_recv() function in order to avoid waiting indefinitely.</p><p>Together, the code size of the kernel, scheduler, and network stack occupies less than 500 bytes of RAM and about 14 KB of flash. This permits sufficient space for multiple application threads to execute in the ATMEL's 4 KB of RAM, as well as sufficient storage in the ATMEL's 128 KB of flash storage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Device Drivers</head><p>MANTIS adopts the traditional logical/physical partitioning with respect to device driver design for the hardware. For example, to turn the green LED on, the LED system API provides a led_green_on call (logical level), which is transformed to a PORTA |= 0x80 (physical level) action. The application developer need not interact with the hardware to accomplish a given task. However, full access is available to the hardware for the adventurous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ADVANCED SENSOR-SPECIFIC FEATURES OF MANTIS OS</head><p>Sensor networks impose additional unique demands on the design of operating systems beyond lightweight resource constraints. Sensor networking application developers need to be able to prototype and test applications prior to distribution and physical deployment in the field. Also, during deployment, in-situ sensor nodes need to be capable of being both dynamically reprogrammed and remotely debugged. In the next sections, MANTIS identifies and implements each of these three key advanced features for expert users of general-purpose sensor systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Multimodal Prototyping Environment</head><p>The MANTIS prototyping environment provides a framework for prototyping diverse applications across heterogeneous platforms.</p><p>A key requirement of sensor systems is the need to provide a  prototyping environment to test sensor networking applications prior to deployment. Postponing testing of an application until after its deployment across a distributed sensor network can incur severe consequences. As a result, a prototyping environment is an especially helpful tool for sensor network application developers.</p><p>The MANTIS prototyping environment extends beyond simulation to provide a larger framework for development of network management and visualization applications as virtual nodes within a MANTIS sensor network. First, MANTIS has the desirable property of enabling an application developer to test execution of the same C code on both virtual sensor nodes and later on in-situ physical sensor nodes.</p><p>Second, MANTIS seamlessly integrates the virtual environment with the real deployment network, such that both virtual and physical nodes can coexist and communicate with each other in the prototyping environment, as shown in Figure <ref type="figure">3</ref>. Seamless integration enables phased deployment and testing of an application, i.e. application code could first be evaluated on an all-virtual network, then be deployed without modification to a hybrid network of both virtual and a few physical nodes, followed by full deployment on an allphysical network. The combination of all-virtual, hybrid, and all-physical modes of testing form a multimodal prototyping environment. Third, MANTIS permits a virtual node to leverage other APIs outside of the MANTIS API, e.g. a virtual node with the MANTIS API could be realized as a UNIX X windows application that communicates with other renderering or database APIs to build visualization and network management applications, respectively. This virtual node, a.k.a. UNIX application, would incorporate the MANTIS system API as a simple means of becoming just another node within the MANTIS network of virtual and physical nodes.</p><p>MANTIS achieves a multimodal prototyping environment by preserving a common C API across all platforms. This approach resembles WINE <ref type="bibr" target="#b13">[12]</ref>, but eliminates the problems of hidden system calls, since all such calls are publicly known in MANTIS. Due to the wide availability and support for the AVR microcontroller under Linux and Windows, it is possible to build MOS, with minor modifications, as an application that runs on the X86 platform over both Linux and Windows. We call this user space application running on an X86 platform XMOS. For example, Figure .4 illustrates XMOS utilizing a POSIX shim layer to translate between MANTIS' uniform API and the underlying UNIX operating system. In this way, MOS applications can be realized as both virtual sensor nodes on X86 platforms as well as live applications on ATMEL sensor nodes (AMOS). This enables MANTIS to support multimodal networks, consisting of XMOS nodes and AMOS nodes seamlessly interacting with each other. The same C source code runs transparently over both XMOS and AMOS platforms, enabling phased deployment from XMOS to AMOS. Figure <ref type="figure">3</ref> shows the structure of the network, with the two networks connected to each other via a serial RS232 link. Thus, a mos_send(…) system call on the AMOS nodes causes the data to be transmitted over the radio. The bridge nodes on either side of the bridging serial link would additionally send the data over the serial link using the mos_uart_send(..) call.</p><p>A mos_send(…) call on the XMOS nodes causes the data to be transmitted over the IP network instead.</p><p>The structural implications of the above multimodal prototyping environment afford great flexibility to application developers. First, XMOS nodes need not be identical and indeed heterogeneous applications can be supported simultaneously. For example, some XMOS nodes can be written as base stations, while others may perform aggregation duties for directed diffusion <ref type="bibr" target="#b14">[13]</ref>, and still others may coexist to perform multicast routing <ref type="bibr" target="#b15">[14]</ref>. Second, XMOS nodes are not confined to a single PC, and can be distributed across any number of PCs, maintaining communication via IP packets. This eases the ability of the prototyping environment to scale to large numbers of XMOS virtual nodes. Third, an arbitrary number of bridging links can connect XMOS and AMOS environments, and need not be limited to serial links either. Fourth, virtual nodes must support but are not limited to the MANTIS API. As a result, a virtual node realized as a UNIX application could be integrated into the MANTIS sensor network on one side and speak with a rendering API, database API, X windows API, or socket API on another side. Thus, the sensor network can be accessed from any virtual node, easing development of applications for visualization, network management, and gateway translation to other networks. The gateway function is especially critical to translate sensor packet data to/from IP networks. Fifth, since the network stack is implemented as user-level thread(s) above the common API, then an added bonus is that the XMOS environment can be used to prototype OS functionality in the form of networking routing and reliability functions. XMOS is not confined to prototyping user programs only. Finally, provided that hardware translation is correct, the XMOS architecture offers the potential to feed real sensor data into virtual nodes to drive prototype evaluation.</p><p>A variety of other sensor networking simulators possess some but not all of the features of the MANTIS multimodal prototyping environment.</p><p>TOSSIM is a simulator for TinyOS <ref type="bibr" target="#b16">[15]</ref>, and enables the same code to run in PC simulation as on real sensor nodes, enabling debugging and verification on PCs prior to deployment. However, the simulator has to run on one machine and with the same application instance inside. TOSSF extends TOSSIM to enable heterogeneous applications, but they're still confined to one PC <ref type="bibr" target="#b17">[16]</ref>. Sensorsim is an extension to ns2 and provides a simulation framework which models the sensor nodes and also provides a "hybrid" simulation combining the real and virtual network <ref type="bibr" target="#b18">[17]</ref>. However, the sensor network applications are required to be re-implemented for the target platform, resulting in two completely different code bases that must be maintained. emStar is a framework for developing applications on wireless sensor networks and combines pure simulation, hybrid mode and real distributed deployments <ref type="bibr" target="#b3">[3]</ref>. However, the implementation is based on the combination of HP iPAQ platform and the motes. In MANTIS, no extra hardware such as the iPAQ is required.</p><p>The MANTIS multimodal framework does have some limitations. By choosing to preserve a high-level API across platforms rather than low-level instructions as in a virtual machine, each XMOS node does not perfectly model the performance of a sensor node. Our tradeoff has been for improved flexibility rather than precise emulation. Also, not all OS functionality can be tested in the above architecture. While the network stack and remote shell via the command server can be tested, as well as user programs, other functionality such as the kernel's scheduler are at present beyond the cross-platform testing capabilities of XMOS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Dynamic Reprogramming</head><p>Dynamic reprogramming or retasking is an especially useful feature for sensor networks. Research has found that sensor nodes should be remotely reconfigurable over a wireless multihop network after being deployed in the field <ref type="bibr" target="#b19">[18]</ref>. Since sensor networks may be deployed in inaccessible areas and may scale to thousands of nodes <ref type="bibr" target="#b20">[19]</ref>, this simplifies management of the sensor network, i.e. so that biologists need not go into the field again to reprogram sensors and change parameters such as. the sensor's sampling rate and trigger threshold or algorithms such as sensor calibration or time synchronization.</p><p>MOS achieves dynamic reprogramming on several granularities: reflashing of the entire OS; reprogramming of a single thread; and changing of variables within a thread. Another feature that is especially useful for sensor systems is the ability to remotely debug a running thread. MOS provides a remote shell that enables a user to login and inspect the sensor node's memory, e.g. the thread table of an executing thread.</p><p>To overcome the difficulty of reprogramming the network, MOS includes two reprogramming modes. The simpler programming mode is similar to that used in many other systems and involves direct communication with a specific MANTIS node. On a Nymph, this would be accomplished via the serial port: The user simply connects the node to a PC and opens the MANTIS shell. Upon reset, MOS enters a boot loader that checks for communication from the shell. At this point, the node will accept a new code image, which is downloaded from the PC over the direct communication line. From the shell, the user also has the ability to inspect and modify the node's memory directly (peek and poke), as well as spawn threads and retrieve debugging information-including thread status, stack fill, and other such statistics-from the operating system. The boot loader transfers control to the MOS kernel on command from the shell, or at startup if the shell is not present.</p><p>The more advanced programming mode is used when a node is already deployed, and does not require direct access to the node. The spectrum of dynamic reprogramming of in-situ sensor networks ranges from fine grained reprogramming (modifying constants like sampling rate) to complete reprogramming of the sensor nodes. MOS has a provision for reprogramming any portion of the node-up to and including the operating system itself-while the node is deployed in the field. This is accomplished through the MOS dynamic reprogramming interface. The capability to use the dynamic reprogramming interface will be built into the MANTIS programming tool.</p><p>Current solutions for dynamic reprogramming <ref type="bibr" target="#b21">[20]</ref> are virtual machine (VM) -based where the VM resides over the underlying sensor operating system and processes the incoming code capsules. A special stack-based instruction set is used to reprogram the sensor nodes, reducing the amount of data that is transmitted over the network. In contrast to the VM based approach, MOS allows binary updates to reprogram a node. The developer does not need to learn a new stack-based instruction set; instead, the existing deployed application only needs to be modified and recompiled, then a binary patch may be transmitted to the MANTIS node.</p><p>The dynamic reprogramming capability is actually implemented as a system call library, which is built into the MOS kernel. Any application may write a new code image through calls to this library; the code image is stored into EEPROM as it is written. The application then calls a commit function that writes out a control block for the MOS boot loader, which causes it to install the new code on reset. A software reset completes the reprogramming process. Using the reprogramming library, an application--such as the MANTIS command server--may download a patch using any communications method it desires (typically the regular network stack), apply the patch to the existing code image, and run the updated code. Thus, the entire code image, with the exception of the locked boot loader section, may be reprogrammed over an arbitrary network while the node is deployed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Remote Shell and Command Server</head><p>Traditional solutions for network management such as SNMP <ref type="bibr" target="#b22">[21]</ref> are not applicable to highly dynamic sensor networks. Existing solutions for monitoring sensor networks look at topology extraction <ref type="bibr" target="#b23">[22]</ref> and computing summaries of network properties for energy efficient monitoring of sensor networks <ref type="bibr" target="#b24">[23]</ref>. In addition to these mechanisms, the user may wish to manage the nodes in the network in other ways. To provide this flexibility, MOS includes the MANTIS Command Server (MCS). From any device in the network equipped with a terminal (a laptop PC, for example), the user may invoke the command server client (also referred to as the shell) and "log in" to a node. This node may be either a physical node (e.g. on a Nymph or Mica board) or it may be a virtual node running as a process on a PC. Figure <ref type="figure" target="#fig_3">5</ref> illustrates an example of the remote shell interface.</p><p>The MCS itself is implemented as an application thread. It listens on a network port for commands and replies with the results, in a manner similar to RPC. In effect, the shell gains the ability to control a node remotely through MCS. The user may alter the node's configuration settings, run or kill programs, display the thread table and other operating system data, inspect and modify the node's data memory, and call arbitrary user-defined functions. The shell is a powerful debugging tool, since it allows the user to examine and modify the state of any node, without requiring physical access to the node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">MANTIS HARDWARE</head><p>The MANTIS hardware nymph's design was inspired by the Berkeley MICA and MICA2 Mote architecture <ref type="bibr" target="#b1">[1]</ref>. To help lower our development costs, shorten our development cycle, and enhance our research goals, we designed the MANTIS hardware nymph sensor node, adhering to the same themes of ease of use, flexibility, and adaptation to sensor networks that characterized our software design. The learning curve for novice users is lowered by employing a single-board design, as shown in Figure <ref type="figure" target="#fig_2">6</ref>, altogether incorporating a low power Atmel Atmega128(L) microcontroller (MCU) <ref type="bibr" target="#b8">[7]</ref>, analog sensor and digital ports, a low power Chipcon CC1000 multi-channel RF radio <ref type="bibr" target="#b25">[24]</ref>, EEPROM, power ADC sensor, and serial ports on a quad-layer 3.67 x 3.3 cm Printed Circuit Board (PCB). For the common user, the singleboard design eliminates the need for a separate sensor board or separate programming board, which reduces volume and cost. The pins for the serial interface are directly accessible on the nymph in a standard DIP package, enabling direct connection of each nymph to a laptop via a serial cable, as shown in Figure <ref type="figure" target="#fig_2">6</ref>.</p><p>Direct serial accessibility combined with dynamic reprogramming over wireless largely eliminate the need for a programming board for the common user. Nymphs are versatile in that any node can serve as a base station or as a leaf. In addition, three sensor interfaces are built into each nymph and are directly accessible to the user via wire-wrappable DIP pins, eliminating the need for the sensor board in the common case. A standard three-wire interface similar to the popular Lego Mindstorms was selected, enabling a novice to quickly prototype from a large selection of inexpensive resistive sensors. Also, GPS capability has been added to each nymph in the form of a connector that fits the Trimble Lassen SQ GPS chip shown to the right of the nymph in Figure <ref type="figure" target="#fig_2">6</ref>. Again, the goal is to simplify deployment of GPS-enabled applications for beginning users. If the GPS chip is not needed, then the connector is simply vacant. Finally, the nymph includes an AC/DC option. This is useful for prototyping in the lab and avoids excessive consumption of batteries. An AC/DC adapter from Radioshack is satisfactory. A simple 3-way switch toggles between the AC/DC option, OFF and the battery option. We envision that the power option will be useful in future deployments of indoor sensor networks, where power outlets are readily available for exploitation. To support advanced research, the nymph includes several interfaces that allow expert users to extend its capability. First, the nymph exports a standard sized JTAG DIP interface for expert users that need to burn the bootloader into the Atmel's flash. For example, researchers experimenting with dynamic reprogramming may need to reset the fuses on the flash. For the novice user, we envision that the bootloader will be preinstalled by the manufacturer or an expert user with access to a JTAG programming device. In difficult debugging situations, the JTAG interface can also be used for line by line, in-system debugging using GDB. Second, the nymph includes a 20-pin connector with standard DIP interface for wire-wrapping or development of an advanced add-on boards with mating connector. This connector has direct access to the MCU's external interrupt pins, I 2 C bus, data lines, timers, and pulse width modulation (PWM) pins. Some potential add-on boards would be I 2 C expanders that use the interrupt and I 2 C pins to add touch pads for example. The data lines may be used to add liquid crystal displays, while the PWM pins may be used for controlling motors, timers for time sensitive applications, or simply as more pins for general digital I/O. Rapid prototyping of user interfaces (conductor's baton) using MANTIS sensor nymphs.</p><p>Third, the MANTIS nymph supports multiple antenna options, including the addition of an antenna amplifier, via another connector. This connector acts more like a jumper enabling and disabling the built in low-range low power capabilities and replacing them by add-on circuitry. The add-on circuitry implements a 30dB low-noise power amplifier that is a 24-pin chip plus its additional support circuitry and properly matched 915 MHz antenna. The addition of the amplifier increases the communication range of the MANTIS Nymph to up to 2km at the cost of up to half a Watt additional power consumption. For those reasons we provide the connector as an option and not a requirement. One final important advanced feature is the addition of a single channel I 2 C 16-bit ADC. This ADC enables monitoring of the battery voltage level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">GPS-Enabled Time Synchronization</head><p>To demonstrate the capabilities of MOS and the MANTIS nymph, we implemented and evaluated a variety of time synchronization algorithms in a GPS-enabled framework. GPS-enabled nymphs provide a framework for evaluating the in-situ accuracy of deployed time synchronization algorithm. Prior to the advent of GPS-enabled nymphs, the accuracy of time synchronization was evaluated in more cumbersome ways in sensor networks, either via equipment probes, or outside of the sensor network realm altogether. GPS has also been used in sensor networks for location awareness <ref type="bibr" target="#b26">[26]</ref> and location tracking of wildlife, e.g. Zebranet <ref type="bibr" target="#b27">[27]</ref>. Time synchronization is important for sensor networks in order to correctly timestamp an event and coordinate wake/sleep duty cycles of low power sensor networks <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b31">31]</ref>. Figure <ref type="figure" target="#fig_6">8</ref> illustrates a general network topology in which nodes that either lack GPS or lack line of sight to be able to observe GPS satellites request clock synchronization with GPS-enabled nodes. We constructed an experiment consisting of a network topology with five sensor nymphs in a row. This linked routing chain is similar to the linear route in Figure <ref type="figure" target="#fig_6">8</ref> taken by node N2's Simple Network Time Protocol (SNTP) request <ref type="bibr" target="#b32">[32]</ref>, which propagates to the GPSenabled node four hops away. On a given sensor node, the estimated clock obtained from a time synchronization algorithm is compared to the authoritative GPS clock right after reception of query response. Sync-requests are initiated by the client every 10 seconds. This experiment was repeated a hundred times to obtain  Power consumption numbers for the 4-layer nymph are given in Table <ref type="table" target="#tab_2">1</ref>. GPS consumes significant power and will require careful power management to limit its impact on battery lifetime. Comparable recent hardware technology includes the MICA2 Motes [25] and the GPS-enabled GNOMES <ref type="bibr" target="#b26">[26]</ref>. The MANTIS platform has successfully served as the basis for a system for constructing rapid prototypes of wireless input devices and user interfaces <ref type="bibr" target="#b6">[6]</ref>. The conductor's baton, shown in Figure <ref type="figure" target="#fig_4">7</ref>, is an example of a gestural interface device that utilizes a two-axis accelerometer to detect the motion of the user's hand. Using one nymph to read the sensor values from the accelerometer and a second nymph (connected to a PC via the serial port) as a base station to wirelessly collect the data, a musical tempo is interpreted from the beats marked by the user. This tempo is then transmitted to an algorithmic music application, which changes the speed at which the music is played based on the user's gestures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">MANTIS APPLICATIONS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Rapid Prototyping of User Interfaces</head><p>an average estimate of the inaccuracy. SNTP provides a simple and well-known mechanism for a client to synchronize with a server who has an accurate clock by using the roundtrip delay over multiple hops. An adaptation of SNTP <ref type="bibr" target="#b31">[31]</ref> that employs hierarchy was also implemented, i.e. each child uses SNTP on its parent. We call this approach hierarchical SNTP (HSNTP). Both algorithms are also evaluated over multi-frequency radios, creating MSNTP and MHSNTP. As MANTIS supports communicating in multi-channels, by employing a separate control channel for time synchronization queries and responses, variations in latency due to collisions are reduced, resulting in more accurate clock estimation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">FUTURE WORK</head><p>The MANTIS system is still very much a work in progress. While we have managed to achieve a lightweight OS, there are additional demands on sensor OS designs that have not yet been fully integrated into our design. We have identified low power operation as a key future direction for development of the MANTIS OS. The challenge will be to integrate within a multithreaded model the idea of sleeping threads until useful work is required. First, the idle loop must be replaced with a powerefficient scheduler. One approach is to add another parameter to the thread_new call so that the application can provide static hints at the time it is spawned. A follow-on approach would incorporate dynamic hints from within the application with a power_hint call to modify the application's requirements dynamically. Prior work on power-efficient scheduling and systems should be leveraged <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b34">34]</ref>. Additional complications will result from integrating components such as the Atmel and CC1000 with multiple low power modes. At present, MOS exports setting these modes through the API, but applications</p><p>have not yet been developed to exploit these low power features. We are further interested in pushing the power-efficient scheduler into user space to further streamline the kernel, similar to the micro-kernel architecture <ref type="bibr" target="#b35">[35]</ref>.</p><p>There is still some work to be done in demonstrating reliability for code updates over the network, optimizing the size of updates, and ensuring the security and authenticity of updates. Even after those issues are addressed, we have only solved the problem of reprogramming a single node remotely. While one could certainly iterate through all nodes in a network in order to reprogram them all, that would be inefficient and perhaps infeasible if the network were large. The broader problem of remotely reprogramming a network, as opposed to a node, will be addressed in future work.</p><p>We also intend to integrate security into dynamic reprogramming, so that downloaded code can be authenticated, decrypted, and checked for tampering. At present, we have implemented an RC5-based CBC mode block cipher encryption/decryption library. This library also provides functions for sending encrypted packets and generating message authentication codes to protect integrity of packets. The API is: mos_sec_send_to(uint16_t addr, uint8_t port, char* data, char dataLen, uint8_t proto, rc5key_info *rc5key); mos_sec_recv(Packet* pkt, uint8_t port, uint8_t proto, rc5key_info *rc5key);</p><p>The overhead of this security library is very small, about 110 bytes of RAM. The encrypted packet transmission function adds about 6% delay compared to non-encrypted packet transmission.</p><p>An area that has not yet been addressed is simulating the wireless channel within the multimodal prototyping environment. One challenge is the difficulty of simulating wireless communication channels, especially indoor communication. Another challenge is building a structure that enable media contention among multiple virtual nodes.</p><p>The MANTIS project was recently awarded an NSF SENSORS grant to study the role of sensor networks in fighting forest fires Stay tuned to the MANTIS Web site http://mantis.cs.colorado.edu</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>The MANTIS sensor system achieves a lightweight classically structured multithreaded operating system in a memory footprint of less than five hundred bytes, including kernel and network stack. The MANTIS OS supports a simple C API that enables a shallow learning curve, cross-platform support, and reuse of a large installed code base. MOS also supports advanced sensorspecific features such as multimodal prototyping, dynamic reprogramming, and remote shells. The MANTIS nymph offers a single-board GPS-enabled solution that is also extensible.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. MANTIS OS architecture compresses a classic multithreaded layered operating system design into &lt;500 bytes of RA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. X86 MANTIS OS (XMOS) architecture uses POSIX shim layer to translate to/from underlying OS.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. MANTIS Nymph.</figDesc><graphic coords="7,361.14,76.20,158.82,152.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Remote shell.</figDesc><graphic coords="7,65.64,243.60,218.88,207.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7.Rapid prototyping of user interfaces (conductor's baton) using MANTIS sensor nymphs.</figDesc><graphic coords="8,336.18,76.20,199.96,114.18" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>over Serial at 19.2kBaud 3.0 14 Sensing and Sending over radio, Transmitting at max power 3.0 73 Sensing and Sending over radio, Transmitting at min power 3.0 40 Sensing and Sending over radio, Receiving at max power 3.0 40 Sensing and Sending over radio, Receiving at min power 3.0 27 Absolute Max power with all LEDs on and radio transmit at max power 3.0 93 Absolute Max power with all LEDs on and radio receive at max power 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Active GPS sensor nodes (G) provide clock synchronization to N1 (indoors) and N2 (outdoors, lacks GPS) via a protocol like SNTP.</figDesc><graphic coords="8,326.64,558.60,216.60,129.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>XMOS S e rial IP AMOS Figure 3. Multimodal prototyping integrates both virtual and physical sensor nodes across heterogeneous X86 and ATMEL sensor platforms.</head><label></label><figDesc></figDesc><table><row><cell>Network Network Network</cell><cell>Stack Stack Stack</cell><cell>Command Command Command</cell><cell>Server Server Server</cell><cell>T3 T4 T5 T3 T4 T5 T3 T4 T5</cell><cell>User-level threads User-level threads User-level threads</cell></row><row><cell></cell><cell cols="4">M ANTIS System API M ANTIS System API M ANTIS System API</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="3">POSIX Shim Layer POSIX Shim Layer POSIX Shim Layer</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>UNIX UNIX UNIX</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="3">Hardware Hardware Hardware</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 . Power consumption of MANTIS Nymph in various modes of operation.</head><label>1</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 . Time synchronization accuracy in microseconds.</head><label>2</label><figDesc>Table2verifies that multichannel radios dramatically improve time synchronization accuracy and lower deviation. Our anecdotal experience with GPS was that on power up GPS takes from 3 to 10 minutes to compute its position, and less than 30 seconds from a warm start. GPS was accurate to 10 meters 90% of the time.</figDesc><table><row><cell>Algorithm</cell><cell>Mean Error</cell><cell>StdDev</cell></row><row><cell>SNTP</cell><cell>39.81979</cell><cell>43. 2736</cell></row><row><cell>HSNTP</cell><cell>23.6972</cell><cell>26.438</cell></row><row><cell>MSNTP</cell><cell>20.9021</cell><cell>22.9463</cell></row><row><cell>MHSNTP</cell><cell>10.44147</cell><cell>11.5746</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">System Architecture Directions For Network Sensors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Szewczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hollar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS 2000</title>
		<imprint>
			<biblScope unit="page" from="93" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An Architecture for a Power-Aware Distributed Microsensor Node</title>
		<author>
			<persName><forename type="first">R</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bhardwaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Workshop on Signal Proc. Systems</title>
		<imprint>
			<date type="published" when="2000-10">Oct 2000</date>
			<biblScope unit="page" from="581" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">EmStar: An Environment for Developing Wireless Embedded Systems Software</title>
		<author>
			<persName><forename type="first">J</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Busek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Bychkovskiy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cerpa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ganesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Girod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Greenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schoellhammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Stathopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<idno>0009</idno>
		<imprint>
			<date type="published" when="2003-03-24">March 24, 2003</date>
		</imprint>
	</monogr>
	<note type="report_type">CENS Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">MetaCricket: A designer&apos;s kit for making computational devices</title>
		<author>
			<persName><forename type="first">F</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mikhak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Silverman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Systems Journal</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3 &amp; 4</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The RC5 Encryption Algorithm</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1994 Leuven Workshop on Fast Software Encryption</title>
		<meeting>the 1994 Leuven Workshop on Fast Software Encryption</meeting>
		<imprint>
			<biblScope unit="page" from="86" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Rapid Prototyping Of Mobile Input Devices Using Wireless Sensor Appeared in 2nd ACM International Workshop on Wireless Sensor Networks and Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Carlson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Narayan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sanghani</surname></persName>
		</author>
		<imprint>
			<publisher>WSNA</publisher>
			<biblScope unit="page">2003</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><surname>Nodes</surname></persName>
		</author>
		<title level="m">5th IEEE Workshop On Mobile Computing Systems and Applications (WMCSA) 2003</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="http://www.atmel.com/products/AVR" />
		<title level="m">Atmel AVR 8-bit RISC processor</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Portable Operating System Interface(POSIX) -Part 1: System Application Programming Interface (API)[C Language] ISO</title>
	</analytic>
	<monogr>
		<title level="j">IEC</title>
		<imprint>
			<biblScope unit="volume">9945</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1996">1996</date>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Alpine: A user-level infrastructure for network protocol development</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd USENIX Symposium on Internet Technologies and Systems</title>
		<meeting>3rd USENIX Symposium on Internet Technologies and Systems</meeting>
		<imprint>
			<date type="published" when="2001-03">March 2001</date>
			<biblScope unit="page" from="171" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An Energy-Efficient MAC Protocol for Wireless Sensor Networks</title>
		<author>
			<persName><forename type="first">John</forename><surname>Wei Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deborah</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings INFOCOM</title>
		<meeting>INFOCOM<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06">June, 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Zero-Copy TCP in Solaris</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">K</forename><surname>Jerry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chu</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX 1996 Annual Technical Conference</title>
		<meeting>the USENIX 1996 Annual Technical Conference<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-01">January 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<ptr target="http://www.winehq.com/" />
		<title level="m">WINE</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Directed Diffusion</title>
		<author>
			<persName><forename type="first">C</forename><surname>Intanagonwiwat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MobiCom 2000</title>
		<imprint>
			<biblScope unit="page" from="56" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">VLM2: A Very Lightweight Mobile Multicast System for Wireless Sensor Networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Wireless Communications and Networking Conference ( WCNC) 2003</title>
		<meeting><address><addrLine>New Orleans, Louisiana</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lee</surname></persName>
		</author>
		<ptr target="http://www.cs.berkeley.edu/pal/research/tossim.html" />
		<title level="m">Simulating tinyos networks</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">F</forename><surname>Perrone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Nicol</surname></persName>
		</author>
		<title level="m">A Scalable Simulator for TinyOS Applications, Winter Simulation Conference</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">SensorSim: A Simulation Framework for Sensor Networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Savvides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of MSWiM 2000</title>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-08-11">August 11, 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Wireless Sensor Networks for Habitat Monitoring</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mainwaring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Polastre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Szewczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">First ACM Workshop on Wireless Sensor Networks and Applications</title>
		<imprint>
			<biblScope unit="page" from="88" to="97" />
			<date type="published" when="2002">2002</date>
			<publisher>WSNA</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A taxonomy of wireless micro-sensor network models</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tilak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">B</forename><surname>Abu-Ghazaleh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Heinzelman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMOBILE Mobile Computing and Communications Review</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="28" to="36" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Mate: a Virtual Machine for Tiny Networked Sensors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ASPLOS</title>
		<imprint>
			<date type="published" when="2002-10">Oct. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Case</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fedor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Schostall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Davin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RFC 1157: Simple network management protocol (SNMP)</title>
		<imprint>
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
	<note>RFC</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">A Topology Discovery Algorithm for Sensor Networks with Applications to Network Management</title>
		<author>
			<persName><forename type="first">B</forename><surname>Deb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhatnagar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nath</surname></persName>
		</author>
		<idno>DCS-TR- 441</idno>
		<imprint>
			<date type="published" when="2001-05">May 2001</date>
		</imprint>
		<respStmt>
			<orgName>Rutgers University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">DCS Technical Report</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Computing Aggregates for Monitoring Wireless Sensor Networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First IEEE International Workshop on Sensor Network Protocols and Applications</title>
		<meeting><address><addrLine>Anchorage, AK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<ptr target="http://www.xbow.com/" />
		<title level="m">Single chip ultra low power RF transceiver</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">GNOMES: A Testbed for Low-Power Heterogeneous Wireless Sensor Networks</title>
		<author>
			<persName><forename type="first">E</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Frantz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Circuits and Systems (ISCAS)</title>
		<meeting><address><addrLine>Bangkok, Thailand</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Energy-efficient computing for wildlife tracking: Design tradeoffs and early experiences with zebranet</title>
		<author>
			<persName><forename type="first">P</forename><surname>Juang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Oki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Peh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rubenstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-10">October 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Time Synchronization for Wireless Sensor Networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Parallel and Distributed Processing Symposium (IPDPS), Workshop on… Wireless and Mobile Computing</title>
		<imprint>
			<date type="published" when="2001-04">April 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Fine-Grained Network Time Synchronization using Reference Broadcasts</title>
		<author>
			<persName><forename type="first">J</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Girod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI 2002</title>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-12">December 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Wireless Sensor Networks: A New Regime for Time Synchronization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Römer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proceedings of the First Workshop on Hot Topics In Networks (HotNets-I)</title>
		<meeting>the First Workshop on Hot Topics In Networks (HotNets-I)<address><addrLine>Princeton, New Jersey</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">October 28-29 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Network-wide Time Synchronization in Sensor Networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ganeriwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Adlakha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Srivastava</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
		<respStmt>
			<orgName>UCLA, Dept of Electrical Engineering</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Simple Network Time Protocol, (SNTP) version 4</title>
		<idno>IETF RFC 2030</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Policies for Dynamic Clock Scheduling</title>
		<author>
			<persName><forename type="first">D</forename><surname>Grunwald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Morrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Neufeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Farkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Operating Systems Design and Implementation -2000</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Itsy: Stretching the Bounds of Mobile Computing</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hamburgen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viredaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Brakmo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Waldspurger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bartlett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Farkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="28" to="36" />
			<date type="published" when="2001-04">April 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Exokernel: An Operating System Architecture for Application-level Resource Management</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Frans</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>O'toole</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Principles (SOSP)</title>
		<imprint>
			<date type="published" when="1995-12">December 1995</date>
			<biblScope unit="page" from="251" to="266" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
