<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">RankSQL: Query Algebra and Optimization for Relational Top-k Queries *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Chengkai</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kevin</forename><surname>Chen-Chuan</surname></persName>
						</author>
						<author>
							<persName><surname>Chang</surname></persName>
							<email>kcchang@cs.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ihab</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
							<email>ilyas@uwaterloo.ca</email>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Waterloo</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sumin</forename><surname>Song</surname></persName>
							<email>ssong4@uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<settlement>Baltimore</settlement>
									<region>Maryland</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">RankSQL: Query Algebra and Optimization for Relational Top-k Queries *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CD7B02680FC93606366EF294F6854D5D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper introduces RankSQL, a system that provides a systematic and principled framework to support efficient evaluations of ranking (top-k) queries in relational database systems (RDBMS), by extending relational algebra and query optimization. Previously, top-k query processing is studied in the middleware scenario or in RDBMS in a "piecemeal" fashion, i.e., focusing on specific operator or sitting outside the core of query engines. In contrast, we aim to support ranking as a first-class database construct. As a key insight, the new ranking relationship can be viewed as another logical property of data, parallel to the "membership" property of relational data model. While membership is essentially supported in RDBMS, the same support for ranking is clearly lacking. We address the fundamental integration of ranking in RDBMS in a way similar to how membership, i.e., Boolean filtering, is supported. We extend relational algebra by proposing a rank-relational model to capture the ranking property, and introducing new and extended operators to support ranking as a first-class construct. Enabled by the extended algebra, we present a pipelined and incremental execution model of ranking query plans (that cannot be expressed traditionally) based on a fundamental ranking principle. To optimize top-k queries, we propose a dimensional enumeration algorithm to explore the extended plan space by enumerating plans along two dual dimensions: ranking and membership. We also propose a sampling-based method to estimate the cardinality of rank-aware operators, for costing plans. Our experiments show the validity of our framework and the accuracy of the proposed estimation model.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Ranking queries (or top-k queries) are dominant in many emerging applications, e.g., similarity queries in multimedia databases, searching Web databases, middlewares, and data mining. Top-k queries aim at providing only the top k query results, according to a user-specified ranking function, which in many cases is an aggregate of multiple criteria.</p><p>The increasing importance of top-k queries warrants an efficient support of ranking in the relational database management system (RDBMS) and has recently gained the attention of the research community. However, most of the available solutions to supporting ranking queries are in the middleware scenario <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b4">4]</ref>, or in RDBMS in a "piecemeal" fashion, i.e., focusing on specific types of operator <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b23">23]</ref> and queries <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b21">21]</ref>, or sitting outside the core of query engines <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b31">31]</ref>. Hence, top-k queries are not treated as first-class query type, losing the advantages of integrating top-k operations with other relational operations.</p><p>Fundamental support of ranking queries is lacking mainly because relational algebra has no notion for ranking. Therefore, supporting ranking queries in RDBMS's as a first-class query type is a significant research challenge. In this paper, we present the RankSQL system, which aims at providing a seamless support and integration of top-k queries with the existing SQL query facility in relational database systems. The following is an example of top-k query.</p><p>Example 1: Consider user Amy, who wants to plan her trip to Chicago. She wants to stay in a hotel, have lunch in an Italian restaurant (condition c1: r.cuisine=Italian), and walk to a museum after lunch; the hotel and the restaurant together should cost less than $100 (c2: h.price+r.price&lt;100); the museum and the restaurant should be in the same area (c3: r.area=m.area). Further, to rank the qualified results, she specifies several ranking criteria, or "predicates"-for low hotel price, with p1: cheap(h.price); for close distance between the hotel and the restaurant, with p2: close(h.addr, r.addr); and for matching her interests with the museum's collections, with p3: related (m.collection, "dinosaur"). These ranking predicates return numeric scores and the overall scoring function sums up their values. The query is shown below in PostgreSQL syntax.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SELECT * FROM</head><p>Hotel h, Restaurant r, Museum m WHERE c1 AND c2 AND c3 ORDER BY p1 + p2 + p3 LIMIT k</p><p>With current relational query processing capabilities, the only way to execute the previous query is to: (1) consume all the records of the three inputs; (2) join the three inputs and materialize the whole join results; (3) evaluate the three predicates p1, p2, and p3 for each valid join result; (4) sort the join results on p1 + p2 + p3; and (5) report only the top k results to the user. Processing the query in this way suffers from the following problems:</p><p>• The three inputs can be arbitrarily large, hence joining these inputs can be very expensive. Moreover, it may be infeasible to assume that we can consume the whole inputs, e.g., if these inputs are from external sources such as Web databases. • The user is not interested in a total order of all possible combinations (hotel, restaurant, museum). Hence, the aforementioned processing is an overkill with unnecessary overhead. • The ranking predicates can be very expensive to compute, and hence should be evaluated only when they affect the order (rank) of the results. Current query processing must evaluate all the predicates against every valid join result to be able to sort these results.</p><p>Our proposed general approach for supporting ranking in relational query engines is based on extending relational algebra to be rank-aware. In the rest of this paper, we show that by taking ranking into account as a basic logical property, efficient query processing and optimization techniques can be devised to efficiently answer top-k queries such as the one in Example 1. We summarize the contributions of RankSQL as follows:</p><p>• Extended algebra: We propose a "rank-relational" algebra, by extending relational algebra to capture ranking as a firstclass construct.</p><p>• Ranking query execution model: We present a pipelined and incremental execution model, enabled by the rank-relational algebra, to efficiently process ranking queries.</p><p>• Rank-aware query optimization: We present a rank-aware query optimizer, by addressing the key challenges in plan enumeration and cost estimation, to construct efficient ranking query plans.</p><p>We conduct an experimental study on our initial implementation of RankSQL in PostgreSQL, for verifying the effectiveness of the extended algebra in enabling the generation of efficient ranking plans, and for evaluating the validity of our cardinality estimation method in query optimization.</p><p>The rest of the paper is organized as follows. We start in Section 2 by defining and motivating ranking queries as first-class construct. Section 3 introduces the rank-relational algebra. Section 4 introduces the execution model and physical implementation of ranking query plans. We present our proposed rank-aware query optimization in Section 5. We describe the experimental evaluation in Section 6 and review related work in Section 7. Finally, we conclude the paper in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RANKING QUERY MODEL</head><p>This section defines rank-relational queries (Section 2.1), and motivates the need for supporting ranking as a first-class construct (Section 2.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Rank-Relational Queries</head><p>A rank-relational query Q, as illustrated by Example 1, is a traditional SPJ query augmented with ranking predicates. Conceptually, such queries have the "canonical" form of Eq. 1 in terms of relational algebra:</p><formula xml:id="formula_0">Q = π * λ k τ F (p 1 ,...,pn) σ B(c 1 ,...,cm) (R1 × • • • × R h ) (1)</formula><p>That is, upon the product of the base relations (R1 × . . . × R h ), the following two types of operations are performed, before the top k tuples (which we denote by λ k ) with projected attributes (as π * indicates) are returned as the results.</p><p>• Filtering: a Boolean function B(c1, . . . , cm) filters the results by the selection operator σB (e.g., B = c1 ∧ c2 ∧ c3 for Example 1), and</p><p>• Ranking: a monotonic scoring function F(p1, . . . , pn) ranks the results by the sorting 1 operator τF (e.g., F = p1+p2+p3 for Example 1).</p><p>Formally, Q returns k top tuples ranked by F , from the qualified tuples</p><formula xml:id="formula_1">RB = σ B(c 1 ,...,cm) (R1 × • • • × R h ).</formula><p>Each tuple u has a predicate score pi [u] for every pi and an overall query score F(p1 , . . . , pn</p><formula xml:id="formula_2">)[u] = F(p1 [u], . . . , pn [u]). As a result, Q returns a sorted list K of k top tuples 2 , ranked by F scores, such that F [u] ≥ F[v], ∀u ∈ K and ∀v / ∈ K.</formula><p>As a standard assumption, F is monotonic, i.e., F(x1, . . . , xn) ≥ F(y1, • • • , yn) when ∀i : xi ≥ yi. Note that we use summation as the scoring function throughout the paper, although F can be other monotonic functions such as multiplication, weighted average, and so on.</p><p>Observe that, as Example 1 shows, a rank-relational query has four types of predicates: For filtering, as traditionally supported, the query has Boolean-selection predicates (e.g., c1) and Booleanjoin predicates (e.g., c2, c3). For ranking, according to our proposal, it has rank-selection predicate (e.g., p1, p3) and rank-join predicate (e.g., p2).</p><p>We note that, the new ranking predicates, much like their Boolean counterparts, can be of various costs to evaluate: Some predicates may be relatively cheap, e.g., p1 may simply be attribute or expression such as (200-h.price)×0.2. However, in general, predicates can be expensive as they can be user-defined or built-in functions. For instance, p1 may as well require accessing on-line sources (e.g., a Web hotel database) for the current price; p2 may involve comparing h.addr with r.addr according to geographical data; and p3 may perform an Information Retrieval style operation to evaluate the relevance.</p><p>Our goal is to support such rank-relational queries efficiently. As our discussion above reveals, such queries add a ranking dimension to query processing and optimization, which in many ways parallels the traditional dimension of filtering: While filtering restricts tuple "membership" by applying a function B of Boolean selection or join predicates, ranking restricts "order" by applying a function F of corresponding ranking predicates. While Boolean predicates can be of various costs, ranking predicates share the same concern. We thus ask, while conceptually parallel, are they both well supported in RDBMS?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Ranking as First-Class Construct</head><p>Unlike Boolean "filtering" constructs, which are essentially supported in RDBMS, the same support for "ranking" is clearly lacking. To motivate, observe that as Eq. 1 shows, relational algebra provides the selection operator σB for filtering, and the sorting operator τF for ranking. However, as we will see, there is a significant gap between their support in current systems.</p><p>Relational algebra models Boolean filtering, i.e., σ B(c 1 ,...,cm) , as a first-class construct in query processing. (Such filtering includes both selections on a single table as well as joins.) With algebraic support for optimization, Boolean filtering is virtually never processed in the canonical form (of Eq. 1)-Consider, for instance, B = c1 ∧ c2, for c1 as a selection over R and c2 a join condition 1 Note that sorting is defined in the extended relational algebra to model the ORDER BY of SQL. 2 More rigorously, it returns min(k, |RB|) tuples.</p><p>over R × S. The algebra framework supports splitting of selections (e.g., σc</p><formula xml:id="formula_3">1 ∧c 2 (R × S) ≡ σc 1 σc 2 (R × S) ≡ σc 1 (R c 2 S))</formula><p>and interleaving them with other operators (e.g., σc 1 (R c 2 S) ≡ σc 1 (R) c 2 S). These algebraic equivalences thus enable query optimization to transform the canonical form into efficient query plans by splitting and interleaving.</p><p>However, in a clear contrast, such algebraic support for optimization is completely lacking for ranking, i.e., τ F (p 1 ,...,pn) . The sorting operator τ is "monolithic": The scoring function F(p1, . . ., pn), unlike its Boolean counterpart B(c1, . . . , cm), is evaluated at its entirety, after the rest of the query is materialized-essentially as "naïve" as in the canonical form.</p><p>Such naïve materialize-then-sort scheme should not be the only choice-in fact, in many cases, it can be prohibitively expensive. If we want only the top k results, full materialization may not be necessary. As we shall see in Section 4, ranking predicates can significantly cut the cardinality of intermediate results. Moreover, all the ranking predicates have to be evaluated against every results of the full materialization under this naïve scheme. With the various costs, it may be beneficial in many cases to evaluate ranking predicates one by one, and interleave them with Boolean filtering. Thus, in a clear departure from the monolithic sorting τ , we believe rank-relational queries call for essentially supporting ranking as a first-class construct-in parallel with filtering. Such essential support, as we have observed, consists of two requirements:</p><p>1. Splitting: Ranking should be evaluated in stages, predicate by predicate-instead of monolithic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Interleaving:</head><p>Ranking should be interleaved with other operatorsinstead of always after filtering.</p><p>There are two major challenges in supporting ranking as a firstclass operation. First, as foundation, we must extend relational algebra to handle ranking and define algebraic laws for equivalence transformations (Section 3). Meanwhile, to realize the algebra, we must define the corresponding query execution model and physical operators in which "rank-relations" are processed incrementally (Section 4). Second, we need to generalize query optimization techniques for integrating the parallel dimensions of Boolean filtering (e.g., join order selection) and ranking (Section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RANK-RELATIONAL ALGEBRA</head><p>To enable rank-aware query processing and optimization, we extend relational algebra to be rank-relational algebra, where the relations, operators, and algebraic laws "respect" and take advantage of the essential concept of "rank". In this section, we define rankrelational model (Section 3.1) and extend relational algebra (Section 3.2). The new rank-relational algebra enables and determines our query execution model and operator implementations. We also discuss several laws (Section 3.3) of the new algebra to lay the foundation of query optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Rank-Relations: Ranking Principle</head><p>To fundamentally support ranking, the notion of rank must be captured in the relational data model. Thus, to start with, we must extend the semantics of relations to be rank-aware. In this extended model, we define rank-relation as a relation with its tuples scored (by some ranking function) and ordered accordingly.</p><p>In this model, how should we rank a relation?-Note that our algebra extension is to support rank-relational queries: Given a scoring function F(p1, . . . , pn) for such a query (as in Eq. <ref type="bibr" target="#b1">1)</ref>, what are the rankings of tuples as they progress in processing? Consider a base relation R.  To begin with, when no ranking predicate pi is evaluated, R as tuples "on the disk" has an arbitrary order. As the splitting requirement (Section 2.2) motivates, these ranking predicates will generally be processed in stages. We thus ask, when some predicates, say P = {p1, . . . , pj} (for j &lt; n) are evaluated (Figure <ref type="figure" target="#fig_10">1,</ref><ref type="figure">cloud  "A"</ref>), what should be the ranking? Note that although the final results are to be ranked by F(p1, . . . , pn), at this stage we do not have the complete scores of all the predicates. Therefore, we want to define a partial ranking of tuples by their current incomplete scores, so that the resulted order is consistent with their "desired" order of further processing. As queries are evaluated incrementally by "iterators" (Section 4), this ranking will order the output tuples to subsequent operations (Figure <ref type="figure" target="#fig_0">1</ref>, cloud "B"). Thus, refer to Figure <ref type="figure" target="#fig_0">1</ref>, when should a tuple t1 be ranked before t2? It turns out that we have the following ranking principle.</p><p>Property 1 (Ranking Principle): With respect to a scoring function F(p1, . . . , pn), and a set of evaluated predicates P = {p1, . . ., pj}, we define the maximal-possible score (or upper-bound) of a tuple t, denoted F P [t], as</p><formula xml:id="formula_4">F P (p1 , . . . , pn )[t] = F pi = pi[t] if pi ∈ P pi = 1 otherwise 3 . ∀i</formula><p>Given two tuples t1 and t2, if</p><formula xml:id="formula_5">F P [t1] &gt; FP [t2]</formula><p>, then t1 must be further processed if we necessarily further process t2 for query answering.</p><p>The proof is straightforward. Intuitively, the maximal-possible score of a tuple t defines what t can achieve, with P already evaluated, by assuming unknown predicates are of perfect scores. (Since F is monotonic, this substitution will result in its upper bound.) Therefore when F P [t1] &gt; F P [t2], whatever score t2 can achieve, t1 can possibly do even better. Refer to Figure <ref type="figure" target="#fig_0">1</ref>, the subsequent operation "B" cannot process only t2 but not t1. Therefore it is desirable that "B" draws outputs from "A" in this order, i.e., t1 should precede t2. By this ranking principle, Definition 1 formalizes rankrelations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Rank-Relation):</head><p>A rank-relation RP <ref type="foot" target="#foot_1">4</ref> , with respect to relation R and monotonic scoring function F(p1, . . . , pn), for P ⊆ {p1, . . . , pn}, is the relation R augmented with the following ranking induced by P.  Note that, when there are ties in scores, an arbitrary deterministic "tie-breaker" function can be used to determine an order, e.g., by unique tuple IDs.</p><formula xml:id="formula_6">(d) R {p 1 } (e) R {p 2 } (f) S {p 3 }</formula><p>The extended rank-relational algebra generally operates on rankrelations. Thus, base relations, intermediate relations, and the results are all rank-relations. That is, rank-relations are closed under the algebra operators, which Section 3.2 will define, since all operators will account for the new ranking property (in addition to "membership"). Note that a base or intermediate relation, when no predicates are evaluated (P = φ), is consistently denoted R φ or simply R. On the other hand, when P = {p1, . . . , pn}, the partial score is effectively complete, resulting in the final ranking with respect to F.</p><p>Example 2: As our running example, Figure <ref type="figure" target="#fig_2">2</ref>(a)-(c) show three base relations, R, R , and S (i.e., R φ , R φ , S φ ), with their schemas, tuple IDs, and ranking predicate scores. Note that tuple IDs and predicate values are shown for pedagogical purpose only. (These predicate values are unknown until evaluated.) For our discussion, as we will illustrate various operators, we assume R and R have the same schema (e.g., to be unioned later) and predicates. S is used later to show join operator. Suppose the scoring function for R and R is F1 = (p1, p2), and for S is F2 = (p3, p4, p5). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Operators</head><p>We next extend the relational-algebra operators for manipulating rank-relations. Recall that, by Definition 1, a rank-relation RP essentially possesses two logical properties-1) membership as defined by the relation R, and 2) order induced by predicates P (with respect to some scoring function F). For manipulating these two properties, we extend relational algebra by adding a new rank operator µ and generalizing the existing operators to be "rankaware". Figure <ref type="figure" target="#fig_4">3</ref> summarizes the definitions of these operators, and Figure <ref type="figure" target="#fig_6">4</ref> illustrates them with examples (as continued from Example 2), which we explain below in more details.</p><p>New Operator µ: For supporting ranking as a first-class construct, we propose to add a new operator, rank or µ. As Section 2.2 motivated, our goal is to satisfy the two requirements: splitting and interleaving. Essentially, we must be able to evaluate ranking predicates (pi's in F) one at a time-thus ranking is effectively split and can be interleaved with other operations.</p><p>The new rank operator (µ) is thus a critical basis of our algebra. As Figure <ref type="figure" target="#fig_4">3</ref> defines, µp(RP ) evaluates an additional predicate p upon rank-relation RP , ordered by evaluated predicate set P as Definition 1 states, and produces a new order by P ∪ {p}-That is,</p><formula xml:id="formula_7">Rank : µ, with a ranking predicate p • t ∈ µ p (R P ) iff t ∈ R P • t 1 &lt; µp(RP ) t 2 iffF P∪{p} [t 1 ] &lt; F P∪{p} [t 2 ] Selection: σ, with a boolean condition c • t ∈ σ c (R P ) iff t ∈ R P and t satisfies c • t 1 &lt; σc(RP ) t 2 iff t 1 &lt; RP t 2 , i.e., F P [t 1 ] &lt; F P [t 2 ] Union: ∪ • t ∈ R P1 ∪ S P2 iff t ∈ R P1 or t ∈ S P2 • t 1 &lt; RP 1 ∪SP 2 t 2 iff F P1 ∪P2 [t 1 ] &lt; F P1 ∪P2 [t 2 ] Intersection: ∩ • t ∈ R P1 ∩ S P2 iff t ∈ R P1 and t ∈ S P2 • t 1 &lt; RP 1 ∩SP 2 t 2 iff F P1 ∪P2 [t 1 ] &lt; F P1 ∪P2 [t 2 ] Difference: - • t ∈ R P1 -S P2 iff t ∈ R P1 and t ∈ S P2 • t 1 &lt; RP 1 -SP 2 t 2 iff t 1 &lt; RP 1 t 2 , i.e., F P1 [t 1 ] &lt; F P1 [t 2 ]</formula><p>Join: , with a join condition c Extended Operators π, σ, ∪, ∩, -, : We extend the original semantics of existing operators with rank-awareness, and thus enable the interaction between the new µ and traditional Boolean operations. As we will see, in the extended algebra, the operations will now be aware of and compute on dual logical properties-both membership (by Boolean predicate) and order (by ranking predicate). (Note that we omit projection π in Figure <ref type="figure" target="#fig_4">3</ref>, since it is obvious. We also omit the discussion on Cartesian-product since it is similar to join.)</p><formula xml:id="formula_8">• t ∈ R P1 c S P2 iff t ∈ R P1 × S P2 and satisfies c • t 1 &lt; RP 1 cSP 2 t 2 iff F P1 ∪P2 [t 1 ] &lt; F P1 ∪P2 [t 2 ]</formula><p>To begin with, unary operators such as selection (and π not shown in Figure <ref type="figure" target="#fig_4">3</ref>) process the tuples in the input rank-relation as in their original semantics, and simply maintains the same order as the input. Thus, in our notation, σc(RP ) ≡ (σcR)P . That is, the selection with c on RP manipulates only the membership of R, by applying c, and maintains the same order as induced by P. An example is shown in Figure <ref type="figure" target="#fig_9">4(b)</ref>.</p><p>Further, most binary operators, such as union (∪), intersection (∩), and join ( ), perform their normal Boolean operations, and at the same time output tuples in the "aggregate" order of the operands-Such aggregate order is induced by all the evaluated predicates from both operands. Thus, for instance, Finally, difference (-) outputs tuples in the order of the outer input operand-since the other is effectively discarded. Thus, RP 1 -SP 2 ≡ (R -S)P 1 . An example is shown in Figure <ref type="figure" target="#fig_6">4</ref>(e).</p><formula xml:id="formula_9">RP 1 ∩ SP 2 ≡ (R ∩ S) {P 1 ∪P 2 } ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Algebraic Laws</head><p>Query optimizers essentially rely on algebraic equivalences to enumerate or transform query plans in search of efficient ones. In the extended rank-relational model and algebra, as the dual logical properties dictate, algebraic equivalences should result in not only the same membership but also the same order. By definition of our algebra, as just discussed, we can assert many algebraic equivalence laws. As we extended the algebra specifically to support ranking, Figure <ref type="figure" target="#fig_7">5</ref> gives several such equivalences relevant to ranking. Essentially, these laws concretely state the new freedom of splitting and interleaving, thus achieving our motivating requirements (Section 2.2)-That is, the rank-relational algebra indeed supports ranking as first-class, in parallel with Boolean filtering. These laws are directly from the definition of the algebra, therefore to save space, we leave the proof to the extended version of this paper and only briefly discuss their usage in query optimization.</p><formula xml:id="formula_10">TID a b F 1{p 1 ,p2} r 1 1 2 1.55 r 3 3 4 1.4 r 2 2 3 1.3 TID a b F 1{p 1 } r 2 2 3 1.8 r 3 3 4 1.7 (a) µp 2 (R {p 1 } ) (b) σa&gt;1(R {p 1 } ) TID a b F1 {p1,p2} r1/r 1 1 2 1.55 r3/r 2 3 4 1.4 TID a b F1 {p1,p2} r1/r 1 1 2 1.55 r3/r 2 3 4 1.4 r 3 5 1 1.35 r2 2 3 1.3 (c) R {p 1 } ∩ R {p 2 } (d) R {p 1 } ∪ R {p 2 } TID a b F 1{p 1 } r 2 2 3 1.8 TID R TID S a b c F 3{p 1,p3 } r 1 s 2 1 2 1 4.8 r 1 s 3 1 2 2 4.4 (e) R {p 1 } -R {p 2 } (f) R {p 1 } θ S {p 3 } , where θ is R {p 1 } .a = S {p 3 } .a, F3 = (p1, p2, p3, p4, p5).</formula><p>In particular, we explain the laws specifically centering around our two requirements: First, rank splitting: Proposition 1 allows us to split a scoring function with several predicates (p1, ..., pn) into a series of rank operations (µ1, ..., µn). This splitting is useful for processing the predicates individually-Our splitting requirement is thus satisfied.</p><p>Second, interleaving: Propositions 4 and 5 together assert that rank operations can swap with other operators, thus achieving the interleaving requirement. In particular, Proposition 4 deals with swapping µ with other unary operators (µ or σ)-thus, we can schedule µ freely with σ. Further, Proposition 5 handles swapping with binary operators-we can thus push down µ across , ∩, and others.</p><p>The new algebraic laws lay the foundation for query optimization of ranking queries as algebraic equivalences define equivalent plans in the search space of query optimizers. As we will see in Section 5, these algebraic laws guide the designing of transformation rules in rule-based optimizers, as well as the plan enumeration and heuristics in bottom-up optimizers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">RANKING QUERY PLANS: EXECUTION MODEL AND PHYSICAL OPERATORS</head><p>In common database query engines, a query execution plan is a tree of physical operators as iterators, which have three interface methods that allow the consumer operator of a physical operator to fetch one result tuple at a time. The three basic interface methods are: (1) Open method that initializes the operator and prepares its internal state; (2) GetNext method that reports the next result upon each request; (3) Close method that terminates the operator and performs the necessary cleanup. During the execution, query results are drawn from the root operator, which draws tuples from Proposition 1 : Splitting law for µ • R {p1,p2,...,pn} ≡ µ p1 (µ p2 (...(µ pn (R))...))</p><formula xml:id="formula_11">Proposition 2 : Commutative law for binary operator • R P1 ΘS P2 ≡ S P2 ΘR P1 , ∀Θ ∈ {∩, ∪, c } Proposition 3 : Associative law • (R P1 ΘS P2 )ΘT P3 ≡ R P1 Θ(S P2 ΘT P3 ), ∀Θ ∈ {∩, ∪, c a } Proposition 4 : Commutative laws for µ • µ p1 (µ p2 (R P )) ≡ µ p2 (µ p1 (R P )) • σ c (µ p (R P )) ≡ µ p (σ c (R P ))</formula><p>Proposition 5 : Pushing µ over binary operators</p><formula xml:id="formula_12">• µ p (R P1 c S P2 ) ≡ µ p (R P1 ) c S P2 , if only R has attributes in p ≡ µ p (R P1 ) c µ p (S P2 ), if both R and S have • µ p (R P1 ∪ S P2 ) ≡ µ p (R P1 ) ∪ µ p (S P2 ) ≡ µ p (R P1 ) ∪ S P2 • µ p (R P1 ∩ S P2 ) ≡ µ p (R P1 ) ∩ µ p (S P2 ) ≡ µ p (R P1 ) ∩ S P2 • µ p (R P1 -S P2 ) ≡ µ p (R P1 ) -S P2 ≡ µ p (R P1 ) -µ p (S P2 ) Proposition 6 : Multiple-scan of µ • µ p1 (µ p2 (R φ )) ≡ µ p1 (R φ ) ∩ r µ p2 (R φ )</formula><p>a When join columns are available. underlying operators recursively, till the scan operators. This provides an efficient pipelining evaluation strategy, unless the flow of tuples is stopped by a blocking operator such as sort or a blocking join implementation, in which case, intermediate results have to be materialized.</p><p>The nature of ranking query lends itself to pipelined and incremental plan execution. We desire that the small number k not only reduces the size of results presented to users, but also allows less work to be done, i.e., we want the execution cost to be proportional to k. In interactive applications, k may be only an estimate of the desired result size or not even specified beforehand. Hence, it is essentially desirable to support incremental processing-for returning top results progressively upon user requests.</p><p>Unfortunately traditional implementation of ranking by sticking a sorting operation on top of the execution plan is an overkill solution to the problem and can be prohibitively expensive. Such materialize-then-sort scheme is undesirably blocking, as the first result is reported after all results (much more than k in general) are produced and sorted. The cost is independent from k and the startup cost is almost equal to the total cost.</p><p>Fortunately rank-relational algebra both advocates and enables non-blocking plans. In this section, we show how ranking query plans, consisting of the new and extended operators, execute according to the ranking principle (Property 1) in Section 4.1 and present their physical implementations in Section 4.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Incremental Execution Model</head><p>To realize the rank-relational algebra, we extend the common execution model to handle ranking query plans, with two differences from traditional plans. First, operators incrementally output rank-relations RP (Definition 1), i.e., tuple streams pass through operators in the order of maximal-possible scores (upper-bounds) F P [t] with respect to the associated ranking predicate set P. As the ranking principle indicates, it is desirable that t1 precedes t2 in further processing if</p><formula xml:id="formula_13">F P [t1] &gt; FP [t2].</formula><p>Second, the query has an explicitly requested result size, k. The execution stops when k results are reported or no more results are available.</p><p>For an operator to output its intermediate result as a rank-relation, as Definition 1 requires, the output must be in the order by the associated predicate set. That is, a tuple can be output to the upper operator if its upper-bound score is guaranteed to be higher than that of all future output tuples. Therefore the key capability of a rank-aware operator is to decide if enough information has been obtained from its input tuples in order to incrementally produce the next ranked output tuple.</p><p>To illustrate, consider a µp operator upon the input RP as the result of its preceding operator x. In order to produce outputs in the correct order by P∪{p}, µp cannot immediately output a tuple t once t is obtained from x, because there may exist some t such that</p><formula xml:id="formula_14">F P∪{p} [t] &lt; F P∪{p} [t ], although FP [t] ≥ F P [t ]</formula><p>(therefore t has not been "drawn" from x yet). Instead, µp has to evaluate p[t] to get F P∪{p} [t] and to buffer t in a ranking queue (implemented as priority queue) that maintains tuples in the order by P∪{p}. At any time, the top tuple t in the queue can be output when a t is drawn from Select * From S Order By p3 + p4 + p5 Limit 1. Figure <ref type="figure" target="#fig_8">6</ref> illustrates three equivalent plans. Plan (a) is a traditional plan consisting of a sorting and a sequential scan operator. It scans tuples from S, evaluates all predicates (p3,p4,p5) for each tuple, buffers and sorts them based on their scores till all tuples are scanned. Plan (b) is a new plan enabled by the rank-relational algebra, with an index scan followed by two µ operators. The index scan accesses tuples in the order of p3 values, where p3 can be as simple as attribute or as complex as external or built-in function. (Such index is supported in DBMS's such as PostgreSQL.)</p><formula xml:id="formula_15">x such that F P∪{p} [t] ≥ FP [t ], thus F P∪{p} [t] ≥ FP [t ] ≥ F P [t ]</formula><p>In these plans, the rank-relation R above each operator op contains the tuples that have ever been processed by op. The portion of R in gray color is the incremental output rank-relation from op to its upper operator op , thus is the incremental input rank-relation to op . Therefore the rank-relation R above op contains the same tuples as the gray portion of R, although may in different order, since op can apply one more predicate and thus result in a new order.</p><p>For example, consider µp 4 in plan (b). It processed 3 tuples (s2,s1,s3) during execution. Among them, s2 and s1 were drawn to µp 5 , which processed 2 tuples (s2 and s1) and output s2 as the top-1 answer since µp 5 is the top operator in the plan tree.</p><p>Note that the order of tuples in the rank-relations are decided by semantics, according to the definition of rank-relation (Definition 1) and operators (Section 3.2). For example, µp 4 must output tuples in the order by F2 {p 3 ,p 4 } since p3 is accessed by the underlying operator idxScanp 3 (S) and p4 is evaluated by µp 4 . Therefore s2 must precede s1 when output from µp 4 since</p><formula xml:id="formula_16">F2 {p 3 ,p 4 } [s2] = 2.75 &gt; F 2 {p 3 ,p 4 } [s1] = 2.5.</formula><p>We further illustrate how tuples flow, still using plan (b) as an example. The operator µp 5 first draws s2 from µp 4 , then evaluates p5 [s2] and gets F2 {p 3 ,p 4 ,p 5 } [s2] = 2.55. At this point µp 5 cannot output s2 yet (refer to our explanation in the paragraph right above Example 3). Therefore µp 5 buffers s2 in its ranking  Binary operators such as join work in the same principle as µ, except that they obtain inputs from two streams, combine the scores from the two inputs to get updated upper-bound scores for seen and unseen output tuples. Illustrated by the previous example, the execution model indicates that rank-aware operators are selective, i.e., they reduce the cardinality of intermediate results as they do not output all of their processed tuples. For instance, the selectivity of µp 4 in Figure <ref type="figure" target="#fig_8">6</ref>(b) is 2/3 as the rank-relation above it clearly shows.</p><p>In contrast to traditional operators, the selectivity of rank-aware operators is context-sensitive. The reason is, selectivities of rankaware operators are dependent on k, and furthermore, cannot be assumed to be independent from their locations in a whole plan, as assumed for selection and join selectivities traditionally. For instance, plan (c) in Figure <ref type="figure" target="#fig_8">6</ref> is similar to plan (b) except that the order of µp 4 and µp 5 is reversed. The selectivities of µp 4 , µp 5 , and idxScanp3(S) in this plan are 1/3, 3/5, and 5/6 respectively, while they are 2/3, 1/2, and 3/6 in plan (b) (remember there are 6 tuples in S).</p><p>Being selective enables operators to both reduce the evaluation of predicates that have various costs and reduce the cost of join, therefore ranking query plans do not need to materialize a query, in contrast to the traditional materialize-then-sort scheme of processing ranking queries. This makes ranking query plans much more efficient than traditional ones, which can be prohibitively expensive. Moreover, different scheduling and interleaving of rankaware operators will result in different number of tuples being processed, therefore query optimizers have to non-trivially explore the new type of ranking plans (Section 5). Furthermore, the contextsensitiveness of selectivities indicate that cardinality estimation of these ranking plans will be challenging (Section 5.2). Assume the costs of predicates p3, p4, and p5 are C3, C4, and C5, then the predicate evaluation cost of plan (a) is 6(C3 + C4 + C5) since it has to evaluate all predicates for every tuples. It also needs to scan 6 tuples. (If there are more tuples in S, it has to scan all of them.) In plan (b), µp 5 evaluates p5 over two tuples (s2, s1) and µp 4 evaluates p4 over three tuples (s2, s1, s3). Therefore the predicate evaluation cost of plan (b) is 3C4 + 2C5. It only needs to scan 3 tuples. The predicate evaluation cost of plan (c) is 3C4 + 5C5 and it needs to scan 5 tuples, according to similar analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementing Physical Operators</head><p>We must implement new physical operators in order to realize the execution model. Fortunately previous works on top-k queries in middleware and relational settings provide a good basis to leverage. Below we briefly discuss the implementation of operators.</p><p>The implementation of µ is straightforward from Example 3 and it is a special case (because it schedules one predicate) of the algorithms (MPro <ref type="bibr" target="#b4">[4]</ref>, Upper <ref type="bibr" target="#b2">[2]</ref>) for scheduling random object accesses in middleware top-k query evaluation. The implementation of C adopts the HRJN (hash rank-join) and NRJN(nested-loop rank-join) algorithms in <ref type="bibr" target="#b22">[22]</ref>  <ref type="bibr" target="#b23">[23]</ref>, which are built upon symmetrical hash join <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b30">30]</ref> or hash ripple join <ref type="bibr" target="#b17">[17]</ref>.</p><p>New algorithms for other operators are similarly implemented. Use ∩ under set semantics as an example. Traditionally it has to exhaust both input streams to ensure that no duplicate tuple is output. However, with the input streams being ranked, it can judge if duplicates of a tuple may have appeared or may be seen in the future according to the predicate values of that tuple. Therefore it can output ranked results incrementally.</p><p>As another example, scan must be provided as a physical operator although it is not in relational algebra. Index-scan can be used to access tuples of a table in the order of some predicate p when there exists an index such as B+tree on p. (Thus we name it rank-scan.) Such index can be available when p is some attribute, expression, or function, as all are supported in practical DBMS's such as Post-greSQL. Moreover, scan-based selection can be used to combine a scan operator on p with a selection operator on selection condition c when a multi-key index on p and c is available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">A GENERALIZED RANK-AWARE OPTI-MIZER</head><p>The task of cost-based query optimization is to transform a parsed input query into an efficient execution plan, which is passed to the query execution engine for evaluation. The transformation task is usually accomplished by examining a large search space of plans. The optimizer utilizes a plan enumeration algorithm that can efficiently search the plan space and prune plans according to their estimated execution costs. To estimate the cost of a plan, the optimizer adopts a cost model.</p><p>Extending relational algebra to support ranking as introduced in Section 3 and Section 4 has direct impact on query optimization. In this section, we motivate the need for extending the query optimizer to support ranking and study the significant challenges associated with the extension. Then we show how to incorporate ranking into practical query optimizers used by real-world database systems.</p><p>The rank-relational algebra enables an extended plan space with plans that cannot be expressed traditionally. For instance, for the query in Example 1, traditional optimizers only allow materializethen-sort plans such as the one in Figure <ref type="figure" target="#fig_11">7</ref>(a). In contrast, the rankrelational algebra enables equivalent plans such as the one in  form an idxScan. Such splitting and interleaving may achieve significant improvements in performance as discussed in Section 4.1.</p><p>In order to fully incorporate the rank-relational algebra into a cost-based query optimizer, we must address the impact of the extended search space on plan enumeration and costing. In plan enumeration, the desirability of splitting and interleaving ranking predicates requires the optimizer to fully explore the extended plan space for generating efficient query plans. In plan costing, cardinality estimation must be performed for the rank-aware operators for costing and pruning plans.</p><p>There are two categories of cost-based query optimizers used by real-world database systems, namely the top-down rule-based optimizers exemplified by Volcano <ref type="bibr" target="#b13">[13]</ref> and Cascade <ref type="bibr" target="#b12">[12]</ref>, and the System R-style bottom-up dynamic programming optimization framework <ref type="bibr" target="#b28">[28]</ref>.</p><p>In Volcano and Cascade, transformation and implementation rules are the two key constructs used for searching the plan space. The transformation rules transform between equivalent algebraic expressions, and the implementation rules map logical operators into physical implementations to realize a plan tree. For extending rulebased optimizers with the rank-relational algebra, the algebraic laws presented in Section 3.3 naturally enable the introduction of new transformation rules to enumerate ranking plans. Implementation rules can be devised to trigger the mapping of physical algorithms presented in Section 4.2. Cost estimation in top-down optimizers can apply similar techniques for extending bottom-up optimizers since it only costs complete plans instead of subplans.</p><p>Extending bottom-up optimizers to incorporate ranking, however, is more challenging as plans are constructed and pruned in bottom-up fashion without global information of a complete plan. Therefore focusing on bottom-up optimizers, we show how to extend the System-R style bottom-up dynamic programming (DP) approach for plan enumeration (Section 5.1) and how to cost and prune plans during enumeration (Section 5.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Two-Dimensional Plan Enumeration</head><p>We take a principled way to extend DP plan enumeration by treating ranking predicates as another dimension of enumeration in addition to Boolean predicates, based on the insight that the ranking (order) relationship is another logical property of data, parallel to membership (Section 2.1). Recall that, by Definition 1, a rankrelation RP essentially possesses two logical properties: Boolean membership (R) and ranking order (P). In a ranking query plan, new ranking predicates are only introduced in µ operators. Therefore the predicate set P of a subplan, i.e., the µ operators in a subplan, determines the order, just like how join conditions (together with other operations) determine the membership. Moreover, for the same logical algebra expression, the optimizer must be able to  produce various plans that schedule and interleave µ operators, and to select the most efficient plan, just like it must be able to select the best join order. This dimensional enumeration approach not only reflects the fact that order and membership are dual logical properties in the rank-relational model, but also takes advantages of the dynamic programming paradigm in reducing searching costs. Furthermore, the dimensional enumeration subsumes the conventional plan enumeration for join order selection and does not affect the optimization of non-ranking plans.</p><p>The concept of dimensional enumeration is general and extensible for naturally including more dimensions, e.g., ordering other operators such as selection, union, intersection, etc. For example, scheduling selection predicates is traditionally considered less important than join order selection and is rather handled by heuristics such as selection pushdown. Under the situation that it is necessary to handle such task, as motivated in <ref type="bibr">[9,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b8">8]</ref>, dimensional enumeration can incorporate the scheduling of both selection and ranking predicates by treating Boolean predicates as another dimension. Due to space limitations, we focus on how to integrate the scheduling of ranking predicates and join order selection and omit the consideration of other operators.</p><p>The DP 2-dimensional enumeration algorithm is shown in Figure <ref type="figure">8</ref>. For each subplan, we define its signature (SR, SP ) as the pair of two logical properties, the set of relations SR and the set of ranking predicates SP in the subplan. Subplans with the same signature result in the same rank-relation. The algorithm first enumerates the number of joined relations, ||SR||, then the number of ranking predicates, ||SP ||. Plans with the signature (SR, SP ) are generated by joining two plans with the signature (SR 1 , SP 1 ) and (SR 2 , SP 2 ) (joinPlan), adding a µp upon a plan with the signature (SR, SP -{p}) (rankPlan), or using a scan operator (scanPlan). Based on the principle of optimality, no sub-optimal subplan can be part of the optimal execution strategy, hence for all the plans with the same signature, only the best plan is kept.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5:</head><p>We illustrate how the algorithm optimizes a simple query over the tables in Figure <ref type="figure" target="#fig_2">2</ref>, Order By p1 + p3 + p4 Limit k. In Figure <ref type="figure" target="#fig_13">9</ref>, each row contains the best plans for signatures of the same size, with one best plan per signature. For instance, row (2, 1) show the best plans for ({R, S}, {p1}), ({R, S}, {p3}), and ({R, S}, {p4}) respectively. We also show the pruned plans (as crossed out) on single table, but omit that for joined relations due to space limitations.</p><p>The enumeration starts with signature size (1, 0) to find scan plans for signatures ({R}, φ) and ({S}, φ). Assume that seqScan is kept for both signatures; and idxScana(R) and idxScanc(S) are pruned. The enumeration continues with size (1, 1) to look for plans for ({R}, {p1}), ({S}, {p3}), and ({S}, {p4}). For example, plans for ({S}, {p3}) can be built by adding µp 3 on top of seqScan(S) or by using idxScanp 3 (S). By comparing their estimated costs, the former is pruned. The enumeration proceeds in this way until the final plan is generated.</p><p>One important detail of System-R algorithm is that multiple plans with the same logical properties may be kept if they have different physical properties. Example physical properties are interesting orders <ref type="bibr" target="#b28">[28]</ref> that are potentially beneficial to subsequent operations. For instance, idxScana can be kept since its sorted access on R.a can be useful for sort-merge join when R is joined with S. In the dimensional enumeration algorithm, the support of physical properties is not affected. It can keep multiple plans that have different physical properties for the same signature. Note that interesting order will only be possessed by plans with empty predicate set (i.e., SP = φ), since by definition rank-relations must be output in the order with respect to P, which is not the kind of order that is useful to operators such as sort-merge join.</p><p>The 2-dimensional enumeration algorithm is exponential in the number of the ranking predicates as well as the number of relations,  as the System-R style algorithm is exponential in the number of relations. As a common practice, query optimizers apply heuristics to reduce the search space. For example, a query optimizer can choose to consider only left-deep join trees and to avoid Cartesian products. Such heuristics are often found effective in improving efficiency and being able to find comparably good query plan.</p><p>Therefore, we propose a heuristic to reduce the space on the dimension of ranking predicates, as shown in Figure <ref type="figure" target="#fig_15">10</ref>. The algorithm in Figure <ref type="figure" target="#fig_15">10</ref> modifies that in Figure <ref type="figure">8</ref> by incorporating the left-deep join heuristic (Line 2) and our new heuristic on the ranking predicate dimension (Line 4). The ranking predicate scheduling heuristic greedily appends µ operators in a sequence instead of considering all valid permutations of µ operators. Given a subplan plan, suppose plan is to be built by adding one µ upon plan. The optimizer does not use µp u to build plan if there exists another applicable µp v such that appending µp v is (likely) better than appending µp u . The goodness of appending µp u upon plan, is based on its selectivity and cost, defined as rank(µp u ) =</p><formula xml:id="formula_17">1-card(plan )/card(plan) cost(µp u )</formula><p>, where cost(µp u ) is the evaluation cost of pu, and card(plan ) and card(plan) are the output cardinalities of plan and plan. (This rank should not be confused with the concept of rank in our algebra.) Therefore µp u is appended upon plan only if there exists no other applicable µp v that has a higher rank. Intuitively the rank of a µ is higher if its cost is lower and its selectivity is smaller, i.e., its power of reducing cardinality is higher. In the formula, cost(µp u ) is one component of the cost model of µp u that should be defined together with its implementation. Techniques for estimating the cardinality of a subplan is presented in Section 5.2.</p><p>The above greedy scheduling heuristic for ranking predicates is inspired by the rank metric in <ref type="bibr" target="#b18">[18]</ref> for scheduling independent selection predicates and the adaptive approach in <ref type="bibr" target="#b1">[1]</ref> for ordering correlated filters in streaming data processing. The rank metric in <ref type="bibr" target="#b18">[18]</ref> guarantees an optimal fixed order of independent selection predicates, that is, a selection predicate should always be applied before another one if it has higher rank. However, the same property cannot be guaranteed for scheduling µ operators simply because of their context-sensitive selectivities (Section 4.1). We adopt rank metric as a heuristic, just like applying left-deep join heuristic, which sacrifices optimality for efficiency as a common practice of query optimizers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Costing Ranking Query Plans</head><p>The optimizer prunes plans according to their estimated execution costs based on a cost model. The cost model for various operators in real-world query optimizers is quite complex and depends on many parameters, including cardinality of inputs, available buffers, type of access paths and many other system parameters. Although cost model can be very complex, a key ingredient of its accuracy is cardinality estimation of intermediate results.</p><p>Cardinality estimation for ranking query plans is much more difficult than that for traditional ones because cardinality information cannot be propagated in a bottom-up way. In conventional query plans, the input cardinality of an operator is independent from the operator itself and depends only on the input subplans. The output cardinality depends only on the size of inputs and the selectivity of the logical operation. In ranking query plans, however, an operator consumes only partial input, therefore the actual input size depends on the operator itself and how the operator decides that it has obtained "enough" information from the inputs to generate "enough" outputs. Hence, the input cardinality depends on the number of results requested from that operator, which is unknown for a subplan during plan enumeration. Note that the number of final results, k, is known only for a complete plan. This imposes a big challenge to System-R style optimizers that build subplans in bottom-up fashion, because the propagation of k value to a specific subplan depends on the location of that subplan in the complete plan.</p><p>To address this challenge, we propose a sampling-based cardinality estimation method for rank-aware operators. Let x be the score of the k-th query result tuple. Our technique is based on the intuition that tuples whose upper-bound scores are lower than x do not need to be output from an operator. Although x is unknown during plan enumeration, the sampling method can be used to estimate x, and to further estimate the output cardinality of a subplan.</p><p>The optimizer randomly samples a small number of tuples from each table and evaluates all the predicates over each tuple. Note that this step is not necessarily performed every time since it is possible to re-use the predicate values for succeeding queries. To estimate x, before plan enumeration, the optimizer evaluates the original query on the sample using any conventional execution plan, to retrieve k top results proportional to the sample size. Suppose the sampling ratio is s%, i.e., each tables ti with original size Ni has a sample size ni = Ni × s%, then k = k × s% . That is, it transforms a top-k query on the database into a top-k query on the samples. The score of the k th topmost answer, x , is used as an estimation of x, based on the intuition that k is proportional to the sample size with respect to k over the database size.</p><p>With x , during plan enumeration, the optimizer estimates the output cardinality of a subplan P , card(P ), by executing P on the small samples. The results are kept together with P so that there is no need to execute P again when estimating the output cardinality of a future plan that is built based on P . Suppose P outputs u answers that have upper-bound scores above x . Then card(P ) is estimated in the following way:</p><p>• card(P ) = u/(s%): if P has only one operator, i.e., a scan operator on a base table.</p><p>• card(P ) = u×card(P )/cards(P ): if the top operator of P is a unary operator, on top of a subplan P , which has output cardinality cards(P ) during the execution of P on the sample and an estimated output cardinality card(P ) during previous steps of plan enumeration.</p><p>• card(P ) = u × card(P 1 ) cards(P 1 ) + card(P 2 ) cards (P 2 )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>: if the top operator of P is a binary operator, taking inputs from two subplans P1 and P2. P1 and P2 have output cardinality cards(P1) and cards(P2), respectively, during the execution of P on the sample; and estimated output cardinalities card(P1) and card(P2), respectively, during previous steps of plan enumeration.</p><p>Our experimental study (Section 6) shows that the simple sampling method with a small sample ratio (e.g., 0.1%) gives accurate cardinality estimates. With small sample size, sampling method does not introduce much overhead to query optimization.</p><p>Accurate random sampling over joins has been known to be difficult <ref type="bibr" target="#b7">[7]</ref>. We plan to investigate the possibilities of using techniques such as <ref type="bibr" target="#b7">[7]</ref> in future work to improve our sampling method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXPERIMENTS</head><p>We build a prototype of the RankSQL system in PostgreSQL 7.4.3. We extend the internal representation of tuples to include the implicit ranking score attribute in rank-relational model and implement the rank operator, the rank-aware join, and the rank-scan operators. In this section, we present two sets of experiments that we conducted on the system. The first set compares different execution plans to demonstrate the performance diversity of the plan space, thus motivates the need of query optimization. It also illustrates that under general circumstances, the performance of plans that are only possible in the extended plan space of the new algebra is superior to traditional plan for evaluating top-k queries. The second set of experiments verifies the accuracy of the sampling-based method for estimating the cardinalities of rank-aware operators.</p><p>The experiments are conducted on a PC having a 1.7GHz Pentium-4 CPU with 256KB cache, 768MB RAM, and 30GB disk, running Linux 2.4.20 operating system. The shared buffers (shared memory buffer size) and sort mem (internal memory for sorting and hashing) settings in PostgreSQL are configured as 24MB and 20MB, respectively. We use a synthetic data set of three database tables (A, B, C) having the same size and schema. Table <ref type="table">A</ref> and B each have one Boolean attribute with 0.4 as their selectivities. The three tables have 2, 2, and 1 ranking predicates, respectively. The ranking predicates have the same cost. They are implemented as user-defined functions, taking attributes of the tables as parameters. Scores of different ranking predicates are within the range between 0 and 1 and are independently generated by different distributions, including uniform, normal (with mean 0.5 and variance 0.16), and cosine distributions. Each table has two attributes jc1 and jc2 as join columns.</p><p>We use a simple top-k query Q as shown below in PostgreSQL syntax. Summation is used as the scoring function F. Figure <ref type="figure" target="#fig_17">11</ref> illustrates four execution plans for the above query. P lan1 is a conventional materialize-then-sort plan, in which filter is the physical selection operator and sort-merge join is used as the physical join operator. P lan2 -4 are new ranking query plans. The implementations of µ operator (rank), rank-aware join operator (HRJN), and rank-scan operator (idxScan) were described in Section 4.2. In plan2, rank-scans are used for accessing base tables and µ is scheduled before join. P lan3 uses sequential scan instead of rank-scan. P lan4 applies µ operators above normal sort-merge join to replace one of the HRJN operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Cost of Ranking Execution Plans</head><p>In this suite of experiments, we show that the costs of execution plans for top-k queries vary with respect to (among other factors) the number of final results (k, from 1 to 1, 000), the number of tuples in each table (s, from 10, 000 to 1, 000, 000), the join selectivity (j, from 0.001 to 0.00001, i.e., the number of distinct values of each join attribute ranges from 1, 000 to 100, 000), and the cost of each ranking predicate (c, from 0 to 1, 000 unit costs).</p><p>We performed 4 groups of experiments. The default values of the parameters are k = 10, s = 100, 000, j = 0.0001, and c = 1. In each group, we vary the value of one parameter and fix the values of the other three parameters. We then execute each plan under these parameter settings and measure their execution time. The results are shown in Figure <ref type="figure" target="#fig_10">12</ref>. (Note that both x and y axes are in logarithmic scale.)</p><p>The figures illustrate that none of the plans is always the best under all situations. Moreover, different plans can have orders of magnitude differences in their costs. The diversity of plan costs verifies the need of query optimization in choosing efficient plans. Apparently, the traditional plan (plan1 in Figure <ref type="figure" target="#fig_17">11</ref>) is far outperformed by rank-aware plans (plan2 -4 in Figure <ref type="figure" target="#fig_17">11</ref>). Its performance is only comparable to other plans when the size of tables and requested results are small, when joins are very selective, and when predicates are cheap. In many situations, the traditional plan becomes prohibitively expensive.</p><p>Specifically, Figure <ref type="figure" target="#fig_10">12</ref>(a) shows that the traditional plan for ranking queries is blocking, while the new rank-aware plans are incremental. Figure <ref type="figure" target="#fig_10">12</ref>(b) illustrates that the cost difference between plans increases (shown as parallel lines in logarithmic scale) together with the cost of predicates. This is because the predicate cost will dominate the plan execution cost while getting larger and the number of predicate evaluations does not change for a given plan when only predicate cost is changing. Figure <ref type="figure" target="#fig_10">12(c)</ref> shows that the traditional plan is efficient when joins are very selective (thus performing join first will result in very small intermediate results, upon which ranking predicates are evaluated). Finally, Figure <ref type="figure" target="#fig_10">12(d)</ref> shows that some ranking query plans (e.g., plan2) are very efficient even with very large tables, while some others are not. For instance, plan4 was relatively acceptable in other situations, but became much less efficient than plan2 and plan3 when each table has 1 million tuples. Note that we remove plan1 from Figure <ref type="figure" target="#fig_17">11(d)</ref> since it takes days to finish and is well off the scale.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Cardinality Estimation</head><p>To evaluate the accuracy of the sampling-based cardinality estimation method, we compare the original and estimated output cardinalities of each operator in a given execution plan except the top operator and selection operators, which do not need estimation. The output cardinality of the top operator, k, is given by the query. The output cardinality of selection operator can be estimated by the estimated output cardinality of its input operator and its selectivity, that is often obtained from database statistics. For example, plan3 has 10 operators in total, among them the output cardinalities of 7 operators are estimated, since we do not estimate for the 2 selection operators and the root operator. Similarly plan2 and plan4 have the estimated cardinalities for 6 and 8 operators, respectively. The experiment is based on a sample database with 0.1% sample ratio. Each of the original tables contains 100, 000 tuples and the join selectivity for the original tables is 0.0001. The number k is set to 10 (thus k is 1). Figure <ref type="figure" target="#fig_20">13</ref> illustrates the estimation results of plan3 and plan4. The result of plan2 is very similar to that of plan3 therefore we do not include it. As we can see from the figure, although we used a very small sample, the real and estimated output cardinalities of majority of the operators are in the same magnitude, validating the estimation method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>In this paper we introduce a systematic and principled framework, by extending relational algebra and query optimizers, to support ranking as first-class construct in relational database systems. We believe that our proposed framework is the first piece of work to fully integrate ranking in database systems on both the logical algebra level and the physical implementation level. Previously top-k query processing is studied in the middleware scenario or in RDBMS in a "piecemeal" fashion, i.e., focusing on specific operator or sitting outside the core of query engines. In contrast, our framework provides principled algebra foundation and is not limited to a specific operation, thus allows for both expressing and optimizing general top-k queries. In the following, we highlight some of the recent effort in rank processing and other related work.</p><p>In middleware settings, various algorithms are proposed for rank aggregation on a set of objects, by merging multiple ranked lists <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b11">11]</ref>, or scheduling random accesses efficiently <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b4">4]</ref>, with the goal of minimizing number of accesses to objects. Although in a different setting, the works in <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b2">2]</ref> explore the concept of upperbound scores that inspires us to formalize our ranking principle for relational top-k queries. A similar sampling approach was applied in <ref type="bibr" target="#b4">[4]</ref> to schedule predicates only, whereas we extend the approach  In RDBMS, there have been several proposals to support answering top-k queries at application level or outside the core of query engines <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b31">31]</ref>, or for supporting special types of ranking queries <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b21">21]</ref>. Recently, supporting top-k queries inside the relational query engine, in terms of physical query operators, has been proved to be an efficient approach that treats ranking as a basic database functionality <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b23">23]</ref>. A stop operator is proposed in <ref type="bibr" target="#b3">[3]</ref> to limit the cardinality of intermediate and query result, either conservatively by integrity constraints or aggressively with the risk of restarting the query plan. The order supported by the stop operator is from columns of relations in SQL queries. Aggregation of multiple ranking criteria is not considered.</p><p>In <ref type="bibr" target="#b22">[22]</ref> a new operator is devised for supporting rank join query, where rank join predicates coexist with Boolean join predicates. Instead of conducting normal join algorithms on Boolean join predicates, the rank-join operator progressively produces the join results. In <ref type="bibr" target="#b23">[23]</ref> the relational query optimizer is further extended to utilize the rank-join operator in generating efficient query plans. We complement their work and together provide a systematic support of relational ranking queries, as we use rank-join as one of the rankaware operators and at the same time supply an algebraic foundation of such support. Our dimensional enumeration framework enumerates plans by two dual logical properties to handle both scheduling of rank operators and join order selection, while <ref type="bibr" target="#b23">[23]</ref> extends the "interesting order" (physical property) concept to deal with join enumeration only. The "interesting order" was also extended to support optimizing queries with expensive Boolean predicates <ref type="bibr" target="#b8">[8]</ref>. The concept of our dimensional enumeration is general and extensible for more dimensions, including scheduling such Boolean predicates, union, and intersection operators.</p><p>With respect to the approach of extending query algebra, <ref type="bibr" target="#b24">[24]</ref> proposes an algebra for capturing the semantic of preference queries. In <ref type="bibr" target="#b27">[27]</ref> an algebra is proposed for expressing complex queries over Web relations that are used to model Web repositories. The algebra extension focuses on capturing the semantic of application-specific ranking and order relationships over Web pages and hyperlinks, instead of enabling efficient query processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>We introduced our RankSQL system for full support of ranking as a first-class operation in real-world database systems. As the foundation of our work, we present the key insight that ranking is another logical property of data, parallel to the "membership" property. Centering around this insight, we first introduced a novel and general framework for supporting ranking in relational query engines based on extending the relational algebra. The extended rank-relational algebra captures the ranking property with rank-relational model and introduces new and extended operators to fully express top-k queries. We also defined a set of algebraic laws that allowed for rewriting, hence optimizing, top-k queries. Second, we presented a pipelined and incremental execution model of ranking query plans, by realizing the fundamental ranking principle in the extended algebra, thus enabling efficient processing of ranking queries. Third, based on the insight of the duality between ranking and membership properties, we introduced a generalized rank-aware optimization framework that defines ranking as an additional plan enumeration dimension beyond enumerating joins and allowed for generating the full space of rank-aware query evaluation plans. For practical purposes, we introduced heuristics that limit the generated space. Moreover, we introduced a novel technique for estimating the cardinality of top-k operations, hence, providing an effective plan pruning mechanism to get efficient ranking query plans. We presented the experimental results on our initial implementation of the RankSQL system.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1</head><label>1</label><figDesc>conceptually illustrates the query tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Ranking of intermediate relations.</figDesc><graphic coords="3,385.68,53.75,99.18,82.33" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Examples of rank-relations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 2(d)-(f) show three rank-relations, R {p 1 } , R {p 2 } , S {p 3 } , with tuples ranked by maximal-possible scores.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Operators defined in the algebra. by definition, µp(RP ) = R P∪{p} . For instance, when µp 2 operates on R {p 1 } in Figure 2(d), the result rank-relation is shown in Figure 4(a), which equals R {p 1 ,p 2 } . Note that R {p 1 ,p 2 } is already the final result for ranking R with F1 because F1 = (p1, p2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>which similarly holds for ∪ and . Examples are shown in Figure 4(c), (d), and (f).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Results of operators.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Some algebraic equivalence laws.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Ranking query plans vs. traditional plan. queue and draws the next tuple, s1, from µp 4 . It is sure at this point that µp 5 can output s2 as the top answer (again, refer to the paragraph above Example 3). After evaluating p5 [s1] and getting F 2 {p 3 ,p 4 ,p 5 } [s1] = 2.4, s1 is buffered. The execution goes on in this way to get more query results. Other operators in plan (b) work in the same way and the whole plan tree is executed in pipeline by recursively drawing tuples, resulting in the diagram in Figure 6(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Example 4 :</head><label>4</label><figDesc>Continuing Example 3, this example shows that ranking query plans (Figure 6(b)(c)) outperform traditional plans (Figure 6(a)) and different ranking plans have different costs, thus it calls for query optimization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>1 idxScanarea</head><label>1</label><figDesc>Figure 7(b). The equivalence is guaranteed by the algebraic laws in Figure 5. First, the ranking function in the sort operator is split into µp 1 , µp 2 , µp 3 by Definition 1 and Proposition 1 of Figure 5. The µ operators are pushed down across join operators by Proposition 4 and 5. Note that µp 1 is combined with scan operation toσc</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Two alternative plans for Example 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 : 2 -</head><label>82</label><figDesc>Figure 8: 2-Dimension Enumeration Algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Plan Enumeration. Select * From R, S Where R.a = S.a Order By p1 + p3 + p4 Limit k.In Figure9, each row contains the best plans for signatures of the same size, with one best plan per signature. For instance, row (2, 1) show the best plans for ({R, S}, {p1}), ({R, S}, {p3}), and ({R, S}, {p4}) respectively. We also show the pruned plans (as crossed out) on single table, but omit that for joined relations due to space limitations.The enumeration starts with signature size (1, 0) to find scan plans for signatures ({R}, φ) and ({S}, φ). Assume that seqScan is kept for both signatures; and idxScana(R) and idxScanc(S) are pruned. The enumeration continues with size (1, 1) to look for plans for ({R}, {p1}), ({S}, {p3}), and ({S}, {p4}). For example, plans for ({S}, {p3}) can be built by adding µp 3 on top of seqScan(S) or by using idxScanp 3 (S). By comparing their estimated costs, the former is pruned. The enumeration proceeds in this way until the final plan is generated.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Procedure 2 4 :</head><label>24</label><figDesc>Dimension Enumeration with Heuristics 1: replace line 4 of Figure 8 with the following 2: for each pair S R1 , S R 2 s.t. S R = S R1 ∪S R 2 , ||S R2 || ≤ 1, S R 1 ∩S R2 = φ do 3: insert the following into Figure 8, between line 10 and 11 5: if ||S R2 || = 0, S P 2 = {pu} and ∃pv s.t. pv ∈ P -S P and rank(µp v ) &gt; rank(µp u ) then 6: continue to line 10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Heuristics for improving efficiency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>WHERE A.jc1=B.jc1 AND B.jc2=C.jc2 AND A.b AND B.b ORDER BY f1(A.p1)+f2(A.p2)+f3(B.p1)+f4(B.p2)+f5(C.p1) LIMIT k</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Execution Plans for Query Q.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>1 Figure 12 :</head><label>112</label><figDesc>Figure 12: Performances of Different Execution Plans.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Estimated and Real Output Cardinalities of Operators.to estimate the cost of general ranking query plans.In RDBMS, there have been several proposals to support answering top-k queries at application level or outside the core of query engines<ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b31">31]</ref>, or for supporting special types of ranking queries<ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b21">21]</ref>. Recently, supporting top-k queries inside the relational query engine, in terms of physical query operators, has been proved to be an efficient approach that treats ranking as a basic database functionality<ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b23">23]</ref>. A stop operator is proposed in<ref type="bibr" target="#b3">[3]</ref> to limit the cardinality of intermediate and query result, either conservatively by integrity constraints or aggressively</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>for any future tuple t from x. Note that F P [t ] ≥ F P∪{p} [t ] according to Definition 1. Therefore µp can conclude that F P∪{p} [t] ≥ F P ∪{p} [t ], thus it can output t. We continue the running example in Example 2, to show how ranking query plans execute differently from traditional plans. Consider a very simple top-k query over base table S (Figure 2(c)) and the ranking function F2 in Example 2,</figDesc><table><row><cell>Example 3:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Procedure 2 Dimension Enumeration 1: //The 1st dimension: join size 2: for i ← 1 to h do 3: for each SR ⊆ {R1, ..., R h } s.t. ||SR|| = i do 4: for each pair SR 1 , SR 2 s.t. SR = SR 1 ∪SR 2 , SR 1 = φ, SR 1 ∩SR 2 = φ do SP ) ← bestP lan 21: return bestPlan({R1, ..., R h }, {p1, ..., pn})</figDesc><table><row><cell>5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20:</cell><cell>//The 2nd dimension: ranking predicates P ← all predicates that are evaluable on SR for j ← 0 to ||P || do for each SP ⊆ P s.t. ||SP || = j do bestP lan ← a pseudo plan with cost +∞ for each pair SP 1 , SP 2 s.t. SP = SP 1 ∪SP 2 , SP 1 ∩SP 2 = φ do plan ← a pseudo plan with cost +∞ if SR 2 = φ then plan ← joinPlan (bestPlan(SR 1 ,SP 1 ), bestPlan(SR 2 ,SP 2 )) if SR 2 = φ and SP 2 = {p} then plan ← rankPlan(bestPlan(SR 1 ,SP 1 ), µp) if i = 1 and ||SP 1 || ≤ 1 and ||SP 2 || = φ then plan ← scanPlan(SR 1 ,SP 1 ) if cost(plan)≤cost(bestP lan) then bestP lan ← plan bestPlan(SR,</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>More rigorously, it should be the application-specific maximalpossible value of pi. We assume 1 without losing generality.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p><ref type="bibr" target="#b4">4</ref> To be more rigorous, it should be notated as R F P . We omit F for simplicity.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This material is based upon work partially supported by NSF Grants IIS-0133199, IIS-0313260, and a 2004 IBM Faculty Award. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author(s) and do not necessarily reflect the views of the funding agencies.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Adaptive ordering of pipelined stream filters</title>
		<author>
			<persName><forename type="first">S</forename><surname>Babu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Munagala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Nishizawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="407" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Evaluating top-k queries over web-accessible databases</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On saying &quot;enough already!&quot; in SQL</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="219" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Minimal probing: Supporting expensive predicates for top-k queries</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="346" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The onion technique: indexing for linear optimization queries</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bergman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Castelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-L</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="391" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Evaluating top-k selection queries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="397" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On random sampling over joins</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Narasayya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="263" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Optimization of queries with user-defined predicates</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="87" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Towards an open architecture for LDL</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chimenti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gamboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="195" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Combining fuzzy information from multiple systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="216" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimal aggregation algorithms for middleware</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The cascades framework for query optimization</title>
		<author>
			<persName><forename type="first">G</forename><surname>Graefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="19" to="29" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The volcano optimizer generator: Extensibility and efficient search</title>
		<author>
			<persName><forename type="first">G</forename><surname>Graefe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Mckenna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="209" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient approximation of optimization queries under parametric aggregation constraints</title>
		<author>
			<persName><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gunopulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vlachos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="778" to="789" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Merging the results of approximate match operations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="636" to="647" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Optimizing multi-feature queries in image databases</title>
		<author>
			<persName><forename type="first">U</forename><surname>Güntzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Balke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Kießling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Ripple joins for online aggregation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="287" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Predicate migration: Optimizing queries with expensive predicates</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="267" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Optimization of parallel query execution plans in xprs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICPDIS</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="218" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">PREFER: A system for the efficient execution of multi-parametric ranked queries</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Joining ranked inputs in practice</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Elmagarmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="950" to="961" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Supporting top-k join queries in relational databases</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Elmagarmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="754" to="765" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Rank-aware query optimization</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Elmagarmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Foundations of preferences in database systems</title>
		<author>
			<persName><forename type="first">W</forename><surname>Kießling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="311" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Supporting incremental join queries on ranked inputs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Natsev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="281" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Query processing issues in image(multimedia) databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nepal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Ramakrishna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="22" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Complex queries over web repositories</title>
		<author>
			<persName><forename type="first">S</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="33" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Access path selection in a relational database management system</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Selinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Astrahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Price</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="23" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Ranked join indices</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tsaparas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Palpanas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Dataflow query execution in a parallel main-memory environment</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Wilschut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M G</forename><surname>Apers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICPDIS</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="68" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficient maintenance of materialized top-k views</title>
		<author>
			<persName><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
