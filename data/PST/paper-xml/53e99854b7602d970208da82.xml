<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Test-Driven Synthesis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Perelman</surname></persName>
							<email>perelman@cs.washington.edu</email>
						</author>
						<author>
							<persName><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
							<email>sumitg@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Dan</forename><surname>Grossman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Provost</surname></persName>
							<email>peterpr@microsoft.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Washington</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University of Washington</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Test-Driven Synthesis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A82769FD61D921F1027CE972AE8E0591</idno>
					<idno type="DOI">10.1145/2594291.2594297</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.1.2 [Programming Techniques]: Automatic Programming-Program synthesis General Terms Languages</term>
					<term>Experimentation program synthesis</term>
					<term>end-user programming</term>
					<term>test driven development</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Programming-by-example technologies empower end-users to create simple programs merely by providing input/output examples. Existing systems are designed around solvers specialized for a specific set of data types or domain-specific language (DSL). We present a program synthesizer which can be parameterized by an arbitrary DSL that may contain conditionals and loops and therefore is able to synthesize programs in any domain. In order to use our synthesizer, the user provides a sequence of increasingly sophisticated input/output examples along with an expert-written DSL definition. These two inputs correspond to the two key ideas that allow our synthesizer to work in arbitrary domains. First, we developed a novel iterative synthesis technique inspired by test-driven development-which also gives our technique the name of testdriven synthesis-where the input/output examples are consumed one at a time as the program is refined. Second, the DSL allows our system to take an efficient component-based approach to enumerating possible programs. We present applications of our synthesis methodology to end-user programming for transformations over strings, XML, and table layouts. We compare our synthesizer on these applications to state-of-the-art DSL-specific synthesizers as well to the general purpose synthesizer Sketch.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Programming-by-example (PBE <ref type="bibr" target="#b2">[4,</ref><ref type="bibr" target="#b18">20]</ref>) empowers end-users without programming experience to automate tasks like normaliz-ing table layouts or reformatting strings merely by providing input/output examples. Present PBE technologies are designed for a specific set of data types usually either by using an SMT solver or similar technology <ref type="bibr" target="#b28">[30,</ref><ref type="bibr" target="#b31">33]</ref> and being limited to efficiently handling only those data types whose operations map well to the SMT solver's theories or by creating a domain-specific language (DSL) for the task in concert withs a program synthesis algorithm capable of producing programs in that DSL <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b9">11,</ref><ref type="bibr" target="#b16">18]</ref>. LaSy<ref type="foot" target="#foot_0">1</ref> instead is able to synthesize programs in arbitrary domains specified by an expert-written DSL. In order to efficiently support arbitrary domains, we developed a synthesizer that combines two key ideas. First, we use a novel iterative synthesis technique inspired by testdriven development (TDD) <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b20">22]</ref>, giving our methodology the name of test-driven synthesis (TDS). Second, we have advanced the state-of-the-art in DSL-based synthesis as our iterative synthesis only shines when paired with a algorithm that can efficiently improve the program from a previous step.</p><p>Iterative synthesis Taking inspiration from the test-driven development (TDD) <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b20">22]</ref> concept of iterating on a program that always works for the tests written so far, the behavior of functions in LaSy is constrained by a sequence of increasingly sophisticated examples like those that might be written by a programmer authoring a function using the TDD programming methodology or demonstrating the functionality via examples to another human.</p><p>Prior PBE systems take as input a set of representative examples from which a program is synthesized (they may be consumed one at a time, but their order is not prioritized). It is desirable that the user provides representative examples; otherwise the system may end up over-fitting on a simple example, and would fail to find a common program that works for all examples <ref type="bibr" target="#b15">[17]</ref>. On the other hand, when describing a task people can easily provide a sequence of examples of increasing complexity-for example, in a human-readable explanation <ref type="bibr" target="#b24">[26]</ref> or in a machine-readable sequence of tests for TDD. The presentation as a sequence allows for the problem of learning the task to be broken down into a series of sub-problems of learning slightly more detail about the task after seeing each new examplethis is one of the key insights of this paper. While this bears some similarity to genetic programming <ref type="bibr" target="#b21">[23]</ref>, our system does not rely on any concept of a function almost or approximately matching an example. By working in a series of steps where after each step the result is a program that is correct for a subset of the input space, our system is able to more effectively narrow down the search space than prior work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DSL-based synthesis</head><p>The underlying synthesis technique, which we refer to as DBS for DSL-based synthesis, is parameterized by a DSL allowing it to be specialized to different domains with minimal effort. Similar to how a parser generator is given a language definition to make a parser for that language, our general-purpose synthesizer is given a DSL definition to make a synthesizer for that DSL. A DSL primarily consists of a context-free grammar over DSL-defined functions. Additionally, the DSL may use synthesis strategies we provide for learning constructs amenable to special reasoning like conditionals and certain forms of loops. Experts may provide further extensions, but that is out of scope for this paper as we focus on the strengths of DBS and our test-driven synthesis methodology without the complication of additional user-provided synthesis strategies.</p><p>As it is part of an iterative synthesis procedure, DBS is given a previous program that satisfies some prefix of the examples and searches for a modification that makes it satisfy all of the examples. These modifications replace some subexpression of the previous program with a new expression. The generation of replacement subexpressions is done by component-based synthesis <ref type="bibr" target="#b13">[15]</ref>: DBS considers the semantically distinct expressions of the DSL, building them up starting with the atoms in the DSL and the previous program's subexpressions. In our DSL-based approach, DBS uses the grammar of the DSL as opposed to just the types of the expressions to decide what expressions to build, which significantly narrows the search space. Contributions 1. The problem statement of solving a PBE problem given a sequence of increasingly sophisticated input/output examples for each function to be synthesized, reified in our LaSy language ( §3). 2. Our novel test-driven synthesis methodology for solving such synthesis problems combines iterative synthesis ( §4) and DSLbased synthesis ( §5) to be able to synthesize programs with nontrivial control flow including conditionals, loops, and recursion in an arbitrary DSL. 3. Being domain-agnostic, our technique has myriad applications, including significant implications for end-user programming; we summarize a few possiblities with concrete examples in §2. 4. We run experiments demonstrating the effectiveness of each of our key ideas and showing the overall effectiveness of our algorithm on important applications including comparing against state-of-the-art synthesizers in each domain and against the general purpose synthesizer Sketch <ref type="bibr" target="#b28">[30]</ref> ( §6). As a source for more difficult problems for our system, particularly for long sequences of examples, we had it play the Pex4Fun programming game <ref type="bibr" target="#b30">[32]</ref> ( §6.1.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Motivating examples</head><p>We present examples demonstrating the breadth of programs LaSy is able to synthesize to highlight its domain-agnostic capabilities. §6 goes into more detail on evaluating the performance and design decisions of our synthesizer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Automating TDD</head><p>To demonstrate iteratively building up a program, we use the example of greedy word wrap, whose use as a TDD practice problem in <ref type="bibr" target="#b20">[22]</ref> was the original inspiration for our methodology. Word wrap inserts newlines into a string so that no line exceeds a given maximum line length; the greedy version inserts newlines as late as possible instead of trying to even out the line lengths. require WordWrap("Word", 4) == "Word"; // Two words wrap... require WordWrap("Extremely longWords", 14) == "Extremely\nlongWords"; // ... when longer than line.</p><p>require WordWrap("How are", 76) == "How are"; // Wrap as late as possible... require WordWrap("How are you?", 9) == "How are\nyou?"; // ... but no later.</p><p>require WordWrap("Hello, how are you today?", 14) == "Hello, how are\nyou today?"; // Wrap in middle of word.</p><p>require WordWrap("Abcdef", 5) == "Abcde\nf"; require WordWrap("ThisIsAVeryLongWord a", 15) == "ThisIsAVeryLong\nWord a"; // Wrap multiple times (using recursion).</p><p>require WordWrap("How are you?", 4) == "How\nare\nyou?"; // Complicated test to ensure program is correct.</p><p>require WordWrap("This is a longer test sentence. a bc", 7) == "This is\na\nlonger\ntest\nsentenc\ne. a bc"; The examples are interspersed with comments that explain how this sequence iteratively builds up a solution with intermediate steps where it is easy to describe what subset of the inputs the program is correct for. Exactly where to break the line is refined over several examples: first it is just at the space, then at the space in a string longer than the maximum line length, then at the last space in a long string, then at the last space before (or at) the maximum line length, only to be refined further toward the end to include inserting breaks in the middle of words that do not fit on a single line. Also, our synthesizer is able to generalize from inserting a single line break to inserting any number of line breaks via recursion.</p><p>The high number of examples indicates this is a fairly sophisticated program for PBE; it should be noted that full test coverage for TDD takes a similar number of examples <ref type="bibr" target="#b20">[22]</ref>. We include word wrap to show LaSy is capable of scaling up to that many examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">End-user data transformations</head><p>Enabling (hundreds of millions of) end-users to construct small scripts for data manipulation is a very important topic <ref type="bibr">[1,</ref><ref type="bibr" target="#b4">6]</ref>. LaSy can be used to synthesize useful scripts in this domain that are beyond the capabilities of leading prior work in this area <ref type="bibr" target="#b4">[6]</ref>.</p><p>String transformations Consider the task of converting bibliography entries (represented as strings) from one format to another. Fig. <ref type="figure" target="#fig_2">2</ref> shows an example of a LaSy program for converting between two such formats. This program is structured using helper functions for rewriting the authors list and for mapping venue abbreviations to the full venue names used in the target format. Unlike ConvertName and ConvertList, VenueFullName does not do any computation (the full name for "POPL 2013" cannot be inferred from the full name for "PLDI 2012" without a web search), so it is declared as a lookup, meaning the function will just store the list of input/output examples and look up any inputs in that list to find the corresponding output.   = "&lt;doc&gt;&lt;div id="ch1"&gt; &lt;p name="a1"&gt;1st Alinea.&lt;/p&gt; &lt;p name="a1.1"&gt;Zomaar ertussen.&lt;/p&gt; &lt;p name="a2"&gt;2nd Alinea.&lt;/p&gt; &lt;p name="a3"&gt;3rd Alinea.&lt;/p&gt; &lt;/div&gt; &lt;div id="ch2"&gt; &lt;p name="a1"&gt;First Para.&lt;/p&gt; &lt;p name="a2"&gt;Second Para.&lt;/p&gt; &lt;p name="a2.1"&gt;Something added here.&lt;/p&gt; &lt;p name="a3"&gt;Third Para.&lt;/p&gt; &lt;/div&gt;&lt;/doc&gt;"; language xml; function XDocument ToTable(XDocument oldXml); function XElement BuildRow(XDocument oldXml, string rowName); require BuildRow(oldXml, "a1.1") == "&lt;tr&gt;&lt;td&gt;Zomaar ertussen.&lt;/td&gt;&lt;td/&gt;&lt;/tr&gt;"; require ToTable(oldXml) == "&lt;table&gt; &lt;tr&gt;&lt;td&gt;1st Alinea.&lt;/td&gt;&lt;td&gt;First Para.&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Zomaar ertussen.&lt;/td&gt;&lt;td/&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2nd Alinea.&lt;/td&gt;&lt;td&gt;Second Para.&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td/&gt;&lt;td&gt;Something added here.&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;3rd Alinea.&lt;/td&gt;&lt;td&gt;Third Para.&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;"; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XML transformations</head><p>We show two LaSy programs for XML transformation tasks found on help forums. Fig. <ref type="figure" target="#fig_4">3</ref> takes a set of &lt;div&gt;s containing named paragraphs and arranges the data as a table with a column for each &lt;div&gt; and a row for each name, so data is lined up in a row if the same name appears in multiple &lt;div&gt;s. This transformation requires a helper which describes how a table row is built from a paragraph name. Both functions are simple enough that they require only a single example. Fig. <ref type="figure" target="#fig_5">4</ref> assigns class attributes to paragraphs without them according to the class of the nearest previous paragraph (if present), and is implemented by the synthesizer using a loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Language</head><p>In addition to the LaSy programming by example language demonstrated in the previous section, which is explained in more detail in language XML; function XDocument AddClasses(XDocument oldXml); require AddClasses("&lt;doc&gt; &lt;p&gt;1&lt;/p&gt; &lt;/doc&gt;") == "&lt;doc&gt; &lt;p&gt;1&lt;/p&gt; &lt;/doc&gt;"; require AddClasses("&lt;doc&gt; &lt;p&gt;1&lt;/p&gt; &lt;p class='a'&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p class='b'&gt;5&lt;/p&gt; &lt;p&gt;6&lt;/p&gt; &lt;p class='c'&gt;7&lt;/p&gt; &lt;/doc&gt;") == "&lt;doc&gt; &lt;p&gt;1&lt;/p&gt; &lt;p class='a'&gt;2&lt;/p&gt; &lt;p class='a'&gt;3&lt;/p&gt; &lt;p class='a'&gt;4&lt;/p&gt; &lt;p class='b'&gt;5&lt;/p&gt; &lt;p class='b'&gt;6&lt;/p&gt; &lt;p class='c'&gt;7&lt;/p&gt; &lt;/doc&gt;"; Figure <ref type="figure" target="#fig_6">5</ref>. The LaSy language. §3.1, we also discuss the language that experts use to define DSLs for use in LaSy in §3.2. Language All LaSy programs begin with a reference to the DSL being synthesized over. The language is defined beforehand by an expert as described below in §3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">LaSy programming by example language</head><p>Functions The function declarations list the functions to be synthesized. Each function has a name and type signature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Examples and semantics</head><p>Each example is a function call with literals given for its arguments and its required return value. A function f is considered to satisfy an example f(V1, . . . )==VR if whenever f is called with arguments that are structurally equivalent (.Equals() in C#) to V1, . . . , it returns a value that is structurally equivalent to Vr.</p><p>Specifically, the examples are an ordered list dictating a sequence of program synthesis operations wherein the function the example references is modified to satisfy the example without violating any previous example. At the beginning of the synthesis of a LaSy program, all functions are empty (and therefore satisfy no examples). The synthesis process is described in detail in §4.</p><p>The semantics of LaSy are naturally quite weak: the only guarantee is that if the synthesis succeeds, then the examples will be satisfied. The synthesizer is heavily biased toward smaller programs with fewer conditionals which tend to be more generalizable, but does not guarantee it will find the smallest program satisfying all of the examples. While the synthesizer implementation should act in a manner predictable enough that the user can trust its programs to be reasonable, ultimately only the user can determine if the synthesized program actually fulfills the user's intended purpose.</p><p>The result of the synthesizer is C# code which can be compiled and used in any .NET program, including another LaSy program.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">DSL definition language</head><p>An example DSL definition is given in Fig. <ref type="figure" target="#fig_8">6</ref>. The DSL gives a grammar which specifies what programs are possible as well as what the semantics of those programs are. Additionally, the DSL optionally provides a few different kinds of hints to the synthesizer that allow the synthesizer to take advantage of expert knowledge of the semantics.</p><p>Grammar The DSL is given as a context-free grammar. Each line defines an option for a non-terminal given on the left of the ::=. For most rules, the right side gives a DSL-defined function and a list of non-terminals for the arguments to that function. Functions are .NET functions defined in the class specified at the top of the file. The semantics of the DSL must be functional; that is, all functions called must be pure. Note that loops can be handled in a pure way by using lambdas. In general a while loop can be written using the function WhileLoop(condition, body, final) = state =&gt; condition(state) ? WhileLoop(condition, body, final)(body(state)) : final(state).</p><p>Rules other than DSL-defined functions are written in all-caps starting with an underscore to distinguish them. These are used for a few different purposes. First, some are items that are not functions like constants, lambda variables, and lambda abstraction. Some reference items depend on the LaSy program: PARAM corresponds to any parameter of the correct type and LASY FN allows for a call to another LaSy function. Those starting with a double underscore are for functions with specialized synthesis strategies.</p><p>CONDITIONAL(b, e) means that some number of if...else if...else branches are allowed where the conditions match the non-terminal b and the branches match the non-terminal e; this could be a DSL-defined function except for the fact that the synthesizer is aware of the semantics of conditionals and has specialized logic for learning them described in §5.2. Similarly, while not used </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rewrite rules</head><p>The rewrite rules allow the DSL designer to express algebraic identities in their language to help prune the search space of programs with identical semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Test-Driven Synthesis</head><p>The Test-Driven Synthesis methodology synthesizes a program by considering a sequence of examples in order and building up iteratively more complicated programs. We will describe the methodology for a LaSy program with one function, but it easily generalizes to multiple functions. §4.1 describes the algorithm in detail. §4.2 details how the iterative nature of the algorithm works. §4.3 discusses the importance of the order of examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Algorithm</head><p>The Test-Driven Synthesis algorithm (TDS in Algorithm 1) synthesizes a program P given a sequence of examples S and a set of base components. By "program" we mean a single function with a specified set of input parameters and return type. By "example" we mean a set of input values for those parameters and the correct output value. By "component" we mean any of the set of expressions known to the synthesizer which are used as the building blocks for the synthesized program; the base components are the functions referenced by the DSL in the LaSy program but components may also be partially filled-in function calls or larger DSL expressions.</p><p>In the spirit of TDD, we build P up, a little at a time, to allow synthesis of larger programs. Pi satisfies the first i examples; its successor program Pi+1 is built by the DSL-based synthesis (DBS) algorithm using the first i + 1 examples along with information from Pi. The previous program Pi is used in three ways: 1. Its subexpressions are added to the component set. (the whole language plus the parameter a) and contexts = {•} (the set containing just the trivial context) because the previous program P0 = ⊥, so there are no subexpressions to remove to build contexts out of. The smallest program to compute 'S' is to select the first character of a, and therefore P1 = f(a) ⇒ CharAt(a, 0). i=1: S1 = (a = "Amy Smith", RET = 'S'). contexts = {•, CharAt(•, 0), CharAt(a, •)} because P1 has two subexpressions that can be removed. exprs now also contains the expression CharAt(a, 0). The simplest program consistent with both examples selects the second word of a instead of a itself, so DBS will generate Word(a, 1) to select the second word and plug it into the second context to generate P2 = f(a) ⇒ CharAt(Word(a, 1), 0). i=2: S2 = (a = "jane doe", RET = 'D'). contexts= {•, CharAt(•, 0), CharAt(Word(•, 1), 0), CharAt(Word(a, •), 0)}. exprs = e ∪ {a, Word(a, 1), CharAt(Word(a, 1))}. Notably, CharAt(a, 0) does not appear in exprs despite it appearing in exprs for the i = 1 step because it is not a subexpression of P2. It is important that such temporary diversions are forgotten so time is not wasted on them in later steps. DBS will output P3 = f(a)⇒ToUpper(CharAt(Word(a, 1), 0)) which takes only a single step because it is the application of ToUpper to P2 which appears in exprs.</p><p>We now discuss a few details of the algorithm to clarify the description and justify some design choices.</p><p>Relation between TDS and DBS DBS is described later in §5. We separate TDS from DBS both to show explicitly how the previous program Pi is used when constructing the next program Pi+1 and to highlight the two key novel ideas in our approach: 1. TDS encapsulates the new idea of treating the examples as a sequence and using that fact to iteratively build up P by way of a series of programs which are correct for a subset of the input space defined by a prefix of the examples. 2. DBS encapsulates the parameterization by a DSL which allows for the flexibility of the algorithm.</p><p>TDS runs DBS repeatedly, each time giving it the next example from S along with expressions and contexts from the program synthesized in the previous iteration. In other words, it iteratively synthesizes P k for each k ≤ |S| where P k is synthesized using S0, S1, . . . , S k-1 and the previous program P k-1 . In this formulation, P0 is the empty program ⊥, or throw new NotImplementedException(); in C#.</p><p>State As described, the only state kept between iterations is the program Pi and the failure count. DBS does not maintain state, and contexts and exprs depend only on Pi. Additionally, DBS is passed all of the examples up to Si, not just Si. One could imagine a more general problem definition where arbitrary (or at least more) state could be kept between invocations of DBS, but in our experience this tended to be more harmful than helpful: preserving state essentially corresponds to not forgetting about failed attempts.</p><p>No lookahead Although we have formulated the problem as giving TDS the sequence of tests, notice it does not look beyond test Si to generate Pi+1. Hence in an interactive setting the user could look at Pi+1 or its output when choosing Si+1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Contexts and subexpressions</head><p>The intuition for the strategy of replacing subexpressions is that the program generated so far is doing the correct computation for some subset of the input space and is overspecialized to that subset. In the example above, after the i = 0 step, we had the program that returns the first character of the string instead of the first character of the second word of the string. That program was overspecialized to inputs where the first and second word start with same letter. Selecting the first letter was the right computation but on the wrong input, so filling in the context CharAt(•, 0) with the right input gave the desired program.</p><p>Each context represents a hypothesis about which part of the program is correct and correspondingly that the expression removed is overspecialized. Note that the expression appears in the set of components, so if a small change is sufficient, the effort to build it in previous iterations will not be wasted. Also, one such hypothesis is always that the entire program is wrong and should be replaced entirely.</p><p>Contexts are made out of each branch as well as the entire program in order to better support building new conditional structures ( §5.2) using parts of one or more of the existing branches. This theory does not limit contexts to a single hole, but, empirically, doing so keeps the number of contexts manageable and seems to be sufficient in practice. Also, it allows the algorithm to prune away locations based on whether they are reached when executing a failing example: modifications elsewhere could not possibly affect whether such examples are handled correctly. If we allowed multiple modifications, the choice of modification points would have to be changed after any modification affecting control flow. <ref type="bibr" target="#b20">[22]</ref> observes that in TDD the test case order can affect the ability of the programmer to produce a program through small code changes. Similarly, our algorithm may fail to synthesize a program if not given examples in a good order-after all, one of our key insights is that the ordering of examples is a useful input to the synthesizer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Example order</head><p>As a "good" order is defined as being one that results in synthesizing a program satisfying the specification the user has in mind, it is unclear how to define a "good" order without referencing the final synthesized program. Needless to say, such a definition cannot be directly used to guide the generation of a sequence of examples. This is unsatisfying, but we provide some intuition on what such orders look like and §6.2 gives evidence that our synthesizer is ro-bust to small variations in the order of examples. We thus remark that a human could learn to produce such an ordering just like a human can learn to produce TDD test cases in an order that easily results in a correct program. Fundamentally, this is analogous to the issue of how a human should generate a concise but sufficient set of black-box tests for a program. Many guidelines exist, but there is no precise methodology. Nonetheless, black-box testing is successful.</p><p>Once the user has covered the entire specification they had in mind, they have produced a suite of simple test cases for the algorithm they are synthesizing. As in TDD, to confirm that they have in fact synthesized the correct procedure, the user should write a few larger, more comprehensive tests of the procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">DSL-Based Synthesis</head><p>The Only programs containing at most m branches will be synthesized in order to avoid over-specializing to the examples. Synthesis of conditionals is discussed in detail in §5.2. 4. If the algorithm times out before a solution is found, it will return a special failure value TIMEOUT. In TDS, this case increments m allowing for more branches in the next run of DBS. 5. The search space can be reduced even further using specialized strategies for some functions. We demonstrate this by describing strategies we defined for a couple common loop forms in §5.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Choosing new expressions</head><p>New expressions to use in the contexts are generated by componentbased synthesis <ref type="bibr" target="#b12">[14]</ref>. In component-based synthesis, a set of components (expressions and methods) are provided as input and iteratively combined to produce expressions in order of increasing size until an expression is generated that matches the specification. In our case, the "specification" is the examples. As opposed to previous component-based synthesis work, the generation of new expressions is guided by a DSL L and instead of testing the expressions against the specification, they are used to fill in contexts producing larger programs which are then tested.</p><p>In our system, all components are expressions marked with which non-terminal in the grammar defined them. Methods are represented as curried functions. The synthesizer generates new expressions by taking one curried function and applying it to an expression marked with the correct non-terminal. Each iteration of the synthesizer does so for every valid combination of previously generated expressions in order to generate programs of increasing size. Representing methods as anonymous functions also simplifies handling methods that themselves take functions as arguments, which are common in higher-order functions like map and fold.</p><p>As the number of components generated after k iterations is exponential with the base being the number of grammar rules (i.e., functions and constants in the DSL) in the worst case, a DSL that is too large will cause DBS to run out of time or memory before finding a solution. In practice, around 40-50 grammar rules seems to be the limit for DBS, but it depends greatly on the structure of the DSL. An earlier version of DBS without the optimizations described below could not handle more than around 20-30 grammar rules. Further optimizations to better prune the search space could possibly allow for even larger DSLs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Optimizations</head><p>Minimizing the number of generated expressions is important for performance. Redundant expressions are eliminated in two ways: the first is syntactic and hence it is fast and always valid, while the second is semantic and valid only when an expression does not take on multiple values in a single execution (e.g., if the program is recursive).</p><p>Syntactic All expressions constructed are rewritten into canonical forms according to the rewrite rules in the DSL and duplicates are discarded. For example, x+y and y+x are written differently but can be rewritten into the same form so one will be discarded.</p><p>DBS will only accept sets of rewrite rules which are acyclic (once commutativity and other easily broken cycles are removed) to ensure there is a canonical form. Related to this, constant folding is applied where possible, so, for example, 2*5 and 5+5 would both be constant folded to 10, further reducing the search space.</p><p>Semantic The vast majority of the time, an expression takes on only a single value for each example input. In other words, the expression is equivalent to a lookup table from the example being executed to its value on that example. Only expressions with distinct values are interesting, so, for example x*x and 2+x would be considered identical if the only example inputs were x = 2 and x = -1. This is similar to the redundant expression elimination in version space algebras <ref type="bibr" target="#b16">[18]</ref>. The exceptions are if the expression is part of a recursive program or lambda expression, in which case this optimization is not used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Conditionals</head><p>So far we have not considered synthesizing programs containing conditionals, which are of course necessary for most programs. We consider first synthesizing programs where a single cascading sequence of if...else if...else expressions occur at the toplevel of the function body, with each branch not containing conditionals. Then the goal is to have as few branches in the one top-level conditional as possible. The problem is to partition the examples into which-branch-handles-them to achieve this goal.</p><p>For every program p DBS tries, the set of examples it handles correctly is recorded and called T (p). If T (p) = S (all examples handled), p is a correct solution and can be returned. Otherwise, each set of programs Q (where |Q| ≤ m) whose union of handled examples p∈Q T (p) equals S is a candidate for a solution with appropriate conditionals. To be a solution, Q also needs guards that lead examples to a branch that is valid for them; to simplify this, whenever a boolean expression g is generated, the set of examples it returns true for, B(g), is recorded. The sets Q are considered in order of increasing size, so if there are multiple solutions, the one with the fewest branches will be chosen.</p><p>If the conditional does not appear at the top-level, then it must appear as the argument to some function. To handle this case, we note that if every branch of the conditional generated as described already happens to contain a call to a function f with different arguments, then it could be rewritten such that the call to f occurs outside of the conditional if that is allowed by the DSL. In that case, we can say that all of the branches match the context f (•).</p><p>In the algorithm, for each non-terminal the DSL allows for conditionals at, each program p is put into zero or more buckets labeled with the context that non-terminal appears in. For example, if the argument of f may be a conditional and p = f (f (x)) then p would be put in the buckets for f (•) and f (f (•)). Then the same algorithm as above is run for each bucket with the conditionals being rewritten to appear inside the context. Inserting multiple conditionals just involves following this logic multiple times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Loops</head><p>The primary way DBS handles loops is to simply not do anything special at all: recursion and calling higher-order functions like map and fold are handled by the algorithm as described so far. As described in §3.2, a general WhileLoop higher-order function can be used to express arbitrary loops that DBS may synthesize like any other DSL-defined function. On the other hand, the use of loops in code often corresponds to patterns in the input/output examples. This section discusses two such common patterns we have written strategies for; experts designing DSLs may additionally define their own strategies for other forms of loops.</p><p>These can be used in a DSL via the FOREACH(E) or FOR(E) rules where E is the non-terminal for the body of the loop.</p><p>Foreach The "foreach" loop strategy's hypothesis is that there is a 1-to-1 correspondence between an input array and an output array. Assuming that hypothesis, the examples can be split into one example for each element where i is the index, current is the element at that index, and acc is the array of outputs for previous indexes:  <ref type="bibr" target="#b14">16)</ref>. Those examples could be used to synthesize the loop body current*current using TDS. The strategy includes the boilerplate code to take the loop body current*current and output a foreach loop over the input array.</p><p>That example is overly simple as such a computation could easily be captured by a map. However, loop strategies also allow for loops that are not as easily expressed with higher-order functions. For example, the loop bodies examples could also include the values computed so far: (in = {5, 2, 3}, RET = {5, 7, 10}) would become (in = {5, 2, 3}, i = 0, current = 5, acc = {}, RET = 5), (in = {5, 2, 3}, i = 1, current = 2, acc = {5}, RET = 7), and (in = {5, 2, 3}, i = 2, current = 3, acc = {5, 7}, RET = 10). Then the synthesized loop body would be acc.Length &gt; 0 ? current + acc.Last() : current, which could be rewritten into a loop computing the cumulative sum of in.</p><p>For Patterns may also show up across examples. For instance, given the examples (in = 0, RET = 0), (in = 1, RET = 1), (in = 2, RET = 3), (in = 3, RET = 6) we can see, looking across examples, that for each input value the result should be the result for the previous input value plus the new input (which is an indirect way of saying "sum the numbers up to in"). In terms of loop strategies, the hypothesis is that pairs of examples where the input in differ by one correspond to adjacent loop iterations so by combining those pairs we can get examples for the loop body where i is current value of the loop iterator and acc is the return value of the i -1 iteration: (i = 1, acc = 0, RET = 1), (i = 2, acc = 1, RET = 3), and (i = 3, acc = 3, RET = 6). Then TDS will give i + acc for the loop body. The loop strategy will identify that (in = 0, RET = 0) indicates that the loop iterator should start at 0 and the accumulator should start at 0 and produce a for loop for(int i = 1; i &lt;= in; i++) acc = i + acc;.</p><p>Other strategies Different loop strategies can give different information like including the index in a foreach or giving acc corresponding to going in reverse order. Furthermore, the concept of spliting up arrays by element to find patterns can also be applied to splitting strings (by length or delimiters), XML nodes, or whatever other structured data may be in the target domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Conditionals and loops, a general theory</head><p>DSL definitions contain rules with and without specialized strategies. Most rules, including all DSL-defined functions, do not have specialized strategies so expressions using those rules are built using the default strategy of searching through the semantically distinct expressions (using the example inputs to decide which expressions are distinguishable). On other other hand, we have defined strategies for conditionals and loops that use the example outputs as well as the inputs to power more directed approaches to learning those constructs. While we referenced the output values directly in the explanation of the strategies for loops, the discussion of conditionals only referenced them indirectly by keeping track of which examples a program was correct for.</p><p>The strategies for conditionals and loops should be considered as just different instances of the same concept. While conditionals merely select a subset of the examples for each branch, loops do larger rewrites of the examples used in the recursive calls to the synthesizer. Theoretically, a DSL designer could include other strategies like inverses of DSL-defined functions or a polynomial solver for synthesizing arithmetic. We presently omit such functionality because we believe it places undue burden on the DSL designer but intend to investigate it in future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Evaluation</head><p>Our evaluation demonstrates that TDS is sufficiently powerful and general to synthesize non-trivial-albeit small-programs in multiple domains from small sequences of real world examples obtained from help forums. We also compare TDS to to Sketch <ref type="bibr" target="#b28">[30]</ref>, the present state-of-the-art in domain-agnostic program synthesis, and to state-of-the-art specialized synthesizers where applicable.</p><p>Furthermore, we explored how sensitive our iterative synthesis technique actually is to the precise ordering of examples, showing that example order is significant to speed or ability to synthesize on a non-trivial proportion of the examples, especially on larger programs. We also validated some of our design decisions by selectively disabling parts of our algorithm.</p><p>All experiments were run on a machine with a quad core Intel Xeon W3520 2.66GHz processor and 6GB of RAM.</p><p>§6.1 describes the benchmarks used in our experiment and our success in synthesizing them and compares TDS to prior specialized synthesizers where applicable. §6.2 investigates the effect of example ordering to our synthesizer's performance. §6.3 breaks down the usefulness of the different parts of our algorithm. §6.4 evaluates performance for our synthesizer and validates our timeout choice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Benchmarks</head><p>We evaluate our technique in four domains: §6.1.1 compares our technique to a state-of-the-art specialized programming by example system for string transformations, §6.1.2 compares our technique to a start-of-the-art specialized programming by example system for table transformations, §6.1.3 discusses using our system for the novel domain of XML transformations, while finally §6.1.4 shows our technique is able to automate coding in TDD for introductory programming problems.</p><p>For the first three, the example sequences used and output of our synthesizer can be found at https://homes.cs.washington. edu/ ~perelman/publications/pldi14-tds.zip; the last section's programs are not public.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">String transformations</head><p>String transformation programs take as input one or more strings and output a string constructed from the input using mainly substring and concatenation operations.</p><p>Strings are a natural format for input/output examples that often appear in real-world end-user programming tasks as recent work by Gulwani et al. <ref type="bibr" target="#b4">[6]</ref> has shown: their work became the FlashFill feature in Excel 2013 <ref type="bibr">[1]</ref>. Unlike FlashFill, TDS does not use careful reasoning about the domain of strings, but it is still able to quickly synthesize many of the same examples as well as some similar programs that the prior work (i.e., FlashFill) cannot synthesize.</p><p>Benchmarks To compare against FlashFill, we first defined exactly the FlashFill DSL in our DSL definition language and ran our synthesizer on the examples which appear in <ref type="bibr" target="#b4">[6]</ref> to confirm we could synthesize them. Then we made a few modifications to the DSL which are shown in Fig. <ref type="figure" target="#fig_8">6</ref> to make it more general; specifically, we allowed nested substring operations, substring indexes dependent on the loop variable, and calls to other LaSy functions.</p><p>In addition to WordWrap and the examples from <ref type="bibr" target="#b4">[6]</ref> we wrote test case sequences for 7 simple real world string manipulation examples outside of the scope of FlashFill but handled by our extended DSL including selecting the two digit year from a date (requires nested substrings), reversing a string (requires substring indexes dependent on the loop variable), and bibliography examples like the one in Fig. <ref type="figure" target="#fig_2">2</ref> (requires a user-defined lookup).</p><p>Results Each of the 15 example sequences contains 1-8 examples except for word wrap which uses 24 examples. 5 of the examples can be synthesized in under a second. 6 take more than 1 second but under 5 seconds, while the other 4 finish in under 25 seconds. FlashFill synthesizes all of the examples it can handle in well under a second. Simply by specifying the DSL, our domain-agnostic synthesis technique nears the performance of a state-of-the-art specialized synthesis technique while maintaining the ability to generate more complicated control flow structures.</p><p>We coded all examples using the corresponding DSLs in Sketch and none of them completed within 10 minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">Table transformations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table transformations convert spreadsheet tables between different formats by rearranging and copying a table's cells.</head><p>Benchmarks <ref type="bibr" target="#b9">[11]</ref> gives a DSL and synthesis algorithm for these transformations along with a collection of benchmarks the authors found on online help forums. We defined their DSL for our synthesizer and ran it on their benchmarks.</p><p>For additional benchmarks not handled by <ref type="bibr" target="#b9">[11]</ref> we added more predicates to the grammar to allow it to handle a wider range of real world normalization scenarios. For example, our extended grammar can support converting various non-standard spreadsheets with subheaders into normalized relational tables.</p><p>Results Each of the 8 benchmarks uses 1-6 examples. TDS synthesizes most of them in under 10 seconds; 2 take 30 seconds and one takes a full minute. <ref type="bibr" target="#b9">[11]</ref> says Sketch was unable to synthesize their benchmarks so we did not attempt to run the benchmarks using Sketch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.3">XML transformations</head><p>XML transformations involve some combination of modifying an XML tree structure and tag attributes and string transformations on the content of the XML nodes.</p><p>Benchmarks We selected 10 different real world examples from online help forums and constructed a DSL able to express the operations necessary to synthesize programs for all of them. Two of the examples appear in §2.2.</p><p>One transformation involved putting a tag around every word, even when words had tags within them, which was easiest to express treating the words as strings instead of as XML. Making the string and XML DSLs work together required simply putting the functions to convert between the two in the DSL. This kind of cross-domain computation shows the strength of our domainagnostic approach.</p><p>Results Most of the benchmarks used a single example while the rest used no more than 3. TDS synthesizes all but two of the benchmarks in under 10 seconds and the remaining two in under 20 seconds.</p><p>We also implemented the DSL and benchmarks in Sketch, which was unable to synthesize any of them within 10 minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.4">Pex4Fun programming game</head><p>Motivation Although we believe our end-user programming scenarios are compelling, we wanted to test our synthesizer in a scenario closer to the TDD programming style it was inspired by and get a source for some more challenging functions to synthesize. To that end, we had our synthesizer play the Pex4Fun <ref type="bibr" target="#b30">[32]</ref> programming game where a player is challenged to implement an unknown function given only a few examples. Each time the player thinks they have a solution, the Pex <ref type="bibr" target="#b29">[31]</ref> test generation tool uses dynamic symbolic execution to compare the player's code to a secret reference solution and generates a distinguishing input if the player's code does not match the specification. Pex provides the test for the test step of the TDD while the player is performing the programming step without full knowledge of the specification they are coding for. This is a more "pure" form of TDD as the player is not biased in their coding by knowing the specification, giving a closer parallel to our synthesizer which does not have knowledge of the specification of the function it is synthesizing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment description</head><p>We use a single DSL with a set of 40 simple string and int functions which may be combined in any type-safe way to show that while a carefully constructed DSL can be given to our synthesizer to make it perform especially well in a given domain, it can still successfully synthesize programs using a less specialized DSL capable of describing a wider range of programs. Note that our DSL was written without looking at the  Pex4Fun puzzles and therefore ended up missing some functions necessary for some puzzles like bitwise operations.</p><p>For each puzzle in the Pex4Fun data, we had our algorithm play Pex4Fun for a maximum of 7 iterations, after which the synthesizer was considered to have failed if it still had not produced a solution. This may seem like too few iterations, but it is more calls to Pex than most users used for any of the puzzles.</p><p>For some of the puzzles, using Pex to generate test cases failed to generate a solution despite manual inspection determining that the puzzles were well within the capabilities of the synthesizer and the DSL used. In such cases, a sequence of test cases was generated manually to synthesize solutions to those puzzles.</p><p>Benchmarks The puzzles our synthesizer could synthesize included, among many others, factorial, swapping elements of an array, and summing numbers in a string delimited by delimiter specified on the first line of the string and some more trivial examples like concatenating the first and last element of a string array.</p><p>The remaining unsynthesized puzzles either involved looping structures not covered by our strategies (e.g., count the number of steps of the 3n + 1 problem 2 needed to reach 1), components not in our component set (e.g. compute bitwise or), or arithmetic expressions too large to construct using component-based synthesis (e.g. compute the value of a specific cubic polynomial).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results</head><p>We ran our experiment across 172 randomly selected puzzles from Pex4Fun. The synthesizer found solutions for 72 of those. For 60 of those, the test cases generated by Pex were sufficient, but for another 12 the test cases had to be written manually.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Example ordering</head><p>We hypothesized that example ordering is useful and TDS is robust to small variations in example order. For the vast majority of our benchmarks, the number of examples is small and their order is unimportant; the use of contexts and subexpressions from the previous program is important (when not synthesizing from a single example) as is shown in §6.3 by disabling them, but the specific order of the examples is not. On the other hand, the 12 Pex4Fun puzzles which required manually written example sequences were difficult enough for TDS that the ordering of examples was in fact valuable to the algorithm. To give an idea of how important the ordering actually was, we ran TDS on randomly reordered copies of those example sequences. Fig. <ref type="figure">7</ref> shows the timing results for the example sequences that were successfully synthesized. Each circle is one example sequence, and the line shows geometric mean of circles.</p><p>The x-coordinate measures how far from the optimal example sequence it was where 0 is the optimal sequence and 1 is the reverse of the optimal sequence. Specifically, the value is the number of inversions <ref type="foot" target="#foot_1">3</ref> between the two sequences divided by the maximum possible number of inversions ( n(n-1) 2 for a sequence of length n). The y-coordinate is the time it took to synthesize the solution using the random sequence measured in the time it took to synthesize using the optimal sequence. Note that the y-axis is a log scale.</p><p>Fig. <ref type="figure">8</ref> shows for how many of the reorderings the program was not successfully synthesized. The x-axis is the same; each bar corresponds to a range of normalized inversion counts. The bar heights are the proportion of sequences for which a program could not be synthesized, and the numbers above the bars are the absolute counts. There are more examples toward the middle as the sequences were selected uniformly at random, and there are more possible sequences in the middle.</p><p>The charts show two important properties of TDS. First, it does in fact depend on example ordering: large changes to the example ordering make it take much longer to find a solution or fail to find a solution at all. Second, it is robust to small changes in the example ordering: for normalized inversion counts less than 0.3, fewer than half the reorderings failed and those that succeeded took on average less than three times as long as the optimal ordering.</p><p>Those 12 examples show the worst case for our synthesizer. For the other 60 Pex4Fun puzzles with test cases sequences from Pex, 51 of them were also successfully synthesized with those test cases in reverse order. For the rest of the examples, nearly all could be synthesized with the examples sequence in reverse order, at worst slowed down by a factor of 3. This indicates that the sensitivity to test case ordering is affected by how complicated the program being synthesized is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Significance of various parts of algorithm</head><p>In order to evaluate the usefulness of the different parts of our algorithm, we ran our benchmarks with parts of it disabled. Fig. <ref type="figure">9</ref> shows how many of the benchmarks were synthesized under each limited version of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Iterative synthesis</head><p>The iterative synthesis strategy employed by TDS is implemented by passing contexts and subexpressions from the previous program to DBS. We disabled these two pieces of information individually and together. The Pex4Fun and table transformation benchmarks were most affected by the removal of features from TDS due to working with larger programs. Notably, we see that either the subexpressions or contexts alone is helpful, but when combined they are significantly more powerful.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DSL-based synthesis</head><p>We also disabled the use of the DSL when generating components in DBS, so it instead would be limited only by the types of expressions. There are no "no DSL" bars for the Pex4Fun benchmarks because the Pex4Fun DSL already only used the types, so that configuration is identical to the "full" configuration. Many of the other programs were synthesized from just a single example, so the weakening of TDS did not have a large effect, but this success was achieved due to the power DBS gained from the DSL as can be seen from the fact that very few of the end-user benchmarks could be synthesized without access to the DSL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Performance</head><p>Fig. <ref type="figure" target="#fig_1">10</ref> shows a CDF of all execution times of all of the DBS runs used in our experiments. This chart shows that DBS is quite efficient with a median running time of approximately 2 seconds and running in under 10 seconds around 75% of the time.</p><p>Timeout Throughout the experiments, we used a 3 minute timeout. Only very rarely in our experiments did DBS ever run for anywhere near 3 minutes without timing out. There is a visible bump around 60-70 seconds after which the line is almost flat, indicating that it is very unlikely that giving DBS a small amount of additional time would have made any noticeable difference in our results. This is further verified by ad-hoc experience that without a timeout, DBS runs for over 30 minutes without a result or runs out of memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head><p>Programming by example Programming by example (PBE) <ref type="bibr" target="#b5">[7]</ref>, or inductive programming <ref type="bibr" target="#b14">[16]</ref>, is a subfield of program synthesis covering many different techniques where a program is incompletely specified by examples (inputs paired with explicit outputs or a quality function for results). In all of the prior work, all of the examples are given at once, although much of it uses some variant of genetic programming <ref type="bibr" target="#b21">[23]</ref> where programs are built and iteratively mutated toward a solution or CEGIS <ref type="bibr" target="#b28">[30]</ref> where new programs are constructed until a solver fails to provide a counterexample, similar to how our synthesizer was used with Pex in the Pex4Fun experiment. A key idea in the recent prior work is reducing the search space using version space algebras <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b6">8,</ref><ref type="bibr" target="#b9">11,</ref><ref type="bibr" target="#b16">18,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b27">29]</ref>, which we avoid in order to maintain generality as they must be constructed for a given domain.</p><p>TDS is most similar to prior work on component-based synthesis and genetic programming.</p><p>Component-based synthesis Component-based synthesis is a family of techniques that perform program synthesis by starting with a set of "components"-that is, expressions and functionsand considering actual programs constructed from combining these components (as opposed to the version space algebra approach where the actual program is merely an artifact that can be recovered after the main synthesis algorithm is complete). Componentbased synthesis has been successfully applied to a wide variety of domains including bit-vector algorithms <ref type="bibr" target="#b7">[9]</ref>, string transformations <ref type="bibr" target="#b22">[24]</ref>, peephole optimizations <ref type="bibr" target="#b3">[5]</ref>, type convertors <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b25">27]</ref>, deobfuscation <ref type="bibr" target="#b11">[13]</ref>, and geometry constructions <ref type="bibr" target="#b8">[10]</ref>.</p><p>The actual search is performed in different ways dictated by the information required be known about the components. For example, Gulwani et al. <ref type="bibr" target="#b7">[9]</ref> used an SMT solver because their components are standard bitwise arithmetic operators, so they have easily expressible logical specifications. Also, this is the prior work we found with the largest program synthesized by componentbased synthesis at 16 lines of code, which took around an hour to synthesize. In comparison, our algorithm can synthesize programs of up to 20 lines of code within 400 seconds consisting of arbitrary user-defined functions.</p><p>The prior work most similar to our DBS is by Katayama <ref type="bibr" target="#b13">[15]</ref>. Like our algorithm, any function can be a component and it maintains an explicit list of the components generated so far and uses them when generating components on the next step. It finds and prunes redundant components by evaluating every component on a subset of the examples and only keeping components that evaluate to different values on some example. This is similar to the pruning done by DBS except that DBS uses all examples seen so far.</p><p>Genetic programming Genetic programming <ref type="bibr" target="#b21">[23]</ref> synthesizes programs by performing a genetic search which involves using previous candidate programs to produce new candidate programs. The primary difference between our work and genetic programming is that genetic programming is directed by a quality function that tells how well a given program performs at the desired task and relies on that quality function being well-behaved while our search is only given a boolean failure or success on each test case.</p><p>ADATE <ref type="bibr" target="#b23">[25]</ref> takes as input a set of test inputs and quality functions for their outputs and performs a genetic search where programs are mutated and only programs that improve or maintain the sum of the quality function values are kept. This formulation means that ADATE has to choose which test case to improve next, unlike in our system where the first k test cases must pass before the synthesizer considers test case k + 1.</p><p>Template-based synthesis Program sketching <ref type="bibr" target="#b28">[30]</ref> is a form of program synthesis where the programmer writes a sketch, i.e., a partial program with holes, and provides a specification the solution must satisfy. LaSy can be seen as a less precise sketch with a DSL instead of partial bodies: in fact, we ported our LaSy programs to Sketch in order to do a comparison for our evaluation. However, the search strategy is very different: our synthesizer fills in the holes using component-based synthesis (as opposed to using SAT/SMT solvers) and checks against input/output examples (instead of a more complete specification).</p><p>Syntax-guided synthesis Our DSL-based approach is similar to the syntax-guided synthesis idea proposed in <ref type="bibr" target="#b0">[2]</ref>, but is more flexible by allowing for a DSL that uses arbitrary .NET functions. That work <ref type="bibr" target="#b0">[2]</ref> only presents simple prototype synthesizers which lack the power of TDS. SyGuS's use of constraints instead of examples makes a direct comparison of synthesizer technologies difficult.</p><p>Rosette <ref type="bibr" target="#b31">[33]</ref> is an extension to the Racket programming language which allows easy access to a solver for applications including synthesis over DSLs embedded in Racket. While the programmer experience is much sleeker than with SyGuS or LaSy, the syn-thesis engine suffers similar limitations to Sketch: it cannot efficiently handle types that don't map to an SMT solver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Automated program repair</head><p>In automated program repair <ref type="bibr" target="#b17">[19,</ref><ref type="bibr" target="#b32">34,</ref><ref type="bibr" target="#b33">35]</ref>, many passing and failing test cases are given along with a buggy human-written program to repair. This is a different task because the automated program repair systems are not expected to add new functionality, only fix existing functionality. As a result, the existing code can be effectively used to guide many repairs.</p><p>In angelic debugging <ref type="bibr" target="#b1">[3]</ref>, expressions that are likely to be the right place to make a change are identified. For each expression, it determines if it is a possible repair point by taking a set of passing and failing test cases and checking if for each test case, there is some alternative value for that expression that makes the test case pass. Angelic debugging does not attempt to synthesize new expressions; it only identifies the possible locations for fixes. Like our algorithm, angelic debugging assumes that a program can be repaired by changing only a single expression. In fact, angelic debugging could be used as a preprocessing step in our algorithm to prune the choices for modification points or determine that a simple modification is unlikely to work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions and Future Work</head><p>Our synthesis technique advances the state-of-the-art in componentbased synthesis which has been restricted to synthesis of straightline code fragments over a given set of components. Our overall test-driven synthesis methodology enables synthesis of programs containing conditionals and loops over a given set of components. As future work, we intend to explore including information about function inverses in the DSL, expanding the range of control flow structures supported by our synthesizer, use the synthesizer to generate feedback for the Pex4Fun game and introductory programming assignments, create an interface for performing end-user programming tasks with LaSy, and explore other applications for TDS utilizing its incremental nature including updating sythesized code as a specification changes or fixing code from another synthesizer that generates approximate or incomplete solutions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1</head><label>1</label><figDesc>shows part of a LaSy program for implementing greedy word wrap, showing only 1 or 2 of the up to 6 examples under language strings; function string WordWrap(string text, int length); // Single word doesn't wrap.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Abbreviated LaSy program for greedy word wrap showing a representative subset of the 24 test cases</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. LaSy program for converting bibliography entries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>oldXml</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. LaSy program for converting set of XML lists to a table</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. LaSy program for adding class attributes P ::= language I; F * E * (Program) F ::= function t f((t x, ) * ); (Function declaration) | lookup t f((t x, ) * ); (Lookup declaration) E ::= require f((V,) * ) == V; (Example) V ::= any constant expression (Value) t ::= I | I&lt;(t,) * &gt; (type name) f ::= I (function name) x ::= I (variable name) I ::= any valid identifier (Identifer)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5</head><label>5</label><figDesc>Fig. 5 gives the syntax of LaSy. Note that LaSy relies on a base language, C# in our implementation, to provide basic types, functions, and values, and therefore the precise syntax for values and identifiers is omitted: type references are C# type references and values are C# expressions. Programs in LaSy consist of a set of function declarations and a sequence of examples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>language strings; assembly flashfill.dll class lasy.FlashFill; start P; P ::= CONDITIONAL(b, e); b ::= ||(d, . . . , d); d ::= &amp;&amp;(π, . . . , π); π ::= m | !(m); m ::= Match(v, r, k) | Match(f, r, k) | &lt;(i, i); i ::= Length(v) | GetPosition(v, p) | j; j ::= PARAM; e ::= Concatenate(f, . . . , f) | SplitAndMerge(v, s, s, λf:e); f ::= ConstStr(s) | SubStr(v,p,p) | Loop(λw:e) | SubStr(f,p,p) | Trim(f) | LASY FN(f) | RECURSE(f, j); s ::= CONSTANT; p ::= Pos(r,r,c) | CPos(k) | CPos(c) | CPos(j) | RelPos(p,r,c); c ::= k | k*w+k; k ::= CONSTANT; r ::= TokenSeq(T,. . . ,T) | ; v ::= PARAM; rewrite &amp;&amp;(π 0, π 1) ==&gt; &amp;&amp;(π 1, π 0); rewrite ||(d 0, d 0) ==&gt; d 0; rewrite 0*w 0+k 0 ==&gt; k 0; rewrite Trim(Trim(f 0)) ==&gt; f 0;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. The extended FlashFill DSL; grammar rules not present in the original DSL are in bold.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Algorithm 1 : 5 if 6 Pi+1 ← Pi; 7 failuresInARow ← 0; 8 else 9 contexts 18 if</head><label>15678918</label><figDesc>TDS(S, L) input : sequence of examples S, DSL specification L output : a program P that satisfies S or FAILURE 1 e ← all grammar rules in L; 2 P0 ← ⊥; 3 failuresInARow ← 0; 4 foreach i ← 0, . . . , |S| -1 do Pi(input(Si))=output(Si) then ← ∅, exprs ← e ∪ parameters of Pi; 10 foreach subexpression s of Pi do 11 Add λexpr.Pi[s/expr] to contexts; 12 Add s to exprs; 13 foreach branch B of Pi do 14 foreach subexpression s of B do 15 Add λexpr.B[s/expr] to contexts; 16 Pi+1 ← DBS(contexts, (S0, . . . , Si), exprs, L, 17 num branch(Pi)+failuresInARow); Pi+1 is TIMEOUT then 19 Pi+1 ← Pi;20 failuresInARow ← failuresInARow + 1; in the example, FOR(i) and FOREACH(arr) have associated synthesis strategies for certain forms of loops which are described in §5.3. Constant value generation The DSL may include code to decide what constant values may appear in the program which may depend on the examples (not shown in the figure). The simplest logic a DSL could use is that any values in the examples may be used as constants in the program. Other DSLs may have cases like including only regular expressions from a preset list that match one of the inputs or, when synthesizing XML, extracting the names of the tags and attributes in the outputs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>2 .</head><label>2</label><figDesc>Contexts to synthesize in are formed by removing each subexpression of Pi one at a time. 3. The number of branches may only exceed the number of branches in Pi if failuresInARow &gt; 0. New conditionals are allowed only after failures in order to avoid overfitting to the examples by creating a separate branch for each one. EXAMPLE 1 (Walkthrough of TDS). We will use the DSL C ::= CharAt(S, N)|ToUpper(C), S ::= Word(S, N)| PARAM, N ::= 0|1 where Word(s, n) selects the n th word from the string s and PARAM is any function parameter and e is the set of all grammar rules in that DSL to demonstrate synthesizing the function f(a)⇒ToUpper(CharAt(Word(a, 1), 0)): i=0: S0 = (a = "Sam Smith", RET = 'S'). exprs = e ∪ {a}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Algorithm 2 : 4 foreach c ← C do 5 foreach expr ← allExprs do 6 Try c(expr); 7 Try</head><label>24567</label><figDesc>DBS(C, S, e, L, m) input : set of contexts C, set of examples S, set of expressions e to build new expressions from, DSL specification L, maximum number of branches m output : a program P that satisfies S or TIMEOUT /* Try generates one or more programs and if one satisfies S, DBS returns it. */ 1 Try loop strategies in a separate thread ( §5.3); 2 allExprs ← e; 3 while not timed out do conditional solutions up to m branches ( §5.2); 8 allExprs ← generate new expressions ( §5.1); 9 return TIMEOUT;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>(in = {3, 5, 4}, RET = {9, 25, 16}) would become the examples (in = {3, 5, 4}, i = 0, current = 3, acc = {}, RET = 9), (in = {3, 5, 4}, i = 1, current = 5, acc = {3}, RET = 25), and (in = {3, 5, 4}, i = 2, current = 4, acc = {9, 25}, RET =</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 7 .Figure 8 .</head><label>78</label><figDesc>Figure 7. Norm. time (1=opt) for many reorderings of examples (dist. measured in inversions, norma. so 1=reverse); the line shows the geo. mean of the data points for each norm. inversion count.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>2Figure 9 .Figure 10 .</head><label>910</label><figDesc>Figure 9. # synthesized by benchmark set and features enabled in algorithm. "full" is the full algorithm, contexts and subexpressions from previous program together form the information TDS uses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>DSL-Based Synthesis algorithm (DBS in Algorithm 2) is the part of TDS that actually generates new programs. DBS takes as input a set of examples S, a set of contexts C which generated DSL expressions are plugged into to form synthesized programs matching L, a set of expressions e, a DSL definition L, and a maximum number of branches m. It outputs a new program P that satisfies all examples in S or TIMEOUT if it is unable to do so. The algorithm is built on five key concepts: 1. New programs are not generated directly; instead expressions are generated and plugged into contexts provided as hints to narrow the search space. This is used by TDS to indirectly provide the previous program as a hint ( §4.2). 2. New expressions are formed from all compositions of expressions according to the DSL L. To produce all smaller expressions before generating larger ones, DBS runs as a series of iterations, where, in each iteration, only expressions from previous iterations are composed into new expressions. §5.1 discusses generation of new expressions (and important optimizations). 3. A new branching structure will be synthesized if no generated program satisfies all examples in S and m &gt; 1.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Language for Synthesis, pronounced "lazy"</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p># of example pairs that have different order in the two lists</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Acknowledgements</head><p>This work was funded in part by two internships at Microsoft Research. We thank the anonymous reviewers for their valuable feedback. We thank Nikolai Tillmann and Peli de Halleux of Microsoft Research's Pex4Fun team for access to the Pex4Fun data.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Syntaxguided synthesis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Juniwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raghothaman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Torlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Udupa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMCAD</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Torlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Barman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<title level="m">Angelic debugging. ICSE</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Watch What I Do: Programming by Demonstration</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cypher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Halbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kurlander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lieberman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maulsby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Turransky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>MIT press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Eliminating branches using a superoptimizer and the GNU C compiler</title>
		<author>
			<persName><forename type="first">T</forename><surname>Granlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kenner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automating string processing in spreadsheets using inputoutput examples</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Synthesis from examples: Interaction models and algorithms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SYNASC</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Spreadsheet data manipulation using examples</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2012-08">Aug. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Synthesis of loopfree programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Korthikanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
		<title level="m">Synthesizing geometry constructions. PLDI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Spreadsheet table transformations from examples</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Test-driven development concepts, taxonomy, and future direction</title>
		<author>
			<persName><forename type="first">D</forename><surname>Janzen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Saiedian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>sept</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Oracle-guided component-based program synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICSE</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Systematic search for lambda expressions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Katayama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TFP</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient exhaustive generation of functional programs using monte-carlo search with iterative deepening</title>
		<author>
			<persName><forename type="first">S</forename><surname>Katayama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PRICAI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Inductive programming: A survey of program synthesis techniques</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kitzelmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approaches and Applications of Inductive Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Schmid</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Kitzelmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Plasmeijer</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Why PBD systems fail: Lessons learned for usable AI</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 2008 Workshop on Usable AI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Programming by demonstration using version space algebra</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wolfman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">53</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Genprog: A generic method for automatic software repair</title>
		<author>
			<persName><forename type="first">C</forename><surname>Le Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2012-01">Jan. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Your wish is my command: Programming by example</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lieberman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Jungloid mining: helping to navigate the API jungle</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mandelin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kimelman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Martin</surname></persName>
		</author>
		<ptr target="http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html" />
		<title level="m">The transformation priority premise</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Grammar-based genetic programming: a survey</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">I</forename><surname>Mckay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">X</forename><surname>Hoai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Whigham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Oneill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetic Programming and Evolvable Machines</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="365" to="396" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A machine learning framework for programming by example</title>
		<author>
			<persName><forename type="first">A</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Tamuz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kalai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICML</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Inductive functional programming using incremental program transformation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Olsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1995-03">Mar. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The mind grows circuits</title>
		<author>
			<persName><forename type="first">R</forename><surname>Panigrahy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<idno>CoRR, abs/1203.0088</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Type-directed completion of partial expressions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Perelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Learning semantic string transformations from examples</title>
		<author>
			<persName><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Synthesizing number transformations from input-output examples</title>
		<author>
			<persName><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Program Synthesis By Sketching</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Solar</forename><surname>Lezama</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008-12">Dec 2008</date>
		</imprint>
		<respStmt>
			<orgName>EECS Department, University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Pex: white box test generation for</title>
		<author>
			<persName><forename type="first">N</forename><surname>Tillmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">De</forename><surname>Halleux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NET</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>TAP</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Pex4Fun: Teaching and learning computer science via social gaming</title>
		<author>
			<persName><forename type="first">N</forename><surname>Tillmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>De Halleux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bishop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CSEE&amp;T</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Growing solver-aided languages with Rosette</title>
		<author>
			<persName><forename type="first">E</forename><surname>Torlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming &amp; software</title>
		<meeting>the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming &amp; software</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="135" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Automatic program repair with evolutionary computation</title>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Le</forename><surname>Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2010-05">May 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Automatically finding patches using genetic programming</title>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Le</forename><surname>Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICSE</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
