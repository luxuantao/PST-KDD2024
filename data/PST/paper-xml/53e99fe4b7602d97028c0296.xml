<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Exemplar Queries: Give me an Example of What You Need</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Davide</forename><surname>Mottin</surname></persName>
							<email>mottin@disi.unitn.eu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Trento</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Matteo</forename><surname>Lissandrini</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Trento</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yannis</forename><surname>Velegrakis</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of Trento</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Themis</forename><surname>Palpanas</surname></persName>
							<email>themis@mi.parisdescartes.fr</email>
							<affiliation key="aff3">
								<orgName type="institution">Paris Descartes University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Exemplar Queries: Give me an Example of What You Need</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EA9174EFE630F3969E22ED2B8C762E80</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Search engines are continuously employing advanced techniques that aim to capture user intentions and provide results that go beyond the data that simply satisfy the query conditions. Examples include the personalized results, related searches, similarity search, popular and relaxed queries. In this work we introduce a novel query paradigm that considers a user query as an example of the data in which the user is interested. We call these queries exemplar queries and claim that they can play an important role in dealing with the information deluge. We provide a formal specification of the semantics of such queries and show that they are fundamentally different from notions like queries by example, approximate and related queries. We provide an implementation of these semantics for graph-based data and present an exact solution with a number of optimizations that improve performance without compromising the quality of the answers. We also provide an approximate solution that prunes the search space and achieves considerably better time-performance with minimal or no impact on effectiveness. We experimentally evaluate the effectiveness and efficiency of these solutions with synthetic and real datasets, and illustrate the usefulness of exemplar queries in practice.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Traditional query answering is about finding the structures in a data repository that satisfy the query conditions <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b32">32]</ref>. Recent advances in information and communication technologies have brought query answering systems to the general public, driving a significant effort for simplifying these systems to a level that allows them to be used by the average user. New techniques for answering simpler, less structured and less specific queries, have attracted considerable attention <ref type="bibr" target="#b6">[6]</ref>. This is because the average users are typically not accustomed to the technicalities of the query language, neither its capabilities, which makes it hard to provide a full specification of the elements of interest. To cope with these situations, query answering systems have employed techniques such as query relaxation <ref type="bibr" target="#b22">[22]</ref>, semantic enhancements <ref type="bibr" target="#b5">[5]</ref>, statistics-driven query answering <ref type="bibr" target="#b14">[14]</ref>, log-based analysis <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b24">24]</ref>, and others.</p><p>A hidden assumption behind all the aforementioned techniques is that the user is aware of the characteristics of the structures of interest and can (at least partially) describe them in the query. We advocate here that there are many practical scenarios in which this is not the case. We are interested in those cases where the user knows one single element among those that are expected to be in the desired result set, and we would like to study ways to infer the rest of the elements from this. In other words, the user "query" works as an example of what the elements of interests that are expected to be returned by the search engine are. We call this novel query paradigm exemplar queries to emphasize its different nature from those previously mentioned and the new evaluation methods they require.</p><p>The notion of exemplar queries reminisces the well-known notion of query by example (QBE) <ref type="bibr" target="#b35">[35]</ref>, yet, it is fundamentally different. In QBE, the user query is also an example, but is used simply to communicate to the query evaluation engine the conditions in a more user-friendly way. In some sense, QBE works like a wildcard query. In contrast, the query in our case is rather a sample from the desired set, indicating the type of elements that are expected to be in the results. These elements may have characteristic properties different from those mentioned in the user query, simply because their similarity to the example that the user query provides may be based on characteristics that are not explicitly stated in the query. Our approach is also different from query relaxation <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b23">23]</ref>, which aims at producing more generic versions of a query. As in the case of QBE, these queries have some of the properties of the original query at their core.</p><p>Exemplar queries find important practical applications in information searching. They are particularly suitable for the case of a student, a curious citizen, an investigator, a lawyer or a reporter that needs to perform a study on a topic to which she may not be familiar, but has as a starting point an element from the desired result set. Exemplar queries can form the basis of a new form of search engines that uses them as the main query evaluation mechanism, or they can be used to enhance the services that existing search engines are currently offering. In particular, in parallel to the query evaluation a search engine performs, the query can also be seen as an exemplar query and be evaluated as such. These results can be appended to the results the search engine generates, increasing the probability to capture the user's intent. Alternatively, the results of the exemplar query evaluation can be modeled as a set of queries, and then appended in the list of "related/additional queries" that most modern search engines are currently suggesting to their users. For instance, a query on the World War II will typically return documents related to this war. Evaluating the query as an exemplar query will result to many other big wars in history. Then, documents related to these wars can be added in the result set, or queries retrieving data about these wars can be added in the list of the related searches that the search engine suggests to the user.</p><p>For the evaluation of exemplar queries we consider two steps. The goal of the first step is to evaluate the user query and identify in the data repository the structure that the user is describing in the query. Once this structure has been identified, in the second step we examine the data store to find similar structures. Our approach is principled and does not depend on the data store model. In this study though, we focus on the case where the data store is based on a graph data model with labels on the edges. In order to find similar structures, we naturally use a version of graph similarity (in particular, graph-isomorphism), but in a way that takes into consideration also labels on the edges. Furthermore, we are interested only on the k most promising results. Traditional query answering on graphs <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b34">34]</ref>, that focuses on finding the best subset of nodes matching a given graph-query, has no straightforward time-efficient adaptation to allow the retrieval of the top-k most similar subgraphs based on our form of similarity. The brute-force solution is exponential in nature, so we devised an efficient iterative pruning schema that pre-computes a representation of the neighborhood of each node, using only the information on the edges. We demonstrate that this algorithm is exact, i.e., it preserves the quality of the answers, while significantly reducing computation time. We also propose an approximate algorithm, which prunes the search space, keeping only the subgraph portion that is closer to the user-query, i.e., contains the top-k answers. We show that this heuristic works very well in practice, with no significant compromise on the quality of the results.</p><p>Our contributions can be summarized as follows: (i) we introduce and formally define a novel form of query answering, referred to as exemplar queries, that treats a query as a sample from the desired result set; (ii) we study exemplar queries for graph-based models, and devise a similarity metric that takes edge-labels into consideration; (iii) we propose two algorithms to compute the exact solution, a baseline and an optimized one, and we further describe an approximation algorithm with significant efficiency gains and minimal effect on quality; (iv) we experimentally show that existing approaches either fail to produce correct exemplar query evaluations, or they do so in a much longer time, that makes them inapplicable for online applications; finally, (v) we perform a thorough experimental evaluation, using the largest multigraph ever used (freebase) in this field, that demonstrates the efficiency of our solution, and a user-study that validates the usefulness of exemplar queries.</p><p>The remainder of the paper is structured as follows. Section 2 provides a motivating example while Section 3 defines formally the notion of exemplar queries, and an instantiation of the problem on a graph-based data model. Sections from 4 to 7 provide algorithmic solutions to this instantiation of the problem. Section 8 describes our experimental </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">MOTIVATING EXAMPLE</head><p>Consider a university student who has been given an assignment to perform a study on company acquisitions in the Bay area. The student is not really an expert in the field, and not familiar with the related terminology. Writing a query with the terms "acquisitions" and "Bay Area" will, in the best case, return documents talking about the topic of acquisitions, and also mentioning the Bay area. An article on the takeover of del.icio.us by Yahoo! may not be returned if the actual words of acquisition and Bay area are not explicitly mentioned in the text.</p><p>The student knows that a good case of the type of acquisition she is looking for is the one of YouTube by Google. Thus, she issues the query: "Google founded-in Menlo Park acquired YouTube". The search engine typically responds with results related to Google, Menlo Park, and YouTube, but will not return anything related to an acquisition of del.icio.us by Yahoo!. If there is a significant number of users that have performed similar searches in the past, an analysis of the query logs may reveal that information and the search engine may be able to propose, in the related searches section, queries on Yahoo! and del.icio.us. (A simple test in existing search engines reveals that this is not actually happening.) Relaxing one or more of the query conditions does not help in a significant way, since the results are still focused around the Google case.</p><p>Consider now a second candidate answer for the user query: Opel that was acquired by General Motors (GM). Among the Yahoo!-del.icio.us and GM-Opel, it is more likely that the former is among the company acquisitions that the user is interested in, and not the latter. This is because even though Yahoo! was founded in a different city than Google, that city is still in California (just like with Google), while the city that GM was founded is in Michigan. Furthermore, the example of Google-YouTube that the user provided is about IT companies, and so are the Yahoo!-del.icio.us, while GM-Opel belong to the automotive industry.</p><p>Thus, there is a need to devise a method for inferring the set of elements that the user is interested in from a single sample (of that set), provided by the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROBLEM STATEMENT</head><p>Achieving the required functionality seems to be a twostep process. The first is to identify in the data repository the structure that the user is referring to in the query, i.e., those that represent the sample that the user already knows to be part of the desired result set. This can be easily achieved using traditional query evaluation techniques that identify in the data repository the structures satisfying the specifications set in the user query. We denote the results of this type of evaluation of a query Q as eval(Q) and refer to it as the user sample.</p><p>The second step is to find the remaining structures of interest for the user based on the structure that has been identified in the first step. Note that there is a query that describes all these structures that the user is looking for, it is just that she is not aware of that query or is not in a position to describe it. Thus, it is natural to assume that all the structures of interest have some commonalities, especially to the one that the user provided as an indicative example. As such, we are interested in finding similar structures to the results of the first step, and return these results as an answer to the user-provided query.</p><p>We refer to this new query paradigm as exemplar queries and the results of their evaluation as relevant answers.</p><p>Definition 1. The evaluation of an exemplar query Qe on a database D, denoted as xmpEval(Qe), is the set {a | ∃s∈eval(Qe) ∧ a≈s}, where a and s are structures in D and the symbol ≈ indicates a similarity function.</p><p>Looking for structures similar and not exact to those explicitly described in the query, reminisces query relaxation. Yet, it is different. In query relaxation, one or more of the query conditions are relaxed, so the results in the answer set are elements that satisfy some of the conditions of the user query. The desired results in our case may satisfy a small number of the query conditions, since the similarity to the structure specified by the user query may be based on characteristics that are different to those mentioned in the user query.</p><p>Note that the definition of exemplar queries is independent of the data model, of the query form, of the retrieved results and of the similarity function. As long as there is a standard query evaluation methodology and some similarity function that can be used that fits a specific use case, the exemplar queries can be answered. This allows maximum flexibility and the ability to use exemplar queries in a wide range of different applications. We are particularly interested in applying exemplar queries in cases where the data is highly heterogeneous and have some relaxed structure. For that reason we have chosen to use a flexible data model, a simple query form, a traditional query evaluation that is based on graph node &amp; edge isomorphism, and a very generic similarity function that is based on edge labelpreserving similarity on graphs.</p><p>For the representation of the data we consider a flexible entity-based data model <ref type="bibr" target="#b11">[11]</ref> that can easily represent various forms of heterogeneous knowledge. In particular, we assume an infinite set of labels L and of values V. The set V consists of an infinite set of atomic values T and of object identifiers O, i.e., V=T ∪O. An object is a representation of a real world entity or concept and is modeled through an object identifier and a set of attributes for that identifier that model characteristic properties of the real world entity or concept. An attribute of an object o∈O is a triple o, l, v , where l∈L and v∈V.</p><p>A database is a finite collection of objects, alongside a finite set of attributes for these objects. The attributes are either connecting the objects or specify some characteristic properties of them. Definition 2. A database D is a pair O, A where O⊆O and A⊂O×L×(O∪T ), both finite.</p><p>A database can be represented as a graph where every object or atomic value in the database is represented as a node and every attribute as a labeled edge from the node representing the object of the attribute to the node representing its value. Thus, we can equivalently say that a database O, A is a graph G(N, E), also denoted as N, E , where the set of nodes N is the set {n | n∈O ∨ ∃ n , l, n ∈A} and the set of edges E is the set {n l → n | n, l, n ∈A}. The expression n l → n , denotes an edge from node n to node n labeled l. We also say that two nodes n1, n2 are equivalent, and denote it as n≡n , if they represent the same atomic value or the same object, i.e., the identifiers of the objects they respectively represent are the same. Definition 3. A database D is edge-preserving<ref type="foot" target="#foot_0">1</ref> isomorphic to a database D , denoted as D D , if there is a bijective function µ from the nodes of D to the nodes of D such that for every edge n1 l →n2 in D, the edge µ(n1)</p><formula xml:id="formula_0">l →µ(n2) is in D .</formula><p>A query is traditionally an expression describing a set of objects alongside a set of conditions they need to satisfy. These conditions describe certain characteristics of these objects and the relationships they may have among them. We make the natural assumption that the objects referenced in a query are somehow all connected, otherwise the query expression would actually constitute two independent queries. Since a query describes a set of objects with attributes, i.e., properties and relationships among them, it can also be seen as a database and consequently represented as a connected graph. Answering a query on a database means finding the database structures that satisfy the query specification. By the term database structures we mean a set of objects and a set of attributes for these objects. In graph terms, answering a query means finding the subgraphs in the database that have a structure like the one of the graph representation of the query. The set of these subgraphs constitutes the answer set of the query. Definition 4. A query Q is a database whose graph representation is a connected graph. An answer to a query Q: NQ, EQ on a database D is any subgraph D : N D , E D of D that is isomorphic to Q, i.e., D Q, and ∀nQ∈NQ, n D ∈N D : µ(nQ)=n D ⇒ nQ≡n D . The set of all such subgraphs, denoted as eval(Q), is referred to as the answer set of the query.</p><p>Note that our implementation of exemplar queries can also be used in cases where queries are flat keyword queries, provided that they are first translated to some structured form. This task is outside of the scope of this work, but there is already a large amount of literature <ref type="bibr" target="#b5">[5]</ref> on that topic.</p><p>Regarding the similarity function, although multiple different forms of similarity can be used we consider edge labelonly isomorphism as the implementation of this similarity, since we found it to be most natural for our purposes. Note that the similarity between structures may range from very</p><formula xml:id="formula_1">Algorithm 1 XQ Input: Database D: N, E Input: User Query Q Output: Set of relevant answers Q 1: Q ← ∅ 2: S ← eval(Q) 3: ns ← selectARandomN ode(S) 4: for each n ∈ N do 5: A ← FindIsomorphicSubgraph(S, ns, D, n) 6: if A = ∅ then 7: Q ← Q ∪ A 8: Rank(Q) 9: return Q</formula><p>high to very low with no clear understanding on where one should stop. For this we will be interested in finding only the k most similar structures, i.e., the top-k, and return them ranked.</p><p>Example 1. Consider the example described in Section 2 and the portion of the database illustrated in Figure <ref type="figure" target="#fig_0">1</ref>. The user query (the exemplar query) is the one shown at the top right corner of the figure. The evaluation of that query on the database results to the user sample that is indicated in the database with the dashed box labeled S. Searching for similar structures (edge-isomorphic structures) to this user sample, results to the two structures indicates with the dotted line boxes labeled A1 and A2, that serve as the relevant answers to the exemplar query. Among the two relevant answers, the neighborhood of A1 has more nodes and edges in common to the user sample S, for instance, the IT Company, the Search Engine and the California, than those that the neighborhood of A2 has in common, hence, A1 should be ranked higher than A2.</p><p>Since the first step of the exemplar query evaluation is a standard search in a graph database for a graph (the user query) we will not spend more time on this. Instead, we focus on the implementation of the second step, which is to devise a method that from a given subgraph (the user sample) finds efficiently other edge-isomorphic subgraphs (the relevant answers) and ranks them based on their neighborhood. The challenging part of this is that there is no clear limit on how large neighborhood to consider, apart from the whole database itself. In our implementation we have considered Freebase, which is one of the largest knowledge graphs available nowadays. Existing works on graph similarity assume search on a large number of small graphs, but searching on a very large graph in the form we consider here has not been considered extensively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE BASIC XQ ALGORITHM</head><p>Once the first step of the exemplar query evaluation has been performed and the user sample S has been identified in the database D, the set of similar to it structures will have to be discovered. This similarity is based on graphisomorphism on the edge labels. To do so, the user sample S will have to be compared with every other subgraph in the database. Instead of considering the exponential number of subgraphs in the database, a node ns from S is randomly selected to serve as a seed. Then all the nodes in the database D are considered, one at a time. For each such node n, it is checked if a subgraph that contains n and is isomorphic</p><formula xml:id="formula_2">Algorithm 2 IterativePruning Input: A database D : N, E Input: A user sample S : NS, ES Output: A set of candidate mappings µ ⊆ NS × N 1: N S d ← d-neighborhood of S 2: Vis ← ∅ Visited nodes 3: nmin ← arg min n∈N S Sel(n) 4: C ← {nmin} Query candidates 5: µ(nmin) ← {n|N S d (nmin) ⊆ N d (n)} 6: for each ns ∈ C do 7: if ns → n s ∈ ES and n s ∈ Vis then 8: µ(ns) ← µ(ns) \ {n|n → n1, n ∈ µ(ns)} 9: µ(n s ) ← {n 1 |n → n 1 , n ∈ µ(ns), N S d (n s ) ⊆ N d (n 1 )} 10: else if n s → q ∈ E S and n s ∈ Vis then 11: µ(ns) ← µ(ns) \ {n|n 1 → n, n ∈ µ(ns)} 12: µ(n s ) ← {n 1 |n 1 → n, n ∈ µ(ns), N S d (n s ) ⊆ N d (n 1 )} 13: C ← C ∪ {n s |ns → n s ∨ ns ← n s } 14: C ← C \ {ns}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>15:</head><p>Vis ← Vis ∪{ns} to S can be constructed. If such a graph is found, then it is added in the result set, i.e., the set of relevant answers. At the end of this procedure the relevant answers are sorted and returned all or only the top-k as an answer to the exemplar query. The sorting task is studied in details in Section 7.</p><p>The pseudo-code of the above steps is described in Algorithm 1.</p><p>The construction of the isomorphic subgraphs (line 5 in Algorithm 1) is done by initially considering a graph G consisting only from the node ns and a subgraph T consisting only from node n, and assuming that an isomorphic function maps ns to n. Then iteratively trying to expand the subgraphs G and T with edges from S and D respectively such that the resulted subgraphs remain edge-isomorphic. If after a number of steps, the graph G becomes equal to S, then the graph T is one of the answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">AN EFFICIENT EXACT SOLUTION</head><p>Searching for possible matches of the user sample in the entire database, as the Algorithm XQ requires is definitely an expensive operation. Sub-graph isomorphism is known to be an NP-complete problem. One can exclude the edges with labels that do not appear in the user sample, but the complexity and the number of operations that need to be done will still be high.</p><p>To improve the performance, we propose an effective way to prune the search space, i.e., the list of database nodes we have to match to the nodes of the user sample in order to find isomorphic structures, leading to a new algorithm FastXQ. For this we devise an efficient technique for comparing nodes, and an algorithm for effectively rejecting pairs of nodes that are bound to not participate in any isomorphic mapping, we call this algorithm IterativePruning. Although this technique may lead to false positives, the schema is effective and reduces significantly the search space. The false positives are subsequently removed by running the traditional isomorphic verification algorithm on them.</p><p>For the first, inspired by <ref type="bibr" target="#b19">[19]</ref>, we devise a technique that is meant to represent the neighborhood in a compact way, and to match the nodes in advance without the need to examine all the nodes in the graph. In more details, the idea is to store in advance a compact representation of the neighborhood of each node, i.e., nodes and edges that are at a fixed distance d from each node. This provides an effective way to compare nodes, allowing the pruning to remove the non-matching nodes without having to actually visit their neighborhood.</p><p>A basic concept of our approach is also the notion of neighborhood. We call d-neighbor of a node n a node that is reachable from n in at most d steps, i.e., the shortest path from n to this node is no longer than d. For every node in the database we compute a table consisting of the number of nodes that are reachable from that node at some specific distance and with a path ending with a label . In other words, for a node n, for every label and for every distance i we keep the cardinality of the set W n,l,i , where</p><formula xml:id="formula_3">W n, ,i = {n1|n1 → n2 ∨ n1 ← n2, n2 ∈ Ni-1(n)}</formula><p>In practice, since doing so for every node in the database is expensive in terms of space, we employ an implementation similar to the idea of the inverted indexes. We use an index structure that for every label and for every distance can provide a list of all the nodes that have a label at the respective distance, and the cardinality of such labels.</p><p>Note that, once computed for each label and each i ≤ d, W compactly represents the neighborhood of a node. For this reason, if we compute W for the nodes of the user sample as well, we can compare nodes in the database and nodes in the user sample, in order to know in advance which nodes can be pruned. We denote the d-neighborhood of a node ns of graph S by N S d (ns). A node n ∈ N of D = N, E matches a node ns ∈ NS in the user sample, and therefore is not pruned, if for each label l and a distance i ≤ d,</p><formula xml:id="formula_4">|W n, ,i | ≥ |W ns, ,i | (ref.</formula><p>to Theorem 1 for a formal proof).</p><p>Using the ability to compare nodes through the compact representation of their neighborhood, we devise a way of fast eliminating pairs of the user sample and database nodes, respectively, that are unlikely to participate in an isomorphism match. Traditional techniques that compute isomorphisms compute matches of the different nodes independently and then try to combine the results.</p><p>We believe that this process can be optimized further, if the comparison of the nodes takes into consideration the previously computed matches. To implement this idea we adopt the notion of simulation <ref type="bibr" target="#b27">[27]</ref>. A graph simulates another graph if it exists a way to map each transition on the first graph with a transition in the second. Definition 6 (Simulation). Let G1 = N1, E1 and G2 = N2, E2 be two graphs. G2 simulates G1 if there exists a relation R, such that, for every node n1 ∈ N1 and n2 ∈ N2 for which (n1, n2) ∈ R and n1 → n 1 , there exists a n 2 such that n2 → n 2 and (n 1 , n 2 ) ∈ R Deciding whether one graph simulates another graph is known to be solvable in polynomial time with respect to the size of the graph <ref type="bibr" target="#b16">[16]</ref>. The main idea of our approach is to perform multiple simulations of the user sample on the database graph while pruning the non matching nodes iteratively. The algorithm works as follows. First, it calculates the d-neighborhood for each node of the user sample. Then, a user sample node is selected as starting node. Although any node is a valid starting node we propose to pick the node with the lowest selectivity among the user sample nodes, with the hope to reduce the number of candidate matches between the user sample and database nodes. The selectivity is an estimate of the number of possible matches generated from a user sample node. The idea is to consider the number of adjacent nodes of a user sample node and the frequency of the labels of the edges connected to it. The selectivity of a node n is</p><formula xml:id="formula_5">Sel(n) = f req(n) + d i=1 1 i W n, ,i |E |,<label>(1)</label></formula><p>where the frequency f req(n) of a node n is defined as the sum of the number of outgoing and incoming edges. Similarly, we define the frequency of a label as the number of edges in the graph having label and we denote it as |E |. The less probable the combination of labels at a certain distance is, the lower the selectivity and the higher is the expected pruning power.</p><p>After having selected the starting node nmin, the algorithm retrieves the nodes in the database that match the node nmin and marks them as candidate mappings µ(nmin), where µ ⊆ NS × N is the mapping between user sample and database nodes that the algorithm will compute. Then the algorithm iteratively checks, for each user sample node ns not yet visited, that each adjacent edge of ns matches the edges adjacent to the nodes n ∈ µ(ns), verifying the label and the direction of the edge. If it does not match, then n is removed from µ(ns), otherwise we consider a node n1 adjacent to n a candidate for the user sample node n s adjacent to ns, i.e., we insert it into µ(ns), if the condition described by Theorem 1 holds. Finally, the user sample node ns is marked as visited and removed from the candidate list. The steps of the algorithm are described in pseudo-code in Algorithm 2.</p><p>The following theorem guarantees that Algorithm 2 does not falsely discard any node while traversing the user sample nodes. However, it may introduce false positives, i.e., nodes that match the user sample nodes but are not included in an isomorphism. </p><formula xml:id="formula_6">: NS → N , then ∀ns ∈ NS, N S d (ns) ⊆ N d (n), n ∈ N, n ∈ µ(ns) Proof. (by contradiction) Suppose that (ns, n) ∈ µ, but N S d (ns) ⊆N d (n), then there exists i, 1 ≤ i ≤ v and a label such that |W ns, ,i | &gt; |W n, ,i |.</formula><p>For this reason we can say that there exists n s ∈ W ns, ,i , connected to n s ∈ Ni-1(ns) by , i.e., n s → n s . The latter assumption is true since we assume that µ is a subgraph-isomorphism. However, there does not exist any µ(n s ) → µ(n s ), which contradicts the subgraph-isomorphism hypothesis.</p><p>Additionally, a guarantee that the algorithm correctly computes multiple simulations of the user sample S, is offered by the following theorem.</p><p>Theorem 2. Given a user sample S, if Algorithm 2 terminates with a complete exploration of the nodes S, then there exists in µ a simulation R of the user sample S.</p><p>(The proof is omitted due to space limitations)</p><p>In the worst case, Algorithm 2 will have to traverse the entire database for each node. Thus, the complexity of the algorithm is O(|N | * (|NS| + |ES|)). Since the user sample is typically very small, the algorithm is, for the majority of practical cases, linear to the size of the graph. In implementation, to reduce the time computation of µ we used a hash map for storing the nodes of the user sample and their partial mappings.</p><p>The set of candidate mappings computed by Algorithm 2 is used to eliminate those nodes of the database that will never participate in an isomorphism with the user sample nodes. The reduced-size database that results from this elimination can then be fed to the XQ Algorithm of Section 4. We refer to this new algorithm as FastXQ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">AN APPROXIMATE SOLUTION</head><p>In the previous section, we described an exact solution to prune the search space, removing nodes that cannot possibly match the user sample. In this section, we propose an additional method that removes in advance nodes that are likely to not be relevant for the user, we call this method ApFastXQ.</p><p>We aim at restricting in advance the search space in order to search for solutions only in the portion of the graph that is more likely to contain relevant answers. As already mentioned in the previous sections, both pairs Yahoo!-Flickr and GM-Opel are part of the solution space, but the pair Yahoo!-Flickr is more relevant to the user, and therefore we would like to restrict our search only to the subgraph that is containing the second but not the first.</p><p>In the following, we describe how we model this portion of the graph, which we call Relevant Neighborhood (Section 6.1). That portion is the subset of nodes with higher proximity to the nodes of the user sample. The intuition behind this is that nodes in the graph that are located far from the user sample will be also semantically distant from the user's intention as expressed in the exemplar query.</p><p>We model a relatedness measure based on the distance in the graph, and we use it to prune away nodes that are far away from the user sample before even looking for isomorphic structures.</p><p>It is clear that, while the approach described in the previous section is exact (does not discard any valid answers), this second approach is approximate: some correct answers could potentially be filtered out as they fall out of the Relevant Neighborhood. For this reason, we propose a principled way of measuring the relatedness and for pruning the graph, aimed at discarding only irrelevant solutions. We implement a function that iteratively retrieves the Relevant Neighborhood without traversing the entire graph (Section 6.2). As we show later (Section 8), thanks to the RelevantNeighborhood algorithm, by operating in this special portion of the graph, we can effectively reduce the search space. The restricted search space can then be given as input to Algorithm 1, without sacrificing the quality of the results. We can still apply on this subgraph the pruning techniques presented in the previous section and then look for isomorphic </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Identifying the Relevant Neighborhood</head><p>To find the subset Qρ of the set of answers Q, that contains the answers that are relevant to the user, we assume to have some measure of relevance ρ. Since the only evidence of the user's intent is the input query Q and the corresponding user sample S we have found in the first step of the exemplar query evaluation, we can define the set of relevant answers as Qρ = {A ∈ Q|ρ(A , S) &gt; τ }, with τ &gt; 0 being a minimum threshold.</p><p>Since Qρ is clearly a set of subgraphs in D, we say that the set of solution Qρ is contained in the subgraph Dρ ⊆ D, which is any subgraph of D that contains all the members of Qρ, relevant answers, and none of the remaining irrelevant solutions in Q\Qρ. For this reason we call Dρ the Relevant Neighborhood of the sample S.</p><p>This portion of the graph, being a subgraph itself, is identified by the subset of relevant nodes Nρ ⊆ N . Those are nodes whose relevance measure ρ is within the a threshold τ , i.e., Nρ = {n ∈ N |ρ(n, S) &gt; τ }. Operationally, we first identify the set of relevant nodes Nρ, and then with only those nodes, we easily construct the subgraph Dρ ⊆ D.</p><p>In our solution, we implement ρ as a distance measure on the graph, such that it measures the distance of every node from the nodes of the sample NS, and we keep only nodes that are within a certain distance threshold from the sample. In order to compute this distance we propose the Adaptive Personalized PageRank Vector (APPV), an extension of the Personalized PageRank Vector (PPV), designed to exploit the properties of our problem. This is implemented by the RelevantNeighborhood algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">The RelevantNeighborhood Algorithm</head><p>Our solution models the computation of the Personalized PageRank vector (PPV) <ref type="bibr" target="#b18">[18]</ref> which is used as an estimate of the distances of the nodes in the graph from the subset of nodes in the user sample. In the literature Personalized PageRank <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b18">18]</ref> is a well known technique that computes the PageRank biased towards the preferences of the user. In our case, user preferences are expressed through the query Q and for this reason we initialize the preference vector according to the nodes in the user sample S, which models the query Q in the database.</p><p>The main difference between the original PPV model and our solution, APPV, lays on the semantic of edges. Tra- ditionally, edges between nodes are treated equally as they usually represent just a link from one webpage to another (i.e., they are of the same kind). In contrast, our model adapts to the various edges and their labels, according to S. In particular, the edges in our model may represent different kinds of relationships. It is therefore natural to differentiate based on the information carried by different edges, as some relationships are more informative than others. Moreover, labels that do appear in the user query should be treated differently when computing the PageRank, because they represent the user preference.</p><p>Figure <ref type="figure" target="#fig_3">2</ref> depicts the output of the computation on the graph of our running example. Here all the nodes have been assigned the weights from the final APPV, computed using the set of nodes in the sample as initial preferences.</p><p>The set Nρ, which satisfies the selectivity requirement, consists of nodes with Personalized PageRank score higher than a minimum threshold τ , 0 &lt; τ &lt; 1.</p><p>This whole process, presented in Algorithm 3, returns the portion of the graph that is combined with Algorithm 2 to produce a restricted database D which is provided to Algorithm 1 instead of D.</p><p>Assume a model of the database D = N, E , and let A D be the adjacency matrix of this graph. If |N | is the number of nodes in the database, then A D is an |N | × |N | square matrix. In this matrix, we have that 0 &lt; A D ij ≤ 1 if and only if the node i has a relationship e ij with node j with label ; otherwise, we have A D ij = 0. In this way, the element A D ij models the amount of information that is transferred from node i to node j by the edge e ij as a function of its label . In our solution, the values in A D are proportional to the amount of information <ref type="bibr" target="#b29">[29]</ref> carried by the edge e ij , which is:</p><formula xml:id="formula_7">I(e ij ) = I( ) = log 1 P ( ) = -log P ( )<label>(2)</label></formula><formula xml:id="formula_8">P ( ) = E |E| (<label>3</label></formula><formula xml:id="formula_9">)</formula><p>where E is the set of edges with label . Note that the frequency of a label can be easily computed in the database.</p><p>In order to account for the importance of the edges in the user sample, we additionally define matrix A S , which is constructed from the adjacency matrix of the database, but where only entries for edges whose label appears also in S are assigned a non-zero value. for each ni ∈ p do 18:</p><formula xml:id="formula_10">v[ni] ← v[ni] + p[ni] 19: return v</formula><p>and j are connected by an edge and that edge has a label that appears as label of one edge in the user sample S, and with A S ij =0 otherwise. We then combine the two matrices into the matrix Ā = A D + A S and normalize it. Under this transformation Ā becomes the transition probability matrix for the knowledgebase graph, where more relevance is given to edges carrying more information, as well as to edges with labels that appear in the query. We also define p, an |N | × 1 column vector, which serves as the normalized preference vector for which p[i] = 0 iff ni ∈ NS, i.e., 0 &lt; p[i] ≤ 1 if and only if the node i is in S. Given the column normalized transition probability matrix Ā, the teleportation probability c, and the preference vector p, our technique adheres to the Personalized PageRank semantics <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b18">18]</ref>.</p><p>Thus, the APPV v is defined as the stationary distribution of the Markov chain with state transition given by the matrix</p><formula xml:id="formula_11">(1 -c) Āv + cp (4)</formula><p>where the teleportation probability c ∈ (0, 1) is typically ≈ 0.15, with small changes in this value having little effect in practice <ref type="bibr" target="#b26">[26]</ref>.</p><p>The exact computation of this vector typically requires O(n 2 ) time and space. Performing the computation through power iteration requires O(nt) time, where t is the number of iterations to be performed. Nevertheless, this computation is still not practical for very large graphs.</p><p>In order to compute this value fast, we extend the template proposed in <ref type="bibr" target="#b3">[3]</ref> and apply an approach similar to the weighted particle filtering procedure proposed in <ref type="bibr" target="#b21">[21]</ref> but extended to correctly take into account the teleportation probability, and to consider the non-uniform edge weights that we previously introduced. The extension is shown in Algorithm 4. Algorithm 4 simulates a set of 1/τ floating particles (line 2) starting from each node with a non-zero value in p. At each iteration (lines 6-15), they split among the neighbors of the node they are currently visiting, but we prevent them to split to arbitrarily small sizes, limiting them to have minimum size τ (lines 12-13). When spreading the particles among the neighbors, the algorithm gives preference to the edges with higher weights. The restart probability c will dissipate part of the particles at every iteration (line 7), and the algorithm will stop when no more particles are floating around.</p><p>At the end of the algorithm, we return the APPV containing the scores that have been accumulated through each iteration on every node. We then keep the subset of the graph containing only those nodes with a score higher than some threshold and the edges connected to them (line 6-7 in Algorithm 3). Since we are dealing with an iterative approximation, we will take all nodes which have been visited by at least one particle, which actually means that we set the threshold to be equal to τ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RANKING QUERY ANSWERS</head><p>Once the answers have been computed from the user sample, they need to be ranked in order to either be returned sorted to the user that posed the query, or to select only the k most promising candidates, i.e., the top-k. To do this, we introduce a novel ranking function that is a linear combination of two scores, namely, the structural similarity score S based on the d-neighborhood and the amount of information as provided by the Personalized PageRank, which indicates the importance of a label in the graph. The score of each answer is computed by using the above two parameters to compare the answer to the user sample.</p><p>Most node similarity measures proposed in the literature are based on the concept of graph similarity and isomorphism. This is the case for Graph Edit Distance <ref type="bibr" target="#b13">[13]</ref>, which is computed with a reduction to graph isomorphism, and is therefore inapplicable to our problem, due to its high time complexity. A different method is proposed in <ref type="bibr" target="#b19">[19]</ref> and is based on a vectorial representation of nodes. This idea seems suitable for our settings, thus we extended it in order to capture the differences among nodes that emerge when taking into account the edge-labels of the neighbors. We also embed distance information aiming at giving different weights to nodes based on their distance from the sample. Thus, for every node n we build a vector containing a value for every label ∈ L in the graph, and we compute this score as</p><formula xml:id="formula_12">σ(n, ) = d i=1 I( )|W n, ,i | i 2<label>(5)</label></formula><p>Given the vectorial representation of two nodes, we compute the node similarity S using a metric for vectors, such as the Jaccard, euclidean distance or cosine similarity. Note that our vectorial representation contains already the computed score σ. In our experiments we use cosine similarity but any other similarity metrics can also be used. Therefore, the structural similarity between a node ns of the user sample and n is computed as follows:</p><formula xml:id="formula_13">S(ns, n) = L σ(ns, )σ(n, ) L σ(ns, ) 2 L σ(n, ) 2<label>(6)</label></formula><p>The structural similarity above does not take into account the proximity measure of the results with respect to the user sample. Therefore, we consider a linear combination, parametrized by λ, between the node similarity (structural) and the Personalized PageRank (proximity) as follows.</p><formula xml:id="formula_14">ρ(ns, n) = λS(ns, n) + (1 -λ)p[n]<label>(7)</label></formula><p>where p[n] is the APPV as defined in the previous section.</p><p>The final score of a query answer with respect to the user sample S is the sum of ρ(ns, n) for every node ns in the user sample with respect to the corresponding (isomorphic) node n in the query answer. Note that the choice of λ is data dependent. A value λ close to 1 favors results that are mostly similar to the neighbors of the user sample nodes. On the other hand, a value close to 0 will take into account only solutions that are close to the original query. For this reason, we can see λ as a diversification parameter that depends on the user and on the data. This is also the approach taken by most diversification models <ref type="bibr" target="#b1">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">EXPERIMENTAL EVALUATION</head><p>In this section, we experimentally validate our solution by comparing it to other approaches, and measuring its performance.</p><p>Queries: We extracted 90 real queries from the AOL query log to use as the query test set, and manually mapped them to the knowledge base<ref type="foot" target="#foot_1">2</ref> . These queries are highly heterogeneous in terms of size and frequency of the edge labels. We then used 50 of these queries for the user study.</p><p>Datasets: We downloaded a full dump of the Freebase knowledge base<ref type="foot" target="#foot_2">3</ref> in August 2012. We removed every triple that is used as internal specification for the community (such as the user and groups data and discussion topics) obtaining a fully connected graph of 53 million nodes and 213 million edges (occupying 24GB of main memory). To the best of our knowledge this is the biggest graph used in this context in the literature, and the first time that the entire Freebase graph is used for this purpose. While related works <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b31">31]</ref> evaluate their methods on just a small part of Freebase, we explored solutions that scale to the full size of the knowledge-base. In the following we refer to it as Real. Based on Real we generated 10 synthetic datasets embedding 20 samples of the test set in different points of the graph. We performed a breadth first traversal of the graph from a fixed starting node and we randomly chose to embed an answer according to a distribution that decreases exponentially with the distance from the starting node (thus modeling answers at varying distances). Only a fixed number of answers are embedded in the graph. To test the scalability with respect to the graph size, we generated graphs having 0.5M, 1M, 5M, 10M and 20M nodes, and 1K embedded queries. We denote them as GSize-x where x is the graph size. Similarly, to test the scalability with respect to the number of answers to retrieve, we generated graphs with 10M nodes, and 0.5K, 1K, 2K, 5K and 10K embedded answers. We denote them as QSize-x where x is the number of generated answer.</p><p>Experimental Setup: Due to space limitations, we do not report the experiments with varying the parameter d of It-           erativePruning (Section 5). For the rest of this paper, we use d = 3 since it proved to be a reasonable choice and allowed us to compute answers in less than 1 second. We also observed that λ = 0.3 (see Section 7) is a good compromise for retrieving diverse and qualitative results. In Section 8.4 we study the effect of varying the threshold parameter τ (see Section 6.2), for which the default value is 0.003. All the reported results are averages over 5 consecutive runs. We implemented our solution in Java 1.6, and ran the experiments on a i686 Intel Xeon X3220 2.40GH, 32Gb RAM machine over Linux kernel v2.6.30. The graphs are loaded into main memory using our graph library available under open source license 4 .</p><p>Implemented Algorithms: Apart from FastXQ and Ap-FastXQ, we implemented three additional algorithms from related works: QueryReformulation: An algorithm that produces query reformulations by mining sessions from query logs in a termlevel fashion <ref type="bibr" target="#b32">[32]</ref>. The model is trained on the AOL query 4 https://github.com/mutandon/Grava log and the suggestions are based on our query test set. EQ-Graph: Entity-query graph is a model that computes serendipitous suggestions starting from entity mentions in a page <ref type="bibr" target="#b9">[9]</ref>. We manually adapted our query test set to work in this setting associating to each node the corresponding Wikipedia page (or the best Wikipedia page that represents the node). The model is trained on a big query log from the Yahoo! Search Engine.</p><p>NeMa: This algorithm <ref type="bibr" target="#b20">[20]</ref>, and other previous works, are based on the assumption that there exists a truly small set of correct answers to a graph query. In our case, this property does not hold: what we need to find is a generalization of the original sample already present in the dataset. Therefore, we implement their technique taking into account edge label matches instead of node matches. The authors kindly provided us a C++ implementation (compiled using gcc v4.4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of Experiments:</head><p>We set up user studies, where we evaluated the usefulness (Section 8.1) of our approach, and also compared it (Section 8.2) to the related works we discussed above. Section 8.2 further studies the performance and quality of our solutions when compared to a query answering system for graphs. In Section 8.3, we study the impact of Itera-tivePruning on query time, and the correlation between pruning time and node selectivity. Section 8.4 presents the effect of τ on query time. Finally, scalability experiments of the proposed algorithms are described in Section 8.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of Results:</head><p>Our user studies demonstrate that 92% of the users exemplar queries are relevant and useful for search tasks, and that existing approaches are not able to provide effective solutions for our problem, while our method identifies meaningful results with 81% precision. When compared to existing approaches, our algorithm retrieves results almost 3 orders of magnitude faster than a state of the art graph matching algorithm. We observe that the proposed pruning strategy reduces the query-time by 30% on average, with even higher improvements when we choose starting nodes with low selectivity. Finally, the last set of results demonstrate the scalability of our approach to the largest knowledge graph available in the field (53M nodes, 213M edges), while maintaining low response time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Usefulness</head><p>In order to assess the quality of the proposed solution, we conducted the following user study. We asked 94 users (uniformly distributed with respect to education level, age and country) to evaluate our system. For each query in the test set, we provided an explanation of the topic, the query intention, and our answer set with the top-10 results provided by our ranking function. We asked each user to rate each result as irrelevant, weakly related, or very related with respect to the topic and the expressed query intention. Each user evaluated between 2 to 10 queries (on average 8). The users provided 4540 marks in total, shown in Figure <ref type="figure" target="#fig_4">3</ref>: 81% of our results are marked as relevant (weakly or strongly) and only 19% of them are not considered relevant suggestions. Out of the 427 suggestions we produced, 172 (i.e., 40%) are judged highly relevant by more than 50% of the users. Note also that each exemplar query contains at least one relevant (weakly or strongly) result for 99% of the users. Moreover, we ask each user to express her opinion with respect to (a) the idea of using examples as a search paradigm, (b) whether she already had the need of searching using exemplar queries, and (c) the usefulness of the system in general. As shown in Figure <ref type="figure">4</ref>, 92% of the users considers the exemplar queries paradigm and the overall system useful for retrieving additional and relevant information. Moreover, 62% of the people interviewed declared that they had already had the need to perform this kind of exemplar queries search in the past (but there was no system to support them).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Comparison to Previous Work</head><p>In the following we compare our method against two different approaches: (a) algorithms that produce related queries, and (b) an approximate query answering technique for graphs.</p><p>Related Queries: We implemented and compared with the methods QueryReformulation and EQ-Graph mentioned earlier, through a user study similar to the one presented in Section 8.1. For each query in the test set, we presented to users three groups of suggestions: one produced with our method, and one produced by each one of the two methods above. We then asked users which of the three groups of suggestions they considered the most helpful for each query task.</p><p>The results, depicted in Figure <ref type="figure" target="#fig_1">5</ref>, show that in 64% of the cases the users preferred our solution to the other two. Furthermore, for 78% of the queries that received more than 2 marks, the majority of users preferred our solution. In 18% of the cases none of the proposed solutions were satisfying, neither the answers proposed by our model nor those produced by the other algorithms. Overall, the two competing approaches together was preferred by less than 30% of the users, none of them choosing the two approaches in all the queries.</p><p>Approximate Query Answering on Graphs: We now present the comparison between our approach and NeMa <ref type="bibr" target="#b20">[20]</ref>, a state of the art technique for answering approximate queries on graphs. Since on Real a single query takes NeMa more than 13 hours to process, we test NeMa on graphs obtained after applying RelevantNeighborhood on our query test set, thus giving it an advantage. The results in Figure <ref type="figure" target="#fig_6">6</ref> show that NeMa is almost three orders of magnitude slower than our algorithm. This suggests that a query answering technique for graphs is not applicable to our setting.</p><p>We also provide anecdotal evidence comparing the top-5 results from our method and NeMa. Tables <ref type="table" target="#tab_2">1</ref> and<ref type="table" target="#tab_3">2</ref> show the top-5 results of NeMa for two different exemplar queries compared with the results of our algorithm, shown in Tables 3 and 4 (for our algorithm, we report the top-2 results containing query terms, the top-2 results not containing query terms, and for reference, the lowest ranking result). We observe that if the structure of the exemplar query is complex (e.g., it contains cycles), NeMa fails to find the correct answers, mapping different query nodes on the same graph node as depicted in Table <ref type="table" target="#tab_3">2</ref>-row 3, where the same graph node,"Oral Transmission", is used twice. Actually, 87% of the answers produced by NeMa are not isomorphic to the test queries, producing results that contain the same node more than once, and thus, leading to poor results. Furthermore, the top answers proposed by NeMa for Q2 contain diseases that are not sexually transmitted (e.g., diabetes that is ranked 2nd), a situation that does not occur with our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Pruning Effectiveness</head><p>In the next experiments we show the impact of pruning on query time and the effect of selectivity on pruning time.</p><p>Pruning impact: We perform a batch of experiments using the query test set, comparing the query time with and without applying IterativePruning, and depict the results in Figure <ref type="figure">7</ref>. (We note that, as discussed in Section 5, our pruning technique does not modify the quality of the final result set, neither does it discard any relevant result.) Applying pruning results in 3% to 99% less query time. Moreover, we observe that for 17% of the queries, pruning does not affect the query time. We notice that pruning is more effective when the frequencies of the edge labels of the sample in the graph are high, since a large part of the graph is eliminated with fewer operations. This observation allows us to run the IterativePruning on demand. On average, Iter-ativePruning reduces query time by 30% and the graph size by 80% (by removing non-matching edges). This entire batch of experiments takes 38 minutes to execute without pruning and 17 minutes with pruning, saving 55% of the total time.</p><p>Pruning Selectivity: We study the performance of pruning in terms of time as a function of the selectivity of the starting node in the sample. Remember that low selectivity means better pruning (see Equation <ref type="formula" target="#formula_5">1</ref>). We run experiments measuring the correlation between time and selectivity, selecting the different nodes of the sample as starting nodes. The results show a positive correlation of 0.57 between selectivity and time performance, which is statistically significant at the 0.01 significance level. We conclude that starting from a low selective node positively impacts the pruning time, with savings up to 87%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Calibrating RelevantNeighborhood</head><p>We study the effect of τ on RelevantNeighborhood in terms of time and quality of the results. Parameter τ of RelevantNeighborhood determines the degree of approximation of the estimation of PPV of each node. In Figure <ref type="figure" target="#fig_13">12</ref>, we plot the size of the neighborhoods (counts of nodes and edges) visited for increasing values of τ (from 0.0005 to 0.01), and the number of answers retrieved in each case. The observed decrease in the number of visited nodes and edges is directly proportional to the number of answers retrieved, and exhibits an exponential decay as τ increases. Figure <ref type="figure" target="#fig_14">13</ref> shows that with larger values of τ the time needed to compute the results decreases in the same manner.</p><p>We now evaluate the quality of the answers produced by ApFastXQ, by measuring precision at 1,5,10,50,100, where precision at k (abbreviated P @k) is defined as the fraction of results produced by FastXQ that are also produced by ApFastXQ in the first k positions. Table <ref type="table" target="#tab_5">5</ref> shows that overall precision is high, especially for the top positions. Any value of τ between 0.003 and 0.005 is a reasonable choice, leading to high precision and an average query time of less than 2.4 seconds. Evidently, the choice of this parameter depends on the application. In a biological setting, where precision is more important than time, τ = 0.002 could be a reasonable choice, producing very precise answers in about 10 seconds. On the web, where timely answers are needed, τ = 0.005 can still offer precise answers in the top positions, in less than 1 second. In our experiments, we used τ = 0.003. τ P @1 P @5 P @10 P @50 P @100 0. <ref type="bibr">002</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Scalability</head><p>We present the scalability experiments as a function of the number of answers and the size of the database. In Figure <ref type="figure" target="#fig_7">8</ref> we show the number of visited edges and nodes, as well as the number of results when the number of embedded answers increase (recall that QSize-x contains exactly x answers for each exemplar query). The time of ApFastXQ is the sum of the times shown in Figure <ref type="figure" target="#fig_7">8</ref>. We observe that using Rel-evantNeighborhood as the number of answers increases from 60 to 100, the number of explored nodes remains almost the same. This behavior is expected, since Relevant-Neighborhood does not explore more nodes as long as the structure of the graph remains almost unchanged, but it finds more answers embedded in the same subgraph.</p><p>Conversely, if the size of the dataset increases and the number of answers is fixed (Figures <ref type="figure" target="#fig_10">10</ref> and<ref type="figure" target="#fig_12">11</ref>) it is less likely to find answers close to the exemplar query. As expected, since the number of nodes explored is almost the same (see Figure <ref type="figure" target="#fig_10">10</ref>) the time is constant, even though we move from 500k to 20M nodes. This supports our design choice, since changes in the peripheral part of the graph do not affect the APPV algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">RELATED WORK</head><p>Query Modification. Many different works study ways to provide the user with answers that may be of interest even if they were not explicitly requested in the query. Query refinement <ref type="bibr" target="#b22">[22]</ref> extends the user query in order to retrieve more precise results <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b32">32]</ref> using some external knowledge. In our work we are not trying to alter the query, but only use it as a sample that can lead us to additional queries generating resources of interest. Query relaxation <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b23">23]</ref>, on the other hand, relaxes an over-specified query that returns no answers to allow a non-empty answer set to be produced. Our approach is somehow similar, however, query relaxation is driven by the conditions in the query. It will not include results that are similar to those the user query generates, unless they are satisfying a subset of these conditions. In contrast, our approach adds additional results by using similarities at the data level. Related queries deal with the discovery of queries generating results of possible interest to a user based on a query that the user has already posed. Their discovery is based on information like query logs <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b32">32]</ref>, document corpuses <ref type="bibr" target="#b7">[7]</ref>, knowledge bases <ref type="bibr" target="#b25">[25]</ref> or wikis <ref type="bibr" target="#b9">[9]</ref>. Since our work can also be used to suggest related queries as explained in the introduction, we can be seen as complementary to these approaches, offering a new way of generating related queries.</p><p>Another group of works that do not try to extend/improve the query results with new data, but only to organize them in some way that is more comprehensive to the user, is the one of faceted-search <ref type="bibr" target="#b12">[12]</ref> and query categorization <ref type="bibr" target="#b30">[30]</ref>. Despite the fundamental difference from our approach, these works are also aiming at increasing the user satisfaction.</p><p>Query Answering on Graphs. Most works on finding a graph structure in a large graph exploit graph edit distance that measures similarity between subgraphs <ref type="bibr" target="#b13">[13]</ref>. Computing the graph edit-distance is NP-hard and numerous indexing and pruning techniques have been proposed to improve performance <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b33">33]</ref>. Our solution is mainly related to works in which the representation of a portion of the neighborhood of a node is used to prune in advance nodes that are unrelated to those in the query <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b34">34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">CONCLUSIONS</head><p>In this paper we introduced a novel query paradigm called exemplar queries. We formally defined it and described how it is applied on a graph-based data model, where it requires search for graph-isomorphism in order to evaluate a query. We discussed why traditional query answering on graphs is not applicable in this context, and proposed an exact solution based on an effective and theoretically sound pruning technique, alongside an efficient approximation algorithm. Moreover, we proposed a novel pruning technique based on the concept of d-neighborhood and of bi-simulation. We evaluated the efficiency and effectiveness of our approach using one of the biggest multigraphs in the literature, and coupled our results with a user study that confirms the usefulness of the proposed system. As future work, we are considering to study the case in which we have multiple exemplar queries for the same desired answer set.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Exemplar Query Evaluation evaluation and findings. Finally, we present the related work in Section 9, and conclude in Section 10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 5</head><label>5</label><figDesc>(d-neighbor). Let n ∈ N be a node of a database D = N, E . The node ni ∈ N is a d-neighbor of n if there exists a shortest path from n to ni of length at most d. The d-neighborhood of n, denoted as N d (n), is the set of d-neighbors of n.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 1 .</head><label>1</label><figDesc>Given a database D = N, E and a user sample S, let N d and N S d be the d-neighborhood of D and S respectively. If there exists a subgraph-isomorphism µ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A visualization of APPV</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Algorithm 3</head><label>3</label><figDesc>RelevantNeighborhood Input: User Sample S : NS, ES Input: Database D : N, E Input: Teleportation probability c Input: Threshold τ Output: Subgraph D ⊆ D 1: Ā ← AdjacencyNormalized(D, S) 2: p ← [0] × N 3: for each qi ∈ NS do 4: p[qi] ← 1/|NS| 5: v ← ComputeAPPV( Ā, p, c, τ ) 6: N D ← Nearest(N, v) 7: D ← GetSubgraph(D, N D ) 8: return D</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Percentage of relevant and irrelevant results per query</figDesc><graphic coords="9,202.68,195.92,84.48,51.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Time vs Size of graph with NeMa and our approach (Real dataset).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Count vs number of answers (QSize-x dataset).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Time vs number of answers (QSize-x dataset).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Count vs number of nodes (GSize-x dataset).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Time vs number of nodes (GSize-x dataset).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Count vs Ap-FastXQ threshold (Real dataset).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Time vs Ap-FastXQ threshold (Real dataset).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>In other words, we construct an |N | × |N | square matrix with 0 &lt; A S ij ≤ 1 if the nodes i</figDesc><table><row><cell cols="3">Algorithm 4 ComputeAPPV</cell></row><row><cell cols="2">Input: Adjacency Matrix</cell><cell>Ā</cell></row><row><cell cols="2">Input: Node vector p</cell></row><row><cell cols="3">Input: restart probability c</cell></row><row><cell cols="2">Input: threshold τ</cell></row><row><cell cols="3">Output: Approximate APPV v</cell></row><row><cell cols="2">1: for each qi ∈ p do</cell></row><row><cell>2:</cell><cell>p[qi] ← p[qi] × 1/τ</cell></row><row><cell cols="2">3: v ← p</cell></row><row><cell cols="3">4: while ∃ ni ∈ p | p[ni] = 0 do</cell></row><row><cell>5:</cell><cell>aux ← [0]</cell></row><row><cell>6:</cell><cell cols="2">for each ni ∈ p | p[ni] = 0 do</cell></row><row><cell>7:</cell><cell cols="2">particles ← p[ni] × (1 -c)</cell></row><row><cell>8:</cell><cell cols="2">for each ni → nj ∈ D (Sort by Āij Desc.) do</cell></row><row><cell>9:</cell><cell cols="2">if particles ≤ τ then</cell></row><row><cell>10:</cell><cell>break</cell></row><row><cell>11:</cell><cell cols="2">passing ← particles × Āij</cell></row><row><cell>12:</cell><cell cols="2">if passing ≤ τ then</cell></row><row><cell>13:</cell><cell cols="2">passing ← τ</cell></row><row><cell>14:</cell><cell cols="2">aux[nj] ← aux[nj] + passing</cell></row><row><cell>15:</cell><cell cols="2">particles ← particles -passing</cell></row><row><cell>16:</cell><cell>p ← aux</cell></row><row><cell>17:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Top-5 results with NeMa for "Google YouTube Menlo Park"</figDesc><table><row><cell>Q2: Condom -Sex -HIV infection</cell></row><row><cell>Water purification -Fecal-oral route -Cholera</cell></row><row><cell>Smoking cessation -Vector -Diabetes mellitus</cell></row><row><cell>Oral Transm. -Cytomegalovirus Infections -Oral Transm.</cell></row><row><cell>Oral Transmission -Cerebral palsy -Cytomegalovirus</cell></row><row><cell>Water purification -Fecal-oral route -Cholera</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Top-5 results with NeMa for "Condom Sex HIV infection"</figDesc><table><row><cell></cell><cell>Q1: Google -YouTube -Menlo Park</cell><cell>Q2: Condom -Sex -HIV infection</cell></row><row><cell cols="2">Google -AdMob -Menlo Park</cell><cell>Safe sex -Sex -HIV infection</cell></row><row><cell cols="2">Google -DoubleClick -Menlo Park</cell><cell>Sexual abstinence -Sex -HIV infection</cell></row><row><cell cols="2">Yahoo! -del.icio.us -Santa Clara</cell><cell>Safe sex -Vertical transmission -Hepatitis B</cell></row><row><cell cols="2">Microsoft -Powerset -Albuquerque</cell><cell>Safe sex -Vertical transmission -Syphilis</cell></row><row><cell cols="2">A&amp;E Television -Lifetime Ent. Services</cell><cell>Hand washing -Droplet Contact -Cold</cell></row><row><cell>Table 3:</cell><cell>Results for exemplar query "Google</cell></row><row><cell cols="2">YouTube Menlo Park"</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4 :</head><label>4</label><figDesc>Results for exemplar query "Condom Sex HIV infection"</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5 :</head><label>5</label><figDesc>Precision of ApFastXQ varying τ</figDesc><table><row><cell>1</cell><cell>0.99</cell><cell>0.99</cell><cell>0.85</cell><cell>0.75</cell></row><row><cell>0.003 1</cell><cell>0.97</cell><cell>0.94</cell><cell>0.80</cell><cell>0.73</cell></row><row><cell>0.004 1</cell><cell>0.95</cell><cell>0.93</cell><cell>0.71</cell><cell>0.60</cell></row><row><cell>0.005 1</cell><cell>0.94</cell><cell>0.92</cell><cell>0.66</cell><cell>0.56</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In the rest of the document we will be dropping the part "edge-preserving"</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>List of queries: http://disi.unitn.eu/ ~themis/exemplarquery</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://download.freebase.com/datadumps/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments: This work was partially supported by the Trento RISE Big Data project <ref type="bibr" target="#b4">[4]</ref>. We would also like to thank the authors of <ref type="bibr" target="#b9">[9]</ref> and <ref type="bibr" target="#b20">[20]</ref> for making available their code to run our experiments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">Q1: Google -YouTube</title>
		<meeting><address><addrLine>Menlo Park Google -YouTube -Menlo Park</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Diversifying search results</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gollapudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Halverson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ieong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="5" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An optimization framework for query recommendation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Anagnostopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Becchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Castillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gionis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="161" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Generalizing pagerank: damping functions for link-based ranking algorithms</title>
		<author>
			<persName><forename type="first">R</forename><surname>Baeza-Yates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Castillo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="308" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The trento big data platform for public administration and large companies: Use cases and opportunities</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bedini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Elser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Velegrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1166" to="1167" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Keyword search over relational databases: a metadata approach</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bergamaschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Domnori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Guerra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Trillo</forename><surname>Lado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Velegrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="565" to="576" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A hidden markov model approach to keyword-based search over relational databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bergamaschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Guerra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rota</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Velegrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ER</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="411" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Query suggestions in the absence of query logs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bhatia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mitra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="795" to="804" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Query reformulation mining: models, patterns, and applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Castillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IR</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="257" to="289" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">From machu picchu to rafting the urubamba river: anticipating information needs via the entity-query graph</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bordino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Francisci Morales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bonchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="275" to="284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dynamic personalized pagerank in entityrelation graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chakrabarti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="571" to="580" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Reference Reconciliation in Complex Information Spaces</title>
		<author>
			<persName><forename type="first">X</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Madhavan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="85" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Finding dimensions for queries</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Dou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1311" to="1320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A survey of graph edit distance</title>
		<author>
			<persName><forename type="first">X</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Analysis and applications</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="113" to="129" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Search improvement via automatic query reformulation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gauch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOIS</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="249" to="280" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Topic-sensitive pagerank</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Haveliwala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="517" to="526" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Computing simulations on finite and infinite graphs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Kopke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="453" to="462" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Determining the informational, navigational, and transactional intent of web queries</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Booth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Spink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing &amp; Management</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1251" to="1266" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Scaling personalized web search</title>
		<author>
			<persName><forename type="first">G</forename><surname>Jeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="271" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Neighborhood based fast graph search in large networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Guan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIG-MOD</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="901" to="912" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Nema: Fast graph search with label similarity</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PVLDB</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Fast query execution for retrieval models based on path-constrained random walks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Lao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="881" to="888" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Interactive query refinement</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="862" to="873" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A probabilistic optimization framework for the empty-answer problem</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mottin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marascu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Palpanas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Velegrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="1762" to="1773" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Entity Ranking Using Click-Log Information</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mottin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Palpanas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Velegrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IDA Journal</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="837" to="856" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Ontology-based query expansion with latently related named entities for semantic text search</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">M</forename><surname>Ngo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJIIDS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">283</biblScope>
			<biblScope unit="page" from="41" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">The pagerank citation ranking: Bringing order to the web</title>
		<author>
			<persName><forename type="first">L</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Winograd</surname></persName>
		</author>
		<idno>1999-66</idno>
		<imprint>
			<date type="published" when="1999-11">November 1999</date>
			<publisher>Stanford InfoLab</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Concurrency and automata on infinite sequences</title>
		<author>
			<persName><forename type="first">D</forename><surname>Park</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Concept based query expansion</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-P</forename><surname>Frei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SI-GIR</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="160" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A mathematical theory of communication. SIG-MOBILE Mob</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Shannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Commun. Rev</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="55" />
			<date type="published" when="2001-01">Jan. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Inferring the most important types of a query: a semantic approach</title>
		<author>
			<persName><forename type="first">D</forename><surname>Vallet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zaragoza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="857" to="858" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">An efficient graph indexing method</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K H</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="210" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Mining term association patterns from search logs for effective query reformulation</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="479" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Graph indexing: a frequent structure-based approach</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="335" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">On graph query optimization in large networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="340" to="351" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Query by example</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Zloof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AFIPS NCC</title>
		<imprint>
			<date type="published" when="1975">1975</date>
			<biblScope unit="page" from="431" to="438" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
