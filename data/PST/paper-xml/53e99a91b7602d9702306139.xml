<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Intersection Type Assignment Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Steffen</forename><surname>Van Bakel</surname></persName>
							<email>steffen@cs.kun.nl</email>
							<affiliation key="aff0">
								<orgName type="department">Afdeling Informatica</orgName>
								<orgName type="institution">Universiteit Nijmegen</orgName>
								<address>
									<addrLine>Toernooiveld 1</addrLine>
									<postCode>6525 ED</postCode>
									<settlement>Nijmegen</settlement>
									<region>Nederland</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Intersection Type Assignment Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EAB988624964F1167FC4E5090827E34E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper gives an overview of intersection type assignment for the Lambda Calculus, as well as compare in detail variants that have been defined in the past. It presents the essential intersection type assignment system, that will prove to be as powerful as the well-known BCD-system. It is essential in the following sense: it is an almost syntax directed system that satisfies all major properties of the BCDsystem, and the types used are the representatives of equivalence classes of types in the BCD-system. The set of typeable terms can be characterized in the same way, the system is complete with respect to the simple type semantics, and it has the principal type property.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>In the recent years several notions of type assignment for several (extended) lambda calculi have been studied. The oldest among these is a well understood and elegantly defined notion of type assignment on lambda terms, known as the Curry type assignment system <ref type="bibr" target="#b13">[14]</ref>. It expresses abstraction and application, and can be used to obtain a (basic) functional characterization of terms. It is well known that in that system, the problem of typeability Given a term M, is there a basis B and a type such that B `M: ? is decidable, and that it has the principal type property. These two properties found their way into programming, mainly through the pioneering work of R. Milner <ref type="bibr" target="#b27">[28]</ref>. He introduced a functional programming language ML, of which the underlying type system is an extension of Curry's system. The extension consists of the introduction of polymorphic functions, i.e. functions that can be applied to various kinds of arguments, even of incomparable type. The formal motivation of this concept lies directly in the notion of principal types.</p><p>Though the Curry system is already powerful and convenient for use in programming practice, it has drawbacks. It is, for example, not possible to assign a type to the term ( x:xx), and terms that are -equal can have different principal type schemes. The Intersection Type Discipline as presented in <ref type="bibr" target="#b9">[10]</ref> by M. Coppo, M. Dezani-Ciancaglini, and B. Venneri (a more enhanced system was presented in <ref type="bibr" target="#b5">[6]</ref> by H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini) is an extension of Curry's system that does not have these drawbacks. The extension being made consists mainly of allowing for term variables (and terms) to have more than one type. Intersection types are constructed by adding, next to the type constructor '!' of Curry's system, the type constructor '\' and the type constant '!'. This slight generalization causes a great change in complexity; in fact, now all terms having a (head) normal form can be characterized by their assignable types, a Supported by the Netherlands Organisation for the advancement of pure research (N.W.O.). Current affiliation: Dipartimento di Informatica, Università degli Studi di Torino, Corso Svizzera 185, 10149 Torino, Italia, bakel@di.unito.it property that immediately shows that type assignment (even in the system that does not contain !, see <ref type="bibr" target="#b0">[1]</ref>) is undecidable. Also, by introducing this extension a system is obtained that is closed under -equality: if B `M: and M = N, then B `N: . The type assignment system presented in <ref type="bibr" target="#b5">[6]</ref> (the BCD-system) is based on the system as presented in <ref type="bibr" target="#b9">[10]</ref>. It defines the set of intersection types T \ in a more general way by treating '\' as a general type constructor, and introduces two derivation rules for introduction and elimination of intersections; the handling of intersection in this way is inspired by the similarity between intersection and logical conjunction. A big contribution of <ref type="bibr" target="#b5">[6]</ref> to the theory of intersection types is the introduction of a filter -model and the proof of completeness of type assignment; to achieve the latter, the system is strengthened further by introducing a partial order relation ' ' on types as well as adding the type assignment rule ( ).</p><p>A disadvantage of the BCD-system is that type assignment in this system is undecidable. In recent years, some decidable restrictions have been studied. The first was the Rank2 intersection type assignment system <ref type="bibr" target="#b1">[2]</ref>, as first suggested by D. Leivant in <ref type="bibr" target="#b25">[26]</ref>, that is very close to the notion of type assignment as used in ML. The key idea for this system is to restrict the set of types to those of the shape (( 1 \ \ n )! ), where the 1 ; : : :; n are types that do not contain intersections. This Rank 2 system was later used as a basis for the notion of type assignment as studied by M. Coppo and P. Giannini in <ref type="bibr" target="#b11">[12]</ref>. In that paper the idea behind the let-construct of ML is generalized. In ML, quantification of type-variables is introduced, with the normal restriction that a term variable can only be bound if it does not occur free in the basis (context) for a term; only those type-variables can be instantiated by types. Similarly in <ref type="bibr" target="#b11">[12]</ref>, only those type-variables can be expanded (for the notion of expansion, see Subsection 5.1). Since the operation of expansion uses also the notion of quantification, intersection types in this system are limited to those that have the same shape, instead of allowing for arbitrary intersections. The system studied by F. Damiani and P. Giannini in <ref type="bibr" target="#b14">[15]</ref> is a restriction of the system in <ref type="bibr" target="#b11">[12]</ref>, in that an (!I)-step can only be performed against the types actually used for the term-variable; the notion of type assignment of that paper is, therefore, called relevant.</p><p>That intersection types can be used as a basis for programming languages was first discussed by J. Reynolds in <ref type="bibr" target="#b31">[32]</ref>. This led to the development of the (typed) programming language Forsythe <ref type="bibr" target="#b32">[33]</ref>, and to the work of B.C. Pierce <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31]</ref>, who studied intersection types and bounded polymorphism in the field of typed lambda calculi. Because there only typed systems are considered, the systems are decidable.</p><p>Another disadvantage of the BCD-system is that it is too general: in this system there are several ways to deduce a desired result, due to the presence of the derivation rules (\I), (\E) and ( ). These rules not only allow of superfluous steps in derivations, but also make it possible to give essentially different derivations for the same result. Moreover, in <ref type="bibr" target="#b5">[6]</ref> the relation induced an equivalence relation on types. Equivalence classes are big (for example: ! ( !!), for all types ) and type assignment is closed for . The BCD-system has the principal type property, as was shown in <ref type="bibr" target="#b33">[34]</ref>; the set of operations needed for this system consists of substitutions, expansions, and rises; although for every M the set fhB; ijB `M: g can be generated using those operations specified in <ref type="bibr" target="#b33">[34]</ref>, the problem of type-checking</p><p>Given a term M and type , is there a basis B such that B `M: ?</p><p>is complicated. This is not only due to the undecidability of the problem, but even a semi-algorithm is difficult to define, due to the equivalence relation. Moreover, because of the general treatment of intersection types, the sequence of operations needed to go from one type to another is normally not unique. The Essential Type Assignment System as presented in this paper is a true restriction of the BCD-system that satisfies all properties of that system, and is also an extension of Curry's system. It will be shown that, in order to prove a completeness result using intersection types, there is no need to be as general as in <ref type="bibr" target="#b5">[6]</ref>; this result can also be obtained for the essential system. The main advantage of the essential system over the BCD-system is that the set of types assignable to a term is significantly smaller. An other advantage of the essential system is that derivations are syntax-directed: there is, unlike in the BCD-system, a one-one relationship between terms and skeletons of derivations. These two features are supported by a less complicated type structure.</p><p>The system presented here is also an extension of the strict type assignment system as presented in <ref type="bibr" target="#b0">[1]</ref>. The major difference is that the essential system will prove to be closed for -reduction: If</p><p>B `E M: and M ! N, then B `E N: . This does not hold for the strict system. This paper also gives an overview of various notions of intersection type assignment, in order to give insight and intuition, and to compare in detail the various systems and their development.</p><p>The main objective of this paper is to show that the treatment of intersection types as in <ref type="bibr" target="#b5">[6]</ref> has been too general; the same results could have been obtained for a far less complicated system, that follows more closely the syntactical structure of terms, and treats the type ! not as a type constant, but as the empty intersection. Great advantages of this approach are a less complicated type language, less complicated proofs, and more precise and elegant definitions. For example, the operations that are defined in this paper, needed in a proof for the principal type property are 'orthogonal': there is no overlap. Also, some results already known for, for example, the BCD-system or one of the CDV-systems will be shown to hold for the essential system ( `E `E has the principal type property.</p><p>In general, this will be done using different techniques like, for example, for Theorems 2.8, 2.10, 3.2.7, and 3.3.2; the proof of Theorem 6.3.3 uses a standard technique, but is based on new ideas.</p><p>The outline of this paper is as follows. Section 1 will give an overview of, in total, five notions of intersection type assignment, that will be compared and discussed. Subsection 1.1 presents the Coppo-Dezani system as defined in <ref type="bibr" target="#b6">[7]</ref>, Subsection 1.2 presents two Coppo-Dezani-Venneri systems as first defined in <ref type="bibr" target="#b9">[10]</ref>, Subsection 1.3 presents the Barendregt-Coppo-Dezani system that can be found in <ref type="bibr" target="#b5">[6]</ref>, and Subsection 1.4 presents the strict system of <ref type="bibr" target="#b0">[1]</ref>.</p><p>Section 2 contains the presentation of the essential type assignment system, an extension of the strict system, and a restriction of the BCD-system that will prove to be equally powerful as the BCD-system. In that subsection it will be shown that type assignment in this system is closed for -equality (Theorem 2.10) and -reduction (Theorem 2.8). In Section 3 an approximation theorem will be proved: B `E M: ( ) 9 A2A(M) [B `E A: ] (Theorem 3.2.7), using a notion of computability. With this result, a characterization of the sets of terms having a (head) normal form will be given (Theorem 3.3.2). In Section 4, soundness and completeness of essential type assignment will be proved (respectively in Theorem 4. <ref type="bibr">3.1 and Theorem 4.3.6)</ref>. The section starts with formulating the relation between the BCD-and the essential system in Subsection 4.1. In Subsection 4.2 a filter -model will be defined, that is used in Subsection 4.3 to prove completeness of type assignment with respect to the simple type semantics (see <ref type="bibr">Definition 1.3.5)</ref>.</p><p>For three of these systems presented in the past (one CDV system, the BCD system and the strict system) the principal type property has been shown to hold in, respectively, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b33">[34]</ref>, and <ref type="bibr" target="#b3">[4]</ref>; in Section 5 the constructions of the proofs of the various papers will be discussed. Finally, in Section 6, the proof for the principal type property for the essential system will be sketched.</p><p>The results presented in this paper first appeared, in a condensed and slightly different form, in <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notations</head><p>In this paper, the symbol ' will be a type-variable; Greek symbols like , , , , , and will range over types, and will be used for principal types. '!' will be assumed to associate to the right, and '\' binds stronger than '!'. M, N are used for lambda terms, x, y, z for term-variables, M[N=x] for the usual operation of substitution in terms, and A for terms in ?-normal form. B is used for bases, Bnx for the basis obtained from B by erasing the statement that has x as subject, and P for principal bases. All symbols can appear indexed.</p><p>Two types (bases, pairs of basis and type) are disjoint if and only if they have no type-variables in common. Notions of type assignment are defined as ternary relations on bases, terms, and types, that are denoted by `, possibly indexed if necessary. If in a notion of type assignment for M there are basis B and type such that B `M: , then M is typed with , and is assigned to M.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">A historical perspective</head><p>Type assignment for the Lambda Calculus was first studied by H.B. Curry in <ref type="bibr" target="#b12">[13]</ref>. (See also <ref type="bibr" target="#b13">[14]</ref>.) Curry's system -the first and most primitive one -expresses abstraction and application and its major advantage is that the problem of type assignment is decidable. The types used in this system are those obtained from type-variables and the type-constructor ! 'arrow'. Definition 1.1 i) The set of Curry-types is inductively defined by: a) All type-variables ' 0 , ' 1 , : : : are Curry-types. b) If and are Curry-types, then so is ! . ii) Curry-type assignment and Curry-derivations are defined by the following natural deduction system.</p><p>[x: ] :</p><p>M:</p><formula xml:id="formula_0">(!I): (a)</formula><p>x:M: ! M: ! N:</p><p>(!E):</p><p>MN:</p><p>(a) If x: is the only statement about x on which M: depends.</p><p>The main results proved for this system are:</p><p>The principal type property: for every typeable M there is a pair hP; i, such that: P `M: , and for every pair hB; i such that B `M: , there exists a substitution Sub such that Sub (hP; i) = hB; i.</p><p>Decidability of type assignment. Strongly normalizability of all typeable terms. Curry's system has drawbacks: it is for example not possible to assign a type to the lambda term ( x:xx), and although the lambda terms ( cd:d) and (( xyz:xz(yz))( ab:a)) are -equal, the principal type schemes for these terms are different, ' 0 !' 1 !' 1 and (' 1 !' 0 )!' 1 !' 1 , respectively. The Intersection Type Discipline as presented in the following subsections is an extension of Curry's system for the pure Lambda Calculus that does not have these drawbacks. It has developed over a period of several years; in the sequel, not just the final version will be presented, but various systems that appeared between 1980 and 1992 will be shown, in order to develop a concise overview of the field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">The Coppo-Dezani type assignment system</head><p>The first paper by M. Coppo and M. Dezani-Ciancaglini from the University of Turin, Italy that introduced intersection types is <ref type="bibr" target="#b6">[7]</ref> (in this paper, instead of the word 'intersection', the word 'sequence' was used). The system presented in this paper is a true extension of Curry's system: the extension made is to allow of more than one type for term-variables in the (!I)-derivation rule and therefore to allow of, also, more than one type for the right hand term in the (!E)-derivation rule. <ref type="bibr" target="#b6">[7]</ref> is inductively defined by: a) All type-variables ' 0 , ' 1 , : : : are types. b) If 1 ; : : :; n are types (n 1), then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1.1.1 i) The set of types considered in</head><formula xml:id="formula_1">1 \ \ n is a sequence. c) If 1 \ \ n is a sequence and is a type, then 1 \ \ n ! is a type.</formula><p>ii) Type assignment and derivations are defined by the following natural deduction system.</p><p>M: 1 : : : M: n (\I):</p><formula xml:id="formula_2">M: 1 \ \ n [x: 1 \ \ n ] : M: (!I):</formula><p>(a)</p><p>x:M:</p><formula xml:id="formula_3">1 \ \ n ! x: 1 \ \ n (\E):</formula><p>x: i M:</p><formula xml:id="formula_4">1 \ \ n ! N: 1 \ \ n (!E):</formula><p>MN:</p><p>(a) If x: 1 \ \ n is the only statement about x on which M: depends.</p><p>The main properties of that system proved in <ref type="bibr" target="#b6">[7]</ref> are:</p><p>Subject reduction: If B `M: and M ! N, then B `N: . Normalizability of typeable terms: If B `M: , then M has a normal form.</p><p>Typeability of all terms in normal form.</p><p>Closure for -equality in the I-calculus: if B `M: and M = N, then B `N: . In the I-calculus: B `M: if and only if M has a normal form.</p><p>It is even possible to prove that, in this system: If B `M: , then M is strongly normalizable (in fact, this follows from a similar result of <ref type="bibr" target="#b0">[1]</ref>; there the BCD-system without ! is studied, which is a supersystem of the CD-system).</p><p>That the system is closed under subject reduction can be illustrated by the following 'Cut and Paste' proof: Suppose that B `( x:M)N: . By (!E), there is a sequence 1 \ \ n such that B ` x:M:</p><formula xml:id="formula_5">1 \ \ n ! and B `N: 1 \ \ n .</formula><p>Since (!I) should be the last step performed for the first result and (\I) should be the last step for the latter, also B; x: 1 \ \ n `M: and B `N: i , for 1 i n. Then a derivation for B `M[N=x]: can be obtained by replacing, for every 1 i n, in the derivation for B; x: 1 \ \ n `M: , the sub-derivation fx: 1 \ \ n g `x: i by the derivation for B `N: i . The problem to solve in a proof for closure under -equality is then that of -expansion: if B `M[N=x]: , then B `( x:M)N: . When restricting to I-terms, the term-variable x occurs in M and the term N is a subterm of M[N=x], so N is typed in the derivation for B `M[N=x]: , probably with several different types 1 ; : : :; n . In the CD-system a derivation for B; x: 1 \ \ n `M: can be obtained by replacing in the derivation for B `M[N=x]: , all occurrences of N: i by the derivation for fx: 1 \ \ n g `x: i . Then, obviously, using (!I), (\I), and (!E), the redex can be typed.</p><p>The system is not closed for -expansion for the full K-calculus: when the term-variable x does not occur in M, the term N is a not a subterm of M[N=x], and if there is no such that B `N: , the redex cannot be typed. Take, for example, the two lambda terms (( xy:y)(( z:zz)( z:zz))) and ( y:y) (notice that the first term reduces to the second). Then of course ` y:y: ! , but it is impossible to type the term (( xy:y:)(( z:zz)( z:zz))). This can be understood from the fact that all typeable terms are normalizable; the subterm (( z:zz)( z:zz)) has no normal form, so is not typeable. For a more intricate example that remains within the set of typeable terms, take the two lambda terms ( yz:( b:z)(yz)) and ( yz:z) (again the first term reduces to the second). It is easy to show that fz: ; y: g `z: , but it is impossible to give a derivation for ( b:z)(yz): from the same basis. This is caused by the fact that (( b:z)(yz)) can only be typed in this system from a basis in which the predicate for y is an arrow type scheme. It is for example possible to derive fz: ; y: ! g `( b:z)(yz): . Therefore, it is possible to derive ` yz:( b:z)(yz):( ! )! ! and ` yz:z: ! ! , but not to give a derivation for yz:( b:z)(yz): ! ! . From this initial system several others emerged. The best known and most frequently quoted is the one presented in <ref type="bibr" target="#b5">[6]</ref>, but there are two earlier papers ( <ref type="bibr" target="#b9">[10]</ref> and <ref type="bibr" target="#b8">[9]</ref>) that investigate interesting systems which can be regarded as in-between those of in <ref type="bibr" target="#b6">[7]</ref> and <ref type="bibr" target="#b5">[6]</ref>. In fact, the system that will be presented in Section 2 is more close to the system of <ref type="bibr" target="#b9">[10]</ref> that to that of <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">The Coppo-Dezani-Venneri type assignment systems</head><p>In <ref type="bibr" target="#b9">[10]</ref> two type assignment systems are presented, that, in approach, are more general than the Coppo-Dezani system: in addition to the type constructors '!' and '\', they also contain the type constant '!'. The first type discipline as presented in [10] (a similar system was presented in <ref type="bibr" target="#b34">[35]</ref>) is a true extension of the one presented in <ref type="bibr" target="#b6">[7]</ref>; the second one limits the use of intersection types in bases. By introducing the type constant ! next to the intersection types, a system is obtained that is closed under -equality for the full K-calculus: if M = N, where M and N are lambda terms, then B `M: ( ) B `N: . Definition 1.2.1 i) The set of types is inductively defined in <ref type="bibr" target="#b9">[10]</ref> by: a) All type-variables ' 0 , ' 1 , : : : are types. b) ! is a type. c) If 1 ; : : :; n are types, (n 1), then 1 \ \ n is a sequence.</p><formula xml:id="formula_6">d) If 1 \ \ n is a</formula><p>sequence and is a type, then 1 \ \ n ! is a type. ii) Every type can be written as 1 ! ! n ! , where 1 ; : : :; n are sequences, and is a type-variable or !. The type is called tail-proper if 6 = !.</p><p>iii) Type assignment and derivations are in <ref type="bibr" target="#b9">[10]</ref> defined by:</p><formula xml:id="formula_7">[x: i ] [x: n ] :</formula><p>M:</p><formula xml:id="formula_8">(!I): (a)</formula><p>x:M: ! M: 1 : : : M: n (\I):</p><formula xml:id="formula_9">M: 1 \ \ n (!): M:! M: 1 \ \ n ! N: 1 \ \ n (!E):</formula><p>MN:</p><p>(a) If x: 1 , : : :, x: n are all and nothing but the statements about x on which M: depends, and is a sequence that at least contains all 1 ; : : :; n .</p><p>Notice that ! is treated as a true type constant; the view of the strict intersection system presented in <ref type="bibr" target="#b0">[1]</ref> (see <ref type="bibr">Subsection 1.4)</ref> and that of the essential system presented in this paper (see Section 2)</p><p>is to treat ! as the empty intersection.</p><p>The changes with respect to the system of <ref type="bibr" target="#b6">[7]</ref> are small, but important. First of all, the type constant !, assignable to all terms, is introduced, which makes all terms having a head normal form typeable; the type ! is needed to cover the subterms that have no normal form. Also, the (\E) rule of <ref type="bibr" target="#b6">[7]</ref> is implicitly present in (!I).</p><p>The main properties of this system proved in <ref type="bibr" target="#b9">[10]</ref>  ii) On the set of types, the relation is defined by: a) ' '.</p><formula xml:id="formula_10">b) 1 \ \ i \ i+1 \ \ n 0 1 \ \ 0 i+1 \ 0 i \ \ 0 n ( ) 8 1 i n [ i 0 i ]. c) ! 0 ! 0 ( ) 0 &amp; 0 .</formula><p>Observe that the only normalized non-tail-proper type is !.</p><p>A good justification for identification of types through can be found in the definition of type-semantics (Definition 1. <ref type="bibr">3.5)</ref>. Notice that, in fact, normalizing types as done here is just the same as treating ! as an empty intersection; the set of normalized types coincides with the set of strict types (see Definition 1.4.1), and normalized sequences correspond to strict intersection types.</p><p>The second type assignment system presented in <ref type="bibr" target="#b9">[10]</ref> is a restricted version of the first. Since it limits the possible bases that can be used in a derivation, it is not a proper extension of Curry's system: if B `M: and the term-variable x does not occur in B, then for ( x:M) only the type !! can be derived. This system is also used in <ref type="bibr" target="#b18">[19]</ref>.</p><p>Definition 1.2.3 Restricted type assignment and restricted derivations are in <ref type="bibr" target="#b9">[10]</ref> defined by:</p><formula xml:id="formula_11">[x: 1 ] [x: n ] : M: (!I):</formula><p>(a)</p><p>x:M:</p><formula xml:id="formula_12">1 \ \ n ! M: 1 : : : M: n (\I): (b) M: 1 \ \ n (!): M:! M: 1 \ \ n ! N: 1 \ \ n (!E):</formula><p>MN:</p><p>(a) If 6 = ! and x: 1 , : : :, x: n are all and nothing but the statements about x on which M:</p><p>depends. If n = 0, so in the derivation for M: there is no premise whose subject is x, then</p><formula xml:id="formula_13">1 \ \ n = !. (b) If for 1 i n, i 6 = !.</formula><p>This notion of type assignment is relevant in the sense of <ref type="bibr" target="#b14">[15]</ref>: in the (!I)-rule, only those types actually used in the derivation can be abstracted. This implies that, for example, for the lambda term ( ab:a) the type ! ! cannot be derived.</p><p>It is obvious that B `M: in the restricted system implies B `M: in the unrestricted one and that the converse does not hold. In both systems, types are not invariant by -expansion, since for example ` x:x:'!', but not ` xy:xy:'!'. Moreover, type assignment in the unrestricted system is not invariant under -reduction: for example</p><formula xml:id="formula_14">` xy:xy:( ! )! \ ! , but not ` x:x:( ! )! \ ! .</formula><p>This is due to the fact that, in the unrestricted system, there is no way to obtain x: \ ! from x: ! . In the restricted system, in the (!I)-rule, only types actually used for a term variable can be collected. This means that the statement xy:xy:( ! )! \ ! cannot be derived, since the type is not used for the application xy.</p><p>The closure under -reduction, however, holds for the restricted system; properties of this restricted system proved in <ref type="bibr" target="#b9">[10]</ref> are:</p><p>If B `M: , then is a normalized type. If B `M: and M ! N, then B `N: .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">The Barendregt-Coppo-Dezani type assignment system</head><p>The type assignment system presented in <ref type="bibr" target="#b5">[6]</ref> by H. Barendregt, M. Coppo and M. Dezani-Ciancaglini is based on the first, unrestricted system as presented in <ref type="bibr" target="#b9">[10]</ref>. It extended the set of types to T \ , introduced a partial order relation ' ' on types, added the type assignment rule ( ), and introduced a more general form of the rules concerning intersection. The rule ( ) was mainly introduced to prove completeness of type assignment.</p><p>In this paper, it was shown that the set of types derivable for a lambda term in the extended system is a filter, i.e. a set closed under intersection and right-closed for . The interpretation of a lambda term by the set of types derivable for it -[[ M ]] -is defined in the standard way and gives a filter -model F \ . The main result of that paper is that, using this model, completeness is proved by proving the statement: `\ M: ( ) [[ M ]] 2 ( ), where : T \ ! F \ is a simple type interpretation as defined in <ref type="bibr" target="#b22">[23]</ref> (see <ref type="bibr">Definition 1.3.5 (ii)</ref>). In order to prove the '('-part of this statement (completeness), the relation is needed. Other interesting applications of filter -models can be found in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b15">[16]</ref>, and <ref type="bibr" target="#b16">[17]</ref>. <ref type="bibr" target="#b5">[6]</ref> is inductively defined by: a) All type-variables ' 0 , ' 1 , : :</p><formula xml:id="formula_15">Definition 1.3.1 i) T \ , the set of types in</formula><formula xml:id="formula_16">: 2T \ . b) !2T \ . c) If and 2T \ , then ! and \ 2T \ . ii) On T \ , the type inclusion relation is inductively defined by: a) . b) !. c) ! !!!. d) \ , \ . e) ( ! )\( ! ) ! \ . f) ) . g) &amp; ) \ . h) &amp; ) ! ! . iii) ( ) .</formula><p>T \ may be considered modulo . Then becomes a partial order.</p><p>Notice that, because of part (i.c), '\' is now also a general type constructor. This is in harmony with the fact that also ! is treated as a 'normal' type constant, but is not motivated by the type system itself. The decision to treat '\' in this way stems from a, in the eyes of this author, wrong line of thought. In order to solve the problem of completeness of type assignment, first the set of types is expanded, where the introduction of a relation on normalized types with contra-variance in the arrow would have done the trick. The goal of this paper is to show that, had the authors restricted themselves to the normalized types of <ref type="bibr" target="#b9">[10]</ref> (Definition 1.2.2) and introduced a relation on those types (essentially composed of parts (ii.a), (ii.b), (ii.d), (ii.f), (ii.g), and (ii.h)), they would have obtained a system with the same expressiveness as that one they defined. This system would then have been identical to the essential system as presented in this paper (Section 2). Definition 1.3.2 i) Type assignment and derivations are in <ref type="bibr" target="#b5">[6]</ref> defined by the following natural deduction system.</p><p>[x: ] :</p><p>M:</p><formula xml:id="formula_17">(!I): (a)</formula><p>x:M: ! M: ! N:</p><p>(!E):</p><p>MN:</p><p>M: M:</p><p>(\I):</p><formula xml:id="formula_18">M: \ M: \ (\E):</formula><p>M:</p><p>M: \ M: M:</p><p>( ):</p><p>M:</p><p>(!):</p><p>M:! (a) If x: is the only statement about x on which M: depends.</p><p>ii) B `\ M: means that M: is derivable from a basis B using these rules.</p><p>An advantage of the presentation in <ref type="bibr" target="#b5">[6]</ref> is, clearly, a very easy type definition and easy understandable derivation rules. But this advantage is superficial, since all difficulties now show up while proving theorems; especially the complexity of and causes confusion.</p><p>For this notion of type assignment, the following properties hold:</p><formula xml:id="formula_19">Lemma 1.3.3 i) B `\ MN: ( ) 9 [B `\ M: ! &amp; B `\ N: ]. ii) B `\ x:M: ( ) 9 ; [ = ! &amp; B; x: `\ M: ]. iii) B `\ x: ( ) 9 [x: 2B &amp; ].</formula><p>In the BCD-system, there are several ways to deduce a desired result, due to the presence of the derivation rules (\I), (\E) and ( ), which allow superfluous steps in derivations. In the CDV-systems, these rules are not present and there is a one-one relationship between terms and skeletons of derivations. In other words: those systems are syntax directed. The BCD-system has the same expressive power as the previous unrestricted CDV-system: all solvable terms have types other than !, and a term has a normal form if and only if it has a type without !-occurrences.</p><p>The main result of <ref type="bibr" target="#b5">[6]</ref> is the proof for completeness of type assignment. The construction of a filter -model and the definition of a map from types to elements of this model (a simple type interpretation) make that proof possible: if the interpretation of the term M is an element of the interpretation of the type , then M is typeable with .</p><p>Filters and the filter -model F \ are defined by:</p><formula xml:id="formula_20">Definition 1.3.4 i) A filter is a subset d T \ such that: a) !2d. b) ; 2d ) \ 2d. c) 2d ) 2d. ii) F \ = fdjd is a filterg. iii) For d 1 ; d 2 2F \ define d 1 d 2 = f 2T \ j9 2d 2 [ ! 2d 1 ]g.</formula><p>Notice that, because of part (i.a), a filter is never empty.</p><p>The following properties are proved in <ref type="bibr" target="#b5">[6]</ref>:</p><formula xml:id="formula_21">8 M 2Λ [f j9 B [B `\ M: g2F \ ]].</formula><p>Let be a valuation of term-variables in F \ and B = fx: j 2 (x)g. For M 2 Λ define [[ M ]] = f j B `\ M: g. Using the definition of Hindley and Longo <ref type="bibr" target="#b23">[24]</ref> it is shown that hF \ , , [[ ]] i is a -model.</p><p>In constructing a complete system, the semantics of types plays a crucial role. As in <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b28">[29]</ref>, and essentially following <ref type="bibr" target="#b21">[22]</ref>, a distinction can be made between several notions of type interpretations and semantic satisfiability. There are, roughly, three notions of type semantics that differ in the meaning of an arrow type scheme: inference type interpretations, simple type interpretations and F type interpretations. These different notions of type interpretations induce of course different notions of semantic satisfiability.</p><formula xml:id="formula_22">Definition 1.3.5 i) Let hD; ; "i be a continuous -model. A mapping : T \ ! }(D) = fX j X Dg is a type interpretation if and only if: a) f" d j 8 e2 ( ) [d e2 ( )]g ( ! ). b) ( ! ) fd j 8 e2 ( ) [d e2 ( )]g. c) ( \ ) = ( ) \ ( ).</formula><p>ii) Following <ref type="bibr" target="#b22">[23]</ref>, a type interpretation is simple if also:</p><formula xml:id="formula_23">( ! ) = fdj8 e2 ( ) [d e2 ( )]g.</formula><p>iii) A type interpretation is called an F type interpretation if it satisfies:</p><formula xml:id="formula_24">( ! ) = f" d j 8 e2 ( ) [d e2 ( )]g.</formula><p>Notice that, in part (ii), the containment relation of part (i.b) is replaced by =, and that in part (iii) the same is done with regard to part (i.a).</p><p>These notions of type interpretation lead, naturally, to the following definitions for semantic satisfiability (called inference-, simple-and F-semantics, respectively).</p><formula xml:id="formula_25">Definition 1.3.6 i) Let M = hD; ; [[ ]] i be a -</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>model and a valuation of term-variables in D.</head><p>Then Since no confusion is possible, the superscript on [[ ]] is omitted.</p><formula xml:id="formula_26">[[ M ]] M 2D is the interpretation of M in M via . ii) Define `by (where M is a -model,</formula><p>The main result of <ref type="bibr" target="#b5">[6]</ref> is obtained by proving:</p><formula xml:id="formula_27">Property 1.3.7 i) Soundness. B `\ M: ) B `s M: . ii) Completeness. B `s M: ) B `\ M: .</formula><p>The proof of completeness is obtained in a way very similar to that of Theorem 4.3.6. The results of <ref type="bibr" target="#b5">[6]</ref> in fact show that type assignment in the BCD-system is complete with respect to simple type semantics; this in contrast to strict type assignment (presented in <ref type="bibr" target="#b0">[1]</ref>, see also the next subsection), that is complete with respect to the inference semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">The strict type assignment system</head><p>The strict type assignment system as defined in <ref type="bibr" target="#b0">[1]</ref> is a restriction of the system of <ref type="bibr" target="#b5">[6]</ref>; it is a type assignment system in which the relation and the derivation rule ( ) are no longer present. The elimination of induces a set of strict types, that is actually the set of normalized tail-proper types of <ref type="bibr" target="#b9">[10]</ref>. Moreover, there the relation S on strict types is presented, that is more restricted than just the relation restricted to strict types. Instead, it is the relation generated by interpreting the type-constructor \ as intersection on sets; in particular, S is not defined over '!'-types, so part (ii.h) of Definition 1.3.1 is missing. The derivation rules used are similar to those of the unrestricted system in <ref type="bibr" target="#b9">[10]</ref>. This implies that, formally, the strict system is a system in between the two presented in <ref type="bibr" target="#b9">[10]</ref>; a significant difference with the restricted system of <ref type="bibr" target="#b9">[10]</ref> is that type assignment in the strict system is not relevant in the sense of <ref type="bibr" target="#b14">[15]</ref>.</p><p>Although the rather strong restrictions imposed, the provable results for the strict system are very close to those for the system of <ref type="bibr" target="#b5">[6]</ref>. For example, the sets of normalizable terms and those having a normal form can be equally elegantly characterized. The main difference between the two systems is that the strict system is not closed for -reduction, whereas the BCD-system is.</p><p>The strict system gives rise to a strict filter -model F S , that satisfies all major properties of the filter -model F \ as presented in <ref type="bibr" target="#b5">[6]</ref>, but is an essentially different -model, equivalent to Engeler's model D A <ref type="bibr" target="#b17">[18]</ref>. In <ref type="bibr" target="#b0">[1]</ref> was shown that soundness for the notion of type assignment of <ref type="bibr" target="#b5">[6]</ref> is lost if instead of simple type semantics, the inference type semantics is used. Take, for example, the statement x:x:( ! )!( \ )! : this statement is derivable in the system `\ , but it is not valid in F S . With the use of the inference type semantics, in [1] soundness and completeness for strict type assignment was proved, without having the necessity of introducing ; this was done using F S .</p><p>The set of types assignable to a term M in the strict system is significantly smaller than the set of types assignable to M in the BCD-system. In particular, the problem of type checking for the strict system is, because of the smaller equivalence classes, less complicated than for the BCD-system.</p><p>Strict types are the types that are strictly needed to assign a type to a term in the BCD-system.</p><p>In the set of strict types, intersection type schemes and the type constant ! play a limited role. Perhaps the most important change from the systems presented before is that the type constant ! is no longer treated as an arbitrary type, that can be handled in any way. Instead, ! is taken to be the empty intersection: if n = 0, then 1 \ \ n !, so ! does not occur in an intersection subtype. Moreover, intersection type schemes (so also !) occur in strict types only as subtypes at the left-hand side of an arrow type scheme, as in the types of <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b8">[9]</ref>, and <ref type="bibr" target="#b9">[10]</ref>.</p><p>Definition 1.4.1 i) T s , the set of strict types, and T S , the set of strict intersection types, are defined by mutual induction by: a) All type-variables ' 0 , ' 1 , : : : 2T s , and if 2T s and 2T S , then ! 2T s . b) If 1 ; : : :; n 2T s (n 0), then 1 \ \ n 2T S . ii) On T S , the relation S is defined by: a)</p><formula xml:id="formula_28">8 1 i n (n 1) [ 1 \ \ n S i ]. b) 8 1 i n (n 0) [ S i ] ) S 1 \ \ n . c) S S ) S . iii) On T S , the relation S is defined by: a) S S ) S . b) S &amp; S ) ! S ! .</formula><p>Notice that T s is a proper subset of T S , and that the second part of (i.a) can also be formulated as: If ; 1 ; : : :; n 2 T s (n 0), then 1 \ \ n ! 2 T s . Moreover, S if and only if can be obtained from by premuting components of an intersection subtype, e.g. in \ ! S \ ! .</p><p>The definition of S as in <ref type="bibr" target="#b0">[1]</ref> did not contain part 1.4.1 (iii.b), but was defined by: S S ( ) S . As was remarked by Professor G. Plotkin of the University of Edinburgh, Scotland (private communication), defining the equivalence relation on types in that way causes an anomaly in the definition of type-interpretation. In particular, the types \ ! and \ ! would be incomparable, which implies that the interpretation of an arrow type ! is no longer a map from the interpretation of onto the interpretation of .</p><p>Definition 1.4.2 i) Strict type assignment and strict derivations are defined by the following natural deduction system (where all types displayed are strict, except for in the rule (!I)):</p><p>M: 1 \ \ n ! N: 1 : : : N: n</p><formula xml:id="formula_29">(!E): (n 0)</formula><p>MN:</p><p>[x: ] :</p><p>M:</p><formula xml:id="formula_30">(!I): (a)</formula><p>x:M: !</p><p>x:</p><formula xml:id="formula_31">1 \ \ n (\E): (b)</formula><p>x: i (a) If x: is the only statement about x on which M: depends. (b) n 2; 1 i n.</p><p>ii) B `s M: is used for: M: is derivable from B using a strict derivation, and `S is defined by: B `S M: if and only if: there are 1 ; : : :; n (n 0) such that Notice that the derivation rule (\E) is only performed on variables and that the derivation rules (!) and (\I) of the BCD-system are implicitly present in the derivation rule (!E). Moreover, a derivation in the `S system with conclusion M:! cannot be composed with any other derivation.</p><p>The derivation rule (\E) could be replaced by a rule for ( S ), in the spirit of the rule ( ) of the BCD-system, but allowed only for term-variables. Also, the derivation rules (!I) and (\E) together correspond to the derivation rule (!I) of the unrestricted CDV-system (Definition 1.2.1).</p><p>The strict filter -model F S is defined in a way very similar to F \ defined in <ref type="bibr" target="#b5">[6]</ref>, by defining filters of types and a map from terms to filters. Definition 1.4.3 i) A subset d of T S is called a strict filter if and only if: a) 1 ; : : :</p><formula xml:id="formula_32">; n 2d (n 0) ) 1 \ \ n 2d. b) 2d &amp; S ) 2d. ii) If V T S ,</formula><p>then " S V is the smallest strict filter that contains V , and " S = " S f g. iii) F S = fd T S jd is a strict filterg. Application on F S is defined by: d e = " S f j9 2e [ ! 2d]g.</p><p>Notice that if types are not considered modulo S then part (i.b) should also contain: 2d &amp; S ) 2d. Notice also that every strict filter contains !.</p><p>The filter -models F S and F \ are not isomorphic as complete lattices, since, for example, in F \ the filter "( \ )! is contained in " ! , but in F S the strict filter " S ( \ )! is not contained in " S ! . Moreover, they are not isomorphic as -models since in F \ the meaning of ( xy:xy) is contained in the meaning of ( x:x), while this does not hold in F S . Another difference is that, while the analogue of G in F \ chooses the minimal representative of functions, this is not the case in F S . Moreover, it is straightforward to show that F S is equivalent to Engeler's model D A .</p><p>The main results of <ref type="bibr" target="#b0">[1]</ref> are: Soundness and completeness of type assignment with respect to inference type semantics.</p><p>If B `\ M: then there are B 0 ; 0 2T S such that B 0 `S M: 0 , 0 and B B 0 . Conservativity. Let B; 2T S . If B `\ M: , then B `S M: . In the BCD-system without !, restricted to the I-calculus: B `s M: ( ) B `\ M: . In the BCD-system without !: fM jM is typeable by means of the derivation rules (\I), (\E), (!I) and (!E)g = fM jM is strongly normalizableg.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The essential intersection type assignment system</head><p>In this section the essential type assignment system is presented, a restricted version of the system presented in <ref type="bibr" target="#b5">[6]</ref>, together with some of its properties. The major feature of this restricted system is, compared to the BCD-system, a restricted version of the derivation rules and the use of strict types. It also forms a slight extension of the strict type assignment system that was presented in <ref type="bibr" target="#b0">[1]</ref> (see Subsection 1.4); the main difference is that the strict system is not closed for -reduction, whereas the essential system presented here is.</p><p>Recall Definition 1.4.1. The relation E on T S , to be defined below, is a natural extension of the relation S , that was only defined for intersection types. Notice that, in the definition of E , the arrow type constructor is contra-variant in its left-hand argument.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1 i)</head><p>The relation E is defined on T S like S , by adding the last alternative. a)</p><formula xml:id="formula_33">8 1 i n (n 1) [ 1 \ \ n E i ]. b) 8 1 i n (n 0) [ E i ] ) E 1 \ \ n . c) E E ) E . d) E &amp; E ) ! E ! . ii) On T S , the relation E is defined by: E ( ) E E .</formula><p>iii) B E B 0 if and only if for every x: 0 2B 0 there is an x: 2B such that E 0 , and B E B 0 ( )</p><formula xml:id="formula_34">B E B 0 E B.</formula><p>Also the relations , , and S are extended to bases.</p><p>Notice that E is exactly the relation restricted to T S (see also Property 4.1.2), so if E , then , and that S is a true subrelation of E , since, for example, ( ! )\( \ ! ) E ! , but this does not hold in S . Moreover, T S may be considered modulo E ; then E becomes a partial order, and from now on in this paper types are considered modulo E .</p><p>Unless stated otherwise, if a type is written as 1 \ \ n , then all 1 ; : : :; n are assumed to be strict. Remember that ! is defined to be the emtpy intersection. Definition 2.2 If B 1 ; : : :; B n are bases, then ΠfB 1 ; : : :; B n g is the basis defined as follows:</p><p>x: 1 \ \ m 2ΠfB 1 ; : : :; B n g if and only if fx: 1 ; : : :; x: m g is the set of all statements about x that occur in B 1 : : : B n .</p><p>Often B fx: g (or B; x: ) will be written for the basis ΠfB; fx: gg, when x does not occur in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.</head><p>For the relation E , the following properties hold:</p><formula xml:id="formula_35">Lemma 2.3 i) S ) E . ii) ' E ( ) '. So f j E 'g = f'g. iii) ! E ( ) !. So f j E !g = f!g. iv) ! E 2T s ( ) 9 2T S , 2T s [ ! &amp; E &amp; E ]. v) 1 \ \ n E 2T s ) 9 1 i n [ i E ]. vi) E )</formula><formula xml:id="formula_36">:; m [ = 1 \ \ n &amp; = 1 \ \ m &amp; 8 1 j m 9 1 i n [ i E j ]].</formula><p>Proof: Easy.</p><p>The essential type assignment system is constructed from the set of strict types and an extension of the derivation rules as in Definition 1.4.2. In this way, a syntax directed system is obtained, that satisfies the main properties of the BCD-system. Definition 2.4 i) Essential type assignment and essential derivations are defined by the following natural deduction system (where all types displayed are strict, except in the rules (!I) and ( E )):</p><p>M: 1 \ \ n ! N: 1 : : : N: n</p><formula xml:id="formula_37">(!E): (n 0)</formula><p>MN:</p><p>[x: ] :</p><p>M:</p><formula xml:id="formula_38">(!I): (a)</formula><p>x:M: !</p><p>x:</p><formula xml:id="formula_39">E ( E ):</formula><p>x:</p><p>(a) If x: is the only statement about x on which M: depends.</p><p>B `e M: is defined as: M: is derivable from B using an essential derivation. ii) Define `E by: B `E M: if and only if: there are 1 ; : : :; n (n 0) such that</p><formula xml:id="formula_40">1 \ \ n</formula><p>and B `e M: i , for every 1 i n.</p><p>Notice that the difference between the strict system and the essential one lies only in the derivation rule for term variables. Instead of a rule (\E), that is in fact defined using the relation S , the essential system contains a similar rule using E .</p><p>The introduction of two different notions of derivability seems somewhat superfluous. In fact, the 'real' notion of type assignment is that defined as `e ; the symbol `E is mainly introduced for convenience, as an abbreviation.</p><p>For these notions of type assignment, the following properties hold: </p><formula xml:id="formula_41">; n [ = 1 \ \ n &amp; 8 1 i n [B `e M: i ]]. vi) B `E M: ( ) fx: 2Bjx2FV(M)g `E M: . vii) B `E M: &amp; B 0 E B ) B 0 `E M: . viii) B `E M: &amp; M &lt; M 0 ) B 0 `E M 0 : . Proof: Easy.</formula><p>Although the rule ( E ) is defined only for term-variables, `E is closed for E . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M:</head><p>Proof: By induction on `E. i) = !. Then, by Lemma 2.3 (iii), = !. Obviously, B `E M: . ii) = 1 \ \ n . By Lemma 2.5 (v), for every 1 i n, B `e M: i . By Lemma 2.3 (vi), there are 1 ; : : :; m 2T s such that = 1 \ \ m and, for every 1 j m, there is a 1 i n such that i E j . By induction, for every 1 j m, B `e M: j . But then, by Lemma 2.5 (v), B `E M: . iii) 2T s . This part is proven by induction on M.</p><p>a) M x. Then B E fx: g E fx: g, so, by Lemma 2.5 (i), B `E x: . b) M x:M 0 . Then, by Lemma 2.5 (iii), there are 2 T S , 2 T s such that = ! and B; x: `e M 0 : . By Lemmas 2.3 (vi) and 2.3 (iv) there are 1 ; : : :; n ; 1 ; : : :; n such that = ( 1 ! 1 ) \ \ ( n ! n ), and for 1 i n, i E and E i . By Lemma 2.5 (vii), for 1 i n, B; x: i `e M 0 : , and by induction B; x: i `e M 0 : i . So, by Lemma 2.5 (iii), for every 1 i n, B `e x:M 0 : i ! i , so, to conclude, by Lemma 2.5 (v), B `E x:M 0 : . c) M M 1 M 2 . Then, by Lemma 2.5 (ii), there is a 2 T S such that B `e M 1 : ! and B `E M 2 : . Since E , also ! E ! and, by induction, B `e M 1 : ! . Then, by Lemma 2.5 (ii), B `E M 1 M 2 : . Now it is easy to prove that type assignment in this system is closed under -reduction. The proof for this result is split in two parts, Lemma 2.7 and Theorem 2.8. The lemma is also used in the proof of Lemmas 3. </p><formula xml:id="formula_42">(2.5 (ii)) 9 [B; x: `e M: ! &amp; B; x: `E x: ] ) (2.5 (i), x not in M) 9 [B `e M: ! &amp; E ] ) (2.1) 9 [B `e M: ! &amp; ! E ! ] ) (2.6)</formula><p>B `e M: ! . As in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b0">1]</ref>, it is possible to prove that the essential type assignment system is closed under = . In the first paper, this result was obtained by a 'Cut and Paste'-proof (see Subsection 1.1). In the latter two papers this result was obtained by building a filter -model as sketched in Section 1.3; from the fact that every M is interpreted by the set of its assignable types, and that set is a filter, the result is then immediate (see also <ref type="bibr">Corollary 4.3.5)</ref>. In this paper the result will first be obtained directly, without constructing a filter model; in this way the precise behaviour of the type constructor '\' and the type constant ! can be made apparent.</p><p>First, a substitution lemma is proved. Notice that, unlike for many other notions of type assignment (Curry's system, the CD-system, the polymorphic type discipline <ref type="bibr" target="#b19">[20]</ref>), the implication holds in both directions. Lemma 2.9 9 [B; x: `E M: &amp; B `E N: ] ( ) B `E M[N=x]: . Proof: By induction on M. Only the case 2T s is considered, of which only the non-trivial parts are shown.</p><formula xml:id="formula_43">i) M x. )) 9 [B; x: `e x: &amp; B `E N: ] ) (2.5 (i)) 9 [ E &amp; B `E N: ] ) (2.5 (iv) &amp; 2.6) B `e x[N=x]: . ii) M y6 = x.</formula><p>() B `e y[N=x]: ) B `e y: &amp; B `E N:!.</p><p>iii) M y:M 0 . By Lemma 2.5 (iii) and induction. </p><formula xml:id="formula_44">iv) M M 1 M 2 . () B `e M 1 M 2 [N=x]: ) (2.5 (ii) &amp; IH) 9 1 ; 2 ; [B; x: i `e M 1 : ! &amp; B `E N: 1 &amp; B; x: 2 `E M 2 : &amp; B `E N: 2 ] ) ( = 1 \ 2 &amp; 2.5 (v) &amp; 2.5 (vii)) 9 [B; x: `e M 1 M 2 : &amp; B `E N: ]. Theorem 2.10 M = N ) (B `E M: ( ) B `E N: ),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Approximation and normalization results</head><p>In <ref type="bibr" target="#b33">[34]</ref> an approximation theorem is proved, that formulates the relation between the types assignable to a term and those assignable to its approximants, as defined in <ref type="bibr" target="#b36">[37]</ref> (see Definition 3.1.1 below).</p><p>Property 3.1 B `\ M: if and only if there exists A2A(M) such that B `\ A: . In this section, an 'essential' variant of this property will be proved; for every M; B and such that B `E M: , there is an A 2 A(M) such that B `E A: . In <ref type="bibr" target="#b33">[34]</ref> this result is obtained through a normalization of derivations, where all (!I)-(!E) pairs, that derive a type for a redex ( x:M)N, are replaced by one for its reduct M[N=x], and all pairs of (\I)-(\E) are eliminated.</p><p>(This technique is also used in <ref type="bibr" target="#b8">[9]</ref> and <ref type="bibr" target="#b5">[6]</ref>. It requires a rather difficult notion of length of a derivation to show that this process terminates.) In this paper, this result will be proved using the computability technique, following Tait <ref type="bibr" target="#b35">[36]</ref>, as was done in <ref type="bibr" target="#b10">[11]</ref>, and <ref type="bibr" target="#b16">[17]</ref>.</p><p>With this result, it can be shown that the BCD-system is conservative over the essential system (Theorem 4.1.5), and prove that the set of all terms having a (head) normal form are typeable in `e (with a type without !-occurrences) (Theorem 3.3.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Approximate normal forms</head><p>The notion of approximant was first presented by C. Wadsworth <ref type="bibr" target="#b36">[37]</ref> and is defined using the notion of terms in ?-normal form (like in <ref type="bibr" target="#b4">[5]</ref>, ? is used, instead of Ω; also, the symbol &lt; is used as a relation on Λ?-terms, inspired by a similar relation defined on Böhm-trees in <ref type="bibr" target="#b4">[5]</ref>). Definition 3.1.1 i) The set of Λ?-terms is defined as the set Λ of lambda terms, extended by: ?2</p><formula xml:id="formula_45">Λ?.</formula><p>ii) The notion of reduction ! ? is defined as ! , extended by: a) x.? ! ? ?. b) ?M ! ? ?.</p><p>iii) The set of normal forms for elements of Λ? with respect to ! ? is the set N of ?-normal forms or approximate normal forms and is inductively defined by: a</p><formula xml:id="formula_46">) ?2N. b) If A2N, A6 = ?, then x:A2N. c) If A 1 , : : :, A n 2N (n 0), then xA 1 A n 2N.</formula><p>The rules of the essential system are generalized to terms containing ? by allowing for the terms to be elements of Λ?. This implies that, because essential type assignment is almost syntax directed, if ? occurs in a term M and B `E M: , then either = !, or in the derivation for M: , ? appears in the right hand subterm of an application on which the rule (!E) is used with n = 0. Moreover, the terms x.? and ?M 1 M n are typeable by ! only.</p><formula xml:id="formula_47">Definition 3.1.2 i) The relation &lt; (Λ?) 2 is defined by: a) ? &lt; M. b) x &lt; x. c) M &lt; M 0 ) x:M &lt; x:M 0 . d) M 1 &lt; M 0 1 &amp; M 2 &lt; M 0 2 ) M 1 M 2 &lt; M 0 1 M 0 2 . For A2N, M 2Λ, if A &lt; M, then A is a direct approximant of M.</formula><p>ii) The relation</p><formula xml:id="formula_48">N Λ is defined by: A v M ( ) 9 M 0 = M [A &lt; M 0 ]. If A M, then A is an approximant of M. iii) A(M) = fA 2 N j A v Mg.</formula><p>The following properties of approximants hold: Proof: Easy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Approximation result</head><p>In this subsection, the approximation theorem will be proved. For reasons of readability, in this subsection 9 A2A(M) [B `E A: ] will be abbreviated by App (B; M; ).</p><formula xml:id="formula_49">Lemma 3.2.1 i) App (B; xM 1 M n ; ! ) &amp; App (B 0 ; N; ) ) App (ΠfB; B 0 g; xM 1 M n N; ). ii) App (B fz: g; Mz; ) &amp; z 6 2FV(M) &amp; 2T s ) App (B; M; ! ). iii) App (B; C[M [N=x]]; ) ) App (B; C[( x:M)N]; ). Proof: i) A2A(xM 1 M n ) &amp; B `E A: ! &amp; A 0 2A(N) &amp; B `E A 0 : ) (3.1.3 (i) &amp; 2.5 (ii)) AA 0 2A(xM 1 M n N) &amp; ΠfB; B 0 g `E AA 0 : . ii) A2A(Mz) &amp; B; z: `E A: &amp; z 6 2FV(M) ) (3.1.3 (ii)) a) A A 0 z &amp; z 6 2FV(A 0 ) &amp; A 0 2A(M) &amp; B; z: `e A 0 z: ) (2.7) A 0 2A(M) &amp; B `e A 0 : ! . b) z:A2A(M) &amp; B; z: `e A: ) z:A2A(M) &amp; B `e z:A: ! . iii) Since M = M 0 implies A(M) = A(M 0 ).</formula><p>In order to prove that for each term typeable in `E an approximant with the same type can be found, a notion of computability is introduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.2.2 Comp (B; M; ) is inductively defined by</head><formula xml:id="formula_50">: i) Comp (B; M; ') ( ) B `E M:' &amp; App (B; M; '). ii) Comp (B; M; ! ) ( ) ( Comp (B 0 ; N; ) ) Comp (ΠfB; B 0 g; MN; ) ). iii) Comp (B; M; 1 \ \ n ) ( ) 8 1 i n [Comp (B; M; i )].</formula><p>Notice that Comp (B; M; !) holds as special case of part (iii). Proof: By induction on the structure of types. The case that is a type-variable follows from Theorem 2.10 and Lemma 3.2.1 (iii).</p><formula xml:id="formula_51">Theorem 3.2.7 B `E M: ( ) 9 A2A(M) [B `E A: ]. Proof: )) B `E M: ) (3.2.6) Comp (B; M; ) ) (3.2.5 (ii)) 9 A2A(M) [B `E A: ].</formula><p>() If B `E A: , then by the remark made after Definition 3.1.1, ? appears only in subterms that are typed by !. Since A 2 A(M ), there is an M 0 such that M 0 = M and A &lt; M 0 . Then, by Lemma 2.5 (viii), B `E M 0 : and, by Theorem 2.10, also B `E M: .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Normalization results</head><p>To prepare the characterization of terms by their assignable types, first is proved that a term in ?-normal form is typeable without !, if and only if it does not contain ?. This forms the basis for the result that all normalizable terms are typeable without !.</p><p>Lemma 3.3.1 i) If B `E A: and B; are !-free, then A is ?-free.</p><p>ii) If A is ?-free, then there are !-free B and , such that B `e A: . Proof: By induction on A.</p><p>i) As before, only the part 2T s is shown; only the part A xA 1 A n is of interest. Then, by Lemma 2.5 (ii) and (i), there are 1 ; : : :; n ; 1 ; : : :; n ; , such that x: 1 ! ! n ! 2B, for every 1 i n, B `E A i : i , and 1 ! ! n ! E 1 ! ! n ! . So, especially, for every 1 i n, i E i . By Theorem 2.8, also for every 1 i n, B `E A i : i . Since each i occurs in B, all are !-free, so by induction each A i is ?-free. Then also xA 1 A n is ?-free. ii) a) A x:A 0 . By induction there are B; such that B `e A 0 : and B; are !-free. If x does not occur in B, take an !-free 2T s . Otherwise, there exist x: 2B, and is !-free. In any case, Bnx `E x:A 0 : ! , and Bnx and ! are !-free. and , are !-free.</p><p>Now, as in <ref type="bibr" target="#b0">[1]</ref> for the strict system, it is possible to prove that the essential type assignment system satisfies the main properties of the BCD-system. A &lt; M 0 . Since A is ?-free, in fact A M 0 , so M 0 itself is in normal form, so, especially, M has a normal form.</p><p>() If M 0 is the normal form of M, then it is a ?-free approximate normal form. Then, by Lemma 3.3.1 (ii), there are !-free B; such that B `e M 0 : . Then, by Theorem 2.10, B `e M: . ii) )) If B `e M: , then, by Theorem 3.2.7, 9 A2A(M) [B `E A: ]. By Definition 3.1.1, there exists M 0 = M such that A &lt; M. Since 2T s , A 6 ?, so A is either x:A 1 or xA 1 A n , with n 0. Since AvM 0 , M 0 is either x:M 1 , or xM 1 M n . Then M has a head-normal form.</p><p>() If M has a head-normal form, then there exists M 0 = M such that M 0 is either x, x:M 1 or xM 1 M n , with each M i 2Λ. 1) M 0 x:M 1 . Since M 1 is in head-normal form, by induction there are B; 2T s such that B `E M 1 : . If x: 2B, then Bnx `e x:M 1 : ! , otherwise B `e x:M 1 :!! . 2) M 0 xM 1 M n , (n 0). Take 2T s , then ΠfB 1 ; : : :; B n ; fx:!! !!! gg `e xM 1 M n : . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Soundness and completeness of essential type assignment 4.1 The relation between the BCD-and the essential system</head><p>The essential system is the nucleus of the BCD-system: in this subsection it will be shown that, for any derivation in the BCD-system, it is possible to find an equivalent derivation in the essential system.</p><p>The proof is based on the fact that for every 2T \ there is a 2T S such that , and the Approximation Theorem 3.2.7. Definition 4.1.1 (cf. <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b0">1]</ref>) i) For every 2T \ , 2T S is inductively defined as follows:</p><formula xml:id="formula_52">a) ' = '. b) ( ! ) = ( ! 1 ) \ \ ( ! n ), if = 1 \ \ n (n 0), each i 2T s . c) ( 1 \ \ n ) = 1 \ \ m ,</formula><p>where f 1 ; : : :; m g = f i 2f 1 ; : : :; n gj i 6 = !g. ii) B = fx: j x: 2 Bg.</p><p>Since T S is a proper subset of T \ , is also defined for 2 T S . Notice that ! = !, as a special case of part (i.c), and that ( !!) = !, as a special case of part (i.b). Lemma 4.1.2 i) <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b0">1]</ref> </p><formula xml:id="formula_53">For every 2T \ , . ii) T \ modulo is isomorphic to T S modulo E . iii) ) E . iv) 2T S ) = .</formula><p>Proof: Easy.</p><p>The proof for the main theorem of this section is achieved by proving first, that for every term in N, typeable in `\ , a derivation in the essential system can be built for which basis and type in the conclusion are equivalent, and afterwards generalizing this result to arbitrary lambda terms. </p><formula xml:id="formula_54">F E ![F E !F E ] and G: [F E !F E ]!F E by: i) F d e = d e. ii) G f = "f ! j 2f(" )g.</formula><p>It is easy to check that F and G are continuous. </p><formula xml:id="formula_55">that F G = Id [F E !F E ] . F G f d = "f j 9 2d [ ! 2"f ! j 2f(" )g]g = (4.2.2 (i)) "f j 9 2d [ 2f(" )]g = f(d).</formula><p>Remark that between F E and F S the same relation exists as between F \ and F S , as discussed after Definition 1.4.3. Definition 4.2.5 Let be a valuation of term variables in F E .</p><p>i) [[ M ]] , the interpretation of terms in F E via is inductively defined by: a</p><formula xml:id="formula_56">) [[ x ]] = (x). b) [[ MN ]] = F [[ M ]] [[ N ]] . c) [[ x:M ]] = G ( d2F E . [[ M ]] (d=x) ).</formula><p>ii) B = fx: j 2 (x)g. Proof: By induction on the structure of lambda terms.</p><formula xml:id="formula_57">i) [[ x ]] = (x). Since fy: j 2 (y)g `E x: ( ) 2 (x). ii) [[ MN ]] = "f j9 [B `E N: &amp; B `E M: ! ]g = (2.5 (ii) &amp; (iv)) "f jB `e MN: g = (4.2.2 (ii)) f jB `E MN: g iii) [[ x:M ]] = "f ! jB (" =x) `E M: g = (2.5 (iv))</formula><p>"f ! jB (" =x) `e M: g = (B 0 = B nx) "f ! jB 0 fx: j 2" g `e M: g = (4.2.2 (i))</p><p>"f ! jB 0 fx: g `e M: g = (2.5 (iii))</p><p>"f ! jB 0 `e x:M: ! g = f jB `E x:M: g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Soundness and completeness</head><p>In this subsection completeness for the `E system will be proved. This is done in a way very similar to the one used in <ref type="bibr" target="#b5">[6]</ref>, using the essential filter -model as defined in the previous subsection. Theorem 4.3.1 Soundness. B `E M: ) B `s M: . Proof: By induction on the structure of derivations.</p><p>The method followed in <ref type="bibr" target="#b5">[6]</ref> for the proof of completeness of type assignment is to define a simple type interpretation that satisfies: for all types , ( ) = fd2F \ j 2dg. The approach taken here is to define a type interpretation, and to show that it is simple. Definition 4.3.2 i) 0 : T S ! }(F E ) is defined by: 0 ( ) = fd2F E j 2dg.</p><p>ii) B (x) = f 2T S jB `E x: g. 8 e [e 2 0 ( ) ) "f j 9 2e [ ! 2d]g2 0 ( )] ( )</p><formula xml:id="formula_58">(4.3.2 (i)) 8 e [ 2e ) 2"f j 9 2e [ ! 2d]g] ( ) ( 2T s ) 8 e [ 2e ) 9 2e [ ! 2d]] ( ) (for ), take e = " ) ! 2d. b) Trivial. ii) Easy. Lemma 4.3.4 i) B `E M: ( ) B B `E M: . ii) F E , B , 0 `s B.</formula><p>Proof: i) Because for every x, B (x) is an essential filter.</p><p>ii) x: 2B )</p><formula xml:id="formula_59">((i)) 2f jB B `E x: g ) 2 [[ x ]] B . So [[ x ]] B 2fd2F E j 2dg = 0 ( ).</formula><p>Since the interpretation of terms by their derivable types gives a -model, the following corollary is immediate and an alternative proof for Theorem 2.10.  </p><formula xml:id="formula_60">Proof: Since F E is a -model, if M = N, then [[ M ]] B = [[ N ]] B ; so f jB `E M: g = f jB `E N: g.</formula><formula xml:id="formula_61">F E , B , 0 `s M: ) (1.3.6 (i)) [[ M ]] B 2 0 ( ) ) (4.3.2 (i)) 2 [[ M ]] B ) (4.2.6) B B `E M: ) (4.3.4 (i))</formula><p>B `E M: . Using the relation between the two notions of type assignment that was defined in the previous subsection, soundness and completeness of essential type assignment can also be proved using the result of <ref type="bibr" target="#b5">[6]</ref>  </p><formula xml:id="formula_62">Proof: )) B `E M: ) B `\ M: ) (1.3.7 (i)) B `s M: . () B `s M: ) (1.3.7 (ii)) B `\ M: ) (4.1.5) B `E M: .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Systems with principal types</head><p>It is well known that Curry's system has the principal type property: M is typeable if and only if there is a pair hP; i of basis and type, called the principal pair for M, such that: P `M: , and for every pair hB; i such that B `M: , there exists an operation O (from a specified set of operations) such that O (hP; i) = hB; i.</p><p>The type is then called the principal type for M. For Curry's system the operation O consists entirely of substitutions, i.e. operations that replace type-variables by types. Principal type schemes for Curry's system are defined by J.R. Hindley in <ref type="bibr" target="#b20">[21]</ref>. In this paper the author actually proved the existence of principal types for an object in Combinatory Logic, but the same construction can be used for a proof of the principal type property for terms in Lambda Calculus. The basic idea used in <ref type="bibr" target="#b20">[21]</ref> is to define a unification-algorithm, that is used to construct the principal type for an application form the principal types deduced for its components. Since substitution is an easy operation, in Curry's system the set fhB; ijB `M: g can be computed in a simple way from the principal pair for M.</p><p>There exist three intersection systems for which the principal type property is proved: a CDVsystem in <ref type="bibr" target="#b8">[9]</ref>, the BCD-system in <ref type="bibr" target="#b33">[34]</ref>, and the strict system in <ref type="bibr" target="#b3">[4]</ref>. The technique used for the proofs of these properties is very different for the one used for Curry's sytem. The principal type scheme for a term is in <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b33">[34]</ref>, and <ref type="bibr" target="#b3">[4]</ref> studied through the notion of approximant of a term; terms with a finite number of approximants have finite principal type schemes, while terms with a infinite number of approximants have 'infinite' principal type schemes. It should be noted that, using intersection types, also terms without normal form or, in particular, terms that have an 'infinite' normal form have types. Therefore, a functional characterization of these terms, through a principal type, cannot be represented in a finite way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The operation of expansion</head><p>As mentioned in the introduction of <ref type="bibr" target="#b8">[9]</ref>, using intersection types different types can be assigned to the same component of a given term. Therefore, the structure of derivation does not follow the syntactic structure of terms, and with the only operation of substitution, for a given term, not all types can be obtained. This difficulty is overcome in <ref type="bibr" target="#b8">[9]</ref> by introducing the (context-dependent) operation of expansion.</p><p>The definition of expansion is very complicated. It is an operation on types that deals with the replacement of (sub)types by a number of copies of that type. Expansion on types corresponds to the duplication of (sub)derivations: a subderivation in the right-hand side of an (!E)-step is expanded by copying. In this process, the types that occur in the subderivation are also copied: the types in the conclusion and in the basis of the subderivation will be instantiated into a number of copies.</p><p>Suppose the following is a correct derivation:</p><p>x: ! B A A</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N: xN:</head><p>then, in general, the expansion that replaces by 1 \ \ n creates the following derivation:</p><p>x:</p><formula xml:id="formula_63">1 \ \ n ! B 1 A A N: 1 B n A A N: n xN:</formula><p>Suppose that is a subtype of that is expanded into n copies. If ! is also a subtype of , then just replacing by an intersection of copies of , would generate !( 1 \ \ n ). This is a not a legal type in <ref type="bibr" target="#b8">[9]</ref> and <ref type="bibr" target="#b3">[4]</ref>. Defining an operation of expansion by saying that it should expand the subtype ! into the type ( ! 1 ) \ \ ( ! n ) -which is by definition of the relation a type equivalent to !( 1 \ \ n ) -would give an expansion that is sound, but not sufficient. The subtype ! will, therefore, be expanded into ( 1 ! 1 )\ \( n ! n ), where the 1 ; : : :; n are copies of . This means that also all other occurrences of should be expanded into 1 \ \ n , with possibly the same effect on other types.</p><p>Apparently, the expansion of can have a more than local effect on . Therefore, the expansion of a type is defined in a such a way that, before the replacement of types by intersections, all subtypes are collected that are affected by the expansion of . Then types are traversed top down, and types are replaced if they end with one of the sub-types found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">The system of [9]</head><p>In <ref type="bibr" target="#b8">[9]</ref> principal type schemes are defined for a type assignment system that is like the restricted one from <ref type="bibr" target="#b9">[10]</ref>, but uses the set of types of the unrestricted system. The reason to not use the normalized types as well is the fact that ! is treated as a type constant; since ! can be substituted for ' in !', also !! is considered a type. The principal type property is achieved by defining principal pairs of basis and type for terms in ?-normal form, specifying the operations of expansion and substitution, proved sufficient to generate all possible pairs for those terms from their principal pair, and generalizing this result to arbitrary lambda terms. This technique is the same as for example used in <ref type="bibr" target="#b33">[34]</ref>, <ref type="bibr" target="#b3">[4]</ref>, and Section 6 of this paper.</p><p>The set of ground pairs for a term A2N, as defined in <ref type="bibr" target="#b8">[9]</ref>, is proved to be complete for A, in the sense that all other pairs for A can be generated from a ground pair for A. Ground pairs are those that express the essential structure of a derivation, and types in it are as general as possible with respect to substitutions.</p><p>The proof of the principal type property is obtained by first proving the following:</p><p>If B `A: with A2 N, then there is a substitution Sub and a ground pair hB 0 ; 0 i for A such that Sub (hB; i) = hB 0 ; 0 i.</p><p>If hB; i is a ground pair for A2N and hB 0 ; 0 i can be obtained from hB; i by an expansion, then hB 0 ; 0 i is a ground pair for A.</p><p>For all A2N, every ground pair for A is complete for A.</p><p>In the construction of principal pairs for lambda terms, first for every A 2N a particular pair Pp (A) is chosen of basis P and type , called the principal basis scheme and principal type scheme of A, respectively (see Definition 6. <ref type="bibr">1.5)</ref>. This pair is called the principal pair of A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The proof is completed by proving:</head><p>Pp (A) is a ground pair for A. B `M: if and only if there exists A2A(M) such that B `A: . fPp(A) j A2A(M)g is complete for M.</p><p>For an example of a ground pair, and its relation to the operation of expansion, take the pair h;; (!!(' 0 !' 0 )!' 1 )!' 1 i, which is the principal pair of ( x:x?( y:y)).</p><formula xml:id="formula_64">[x : !!(' 0 !' 0 )!' 1 ]</formula><p>[y : ' 0 ] y:y : ' 0 !' 0 x? : (' 0 !' 0 )!' <ref type="formula">1</ref>x?( y:y) : ' 1</p><p>x:x?( y:y) : (!!(' 0 !' 0 )!' 1 )!' 1 Let Exp be the expansion that copies the subderivation for y:y:' 0 !' 0 , then</p><formula xml:id="formula_65">Exp (h;; (!!(' 0 !' 0 )!' 1 )!' 1 )i = h;; (!!(' 2 !' 2 )\(' 3 !' 3 )!' 1 )!' 1 i,</formula><p>which is, by the results mentioned above, a ground pair for ( x:x?( y:y)).</p><formula xml:id="formula_66">[x : !!(' 2 !' 2 )\(' 3 !' 3 )!' 1 ] [y : ' 2 ] y:y : ' 2 !' 2 [y : ' 3 ]</formula><p>y:y : ' 3 !' 3 x? : (' 2 !' 2 )\(' 3 !' 3 )!' 1</p><p>x?( y:y) : ' 1</p><p>x:x?( y:y) : (!!(' 2 !' 2 )\(' 3 !' 3 )!' 1 )!' 1 (See Definition 6.2.5.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">The system of [34]</head><p>For the system as defined in <ref type="bibr" target="#b5">[6]</ref>, principal type schemes can be defined as in <ref type="bibr" target="#b33">[34]</ref>. There three operations are provided -substitution, expansion, and rise -that are sound and sufficient to generate all suitable pairs for a term M from its principal pair.</p><p>In this paper, all constructions and definitions are made modulo the equivalence relation . In fact, the complexity inserted in the type language of <ref type="bibr" target="#b5">[6]</ref> by allowing for intersection types on the right of the arrow type constructor, disturbs greatly the accessibility of this paper. As shown in Section 6, the results of <ref type="bibr" target="#b33">[34]</ref> can also be obtained for the essential system presented here, that is equally powerful.</p><p>The first operation defined is substitution, that is defined without restriction: the type that is to be substituted can be every element of T \ . Next, the operation of expansion is defined, which is a generalization of the notion of expansion defined in <ref type="bibr" target="#b8">[9]</ref>. Both substitution and expansions are in the natural way extended to operations on bases and pairs. The third operation defined (on pairs) is the operation of rise: it consists of adding applications of the derivation rule ( ) to a derivation. All defined operations are sound in the following sense:</p><p>(Soundness) Let for A 2 N, B; be such that B `\ A: , O be an operation of substitution, expansion or rise, and O (hB; i) = hB 0 ; 0 i. Then B 0 `\ A: 0 . Linear chains of operations are defined as sequences of operations that start with a number of expansions, followed by a number of substitutions, and that end with one rise. (In <ref type="bibr" target="#b33">[34]</ref>, linear chains are defined as those sequences of operations that start with a number of expansions, followed by a number of substitutions or rises; both are allowed. This definition is not complete, in the sense that the fact that the chain ends with one rise is essential in the proof for completeness.) As in <ref type="bibr" target="#b8">[9]</ref>, principal pairs are defined for terms in ?-normal form. The proof of the principal type property is completed by, using the above approximation theorem, proving first that, when A(M) is finite, then fPp (A) j A2A(M)g has a maximal element (see Theorem 6.3.4 and Definition 6.3.5). The following is proved: Property 5.3.1 i) (Completeness) Let A2N. For any pair hB; i such that B `\ A: there exists a linear chain C such that C (Pp (A)) = hB; i. ii) Let B `\ M: . a) A(M) is finite. Then fPp(A) j A2A(M)g has a maximal element, say hP; i. Then there exists a chain C, such that C (hP; i) = hB; i. b) A(M) is infinite. Then there exist a pair hP; i2fPp(A)jA2A(M)g and a chain C, such that C (hP; i) = hB; i.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">The system of [4]</head><p>The proof of the principal type property for the strict system as presented in <ref type="bibr" target="#b3">[4]</ref> is achieved in a way similar to, but significantly different from, the two techniques sketched above. In that paper, three operations on pairs of basis and types are defined: substitution, expansion, and lifting. The operation of lifting resembles the operation of rise as defined in <ref type="bibr" target="#b33">[34]</ref>, the operation of substitution is a modification of the one normally used, and the operation of expansion coincides with the one given in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b33">34]</ref>.</p><p>In order to prove that the operations defined are sufficient, three subsets of the set of all pairs of basis and type are defined, namely: principal pairs, ground pairs, and primitive pairs. (The definition of ground pairs coincides with the one given in <ref type="bibr" target="#b8">[9]</ref>.) In that paper is shown that these form a true hierarchy, that the set of ground pairs for a term is closed under the operation of expansion, that the set of primitive pairs is closed under the operation of lifting, and that the set of pairs is closed for substitution.</p><p>The main result of that paper is reached by showing that the three operations defined are complete: if hB; i is a suitable pair for a term A in ?-normal form, and hP; i is the principal pair for A, then there are a sequence of operations of expansion Exp, an operation of lifting Lift, and a substitution Sub, such that</p><formula xml:id="formula_67">hB; i = Sub (Lift (Exp ! (hP; i))).</formula><p>Finally, this result is generalized to arbitrary lambda terms.</p><p>Because of technical reasons, substitution is in <ref type="bibr" target="#b3">[4]</ref> defined as (' 7 ! ), where ' is a typevariable and 2T s f!g, so it can also replace type-variables by the type constant ! (this is not needed in the proofs of Section 6). Although substitution is normally defined on types as the operation that replaces type-variables by types, for strict types this definition would not be correct.</p><p>For example, the replacement of ' by ! would transform !' (or \') into !! ( \!), which is not a strict type. Therefore, for strict types substitution is not defined as an operation that replaces type-variables by types, but as a mapping from types to types, that, in a certain sense, 'normalizes while substituting'.</p><p>The operation of expansion, as defined in <ref type="bibr" target="#b3">[4]</ref>, corresponds to the one given in <ref type="bibr" target="#b8">[9]</ref> and is a simplified version of the one defined in <ref type="bibr" target="#b33">[34]</ref>. A difference is that in those definitions subtypes are collected, whereas the definition of expansion in <ref type="bibr" target="#b3">[4]</ref> (see Definition 6.2.5) collects type-variables.</p><p>Recall Definition 2.1. Observe that strict type assignment is not closed for the relation E , so the following does not hold:</p><p>If B `S M: and E , then B `S M: . As a counter example, take fx: ! g `s x: ! . Notice that ! E \ ! , but it is impossible to derive fx: ! g `S x: \ ! . The operation of lifting as defined in <ref type="bibr" target="#b3">[4]</ref> (see Definition 6.2. <ref type="bibr" target="#b15">16</ref>) is based on the relation E , in the same way as the operation of rise is based on . As shown there, and illustrated above, that operation is not sound on all pairs hB; i. (In fact, as argued in <ref type="bibr" target="#b3">[4]</ref>, it is impossible to formulate an operation that performs the desired lifting and is sound on all pairs.) The reason for this is that introducing a derivation rule, allowed on all terms, using the relation E , corresponds to a -reduction step (see Theorem 2.8), and the strict system is not closed for -reduction. Since strict type assignment is not closed for E , and the operation of lifting applies E to a derivation, it is clear that a conflict arises.</p><p>However, in <ref type="bibr" target="#b3">[4]</ref> it is shown that the operation defined there is sound on primitive pairs. The definition for primitive pairs is based on the definition of ground pairs as given in <ref type="bibr" target="#b8">[9]</ref>. The main difference between ground pairs and primitive pairs is that in a primitive pair a predicate for a term-variable (bound or free) is not the smallest type needed, but can contain some additional, irrelevant types. The problem mentioned above is then solved by allowing liftings only on primitive pairs for terms.</p><p>The result of <ref type="bibr" target="#b3">[4]</ref> follows from:</p><p>Every principal pair is a ground pair.</p><p>-For every expansion Exp, if hB; i is a ground pair for A and Exp (hB; i) = hB 0 ; 0 i, then hB 0 ; 0 i is a ground pair for A. -If B `S A: and Exp (hB; i) = hB 0 ; 0 i, then B 0 `S A: 0 . Every ground pair is a primitive pair. For all A 2N, liftings Lift: if hB; i is a primitive pair for A, then Lift (hB; i) is a primitive pair for A.</p><p>Every primitive pair is a (normal) pair.</p><p>If B `S A: , then for every substitution Sub: if Sub (hB; i) = hB; 0 i, then B 0 `S A: 0 .</p><p>Although lifting is not sound on all pairs, using the results mentioned above it is possible to prove that the three operations defined in <ref type="bibr" target="#b3">[4]</ref> are sufficient (complete): for every pair hB; i and A2 N, if B `S A: , then there exists a number of expansion, one lifting, and a substitution, such that hB; i can be obtained from Pp (A) by performing these operations in sequence. As in <ref type="bibr" target="#b33">[34]</ref>, this result is then generalized to arbitrary lambda terms (see Property 5.3.1 and Theorem 6.3.6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Principal type property for the essential system</head><p>Using a technique different from those discussed above, in this section the proof for the principal type property of the essential system will be given. For each lambda term the principal pair (of basis and type) will be defined. Four operations on pairs of basis and types will be defined, namely expansion, covering, substitution, and lifting, that are correct and sufficient to generate all derivable pairs for lambda terms in the essential system.</p><p>A relevant restriction of the essential system will be presented ( `R ), that is close to the system defined in Definition 1.2.3. For this system, the principal type property will be proved, using a technique different from the one used in <ref type="bibr" target="#b8">[9]</ref>. In fact, it will be shown that, if B `R M: and hP; i is the principal pair for M, then there is a chain C of operations, consisting of expansions, one covering, and one substitution, such that C (hP; i) = hB; i. Using this result, the principal type property for the essential system will be proved.</p><p>In <ref type="bibr" target="#b3">[4]</ref>, the main problem to solve was to find an operation of lifting that was able to take the special role of the relation S into account. As argued in Subsection 5.4, for the strict system there exist no operation of lifting that is sound on all pairs. Since the essential system is more liberal than the strict one, in the sense that the essential system is closed for the relation E , the operation of lifting as defined in <ref type="bibr" target="#b3">[4]</ref> is a sound operation for the essential system (see Theorem 6.2.17). It is then easy to show that, with just the operations as defined in <ref type="bibr" target="#b3">[4]</ref>, the principal type property holds for the essential system.</p><p>In this subsection a different proof will be presented, that follows a new approach. The most significant difference between proofs for the principal type property made in other papers and the one presented here, is that, in a certain sense, the operations presented in this section are more elegant. In <ref type="bibr" target="#b33">[34]</ref>, there is an overlap between operations; for example, intersections can be introduced by expansions as well as by substitutions and rise. Also, in <ref type="bibr" target="#b3">[4]</ref> the step from the pair hB; i to hB; !i can be made using a lifting as well as a substitution. The operations of expansion, covering, and substitution as defined in this paper are 'orthogonal' in that sense; no kind of operation can be mimicked by another kind of operation.</p><p>The difference between the operations specified in <ref type="bibr" target="#b3">[4]</ref> and this paper lie in the fact that here the operation of substitution has been changed, in a subtle, natural, but drastic way: a substitution can no longer replace a type-variable by !. In the papers discussed above that possibility existed and, especially in <ref type="bibr" target="#b8">[9]</ref> and <ref type="bibr" target="#b3">[4]</ref>, caused inconvenience, since there a 'normalization-after-substitution' was called for, explicitly defined in <ref type="bibr" target="#b8">[9]</ref>, and part of the definition of substitution in <ref type="bibr" target="#b3">[4]</ref>. The approach of this paper will be to allow of only substitutions of type variables by strict types, and to introduce a separate operation of covering, that deals with the assignment of ! to subterms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Relevant intersection type assignment</head><p>The next definition presents a restricted variant of the essential system, that is similar to that of Definition 1.2.3, and is the system used in <ref type="bibr" target="#b18">[19]</ref>. Since bases play a more significant role in this system, the presentation of the derivation rules differs from the one used above. Definition 6.1.1 i) Relevant intersection type assignment and relevant intersection derivations are defined by the following natural deduction system (where all types displayed are in T s , except for in rules (!E) and (!I)):</p><formula xml:id="formula_68">(Ax): fx: g `R x: B 1 `R M: ! B 2 `R N:</formula><p>(!E): ii) `R is defined by: B `R M: if and only if there is a relevant derivation that has B `R M:</p><formula xml:id="formula_69">ΠfB 1 ; B 2 g `R MN: B 1 `R M: 1 B n `R M: n<label>(</label></formula><p>as conclusion.</p><p>Notice that, by rule (\I), ; `R M:!, for all terms M. Notice moreover, that this system is indeed relevant, in the sense that only those statements occur in bases that are actually used for the derived statement.</p><p>For terms in N, the relation between the essential and the relevant system is formulated by: Lemma 6.1.2 If A is in ?-normal form and B `E A: , then there are B 0 ; 0 such that B 0 `R A: 0 , 0 E and B E B 0 .</p><p>Proof: By induction on the structure of terms in N. i) B `?:!, then B 0 = ;, and 0 = !.</p><p>ii) B `E x:A 0 : ! , with A 0 6 = ?, then B fx: g `E A 0 : . By induction, there are B 0 ; 0 ; 0 such that 0 E , B fx: g E B 0 fx: 0 g, and B 0 fx: 0 g `R A 0 : 0 . Then also 0 ! 0 E ! , B E B 0 , and B 0 `R x:A 0 : 0 ! 0 . iii) B `E xA 1 A n : , with n 0. Then there are 1 ; : : :; n such that, for 1 i n, B `E A i : i , and B `E x: 1 ! ! n ! . By induction, for every 1 i n, there are B i ; 0 i , such that B i `R A i : 0 i , 0 i E i , and B E B i . Then also B E ΠfB 1 ; : : :; B n ; fx: 0 1 ! ! 0 n ! gg, and ΠfB 1 ; : : :; B n ; fx: 0  1 ! ! 0 n ! gg `R xA 1 A n : .</p><p>Using the same technique as in Subsection 3.2, the following theorem can be proved. Using this approximation result for the relevant system, the following becomes easy.</p><p>Theorem 6.1.4 If B `E M: , then there are B 0 ; 0 such that B 0 `R M: 0 , 0 E and B E B 0 .</p><p>Proof: If B `E M: then, by Theorem 3.2.7, there is an A 2 A(M) such that B `E A: . By Lemma 6.1.2, there are B 0 ; 0 such that B 0 `R A: 0 , 0 E and B E B 0 . Then, by Theorem 6.1.3, B 0 `R M: 0 .</p><p>In the construction of principal pairs for lambda terms, first, for any A 2 N, a particular pair Pp (A) of basis P and type is chosen, which will be called respectively the principal basis scheme and principal type scheme of A. Principal pairs for the relevant, and the essential system are defined by: Definition 6.1.5 i) Let A2N. Pp (A), the principal pair of A, is defined by: a) Pp (?) = h;; !i. b) Pp (x) = hfx:'g; 'i. c) If A6 = ?, and Pp (A) = hP; i, then: 1) If x occurs free in A, and x: 2P, then Pp ( x:A) = hPnx; ! i.</p><p>2) Otherwise Pp ( x:A) = hP; !! i. d) If for 1 i n, Pp (A i ) = hP i ; i i (disjoint in pairs), then Pp (xA 1 A n ) = hΠfP 1 ; : : :; P n ; fx:</p><formula xml:id="formula_70">1 ! ! n !'gg; 'i,</formula><p>where ' is a type-variable that does not occur in Pp (A i ), for 1 i n.</p><p>ii) P = fhP; ij9 A2N [Pp (A) = hP; i]g.</p><p>The following result is almost immediate: Lemma 6.1.6 If Pp (A) = hP; i, then P `R A: and P `E A: . Proof: Easy.</p><p>The notion of principal pairs for terms in N will be generalized to arbitrary lambda terms in Definition 6.3.5.</p><p>The principal pairs in the systems as presented in <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b33">[34]</ref>, and <ref type="bibr" target="#b3">[4]</ref> are exactly the same. Since the essential type assignment system is a sub-system of the BCD-system (in the sense that if B `E M: , then also B `\ M: , but not vice-versa), and it is a super-system for both the strict and the restricted CDV-system, it not surprising that the principal pairs in the essential system turn out to be exactly the same as the principal pairs in all the other systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Operations</head><p>Substitution is normally defined on types as the operation that replaces type-variables by types, without restriction. The notion of substitution defined here replaces type-variables by strict types only. Although this is a severe restriction with regard to the usual approach, the operation will proven to be sufficient. Definition 6.2.1 i) The substitution (' 7 ! ) : T S ! T S , where ' is a type-variable and 2T s , is defined by:</p><formula xml:id="formula_71">a) (' 7 ! ) (') = . b) (' 7 ! ) (' 0 ) = ' 0 , if '6 ' 0 . c) (' 7 ! ) ( ! ) = (' 7 ! ) ( ) ! (' 7 ! ) ( ). d) (' 7 ! ) ( 1 \ \ n ) = (' 7 ! ) ( 1 ) \ \ (' 7 ! ) ( n ).</formula><p>ii) If Sub 1 and Sub 2 are substitutions, then so is Sub 1 Sub 2 , where Sub 1 Sub 2 ( ) = Sub 1 (Sub 2 ( )).</p><p>iii) Sub (B) = fx:Sub( ) j x: 2Bg. iv) Sub (hB; i) = hSub(B); Sub ( )i.</p><p>The operation of substitution is sound for the relevant system. Theorem 6.2.2 If B `R A: , then for every substitution Sub: if Sub (hB; i) = hB 0 ; 0 i, then B 0 `R A: 0 . Proof: By straightforward induction on the definition of `R.</p><p>The following is needed in the proof of Theorem 6.3.3. Lemma 6.2.3 Let 2T s and Sub be a substitution such that Sub ( ) = 0 . Then: i) If Sub (B fx: g) = B 0 fx: 0 g, then Sub (hB; ! i) = hB 0 ; 0 ! 0 i. ii) If for every 1 i n, Sub (hB i ; i i) = hB 0 i ; 0 i i, then Sub (hΠfB 1 ; : : :; B n ; fx: 1 ! ! n ! gg; i) = hΠfB 0</p><p>1 ; : : :; B 0 n ; fx: 0 1 ! ! 0 n ! 0 gg; 0 i.</p><p>Proof: Immediately by Definition 6.2.1.</p><p>The operation of expansion of types defined here corresponds to the notion of expansion as defined in <ref type="bibr" target="#b33">[34]</ref> and <ref type="bibr" target="#b3">[4]</ref>. A difference between the notions of expansion as defined in <ref type="bibr" target="#b8">[9]</ref> and <ref type="bibr" target="#b33">[34]</ref> is that in those papers a set of types involved in the expansion is created. As in <ref type="bibr" target="#b3">[4]</ref>, here just type-variables are collected, so the definition of expansion presented here is less complicated. Definition 6.2.4 i) If B is a basis and 2T S , then T hB; i is the set of all strict subtypes occurring in the pair hB; i.</p><p>ii) The last type-variable of a strict type is defined by: a) The last type-variable of ' is '.</p><p>b) The last type-variable of  </p><formula xml:id="formula_72">; i ( 1 \ \ n ) = Exp h ;n;B; i ( 1 ) \ \ Exp h ;n;B; i ( n ). b) If the last type-variable of is in V (hB; i), then Exp h ;n;B; i ( ) = Sub 1 ( ) \ \ Sub n ( ). c)</formula><formula xml:id="formula_73">;; i. Then V ' 1 (h;; i) = f' 1 , ' 3 g, and Exp ( ) = ((' 4 \' 5 )!' 2 )!((' 6 !' 4 )\(' 7 !' 5 ))!(' 6 \' 7 )!' 2 .</formula><p>Notice that both h;; i and Exp (h;; i) are pairs for the term xyz:x(yz) in `E:</p><formula xml:id="formula_74">y : ' 3 !' 1 z : ' 3 yz : ' 1 x : ' 1 !' 2 x(yz) : ' 2 z:x(yz) : ' 3 !' 2 yz:x(yz) : (' 3 !' 1 )!' 3 !' 2 xyz:x(yz) : (' 1 !' 2 )!(' 3 !' 1 )!' 3 !' 2</formula><p>so all type-variables in hB j ; l j i are in V (hB; i), for 1 j m, 1 l k j . So all type-variables in hΠfB 1 ; : : :; B m ; fx: 1 ! ! m ! gg; i are in V (hB; i). Lemma 6.2.9 Let B 0 `R A: , where 2 T s , and Exp = h ; n; B; i be an expansion such that T hB 0 ; i T hB; i . Then either there are B 1 ; : : :; B n , 1 ; : : :; n , such that Exp (hB 0 ; i) = hΠfB 1 ; : : :; B n g; 1 \ \ n i and, for every 1 i n, hB i ; i i is a trivial variant of hB 0 ; i, or Exp (hB 0 ; i) = hB 00 ; 0 i, with 0 2 T s . Proof: By Lemmas 6.2.7, and 6.2.8.</p><p>Notice that, in particular, this lemma holds for the case that hB 0 ; i = hB; i.</p><p>The following property is needed in the proofs for the fact that expansion is sound (Theorem 6.2.11), and for completeness of chains of operations (Theorem 6.3.3). <ref type="bibr">Property 6.2.10 ([4]</ref>) Let Exp be an expansion, 2T s such that the last type-variable of is not affected by Exp, and Exp ( ) = 0 . Then: i) Exp (hB fx: g; i) = hB 0 fx: 0 g; 0 i, if and only if Exp (hB; ! i) = hB 0 ; 0 ! 0 i. ii) Let Exp (hB i ; i i) = hB 0 i ; 0 i i, for every 1 i n. Then Exp (hΠfB 1 ; : : :; B n ; fx: 1 ! ! n ! gg; i) = hΠfB 0</p><p>1 ; : : :; B 0 n ; fx: 0 1 ! ! 0 n ! 0 gg; 0 i.</p><p>The following theorem states that expansion is sound for relevant type assignment.</p><p>Theorem 6.2.11 If B `R A: and Exp an expansion such that Exp (hB; i) = hB 0 ; 0 i, then B 0 `R A: 0 .</p><p>Proof: By induction on the definition of `R , of which only the part 2T s is shown. By Lemma 6.2.9 either: i) 0 = 1 \ \ m , B 0 = ΠfB 1 ; : : :; B m g, and each hB i ; i i is a trivial variant of hB; i and, therefore, B i `R A: i . So, by rule (\I), B 0 `R A: 0 .</p><p>or ii) 0 2T s . This part is proved by induction on the structure of elements of N. Notice that the case that A ? need not be considered. a) A x:A 0 , = ! , and B fx: g `R A 0 : . Let 0 = 0 ! 0 . (Notice that, if = !, by Definition 6.2.5, also 0 = !). By Lemma 6.2.10 (i), Exp (hB fx: g; i)=hB 0 fx: 0 g; 0 i, and, by induction, B 0 fx: 0 g `R A 0 : 0 . Then also B 0 `R x:A 0 : 0 ! 0 . b) A xA 1 A n , with n 0, B = ΠfB 1 ; : : :; B n ; fx: 1 ! ! n ! gg, and B i `R A i : i , for 1 i n. Let, for 1 i n, Exp (hB i ; i i) = hB 0 i ; 0 i i, then, by induction, for every 1 i n, B 0 i `R A j : 0 i . Then, by Lemma 6.2.10 (ii), Exp (hΠfB 1 ; : : :; B m ; fx: 1 ! ! n ! gg; i) = hΠfB 0 1 ; : : :; B 0 m ; fx: 0 1 ! ! 0 n ! 0 gg; 0 i.</p><note type="other">Then ΠfB 0</note><p>1 ; : : :; B 0 m ; fx: 0</p><formula xml:id="formula_75">1 ! ! 0 n ! 0 gg `R xA 1 A m : 0 .</formula><p>The third operation on pairs defined in this section is the operation of covering. It is, unlike the definition of lifting and rise, not defined on types, but directly on pairs, using the relation defined on pairs. This relation is inspired by the relation &lt; on terms in N, and the relation between the principal pairs of two terms that are in that relation (see also Theorem 6.3.4). Definition 6.2.12 The relation on pairs is defined by: i) hB; i h;; !i. ii) 8 1 i n (n 2) [hB i ; i i hB 0 i ; 0 i i] ) hΠfB 1 ; : : :; B n g; 1 \ \ n i hΠfB 0 1 ; : : :; B 0 n g; 0 1 \ \ 0 n i. iii) hB fx: g; i hB 0 fx: 0 g; 0 i ) hB; ! i hB 0 ; 0 ! 0 i. </p><formula xml:id="formula_76">i) = hB 1 ; 1 i, if hB; i = hB 0 ; 0 i, = hB; i, otherwise.</formula><p>As mentioned above, the operation of covering defined here is inspired by the relation &lt; on terms in N, and, in fact, is very close to a notion defined in <ref type="bibr" target="#b26">[27]</ref>. In that paper principal typings for the type assignment system as presented in <ref type="bibr" target="#b24">[25]</ref> are studied. That system is a combination of the BCD-system and the polymorphic type discipline as presented in <ref type="bibr" target="#b19">[20]</ref>, and can be seen as an extension of the BCD-system by adding quantification over type-variables.</p><p>In <ref type="bibr" target="#b26">[27]</ref>, for every A in ?-normal form a relation A is defined on the inductively defined set of pairs hB; i admissible for A (i.e. such that B `A: ). This relation satisfies:</p><p>If hB 1 ; 1 i A hB 2 ; 2 i, then both pairs are admissible for A. It is, for example, straightforward to show that hB 1 ; 1 i A hB 2 ; 2 i, when restricted to `E , implies hB 1 ; 1 i hB 2 ; 2 i. Notice that the structure of a term A is present in the relation A , but absent in , although of course Definition 6.2.12 follows in part the syntactic structure of terms in N (part (iii) and (iv)).</p><p>The operation of covering is not sound for `E.</p><p>Example 6.2.14 It is easy to check that hfx: \( ! )g; i hfx:!! g; i. Notice that the first pair is legal since fx: \( ! )g `E x: is derivable, but not fx:!! g `E x: . The operation of covering is sound for the relevant system. Theorem 6.2.15 For every covering hB; i; hB 0 ; 0 i , if B `R A: , then B 0 `R A: 0 .</p><p>Proof: By induction on the structure of types.</p><p>i) 0 = !, B 0 = ;. Trivial.</p><p>ii) 0 = 0 1 \ \ 0 n , n 2. Then B = ΠfB 1 ; : : :; B n g, = 1 \ \ n , and, for every 1 i n, B i `R A: i . By Definition 6.2.12 (ii), B 0 = ΠfB 0 1 ; : : :; B 0 n g, and, for every 1 i n, hB i ; i i; hB 0 i ; 0 i i is a covering. Then, by induction, B 0 i `R A: 0 i , so also B 0 `R A: 0</p><formula xml:id="formula_77">1 \ \ 0 n .</formula><p>iii) 0 2T s . By induction on A. a) A x:A 0 . If B `R x:A 0 : , then = ! , B; x: `R A 0 : , and 0 = 0 ! 0 . Since hB; ! i; hB 0 ; 0 ! 0 i is a covering, also hB fx: g; i; hB 0 fx: 0 g; 0 i is a covering, so, by induction, B 0 ; x: 0 `R A 0 : 0 , so B 0 `R x:A 0 : 0 ! 0 . b) A yA 1 A n , with n 0. Since B `R yA 1 A n : , there are B 1 , : : :, B n , 1 ; : : :; n , such that B = ΠfB 1 ; : : :; B n ; fx: 1 ! ! n ! gg, and B i `R A i : i , for every 1 i n.</p><p>Then there are B 0 1 ; : : :; B 0 </p><formula xml:id="formula_78">i) Lift ( ) = 1 , if = 0 ; otherwise, Lift ( ) = . ii) Lift (B) = B 1 , if B = B 0 ; otherwise, Lift (B) = B. iii) Lift (hB; i) = hLift (B); Lift ( )i.</formula><p>The operation of lifting is sound for essential type assignment.</p><p>Theorem 6.2.17 If B `E M: and &lt;hB; i,hB 0 ; 0 i&gt; is a lifting, then B 0 `E M: 0 .</p><p>Proof: By definition 6.2.16, B 0 E B, and E 0 . The proof follows from Lemmas 2.5 (vii) and</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.6.</head><p>Notice that the definition of covering differs from that of lifting, in that &lt;hB 0 ; 0 i, hB 1 ; 1 i&gt; is a lifting only if B 1 E B 0 and 0 E 1 . For a covering, this is normally not the case.</p><p>Example 6.2.18 Since by 6.2.12 (i) hfy:'g; 'i h;; !i, by 6.2.12 (iv) also hfx:'!' 0 ; y:'g; ' 0 i hfx:!!' 0 g; ' 0 i, so by <ref type="bibr">6.2.12 (iii)</ref> hfx:'!' 0 g; '!' 0 i hfx:!!' 0 g; !!' 0 i, and, again by 6.2.12 (iii), h;; ('!' 0 )!'!' 0 i h;; (!!' 0 )!!!' 0 i, but not ('!' 0 )!'!' 0 E (!!' 0 )!!!' 0 , and neither (!!' 0 )!!!' 0 E ('!' 0 )!'!' 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Completeness of operations</head><p>In this subsection, completeness of the above specified operations will be proved, both for the relevant as for the essential system. First the notion of chain of operations is introduced. iii) A relevant chain is a chain of expansions, concatenated with a chain consisting of at most one substitution, and at most one covering, in that order. iv) An essential chain is a relevant chain, concatenated with one operation of lifting.</p><p>The next theorem shows that for every suitable pair for a term A, there exists a chain such that the result of the application of this chain to the principal pair of A produces the desired pair. Part (i) of the Lemmas 6.2.3, and 6.2.10 are needed for the inductive step in case of an abstraction term, part (iii.b) of the proof, part (ii) of those lemmas are needed for the inductive step in case of an application term, part (iii.c). Notice that, by construction, all operations mentioned in that part satisfy the conditions required by these lemmas. Theorem 6.3.2 If B `R A: and Pp (A) = hP; i, then there exists a relevant chain C such that C (hP; i) = hB; i. Proof: By induction on the definition of `R.</p><p>i) ; `R A:!. Take Cov = hP; i; h;; !i , which, by Definition 6.2.13 (i), is a covering. Take</p><formula xml:id="formula_79">C = [Cov].</formula><p>ii) B `R A: 1 \ \ n . Then there are B 1 ; : : :; B n such that for 1 i n, B i `R A: i , and B = ΠfB 1 ; : : :; B n g. Let Exp = h ; n; P; i, then Exp (hP; i) = hΠfP 1 ; : : :; P n g; 1 \ \ n i, with Pp (A) = hP i ; i i. By induction, there exist relevant chains C 1 , : : :, C n such that for 1 i n, C i (hP i ; i i) = hB i ; i i. iii) B `R A: , so 2T s . This part is proved by induction on the structure of elements of N. Notice that the case that A ? need not be considered.  1) x2 FV (A 0 ). Then there are ; such that = ! , B; x: `R A 0 : , and Pp ( x:A 0 ) = hP; ! i, where Pp (A 0 ) = hP fx: g; i. By induction there exists a relevant chain C 0 = Exp ! [Sub] [Cov'] such that C 0 (hP fx: g; i) = hB fx: g; i.</p><p>Let 0 ; 0 ; B 0 be such that Exp ! [Sub] (hP fx: g; i) = hB 0 fx: 0 g; 0 i, and Cov 0 = hB 0 fx: 0 g; 0 i; hB fx: g; i . Since 2 T s , by construction also 0 2 T s and, by Lemmas 6.2.10 (i) and 6.2.3 (i), Exp ! [Sub] (hP; ! i) = hB 0 ; 0 ! 0 i. Take Cov = hB 0 ; 0 ! 0 i; hB; ! i , which, by Definition 6.2.12 (iii), is a covering. Take</p><formula xml:id="formula_80">C = Exp ! [Sub] [Cov].</formula><p>2) x6 2 FV (A 0 ). Then there is such that = !! , and B `R A 0 : . Then Pp ( x:A 0 ) = hP; !! i, where Pp (A 0 ) = hP; i. By induction there exists a chain C 0 = Exp ! [Sub] [Cov'] such that C 0 (hP; i) = hB; i.</p><p>Let B 0 ; 0 be such that Exp ! [Sub] (hP; i) = hB 0 ; 0 i, and Cov 0 = hB 0 ; 0 i; hB; i . Since 2 T s , by construction also 0 2 T s and, by Lemma 6.2.10 (i), and 6.2.3 (i), Exp ! [Sub] (hP; !! i) = hB 0 ; !! 0 i. Take Cov = hB 0 ; !! 0 i; hB; !! i , which, by Definition 6.2.12 (iii), is a covering. Take</p><formula xml:id="formula_81">C = Exp ! [Sub] [Cov].</formula><p>c) A xA 1 A m . Then there are 1 ; : : :; m , B 1 , : : :, B m , such that, for every 1 j m, B j `R A j : j , B = ΠfB 1 ; : : :; B m ; fx: 1 ! ! m ! gg, and P = ΠfP 1 ; : : :; P m ; fx: 1 ! ! m !'gg, = ', with for every 1 j m, Pp (A j ) = hP j ; j i, in which ' does not occur. By induction, there are relevant chains C 1 , : : :, C m such that, for 1 j m, C j (hP j ; j i) = hB j ; j i. Let, for 1 j m, C j = Exp ! j [Sub j ] [Cov j ], and B 0 j ; 0 j be such that Exp ! j [Sub j ] (hP j ; j i) = hB 0 j ; 0 j i, and Cov j = hB 0 j ; 0 j i; hB j ; j i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let Exp ! = Exp</head><p>Then, by Definition 6.2.12 (iv), Cov = hΠfB 0 1 ; : : :; B 0 m ; fx: 0 1 ! ! 0 m ! gg; i , hΠfB 1 ; : : :; B m ; fx: 1 ! ! m ! gg; i, is a covering. Take</p><formula xml:id="formula_82">C = Exp ! [Sub] [Cov].</formula><p>Now, for essential type assignment the completeness of the here specified operations becomes easy to prove: Theorem 6.3.3 If B `E A: and Pp (A) = hP; i, then there exists an essential chain C such that C (hP; i) = hB; i. Proof: By Lemma 6.1.2 there are B 0 ; 0 such that B 0 `R A: , 0 E , and B E B 0 . By Theorem 6.3.2, there exists a relevant chain C such that such that C (hP; i) = hB 0 ; 0 i. Since &lt;hB 0 ; 0 i,hB; i&gt; is a lifting, by Definition 6.3.1 (iv), there exists an essential chain such that C (hP; i) = hB; i.</p><p>Like in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b3">4]</ref>, it can be proved that there exists a precise relation between terms in N and principal pairs, both equipped with an appropriate ordering. This relation is in <ref type="bibr" target="#b33">[34]</ref> defined using substitution of type-variables by the type constant !. Using the notion of substitution defined here, this approach cannot be taken; instead, the relation on pairs as given in Definition 6.2.12 is used. Theorem 6.3.4 hP; i is a meet semilattice isomorphic to hN; &lt; i. Proof: Pp is, as function from N to P, by Definition 6.1.5 (ii), surjective. It is injective because of Theorems 4.2.4, 4.2.6, and 6.3.3. That Pp respects the order, i.e. if A &lt; A 0 , then Pp (A 0 ) Pp (A), follows by straightforward induction. Definition 6.3.5 (cf. <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b3">4]</ref>) i) Let M be a term. Let Π(M ) be the set of all principal pairs for all approximants of M: Π(M ) = fPp(A) j A2A(M)g. ii) Π(M ) is an ideal in P, and therefore: a) If Π(M ) is finite, then there exists a pair hP; i = F Π(M ), where hP; i2P. This pair is then called the principal pair of M. The proof of the principal type property for the essential system is completed by the following: Theorem 6.3.6 Let B and be such that B `E M: . i) A(M) is finite. Let hP; i be the principal pair of M. Then there exists an essential chain C such that C (hP; i) = hB; i. ii) A(M) is infinite. Then there exist a pair hP; i2 Π(M ) and an essential chain C such that C (hP; i) = hB; i.</p><p>Proof: From B `E M: and Theorem 3.2.7 follows 9 A2A(M) [B `E A: ]. Then: i) By Definition 6.3.5, there exists A M 2 A(M) such that Pp (M ) = Pp (A M ) = hP; i. Since Pp (A M ) is minimal in P, so Pp (A M ) Pp (A), by Theorem 6.3.4, A M is maximal in A(M), so A &lt; A M . Then, by <ref type="bibr">Lemma 2.5 (viii)</ref>, also B `E A M : . ii) By Definition 6.3.5, hP; i = Pp (A) 2Π(M). In any case, by Theorem 6.3.3, there exists an essential chain such that C (hP; i) = hB; i.</p><p>The same result, using relevant chains rather than essential chains, can be formulated for the relevant system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusions</head><p>This paper presented the essential intersection type assignment system, as a true restriction of the BCD-system that satisfies all properties of that system, where derivations are syntax-directed. Since all properties of the BCD-system are shown to hold for the essential system, the treatment of intersection types as in <ref type="bibr" target="#b5">[6]</ref> has been too general. Instead of introducing \ as a general typeconstructor, and ! as a type-constant, it is better to treat ! as the empty intersection, and to allow intersections only on the left of the !.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>a valuation and a type interpretation): a) M; ; `M: ( ) [[ M ]] M 2 ( ). b) M; ; `B ( ) M; ; `x: for every x: 2B. c) 1) B `M: ( ) 8 M; ; [M; ; `B ) M; ; `M: ]. 2) B `s M: ( ) 8 M; , simple type interpretations [M; ; `B ) M; ; `M: ]. 3) B `F M: ( ) 8 M; ;F type interpretations [M; ; `B ) M; ; `M: ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 2 .</head><label>2</label><figDesc>5 i) B `E x: ( ) 9 2T S [x: 2B &amp; E ]. ii) B `e MN: ( ) 9 2T S [B `e M: ! &amp; B `E N: ]. iii) B `e x:M: ( ) 9 2T S , 2T s [ = ! &amp; B; x: `e M: ]. iv) B `e M: ( ) B `E M: &amp; 2T s . v) B `E M: ( ) 9 1 ; : : :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Lemma 2 . 6</head><label>26</label><figDesc>If B `E M: and E , then B `E M: , so the following is an admissible rule in `E:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>2 . 1 ,</head><label>21</label><figDesc>Theorem 3.2.5, and Theorem 6.2.15. Lemma 2.7 B; x: `e Mx: &amp; x6 2FV(M) ) B `e M: ! . Proof: B; x: `e Mx: &amp; x6 2FV(M) )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 2 . 8</head><label>28</label><figDesc>If B `E M: and M ! N, then B `E N: . Proof: Only the part 2 T s is shown. The proof is completed by induction on the definition of ! , of which only the part x:Mx ! M is shown, where x does not occur free in M. The other parts are dealt with by straightforward induction. Then: B `e x:Mx: ) (2.5 (iii)) 9 ; [ = ! &amp; B; x: `e Mx: ] ) (2.7) B `e M: . For example, ; `E xy:xy:( ! )! \ ! and ; `E x:x:( ! )! \ ! are both easy to derive.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>so the following rule is an admissible rule in `By induction on the definition of = . The only part that needs attention is that of a redex, B `E ( x:M)N: ( ) B `E M[N=x]: , where 2 T s ; all other cases follow by straightforward induction. To conclude, notice that, if B `E ( x:M)N: , then, by Lemma 2.5 (ii) &amp; (iii), 9 [B; x: `E M: &amp; B `E N: ]. The result follows then by applying Lemma 2.9.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Lemma 3 . 1 .</head><label>31</label><figDesc>3 i) If A2A(xM 1 : : :M n ) and A 0 2A(N), then AA 0 2A(xM 1 : : :M n N).ii) If A2A(Mz) and z 6 2FV(M), then either: a) A A 0 z, z 6 2FV (A), and A 0 2A(M), or b) z:A2A(M).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Lemma 3 . 2 . 3</head><label>323</label><figDesc>Take and such that E . Then Comp (B; M; ) ) Comp (B; M; ). Proof: By straightforward induction on the definition of E . Lemma 3.2.4 Comp (B; C[M [N=x]]; ) ) Comp (B; C[( x:M)N]; ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Corollary 3 . 3 .</head><label>33</label><figDesc>3 i) 9 B; [B `E M: &amp; B; !-free] ( ) M has a normal form. ii) 9 B; [B `E M: &amp; 6 = !] ( ) M has a head normal form.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Theorem 4 .</head><label>4</label><figDesc>1.3 B `\ A: ) B `E A: . Proof: Easy. Definition 4.2.3 Define F:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Theorem 4 . 2 . 4</head><label>424</label><figDesc>&lt;F E , &gt;, with F and G as defined in 4.2.3, is a -model. Proof: By [5].5.4.1 it is sufficient to prove</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Theorem 4 . 2 . 6</head><label>426</label><figDesc>For all M, : [[ M ]] = f jB `E M: g.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>( 2 . 5</head><label>25</label><figDesc>(vi)) "f ! jB `e x:M: ! g = (2.5 (iii) &amp; 4.2.2 (ii))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Theorem 4 .</head><label>4</label><figDesc>3.3 i) The map 0 is a simple type interpretation. ii) If E , then 0 ( ) 0 ( ). Proof: i) It is sufficient to check the conditions of Definition 1.3.5 (ii). a) 8 e [e 2 0 ( ) ) d e2 0 ( )] ( ) (4.2.1 (iii))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Corollary 4 . 3 . 5</head><label>435</label><figDesc>If M = N and B `E M: , then B `E N: .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>x:M:!! (a) If x does not occur in B.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Theorem 6 . 1 . 3 B</head><label>613</label><figDesc>`R M: ( ) 9 A2A(M) [B `R A: ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>1 Exp ! n [Sub 1</head><label>11</label><figDesc>Let, for 1 i n, C i = Exp ! i [Sub i ] [Cov i ], and B 0 i ; 0 i be such that Exp ! i [Sub i ] (hP i ; i i) hΠfB 1 ; : : :; B n g; 1 \ \ n i is a covering. Take C = [Exp] Exp ! Sub n ] [Cov].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>a) A x. Then B = fx: g, P = fx:'g, and = '. Take C = [(' 7 ! )]. b) A x:A 0 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>b) If Π(M ) is infinite, F Π(M ) does not exist in P. The principal pair of M is then the infinite set of pairs Π(M ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>are:If B `M: and M = N, then B `N: . B `M: and is tail-proper, if and only if M has a head normal form. B `M: and ! does not occur in B and , if and only if M has a normal form.That the system is now also closed for -expansion, is solved by the introduction of the type constant ! and the sequences. The type constant ! is the universal type, i.e. each term can be typed by !. It can be used in the expansion from B `M[N=x]: to B `( x:M)N: to type N if N does not occur in M[N=x], and there is no other type such that B `N: . If N does not occur in M[N=x], x does not occur in M, and there is a derivation for B ` x:M:!! . Since N</figDesc><table><row><cell>is typeable by !, by derivation rule (!E) also B `( x:M)N: .</cell></row><row><cell>The sequences allow, as in the CD-system, for a term-variable to have different types within</cell></row><row><cell>a derivation; they are used for the cases that N occurs more than once in M[N=x], and these occurrences were typed in the derivation for B `M[N=x]: with different types. (See also</cell></row><row><cell>Lemma 2.9.)</cell></row><row><cell>Definition 1.2.2 i) The set of normalized types is inductively defined in [10] by:</cell></row><row><cell>a) All type-variables ' 0 , ' 1 , : : : are normalized types.</cell></row><row><cell>b) ! is a normalized sequence.</cell></row><row><cell>c) If 1 ; : : :; n are normalized types (n 1) and, for 1 i n, i 6 = !, then 1 \ \ n is a</cell></row><row><cell>normalized sequence.</cell></row><row><cell>d) If 1 \ \ n is a normalized sequence and is a normalized type, where 6 = !, then 1 \ \ n ! is a normalized type.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Theorem 3.3.2 i) 9 B; [B `e M: &amp; B; !-free] ( ) M has a normal form. ii) 9 B; [B `e M: ] ( ) M has a head normal form.</figDesc><table /><note><p>Proof: i) )) If B `e M: , then, by Theorem 3.2.7, 9 A 2 A(M) [B `E A: ]. Because of Lemma 3.3.1 (i), this A is ?-free. By Definition 3.1.1, there exists M 0 = M such that</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Notice that because of the way in which `E is defined, Corollary 4.3.5 also holds if `E is replaced by `e . Completeness. Let 2T S , then B `s M: ) B `E M: . Proof: B `s M: )</figDesc><table><row><cell>Theorem 4.3.6 (1.3.6 (ii.c.2), 4.3.4 (ii) &amp; 4.3.3)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>(Property 1.3.7). Soundness and completeness of essential type assignment. Let B and contain types in T S . Then B `E M: ( ) B `s M: .</figDesc><table><row><cell>Theorem 4.3.7</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>1 \ \ n ! is the last type-variable of . Definition 6.2.5 For every 2T s , n 2, basis B, and 2T S , the quadruple h ; n; B; i determines an expansion Exp h ;n;B; i : T S ! T S , that is constructed as follows.i) The set of type-variables V (hB; i) affected by Exp h ;n;B; i is constructed by: a) If ' occurs in , then '2V (hB; i). b) If the last type-variable of 2 T hB; i is in V (hB; i), then for all type-variables ' that occur in : '2V (hB; i). ii) Suppose V (hB; i) = f' 1 ; : : :; ' m g. Choose m n different type-variables ' 1 1 , : : :, ' n 1 , : : :, ' 1 m , : : :, ' n m , such that each ' i j does not occur in hB; i, for 1 i n and 1 j m. Let, for 1 i n, Sub i be such that Sub i (' j ) = ' i j , for 1 j m.</figDesc><table /><note><p>iii) Exp h ;n;B; i ( ) is obtained by traversing top-down and replacing every subtype by Sub 1 ( ) \ \ Sub n ( ), if the last type-variable of is in V (hB; i), i.e.: a) Exp h ;n;B</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>iv) 8 1 i n [hB i ; i i hB 0 Definition 6.2.13 A covering Cov is an operation denoted by a pair of pairs hB 0 ; 0 i; hB 1 ; 1 i such that hB 0 ; 0 i hB 1 ; 1 i, and is defined by: Cov (hB;</figDesc><table><row><cell>i ; 0 i i] ) hΠfB 1 ; : : :; B n ; fx: 1 ! ! n ! gg; i</cell><cell>hΠfB 0 1 ; : : :; B 0 n ; fx: 0 1 ! ! 0 n ! gg; i.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>Definition 6.3.1 i) A chain is an object [O 1 ; : : :; O n ], where each O i is an operation of expansion, covering, substitution, or lifting, and [O 1 ; : : :; O n ] (hB; i) = O n ( (O 1 (hB; i)) ). ii) On chains the operation of concatenation is denoted by , and [O 1 ; : : :; O i ] [O i+1 ; : : :; O n ] = [O 1 ; : : :; O n ].</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>\ \ n , and for every 1 i n, B `s M: i .</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Notice that, by part (ii), in particular Comp (fx: g; x; ), for all x; . Theorem 3.2.6 If B = fx 1 : 1 ; : : :; x n : n g, B `E M: , and, for every 1 i n, Comp (B i ; N i ; i ), then Comp (ΠfB 1 ; : : :; B n g; M[N 1 =x 1 ; : : :; N n =x n ]; ). Proof: By induction on the structure of types, of which only the part 2T s is presented. This is shown by induction on the structure of derivations.</p><p>(!I): Then M y:M 0 , = ! , and B; y: `E M 0 : . B = fx 1 : </p><p>Comp (ΠfB 1 ; : : :; B n g;</p><p>As for the BCD-system and the strict system, the relation between types assignable to a lambda term and those assignable to its approximants can be formulated as follows:</p><p>Proof: By induction on the structure of terms in N, using Lemmas 1. <ref type="bibr">3.3, 2.5, and 4.1.2 (iii)</ref>.</p><p>The relation between the two different notions of type assignment is formulated as follows:</p><p>The BCD system is a conservative extension of the essential system. Obviously, since the essential system is a subsystem of the BCD-system, the implication in the other direction also holds: If B `E M: , then B `\ M: . Also using this last result, it is possible to prove completeness of essential type assignment with respect to the simple type semantics (see Theorem 4.3.7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">An essential filter -model</head><p>As in <ref type="bibr" target="#b5">[6]</ref> and <ref type="bibr" target="#b0">[1]</ref>, a filter -model can be constructed. Names will be used to distinguish between the definition of filters in those papers and the one given here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.2.1 i) A subset d of T S is an essential filter if and only if:</head><p>a) 1 ; : : :; n 2d (n 0) )</p><p>then " E V is the smallest essential filter that contains V , and " E = " E f g. iii) F E = fd T S jd is an essential filterg. Application on F E is defined by: d e = " E f j 9 2 e [ ! 2 d]g.</p><p>Notice that every strict filter (Definition 1.4.3) is an essential filter, and that an essential filter is a filter in the sense of Definition 1.3.4.</p><p>If no confusion is possible, the subscript on " will be omitted. Notice that an essential filter is never empty; because of part (i.a), for all d, ! 2d. Notice also that the application on filters as in Definition 1.3.4 is not useful for F E , since it would not be well defined. As in [1], application must be forced to yield filters, since in each arrow type scheme ! 2T S , is strict. &lt;F E , &gt; is a cpo and henceforward it will be considered with the corresponding Scott topology.</p><p>For essential filters the following properties hold:</p><p>For an operation of expansion the following property holds: Lemma 6.2.7 Let Exp = h ; n; B; i be an expansion. Exp ( ) = 1 \ \ n with for every 1 i n, i is a trivial variant of , or Exp ( )2 T s .</p><p>Proof: Immediately by Definition 6.2.5.</p><p>The following lemmas are needed in the proofs of the following theorems. The first states that if the last type-variable of the type in a pair is affected by an expansion, then all type-variables in that pair are affected. Lemma 6.2.8 Let B 0 `R A: , where 2T s with last type-variable ', and h ; n; B; i be an expansion such that T hB 0 ; i T hB; i . If ' 2V (hB; i), then, for every type-variable ' 0 that occurs in hB 0 ; i, ' 0 2V (hB; i).</p><p>Proof: By induction on the structure of elements of N.</p><p>i) A x, then B 0 = fx: g. Since the last type-variable of is in V (hB; i), and 2T hfx: g; i T hB; i , all type-variables that occur in are in V (hB; i). ii) A x:A 0 , then = ! , and B 0 fx: g `R A 0 : (if = !, then B 0 fx: g = B 0 ). Since the last type-variable of ! is the last type-variable of , and T hB 0 fx: g; i T hB 0 ; ! i T hB; i , by induction, all type-variables in hB 0 fx: g; i are in V (hB; i). So all type-variables in hB 0 ; ! i are in V (hB; i).</p><p>iii) A xA 1 A m . Then there are 1 ; : : :; m , B 1 , : : :, B m , such that for every 1 j m, B j `R A j : j , and B 0 = ΠfB 1 ; : : :; B m ; fx: 1 ! ! m ! gg. Since the last type-variable of is in V (hB; i), and 1 ! ! m ! 2T hΠfB 0 ;:::;Bm;fx: 1 ! ! m! gg; i T hB; i , every type-variable in 1 ! ! m ! is in V (hB; i). If, for 1 j m, j = 1 j \ \ k j j , then, for every 1 l k j , the last type-variable of l j is in V (hB; i), and T hB j ; l j i T hΠfB 0 ;:::;Bm;fx: 1 ! ! m! gg; i T hB; i ,</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Complete restrictions of the Intersection Type Discipline</title>
		<author>
			<persName><forename type="first">S</forename><surname>Van Bakel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="page" from="135" to="163" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Partial Intersection Type Assignment of Rank 2 in Applicative Term Rewriting Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Van Bakel</surname></persName>
		</author>
		<idno>92-03</idno>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Nijmegen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Essential Intersection Type Assignment</title>
		<author>
			<persName><forename type="first">S</forename><surname>Van Bakel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FST&amp;TCS &apos;93. 13 th Conference on Foundations of Software Technology and Theoretical Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Shyamasunda</surname></persName>
		</editor>
		<meeting>FST&amp;TCS &apos;93. 13 th Conference on Foundations of Software Technology and Theoretical Computer Science<address><addrLine>Bombay, India</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">761</biblScope>
			<biblScope unit="page" from="13" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Principal type schemes for the Strict Type Assignment System</title>
		<author>
			<persName><forename type="first">S</forename><surname>Van Bakel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="643" to="670" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Barendregt</surname></persName>
		</author>
		<title level="m">The Lambda Calculus: its Syntax and Semantics</title>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
	<note>revised edition</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A filter lambda model and the completeness of type assignment</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barendregt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="931" to="940" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An Extension of the Basic Functionality Theory for the -Calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Formal Logic</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="685" to="693" />
			<date type="published" when="1980">1980</date>
			<publisher>Notre Dame</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Extended type structures and filter lambda models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Honsell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Longo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Colloquium 82</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Lolli</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Longo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Marcja</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam, the Netherlands; North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="241" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Principal type schemes and -calculus semantics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Venneri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">To H.B. Curry, Essays in combinatory logic, lambda-calculus and formalism</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hindley</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Seldin</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic press</publisher>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="535" to="560" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Functional characters of solvable terms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Venneri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Zeitschrift f ür Mathematische Logik und Grundlagen der Mathematik</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="45" to="58" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Type Theories, Normal Forms and D 1 -Lambda-Models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zacchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="85" to="116" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A complete type inference algorithm for simple intersection types</title>
		<author>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Giannini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CAAP &apos;92. 17th Colloquim on Trees in Algebra and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J.-C</forename><surname>Raoult</surname></persName>
		</editor>
		<meeting>CAAP &apos;92. 17th Colloquim on Trees in Algebra and Programming<address><addrLine>Rennes, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">581</biblScope>
			<biblScope unit="page" from="102" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Functionality in combinatory logic</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Curry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Nat. Acad. Sci. U.S.A</title>
		<meeting>Nat. Acad. Sci. U.S.A</meeting>
		<imprint>
			<date type="published" when="1934">1934</date>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="584" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Curry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Feys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatory Logic</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1958">1958</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Decidable Intersection Type System based on Relevance</title>
		<author>
			<persName><forename type="first">F</forename><surname>Damiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Giannini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TACS &apos;94. International Symposium on Theoretical Aspects of Computer Software</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Hagiya</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</editor>
		<meeting>TACS &apos;94. International Symposium on Theoretical Aspects of Computer Software<address><addrLine>Sendai, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">789</biblScope>
			<biblScope unit="page" from="707" to="725" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">F-semantics for intersection type discipline</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Margaria</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantics of data types. International symposium</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Kahn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Macqueen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</editor>
		<meeting><address><addrLine>Sophia-Antipolis, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">173</biblScope>
			<biblScope unit="page" from="279" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A characterisation of F-complete type assignments</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Margaria</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="121" to="157" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Algebras and combinators</title>
		<author>
			<persName><forename type="first">E</forename><surname>Engeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algebra universalis</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="389" to="392" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Discovering Needed Reductions Using Type Theory</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gardner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TACS &apos;94. International Symposium on Theoretical Aspects of Computer Software</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Hagiya</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</editor>
		<meeting>TACS &apos;94. International Symposium on Theoretical Aspects of Computer Software<address><addrLine>Sendai, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">789</biblScope>
			<biblScope unit="page" from="555" to="597" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The System F of Variable Types, Fifteen years later</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Girard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="159" to="192" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The principal type scheme of an object in combinatory logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hindley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">146</biblScope>
			<biblScope unit="page" from="29" to="60" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The simple semantics for Coppo-Dezani-Sallé type assignment</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hindley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International symposium on programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Dezani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="volume">137</biblScope>
			<biblScope unit="page" from="212" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The Completeness Theorem for Typing -terms</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hindley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Lambda calculus models and extensionality</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hindley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Longo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Zeitschrift f ür Mathematische Logik und Grundlagen der Mathematik</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="289" to="310" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Filter Models with Polymorphic Types</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Margaria</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zacchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="page" from="143" to="158" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Polymorphic Type Inference</title>
		<author>
			<persName><forename type="first">D</forename><surname>Leivant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 10 th ACM Symposium on Principles of Programming Languages</title>
		<meeting>10 th ACM Symposium on Principles of Programming Languages<address><addrLine>Austin Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="88" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Principal Typing in a 8\-Discipline. Logic and Computation</title>
		<author>
			<persName><forename type="first">I</forename><surname>Margaria</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zacchi</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A theory of type polymorphism in programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="348" to="375" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Polymorphic Type Inference and Containment</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="211" to="249" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Programming with Intersection Types and Bounded Polymorphism</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<idno>CMU-CS-91-205</idno>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University, School of Computer Science, Pitssburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Intersection Types and Bounded Polymorphism</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TLCA &apos;93. International Conference on Typed Lambda Calculi and Applications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bezem</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</editor>
		<meeting>TLCA &apos;93. International Conference on Typed Lambda Calculi and Applications<address><addrLine>Utrecht, the Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">664</biblScope>
			<biblScope unit="page" from="346" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The essence of Algol</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algorithmic languages</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Van Vliet</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="345" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Preliminary design of the programming language Forsythe</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
		<idno>CMU-CS-88- 159</idno>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Pitssburgh</publisher>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Principal type schemes for an extended type theory</title>
		<author>
			<persName><forename type="first">S. Ronchi</forename><surname>Della Rocca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Venneri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="151" to="169" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Une extension de la théorie des types</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sallé</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, languages and programming. Fifth Colloquium</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Ausiello</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Böhm</surname></persName>
		</editor>
		<meeting><address><addrLine>Udine, Italy; Udine, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="398" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Intensional interpretation of functional of finite types</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Tait</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">The relation between computational and denotational properties for Scott&apos;s D 1 -models of the lambda-calculus</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Wadsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="488" to="521" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
