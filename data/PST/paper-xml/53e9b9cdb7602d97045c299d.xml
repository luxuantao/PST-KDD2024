<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A rewriting logic approach to operational semantics ୋ</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2008-12-06">6 December 2008</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Traian</forename><surname>Florin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Şerbȃnu</forename><surname>¸tȃ</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Faculty of Mathematics and Informatics</orgName>
								<orgName type="institution">University of Bucharest</orgName>
								<address>
									<country key="RO">Romania</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Grigore</forename><surname>Ro</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">José</forename><surname>Meseguer</surname></persName>
							<email>meseguer@cs.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>St</surname></persName>
						</author>
						<author>
							<persName><forename type="first">;</forename><surname>St</surname></persName>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A rewriting logic approach to operational semantics ୋ</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2008-12-06">6 December 2008</date>
						</imprint>
					</monogr>
					<idno type="MD5">408E3D0F439E850097043F2043FBD6AD</idno>
					<idno type="DOI">10.1016/j.ic.2008.03.026</idno>
					<note type="submission">Received 26 February 2007 Revised 9 March 2008</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Operational semantics Rewriting logic Rewriting logic semantics</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper shows how rewriting logic semantics (RLS) can be used as a computational logic framework for operational semantic definitions of programming languages. Several operational semantics styles are addressed: big-step and small-step structural operational semantics (SOS), modular SOS, reduction semantics with evaluation contexts, continuationbased semantics, and the chemical abstract machine. Each of these language definitional styles can be faithfully captured as an RLS theory, in the sense that there is a one-to-one correspondence between computational steps in the original language definition and computational steps in the corresponding RLS theory. A major goal of this paper is to show that RLS does not force or pre-impose any given language definitional style, and that its flexibility and ease of use makes RLS an appealing framework for exploring new definitional styles.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>This paper is part of the rewriting logic semantics (RLS) project (see <ref type="bibr" target="#b57">[57,</ref><ref type="bibr" target="#b56">56]</ref> and the references there in). The broad goal of the project is to develop a tool-supported computational logic framework for modular programming language design, semantics, formal analysis and implementation, based on rewriting logic <ref type="bibr" target="#b50">[50]</ref>.</p><p>Any logical framework worth its salt should be evaluated in terms of its expressiveness and flexibility. Regarding expressiveness, a very pertinent question is: how does RLS express various approaches to operational semantics? In particular, how well can it express various approaches in the SOS tradition? The goal of this paper is to provide an answer to these questions. Partial answers, giving detailed comparisons with specific approaches have appeared elsewhere. For example, <ref type="bibr" target="#b48">[48,</ref><ref type="bibr" target="#b93">91]</ref> provide comparisons with standard SOS <ref type="bibr" target="#b70">[70]</ref>; <ref type="bibr" target="#b55">[55]</ref> compares RLS with both standard SOS and Mosses' modular structural operational semantics (MSOS) <ref type="bibr" target="#b65">[65]</ref>; and <ref type="bibr" target="#b50">[50]</ref> compares RLS with chemical abstract machine (Cham) semantics <ref type="bibr" target="#b8">[8]</ref>. However, no comprehensive comparison encompassing most approaches in the SOS tradition has been given to date. To make our ideas more concrete, in this paper we use a simple programming language, show how it is expressed in each different definitional style, and how that style can be faithfully captured as a rewrite theory in the RLS framework. We furthermore prove correctness theorems showing the faithfulness of the RLS representation for each style. Even though we exemplify the techniques and proofs with a simple language for concreteness' sake, the process of representing each definitional style in RLS and proving the faithfulness of the representation is completely general and mechanical, and in some cases like MSOS has already been automated <ref type="bibr" target="#b19">[19]</ref>. The range of styles covered includes: big-step (or natural) SOS semantics; small-step SOS semantics; MSOS semantics; context-sensitive reduction semantics; continuation-based semantics; and Cham semantics.</p><p>Concerning flexibility, we show that each language definitional style can be used as a particular definitional methodology within rewriting logic. It is not our point in this paper to argue whether certain rewriting-logic specific methodologies are in some ways better or worse than others, but simply to enable the language designer to use his/her favorite techniques within rewriting logic with the benefit of a unified logic and generic tool support. Other than that, representing a language definitional style in rewriting logic, does not make that style more flexible: as it will soon become clear once we start presenting the details, the technique representing it within rewriting logic inherits the same benefits and limitations that the original definitional style had.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Challenges</head><p>Any logical framework for operational semantics of programming languages has to meet strong challenges. We list below some of the challenges that we think any such framework must meet to be successful. We do so in the form of questions from a skeptical language designer, following each question by our answer on how the RLS framework meets each challenge question. The full justification of many of our answers will become clearer in the body of the paper.</p><p>(1) Q: Can you handle standard SOS?</p><p>A: As illustrated in Sections 5 and 6 for our example language, and also shown in <ref type="bibr" target="#b48">[48,</ref><ref type="bibr" target="#b93">91,</ref><ref type="bibr" target="#b55">55]</ref> using somewhat different representations, both big-step and small-step SOS definitions can be expressed as rewrite theories in RLS. Furthermore, as illustrated in Section 7 for our language, and systematically explained in <ref type="bibr" target="#b55">[55]</ref>, MSOS definitions can also be faithfully captured in RLS.</p><p>(</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Q: Can you handle context-sensitive reduction?</head><p>A: There are two different questions implicit in the above question: (i) how are approaches to reduction semantics based on evaluation contexts (e.g., <ref type="bibr" target="#b98">[96]</ref>) represented as rewrite theories? and (ii) how does RLS support context-sensitive rewriting in general? We answer subquestion (i) in Section 8, where we illustrate with our example language a general method to handle evaluation contexts in RLS. Regarding subquestion (ii), it is worth pointing out that, unlike standard SOS, because of its congruence rule, rewriting logic is context-sensitive and, furthermore, using frozen operator arguments, reduction can be blocked on selected arguments (see <ref type="bibr">Section 2)</ref>. Rewriting logic provides no support for matching the context in which a rewrite rule applies and to modify that context at will, which is one of the major strengths of reduction semantics with evaluation contexts. If that is what one wants to do, then one should use the technique in Section 8 instead.</p><p>(3) Q: Can you handle higher-order syntax?</p><p>A: Rewriting logic, cannot directly handle higher-order syntax with bindings and reasoning modulo α-conversion. However, it is well known that higher-order syntax admits first-order representations, such as explicit substitution calculi and de Bruijn numbers, e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b82">82]</ref>. However, the granularity of computations is changed in these representations; for example, a single β-reduction step now requires additional rewrites to perform substitutions. In rewriting logic, because computation steps happen in equivalence classes modulo equations, the granularity of computation remains the same, because all explicit substitution steps are equational. Furthermore, using explicit substitution calculi such as CINNI <ref type="bibr" target="#b82">[82]</ref>, all this can be done automatically, keeping the original higher-order syntax not only for λ-abstraction, but also for any other name-binding operators. (4) Q: What about continuations?</p><p>A: Continuations <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b71">71]</ref> are traditionally understood as higher-order functions. Using the above-mentioned explicit calculi they can be represented in a first-order way. In Section 9, we present an alternative view of continuations that is intrinsically first-order in the style of, e.g., Wand <ref type="bibr" target="#b97">[95]</ref>, and prove a theorem showing that, for our language, first-order continuation semantics and context-sensitive reduction semantics are equivalent as rewrite theories in RLS. We also emphasize that in a computational logical framework, continuations are not just a means of implementing a language, but can be used to actually define the semantics of a language.</p><p>(5) Q: Can you handle concurrency?</p><p>A: One of the strongest points of rewriting logic is precisely that it is a logical framework for concurrency that can naturally express many different concurrency models and calculi <ref type="bibr" target="#b51">[51,</ref><ref type="bibr" target="#b49">49]</ref>. Unlike standard SOS, which forces an interleaving semantics, true concurrency is directly supported. We illustrate this in Section 10, where we explain how Cham semantics is a particular style within RLS. (6) Q: How expressive is the framework?</p><p>A: RLS is truly a framework, which does not force on the user any particular definitional style. This is illustrated in this paper by showing how quite different definitional styles can be faithfully captured in RLS. Furthermore, as already mentioned, RLS can express a wide range of concurrent languages and calculi very naturally, without artificial encodings. Finally, real-time and probabilistic systems can likewise be naturally expressed <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b54">54,</ref><ref type="bibr" target="#b67">67]</ref>. <ref type="bibr" target="#b6">(7)</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Q: Is anything lost in translation?</head><p>A: This is a very important question, because the worth of a logical framework does not just depend on whether something can be represented "in principle", but on how well it is represented. The key point is to have a very small repre-sentational distance between what is represented and the representation. Turing machines have a huge representational distance and are not very useful for semantic definitions exactly for that reason. Typically, RLS representations have what we call " -representational distance", that is, what is represented and its representation differ at most in inessential details. In this paper, we show that all the RLS representations for the different definitional styles we consider have this feature. In particular, we show that the original computations are represented in a one-to-one fashion. Furthermore, the good features of each style are preserved. For example, the RLS representation of MSOS is as modular as MSOS itself. (8) Q: Is the framework purely operational?</p><p>A: Although RLS definitions are executable in a variety of systems supporting rewriting, rewriting logic itself is a complete logic with both a computational proof theory and a model-theoretic semantics. In particular, any rewrite theory has an initial model, which provides inductive reasoning principles to prove properties. What this means for RLS representations of programming languages is that they have both an operational rewriting semantics, and a mathematical model-theoretic semantics. For sequential languages, this model-theoretic semantics is an initial-algebra semantics. For concurrent languages, it is a truly concurrent initial-model semantics. In particular, this initial model has an associated Kripke structure in which temporal logic properties can be both interpreted and model-checked <ref type="bibr" target="#b53">[53]</ref>. <ref type="bibr" target="#b9">(9)</ref> Q: What about performance?</p><p>A: RLS as such is a mathematical framework, not bound to any particular rewrite engine implementation. However, because of the existence of a range of high-performance systems supporting rewriting, RLS semantic definitions can directly be used as interpreters when executed in such systems. Performance will then depend on both the system chosen and the particular definitional style used. The RLS theory might need to be slightly adapted to fit the constraints of some of the systems. In Section 11, we present experimental performance results for the execution of mechanically generated interpreters from RLS definitions for our example language using various systems for the different styles considered. Generally speaking, these performance figures are very encouraging and show that good performance interpreters can be directly obtained from RLS semantic definitions. Although for this paper, we have used hand-made (though mechanical) translations to the presented implementation languages, we envision a toolkit which would use RLS as a common framework for different definitional styles having as back-ends multiple execution languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Benefits</head><p>Our skeptical language designer could still say,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>So what? What do I need a logical framework for?</head><p>It may be appropriate to point out that he/she is indeed free to choose, or not choose, any framework. However, using RLS brings some intrinsic benefits that might, after all, not be unimportant to him/her.</p><p>Besides the benefits already mentioned in our answers to questions in Section 1.1, one obvious benefit is that, since rewriting logic is a computational logic, and there are state-of-the-art system implementations supporting it, there is no gap between an RLS operational semantics definition and an implementation. This is an obvious advantage over the typical situation in which one gives a semantics to a language on paper following one or more operational semantics styles, and then, to "execute" it, one implements an interpreter for the desired language following "in principle" its operational semantics, but using one's favorite programming language and specific tricks and optimizations for the implementation. This creates a nontrivial gap between the formal operational semantics of the language and its implementation.</p><p>A second, related benefit, is the possibility of rapid prototyping of programming language designs. That is, since language definitions can be directly executed, the language designer can experiment with various new features of a language by just defining them, eliminating the overhead of having to implement them as well in order to try them out. As experimentally shown in Section 11, the resulting prototypes can have reasonable performance, sometimes faster than that of well-engineered interpreters.</p><p>A broader, third benefit, of which the above two are special cases, is the availability of generic tools for: (i) syntax; (ii) execution; and (iii) formal analysis. The advantages of generic execution tools have been emphasized above. Regarding (i), languages such as Asf+Sdf <ref type="bibr" target="#b89">[87]</ref> and Maude <ref type="bibr" target="#b23">[23]</ref> support user-definable syntax for RLS theories, which for language design has two benefits. First, it gives a prototype parser for the defined language essentially for free; and second, the language designer can use directly the concrete syntax of the desired language features, instead of the more common, but harder to read, abstract syntax tree (AST) representation. Regarding (iii), there is a wealth of theorem proving and model checking tools for rewriting/equational-based specifications, which can be used directly to prove properties about language definitions. The fact that these formal analysis tools are generic, should not fool one into thinking that they must be inefficient. For example, the LTL model checkers obtained for free in Maude from the RLS definitions of Java and the JVM compare favorably in performance with state-of-the-art Java model checkers <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b33">33]</ref>.</p><p>A fourth benefit comes from the availability in RLS of what we call the "abstraction dial", which can be used to reach a good balance between abstraction and computational observability in semantic definitions. The point is which computational granularity is appropriate. A small-step semantics opts for very fine-grained computations. But this is not necessarily the only or the best option for all purposes. The fact that an RLS theory's axioms include both equations and rewrite rules provides the useful "abstraction dial", because rewriting takes place modulo the equations. That is, computations performed by equations are abstracted out and become invisible. This has many advantages, as explained in <ref type="bibr" target="#b57">[57]</ref>. For example, for formal analysis it can provide a huge reduction in search space for model checking purposes, which is one of the reasons why the Java model checkers described in <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b33">33]</ref> perform so well. For language definition purposes, this again has many advantages. For example, in Sections 6 and 5, we use equations to define the semantic infrastructure (stores, etc.) of SOS definitions; in Section 8 equations are also used to hide the extraction and application of evaluation contexts, which are "meta-level" operations, carrying no computational meaning; in Section 9, equations are also used to decompose the evaluation tasks into their corresponding subtasks; finally, in Sections 7 and 10, equations of associativity and commutativity are used to achieve, respectively, modularity of language definitions, and true concurrency in chemical-soup-like computations. The point in all these cases is always the same: to achieve the right granularity of computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Outline of the paper</head><p>The remainder of this paper is organized as follows. Section 2 presents basic concepts of rewriting logic and recalls its deduction rules and its relationship with equational logic and term rewriting. Section 3 introduces a simple imperative language that will be used in the rest of the paper to discuss the various definitional styles and their RLS representations. Section 4 gathers some useful facts about the algebraic representation of stores. Section 5 addresses the first operational semantics style that we consider in this paper, the big-step semantics. Section 6 discusses the small-step SOS, followed by Section 7 which discusses modular SOS. Sections 8 and 9 show how reduction semantics with evaluation contexts and continuation-based semantics can respectively be faithfully captured as RLS theories, as well as results discussing the relationships between these two interesting semantics. Section 10 presents the Cham semantics. Section 11 shows that the RLS theories corresponding to the various definitional styles provide relatively efficient interpreters to the defined languages when executed on systems that provide support for term rewriting. Finally, Section 12 discusses some related work and Section 13 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Rewriting logic</head><p>Rewriting logic <ref type="bibr" target="#b50">[50]</ref> is a computational logic that can be efficiently implemented and that has good properties as a general and flexible logical and semantic framework, in which a wide range of logics and models of computation can be faithfully represented <ref type="bibr" target="#b48">[48]</ref>. In particular, for programming language semantics it provides the RLS framework, of which we emphasize the operational semantics aspects in this paper (for the mathematical aspects of RLS see <ref type="bibr" target="#b56">[56,</ref><ref type="bibr" target="#b57">57]</ref>).</p><p>Two key points to explain are: (i) how rewriting logic combines equational logic and traditional term rewriting; and (ii) what the intuitive meaning of a rewrite theory is all about. A rewrite theory is a triple R = ( ,E,R) with a signature of function symbols, E a set of (possibly conditional) -equations, and R a set of -rewrite rules which in general may be conditional, with conditions involving both equations and rewrites. That is, a rule in R can have the general form</p><formula xml:id="formula_0">(∀X) t -→ t if ⎛ ⎝ i u i = u i ⎞ ⎠ ∧ ⎛ ⎝ j w j -→ w j ⎞ ⎠</formula><p>Alternatively, such a conditional rule could be displayed with an inference-rule-like notation as</p><formula xml:id="formula_1">i u i = u i ∧ j w j -→ w j t -→ t</formula><p>Therefore, the logic's atomic sentences are of two kinds: equations and rewrite rules. Equational theories and traditional term rewriting systems then appear as special cases. An equational theory ( ,E) can be faithfully represented as the rewrite theory ( ,E,∅); and a term rewriting system ( ,R) can likewise be faithfully represented as the rewrite theory ( ,∅,R).</p><p>Of course, if the equations of an equational theory ( ,E) are confluent, there is another useful representation, namely, as the rewrite theory ( ,∅, -→ E ), where -→ E are the rewrite rules obtained by orienting the equations E as rules from left to right. This representation is at the basis of much work in term rewriting, but by implicitly suggesting that rewrite rules are just an efficient technique for equational reasoning it can blind us to the fact that rewrite rules can have a much more general non-equational semantics. This is the whole raison d'être of rewriting logic. In rewriting logic a rewrite theory R = ( ,E,R) axiomatizes a concurrent system, whose states are elements of the algebraic data type axiomatized by ( ,E), that is, they are E-equivalence classes of ground -terms, and whose atomic transitions are specified by the rules R. The inference system of rewriting logic described below then allows us to derive as proofs all the possible concurrent computations of the system axiomatized by R, that is, concurrent computation and rewriting logic deduction coincide.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rewriting logic deduction</head><p>The inference rules below assume a typed setting, in which ( ,E) is a membership equational theory <ref type="bibr" target="#b52">[52]</ref> having sorts (denoted s,s ,s , etc.), subsort inclusions, and kinds (denoted k,k ,k , etc.), which gather together connected components of sorts. Kinds allow error terms like 3/0, which has a kind but no sort. Similar inference rules can be given for untyped or simply typed (many-sorted) versions of the logic. Given R = ( ,E,R), the sentences that R proves are universally quantified rewrites of the form (∀X) t -→ t , with t,t ∈ T (X) k , for some kind k, which are obtained by finite application of the following rules of deduction: • Replacement. For each θ : X -→ T (Y ) and for each rule in R of the form</p><formula xml:id="formula_2">• Reflexivity. For each t ∈ T (X), (∀X) t -→ t • Equality. (∀X) u -→ v E (∀X)u = u E (∀X)v = v (∀X) u -→ v • Congruence. For each f : s 1 , . . . ,s n -→ s in , with t i ∈ T (X) s i , 1 ≤ i ≤ n, and with t j l ∈ T (X) s j l , 1 ≤ l ≤ m, (∀X) t j 1 -→ t j 1 . . . (</formula><formula xml:id="formula_3">(∀X) t -→ t if ⎛ ⎝ i u i = u i ⎞ ⎠ ∧ ⎛ ⎝ j w j -→ w j ⎞ ⎠ x (∀Y ) θ(x) -→ θ (x) ∧ i (∀Y ) θ(u i ) = θ(u i ) ∧ j (∀Y ) θ(w j ) -→ θ(w j ) (∀Y ) θ(t) -→ θ (t )</formula><p>where θ is the new substitution obtained from the original substitution θ by some possibly complex rewriting of each θ(x) to some θ (x) for each x ∈ X.</p><p>• Transitivity.</p><formula xml:id="formula_4">(∀X) t 1 -→ t 2 (∀X) t 2 -→ t 3 (∀X) t 1 -→ t 3</formula><p>We can visualize the above inference rules as in Fig. <ref type="figure" target="#fig_0">1</ref>. The notation R t -→ t states that the sequent t -→ t is provable in the theory R using the above inference rules. Intuitively, we should think of the inference rules as different ways of constructing all the (finitary) concurrent computations of the concurrent system specified by R. The "Reflexivity" rule says that for any state t there is an idle transition in which nothing changes. The "Equality" rule specifies that the states are in fact equivalence classes modulo the equations E. The "Congruence" rule is a very general form of "sideways parallelism", so that each operator f can be seen as a parallel state constructor, allowing its arguments to evolve in parallel. The "Replacement" rule supports a different form of parallelism, which could be called "parallelism under one's feet", since besides rewriting an instance of a rule's left-hand side to the corresponding right-hand side instance, the state fragments in the substitution of the rule's variables can also be rewritten. Finally, the "Transitivity" rule allows us to build longer concurrent computations by composing them sequentially.</p><p>A somewhat more general version of rewriting logic <ref type="bibr" target="#b15">[15]</ref> allows rewrite theories of the form R = ( ,E ∪ A,R,φ), where the additional component φ is a function assigning to each function symbol f ∈ with n arguments a subset φ(f ) ⊆ {1, . . . ,n} of those argument positions that are frozen, that is, positions under which rewriting is forbidden. The above inference rules can then be slightly generalized. Specifically, the Congruence rule is restricted to non-frozen positions {j 1 , . . . ,j m }, and the substitution θ in the Replacement rule should only differ from θ for variables x in non-frozen positions. The generalized form R = ( ,E ∪ A,R,φ), makes possible a more expressive control of the possibility of rewriting under contexts already supported by the Congruence rule; that is, it endows rewrite theories with flexible context-sensitive rewriting capabilities. <ref type="foot" target="#foot_0">1</ref>Note that, in general, a proof R t -→ t does not represent an atomic step, but can represent a complex concurrent computation. In some of the mathematical proofs that we will give to relate different operational semantics definitions, it will be easier to work with a "one step" rewrite relation → 1 , defined on ground terms. This relation is just the special case in which: (i) Transitivity is excluded; (ii) m = 1 in the Congruence rule (only one rewrite below); and (iii) Replacement is restricted, so that no rewriting of the substitution θ to θ is allowed; and (iv) there is exactly one application of Replacement. The relation → ≤1 is defined by allowing either one or no applications of Replacement in the last condition. Similarly, one can define relations → n (or → ≤n ) by controlling the number of applications of the Transitivity rule. However, it should be noted that rewriting logic does not have a builtin "one-step" rewrite relation, that being the reason for which we need a methodology to encode "one step"-based formalisms such as SOS semantics. The "one-step" relation we define above is only at the deduction level and is introduced solely to help our proofs.</p><p>The whole point of RLS is then to define the semantics of a programming language L as a rewrite theory R L . RLS uses the fact that rewriting logic deduction is performed modulo the equations in R L to faithfully capture the desired granularity of a language's computations. This is achieved by making rewriting rules all intended computational steps, while using equations for convenient equivalent structural transformations of the state, or auxiliary "infrastructure" computations, which should not be regarded as computation steps. Note that this does not preclude performing also equational simplification with equations. That is, the set E of equations in a rewrite theory can often be fruitfully decomposed as a disjoint union E = E 0 ∪ A, where A is a set of structural axioms, such as associativity, commutativity and identity of some function symbols, and E 0 is a set of equations that are confluent and terminating modulo the axioms A. A rewrite engine supporting rewriting modulo A will then execute both the equations E 0 and the rules R modulo A by rewriting. Under a condition called coherence <ref type="bibr" target="#b94">[92]</ref>, this form of execution then provides a complete inference system for the given rewrite theory ( ,E,R). However, both conceptually and operationally, the execution of rules R and equations E 0 must be separated. Conceptually, what we are rewriting with R are E-equivalence classes, so that the E 0 -steps become invisible. Operationally, the execution of rules R and equations E 0 must be kept separate for soundness reasons. This is particularly apparent in the case of executing conditional equations and rules: for a conditional equation it would be unsound to use rules in R to evaluate its condition; and for a conditional rule it would likewise be unsound to use rules in R to evaluate the equational part of its condition.</p><p>There are many systems that either specifically implement term rewriting efficiently, so-called as rewrite engines, or support term rewriting as part of a more complex functionality. Any of these systems can be used as an underlying platform for execution and analysis of programming languages defined using the techniques proposed in this paper. Without attempting to be exhaustive, we here only mention (alphabetically) some engines that we are more familiar with, noting that many functional languages and theorem provers provide support for term rewriting as well: Asf+Sdf <ref type="bibr" target="#b89">[87]</ref>, CafeOBJ <ref type="bibr" target="#b28">[28]</ref>, Elan <ref type="bibr" target="#b9">[9]</ref>, Maude <ref type="bibr" target="#b22">[22]</ref>, OBJ <ref type="bibr" target="#b38">[38]</ref>, and Stratego <ref type="bibr" target="#b95">[93]</ref>. Some of these engines can achieve remarkable speeds on today's machines, in the order of tens of millions of rewrite steps per second.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A simple imperative language</head><p>To illustrate the various operational semantics styles, we have chosen a small imperative language having arithmetic and boolean expressions with side effects (increment expression), short-circuited boolean operations, assignment, conditional, while loop, sequential composition, blocks, and halt. The syntax of the language is depicted in Table <ref type="table" target="#tab_1">1</ref>.</p><p>The semantics of ++x is that of incrementing the value of x in the store and then returning the new value. The increment is done at the moment of evaluation, not after the end of the statement as in C/C++. Also, we assume short-circuit semantics for boolean operations. This BNF syntax is entirely equivalent to an algebraic order-sorted signature having one (mixfix) operation definition per production, terminals giving the name of the operation and non-terminals the arity. For example, the production defining if-then-else can be seen as an algebraic operation</p><formula xml:id="formula_5">if_then_else_ : BExp × Stmt × Stmt → Stmt</formula><p>We will use the following conventions for variables throughout the remainder of the paper: X ∈ Var, A ∈ AExp, B ∈ BExp, St ∈ Stmt, P ∈ Pgm, I ∈ Int, T ∈ Bool = {true,false}, any of them primed or indexed.</p><p>The next sections will use this simple language and will present definitions in various operational semantics styles (bigstep, small-step SOS, MSOS, reduction using evaluation contexts, continuation-based, and Cham), as well the corresponding RLS representation of each definition. We will also characterize the relation between the RLS representations and their corresponding definitional style counterparts, pointing out some strengths and weaknesses for each style. The reader is referred to <ref type="bibr" target="#b44">[44,</ref><ref type="bibr" target="#b70">70,</ref><ref type="bibr" target="#b65">65,</ref><ref type="bibr" target="#b98">96,</ref><ref type="bibr" target="#b8">8]</ref> for further details on the described operational semantics styles.</p><p>We assume equational definitions for basic operations on booleans and integers, and assume that any other theory defined in the rest of this paper includes them. One of the reasons why we wrapped booleans and integers in the syntax is precisely to distinguish them from the corresponding values, and thus to prevent the "builtin" equations from reducing expressions like 3 + 5 directly in the syntax (we wish to have full control over the computational granularity of the language), since our RLS representations aim to have the same computational granularity of each of the different styles represented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Store</head><p>Unlike in various operational semantics, which usually abstract stores as functions, in rewriting logic we explicitly define the store as an algebraic datatype: a store is a set of bindings from variables to values, together with two operations on them, one for retrieving a value, another for setting a value. We show that well-formed stores correspond to partially defined functions. Having this abstraction in place, we can regard them as functions for all practical purposes from now on.</p><p>To define the store, we assume a pairing "binding" constructor "_ → _", associating values to variables,<ref type="foot" target="#foot_1">2</ref> and an associative and commutative union operation "_ _" with ∅ as its identity to put together such bindings. The equational definition E Store of operations _[_] to retrieve the value of a variable in the store and _[_ ← _] to update the value of a variable is given by the following equations, that operate modulo the associativity and commutativity of _ _</p><formula xml:id="formula_6">(S X → I)[X] = I (S X → I)[X ] = S[X ] if X / = X (S X → I)[X ← I ] = S X → I (S X → I)[X ← I ] = S[X ← I ] X → I if X / = X ∅[X ← I] = X → I Note the X /</formula><p>= X appearing as a condition is not a negative condition, but rather a Boolean predicate, which can be equationally defined for any constructor-based type such as the type of variables, for example. Since these definitions are equational, from a rewriting logic semantic point of view they are invisible: transitions are performed modulo these equations. This way we can maintain a coarser computational granularity, while making use of auxiliary functions defined using equations. Although it might seem that, by using built-ins as integers and names, one cannot guarantee the existence of the initial model, notice that all the "built-ins" appearing in these definitions (names, booleans, integers) are definable as initial models of corresponding equational theories. And indeed, when performing formal proofs, one will make use of these equational definitions of the so-called built-ins. A store s is well formed if E Store s = x 1 → i 1 , . . . ,x n → i n for some x j ∈ Var and i j ∈ Int, for all 1 ≤ j ≤ n, such that x i / = x j for any i / = j. We say that a store s is equivalent to a finite partial function</p><formula xml:id="formula_7">σ : Var • → Int, written s σ , if s is well formed and behaves as σ , that is, if for any x ∈ Var,i ∈ Int, σ (x) = i iff E Store s[x] = i.</formula><p>We recall that, given a store-function σ , σ [i/x] is defined as the function mapping x to i and other variables y to σ (y). (1) ∅ ⊥ where ⊥ is the function undefined everywhere.</p><formula xml:id="formula_8">(2) (s x → i) σ implies that s σ [⊥ /x] where σ [⊥ /x] is defined as σ restricted to Dom(σ ) \ {x}. (3) If s σ then also s[x ← i] σ [i/x].</formula><p>Proof.</p><p>(1) Trivial, since E Store ∅[x] = i for any x ∈ Var,i ∈ Int.</p><p>(2) Let σ be such that s σ . We will prove that Dom(σ ) = Dom(σ ) \ {x} and for any x ∈ Dom(σ ), σ (x) = σ (x). Consider an arbitrary x . If x = x, then E Store s[x ] = i for any i , since otherwise we would have E Store s = s x → i which contradicts the well formedness of s x → i; therefore, σ is not defined on</p><formula xml:id="formula_9">x . If x / = x, then E Store s[x ] = (s x → i)[x ]</formula><p>, therefore σ is defined on x iff σ is defined on x , and if so σ (x ) = σ (x ).</p><p>(3) Suppose s σ . We distinguish two cases-if σ is defined on x or if it is not. If it is, then let us say that σ (x) = i ; in that case we must have that</p><formula xml:id="formula_10">E Store s[x] = i which can only happen if E Store s = s x → i , whence E Store s[x ← i] = s x → i. Let</formula><p>x be an arbitrary variable in Var.</p><formula xml:id="formula_11">If x = x then E Store (s[x ← i])[x ] = (s x → i)[x ] = i If x / = x then E Store (s[x ← i])[x ] = (s x → i)[x ] = s [x ] = (s x → i )[x ] = s[x ] If σ is not defined for x, it means that E Store s[x] = i for any i, whence E Store s = s x → i. If E Store s = ∅ then we are done, since E Store (x → i)[x ] = i iff x = x and i = i . If E Store s = ∅, it must be that E Store s = x 1 → i 1 . . . x n → i n with x i / = x. This leads to E Store s[x ← i] = • • • = (x 1 → i 1 . . . x i → i i )[x ← i](x i+1 → i i+1 . . . x n → i n ) = • • • = ∅[x ← i]s = (x → i)s = s(x → i).</formula><p>In the following, we will use symbols S, S , S 1 ,. . ., to denote variables of type Store.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Big-step operational semantics</head><p>Introduced as natural semantics in <ref type="bibr" target="#b44">[44]</ref>, also named relational semantics in <ref type="bibr" target="#b60">[60]</ref>, or evaluation semantics, big-step semantics is "the most denotational" of the operational semantics. One can view big-step definitions as definitions of functions interpreting each language construct in an appropriate domain.</p><p>Big-step semantics can be easily represented within rewriting logic. For example, consider the big-step rule defining integer division</p><formula xml:id="formula_12">A 1 ,σ ⇓ I 1 ,σ 1 , A 2 ,σ 1 ⇓ I 2 ,σ 2 A 1 /A 2 ,σ ⇓ I 1 / Int I 2 ,σ 2 , if I 2 / = 0</formula><p>This rule can be automatically translated into the rewrite rule</p><formula xml:id="formula_13">A 1 /A 2 ,S → I 1 / Int I 2 ,S 2 if A 1 ,S → I 1 ,S 1 ∧ A 2 ,S 1 → I 2 ,S 2 ∧ I 2 / = 0</formula><p>The complete big-step operational semantics definition for our simple language, except its halt statement (which is discussed at the end of this section), which we call BigStep, is presented in Table <ref type="table" target="#tab_2">2</ref>. We choose to exclude from the presentation the semantics for constructs entirely similar to the ones presented, such as "-", "*", "/", and "or". To give a rewriting logic theory for the big-step semantics, one needs to first define the various configuration constructs, which are assumed by default in BigStep, as corresponding operations extending the signature. Then one can define the rewrite theory R BigStep corresponding to the big-step operational semantics BigStep entirely automatically as shown by Table <ref type="table" target="#tab_3">3</ref>. Note that, because the rewriting relation is reflexive, we did not need to add the reflexivity rules for boolean and integer values.</p><p>Due to the one-to-one correspondence between big-step rules in BigStep and rewrite rules in R BigStep , it is easy to prove by induction on the length of derivations the following result: Proposition 2. For any p ∈ Pgm and i ∈ Int, the following are equivalent:</p><formula xml:id="formula_14">(1) BigStep p ⇓ i (2) R BigStep p → 1 i</formula><p>Proof. A first thing to notice is that, since all rules involve configurations, rewriting can only occur at the top, thus the general application of term rewriting under contexts is disabled by the definitional style. Another thing to notice here is </p><formula xml:id="formula_15">• I,σ ⇓ I,σ • X,σ ⇓ σ (X),σ • ++X,σ ⇓ I,σ [I/X] , if I = σ (X) + 1 A 1 ,σ ⇓ I 1 ,σ 1 , A 2 ,σ 1 ⇓ I 2 ,σ 2 A 1 + A 2 ,σ ⇓ I 1 + Int I 2 ,σ 2 • T ,σ ⇓ T,σ A 1 ,σ ⇓ I 1 ,σ 1 , A 2 ,σ 1 ⇓ I 2 ,σ 2 A 1 &lt;=A 2 ,σ ⇓ (I 1 ≤ Int I 2 ),σ 2</formula><p>that all configurations in the right hand sides are normal forms, thus the transitivity rule for rewriting logic also becomes inapplicable. Suppose s ∈ Store and σ : Var</p><p>• → Int such that s σ . We prove the following statements:</p><p>(</p><formula xml:id="formula_16">1) BigStep a,σ ⇓ i,σ iff R BigStep a,s → 1 i,s and s σ , for any a ∈ AExp,i ∈ Int,σ : Var • → Int and s ∈ Store. (2) BigStep b,σ ⇓ t,σ iff R BigStep b,s → 1 t,s and s σ , for any b ∈ AExp,t ∈ Bool,σ : Var • → Int and s ∈ Store. (3) BigStep st,σ ⇓ σ iff R BigStep st,s → 1 s and s σ , for any st ∈ Stmt,σ : Var • → Int and s ∈ Store. (4) BigStep p ⇓ i iff R BigStep p → 1 i , for any p ∈ Pgm and i ∈ Int.</formula><p>Each can be proved by induction on the size of the derivation tree. To avoid lengthy and repetitive details, we discuss the corresponding proof of only one language construct in each category: </p><formula xml:id="formula_17">(1) BigStep x++,σ ⇓ i,σ [i/x] iff i = σ (x) + 1 iff E Store ⊆ R BigStep i = s[x] + 1 iff R BigStep x++,s → 1 i,s[x ← i] . This completes the proof, since s[x ← i] σ [i/x], by 3 in Proposition 1.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X,S → S[X],S ++X,S → I,S[X &lt;</head><formula xml:id="formula_18">∼ I] if I = S[X] + 1 A 1 + A 2 ,S → I 1 + Int I 2 ,S 2 if A 1 ,S → I 1 ,S 1 ∧ A 2 ,S 1 → I 2 ,S 2 A 1 &lt;=A 2 ,S → (I 1 ≤ Int I 2 ),S 2 if A 1 ,S → I 1 ,S 1 ∧ A 2 ,S 1 → I 2 ,S 2 B 1 and B 2 ,S → T,S 2 if B 1 ,S → true,S 1 ∧ B 2 ,S 1 → T,S 2 B 1 and B 2 ,S → false,S 1 if B 1 ,S → false,S 1 not B,S → not(T ),S if B,S → T ,S skip,S → S X:=A,S → S [X &lt; ∼ I] if A,S → I,S St 1 ; St 2 ,S → S if St 1 ,S → S ∧ St 2 ,S → S {St},S → S if St,S → S if B then St 1 else St 2 ,S → S 2 if B,S → true,S 1 ∧ St 1 ,S 1 → S 2 if B then St 1 else St 2 ,S → S 2 if B,S → false,S 1 ∧ St 2 ,S 1 → S 2 while B St,S → S if B,S → false,S while B St,S → S if B,S → true,S 1 ∧ St,S 1 → S 2 ∧ while B St,S 2 → S St.A → I if St,∅ → S ∧ A,S → I,S (2) BigStep b 1 and b 2 ,σ ⇓ t,σ iff (BigStep b 1 ,σ ⇓ false,σ and t = false or BigStep b 1 ,σ ⇓ true,σ and BigStep b 2 ,σ ⇓ t,σ ) iff (R BigStep b 1 ,s → 1 false,s , s σ and t = false or R BigStep b 1 ,s → 1 true,s , s σ , R BigStep b 2 ,s → 1 t,σ and s σ ) iff R BigStep b 1 and b 2 ,s → 1 t,s and s σ . (3) BigStep while b st,σ ⇓ σ iff (BigStep b,σ ⇓ false,σ or BigStep b,σ ⇓ true,σ 1 and BigStep st,σ 1 ⇓ σ 2 and BigStep while b st,σ 2 ⇓ σ ) iff (R BigStep b,s → 1 false,s and s σ or R BigStep b,s → 1 true,s 1 , s 1 σ 1 and R BigStep st,s 1 → 1 s 2 , s 2 σ 2 and R BigStep while b st,s 2 → 1 s and s σ ) iff R BigStep while b st,s → 1 s and s σ . (4) BigStep st.a ⇓ i iff BigStep st, ⊥ ⇓ σ and BigStep a,σ ⇓ i,σ iff R BigStep st,∅ → 1 s , s σ , R BigStep a,s → 1 i,s and s σ iff R BigStep st.a → 1 i</formula><p>This completes the proof.</p><p>The only apparent difference between BigStep and R BigStep is the different notational conventions they use. However, as the above theorem shows, there is a one-to-one correspondence also between their corresponding "computations" (or executions, or derivations). Therefore, R BigStep actually is the big-step operational semantics BigStep, not an "encoding" of it. Note that, in order to be faithfully equivalent to BigStep computationally, R BigStep lacks the main strength of rewriting logic that makes it an appropriate formalism for concurrency, namely, that rewrite rules can apply under any context and in parallel (here all rules are syntactically constrained so that they can only apply at the top, sequentially).</p><p>Strengths. Big-step operational semantics allows straightforward recursive definition. It can be easily and efficiently interpreted in any recursive, functional, or logical framework. It is particularly useful for defining type systems.</p><p>Weaknesses. Due to its monolithic, single-step evaluation, it is hard to debug or trace big-step semantic definitions. If the program is wrong, no information is given about where the failure occurred. Divergence is not observable in the specified evaluation relation. It may be hard or impossible to model concurrent features. It is not modular, e.g., to add side effects to expressions, one must redefine the rules to allow expressions to evaluate to pairs (value-store). It is inconvenient (and non-modular) to define complex control statements; consider, for example, adding halt to the above definition-one needs to add a special configuration halting(I), and the following rules:</p><formula xml:id="formula_19">halt A,S → halting(I) if A.S → I,S St 1 ; St 2 ,S → halting(I) if St 1 ,S → halting(I) while B St,S → halting(I) if B,S → S ∧ St,S → halting(I) St.A,S → I if St,∅ → halting(I)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Small-step operational semantics</head><p>Introduced by Plotkin in <ref type="bibr" target="#b70">[70]</ref>, also called transition semantics or reduction semantics, small-step semantics captures the notion of one computational step.</p><p>One inherent technicality involved in capturing small-step operational semantics as a rewrite theory in a one-to-one notational and computational correspondence is that the rewriting relation is by definition transitive, while the small-step</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 4</head><p>The SmallStep language definition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Types of configurations:</head><formula xml:id="formula_20">AExp,Store , BExp,Store , Stmt,Store , Pgm,Store • X,σ → (σ (X)),σ • ++X,σ → I,σ [I/X] , if I = σ (X) + 1 A 1 ,σ → A 1 ,σ A 1 + A 2 ,σ → A 1 + A 2 ,σ A 2 ,σ → A 2 ,σ I 1 + A 2 ,σ → I 1 + A 2 ,σ • I 1 + I 2 ,σ → I 1 + Int I 2 ,σ A 1 ,σ → A 1 ,σ A 1 &lt;=A 2 ,σ → A 1 &lt;=A 2 ,σ A 2 ,σ → A 2 ,σ I 1 &lt;=A 2 ,σ → I 1 &lt;=A 2 ,σ • I 1 &lt;=I 2 ,σ → (I 1 ≤ Int I 2 ),σ B 1 ,σ → B 1 ,σ B 1 and B 2 ,σ → B 1 and B 2 ,σ • true and B 2 ,σ → B 2 ,σ • false and B 2 ,σ → false,σ B,σ → B ,σ not B,σ → not B ,σ • not true,σ → false,σ • not false,σ → true,σ A,σ → A ,σ X:=A,σ → X:=A ,σ • X:=I,σ → skip,σ [I/X] St 1 ,σ → St 1 ,σ St 1 ; St 2 ,σ → St 1 ; St 2 ,σ • skip; St 2 ,σ → St 2 ,σ • {St},σ → St,σ B,σ → B ,σ if B then St 1 else St 2 ,σ → if B then St 1 else St 2 ,σ • if true then St 1 else St 2 ,σ → St 1 ,σ • if false then St 1 else St 2 ,σ → St 2 ,σ • while B St,σ → if B then (St; while B St) else skip,σ St,σ → St ,σ St.A,σ → St .A,σ A,σ → A ,σ skip.A,σ → skip.A ,σ P, ⊥ → * skip.I,σ eval(P) → I Table 5 R SmallStep rewriting logic theory. • X,S → (S[X]),S • ++X,S → I,S[X &lt; ∼ I] if I = S[X] + 1 • A 1 + A 2 ,S → A 1 + A 2 ,S if • A 1 ,S → A 1 ,S • I 1 + A 2 ,S → I 1 + A 2 ,S if • A 2 ,S → A 2 ,S • I 1 + I 2 ,S → I 1 + Int I 2 ,S • A 1 &lt;= A 2 ,S → A 1 &lt;= A 2 ,S if • A 1 ,S → A 1 ,S • I 1 &lt;= A 2 ,S → I 1 &lt;= A 2 ,S if • A 2 ,S → A 2 ,S • I 1 &lt;= I 2 ,S → (I 1 ≤ Int I 2 ),S • B 1 and B 2 ,S → B 1 and B 2 ,S if • B 1 ,S → B 1 ,S</formula><p>• true and B 2 ,S → B 2 ,S</p><p>• false and B 2 ,S → false,S</p><formula xml:id="formula_21">• not B,S → not B ,S if • B,S → B ,S</formula><p>• not true,S → false,S</p><p>• not false,S → true,S relation is not transitive (its transitive closure can be defined a posteriori). Therefore, we need to devise a mechanism to "inhibit" rewriting logic's transitive and uncontrolled application of rules. An elegant way to achieve this is to view a smallstep as a modifier of the current configuration. Specifically, we consider "•" to be a modifier on the configuration which performs a "small-step" of computation; in other words, we assume an operation •_ : Config → Config. Then, a small-step semantic rule, e.g.,</p><formula xml:id="formula_22">• X := A,S → X := A ,S if • A,S → A ,S • X := I,S → skip,S[X &lt; ∼ I] • St 1 ; St 2 ,S → St 1 ; St 2 ,S if • St 1 ,S → St 1 ,S • skip; St 2 ,S → St 2 ,S • {St},S → St,S • if B then St 1 else St 2 ,S → if B then St 1 else St 2 ,S if • B,S → B ,S • if true then St 1 else St 2 ,S → St 1 ,S • if false then St 1 else St 2 ,S → St 2 ,S • while B St,S → if B then (St; while B St) else skip,S • St.A,S → St .A,S if • St,S → St ,S • skip.A,S → skip.A ,S if • A,S → A ,S</formula><formula xml:id="formula_23">A 1 ,S → A 1 ,S A 1 + A 2 ,S → A 1 + A 2 ,S</formula><p>is translated, again automatically, into a rewriting logic rule, e.g.,</p><formula xml:id="formula_24">• A 1 + A 2 ,S → A 1 + A 2 ,S if • A 1 ,S → A 1 ,S</formula><p>A similar technique is proposed in <ref type="bibr" target="#b55">[55]</ref>, but there two different types of configurations are employed, one standard and the other "tagged" with the modifier. However, allowing "•" to be a modifier rather than a part of a configuration gives more flexibility to the specification-for example, one can specify that one wants two steps simply by putting two dots in front of the configuration.</p><p>The complete<ref type="foot" target="#foot_2">3</ref> small-step operational semantics definition for our simple language except its halt statement (which is discussed at the end of this section), which we call SmallStep, is presented in Table <ref type="table">4</ref>. The corresponding small-step rewriting logic theory R SmallStep is given in Table <ref type="table">5</ref>. The language described here does not involve labels on rules like in the SOS of concurrent systems. For that, one would take an approach similar to that presented in Section 7, that is, pushing the labels back into the configurations.</p><p>As for big-step semantics, the rewriting under context deduction rule for rewriting logic is again inapplicable, since all rules act at the top, on configurations. However, in SmallStep it is not the case that all right hand sides are normal forms (this actually is a key feature of small-step semantics). The "•" operator introduced in R SmallStep prevents the unrestricted application of transitivity, and can be regarded as a token given to a configuration to allow it to change to the next step. We use transitivity at the end (rules for smallstep) to obtain the transitive closure of the small-step relation by specifically giving tokens to the configuration until it reaches a normal form.</p><p>Again, there is a direct correspondence between SOS-style rules and rewriting rules, leading to the following result, which can also be proved by induction on the length of derivations: Proposition 3. For any p ∈ Pgm,σ ,σ : Var • → Int and s ∈ Store such that s σ , the following are equivalent:</p><p>(1) SmallStep p,σ → p ,σ , and</p><formula xml:id="formula_25">(2) R SmallStep • p,s → 1 p ,s and s σ .</formula><p>Moreover, the following are equivalent for any p ∈ Pgm and i ∈ Int:</p><p>(1) SmallStep p, ⊥ → * skip.i,σ for some σ :</p><formula xml:id="formula_26">Var • → Int, and (2) R SmallStep eval(p) → i.</formula><p>Proof. As for big-step, we split the proof into four cases, by proving for each syntactical category the following facts (suppose s ∈ Store,σ :</p><formula xml:id="formula_27">Var • → Int, s σ ): (1) SmallStep a,σ → a ,σ iff R SmallStep • a,s → 1 a ,s and s σ ,</formula><p>for any a,a ∈ AExp, σ : These equivalences can be shown by induction on the size of the derivation tree. Again, we only show one example per category:</p><formula xml:id="formula_28">Var • → Int and s ∈ Store. (2) SmallStep b,σ → b ,σ iff R SmallStep • b,s → 1 b ,s and s σ , for any b,b ∈ BExp, σ : Var • → Int and s ∈ Store. (3) SmallStep st,σ → st ,σ iff R SmallStep • st,s → 1 st</formula><p>( Weaknesses. Each small step does the same amount of computation as a big-step in finding the next redex. It does not give a "true concurrency" semantics, that is, one has to choose a certain interleaving (no two rules can be applied on the same term at the same time), mainly because reduction is forced to occur only at the top. One of the reasons for introducing SOS was that abstract machines need to introduce new syntactic constructs to decompose the abstract syntax tree, while SOS would and should only work by modifying the structure of the program. We argue that this is not entirely accurate: for example, one needs to have the syntax of boolean values if one wants to have boolean expressions, and needs an if mechanism in the above definition to evaluate while. The fact that these features are common in programming languages does not mean that the languages which don't want to allow them should be despised. It is still hard to deal with control-for example, consider adding halt to this language. One cannot simply do it as for other ordinary statements: instead, one has to add a corner case (additional rule) to each statement, as shown below:</p><formula xml:id="formula_29">1) SmallStep a 1 + a 2 ,σ → a 1 + a 2 ,σ iff a 1 = i and SmallStep a 2 ,σ → a 2 ,σ iff a 1 = i, R SmallStep • a 2 ,s → 1 a 2 ,s and s σ iff R SmallStep • a 1 + a 2 ,s → 1 a 1 + a 2 ,s and s σ . (2) SmallStep not true,σ → false,σ iff R SmallStep • not true,s → 1 false,s . (3) SmallStep st 1 ; st 2 ,σ → st 1 ; st 2 ,σ iff SmallStep st 1 ,σ → st 1 ,σ iff R SmallStep • st 1 ,s → 1 st 1 ,s and s σ iff R SmallStep • st 1 ; st 2 ,s → 1 st 1 + st 2 ,s and s σ . (4) SmallStep st.a,σ → st.a ,σ iff st = skip and SmallStep a,σ → a ,σ iff st = skip, R SmallStep • a,s → 1 a ,s and s σ iff R SmallStep • st.a,</formula><formula xml:id="formula_30">• halt A,S → halt A ,S if • A,S → A ,S • halt I; St,S → halt I,S</formula><p>• halt I.A,S → skip.I,S If expressions could also halt the program, e.g., if one adds functions, then a new rule would have to be added to specify the corner case for each halt-related arithmetic or boolean construct. Moreover, by propagating the "halt signal" through all the statements and expressions, one fails to capture the intended computational granularity of halt: it should just terminate the execution in one step!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">MSOS semantics</head><p>MSOS semantics was introduced by Mosses in <ref type="bibr" target="#b64">[64,</ref><ref type="bibr" target="#b65">65]</ref> to deal with the non-modularity issues of small-step and big-step semantics. The solution proposed in MSOS involves moving the non-syntactic state components to the labels on transitions (as provided by SOS), plus a discipline of only selecting needed attributes from the states.</p><p>A transition in MSOS is of the form P X -→ P , where P and P are program expressions and X is a label describing the structure of the state both before and after the transition. If X is missing, then the state is assumed to stay unchanged. Specifically, X is a record containing fields denoting the semantic components; the preferred notation in MSOS for saying that in the label X the semantic component associated to the field name σ (e.g., a store name) is σ 0 (e.g., a function associating values to variables) is X = {σ = σ 0 , . . .}. Modularity is achieved by the record comprehension notation ". . ." which indicates that more fields could follow but that they are not of interest for this transition. If record comprehension is used in both the premise and the conclusion of an MSOS rule, then all occurrences of ". . ." stand for the same fields with the same semantic components. Fields of a label can fall in one of the following categories: read-only, read-write, and write-only.</p><p>Read-only fields are only inspected by the rule, but not modified. For example, when reading the location of a variable in an environment, the environment is not modified.</p><p>Read-write fields come in pairs, having the same field name, except that the "write" field name is primed. They are used for transitions modifying existing state fields. For example, a store field σ can be read and written, as illustrated by the MSOS rule' for assignment</p><formula xml:id="formula_31">unobs{σ = σ 0 ,σ = σ 0 . . .} X:=I {σ =σ 0 ,σ =σ 0 [I/X],...} -------------→ skip</formula><p>The above rule says that, if before the transition the store was σ 0 , after the transition it will become σ 0 [I/X], updating X by I. The unobs predicate is used to express that the rest of the state does not change.</p><p>Write-only fields are used to record things whose values cannot be inspected before a transition such as emission of actions to the outside world (e.g., output, recording of the trace). Their names are always primed and they have a free monoid semantics-everything written on them is actually added at the end. A good example of the usage of write-only fields would</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 6</head><p>The MSOS language definition. unobs{σ , . . .}, σ ( where "()" stand for monoid unit.</p><formula xml:id="formula_32">X) = I X {σ ,...} ---→ I unobs{σ = σ 0 ,σ = σ 0 , . . .}, I = σ 0 (X) + 1 ++X {σ =σ 0 ,σ =σ 0 [I/X],...} -------------→ I A 1 X -→ A 1 A 1 + A 2 X -→ A 1 + A 2 A 2 X -→ A 2 I 1 + A 2 X -→ I 1 + A 2 I = I 1 + Int I 2 I 1 + I 2 → I A 1 X -→ A 1 A 1 &lt;=A 2 X -→ A 1 &lt;=A 2 A 2 X -→ A 2 I 1 &lt;=A 2 X -→ I 1 &lt;=A 2 T = I 1 ≤ Int I 2 I 1 &lt;=I 2 → T B 1 X -→ B 1 B 1 and B 2 X -→ B 1 and B 2 true and B 2 → B 2 false and B 2 → false B X -→ B not B X -→ not B not true → false not false → true A X -→ A X:=A X -→ X:=A unobs{σ = σ 0 ,σ = σ 0 , . . .} X:=I {σ =σ 0 ,σ =σ 0 [I/X],...} -------------→ skip St 1 X -→ St 1 St 1 ; St 2 X -→ St 1 ; St 2 skip; St 2 → St 2 {St} → St B X -→ B if B then St 1 else St 2 X -→ if B then St 1 else St 2 if true then St 1 else St 2 → St 1 if false then St 1 else St 2 → St 2 while B St → if B then (St; while B St) else skip St X -→ St St.A X -→ St .A A X -→ A skip.A X -→ skip.A</formula><p>The state after this rule is applied will have the out field containing "LI", where the juxtaposition LI denotes the free monoid multiplication of L and I.</p><p>The MSOS description of the small-step SOS definition in Table <ref type="table">4</ref> is given in Table <ref type="table">6</ref> (we let X range over labels on transitions).</p><p>Because the part of the state not involved in a certain rule is hidden through the ". . ." notation, language extensions can be made modularly. Consider, for example, adding halt to the definition in Table <ref type="table">6</ref>. One possible way to do it is to follow the technique proposed in <ref type="bibr" target="#b65">[65]</ref> for adding non-parametric abrupt termination, with some modifications to suit our needs to abruptly terminate the program with a value. For this, we add a write-only field in the record, say halt? having as arrows the monoid freely generated by integer numbers, along with a language construct stuck to block the execution of the program.</p><p>To "catch the halt signal" we extend the abstract syntax with a new construct, say program, applied to a top-level program. The first set of MSOS rules for halt are then  <ref type="figure">-------------→</ref> stuck unobs{halt? = I, . . .} P {halt?=I,...} -------→ skip.I However, since the last rule is based on observation of the state, the program is not forced to terminate as soon as halt is consumed (as was the case in the first definition), since in the case of non-determinism, for example, there might be other things which are still computable.</p><p>To give a faithful representation of MSOS definitions in rewriting logic, we here follow the methodology in <ref type="bibr" target="#b55">[55]</ref>. Using the fact that labels describe changes from their source state to their destination state, one can move the labels back into the configurations. That is, a transition step P u -→ P is modeled as a rewrite step • P,u pre → P ,u post , where u pre and u post are records describing the state before and after the transition. Notice again the use of the "•" operator to emulate small-steps by restricting transitivity. State records can be specified equationally as wrapping (using a constructor "{_}") a set of fields built from fields as constructors, using an associative and commutative concatenation operation "_,_". Fields are constructed from state attributes; for example, the store can be embedded into a field by a constructor "σ : _".</p><p>Records u pre and u post are computed from u in the following way:</p><p>• For unobservable transitions, u pre = u post ; same applies for unobservable attributes in premises;</p><p>• Read-only fields of u are added to both u pre and u post .</p><p>• Read-write fields of u are translated by putting the read part in u pre and the (now unprimed) write part in u post . The assignment rule, for example, becomes</p><formula xml:id="formula_33">• X:=I,{σ : S 0 ,W } → skip,{σ : S 0 [X &lt; ∼ I],W }</formula><p>Notice that the ". . ." notation gets replaced by a generic field-set variable W . • Write-only fields i = v of u are translated as follows: i : L, with L a fresh new variable, is added to u pre , and i : Lv is added to u post . For example, the print rule above becomes</p><p>• print(I),{out : L,W } → skip,{out : LI,W }</p><p>• When dealing with observable transitions, both state records meta-variables and . . . operations are represented in u pre by some variables, while in u post by others. For example, the first rule defining addition in Table <ref type="table">6</ref> is translated into</p><formula xml:id="formula_34">• A 1 + A 2 ,R → A 1 + A 2 ,R if • A 1 ,R → A 1 ,R</formula><p>The key thing to notice here is that modularity is preserved by this translation. What indeed makes MSOS definitions modular is the record comprehension mechanism. A similar comprehension mechanism is achieved in rewriting logic by using sets of fields and matching modulo associativity and commutativity. That is, the extensibility provided by the ". . ." record notation in MSOS is here captured by associative and commutative matching on the W variable, which allows new fields to be added.</p><p>The relation between MSOS and R MSOS definitions assumes that MSOS definitions are in a certain normal form <ref type="bibr" target="#b55">[55]</ref> and is made precise by the following theorem, strongly relating MSOS and modular rewriting semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 ([55]</head><p>). For each normalized MSOS definition, there is a strong bisimulation between its transition system and the transition system associated to its translation in rewriting logic.</p><p>The above presented translation is the basis for the Maude-MSOS tool <ref type="bibr" target="#b19">[19]</ref>, which has been used to define and analyze complex language definitions, such as Concurrent ML <ref type="bibr" target="#b18">[18]</ref>.</p><p>Table <ref type="table" target="#tab_6">7</ref> presents the rewrite theory corresponding to the MSOS definition in Table <ref type="table">6</ref>. The only new variable symbols introduced are R,R , standing for records, and W standing for the remainder of a record.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Strengths.</head><p>As it is a framework on top of any operational semantics, it inherits the strengths of the semantics for which it is used; moreover, it adds to those strengths the important new feature of modularity. It is well known that SOS definitions are typically highly unmodular, so that adding a new feature to the language often requires the entire redefinition of the SOS rules.</p><p>Weaknesses. Control is still not explicit in MSOS, making combinations of control-dependent features (e.g., call/cc) impossible to specify <ref type="bibr">[65, p. 223</ref>]. Also, MSOS still does not allow to capture the intended computational granularity of some defined language statements. For example, the desired semantics of "halt i" is "stop the execution with the result i"; unfortunately, MSOS, like its SOS ancestors, still needs to "propagate" the halting signal along the syntax all the way to the top.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Reduction semantics with evaluation contexts</head><p>Introduced in <ref type="bibr" target="#b98">[96]</ref>, also called context reduction, the evaluation contexts style improves over small-step definitional style in two ways:</p><p>(1) it gives a more compact semantics to context-sensitive reduction, by using parsing to find the next redex rather than small-step rules; and • X,{σ : S,W } → I,{σ : S,W</p><formula xml:id="formula_35">} if I = S[X] • ++X,{σ : S 0 ,W } → I,{S 0 [X &lt; ∼ I],W } if I = S 0 [X] + 1 • A 1 + A 2 ,R → A 1 + A 2 ,R if • A 1 ,R → A 1 ,R • I 1 + A 2 ,R → I 1 + A 2 ,R if • A 2 ,R → A 2 ,R • I 1 + I 2 ,R → I 1 + Int I 2 ,R • A 1 &lt;=A 2 ,R → A 1 &lt;=A 2 ,R if • A 1 ,R → A 1 ,R • I 1 &lt;=A 2 ,R → I 1 &lt;=A 2 ,R if • A 2 ,R → A 2 ,R • I 1 &lt;=I 2 ,R → I 1 ≤ Int I 2 ,R • B 1 and B 2 ,R → B 1 and B 2 ,R if • B 1 ,R → B 1 ,R • true and B 2 ,R → B 2 ,R • false and B 2 ,R → false,R • not B,R → not B ,R if • B,R → B ,R • not true,R → false,R • not false,R → true,R • X:=A,R → X:=A ,R if • A,R → A ,R • X:=I,{σ : S 0 ,W } → skip,{σ : S 0 [X &lt; ∼ I],W } • St 1 ; St 2 ,R → St 1 ; St 2 ,R if • St 1 ,R → St 1 ,R • skip; St 2 ,R → St 2 ,R • {St},R → St,R • if B then St 1 else St 2 ,R → if B then St 1 else St 2 ,R if • B,R → B ,R • if true then St 1 else St 2 ,R → St 1 ,R • if false then St 1 else St 2 ,R → St 2 ,R • while B St,R → if B then (St; while B St) else skip,R • St.A,R → St .A,R if • St,R → St ,R • skip.A,R → skip.A ,R if • A,R → A ,R</formula><p>(2) it provides the possibility of also modifying the context in which a reduction occurs, making it much easier to deal with control-intensive features. For example, defining halt is done now using only one rule, C[halt I] → I, preserving the desired computational granularity. Additionally, one can also incorporate the configuration as part of the evaluation context, and thus have full access to semantic information on a "by need basis"; the PLT-Redex implementation of context reduction, for example, supports this approach. Notice how the assignment rule, for example, modifies both the redex, transforming it to skip, and the evaluation context, altering the state which can be found at its top. In this framework, constructs like call/cc can be defined with little effort.</p><p>In a context reduction semantics of a language, one typically starts by defining the syntax of evaluation contexts. An evaluation context is a program with a "hole", the hole being a placeholder where the next computational step takes place. If C is such a context and E is some expression whose type fits into the type of the hole of C, then C[E] is the program formed by replacing the hole of C by E. The characteristic reduction step underlying context reduction is</p><formula xml:id="formula_36">E → E C[E] → C[E ]</formula><p>extending the usual "only-at-the-top" reduction by allowing reduction steps to take place under any desired evaluation context. Therefore, an important part of a context reduction semantics is the definition of evaluation contexts, which is typically done by means of a context-free grammar. The definition of evaluation contexts for our simple language is found in Table <ref type="table" target="#tab_7">8</ref> (we let [] denote the "hole").</p><p>In this BNF definition of evaluation contexts, S is a store variable. Therefore, a "top level" evaluation context will also contain a store in our simple language definition. There are also context-reduction definitions which operate only on syntax (i.e., no additional state is needed), but instead one needs to employ some substitution mechanism (particularly in definitions of λ-calculus based languages). The rules following the evaluation contexts grammar in Table <ref type="table" target="#tab_7">8</ref> complete the context reduction semantics of our simple language, which we call CxtRed.</p><p>By making the evaluation context explicit and changeable, context reduction is, in our view, a significant improvement over small-step SOS. In particular, one can now define control-intensive statements like halt modularly and at the desired level of computational granularity. Even though the definition in Table <ref type="table" target="#tab_7">8</ref> gives one the feeling that evaluation contexts and their instantiation come "for free", the application of the "rewrite in context" rule presented above can be expensive in practice. This is because one needs either to parse/search the entire configuration to put it in the form C[E] for some appropriate  C satisfying the grammar of evaluation contexts, or to maintain enough information in some special data-structures to perform the split C[E] using only local information and updates. Moreover, this "matching-modulo-the-CFG-of-evaluationcontexts" step needs to be done at every computation step during the execution of a program, so it may easily become the major bottleneck of an executable engine based on context reduction. Direct implementations of context reduction such as PLT-Redex cannot avoid paying a significant performance penalty <ref type="bibr" target="#b99">[97]</ref>. Danvy and Nielsen propose in <ref type="bibr" target="#b27">[27]</ref> a technique for efficiently interpreting a restricted form of reduction semantics definitions by means of "refocusing" functions which yield efficient abstract machines. Although these refocusing functions are equationally definable, since we aim here to achieve minimal representational distance, we prefer to translate the definitions into rewriting logic by leaving the rules unchanged and implementing the decompose and plug functions from reduction semantics by means of equations. Next section will present an abstract-machine definition of a programming language in rewriting logic, resembling Felleisen's CK machine <ref type="bibr" target="#b34">[34]</ref>, which is obtained by applying Danvy and Nielsen's technique.</p><formula xml:id="formula_37">::= [] | Int + CAExp | CAExp + AExp E → E C[E] → C[E ] I 1 + I 2 → (I 1 + Int I 2 ) P,σ [X] → P,σ [(σ (X))] P,σ [++X] → P,σ [I/X] [I] when I = σ (X) + 1 I 1 &lt;=I 2 → (I 1 ≤ Int I 2 )</formula><p>Context reduction is trickier to faithfully capture as a rewrite theory, since rewriting logic, by its locality, always applies a rule in context, without actually having the capability of changing the given context. Also, from a rewriting point of view, context-reduction captures context-sensitive rewriting, which, although supported by rewriting logic in the form of congruence restricted to the non-frozen arguments of each operator, cannot be captured "as-is" in its full generality within rewriting logic.</p><p>To faithfully model context-reduction, we make use of two equationally-defined operations: s2c, which splits a piece of syntax into a context and a redex, and c2s, which plugs a piece of syntax into a context. In our rewriting logic definition, C[R] is not a parsing convention, but rather a constructor conveniently representing the pair (context C, redex R). In order to have an algebraic representation of contexts we extend the signature by adding a constant [], representing the hole, for each syntactic category. The operation s2c, presented in Table <ref type="table">9</ref>, has an effect similar to what one achieves by parsing in context reduction, in the sense that given a piece of syntax it yields C[R]. It is a straight-forward, equational definition of the decompose function used in context-reduction implementations based on the syntax of contexts. We here assume the same restrictions on the context syntax as in <ref type="bibr" target="#b27">[27]</ref>, namely that the grammar defining them is context-free and that there is always a unique decomposition of an expression into a context and a redex. The operation c2s, presented in Table <ref type="table" target="#tab_1">10</ref>, is the equational definition of the plug function used in interpreting context-reduction definitions, and it is a morphism on the syntax. Notice that (from the defining equations) we have the guarantee that it will be applied only to "well formed"</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 9</head><p>Equational definition of s2c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>s2c( P,S</head><formula xml:id="formula_38">) = C,S [R] if C[R] = s2c(P) s2c(skip.I) = [][skip.I] s2c(skip.A) = (skip.C)[R] if C[R] = s2c(A) s2c(St.A) = (C.A)[R] if C[R] = s2c(St) s2c(halt I) = [][halt I] s2c(halt A) = (halt C)[R] if C[R] = s2c(A) s2c(while B St) = [][while B St] s2c(if T then St 1 else St 2 ) = [][if T then St 1 else St 2 ] s2c(if B then St 1 else St 2 ) = (if C then St 1 else St 2 )[R] if C[R] = s2c(B) s2c({St}) = [][{St}] s2c(skip; St 2 ) = [][skip; St 2 ] s2c(St 1 ; St 2 ) = (C; St 2 )[R] if C[R] = s2c(St 1 ) s2c(X:=I) = [][X:=I] s2c(X:=A) = (X:=C)[R] if C[R] = s2c(A) s2c(I 1 &lt;=I 1 ) = [][I 1 &lt;=I 2 ] s2c(I&lt;=A) = (I&lt;=C)[R] if C[R] = s2c(A) s2c(A 1 &lt;=A 2 ) = (C&lt;=A 2 )[R] if C[R] = s2c(A 1 ) s2c(T and B 2 ) = [][T and B 2 ] s2c(B 1 and B 2 ) = (C and B 2 )[R] if C[R] = s2c(B 1 ) s2c(not T ) = [][not T ] s2c(not B) = (not C)[R] if C[R] = s2c(B) s2c(X) = [][X] s2c(++X) = [][++X] s2c(I 1 + I 2 ) = [][I 1 + I 2 ] s2c(I + A) = (I + C)[R] if C[R] = s2c(A) s2c(A 1 + A 2 ) = (C + A 2 )[R] if C[R] = s2c(A 1 )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 10</head><p>Equational definition of c2s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>c2s([][H]) = H c2s( P,S [H]) = c2s(P[H]),S c2s( I</head><formula xml:id="formula_39">[H]) = I c2s(E 1 .E 2 [H]) = c2s(E 1 [H]).c2s(E 2 [H]) c2s(halt E[H]) = halt c2s(E[H]) c2s(while E 1 E 2 [H]) = while c2s(E 1 [H]) c2s(E 2 [H]) c2s(if E then E 1 else E 2 [H]) = if c2s(E[H]) then c2s(E 1 [H]) else c2s(E 2 [H]) c2s({E}[H]) = {c2s(E[H])} c2s(E 1 ; E 2 [H]) = c2s(E 1 [H]); c2s(E 2 [H]) c2s(X:=E[H]) = X:=c2s(E[H]) c2s(skip[H]) = skip c2s(E 1 &lt;=E 2 [H]) = c2s(E 1 [H])&lt;=c2s(E 2 [H]) c2s(E 1 and E 2 [H]) = c2s(E 1 [H]) and c2s(E 2 [H]) c2s(not E[H]) = not c2s(E[H]) c2s(true[H]) = true c2s(false[H]) = false c2s(++X[H]) = ++X c2s(E 1 + E 2 [H]) = c2s(E 1 [H]) + c2s(E 2 [H]) c2s(I[H]) = I</formula><p>contexts (i.e., contexts containing only one hole). The rewrite theory R CxtRed is obtained by adding the rules in Table <ref type="table" target="#tab_8">11</ref> to the equations of s2c and c2s.</p><p>The R CxtRed definition is a faithful representation of context reduction semantics: indeed, it is easy to see that s2c recursively finds the redex taking into account the syntactic rules defining a context in the same way a parser would, and in the same way as other current implementations of this technique do it. Also, since parsing issues are abstracted away using equations, the computational granularity is the same, yielding a one-to-one correspondence between the computations performed by the context reduction semantics rules and those performed by the rewriting rules.</p><p>Theorem 2. Suppose that s σ. Then the following hold:</p><formula xml:id="formula_40">(1) p,σ parses in CxtRed as c,σ [r] iff R CxtRed s2c( p,s ) = c,s [r]; (2) R CxtRed c2s(c[r]) = c[</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>r/[]] for any valid context c and appropriate redex r;</head><formula xml:id="formula_41">(3) CxtRed p,σ → p ,σ iff R CxtRed •( p,s ) → 1 p ,s and s σ ; (4) CxtRed p,σ → i iff R CxtRed •( p,s ) → 1 i ; (5) CxtRed p, ⊥ → * i iff R CxtRed eval(p) → i.</formula><p>Proof.</p><p>(1) By induction on the number of context productions applied to parse the context, which is the same as the length of the derivation of R CxtRed s2c(syn) = c[r], respectively, for each syntactical construct syn. We only show some of the more interesting cases.</p><p>Case ++x:</p><formula xml:id="formula_42">++x parses as [][++x]. Also R CxtRed s2c(++x) = [][++x] in one step (it is an instance of an axiom).</formula><p>Case a 1 &lt;=a 2 : a 1 &lt;= a 2 parses as  •(I 1 + I 2 ) → (I 1 + Int I 2 )</p><formula xml:id="formula_43">a 1 &lt;= c[r] iff a 1 ∈ Int and a 2 parses as c[r] iff a 1 ∈ Int and R CxtRed s2c(a 2 ) = c[r] iff R CxtRed s2c(a 1 &lt;=a 2 ) = (a 1 &lt;=c)[r].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>•( P,S [X]) → P,S [(S[X])] •( P,S [++X]) → P,S[X &lt; ∼ I] [I] if I = s(S[X]</head><p>)</p><formula xml:id="formula_44">•(I 1 &lt;=I 2 ) → (I 1 ≤ Int I 2 )</formula><p>•(true and B) → B</p><p>•(false and B) → false</p><formula xml:id="formula_45">•(not true) → false •(not false) → true •(if true then St 1 else St 2 ) → St 1 •(if false then St 1 else St 2 ) → St 2 •(skip; St) → St •({St}) → St •( P,S [X:=I]) → P,S[X &lt; ∼ I] [skip]</formula><p>•(while B St)</p><formula xml:id="formula_46">→ if B then (St; while B St) else skip •(C[halt I]) → I [[]] •(C[skip.I]) → I [[]] •(C[R]) → C[R ] if •(R) → R •(Cfg) → c2s(C[R]) if •(s2c(Cfg)) → C[R] eval(P) = reduction( P,∅ ) reduction(Cfg) = reduction(•(Cfg)) reduction( I ) = I R CxtRed s2c(p) = c [r] and c = c ,s iff R CxtRed s2c( p,s ) = c ,s [r].</formula><p>(2) From the way it was defined, c2s acts as a morphism on the structure of syntactic constructs, changing [] in C by R. Since c2s is defined for all constructors, it will work for any valid context C and pluggable expression e. Note, however, that c2s works as stated also on multi-contexts (i.e., on contexts with multiple holes), but this aspect does not interest us here. (3) There are several cases again to analyze, depending on the particular reduction that provoked the derivation CxtRed p,σ → p ,σ . We only discuss some cases; the others are treated similarly.</p><formula xml:id="formula_47">CxtRed p,σ → p ,σ because of CxtRed c,σ [x] → c,σ [σ (x)] iff p,σ parses as c,σ [x] and p ,σ is c,σ [σ (x)] (in particular σ = σ ) iff R CxtRed s2c( p,s ) = c,s [x], R CxtRed s[x] = i where i = σ (x) and R CxtRed c2s( c,s [i]) = p ,s iff R CxtRed •( p,s ) → 1 p ,s , because R CxtRed •( c,s [x]) → 1 c,s [i]. CxtRed p,σ → p ,σ because of not true→false c[not true]→c[false] for some evaluation context c iff p,σ parses as c[not true] and p ,σ is c[false] iff R CxtRed s2c( p,s ) = c[not true] and R CxtRed c2s(c[false]) = p ,s iff R CxtRed •( p,s ) → 1 p ,s , because R CxtRed •(c[not true]) → 1 c[false] (which follows since R CxtRed •(not true) → 1 false). CxtRed p,σ → p ,σ because of CxtRed c,σ [x:=i] → c,σ [i/x][skip] iff p,σ parses as c,σ [x:=i], σ = σ [i/x] and p ,σ is c,σ [skip] iff R CxtRed s2c( p,s ) = c,s [x:=i], s = s[x ← i] σ and R CxtRed c2s( c,s [skip]) = p ,s iff R CxtRed •( p,s ) → 1 p ,s , because R CxtRed •( c,s [x:=i]) → 1 c,s [skip]. (4) CxtRed p,σ → i because of CxtRed c[skip.i] → i iff p,σ parses as [],σ [skip.i] iff R CxtRed s2c( p,s ) = [],s [skip.i] iff R CxtRed •( p,s ) = i , since R CxtRed •( [],σ [skip.i]) → 1 i [[]] and since R CxtRed c2s( i [[]]) = i . Also, CxtRed p,σ → i because of CxtRed c[halt i] → i iff p,σ parses as c,σ [halt i] iff R CxtRed s2c( p,s ) = c,s [halt i] iff R CxtRed •( p,s ) = i since R CxtRed •( c,σ [halt i]) → 1 i [[]] and since R CxtRed c2s( i [[]]) = i .</formula><p>(5) This part of the proof follows the same pattern as that for the similar property for SmallStep (Proposition 3), using the above properties and replacing smallstep by reduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 12</head><p>Rewriting logic theory R K (continuation-based definition of the language). Weaknesses. It still only allows "interleaving semantics" for concurrency. Although context-sensitive rewriting might seem to be easily implementable by rewriting, in fact all current implementations of context reduction work by transforming context grammar definitions into traversal functions, thus being as (in)efficient as the small-step implementations (one has to perform an amount of work linear in the size of the program for each computational step). However, one might obtain efficient implementations for restricted forms of context-reduction definitions by applying refocusing techniques <ref type="bibr" target="#b27">[27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>aexp(I) = I aexp(A</head><formula xml:id="formula_48">1 + A 2 ) = (aexp(A 1 ),aexp(A 2 )) + k(aexp(X) K) store(Store) → k(Store[X] K) store(Store) k(aexp(++X) K) store((X = I) Store) → k(s(I) K) store((X = s(I)) Store) k(I 1 ,I 2 + K) → k(I 1 + Int I 2 K) bexp(true) = true bexp(false) = false bexp(A 1 &lt;=A 2 ) = (aexp(A 1 ),aexp(A 2 )) ≤ bexp(B 1 and B 2 ) = bexp(B 1 ) and(bexp(B 2 )) bexp(not B) = bexp(B) not k(I 1 ,I 2 ≤ K) → k(I 1 ≤ Int I 2 K) k(true and(K 2 ) K) → k(K 2 K) k(false and(K 2 ) K) → k(false K) k(T not K) → k(not Bool T K) stmt(skip) = nothing stmt(X := A) = aexp(A) write(X) stmt(St 1 ; St 2 ) = stmt(St 1 ) stmt(St 2 ) stmt({St}) = stmt(St) stmt(if B then St 1 else St 2 ) = bexp(B) if(stmt(St 1 ),stmt(St 2 )) stmt(while B St) = bexp(B) while(bexp(B),stmt(St)) stmt(halt A) = aexp(A) halt k(I write(X) K) store(Store) → k(K) store(Store[X ← I]) k(true if(K 1 ,K 2 ) K) → k(K 1 K) k(false if(K 1 ,K 2 ) K) → k(K 2 K) k(true while(K 1 ,K 2 ) K) → k(K 2 K 1 while(K 1 ,K 2 ) K) k(false while(K 1 ,K 2 ) K) → k(K) k(I halt K) → k(I) pgm(St.A) = stmt(St)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">A continuation-based semantics</head><p>The idea of continuation-based interpreters for programming languages and their relation to abstract machines has been well studied (see, for example, <ref type="bibr" target="#b34">[34]</ref>). In this section, we propose a rewriting logic theory based on a structure that provides a first-order representation of continuations in the spirit of Wand <ref type="bibr" target="#b97">[95]</ref>; this is the only reason why we call this structure a "continuation"; but notice that it can just as well be regarded as a post-order representation of the abstract syntax tree of the program, so one needs no prior knowledge of continuations <ref type="bibr" target="#b34">[34]</ref> in order to understand this section. We will show the equivalence of this theory to the context reduction semantics theory.</p><p>Based on the desired order of evaluation, the program is sequentialized by transforming it into a list of tasks to be performed in order. This is done once and for all at the beginning, the benefit being that at any subsequent moment in time we know precisely where the next redex is: at the top of the list of tasks. We call this list of tasks a continuation, but is nothing more than a pure first-order flattening of the program and can be easily introduced without appealing to high-order constructs. For example aexp(A 1 + A 2 ) = (aexp(A 1 ),aexp(A 2 )) + precisely encodes the order of evaluation: first A 1 , then A 2 , then add the values. Also, stmt(if B then St</p><formula xml:id="formula_49">1 else St 2 ) = B if(stmt(St 1 ),stmt(St 2</formula><p>)) says that St 1 and St 2 are dependent on the value of B for their evaluation. The fact that we denote the above relation by equality, although we operationally interpret it from left to right, indicates that the two terms are structurally equal (and in fact, they are equal in the initial model of the specification)-at any time during the evaluation one could apply the equations backwards and reconstitute the current state of the program being executed.</p><p>The top level configuration is constructed by an operator "_ _" putting together the store (wrapped by a constructor store) and the continuation (wrapped by k). Also, syntax is added for the continuation items. Here, the distinction between equations and rules becomes even more obvious: equations are used to prepare the context in which a computation step can be applied, while rewrite rules exactly encode the computation steps semantically, yielding the intended computational granularity. Specifically pgm, stmt, bexp, aexp are used to flatten the program to a continuation, taking into account the order of evaluation. The continuation is defined as a list of tasks, where the list constructor "_ _" is associative, having as identity a constant "nothing". We also use lists of values and continuations, each having an associative list append constructor "_,_" with identity ".". We use variables K and V to denote continuations and values, respectively; also, we use Kl and Vl for lists of continuations and values, respectively. The rewrite theory R K specifying the continuation-based definition of our example language is given in Table <ref type="table" target="#tab_2">12</ref>. Lists of expressions are evaluated using the following (equationally defined) mechanism:</p><formula xml:id="formula_50">k((Vl, Ke, Kel) K) = k(Ke (Vl, nothing, Kel) K)</formula><p>Because in rewriting engines equations are also executed by rewriting, one would need to split the above rule into two rules:</p><formula xml:id="formula_51">k((Vl, Ke, Kel) K = k(Ke (Vl, nothing, Kel) K) k(V (Vl, nothing, Kel) K) = k((Vl, V , Kel) K)</formula><p>The semantics we obtain here for this simple sequential language is an abstract machine, similar in spirit to the one obtainable by applying CPS transformers on an interpreter as in <ref type="bibr" target="#b74">[74]</ref> or that obtained by applying refocusing <ref type="bibr" target="#b27">[27]</ref> on the context-reduction definition. One slight difference is that we keep the state and the continuation as distinct entities at the top level, rather than embedding the state as part of the context/continuation structure. In a computational logic framework like rewriting logic where the gap between "implementations" and "specifications" is almost inexistent, this continuation-like style can be used to define languages, not only to efficiently interpret them.</p><p>An important benefit of this definitional style is that of gaining locality. Now one needs to specify from the context only what is needed to perform the computation. This indeed gives the possibility of achieving "true concurrency", since rules which do not act on the same parts of the context can be applied in parallel. In <ref type="bibr" target="#b72">[72]</ref>, we show how the same technique can be used, with no additional effort, to define concurrent languages; the idea is, as expected, that one continuation structure is generated for each concurrent thread or process. Then rewrite rules can apply "truly concurrently" at the tops of continuations.</p><p>Strengths. In continuation-based semantics there is no need to search for a redex anymore, because the redex is always at the top. It is much more efficient than direct implementations of evaluation contexts or small-step SOS. Also, this style greatly reduces the need for conditional rules/equations; conditional rules/equations might involve inherently inefficient reachability analysis to check the conditions and are harder to deal with in parallel environments. An important "strength" specific to the rewriting logic approach is that reductions can now apply wherever they match, in a context-insensitive way. Additionally, continuation-based definitions in the RLS style above are very modular (particularly due to the use of matching modulo associativity and commutativity).</p><p>Weaknesses. The program is now hidden in the continuation: one has to either learn to like it like this, or to write a backwards mapping to retrieve programs from continuations <ref type="foot" target="#foot_3">4</ref> ; to flatten the program into a continuation structure, several new operations (continuation constants) need to be introduced, which "replace" the corresponding original language constructs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1.">Relation with context reduction</head><p>We next show the equivalence between the continuation-based and the context-reduction rewriting logic definitions. The specification in Table <ref type="table" target="#tab_3">13</ref> relates the two semantics, showing that at each computational "point" it is possible to extract from our continuation structure the current expression being evaluated. For each syntactical construct Syn ∈ {AExp,BExp,Stmt,Pgm}, we equationally define two (partial) functions:</p><p>• k2Syn takes a continuation encoding of Syn into Syn; and • kSyn extracts from the tail of a continuation a Syn and returns it together with the remainder prefix continuation.</p><p>Together, these two functions can be regarded as a parsing process, where the continuation plays the role of "unparsed" syntax, while Syn is the abstract syntax tree, i.e., the "parsed" syntax. The formal definitions of k2Syn and kSyn are given in Table <ref type="table" target="#tab_3">13</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 13</head><p>Recovering the abstract syntax trees from continuations.</p><formula xml:id="formula_52">k2Pgm(K) = k2Stmt(K ).A if {K ,A} = kAExp(K) k2Stmt(nothing) = skip k2Stmt(K) = k2Stmt(K ); St if {K ,St} = kStmt(K) ∧ K / = nothing k2Stmt(K) = St if {K ,St} = kStmt(K) ∧ K = nothing kStmt(K write(X)) = {K ,X:=A} if {K ,A} = kAExp(K) kStmt(K while(K 1 ,K 2 )) = {K ,if B then {St; while B 1 St} else skip} if {K ,B} = kBExp(K) ∧ B 1 = k2BExp(K 1 ) ∧ St = k2Stmt(K 2 ) ∧ B / = B 1 kStmt(K while(K 1 ,K 2 )) = {K ,while B St} if {K ,B} = kBExp(K) ∧ B 1 = k2BExp(K 1 ) ∧ St = k2Stmt(K 2 ) ∧ B = B 1 kStmt(K if(K 1 ,K 2 )) = {K ,if B then k2Stmt(K 1 ) else k2Stmt(K 2 )} if {K ,B} = kBExp(K) kStmt(K halt) = {K ,halt A} if {K ,A} = kAExp(K) k2AExp(K) = A if {nothing,A} = kAExp(K) kAExp(K kv(Kl,Vl) K ) = kAExp(Vl,K,Kl K ) kAExp(K aexp(A)) = {K,A} kAExp(K I) = {K,I} kAExp(K K 1 ,K 2 +) = {K,k2AExp(K 1 ) + k2AExp(K 2 )} k2BExp(K) = B if {nothing,B} = kBExp(K) kBExp(K kv(Kl,Vl) K ) = kBExp(Vl,K,Kl K ) kBExp(K T ) = {K,T } kBExp(K K 1 ,K 2 ≤) = {K,k2AExp(K 1 )&lt;=k2AExp(K 2 )} kBExp(K and(K 2 )) = {K 1 ,B 1 and k2BExp(K 2 )} if {K 1 ,B 1 } = kBExp(K) kBExp(K not) = {K ,not B} if {K ,B} = kBExp(K)</formula><p>We will show below that for any step CxtRed takes, R K performs at most one step to reach the same<ref type="foot" target="#foot_4">5</ref> configuration. No steps are performed for skip, or for dissolving a block (because these were dealt with when we transformed the syntax into continuation form), or for dissolving a statement into a skip (there is no need for that when using continuations). Also, no steps will be performed for loop unrolling, because this is not a computational step; it is a straightforward structural equivalence. In fact, note that, because of its incapacity to distinguish between computational steps and structural equivalences, CxtRed does not capture the intended granularity of while: it wastes a computation step for unrolling the loop and one when dissolving the while into skip; neither of these steps has any computational content.</p><p>In order to clearly explain the relation between reduction contexts and continuations, we go a step further and define a new rewrite theory R K which, besides identifying while with its unrolling, adds to R K the idea of contexts, holes, and pluggable expressions. More specifically, we add a new constant "[]" and the following equation, again for each syntactical category Syn:</p><formula xml:id="formula_53">k(syn(Syn) K ) = k(syn(Syn) syn([]) K )</formula><p>replacing the equation for evaluating lists of expressions, namely,</p><formula xml:id="formula_54">k((Vl, Ke, Kel) K) = k(Ke (Vl, nothing, Kel) K)</formula><p>by the following equation which puts in a hole instead of nothing:</p><formula xml:id="formula_55">k((Vl, Ke, Kel) K) = k(Ke (Vl, syn([]), Kel) K)</formula><p>The intuition for the first rule is that, as we will next show, for any well-formed continuation (i.e., one obtained from a syntactic entity) having a syntactic entity as its prefix, its corresponding suffix represents a valid context where the prefix syntactic entity can be plugged in. As expected, R K does not bring any novelty to R K , that is, for any term (Note that r in the proposition above needs not be a redex, but can be any expression of the right syntactical category, i.e., pluggable in the hole.) All other constructs are dealt with in a similar manner.</p><formula xml:id="formula_56">t in R K , Tree R K (t) is bisimilar to Tree R K (t).</formula><formula xml:id="formula_57">Proof. ++x = [][++x]: R K k(aexp(++x)) = k(aexp(++x) aexp([])) a 1 + a 2 = [] + a 2 [a 1 ]: R K k(aexp(a 1 + a 2 )) = k((aexp(a 1 ),aexp(a 2 )) +) = k(aexp(a 1 ) (aexp([]),aexp(a 2 )) +) = k(aexp(a 1 ) aexp([] + a 2 )) i 1 + a 2 = i 1 + [][a 2 ]: R K k(aexp(i 1 + a 2 )) = k((aexp(i 1 ),aexp(a 2 )) +) = k(aexp(a 2 ) (i 1 ,aexp([])) +) = k(aexp(a 2 ) aexp(i 1 + [])).</formula><formula xml:id="formula_58">Lemma 1. R K k(k 1 ) = k(k 2 ) implies that for any k rest , R K k(k 1 k rest ) = k(k 2 k rest ).</formula><p>Proof. We can replay all steps in the first proof, for the second proof, since all equations only modify the head of a continuation.</p><p>By structural induction on the equational definitions, thanks to the one-to-one correspondence of rewriting rules, we obtain the following result: Theorem 3. Suppose s σ.</p><p>( Proof (Sketch).</p><p>(1) First, one needs to notice that rules in R K correspond exactly to those in CxtRed. For example, for i 1 + i 2 → i 1 + Int i 2 , which can be read as c,σ</p><formula xml:id="formula_59">[i 1 + i 2 ] → c,σ [i 1 + Int i 2 ] we have the rule k((i 1 ,i 2 ) + k rest ) → k((i 1 + Int i 2 ) k rest )</formula><p>which, taking into account the above results, has, as a particular instance:</p><formula xml:id="formula_60">k(pgm(c[i 1 + i 2 ])) → k(pgm(c[i 1 + Int i 2 ]). For c,σ [x:=i] → c,σ [i/x] [skip] we have k(i write(x) k) store(s) → k(k) store(s[x ← i]</formula><p>) which again has as an instance:</p><formula xml:id="formula_61">k(pgm(c[x:=i]) store(s) → k(c[skip) store(s[x ← i]). (<label>2</label></formula><p>) Actually σ is uniquely determined by s and p is the program obtained by advancing p all non-computational stepswhich were dissolved by pgm, or are equationally equivalent in R K , such as unrolling the loops-, then performing the step similar to that in R K . (3) Using the previous two statements, and the rules for halt or end of the program from both definitions. We exemplify only halt, the end of the program is similar, but simpler. For c,σ</p><formula xml:id="formula_62">[halt i] → i we have k(i halt k) → k(i), and combined with R K result(k(i) store(s)) = i we obtain R K result(k(pgm(c[halt i])) store(s)) → i.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">The chemical abstract machine</head><p>Berry and Boudol's chemical abstract machine, or Cham <ref type="bibr" target="#b8">[8]</ref>, is both a model of concurrency and a specific style of giving operational semantics definitions. Properly speaking, it is not an SOS definitional style. Berry and Boudol identify a number of limitations inherent in SOS, particularly its lack of true concurrency, and what might be called SOS's rigidity and slavery to syntax <ref type="bibr" target="#b8">[8]</ref>. They then present the Cham as an alternative to SOS. In fact, as already pointed out in <ref type="bibr" target="#b50">[50]</ref>, what the Cham is, is a particular definitional style within RLS. That is, every Cham is, by definition, a specific kind of rewrite theory; and Cham computation is precisely concurrent rewriting computation; that is, proof in rewriting logic.</p><p>The basic metaphor giving its name to the Cham is inspired by Banâtre and Le Métayer's GAMMA language <ref type="bibr" target="#b5">[6]</ref>. It views a distributed state as a "solution" in which many "molecules" float, and understands concurrent transitions as "reactions" that can occur simultaneously in many points of the solution. It is possible to define a variety of chemical abstract machines. Each of them corresponds to a rewrite theory satisfying certain common conditions.</p><p>There is a common syntax shared by all chemical abstract machines, with each machine possibly extending the basic syntax by additional function symbols. The common syntax is typed, and can be expressed as the following order-sorted signature : AirlockAx. The associativity and commutativity (AC) axioms are asserted of the operator _ ,_, which has identity λ. The rules in R may involve variables, but are subject to certain syntactic restrictions that guarantee an efficient form of AC matching <ref type="bibr" target="#b8">[8]</ref>. AirlockAx is the bidirectional rule<ref type="foot" target="#foot_5">6</ref> {|m,M|} {|m {|M|}|}, where m is a variable of sort Molecule and M a variable of sort Molecules. The purpose of this axiom is to choose one of the molecules m in a solution as a candidate for reaction with other molecules outside its membrane. The Heating and Cooling rules can typically be paired, with each rule t -→ t ∈ Heating having a symmetric rule t -→ t ∈ Cooling, and vice-versa, so that we can view them as a single set of bidirectional rules t t in Heating-Cooling.</p><p>Berry and Boudol <ref type="bibr" target="#b8">[8]</ref> make a distinction between rules, which are rewrite rules specific to each Cham-and consist of the Reaction, Heating, and Cooling rules-and laws which are general properties applying to all Chams for governing the admissible transitions. The first three laws, the Reaction, Chemical and Membrane laws, just say that the Cham evolves by AC-rewriting. The fourth law states the axiom AirlockAx. The Reaction rules are the heart of the Cham and properly correspond to state transitions. The rules in Heating-Cooling express structural equivalence, so that the Reaction rules may apply after the appropriate structurally equivalent syntactic form is found. A certain strategy is typically given to address the problem of finding the right structural form, for example to perform "heating" as much as possible. In rewriting logic terms, a more abstract alternative view is to regard each Cham as a rewrite theory C = ( ,ACI ∪ Heating-Cooling ∪ AirlockAx,Reaction), in which the Heating-Cooling rules and the AirlockAx axiom have been made part of the theory's equational axioms. That is, we can more abstractly view the Reaction rules as applied modulo ACI ∪ Heating-Cooling ∪ AirlockAx.</p><p>As Berry and Boudol demonstrate in <ref type="bibr" target="#b8">[8]</ref>, the Cham is particularly well suited to give semantics to concurrent calculi, yielding considerably simpler definitions than those afforded by SOS. In particular, <ref type="bibr" target="#b8">[8]</ref> presents semantic definitions for the TCCS variant of CCS, a concurrent λ-calculus, and Milner's π -calculus. Milner himself also used Cham ideas to provide a compact formulation of his π-calculus <ref type="bibr" target="#b59">[59]</ref>. Since our example language is sequential, it cannot take full advantage of the Cham's true concurrent capabilities. Nevertheless, there are interesting Cham features that, as we explain below, turn out to be useful even in this sequential language application. A Cham semantics for our language is given in Table <ref type="table" target="#tab_1">14</ref>. Note that, since the Cham is itself a rewrite theory, in this case there is no need for a representation in RLS, nor for a proof of correctness of such a representation; that is, the "representational distance" in this case is equal to 0. Again, RLS does not advocate any particular definitional style: the Cham style is just one possibility among many, having its own advantages and limitations.</p><p>The CHAM definition for our simple programming language takes the CxtRed definition in Table <ref type="table" target="#tab_7">8</ref> as a starting point. More precisely, we follow the "refocusing" technique <ref type="bibr" target="#b27">[27]</ref>. We distinguish two kinds of molecules: syntactic molecules and store molecules. Syntactic molecules are either language constructs or evaluation contexts and we will use "[_ | _]" as a molecule constructor for stacking molecules. We let C range over syntactic molecules representing stacked contexts. Store molecules are pairs (x,i), where x is a variable and i is an integer. The store is a solution containing store molecules. Then the definition of "refocusing" functions is translated into heating/cooling rules, bringing the redex to the top of the syntactic molecule. This allows for the reduction rules to only operate at the top, in a conceptually identical way as for continuation based definitions in Table <ref type="table" target="#tab_2">12</ref>, both of them following the same methodology introduced in <ref type="bibr" target="#b72">[72]</ref>.</p><p>One can notice a strong relation between our CHAM and CxtRed definitions, in the sense that a step performed using reduction under evaluation contexts is equivalent to a suite of heating steps followed by one transition step and then by as many cooling steps as possible. That is, given programs P, P and states σ , σ CxtRed P,σ → P ,σ ⇐⇒ CHAM P,{|σ |} * ; → 1 ; * P ,{|σ |}</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 14</head><p>The CHAM language definition. The above language definition does not exhibit the strengths of the Cham, since Cham was designed to handle easily concurrent constructs, which are missing from our language. However, making the above language concurrent in Cham comes at no additional effort. One can execute multiple programs at the same time, sharing the store, simply by putting them together, and together with the store at the top-level solution and replacing the rule for the end of the program by skip.I → I, to allow all programs to finish their evaluation and keep the results.</p><formula xml:id="formula_63">St.A [St | [[].A]] skip.A [A | [skip.[]]] [X:=A | C] [A | [X:=[] | C]] [St 1 ; St 2 | C] [St 1 | [[]; St 2 | C]] [if B then St 1 else St 2 | C] [B | [if [] then St 1 else St 2 | C]] [halt A | C] [A | [halt [] | C]] [A 1 &lt;=A 2 | C] [A 1 | [[]&lt;=A 2 | C]] [I&lt;=A | C] [A | [I&lt;=[] | C]] [B 1 and B 2 | C] [B 1 | [[] and B 2 | C]] [not B | C] [B | [not [] | C]] [A 1 + A 2 | C] [A 1 | [[] + A 2 | C]] [I + A | C] [A | [I + [] | C]] I 1 + I 2 → (I 1 + Int I 2 ) [X | C],{|(X,I) σ |} → [I | C],{|(X,I) σ |} [++X | C],{|(X,I) σ |} → [I + Int 1 | C],</formula><p>When Cham definitions follow the style in Table <ref type="table" target="#tab_1">14</ref>, i.e., taking a context-reduction-like approach, one could use as evaluation strategies heating only on redexes and cooling only on values, which would lead to a deterministic abstract-machine. Moreover, one can notice that airlock rules were introduced to select elements from a set without specifying the rest of the set, abstracted by a molecule. Efficient implementations should probably do exactly the opposite, that is, matching in the sets. To do that in our rewrite framework, one would orient the airlock rules in the sense of inserting back the "airlocked" molecules into their original solution and to apply them on the terms of the existing rules, to make the definition executable. The only rules changing in the definition above are those involving the store; for example, the assignment rule is transformed into:</p><formula xml:id="formula_64">[X:=I | C],{|(X,I ),σ |} → [skip | C],{|(X,I),σ |}</formula><p>One should notice that the specification obtained by these transformations is equivalent to the initial one, since it does not change the equivalence classes and the transitions. The main advantage of the newly obtained specification is that it is also executable in a deterministic fashion, that is, there is no need to search for a final state anymore.</p><p>Strengths. Being a special case of rewriting logic, it inherits many of the benefits of rewriting logic, being specially well suited for describing truly concurrent computations and concurrent calculi.</p><p>Weaknesses. Heating/cooling rules are hard to implement efficiently in general-an implementation allowing them to be bidirectional in an uncontrolled manner would have to search for final states, possibly leading to a combinatorial explosion. Rewriting strategies such as those in <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b95">93,</ref><ref type="bibr" target="#b29">29]</ref> can be of help for solving particular instances of this problem. Although this solution-molecule paradigm seems to work pretty well for languages in which the structure of the state is simple enough, it is not clear how one could represent the state for complex languages, with threads, locks, environments, and so on. Finally, Chams provide no mechanism to freeze the current molecular structure as a "value", and then to store or retrieve it, as we would need in order to define language features like call/cc. Even though it was easy to define halt because we simply discarded the entire solution, it would seem hard or impossible to define more complex control-intensive language features in Cham.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Experiments</head><p>RLS definitions, being executable, actually are also interpreters for the programming languages they define. One can take an RLS executable definition as is and execute it on top of a rewrite engine.</p><p>However, one should not wrongly conclude from this that in order to make any use of RLS definitions of programming languages, in particular of those following the various definitional styles proposed in this paper, one must have an advanced rewrite engine. In fact, one can implement interpreters for languages given an RLS definition using one's programming language of choice. Although the proposed RLS definitions follow the same style and intuitions, and have the same strengths and limitations as their original formulation in their corresponding definitional styles, we believe that automating the process of generating interpreters from the rewriting logic language definitions following a specific operational semantics style should be easier than doing it directly from the original definition, since the rewriting logic definition is already executable. Furthermore, since most of the definitional styles presented in this paper use a restricted from of rewriting, one can hope for automatic translations of those definitions into interpreters in programming languages offering a limited support for matching and rewriting. To test this claim, we have manually but mechanically translated the RLS definitions for all styles (except for MSOS and the Cham) in Haskell, Ocaml, and Prolog. Appendix 13 discusses our translation procedures into these programming languages.</p><p>We compare the running times and memory requirements of the interpreters derived mechanically using the abovementioned procedures, with those of the "free" interpreters given by executing the definition "as-is" on two rewrite engines (marked with ୋ in the tables), namely Asf+Sdf 1.5 (a compiler) and Maude 2.2 (a fast interpreter with good tool support), as well as with those obtained executing off-the-shelf interpreter implementations in Scheme, used in teaching programming languages (marked with in the tables). For Scheme we have used PLT-Scheme as an interpreter and language interpreter implementations from <ref type="bibr" target="#b35">[35]</ref>, chapters 3.9 (evaluation semantics) and 7.3 (continuation based semantics), and a PLT-Redex definition given as example in the installation package (for context reduction). Big-step interpreters are also compared against bc, a C-written interpreter for a subset of C working only with integers (bc comes as part of UNIX; type "man bc" for documentation), and two interpreters implemented using monads in Haskell and Ocaml (we mark these interpreters with in Table <ref type="table" target="#tab_12">16</ref>). Since RLS representations of MSOS and Cham definitions rely intensively on matching modulo associativity and commutativity, which is only supported by Maude, we have only performed some experiments on their RLS definitions in Maude. For Cham we preferred to give the times obtained by using the novel transformations and strategies presented in Section 10 for making the specification "more executable". Using the specification as is, Cham is extremely ineffective when executed: it takes about 1205MB of memory and 188 s to search for the solution of running the Collatz program (explained below) up to 3.</p><p>One may naturally ask: "What is the point of all these experiments? They show little or nothing to support the RLS resulting definitions compared to their original definitions, and only show what programs (interpreters) in what programming languages are more efficient than others." Our goal here is to convey the reader our strong belief, supported by empirical evaluation, that the working language designer may be better off in practice formally defining a desired language, using some preferred definitional style, than implementing an interpreter in an ad-hoc way for that language, even in a preferred programming language. Unfortunately, the latter approach is also how programming language concepts are being taught in many places. Formal definitions tend to be significantly more compact, easier to read and more modular than ad-hoc language implementations, so they are easier to change and experiment with. Additionally, they can serve as a mathematical object capturing the essence of the desired language. One can then use this mathematical object for many other purposes in addition to executing programs, including formal analyses such as theorem proving and model-checking, static analysis, partial evaluation, compiler generation, and so on. Of course, this belief transcends the boundaries of rewriting logic; what RLS gives us here is a unified framework, with a uniform notation supported by a rigorous computational logic, in which one can formally define programming languages using any of the desired styles. None of the translations from RLS definitions into programming languages has been implemented, because that is not the focus of this paper. Nevertheless, we strongly believe that they can be implemented with relatively little effort. One of the programs chosen to test various implementations consists of n nested loops, each of 2 iterations, parameterized by n. The other program tests the Collatz's conjecture up to 300. Collatz's conjecture states that starting from any positive number n and performing the following operations:</p><p>• if n is even then divide it by 2; • if n is odd then multiply it by 3 and add 1; after a finite number of steps, the value of n will become 1. To make the program more computation-intensive (and also to maximize the number of language constructs used), we here use repeated subtraction to compute division. We also count in steps the cumulative number of operations performed until 1 is reached for all numbers tested and return it as the result of the program. The source code for the programs used is presented in Table <ref type="table" target="#tab_11">15</ref>.</p><p>Tables <ref type="table" target="#tab_12">16,</ref><ref type="table" target="#tab_6">17</ref>,18 and 19, give for each definitional style the running time of the various interpreters. For the largest number n (18) of nested loops, peak memory usage was also recorded. Times are expressed in seconds. A limit of 700 mb was set on memory usage, to avoid swapping; the symbol "-" found in a table cell signifies that the memory limit was reached. For Haskell we have used the ghc 6.4.2 compiler. For Ocaml we have used the ocamlcopt 3.09.3 compiler. For Prolog we have compiled the programs using the gprolog 1.3.0 compiler. For Scheme we have used the PLT-Scheme (mzscheme 3.7.1) interpreter. Tests were performed on an Intel Pentium 4@2 GHz with 1 GB RAM, running Linux.</p><p>To have an overview of execution times obtained by using the RLS definition as is for all the styles presented, Table <ref type="table" target="#tab_13">20</ref> shows, side by side, their execution times in Maude.</p><p>Prolog yields pretty fast interpreters. However, for backtracking reasons, it needs to maintain the stack of all predicates tried on the current path, thus the amount of memory grows with the number of computational steps. The style promoted in <ref type="bibr" target="#b35">[35]</ref> seems to also take into account efficiency. Its only drawback is the fact that it looks more like an implementation, the representational distance to the big-step definition being much bigger than in interpreters based on RLS. The PLT-Redex implementation of context reduction seems to serve more a didactic purpose. It compensates for lack of speed by providing a nice interface and the possibility to visually trace a run. The rewriting logic implementations seem to be quite efficient in terms of speed and memory usage, while keeping a minimal representational distance to the operational semantics definitions. In particular, RLS definitions interpreted in Maude are comparable in terms of efficiency with the interpreters in Scheme, while having the advantage of being formal definitions. The main reason for Maude and Scheme being slower than the others, is because they are both interpreters while the others are compilers. It is well known that compilers usually generate executables one order of magnitude faster than their interpreted versions. Also, it is good to notice that the interpreter obtained by mechanically compiling the RLS definition in Ocaml can reach the speed of the hand-optimized, C-written bc interpreter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.">Related work</head><p>There is much related work on frameworks for defining programming languages. Without trying to be exhaustive, we mention some of them. We do not try to give detailed comparisons with each approach, but limit ourselves to making some high-level remarks. Also, we do not discuss any of the approaches, such as SOS, MSOS, context reduction, or the Cham, which we have already discussed in the body of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.1.">Algebraic denotational semantics</head><p>This approach, (see <ref type="bibr" target="#b97">[95,</ref><ref type="bibr" target="#b39">39,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b62">62]</ref> for early papers and <ref type="bibr" target="#b37">[37,</ref><ref type="bibr" target="#b90">88]</ref> for two more recent books), is a special case of RLS, namely, the case in which the rewrite theory R L defining language L is an equational theory. While algebraic semantics shares a number of advantages with RLS, its main limitation is that it is well suited for giving semantics to deterministic languages, but not well suited for concurrent language definitions. At the model-theoretic level, initial algebra semantics, pioneered by Joseph Goguen, is the preferred approach (see, for example, <ref type="bibr" target="#b39">[39,</ref><ref type="bibr" target="#b37">37]</ref>), but other approaches, based on loose semantics or on final algebras, are also possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.2.">Other RLS work</head><p>RLS is a collective international project. Through the efforts of various researchers, there is by now a substantial body of work demonstrating the usefulness of this approach <ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b30">[30]</ref><ref type="bibr" target="#b31">[31]</ref><ref type="bibr" target="#b32">[32]</ref><ref type="bibr" target="#b33">[33]</ref><ref type="bibr" target="#b36">36,</ref><ref type="bibr" target="#b42">42,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b45">45,</ref><ref type="bibr" target="#b53">53,</ref><ref type="bibr" target="#b56">56,</ref><ref type="bibr" target="#b73">73,</ref><ref type="bibr" target="#b75">75,</ref><ref type="bibr" target="#b76">76,</ref><ref type="bibr" target="#b84">[84]</ref><ref type="bibr" target="#b86">[85]</ref><ref type="bibr" target="#b88">[86]</ref><ref type="bibr" target="#b91">[89]</ref><ref type="bibr" target="#b92">[90]</ref><ref type="bibr" target="#b93">[91]</ref>. A first snapshot of the RLS project was given in <ref type="bibr" target="#b56">[56]</ref>, and a second in <ref type="bibr" target="#b57">[57]</ref>. This paper can be viewed as third snapshot focusing on the variety of definitional styles supported. In particular, a substantial body of experience in giving programming language definitions, and using those definitions both for execution and for analysis purposes has already been gathered. For example, Java 1.4 (see also <ref type="bibr" target="#b20">[20]</ref> for a complete formal semantics) and the JVM (see <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b30">30]</ref>) have been specified in Maude this way, with the Maude rewriting logic semantics being used as the basis of Java and JVM program analysis tools that for some examples outperform well-known Java analysis tools <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b31">31]</ref>. A semantics of a Caml-like language with threads was discussed in detail in <ref type="bibr" target="#b56">[56]</ref>, and a modular rewriting logic semantics of a subset of CML has been given in <ref type="bibr" target="#b18">[18]</ref> using the Maude MSOS tool <ref type="bibr" target="#b19">[19]</ref>. A definition of the Scheme language has been given in <ref type="bibr" target="#b26">[26]</ref>. Other language case studies, all specified MSOS, context reduction, continuation-based semantics, and the Cham, we hope to have illustrated what might be called its ecumenical character; that is, its flexible support for a wide range of definitional styles, without forcing or pre-imposing any given style. In fact, we think that this flexibility makes RLS useful as a way of exploring new definitional styles. For example, our discussion on the Cham makes clear that the Cham proponents are dissatisfied with the lack of true concurrency in standard SOS. For highly concurrent languages, such as mobile languages, or for languages involving concurrency, real-time and/or probabilities, it seems clear to us that a centralized approach forcing an interleaving semantics becomes increasingly unnatural. We have, of course, refrained from putting forward any specific suggestions in this regard: that was not the point of an ecumenical paper. But we think that new definitional styles are worth investigating; and hope that RLS in general, and this paper in particular, will stimulate such investigations.</p><p>Haskell: We use Scgf(st,s) and Acfg(a,s), etc., to encode configurations st,s and a,s , respectively. We define an evaluation function for each type of configuration, for example eStmt is the function evaluating Scfg configurations and eAExp is evaluating Acfg configurations. The matching of the evaluation of premises is performed by using the let construct.</p><p>eStmt (Scfg (Assign x a) s) = let (Acfg (Int i) s1) = eAExp (Acfg a s) in (bind s1 x i)</p><p>Maude: Since Maude is the standard execution engine for rewriting logic specifications, the rules here are the ones in the specification.</p><p>rl &lt; X := A,S &gt; =&gt; S1[X &lt;-I] if &lt; A,S &gt; =&gt; {I,S1}.</p><p>Ocaml: Since Ocaml supports polymorphic functions, we only need to define one evaluation function for all constructs.</p><p>Then matching is used to obtain the starting term and match ... with ... is used for evaluating the premises.</p><p>let rec eval = function ... | Scfg(Assign(x,a),s) -&gt; (match eval (Acfg(a,s)) with Acfg(Int(i),s1) -&gt; (bind s1 x i))</p><p>Prolog: In Prolog we define a relation for each type of configuration and use unification for matching only purposes. Note that while in Ocaml, constructors of abstract data types start with capital letter, in Prolog this would correspond to variables, so we need to use scfg, acfg, etc., to encode configurations.</p><p>eStmt(scfg(X = A,S),S2) :-eAExp(acfg(AE,S),acfg(I,S1)), bind(S1,X,I,S2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2. Continuation-based definitions</head><p>Recall that the RLS semantics for assignment consists of an equation and a rule: Asf+Sdf Again, the translation to Asf+Sdf implies minimal or no modifications. Note that Asf+Sdf makes no distinction between equations and rules, all of them being written as equations.</p><p>[] stmt(X := A) = aexp(A) -&gt; write(X) [] k(int(I) -&gt; write(X) -&gt; K) store(Store) = k(K) store(bind(Store,X,I))</p><p>Haskell: The continuation concatenation is replaced by list concatenation. The evaluation rules are transformed into a recursive evaluation function acting at the top of the state. eq stmt(X := A) = aexp(A) -&gt; write(X) . rl k(int(I) -&gt; write(X) -&gt; K) store(Store) =&gt; k(K) store(Store[X &lt;-I]) .</p><p>Ocaml: A similar approach as that for Haskell. Prolog: Same approach as for the functional languages above, but we now define (functional) evaluation relations for functions decomposing the program and a one-step rewrite relation for the top-level evaluation process.</p><p>stmt(X = A,K) :-aexp(A,KA), append(KA,[write(X)],K). step(conf(store(S),v([I]),k([write(X)|K])), conf(store(S1),v(Vl),k(K))) :-bind(S,X,I,S1).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Visual representation of rewriting logic deduction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Proposition 1 .</head><label>1</label><figDesc>Let x,x ∈ Var,i,i ∈ Int,s,s ∈ Store and finite partial functions σ ,σ : Var • → Int.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>eval(P) = smallstep( P,∅ ) smallstep( P,S ) = smallstep(• P,S ) smallstep(• skip.I,S ) → I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>be a rule for defining a print language construct unobs{out = (), . . .} print(I) {out =I,...} ------→ skip</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>A unobs{halt? = (), . . .} halt I {halt? =I,...} -------→ stuck P {halt? =I,...} -------→ P program P {halt? =I,...} -------→ program skip.I P {halt? =(),...} --------→ P program P {halt? =(),...} --------→ program P An alternative to the above definition, which would not require the introduction of new syntax, is to make halt? a readwrite field with possible values integers along with a default value nil and use an unobservable transition at top to terminate the program: A X -→ A halt A X -→ halt A unobs{halt? = nil,halt? = nil, . . .} halt I {halt?=nil,halt? =I,...}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>true and B → B false and B → false not true → false not false → true if true then St 1 else St 2 → St 1 if false then St 1 else St 2 → St 2 skip; St → St {St} → St P,σ [X:=I] → P,σ [I/X] [skip] while B St → if B then (St; while B St) else skip C[halt I] → I C[skip.I] → I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Case x:=a: x:=a parses as[][x:=a] iff a ∈ Int, iff R CxtRed s2c(x:=i) = [][x:=i].Case st.a: st.a parses as st.c[r] iff st = skip and a parses as c[r], iff st = skip and R CxtRed s2c(a) = c[r] iff R CxtRed s2c(at.a) = st.c[r]. Case p,σ : p,σ parses as c[r] iff p parses as c [r] and c = c ,s iff</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>aexp(A) P = result(k(pgm(P)) store(empty)) result(k(I) store(Store)) = IStrengths. Context reduction semantics divides SOS rules into computational rules and rules needed to find the redex; the latter are transformed into grammar rules generating the allowable contexts. This makes definitions more compact. It improves over SOS semantics by allowing the context to be changed by execution rules. It can easily deal with control-intensive features. It is more modular than SOS.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Proposition 4 .</head><label>4</label><figDesc>For each arithmetic context c in CxtRed and r ∈ AExp, we have that R K k(aexp(c[r])) = k(aexp(r) aexp(c))).Similarly for any possible combination for c and r among AExp,BExp,Stmt,Pgm,Cfg.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>b 1</head><label>1</label><figDesc>and b 2 = [] and b 2 [b 1 ]: R K k(bexp(b 1 and b 2 )) = k(bexp(b 1 ) and(bexp(b 2 ))) = k(bexp(b 1 ) bexp([]) and(aexp(b 2 ))) = k(bexp(b 1 ) bexp([]and b 2 )). t and b 2 = [][t and b 2 ]: R K k(bexp(t and b 2 )) = k(bexp(t and b 2 ) bexp([])). st.a = [].a[st]: R K k(pgm(st.a)) = k(stmt(st) aexp(a)) = k(stmt(st) stmt([]) aexp(a)) = k(stmt(st) pgm([].a)). skip.a = skip.[][a]: R K k(pgm(skip.a)) = k(stmt(skip) aexp(a)) = k(aexp(a)) = k(aexp(a) aexp([])) = k(aexp(a) stmt(skip) aexp([])) = k(aexp(a) pgm(skip.[])).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>sorts Molecule, Molecules, Solution. subsorts Solution &lt; Molecule &lt; Molecules. op λ :-→Molecules. op _,_ : Molecules Molecules-→Molecules. op {|_|} : Molecules-→Solution . *** membrane operator op _ _ : Molecule Solution-→Molecule . *** airlock operator A Cham is then a rewrite theory C = ( ,AC,R), with ⊇ , together with a partition R = Reaction Heating Cooling</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>stmt(X :=A) = aexp(A) write(X) k(I write(X) K) store(Store) → k(K) store(Store[X ← I])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>stmt (Assign x a)) = (aexp a) ++ [Kwrite x] result (Kval (Vint i):Kwrite x:k) s = result k (bind s x i) Maude: Representation in Maude is the exact rewriting logic definition.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>let rec stmt = function ... | Assign(x, a) -&gt; (aexp a) @ [Kwrite x] let rec result s = function ... | (Kval (Vint i)::Kwrite x::k) -&gt; result (bind s x i) k</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>A small imperative language. AExp &lt;= AExp | AExp &gt;= AExp | AExp == AExp | BExp and BExp | BExp or BExp | not BExp</figDesc><table><row><cell>AExp</cell><cell>::=</cell><cell>Var | Int | AExp + AExp | AExp -AExp | AExp * AExp |</cell></row><row><cell></cell><cell></cell><cell>AExp / AExp | ++ Var</cell></row><row><cell cols="3">BExp Bool | Stmt ::= ::= skip | Var := AExp | Stmt ; Stmt | { Stmt } |</cell></row><row><cell></cell><cell></cell><cell>if BExp then Stmt else Stmt | while BExp Stmt | halt AExp</cell></row><row><cell>Pgm</cell><cell>::=</cell><cell>Stmt . AExp</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2</head><label>2</label><figDesc>The BigStep language definition.</figDesc><table /><note><p>Types of configurations: Int,Store , Bool,Store , AExp,Store , BExp,Store , Stmt,Store , Pgm , Int .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 R</head><label>3</label><figDesc>BigStep rewriting logic theory.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>s → st.a ,s and s σ .Let us now move to the second equivalence. For this proof let → n be the restriction of R SmallStep relation → to those pairs which can be provable by exactly applying n -1 times the Transitivity rule if n &gt; 0, or Reflexivity for n = 0. We first prove the following more general result (suppose p ∈ Pgm, σ : Var SmallStep smallstep( p 1 ,s 1 ) → n-1 smallstep(• p ,s ) and s σ (by the induction hypothesis) iff R SmallStep smallstep(• p,s ) → 1 smallstep( p 1 ,s 1 ) and s 1 σ 1 and R SmallStep smallstep( p 1 ,s 1 ) → n-1 smallstep(• p ,s ) and s σ iff R SmallStep smallstep(• p,s ) → n smallstep(• p ,s ) and s σ . We are done, since R SmallStep smallstep( p,s ) = smallstep(• p,s ). SmallStep eval(p) = smallstep( p,∅ ) and R SmallStep smallstep(• skip.i,s ) = i. Strengths. Small-step operational semantics precisely defines the notion of one computational step. It stops at errors, pointing them out. It is easy to trace and debug. It gives interleaving semantics for concurrency.</figDesc><table><row><cell>Finally, SmallStep</cell><cell>p, ⊥ →</cell></row></table><note><p><p><p>• → Int and s ∈ Store such that s σ ):</p>SmallStep p,σ → n p ,σ iff</p>R SmallStep smallstep( p,s ) → n smallstep(• p ,s ) and s σ , by induction on n. If n = 0 then p,σ = p ,σ and since R SmallStep smallstep( p,s ) = smallstep(• p,s ) we are done. If n &gt; 0, we have that SmallStep p,σ → n p ,σ iff SmallStep p,σ → p 1 ,σ 1 and SmallStep p 1 ,σ 1 → n-1 p ,σ iff R SmallStep • p,s → p 1 ,s 1 and s 1 σ 1 (by 1) and R * skip.i,σ iff R SmallStep smallstep( p,∅ ) → smallstep(• skip.i,s ), s σ ; the rest follows from R</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 7 R</head><label>7</label><figDesc>MSOS rewriting logic theory.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 8 The</head><label>8</label><figDesc>CxtRed language definition.</figDesc><table><row><cell>CConf</cell><cell>::=</cell><cell>CPgm,Store</cell></row><row><cell>CPgm</cell><cell>::=</cell><cell>[] | skip.CAExp | CStmt.AExp</cell></row><row><cell>CStmt</cell><cell>::=</cell><cell></cell></row></table><note><p>[] | CStmt; Stmt | X:=CAExp | if CBExp then Stmt else Stmt | halt CAExp CBExp ::= [] | Int&lt;=CAExp | CAExp&lt;=AExp | CBExp and BExp | not CBExp CAExp</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 11 R</head><label>11</label><figDesc>CxtRed rewriting logic theory.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>{|(X,I +Int 1) σ |} I 1 &lt;=I 2 → (I 1 ≤ Int I 2 ) St 1 else St 2 → St 1 if false then St 1 else St 2 → St 2Note that we could not use the existing airlock mechanism to stack evaluation contexts since that could lead to unsound computations. Indeed, say one would use constructs {|_ _|} to stack contexts, replacing the [_ | _] construct. Then by applying heating on skip; 3/4/5, one can obtain the following sequence (of structurally equivalent molecules)</figDesc><table><row><cell>true and B → B</cell><cell></cell><cell></cell></row><row><cell>false and B → false</cell><cell></cell><cell></cell></row><row><cell>not true → false</cell><cell></cell><cell></cell></row><row><cell>not false → true</cell><cell></cell><cell></cell></row><row><cell>if true then skip; 5/(2/x)</cell><cell cols="3">{|5/(2/x) {|skip; []|}|}</cell><cell>{|2/x {|5/[] {|skip; []|}|}|}</cell></row><row><cell cols="3">{|x {|2/[] {|5/[] {|skip; []|}|}|}|}</cell></row><row><cell cols="4">Now, by applying the cooling, then heating rules for airlock, one obtains the following sequence (of, again, equivalent</cell></row><row><cell>molecules)</cell><cell></cell><cell></cell></row><row><cell cols="3">{|x {|2/[] {|5/[] {|skip; []|}|}|}|}</cell><cell>{|x {|2/[] {|5/[],skip; []|}|}|}</cell></row><row><cell cols="2">{|x {|2/[],5/[],skip; []|}|}</cell><cell cols="2">{|x {|5/[] {|2/[],skip; []|}|}|}</cell></row><row><cell cols="3">{|x {|5/[] {|2/[] {|skip; []|}|}|}|}</cell></row><row><cell cols="4">Finally, by applying cooling rules for contexts, we obtain the sequence:</cell></row><row><cell cols="3">{|x {|5/[] {|2/[] {|skip; []|}|}|}|}</cell><cell>{|5/x {|2/[] {|skip; []|}|}|}</cell></row><row><cell cols="2">{|2/(5/x) {|skip; []|}|}</cell><cell cols="2">skip; 2/(5/x)</cell></row><row><cell cols="4">However, skip; 5/(2/x) and skip; 2/(5/x) are obviously not structurally equivalent.</cell></row></table><note><p>skip; St → St {St} → St [X:=I | C],{|(X,I ) σ |} → [skip | C],{|(X,I) σ |} [while B St | C] → [if B then (St; while B St) else skip | C] [halt I | C],σ → I skip.I,σ → I</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 15</head><label>15</label><figDesc>Programs used in evaluation: (a) a tower of loops, each performing two iterations; (b) pProgram testing Collatz's conjecture up to 300.</figDesc><table><row><cell></cell><cell>nr:=300;</cell></row><row><cell></cell><cell>while (not (nr&lt;=2)){</cell></row><row><cell></cell><cell>n:=nr;</cell></row><row><cell>x0 := 0;</cell><cell>nr:=nr -1;</cell></row><row><cell>while (++x0&lt;=2){</cell><cell>while (not (n==1)){</cell></row><row><cell>x1:=0;</cell><cell>steps:=steps + 1;</cell></row><row><cell>while (++x1&lt;=2){</cell><cell>r:=n;</cell></row><row><cell>• • •</cell><cell>q:=0;</cell></row><row><cell>x18:=0;</cell><cell>while (not (r&lt;=1)){</cell></row><row><cell>while (++x18&lt;=2){</cell><cell>r:=r -2;</cell></row><row><cell>skip;</cell><cell>q:=q + 1</cell></row><row><cell>}</cell><cell>};</cell></row><row><cell>• • •</cell><cell>if (r==0)</cell></row><row><cell>}</cell><cell>then n:=q</cell></row><row><cell>}.0</cell><cell>else n:=3*n + 1</cell></row><row><cell></cell><cell>}</cell></row><row><cell></cell><cell>}</cell></row><row><cell></cell><cell>}.steps</cell></row><row><cell>(a)</cell><cell>(b)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 16</head><label>16</label><figDesc>Execution times for big-step definitions.</figDesc><table><row><cell>N nested loops(1…2)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table 20</head><label>20</label><figDesc>Execution times for RLS definitions interpreted in Maude.</figDesc><table><row><cell>N nested loops(1…2)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We will not consider this general version. The interested reader is referred to<ref type="bibr" target="#b15">[15]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In general, one would have both an environment, and a store, with variables mapped to locations in the environment, and locations mapped to values in the store. However, for the sake of brevity, and given the simplicity of our example language, we do not use environments and map variables directly to values in the store.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>However, for brevity's sake, we do not present the semantics of similar constructs, such as -, * ,/, or.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>However, we regard these as minor syntactic details. After all, the program needs to be transformed into an abstract syntax tree (AST) in any of the previous formalisms. Whether the AST is kept in prefix versus postfix order is somewhat irrelevant.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>"same" modulo irrelevant but equivalent syntactic notational conventions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Which is of course understood as a pair of rules, one in each direction.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank our fellow researchers in the RLS project, including Wolfgang Ahrendt, Musab Al-Turki, Marcelo d'Amorim, Eyvind W. Axelsen, Christiano Braga, Illiano Cervesato, Fabricio Chalub, Feng Chen, Manuel Clavel, Azadeh Farzan, Alejandra Garrido, Mark Hills, Einar Broch Johnsen, Ralph Johnson, Michael Katelman, Laurentiu Leustean, Narciso Martí-Oliet, Olaf Owe, Stefan Reich, Andreas Roth, Juan Santa-Cruz, Ralf Sasse, Koushik Sen, Mark-Oliver Stehr, Carolyn Talcott, Prasanna Thati, Ram Prasad Venkatesan, and Alberto Verdejo, for their many contributions, which have both advanced the project and stimulated our ideas. We also thank the students at UIUC who attended courses on programming language design, semantics, and formal methods, who provided important feedback and suggestions. Last but not least, we thank Mark Hills for fruitful discussions and his help in adjusting the PLT-Redex implementation to suit our needs.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ୋ Supported by NSF Grants CCF-0448501, CNS-0509321 and CNS-0720512, NASA Grant NNL08AA23C, and by several Microsoft gifts.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>in Maude, include BC <ref type="bibr" target="#b13">[13]</ref>, CCS <ref type="bibr" target="#b92">[90,</ref><ref type="bibr" target="#b13">13]</ref>, CIAO <ref type="bibr" target="#b86">[85]</ref>, Creol <ref type="bibr" target="#b43">[43]</ref>, ELOTOS <ref type="bibr" target="#b91">[89]</ref>, MSR <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b83">83]</ref>, PLAN <ref type="bibr" target="#b84">[84,</ref><ref type="bibr" target="#b86">85]</ref>, the ABEL hardware description language <ref type="bibr" target="#b45">[45]</ref>, SILF <ref type="bibr" target="#b42">[42]</ref>, FUN <ref type="bibr" target="#b72">[72]</ref>, Orc <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>, and the π -calculus <ref type="bibr" target="#b88">[86]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.3.">Higher-order approaches</head><p>The most classic higher-order approach, although not exactly operational, is denotational semantics <ref type="bibr" target="#b78">[78,</ref><ref type="bibr" target="#b79">79,</ref><ref type="bibr" target="#b77">77,</ref><ref type="bibr" target="#b63">63]</ref>. Denotational semantics has some similarities with its first-order algebraic cousin mentioned above, since both are based on semantic equations. Two differences are: (i) the use of first-order equations in the algebraic case versus the higher-order ones in traditional denotational semantics; and (ii) the kinds of models used in each case. A related class of higher-order approaches uses higher-order functional languages or higher-order theorem provers to give operational semantics to programming languages. Without trying to be comprehensive, we can mention, for example, the use of Scheme in <ref type="bibr" target="#b35">[35]</ref>, the use of ML in <ref type="bibr" target="#b69">[69]</ref>, and the use of Common LISP within the ACL2 prover in <ref type="bibr" target="#b46">[46]</ref>. There is also a body of work on using monads <ref type="bibr" target="#b61">[61,</ref><ref type="bibr" target="#b96">94,</ref><ref type="bibr" target="#b47">47]</ref> to implement language interpreters in higher-order functional languages; the monadic approach has better modularity characteristics than standard SOS. A third class of higher-order approaches are based on the use of higher-order abstract syntax (HOAS) <ref type="bibr" target="#b68">[68,</ref><ref type="bibr" target="#b41">41]</ref> and higher-order logical frameworks, such as LF <ref type="bibr" target="#b41">[41]</ref> or λ-Prolog <ref type="bibr" target="#b66">[66]</ref>, to encode programming languages as formal logical systems. For a good example of recent work in this direction see <ref type="bibr" target="#b58">[58]</ref> and references there.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.4.">Logic-programming-based approaches</head><p>Going back to the Centaur project <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b25">25]</ref>, logic programming has been used as a framework for SOS language definitions. Note that λ-Prolog <ref type="bibr" target="#b66">[66]</ref> belongs both in this category and in the higher-order one. For a recent textbook giving logic-programming-based language definitions, see <ref type="bibr" target="#b80">[80]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.5.">Abstract state machines</head><p>Abstract State Machine (ASM) <ref type="bibr" target="#b40">[40]</ref> can encode any computation and have a rigorous semantics, so any programming language can be defined as an ASM and thus implicitly be given a semantics. Both big-and small-step ASM semantics have been investigated. The semantics of various programming languages, including, for example, Java <ref type="bibr" target="#b81">[81]</ref>, has been given using ASMs. There are interesting connections between ASMs and rewriting logic, but their discussion is beyond the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="13.">Conclusions</head><p>In this paper, we have tried to show how RLS can be used as a logical framework for operational semantics definitions of programming languages. In particular, by showing in detail how it can faithfully capture big-step and small-step SOS,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Obtaining interpreters from RLS definitions</head><p>Since the definitions presented above are deterministic and use a restricted form of rewriting (with the exception of MSOS and CHAM), we believe it is straight-forward to generate interpreters from them in languages having built-in support for pattern matching and abstract data types. The main principle we use is to translate rewriting rules into evaluation functions. Since the store was defined separately and relies on matching modulo associativity and commutativity, we abstract it away, assuming each such language comes with a pre-defined store.</p><p>In the following we will show, with the definitions of assignment from big-step and continuation semantics how their translation appears as part of the chosen implementation languages. Since functional languages have a particular way of declaring abstract data types, you will notice that the syntax of the program looks different in different languages. However, assuming the existence of an external parser, we could ask from that parser to give as output terms of the abstract data type in the corresponding language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1. Big-Step based definitions</head><p>The rewriting rule for assignment in big-step is</p><p>Asf+Sdf Since Asf+Sdf is a rewriting engine, translating RLS specifications to Asf+Sdf interpreters is mostly a matter of using a different notation. In fact Asf+Sdf adopts a notation with setting the premises above the line, close to the original semantics.</p><p>[] &lt;I,S1&gt; := &lt;A,S&gt; ========================== &lt;X := A,S&gt; = bind(S1,X,I)</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Explicit substitutions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-L</forename><surname>Curien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-J</forename><surname>Lévy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;90: Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="31" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">PMaude: rewrite-based specification language for probabilistic object systems</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Agha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd Workshop on Quantitative Aspects of Programming Languages (QAPL 05)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">153</biblScope>
			<biblScope unit="page" from="213" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automatic validation of transformation rules for java verification against a rewriting semantics</title>
		<author>
			<persName><forename type="first">W</forename><surname>Ahrendt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sasse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th International Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Sutcliffe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting><address><addrLine>Montego Bay, Jamaica</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">December 2-6, 2005. 2005</date>
			<biblScope unit="volume">3835</biblScope>
			<biblScope unit="page" from="412" to="426" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">A Rewriting Logic Approach to the Semantics of Orc, Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Al-Turki</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-12">December 2005</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Real-time rewriting semantics of orc</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alturki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Leuschel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</editor>
		<meeting>the 9th International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming<address><addrLine>Wroclaw, Poland</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">July 14-16, 2007. 2007</date>
			<biblScope unit="page" from="131" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The GAMMA model and its discipline of programming</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Banâtre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Métayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="77" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Z.-E</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Rouyer-Degli, λ -ν, a calculus of explicit substitutions which preserves strong normalisation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Benaissa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Briaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lescanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="699" to="722" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The chemical abstract machine</title>
		<author>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="217" to="248" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<author>
			<persName><forename type="first">P</forename><surname>Borovanský</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cirstea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kirchner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kirchner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-E</forename><surname>Moreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ringeissen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vittek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ELAN V 3.4 User Manual</title>
		<meeting><address><addrLine>Nancy (France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-01">January 2000</date>
		</imprint>
	</monogr>
	<note>fourth ed.</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">ELAN from a rewriting logic point of view</title>
		<author>
			<persName><forename type="first">P</forename><surname>Borovanský</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kirchner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kirchner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-E</forename><surname>Moreau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="155" to="185" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Borras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clément</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Despeyroux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Incerpi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename></persName>
		</author>
		<title level="m">CENTAUR: the system, in: Software Development Environments (SDE)</title>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="14" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Braga</surname></persName>
		</author>
		<title level="m">Rewriting Logic as a Semantic Framework for Modular Structural Operational Semantics</title>
		<meeting><address><addrLine>Brasil</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Departamento de Informática, Pontificia Universidade Católica de Rio de Janeiro</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Modular rewriting semantics in practice</title>
		<author>
			<persName><forename type="first">C</forename><surname>Braga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Workshop on Rewriting Logic and its Applications (WRLA 2004)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<meeting>the Fifth International Workshop on Rewriting Logic and its Applications (WRLA 2004)</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">117</biblScope>
			<biblScope unit="page" from="393" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On the algebraic definition of programming languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="54" to="99" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>TOPLAS)</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Semantic foundations for generalized rewrite theories</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bruni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">360</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="386" to="414" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Representing the MSR cryptoprotocol specification language in an extension of rewriting logic with dependent types</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-O</forename><surname>Stehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Workshop on Rewriting Logic and its Applications</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Degano</surname></persName>
		</editor>
		<meeting>the Fifth International Workshop on Rewriting Logic and its Applications</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2004">2004. 2005</date>
			<biblScope unit="volume">117</biblScope>
			<biblScope unit="page" from="183" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Chalub</surname></persName>
		</author>
		<ptr target="&lt;http://www.ic.uff.br/frosario/dissertation.pdf&gt;" />
		<title level="m">An Implementation of Modular SOS in Maude, Master&apos;s thesis</title>
		<imprint>
			<date type="published" when="2005-05">May 2005</date>
		</imprint>
		<respStmt>
			<orgName>Universidade Federal Fluminense</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A modular rewriting semantics for CML</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chalub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Braga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Universal Computer Science</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="789" to="807" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<author>
			<persName><forename type="first">F</forename><surname>Chalub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Braga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maude</forename><forename type="middle">Msos</forename><surname>Tool</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Denker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</editor>
		<meeting>the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">176</biblScope>
			<biblScope unit="page" from="133" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro ¸su</surname></persName>
		</author>
		<ptr target="http://fsl.cs.uiuc.edu/index.php/,mailto:Rewriting_Logic_Semantics_of_Java" />
		<title level="m">Rewriting Logic Semantics of Java</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Rule-based analysis of dimensional safety</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Rewriting Techniques and Applications, 14th International Conference, RTA 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Nieuwenhuis</surname></persName>
		</editor>
		<meeting><address><addrLine>Valencia, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">June 9-11, 2003. 2003</date>
			<biblScope unit="volume">2706</biblScope>
			<biblScope unit="page" from="197" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">specification and programming in rewriting logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Durán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Quesada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="187" to="243" />
			<date type="published" when="2002">2002</date>
			<pubPlace>Maude</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">All about Maude, A High-Performance Logical Framework</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Durán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">4350</biblScope>
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">ASIP + ITP: a verification tool based on algebraic semantics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Santa-Cruz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PROLE 2005: V Jornadas sobre Programacin y Lenguajes</title>
		<imprint>
			<publisher>Thomson</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Natural semantics on the computer</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clément</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Despeyroux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hascoet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kahn</surname></persName>
		</author>
		<idno>PL-86-6 and Rapport de recherche #0416</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the France-Japan AI and CS Symposium, ICOT, Japan</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Fuchi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Nivat</surname></persName>
		</editor>
		<meeting>the France-Japan AI and CS Symposium, ICOT, Japan</meeting>
		<imprint>
			<publisher>INRIA</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="49" to="89" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Memorandum</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">An equational specification for the Scheme language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Amorim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
		<idno>No. UIUCDCS-R-2005-2567</idno>
	</analytic>
	<monogr>
		<title level="m">Selected papers from the 9th Brazilian Symposium on Programming Languages (SBLP&apos;05)</title>
		<imprint>
			<date type="published" when="2005-04">2005. April 2005</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1327" to="1348" />
		</imprint>
	</monogr>
	<note type="report_type">Also Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Refocusing in reduction semantics</title>
		<author>
			<persName><forename type="first">O</forename><surname>Danvy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Nielsen</surname></persName>
		</author>
		<idno>RS-02-04</idno>
	</analytic>
	<monogr>
		<title level="m">A preliminary version appears in the informal proceedings of the Second International Workshop on Rule-Based Programming</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<meeting><address><addrLine>Aarhus, Denmark; RULE</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">November 2004. 2001</date>
			<biblScope unit="volume">59</biblScope>
		</imprint>
		<respStmt>
			<orgName>BRICS, DAIMI, Department of Computer Science, University of Aarhus</orgName>
		</respStmt>
	</monogr>
	<note>This report supersedes BRICS report</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The Language, Proof Techniques, and Methodologies for Object-Oriented Algebraic Specification</title>
		<author>
			<persName><forename type="first">R</forename><surname>Diaconescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Futatsugi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cafeobj</forename><surname>Report</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">AMAST Series in Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="1998">1998</date>
			<publisher>World Scientific</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Verdejo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Workshop on Strategies in Automated Deduction (STRATEGIES 2006)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Boy De La Tour</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Archer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Muoz</surname></persName>
		</editor>
		<meeting>the 6th International Workshop on Strategies in Automated Deduction (STRATEGIES 2006)</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">174</biblScope>
			<biblScope unit="page" from="3" to="25" />
		</imprint>
	</monogr>
	<note>Deduction, strategies, and rewriting</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Static and Dynamic Formal Analysis of Concurrent Systems and Languages: A Semantics-based Approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farzan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Formal analysis of Java programs in JavaFAN</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farzan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification, 16th International Conference, CAV 2004</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</editor>
		<meeting><address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">July 13-17, 2004. 2004</date>
			<biblScope unit="volume">3114</biblScope>
			<biblScope unit="page" from="501" to="505" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Partial order reduction for rewriting semantics of programming languages</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farzan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Denker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</editor>
		<meeting>the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">176</biblScope>
			<biblScope unit="page" from="61" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<author>
			<persName><forename type="first">A</forename><surname>Farzan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algebraic Methodology and Software Technology, 10th International Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Rattray</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Maharaj</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Shankland</surname></persName>
		</editor>
		<meeting><address><addrLine>Stirling, Scotland, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004-07-12">2004. July 12-16, 2004. 2004</date>
			<biblScope unit="volume">3116</biblScope>
			<biblScope unit="page" from="132" to="147" />
		</imprint>
	</monogr>
	<note>AMAST</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Control operators, the SECD-machine, and the lambda-calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd Working Conference on the Formal Description of Programming Concepts</title>
		<meeting><address><addrLine>Ebberup, Denmark</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-08">August 1986</date>
			<biblScope unit="page" from="193" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">T</forename><surname>Haynes</surname></persName>
		</author>
		<title level="m">Essentials of Programming Languages</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Algebraic Semantics of the C Preprocessor and Correctness of its Refactorings</title>
		<author>
			<persName><forename type="first">A</forename><surname>Garrido</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<idno>UIUCDCS-R-2006- 2688</idno>
		<imprint>
			<date type="published" when="2006-02">February 2006</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Algebraic Semantics of Imperative Programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Malcolm</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Introducing OBJ</title>
		<author>
			<persName><forename type="first">J</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Winkler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Futatsugi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applications of Algebraic Specification using OBJ</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Goguen</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Algebraic denotational semantics using parameterized abstract modules</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Parsaye-Ghomi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Díaz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Ramos</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">107</biblScope>
			<biblScope unit="page" from="292" to="309" />
			<date type="published" when="1981">April 19-25, 1981. 1981</date>
			<publisher>Springer</publisher>
			<pubPlace>Peniscola, Spain</pubPlace>
		</imprint>
	</monogr>
	<note>Formalization of Programming Concepts, International Colloquium</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Evolving algebras 1993: Lipari Guide</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gurevich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Specification and Validation Methods</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Börger</surname></persName>
		</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="9" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A framework for defining logics</title>
		<author>
			<persName><forename type="first">R</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Honsell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="143" to="184" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Ro ¸su, A rewrite framework for language definitions and for generation of efficient interpreters</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hills</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Şerbȃnu ¸tȃ</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Denker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</editor>
		<meeting>the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">176</biblScope>
			<biblScope unit="page" from="215" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A run-time environment for concurrent objects with asynchronous method calls</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Johnsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Owe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Axelsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Workshop on Rewriting Logic and its Applications</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</editor>
		<meeting>the Fifth International Workshop on Rewriting Logic and its Applications</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2004">2004. 2005</date>
			<biblScope unit="volume">117</biblScope>
			<biblScope unit="page" from="375" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Natural semantics</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STACS 87, 4th Annual Symposium on Theoretical Aspects of Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">F.-J</forename><surname>Brandenburg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Vidal-Naquet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</editor>
		<meeting><address><addrLine>Passau, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">February 19-21, 1987. 1987</date>
			<biblScope unit="volume">247</biblScope>
			<biblScope unit="page" from="22" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A rewriting semantics for ABEL with applications to hardware/software co-design and analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Katelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Denker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</editor>
		<meeting>the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">176</biblScope>
			<biblScope unit="page" from="47" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Manolios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Moore</surname></persName>
		</author>
		<title level="m">Computer-Aided Reasoning: ACL2 Case Studies</title>
		<imprint>
			<publisher>Kluwer Academic Press</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jones</surname></persName>
		</author>
		<title level="m">Monad transformers and modular interpreters, in: POPL &apos;95: Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="333" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Rewriting logic as a logical and semantic framework</title>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<idno>SRI-CSL-93-05</idno>
	</analytic>
	<monogr>
		<title level="m">Handbook of Philosophical Logic</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Gabbay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Guenthner</surname></persName>
		</editor>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1993">2002. August 1993</date>
			<biblScope unit="page" from="1" to="87" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>First published as SRI</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Rewriting logic: roadmap and bibliography</title>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="121" to="154" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Conditional rewriting logic as a unified model of concurrency</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="155" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Rewriting logic as a semantic framework for concurrency: a progress report</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Sassone</surname></persName>
		</editor>
		<meeting><address><addrLine>Pisa, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">August 26-29, 1996. 1996</date>
			<biblScope unit="volume">1119</biblScope>
			<biblScope unit="page" from="331" to="372" />
		</imprint>
	</monogr>
	<note>CONCUR &apos;96, Concurrency Theory, 7th International Conference</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Membership algebra as a logical framework for equational specification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recent Trends in Algebraic Development Techniques, 12th International Workshop, WADT&apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Parisi-Presicce</surname></persName>
		</editor>
		<meeting><address><addrLine>Tarquinia, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997-06">June 1997. 1997</date>
			<biblScope unit="volume">1376</biblScope>
			<biblScope unit="page" from="18" to="61" />
		</imprint>
	</monogr>
	<note>Selected Papers</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Software specification and verification in rewriting logic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Models, Algebras, and Logic of Engineering Software</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Pizka</surname></persName>
		</editor>
		<meeting><address><addrLine>Marktoberdorf, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2002-08-11">July 30-August 11. 2002. 2003</date>
			<biblScope unit="page" from="133" to="193" />
		</imprint>
		<respStmt>
			<orgName>NATO Advanced Study Institute</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theoretical Aspects of Computing-ICTAC 2005, Second International Colloquium</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">V</forename><surname>Hung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</editor>
		<meeting><address><addrLine>Hanoi, Vietnam</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">October 17-21, 2005. 2005</date>
			<biblScope unit="volume">3722</biblScope>
			<biblScope unit="page" from="1" to="28" />
		</imprint>
	</monogr>
	<note>A rewriting logic sampler</note>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Modular rewriting semantics of programming languages</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Braga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algebraic Methodology and Software Technology, 10th International Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Rattray</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Maharaj</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Shankland</surname></persName>
		</editor>
		<meeting><address><addrLine>Stirling, Scotland, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004-07-12">2004. July 12-16, 2004. 2004</date>
			<biblScope unit="volume">3116</biblScope>
			<biblScope unit="page" from="364" to="378" />
		</imprint>
	</monogr>
	<note>AMAST</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Rewriting logic semantics: from language specifications to formal analysis tools</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Reasoning-Second International Joint Conference, IJCAR 2004</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Basin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</editor>
		<meeting><address><addrLine>Cork, Ireland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">July 4-8, 2004. 2004</date>
			<biblScope unit="volume">3097</biblScope>
			<biblScope unit="page" from="1" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">The rewriting logic semantics project</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">373</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="213" to="237" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Representing and reasoning with operational semantics</title>
		<author>
			<persName><forename type="first">D</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third International Joint Conference, IJCAR 2006</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Furbach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</editor>
		<meeting><address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">August 17-20, 2006. 2006</date>
			<biblScope unit="volume">4130</biblScope>
			<biblScope unit="page" from="4" to="20" />
		</imprint>
	</monogr>
	<note>Automated Reasoning</note>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Functions as processes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="119" to="141" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tofte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Macqueen</surname></persName>
		</author>
		<title level="m">The Definition of Standard ML (Revised)</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">An Abstract View of Programming Languages</title>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
		<idno>ECS-LFCS-90-113</idno>
		<imprint>
			<date type="published" when="1989-06">June 1989</date>
		</imprint>
		<respStmt>
			<orgName>Edinburgh University, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Mosses</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STACS 89, 6th Annual Symposium on Theoretical Aspects of Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Monien</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Cori</surname></persName>
		</editor>
		<meeting><address><addrLine>Paderborn, FRG</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">February 16-18, 1989. 1989</date>
			<biblScope unit="volume">349</biblScope>
			<biblScope unit="page" from="17" to="35" />
		</imprint>
	</monogr>
	<note>Unified algebras and action semantics</note>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Denotational semantics</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Mosses</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">B</biblScope>
			<date type="published" when="1990">1990</date>
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
	<note>Chapter 11</note>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Mosses</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algebraic Methodology and Software Technology, 9th International Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Kirchner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Ringeissen</surname></persName>
		</editor>
		<meeting><address><addrLine>Saint-Gilles-les-Bains, Reunion Island, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002-09-09">2002. September 9-13, 2002. 2002</date>
			<biblScope unit="volume">2422</biblScope>
			<biblScope unit="page" from="21" to="40" />
		</imprint>
	</monogr>
	<note>AMAST</note>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Modular structural operational semantics</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Mosses</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="195" to="228" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">An overview of Lambda-PROLOG</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nadathur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Programming, Proceedings of the Fifth International Conference and Symposium</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">A B</forename><surname>Robert</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Kowalski</surname></persName>
		</editor>
		<meeting><address><addrLine>Seattle, Washington</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1988">August 15-19, 1988. 1988</date>
			<biblScope unit="page" from="810" to="827" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Real-time Maude 2.1</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Ölveczky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Workshop on Rewriting Logic and its Applications</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</editor>
		<meeting>the Fifth International Workshop on Rewriting Logic and its Applications</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2004">2004. 2005</date>
			<biblScope unit="volume">117</biblScope>
			<biblScope unit="page" from="285" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Higher-order abstract syntax</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Elliott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;88: Proceedings of the ACM SIGPLAN 1988 Conference on Programming Language Design and Implementation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">Types and Programming Languages</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pierce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">A structural approach to operational semantics</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<idno>DAIMI FN-19</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">61</biblScope>
			<biblScope unit="page" from="17" to="139" />
			<date type="published" when="1981">2004. 1981</date>
		</imprint>
		<respStmt>
			<orgName>University of Aarhus</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Original version</note>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">The discoveries of continuations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lisp and Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="233" to="248" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">K: a Rewrite-based Framework for Modular Language Design, Semantics, Analysis and Implementation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ro</surname></persName>
		</author>
		<idno>UIUCDCS-R-2003-2897: lecture notes of CS322</idno>
	</analytic>
	<monogr>
		<title level="m">K was first introduced in 2003, in the technical report</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>programming language design</note>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Certifying optimality of state estimation programs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Venkatesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Whittle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Leustean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification, 15th International Conference, CAV 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Hunt</surname><genName>Jr</genName></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</editor>
		<meeting><address><addrLine>Boulder, CO, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">July 8-12, 2003. 2003</date>
			<biblScope unit="volume">2725</biblScope>
			<biblScope unit="page" from="301" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Reasoning about programs in continuation-passing style</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sabry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lisp and Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="289" to="360" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Rewriting Logic-Relating Semantics of Java, Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sasse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Taclets vs</title>
		<meeting><address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-05">May 2005</date>
			<biblScope unit="page" from="2005" to="2016" />
		</imprint>
		<respStmt>
			<orgName>Fakultät für Informatik, Universität Karlsruhe</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Java+ITP: a verification tool based on hoare logic and algebraic semantics</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sasse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Denker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</editor>
		<meeting>the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006)</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">176</biblScope>
			<biblScope unit="page" from="29" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<title level="m" type="main">Denotational Semantics-A Methodology for Language Development, Allyn and Bacon</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Schmidt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<pubPlace>Boston, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Outline of a mathematical theory of computation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, Fourth Annual Princeton Conference on Information Sciences and Systems</title>
		<meeting>Fourth Annual Princeton Conference on Information Sciences and Systems</meeting>
		<imprint>
			<date type="published" when="1970">1970</date>
			<biblScope unit="page" from="169" to="176" />
		</imprint>
		<respStmt>
			<orgName>Princeton University ; Oxford University, Programming Research Group</orgName>
		</respStmt>
	</monogr>
	<note>Also appeared as Technical Monograph PRG 2</note>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Toward a mathematical semantics for computer languages</title>
		<author>
			<persName><forename type="first">D</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Strachey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Microwave Research Institute Symposia Series, Proceedings of the Symposium on Computers and Automata</title>
		<imprint>
			<publisher>Polytechnical Institute of Brooklyn</publisher>
			<date type="published" when="1971">1971</date>
			<biblScope unit="volume">21</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<monogr>
		<title level="m" type="main">Formal Syntax and Semantics of Programming Languages</title>
		<author>
			<persName><forename type="first">K</forename><surname>Slonneger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">L</forename><surname>Kurtz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Stärk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Börger</surname></persName>
		</author>
		<title level="m">Java and the Java Virtual Machine: Definition, Verification, Validation</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">CINNI-a generic calculus of explicit substitutions and its application to lambda-, sigma-and pi-calculi</title>
		<author>
			<persName><forename type="first">M.-O</forename><surname>Stehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Workshop on Rewriting Logic and its Applications (WRLA 2000)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Futatsugi</surname></persName>
		</editor>
		<meeting>the Third International Workshop on Rewriting Logic and its Applications (WRLA 2000)</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">36</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<monogr>
		<title level="m" type="main">An execution environment for the MSR cryptoprotocol specification language</title>
		<author>
			<persName><forename type="first">M.-O</forename><surname>Stehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reich</surname></persName>
		</author>
		<ptr target="&lt;http://formal.cs.uiuc.edu/stehr/msr&gt;" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M.-O</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Plan in Maude: specifying an active network programming language</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Stehr</surname></persName>
		</author>
		<author>
			<persName><surname>Talcott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Forth International Workshop on Rewriting Logic and its Applications (WRLA 2002)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Gadducci</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</editor>
		<meeting>the Forth International Workshop on Rewriting Logic and its Applications (WRLA 2002)</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="page" from="240" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M.-O</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Practical techniques for language design and prototyping</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Stehr</surname></persName>
		</author>
		<author>
			<persName><surname>Talcott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Abstracts Collection of the Dagstuhl Seminar 05081 on Foundations of Global Computing</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Fiadeiro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</editor>
		<meeting><address><addrLine>Wadern, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">February 20-25, 2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">An executable specification of asynchronous Pi-Calculus semantics and may testing in Maude 2.0</title>
		<author>
			<persName><forename type="first">P</forename><surname>Thati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Forth International Workshop on Rewriting Logic and its Applications</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Gadducci</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</editor>
		<meeting>the Forth International Workshop on Rewriting Logic and its Applications</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="volume">71</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Compiling language definitions: the asf+sdf compiler</title>
		<author>
			<persName><forename type="first">M</forename><surname>Van Den Brand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Klint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Olivier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="334" to="368" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>TOPLAS)</note>
</biblStruct>

<biblStruct xml:id="b90">
	<monogr>
		<title level="m" type="main">Language Prototyping: An Algebraic Specification Approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Deursen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Klint</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>World Scientific</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Verdejo</surname></persName>
		</author>
		<title level="m">Maude como marco semántico ejecutable</title>
		<meeting><address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>Facultad de Informática, Universidad Complutense</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<author>
			<persName><forename type="first">A</forename><surname>Verdejo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Forth International Workshop on Rewriting Logic and its Applications</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Gadducci</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</editor>
		<meeting>the Forth International Workshop on Rewriting Logic and its Applications</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="volume">71</biblScope>
		</imprint>
	</monogr>
	<note>Implementing CCS in Maude 2</note>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Executable structural operational semantics in Maude</title>
		<author>
			<persName><forename type="first">A</forename><surname>Verdejo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="226" to="293" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Equational rules for rewriting logic</title>
		<author>
			<persName><forename type="first">P</forename><surname>Viry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="487" to="517" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Domain-Specific Program Generation, International Seminar</title>
		<author>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Program transformation with Stratego/XT: rules, strategies, tools, and systems in Stratego/XT 0</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Batory</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Consel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</editor>
		<meeting><address><addrLine>Dagstuhl Castle, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">March 23-28, 2003. 2003</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="216" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">The essence of functional programming</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;92: Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">First-order identities as a defining language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="337" to="357" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">A syntactic approach to type soundness</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="38" to="94" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">From syntactic theories to interpreters: a specification language and its compilation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Ariola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mauny</surname></persName>
		</author>
		<idno>cs.PL/0009030</idno>
	</analytic>
	<monogr>
		<title level="j">The Computing Research Repository (CoRR)</title>
		<imprint>
			<date type="published" when="2000-09">September 2000</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
