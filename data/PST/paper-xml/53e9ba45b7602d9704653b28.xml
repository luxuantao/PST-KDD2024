<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ConMem: Detecting Severe Concurrency Bugs through an Effect-Oriented Approach</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Wei</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Chong</forename><surname>Sun</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Shan</forename><surname>Lu</surname></persName>
							<email>shanlu@cs.wisc.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computer Sciences Department</orgName>
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Pittsburgh</settlement>
									<region>Pennsylvania</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">ConMem: Detecting Severe Concurrency Bugs through an Effect-Oriented Approach</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B68BFA4A336623030050A7678F4A219F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.5 [Testing and Debugging]: Testing Tools General Terms Languages</term>
					<term>Reliability Software testing</term>
					<term>concurrency bugs</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Multicore technology is making concurrent programs increasingly pervasive. Unfortunately, it is difficult to deliver reliable concurrent programs, because of the huge and non-deterministic interleaving space. In reality, without the resources to thoroughly check the interleaving space, critical concurrency bugs can slip into production runs and cause failures in the field. Approaches to making the best use of the limited resources and exposing severe concurrency bugs before software release would be desirable.</p><p>Unlike previous work that focuses on bugs caused by specific interleavings (e.g., races and atomicity-violations), this paper targets concurrency bugs that result in one type of severe effects: program crashes. Our study of the error-propagation process of realworld concurrency bugs reveals a common pattern (50% in our non-deadlock concurrency bug set) that is highly correlated with program crashes. We call this pattern concurrency-memory bugs: buggy interleavings directly cause memory bugs (NULL-pointerdereference, dangling-pointer, buffer-overflow, uninitialized-read) on shared memory objects.</p><p>Guided by this study, we built ConMem to monitor program execution, analyze memory accesses and synchronizations, and predicatively detect these common and severe concurrency-memory bugs. We also built a validator ConMem-v to automatically prune false positives by enforcing potential bug-triggering interleavings.</p><p>We evaluated ConMem using 7 open-source programs with 9 real-world severe concurrency bugs. ConMem detects more tested bugs (8 out of 9 bugs) than a lock-set-based race detector and an unserializable-interleaving detector that detect 4 and 5 bugs respectively, with a false positive rate about one tenth of the compared tools. ConMem-v further prunes out all the false positives. Con-Mem has reasonable overhead suitable for development usage.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction 1.1 Motivation</head><p>Multicore technology is making concurrent programs increasingly pervasive. Unfortunately, concurrent programs are prone to bugs. To exacerbate the problem, concurrency bugs are particularly difficult to detect and diagnose due to their unique non-determinism. Concurrency bugs can cause severe software failures and realworld disasters, such as the Northeastern Blackout of 2003 <ref type="bibr" target="#b40">[41]</ref>. As concurrent programs grow increasingly popular, developing effective approaches to detecting concurrency bugs is vital.</p><p>A fundamental challenge in concurrency bug detection is the enormous size of concurrent programs' interleaving space (exponential to the execution length for each input). Thoroughly checking this large space is crucial because concurrency bugs only manifest under certain interleavings. Unfortunately, in reality, software development resources can only afford to check a small part of this large space. Determining which part of the interleaving space should be checked is a critical and open problem.</p><p>To address the above challenge, previous concurrency bug detection and testing works <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b49">50]</ref> intelligently focus on certain interleaving patterns that are prone to concurrency bugs. Widely used patterns include data races (un-synchronized conflicting accesses to shared variables) and atomicity violations (an interleaving that makes certain code regions unserializable).</p><p>Although great progress has been made, previous work still leaves some key issues unsolved.</p><p>Firstly, large number of false positives could keep programmers away from bug reports. Previous research <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b28">29]</ref> observes that only approximately 2-10% of real data races are harmful; a similar trend is also seen among unserializable interleavings <ref type="bibr" target="#b33">[34]</ref>.</p><p>Secondly, not all bugs present equally harmful end effects, while they are not differentiated by many previous work. Table <ref type="table" target="#tab_0">1</ref> illustrates this trend by breaking down the relationship between faults (i.e., buggy interleaving patterns) and failures in 70 real concurrency bugs that are reported and fixed in open-source software (Section 3 will explain how we get this data). for each row should be even larger.)</p><p>Figure <ref type="figure" target="#fig_0">1</ref> visualizes the limitations of previous works (and our opportunities) by projecting a concurrent program's interleavings into a two-dimension space. The x-axis and y-axis represent differ-ent effects and different patterns of interleavings (i.e., failures and faults for buggy interleavings), respectively. Note that, this is only a conceptual projection. The different categories along the y-axis can actually overlap; some horizontal stripes may have larger portions of benign effects than others.  Previous concurrency bug detection work each takes a horizontal stripe of the above 2-D interleaving space. These horizontal approaches inevitably suffer from the following limitations.</p><p>Firstly, lack of good coverage for certain type of failures. Developers naturally want to know about all (or most) interleavings that can cause certain negative effects, such as software crashes. Unfortunately, interleavings that cause certain effects span vertically in the space and are difficult to adequately capture through a horizontal approach. This difficulty is reflected in every column in Table <ref type="table" target="#tab_0">1</ref>: no single interleaving pattern can monopolize one type of failures.</p><p>Secondly, an inevitably large number of false positives. This is clearly shown by the horizontal stripes in Figure <ref type="figure" target="#fig_0">1</ref> and is observed in the real world <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b33">34]</ref>.</p><p>Thirdly, a lack of severity differentiation. Severity is a qualitative metric for software failures. In practice <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>, bugs that lead to "crashes and loss of data" are considered to have high severity, and bugs that only lead to "minor loss of function or cosmetic problems" are considered minor or trivial. This lack of severity differentiation can be seen in each row from Table <ref type="table" target="#tab_0">1</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2: The cause-effect chain</head><p>We can deepen our understanding of the false positive and severity issues by looking at the cause-effect chains in concurrent programs. As shown in Figure <ref type="figure">2</ref>, interleaving patterns like data races and atomicity violations are only the start of potential error propagation chains. Some interleaving patterns do not propagate to any incorrect states (e.g., not every piece of code is intended to be atomic). For those that do cause wrong states, their intermediate errors might be masked during further propagation (e.g., due to redundant paths <ref type="bibr" target="#b28">[29]</ref>), or end up as a minor issue hardly visible to users, in many of which cases the data races or unserializable interleavings are intentionally left there by developers for better performance (e.g., conflicting accesses to performance counter <ref type="bibr" target="#b49">[50]</ref>). A pair of concrete examples are shown in Figure <ref type="figure" target="#fig_1">3</ref> and Figure <ref type="figure" target="#fig_2">4</ref>. These two real-world bugs start with similar bug-triggering interleavings, both involving data races and unserializable interleavings. However, one causes a server crash, while the other has an almost invisible effect at the end.</p><p>The false positive issue has already caught the attention of many researchers. Various innovative approaches, such as training <ref type="bibr" target="#b22">[23]</ref>, automated testing <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b41">42]</ref> and heuristics-based ranking, have been  proposed to mitigate this problem. However, without changing the underlying horizontal mechanism, these proposals still require significant manual efforts in specification writing and test-oracle design, as well as large amount of computational resources in many rounds of testing or training.</p><p>The severity issue has not received the attention it deserves in concurrency bug detection research. Severity guidance is important for concurrent programs due to several reasons: <ref type="bibr" target="#b0">(1)</ref> In general, developers use severity to prioritize their diagnosis and fixing efforts <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>. This is also observed by a recent study of Linux kernel developers' reactions to static bug detection reports <ref type="bibr" target="#b15">[16]</ref>; <ref type="bibr" target="#b1">(2)</ref> The huge interleaving space makes the prioritization process extremely important; (3) The unique non-determinism makes minorimpact concurrency bugs more trivial than their sequential counterparts; and (4) Fixing concurrency bugs often results in performance penalties, which make developers more reluctant to fix inconsequential concurrency bugs. In reality, programmers are even willing to introduce new non-severe concurrency bugs in order to fix severe concurrency bugs <ref type="bibr" target="#b25">[26]</ref>.</p><p>In summary, this paper plans to explore a bug detection approach that focuses on certain vertical stripes of the interleaving space -specifically, the crash stripe that spans across all kinds of (horizontal) interleaving pattern categories. This vertical approach will complement existing bug detection work and provide better guidance to expose severe concurrency bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Contributions</head><p>This paper proposes a concurrency bug detection tool, ConMem, which is guided not by certain interleaving patterns, but by certain general and severe bug effects, program crashes. As a dynamic monitoring tool, ConMem accurately and predicatively detects severe concurrency bugs that can lead to program crashes, no matter which interleaving pattern (race, atomicity violation, order violation, etc.) is the cause.</p><p>In order to capture the crash stripe in the interleaving space, we need to look backward along the cause-effect chain and find a pattern that can predict the crash effect. Fortunately, we find one.</p><p>Our characteristics study (Section 3) of the cause-effect chains of 70 real-world concurrency bugs reveals an error-propagation pattern that is both common (including almost half of the examined bugs) and highly correlated with software crashes (&gt; 85% observed conditional probability on both directions). This pattern occurs when interleavings cause an incorrect order among shared memory operations and directly turn to memory errors, including NULLshared-pointer dereference, dangling pointers to shared memory, un-initialized shared-memory read, and shared-buffer overflow. We refer to this pattern as concurrency-memory errors. Based on the above observation, ConMem (Figure <ref type="figure" target="#fig_3">5</ref>) is designed to predicatively catch concurrency-memory errors and to report fatal interleavings before they occur. Under each test input, ConMem monitors one run of the test concurrent program. It uses run-time information to first identify ingredients of potential concurrency-memory errors (e.g., a NULL-assignment and a dereference of a shared pointer from different threads are ingredients of a concurrency-NULL-dereference bug). It then analyzes synchronizations around these suspect ingredients to decide whether fatal interleavings exist to trigger the concurrency-memory error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>One</head><p>Furthermore, a noise-injection tool ConMem-v is built to automatically validate whether the fatal interleavings reported by Con-Mem can truly occur. Through ConMem-v, developers can easily validate ConMem report and reliably repeat true bugs.</p><p>Overall, this paper has made the following contributions.</p><p>• The first characteristic study on the cause-effect chains of realworld concurrency bugs. Our study is based on 70 fixed, realworld concurrency bugs collected by a previous study <ref type="bibr" target="#b21">[22]</ref> from four widely-used C/C++ applications (Apache, Mozilla, MySQL, and OpenOffice).  A new perspective to check the huge interleaving space. Traditional bug detectors focus on the cause of concurrency bugs and work horizontally in the interleaving space shown in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>ConMem complements them by focusing on certain effects and working vertically. Specifically, traditional tools identify all instances of certain interleaving patterns and rely on testing, training, or manual inspection to determine which can truly cause (severe) failures. ConMem benefits from its effect-oriented vertical approach and effectively prioritizes its bug detection effort towards severe software bugs, instead of benign or trivial interleaving problems. • A bridge between the well-studied memory bug problem and the challenging concurrency bug issue. Memory bug detection techniques are already mature for sequential programs <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b29">30]</ref>. However, they are not as effective in concurrent programs for several reasons. First of all, dynamic memory bug detectors are sensitive to interleaving. They can only catch bugs when they occur, unable to predict what might happen under future interleavings. Furthermore, even for those bugs that do occur during the monitored run, memory bug detectors cannot identify the root causes (i.e., buggy interleaving) and cannot help developers fully understand and fix the bug. Static analysis is not sensitive to interleaving. However, even with recent inspiring progress <ref type="bibr" target="#b6">[7]</ref>, its scalability and effectiveness in concurrent programs are still limited by the fundamental pointer alias and concurrency analysis problems. ConMem combines classic memory bug detection techniques with predictive interleaving analysis and interleaving testing, thus solving the above problems (more discussion is in Section 8). In the following, background and our cause-effect characteristics study are presented in Section 2 and 3. Section 4 discusses Con-Mem bug detection, followed by ConMem validator in Section 5. Section 6 and Section 7 present evaluation methodology and experimental results. Finally, related works are presented in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>Memory bugs are very common and also severe <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b50">51]</ref>. Many of them can cause program crashes, data loss and even security problems. This section provides a brief review of memory bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Typical Memory Bugs</head><p>NULL pointer dereference happens when the program dereferences a NULL-valued pointer. It causes the program to immediately crash. Much work has been done on static detection of NULLpointer dereference. However, their accuracy and scalability is limited by pointer alias problems. Un-initialized read occurs when a valid memory location is read before well initialized. It could cause wrong output or crash. Dynamically detecting un-initialized reads is straightforward. In prac-tice, sophisticated memory detectors, like Valgrind <ref type="bibr" target="#b29">[30]</ref>, also consider the context of the un-initialized read, and only report bugs when the un-initialized value is used in critical scenarios. Accessing invalid memory locations includes dangling pointer bugs (accessing memory locations that are already freed), buffer overflow bugs (accessing memory locations that are beyond the buffer-boundary), and stack smashing (overwriting critical data stored on stack). These bugs can cause not only wrong outputs, but also crashes and security vulnerabilities. Other memory bugs include double-free bugs (a memory location is freed twice), memory leak bugs, and complicated bugs, such as accessing legitimate but wrong memory locations. Various algorithms have been proposed to detect these bugs <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b37">38]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Memory Bugs in Concurrent Programs</head><p>Memory bugs in concurrent programs can be classified into two types. The first type only involves one thread and can be deterministically triggered by special inputs. In terms of dynamic detection, testing and diagnosis, this type of bugs is of no difference with those in sequential programs.</p><p>The second type such as the one shown in Figure <ref type="figure" target="#fig_1">3</ref> is more complicated. They involve more than one thread and require not only special inputs but also special interleavings to trigger. These bugs are actually side-effects of more fundamental concurrency bugs. As discussed in Section 1, these bugs cannot be addressed by existing dynamic memory bug detectors because their existence under future interleavings cannot be predicted by existing dynamic detectors. Even when they do occur under the current interleaving, their root causes still cannot be correctly identified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Cause-Effect Characteristics</head><p>Before designing the concurrency bug detection tools, we first study the error propagation process of 70 real-world concurrency bugs. This study will help us understand how buggy interleavings gradually deteriorate program states and ultimately cause various software failures, especially those that are severe (e.g., crashes).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Cause Error Propagation</head><p>Buggy Interleavings Visible Software Failures</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Effect</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intermediate Errors</head><p>Figure <ref type="figure">6</ref>: Cause-effect chain</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Methodology and Caveat</head><p>Bug Source This study uses a set of 70 real-world non-deadlock concurrency bugs collected in <ref type="bibr" target="#b21">[22]</ref> <ref type="foot" target="#foot_0">1</ref> . All of these 70 bugs are reported by users and fixed by developers from four widely-used C/C++ open-source applications: Apache HTTP server, MySQL database server, Mozilla web browser, and OpenOffice office toolkits. These bugs are collected by previous researchers through random sampling among all fixed bugs in the bug databases. We choose to focus on non-deadlock concurrency bugs, because deadlocks have much more regular effects and are better understood and addressed than non-deadlock bugs. Characteristics in study Previous characteristics studies <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b21">22]</ref> focus primarily on the interleaving patterns that cause the concurrency bugs. This work will study the error propagation process from its cause (buggy interleavings), through intermediate errors, to the final effects (demonstrated by Figure <ref type="figure">6</ref>).</p><p>In terms of causes, we refer to previous work <ref type="bibr" target="#b21">[22]</ref> to consider two causes: atomicity violation and order violation. Data races are orthogonal to these two and are not separately considered here.</p><p>In terms of effects, we follow previous general bug characteristics studies <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b50">51]</ref> and consider three main effects: crashes, hangs, and minor wrong functionality issues (including wrong outputs). Strictly speaking, there could also be severe bugs like loss of data, but the bug set we use does not contain such examples.</p><p>The most difficult part of our categorization is the intermediate errors. Since there has been no previous study regarding this, based on our own observations and inspiration from studies of general software bugs, we generalize two major categories: intermediate memory errors and intermediate semantic errors.</p><p>An intermediate memory error occurs when the buggy interleaving changes the execution order of a set of shared memory operations so that these operations themselves directly instantiate a memory bug. Afterward, the program fails similarly to those caused by memory bugs in sequential programs. This paper refers to this as concurrency-memory errors. They are further classified based on which types of memory bugs are instantiated, as shown in Table <ref type="table" target="#tab_6">2</ref>.</p><p>An intermediate semantic error occurs when the buggy interleaving causes new and unexpected program states that are not handled by the program. Once that unexpected state happens, the program fails, as happens with semantic bugs in sequential programs.</p><p>These two categories are usually easy to classify, except for a few complicated cases, such as the Mozilla bug shown in Figure <ref type="figure">7</ref>. This bug and the MySQL bug in Figure <ref type="figure" target="#fig_1">3</ref> both result in NULLpointer dereference and crashes. However, they have different error propagation processes. In the MySQL example, the NULL pointer is a shared variable, and the NULL pointer dereference is a direct result of the buggy interleaving. However, in the Mozilla bug, the NULL-assignment (S2) and NULL-dereference (S3) both occur in one thread as a result of an unexpected {id,key1} pair caused by the buggy interleaving. Our principle is to categorize based on the direct impact of interleavings. Therefore, Figure <ref type="figure">7</ref> is considered a concurrency-semantic error. S2: p = hash_get_property(id, key1); hash-table retrieval hash_lookup returns an 'id' for future hash_get_property returns NULL with invalid id-key pair. key1 = key2 when the bug manifest id, key1, key2, p are all local; the hash table is shared</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 7: A complicated concurrency bug with intermediate semantic error (simplified from a real Mozilla bug). The buggy interleaving causes an (unexpectedly) invalid {id,key1} pair, which causes hash get property to return NULL.</head><p>Caveats We attempted to the best of our ability to use representative bugs and correctly classify them. We do not intend to draw general conclusion for all bugs and all applications. We only plan to use those trends that are consistent throughout our bug set to guide effect-oriented concurrency bug detection. We warn readers to interpret the following characteristics with the methodology in mind. Since this study focuses on C/C++ programs, the cause-effect characteristics may not apply to other types of programs, e.g., Java programs. Of course, since many multi-threaded programs, especially client/server programs, are still written in C/C++, we believe our study is representative of a large class of important applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Results and Implications</head><p>Many interesting results are revealed in this study. Due to the space limit, we only emphasize several findings that are closely related to the design of effect-oriented concurrency bug detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Categories Description</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Con-Memory Errors* Wrong execution order among shared memory operations directly transit to memory bugs Buffer Overflow</head><p>Conflicting accesses to shared buffer and shared buffer index/boundary variables cause buffer overflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dangling Pointer</head><p>Interleaving causes one thread to deallocate a shared buffer before another thread accesses it (Figure <ref type="figure">9</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>NULL Pointer</head><p>Interleaving causes one thread to dereference a shared pointer assigned NULL by another thread (Figure <ref type="figure" target="#fig_1">3</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Uninitialized Read</head><p>Interleaving pushes a shared memory read to occur before the intended initialization from a remote thread (Figure <ref type="figure" target="#fig_7">8</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Con-Semantic Errors</head><p>Interleaving causes unexpected variable values and program states.  <ref type="table" target="#tab_7">3</ref>. This indicates that crash concurrency bugs are not only severe, but also common among those reported-and-fixed bugs. Detecting them is crucial.</p><p>Finding 2 There is no correlation between the cause and the effect of a concurrency bug in our study. A breakdown between the types of interleaving patterns (causes) and the types of failures (effects) is presented in Table <ref type="table" target="#tab_0">1</ref>. As discussed in Section 1, it is difficult to predict the final effect or severity of a concurrency bug based on its root cause interleaving pattern.</p><p>Crash Hang Minor Func. Issues Con-Memory err. 31 0 3 Con-Semantic err. 6 7 23</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 4: Types of failures vs. types of intermediate errors</head><p>Finding 3 Approximately 84% (31 out of 37) of the studied concurrency bugs that cause crashes have concurrency-memory error patterns, as shown in Table <ref type="table">4</ref>. The few exceptions are similar with the Mozilla bug shown in Figure <ref type="figure">7</ref>. This finding provides a promising implication: by focusing on the concurrency-memory error pattern, we can handle most severe concurrency bugs that can cause program crashes (at least in C/C++ programs).</p><p>Finding 4 Approximately 90% (31 out of 34) of the intermediate memory errors in our bug set cause program crashes at the end, as shown in Table <ref type="table">4</ref>. This finding is consistent with the trend in sequential programs <ref type="bibr" target="#b50">[51]</ref>. It further demonstrates that by targeting concurrency-memory errors, we can effectively focus the bug detection and testing effort upon severe concurrency bugs, without wasting resources on benign or non-critical interleaving problems.   <ref type="table" target="#tab_9">5</ref>, all the concurrency-memory errors in our study fall into four well-defined categories: NULL-pointer dereference, dangling-pointer, buffer-overflow and uninitialized-read. For simplicity, we will refer to these four sub-types of concurrency-memory errors as follows: Con-NULL (NULL pointer dereference directly caused by buggy interleavings), Con-UnInit (uninitialized read directly caused by buggy interleavings), Con-Dangling (dangling pointer directly caused by buggy interleavings), and Con-Overflow (buffer overflow directly caused by buggy interleavings).</p><p>These regular bug patterns provide clear guidance to our concurrency bug detection; by focusing on these four types of bugs, the bug detection will have small false positives and small false negatives regarding concurrency bugs with crash-effects. This is precisely the guidance utilized for ConMem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Detecting Severe Concurrency Bugs</head><p>The ConMem design is guided by the above characteristics study. It includes four dynamic bug detection modules that are responsible for detecting Con-NULL, Con-UnInit, Con-Dangling, and Con-Overflow bugs, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Overview</head><p>The design of ConMem follows three principles:</p><p>(1) Effect-oriented, instead of interleaving-oriented. ConMem tries not to analyze an interleaving pattern unless it is related to concurrency-memory errors. In the mean-time, ConMem does not limit itself to any specific interleaving pattern.</p><p>(2) Predictive bug detection. ConMem bug detection is not limited to the monitored interleaving. Instead, it targets reporting concurrency bugs that could occur under future interleavings. This property is critical due to concurrent programs' non-determinism.</p><p>(3) Balanced analysis accuracy and complexity. Since validator ConMem-v can help prune out false positives, ConMem has some luxury of trading accuracy for simplicity, when necessary.</p><p>Following these principles, ConMem dynamically detects concurrencymemory errors in two steps.</p><p>First, detecting the basic ingredients of concurrency-memory errors, which are mostly insensitive to interleavings. A concurrencymemory error's basic ingredients are its memory operations, such as a pointer dereference, a NULL assignment, a buffer deallocation, etc. Their existence is necessary to a concurrency-memory error and is (fortunately) usually insensitive to interleavings. They will be detected by the memory checking part of ConMem.</p><p>Second, checking the timing condition among the basic ingredients. The appropriate timing, such as de-allocating a memory object before another thread accesses it, turns a set of memory operations into a true bug. Whether a timing condition can be satisfied in future interleavings depends on the synchronizations in the program. The synchronization analysis part of ConMem is responsible for making this decision and reporting bugs.</p><p>A summary of the ingredient-and-timing conditions for each sub-type of concurrency-memory errors is shown in Table <ref type="table" target="#tab_10">6</ref>. The following sub-sections will elaborate on how to detect each subtype of concurrency-memory errors, one by one. In general, the basic ingredients of Con-NULL bugs include two pointer-accesses, denoted as wp and rp. wp writes NULL to a shared pointer-variable ptr, and rp reads ptr from a different thread that later conducts pointer dereference. We consider each {wp,rp} pair to be a bug suspect.</p><p>The timing condition of Con-NULL is to execute wp before rp with no other write to ptr in between. A suspect is reported as a Con-NULL bug only if the timing condition can be satisfied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Con-NULL detection algorithm</head><p>Detecting the basic ingredients Detecting the {wp, rp} pair for Con-NULL is straightforward using binary instrumentation. Specifically, for every heap/global access<ref type="foot" target="#foot_1">2</ref> , ConMem collects its thread-id, program counter, memory location, and store-value information at run time. Analyzing this information can easily reveal Con-NULL suspects. The only issue remaining is to differentiate memory locations that hold pointers from those that hold normal integer or Boolean variables. This matter will be discussed later.</p><p>Checking the timing condition After a Con-NULL error suspect (i.e., a {wp,rp} pair) is discovered, the next step is to check whether the synchronization operations in the program allow wp to execute before rp without other interfering definition in between.</p><p>Without losing generality, ConMem separately considers mutual exclusion synchronization and order synchronization. If the above timing condition is not prohibited by either of them, the corresponding suspect will be reported as a Con-NULL bug.</p><p>Order synchronization operations <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b33">34]</ref>, such as barriers, set up a happens-before partial order among all accesses in the concurrent execution. Under this happens-before order, two accesses are either strictly ordered or concurrent with one another.</p><p>Order synchronization could make a Con-NULL timing condition infeasible if and only if one of these two conditions are satisfied: <ref type="bibr" target="#b0">(1)</ref> The NULL-assignment is strictly ordered after the pointerread; or (2) Another write to the pointer is strictly ordered between the NULL-assignment and the read. The 'order' here is determined by the happens-before relationship.</p><p>Mutual exclusion, such as locks and transactions, prevents certain code regions, e.g., those protected by the same lock or covered in transactions, from interfering with one another.</p><p>Mutual exclusion could protect the {wp,rp} pair and prevent a Con-NULL error in two ways: <ref type="bibr" target="#b0">(1)</ref> rp and an earlier write to ptr from the same thread are atomic from wp; or (2) wp and a later write to ptr from the same thread are atomic from rp. In the former case, rp always uses definition from its own thread, instead of wp. In the latter case, wp's assignments are always overwritten before reaching rp.</p><p>ConMem monitors mutual exclusion and order synchronizations at run time. By checking against the above conditions, Con-Mem can identify Con-NULL suspects that are well protected and report the remaining suspects as Con-NULL bugs.</p><p>Of course, our synchronization analysis is neither sound nor complete, mainly because it does not consider potential control flow changes under future interleavings. We believe it provides a good balance between analysis complexity and the analysis accuracy, as shown by our experimental results in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Implementation</head><p>ConMem implements the above algorithm using run-time recording (with PIN <ref type="bibr" target="#b24">[25]</ref> binary instrumentation) and off-line trace analysis. We choose trace analysis over pure run-time detection due to the algorithm complexity.</p><p>The run-time logs three types of information. The first is the information of a global or heap memory access, which is used to identify basic ingredients (i.e., {wp, rp}). The second part is the synchronization operations, including barrier, pthread mutex (un)lock, pthread create/join, etc. This part is used to check suspects' timing conditions. The last part is the information of all malloc/free operations. Since virtual addresses could be recycled through malloc/free, this part of information helps us to identify which memory locations are truly holding the same memory object. This recycling issue is similarly handled in the three remaining detection modules.</p><p>Con-NULL only needs to record and analyze memory accesses to pointer variables. Our current implementation differentiates pointer accesses from non-pointer accesses based on the read/write values. That is, we ignore memory accesses when the involved values are clearly out of the range of stack, heap, global data region, or 0. This scheme works well in practice. It can be further improved by static analysis.</p><p>The trace-analysis includes three major steps: The first step is straightforward. By checking the memoryaddress, thread-id and store-value information in the trace, we can easily find all Con-NULL suspects.</p><p>The second step is to analyze mutual exclusion synchronization. Following our earlier discussion, for every suspect {wp, rp} pair, ConMem identifies the preceding write of rp (refer to as rp-p) and the follow-up write of wp (refer to as wp-f ) from the trace. It then calculates the lock-sets that protect rp, {rp-p,rp}, wp, and {wp,wpf }. Any lock-set overlap between {rp-p,rp} and wp or overlap between {wp,wpf } and rp indicates that this suspect is well protected and should not be reported as a bug.</p><p>The last step is to determine whether order synchronization can protect a {wp, rp} pair from NULL-pointer dereference. The straightforward solution here is to calculate the vector timestamps for all memory accesses involved in the NULL-Con suspects and to compare their timestamps, according to the condition discussed above. The timestamp calculation is not difficult, because the trace includes information for every order synchronization executed at run-time, including pthread mutex create/join and barrier. Using this information, we can easily calculate vector timestamps based on the Lamport logical-timestamp algorithm <ref type="bibr" target="#b19">[20]</ref>.</p><p>The time-consuming part of the above analysis is that for a {wp, rp} pair that accesses memory location ptr, we must find every memory access to ptr and check whether it is strictly ordered between wp and rp. The complexity is linear to the number of dynamic write instances to ptr. Our implementation uses a heuristic to simplify the complexity to constant time: If there exists such a ptr-definition that is strictly ordered between wp and rp, it usually comes from either the same thread as wp or the same thread as rp. Under this heuristic, we only need to check two candidates that might sit between rp and wp: the write to ptr on rp's thread right before rp and the write to ptr on wp's thread right after wp. This heuristic works well in our experiments, never introducing false positives.</p><p>Discussions The false positives of Con-NULL detection mainly come from two sources. The first is un-identified custom synchronization, an issue shared with many previous concurrency bug detection tools <ref type="bibr" target="#b39">[40]</ref>. Without the knowledge of some customized synchronization, ConMem will mistakenly consider some timing conditions as feasible and report false positives. The second are those simplifications made by our implementation. One simplification that has not yet been mentioned is that we do not check whether a pointer read is used for dereference. Sometimes, a pointer read is used for condition-checking, where reading a NULL-valued pointer does not cause any problem. We prune out this type of false positive by checking whether a pointer read has a NULL value during the monitored run. If it does, we do not report the bug. This pruning has been very effective, as we will see in Section 7.</p><p>In terms of false negatives, in general, the bug detection of Con-Mem is sensitive to code/path coverage and insensitive to the timing (i.e., interleavings) among a set of code statements. Specifically, with a given test input, if an instruction is executed only under certain rare interleavings, or if two instructions access the same memory location only under certain rare interleavings, ConMem may not be able to catch all basic ingredients of potential Con-NULL bugs, thus resulting in false negatives. This type of false negative is general to all ConMem detection. Fortunately, it rarely occurs based on our experience. In addition, this problem can be mitigated by making ConMem observe more than one runs of the program under the same input. It can also benefit from work that focuses on code coverage in concurrent programs <ref type="bibr" target="#b42">[43]</ref>.</p><p>Finally, trace size is a potential concern for all trace-based analysis tools. Since Con-NULL only records heap/global memory accesses that touch (likely) pointer variables, its traces will be significantly smaller than those generated by deterministic replay tools <ref type="bibr" target="#b34">[35]</ref>. Based on our experience, it is rarely a problem for Con-NULL, as shown in Section 7. Future work can also split the trace of a long-running program into several sub-traces and extend Con-NULL algorithm to process sub-traces.  Con-UnInit bugs are un-initialized memory reads directly caused by buggy interleavings. An example of Con-UnInit bugs is shown in Figure <ref type="figure" target="#fig_7">8</ref>. In this example, a shared variable h→ bandwidth is initialized on S1 in thread 1. Read accesses to this variable are supposed to occur after S1. Unfortunately, without proper synchronization, S2 in thread 2 can execute before S1 and read an uninitialized variable, which causes an assertion failure later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Con-UnInit</head><p>Con-UnInits' basic ingredients typically include a read access, denoted as r (e.g., the S2 in Figure <ref type="figure" target="#fig_7">8</ref>), to a memory location that depends on other threads to initialize. The timing condition for a Con-UnInit is to execute r before the initializations from other threads.</p><p>Note that, when we observe an r reading a value defined by its own thread, un-initialized read is unlikely to happen under a different interleaving. However, there could be exceptions. For example, future interleavings could change the execution path and make the local definition disappear. This goes beyond our definition of concurrency-memory errors and is not considered here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Detection algorithm &amp; implementation</head><p>Con-UnInit's detection algorithm is simpler than Con-NULL's and is implemented as run-time detection without trace analysis.</p><p>Detecting the basic ingredients This task identifies sharedmemory read, the target memory location of which is not defined earlier in its own thread, but in other threads. These reads will be considered as Con-UnInit suspects.</p><p>This task is quite straight-forward to implement in dynamic monitoring. Relying on the PIN instrumentation framework, we use a hash-table Initializer to maintain the per-thread information about which memory locations are already initialized in this thread. Specifically, Initializer is indexed by memory locations. Whenever a write to memory location v occurs, Initializer is checked to determine whether this is the first write to v from that thread. If it is, the information of this write is inserted into the table. Looking up Initializer at every read accesses to heap variables will reveal all Con-UnInit suspects.</p><p>Checking the timing condition At run-time, whenever a read suspect r is discovered, ConMem must conduct a synchronization analysis and decide whether there exists a remote initialization that is strictly ordered before r. Mutual exclusion cannot help avoid this type of bugs and is not considered here.</p><p>Conducting this task at run-time requires several pieces of information. Suppose the suspect r accesses memory location v. The first piece of information we need is the vector timestamp of r. ConMem maintains the vector timestamp for each thread at run-time, by intercepting order synchronizations (i.e., barrier and pthread create/join) and analyzing them based on the classic Lamport algorithm <ref type="bibr" target="#b19">[20]</ref>. The timestamp of r can be easily retrieved from the current timestamp of its own thread.</p><p>The second piece of information is the vector timestamp of all the initializations to v from other threads. This information is kept in the Initializer table we mentioned above. Specifically, when a write access is found to be the first write to v from thread t, t's current timestamp is inserted into Initializer.</p><p>Finally, after obtaining the above information, ConMem compares the timestamp of r with the timestamps of remote initializers. A Con-UnInit bug is reported when r is concurrent with all the recorded initialization timestamps.</p><p>As an optimization, we only conduct the above check for the first read from each thread to a memory location v. This is sufficient to detect Con-UnInit bugs on v, if they exist.</p><p>Discussions The sources of false negatives and false positives for Con-UnInit detection are similar to those of Con-NULL, except for one unique source of false positives. That is, some uninitialized reads may not cause negative effects, a property different from NULL-pointer dereference, dangling pointer and bufferoverflow. Previous sequential bug detectors, such as Valgrind <ref type="bibr" target="#b29">[30]</ref>, have considered this and choose to report bugs only when the uninitialized value is used for critical operations, including system calls, condition checking, and memory address calculation. Con-Mem can borrow this idea to prune this set of false positives.</p><p>Different from Con-NULL, Con-UnInit does not dump traces and does not have the trace size issue. However, since Con-UnInit conducts all the analysis on-line, its run-time analysis will consume more memory than Con-NULL. The memory consumption of Con-UnInit is mainly for storing the initialization timestamp for each active heap/global memory location. It is linear to the heap/global memory footprint of a program, like many previous dynamic bug detectors <ref type="bibr" target="#b22">[23]</ref>. It will not increase with longer execution, as long as the program's active memory consumption does not change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Con-Dangling Detection</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">What is a Con-Dangling bug?</head><p>Thread 2 Thread 1 (decompression thread) (main thread)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S1 delete q;</head><p>q is a pointer local to thread 1; while (!fifo-&gt;empty) { S2 ... that contains fifo-&gt;empty It points to the memory region Figure <ref type="figure">9:</ref> A concurrency bug that leads to dangling pointer and finally causes crash (from PBZIP2-0.9.4) Con-Dangling occurs when buggy interleavings directly cause dangling pointer accesses. Figure <ref type="figure">9</ref> demonstrates a bug from PBZIP2. In this example, pointer q (a local variable in thread 1) points to a heap object shared by thread 1 and thread 2 (fifo in thread 2 points to the same object). Due to lack of synchronization, thread 2 can access the shared object at S2 when it is already deleted by thread 1 at S1, which can cause PBZIP2 to crash.</p><p>As we can see, the basic ingredients of a Con-Dangling bug is a memory access whose target memory location is de-allocated by a different thread. The timing condition of Con-Dangling is to conduct the memory access after the de-allocation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">Detection algorithm &amp; implementation</head><p>Similar to Con-UnInit detection, Con-Dangling is implemented upon PIN as a pure run-time bug detector with no trace analysis.</p><p>The algorithms of detecting basic ingredients and checking timing conditions are straightforward here. For the first task, we must identify all memory accesses whose target memory locations are de-allocated by a different thread. For the second task, we must analyze order synchronizations to determine whether the accesses are concurrent with the de-allocation operation. Just like that in Con-UnInit, mutual exclusion itself cannot avoid Con-Dangling bugs and is not considered in the following.</p><p>In our PIN-based implementation, every malloc and free invocation is intercepted, in addition to every order synchronization and heap accesses. A map Malloc Map is used to maintain a list of currently active heap memory regions, ordered by their starting addresses. A new entry is inserted to Malloc Map at every malloc. At every heap access, ConMem looks up Malloc Map with the accessed heap address to find the corresponding entry, and then updates the entry to record the latest access from each thread to each memory region. Whenever a free is invoked, the timestamp of this free will be compared with the timestamps of the latest accesses to this to-be de-allocated memory region from each thread. A Con-Dangling bug is reported when we find a concurrent (based on timestamps) access from a different thread.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Con-Overflow Detection</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.1">What is a Con-Overflow bug?</head><p>Buffer overflow occurs when a buffer-access goes beyond the buffer-boundary. In concurrent programs, interleavings can cause additional buffer-overflow problems when buffer-index or bufferboundary variables are shared among different threads. Figure <ref type="figure" target="#fig_8">10</ref> shows an example of typical Con-Overflow bugs. Thread 1 conducts sanity check at S1 on buffer index variable buf→cnt to ensure that the later memcpy will not overflow the buffer buf. Unfortunately, the index variable is shared with thread 2. Due to lack of synchronization, thread 2 can change the buffer index between the sanity check and the real buffer access, thus causing a buffer overflow.</p><p>Accurately reporting Con-Overflow bugs is difficult because exposing buffer-overflow bugs requires not only certain order of memory operations but also certain variable values. Even when an index variable is unexpectedly corrupted by a different thread, buffer overflow may not occur, depending on the new value stored into the index. In the future, symbolic execution and constraint solver techniques <ref type="bibr" target="#b4">[5]</ref> can potentially address this value issue.</p><p>In our current prototype, we only consider a common sub-set of Con-Overflow bugs: conflicting accesses to shared buffer index variables cause buffer overflows. Specifically, we report all data races among instructions that access shared buffer index variables as potential Overflow-Con bugs, and we rely on our ConMemvalidator (Section 5) to prune out false positives. We leave the more general Con-overflow detection problem to future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.2">Detection algorithm &amp; implementation</head><p>Con-Overflow detection includes two steps. The first step detects data races in the execution. The second step attempts to identify accesses to buffer-index-variables among those data races. The first step is conducted through an existing lock-set algorithm <ref type="bibr" target="#b39">[40]</ref>. The second step can be conducted in different ways. Our solution is based on the heuristic that an index variable should be used to generate buffer-access addresses sooner or later. Currently, we implement this step as an additional run of dynamic data dependence analysis. That is, after we receive the information of data races, the program is executed a second time. Whenever a memory location involved in races is read, the dependence analysis starts, tracking the data flow to determine whether the read value would be used to generate a global/heap address within a threshold number of steps. In addition, we also make sure the read value itself is not already a global/heap address. Full dependence-analysis has large overhead. Fortunately, we only need to track those accesses and memory locations related to races. Therefore, the overhead is acceptable. We expect that this second step is not always necessary. After one variable or one instruction is marked as accessing (or not accessing) a buffer index, this information can be kept for future usage. Static analysis can also help us and enable ConMem to report Con-Overflow bug candidates at run-time.</p><p>In summary, ConMem bug detection includes four sub-tools. Con-UnInit and Con-Dangling bugs are detected and reported at run-time. Con-NULLs and Con-Overflow bugs are reported at postmortem analysis. It is also conceivable to combine all these four modules into one big run-time bug detection tool in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Bug Exposing and Validation</head><p>The design of ConMem-v is inspired by previous tools that validate data race <ref type="bibr" target="#b32">[33]</ref> and atomicity violation bug reports <ref type="bibr" target="#b33">[34]</ref>. ConMem-v takes every bug reports from ConMem as inputs. It tries to enforce those buggy interleavings predicted in ConMem's bug reports by carefully perturbing the concurrent execution. The whole process is automated.</p><p>ConMem-v will serve two purposes. The first is to prune Con-Mem's false positives that are caused by customized synchronization and some approximation made by ConMem detection algorithm. The second is to provide developers with a reliable way to repeat the true bugs reported by ConMem.</p><p>In the following, we will discuss the design and implementation of ConMem-v, explaining what is the interleaving enforcement target and how to enforce a specific timing condition. ConMemv is implemented using PIN <ref type="bibr" target="#b24">[25]</ref> binary instrumentation. Due to the space limit, some implementation details are omitted. Validating Con-NULL bug reports Provided with a {wp,rp} pair of Con-NULL bug report, ConMem-v's target is to execute wp before rp, with minimized timing distance in between.</p><p>In order to enforce such a timing condition, ConMem-v instruments the binary code right before and after wp and rp. At run-time, whenever wp or rp is going to be executed, ConMemv checks whether the other instruction has already 'arrived'. If so, wp will be arranged to execute first, immediately followed by rp.</p><p>If not, an artificial delay (several iterations of usleep()) is added into this thread, waiting for the other instruction to arrive from a different thread. This process is demonstrated in Figure <ref type="figure" target="#fig_10">11</ref>   Note that, as a general principle in ConMem-v, ConMem-v only improves the chances of a bug to occur and does not provide any guarantee. All the delay inserted by ConMem-v has time-out, so that the program will not hang.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Validating Con-UnInit bug reports</head><p>The input to Con-UnInit validation is a list of instruction pairs {w,r} from the Con-UnInit bug report. w is an instruction that initializes a memory location that is later read by r from a different thread.</p><p>ConMem-v's target here is to execute w after r. To achieve this target, ConMem-v instruments the binary code to postpone the execution of w in order to wait for r to execute first (consider r as A and w as B in Figure <ref type="figure" target="#fig_10">11</ref>). ConMem-v can keep track of all heap/global writes to know whether an uninitialized read has truly occurred. In practice, just observing whether r is executed before w pretty much already tells users whether the Con-UnInit bug report is a true bug.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Validating Con-Dang bug reports</head><p>The input to ConMem-v here is a list of instruction pairs {F,a}. F is a call instruction that invokes the de-allocation to a memory region that contains the memory location accessed by a from a different thread.</p><p>ConMem-v's target here is to postpone the execution of a in order for the F to occur first, which is conducted as Figure <ref type="figure" target="#fig_10">11</ref> (F is A, a is B). In order to know whether a dangling pointer has truly occurred, ConMem-v records and compares the memory address accessed by a and the range of the memory region freed by F.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Validating Con-Overflow bug reports</head><p>The input here is a list of data race pairs {i1,i2}. i1 and i2 race upon a shared buffer index variable. The target of ConMem-v is to make the race truly occur (i.e., first execute i1 right before i2 without any other instruction in the middle and then i2 right before i1) and observe what happens after the race.</p><p>ConMem-v's perturbation strategy for Con-Overflow bugs is similar with those for the above three. The unique complexity of Con-Overflows is that even if a buffer index is corrupted to a wrong value through data races, overflow may not happen. In our current validator, we look for fail-stop symptoms (crash or assertion failure) to tell whether buffer overflow has happened, which can be improved by more accurate buffer-overflow detection designed for sequential programs <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b29">30]</ref>. Discussions Two types of interleaving enforcement approaches were proposed before. One is to execute programs on single-core machines and control the scheduling <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b41">42]</ref>; the other is to insert artificial delays <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b33">34]</ref>. ConMem-v chooses the latter one for better performance.</p><p>In summary, ConMem-v will not report any false positives. In addition, benefiting from the clear error pattern of memory bugs, ConMem-v does not need manually written oracles to judge whether a bug has occurred. However, ConMem-v could have false negatives. Some timing conditions require sophisticated interleaving manipulation and may be missed by ConMem-v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Methodology</head><p>Applications ConMem is evaluated using 7 widely-used C/C++ applications, including 3 server (Apache HTTP server, MySQL data base server, and Cherokee HTTP server), 3 desktop (Mozilla web browser, PBZIP2 parallel decompressor, and Transmission bittorrent client) and 1 scientific application (FFT) from SPLASH2 <ref type="bibr" target="#b46">[47]</ref>. Except for FFT, all of them contain real concurrency bugs that can cause crashes.</p><p>Bugs in evaluation We use 9 concurrency bugs 3 that can cause client and server crash for evaluation. These 9 bugs are all real bugs introduced by the original developers. We carefully set up this bug set to make sure it is representative, covering different types of faults and error propagation patterns, as shown in Table <ref type="table" target="#tab_12">7</ref>. FFT contains a non-severe concurrency bug introduced by external library developers. We add it into our bug set to measure the false positive rate and overhead of ConMem on scientific applications.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bug-ID</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment setup</head><p>The experiments are conducted on dual quad-core Intel Xeon (2.67GHz) machines, with Linux, version 2.6.18. We use the PIN <ref type="bibr" target="#b24">[25]</ref> binary instrumentation framework for all our tools. We use Valgrind-Helgrind <ref type="bibr" target="#b29">[30]</ref> as the race detection front-end for Con-Overflow.</p><p>Our experiments use bug-triggering inputs reported by the user, like previous dynamic concurrency bug detectors <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b47">48]</ref>. Note that the bugs never manifest during our bug detection runs. Actually, many concurrency bugs do not manifest even after days' execution with bug triggering inputs <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b33">34]</ref>, which is exactly why ConMem's predictive detection will be useful.</p><p>Our evaluation executes each bug-triggering input (or a set of bug-triggering client requests) to the end in order to measure the false positives and the performance. The reported performance number is the average across multiple runs.</p><p>ConMem includes four sub-tools for four types of concurrencymemory errors. Each application will be executed with the bugtriggering input once for each sub-tool. We present the bug detection results of each sub-tool. When ConMem is compared with other detection tools, the true bugs as well as the false positives from all the four sub-tools are put together. The artificial delay used by ConMem-v is 1 milli-second at a time.</p><p>We also compare ConMem with two state-of-the-art interleaving checking approaches: race-based (short for Race) and atomicity-violation-based (short for Atom). Race is a lock-sethappens-before hybrid race detector, originally implemented in widely-used Valgrind-Helgrind detector <ref type="bibr" target="#b29">[30]</ref> and slightly modified by us for better race coverage. Atom is implemented by us based on an algorithm described in previous work <ref type="bibr" target="#b33">[34]</ref>. It predicatively identifies each static memory instruction that can be unserializably interleaved with its preceding access to the same memory location from the same thread (the most common type of atomicity bugs <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b45">46]</ref>). There are other race and atomicity bug detectors, such as happens-before race detectors <ref type="bibr" target="#b30">[31]</ref> and training-based atomicity detectors <ref type="bibr" target="#b22">[23]</ref>. We did not choose them, because their training requirement or interleaving-sensitive design will make the comparison apples to oranges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Experimental Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Overall Results</head><p>Overall, as shown in Table <ref type="table" target="#tab_13">8</ref>, ConMem can detect 9 out of 10 tested concurrency bugs, showing a good coverage on this set of severe concurrency bugs. In comparison, Race and Atom detect 4 and 6 out of the 10 bugs, respectively. ConMem shows a good bug detection capability on these evaluated bugs, because it effectively captures the most common error propagation pattern among concurrency bugs with crash-effects. Specifically, three bugs (MySQL-1, MySQL-2, and PBZIP2) are detected by Con-NULL; Apache-1 and PBIP2-2 are detected by Con-Dangling; Apache-2 and Cherokee are detected by Con-Overflow; Transmission and FFT are detected by Con-UnInit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bug-ID</head><formula xml:id="formula_0">ConMem Race Atom MySQL-1 Y Y Y MySQL-2 Y N Y PBZIP2 Y Y Y Apache-1 Y N N Mozilla N N N PBZIP2-2 Y N N Apache-2 Y Y Y Cherokee Y Y Y Transmission Y N N FFT Y N Y</formula><p>ConMem still misses one severe bug in Mozilla. The reason is that the buggy interleaving in Mozilla first causes semantic errors before it finally corrupts memory states and crashes Mozilla. This type of concurrency-semantic error pattern is not captured by Con-Mem. Because of the complexity of this bug, Race and Atom also failed to correctly detect this bug.</p><p>Atom and Race failed to detect 3 and 4 severe concurrency bugs that can be detected by ConMem, mainly because these bugs are not caused by data races or simple atomicity violation. For example, Apache-1 is caused by conflicting accesses to multiple variables. Therefore, it is not detected by either Race or Atom. PBZIP2-2 and Transmission are both caused by order violation problems and are missed by Atom. In addition, the heuristics used in the Valgrind-Helgrind algorithm to prune false positives also lead to some false negatives in Race.</p><p>Overall, ConMem has a good coverage on the evaluated realworld concurrency bugs that can cause crashes, not limited to any specific interleaving patterns. It can well complement existing race and atomicity-violation bug detection tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">False Positive Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Before automated pruning</head><p>Table <ref type="table" target="#tab_14">9</ref> shows the numbers of false positives (vs. true bugs) of all the tools on the 7 evaluated applications. Every report of Race is a pair of static race instructions; every report of Atom is a static instruction that can be unserializably interleaved with its preceding access; every report of ConMem is a static instruction that, under certain interleaving, can dereference NULL-pointer, access freed memory regions, etc. Since some bug reports in Table <ref type="table" target="#tab_14">9</ref> share the same root cause, the total number of true bug reports there is larger than that in Table <ref type="table" target="#tab_13">8</ref>.</p><p>In general, ConMem' false positive rate is much lower (about one tenth) than Race and Atom, benefiting from its effect-oriented approach. ConMem's false positive rate (about 2.5 false positives per true bug) is reasonably low considering ConMem' predictive detection capability on severe concurrency bugs.</p><p>All these tools, including Race and Atom, have done a good job in identifying bug-prone interleavings from the huge interleaving space. As we can see in  ConMem has much smaller false positive rates than Race and Atom, mainly because of its effect-oriented approach (i.e., taking vertical stripes in the interleaving space of Figure <ref type="figure" target="#fig_0">1</ref>). As discussed in Section 1, races and unserializable interleavings do not always end up as bugs. Although the algorithms in Race and Atom already use good heuristics to prune false positives, the false positive problem is still there.</p><p>Table <ref type="table" target="#tab_0">10</ref> provides a further breakdown for the false positives of ConMem. As we can see, 51 of these 53 false positives are caused by un-identified custom synchronizations. These 51 bug reports involve infeasible interleavings and can never occur. ConMem mistakenly reported these 51 bugs because it did not consider while/ifflags and producer-consumer queue synchronizations in the program. The remaining 2 false positives come from harmless uninitialized read, as discussed in Section 4.3.</p><p>Note that, according to Table <ref type="table" target="#tab_0">10</ref>, almost all buggy interleavings reported by ConMem are true and severe bugs, as long as they are feasible. This is a big accuracy improvement over data race detection tools, where only about 2-10% feasible data races are true bugs <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b27">28]</ref>.  <ref type="table" target="#tab_13">8</ref> and<ref type="table" target="#tab_12">Table 7</ref>.</p><p>Specifically, among the 20 true bug reports from ConMem, ConMem-v successfully makes 15 bug reports manifest through its systematic perturbation. Each of these 15 can be reliably (almost deterministically) exposed under ConMem-v, which will help developers' bug diagnose and fixing. There are still 5 bug reports that are actually true bugs. However, the manifestation condition is complicated, requiring artificial delays at multiple places, and is not handled by our current prototype of ConMem-v. Note that some bug reports in Table <ref type="table" target="#tab_14">9</ref> have one common root cause and are grouped into one bug in Table <ref type="table" target="#tab_12">7</ref> and<ref type="table" target="#tab_13">8</ref>. Because of this, failing to expose these 5 bug reports did not cause ConMem-v to miss any root bug there.</p><p>The ConMem-v validation phase is fast, because of the small number of ConMem bug reports. For example, validating the 17 bug reports of PBZIP2 only takes 20.02 seconds, roughly equal to executing PBZIP2 without any instrumentation for 30 times.</p><p>Discussion One interesting question that the above evaluation does not directly answer is how false positives would change under longer execution with more inputs or more runs of one input.</p><p>As discussed in Section 4.2, the bug detection of ConMem is sensitive to the code/path coverage, like all dynamic bug detectors <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b39">40]</ref>, and is mostly insensitive to the timing among certain code. Therefore, we expect ConMem to report more true bugs and more false positives when it observes more program runs that touch previously unobserved code/path.</p><p>We also expect ConMem's false positive rate to remain low for most applications and most inputs, because of its effect-oriented design philosophy. For example, if a program conducts few NULLpointer assignments, there will be few bug reports, no matter how long the execution is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Time and Space Overhead</head><p>Table <ref type="table" target="#tab_17">11</ref> shows the run-time overhead of ConMem tools. Overall, ConMem tools have reasonable run-time overhead: around 16X slow down for memory intensive FFT and 3-29% latency overhead for I/O intensive server applications. This overhead is comparable to previous concurrency bug detection tools <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b47">48]</ref> and is suitable for developers' use.</p><p>Table <ref type="table" target="#tab_17">11</ref> excludes the trace-analysis time of Con-NULL, which takes less than 10% of the base-line execution time in our experiments. Con-Overflow's major overhead comes from Valgrind-Helgrind race detector. The overhead of its dependence-analysis ranges from 5% overhead (server applications) to 13X slow down (for FFT).</p><p>Currently, Con-NULL, Con-UnInit, Con-Dangling, and Con-Overflow are implemented as separate tools. Since many tasks conducted by them overlap with each other, we expect the overhead of the combined tool to be smaller than running each of them one by one.  In terms of space overhead, Con-NULL is the only tool in Con-Mem that generates traces. In our experiments, the traces are reasonably small under the bug triggering inputs, ranging from 50KB to 30 MB. The fact that Con-NULL only analyzes memory accesses to pointer variables greatly mitigates the trace size problem that is encountered by all trace-based analysis tools. With the disk size keeps increasing, we believe the trace size will not be an issue for the usage of Con-NULL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bug-ID</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Synchronization Analysis in ConMem</head><p>When detecting Con-NULL, Con-UnInit, and Con-Dangling bugs, ConMem conducts synchronization analysis to check whether the timing condition of bug suspects can be satisfied in the future or not. ConMem prunes out those suspects that are well protected by mutual exclusion or order synchronizations. Table <ref type="table" target="#tab_18">12</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Related Work</head><p>Many related works are discussed in earlier sections. Here, we only discuss a few that are closely related and not discussed yet.</p><p>Concurrent programs' empirical study Due to the lack of concurrency bug sources, only a few studies <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b21">22]</ref> have been done, and they mostly focus on the interleaving patterns of concurrency bugs. Most recently, interesting studies are also conducted to evaluate how new synchronization primitives (such as Transactional Memory) can be used to write concurrent programs <ref type="bibr" target="#b36">[37]</ref>. Our paper complements previous studies by looking at concurrency bugs' error propagation process.</p><p>Concurrency bug detection, testing and avoidance Existing concurrency bug detection tools can be categorized into race detection <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b49">50]</ref>, atomicity violation detection <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b47">48]</ref> and deadlock detection <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b20">21]</ref>. ConMem complements existing tools by focusing on the crash effect, instead of specific interleaving pattern. The predictive interleaving analysis in ConMem is inspired by previous predictive race and atomicity violation detectors <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b39">40]</ref>. Many innovative approaches, such as training <ref type="bibr" target="#b22">[23]</ref> and interleaving testing <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b41">42]</ref>, have been proposed to address the false positive problem in concurrency bug detection. ConMem uses similar synchronization analysis and perturbation-based interleaving enforcement techniques with some of these tools <ref type="bibr" target="#b33">[34]</ref>. ConMem complements these tools by handling the problem from a different perspective. It focuses on certain effect of concurrency bugs, instead of a specific interleaving pattern.</p><p>Atom-Aid <ref type="bibr" target="#b23">[24]</ref> and PSet <ref type="bibr" target="#b48">[49]</ref> extended existing dynamic bug detectors by prohibiting certain patterns of interleavings at run time through hardware support in order to survive concurrency bugs during production runs. Software-only tools like Grace <ref type="bibr" target="#b1">[2]</ref> and Kendo <ref type="bibr" target="#b31">[32]</ref> achieve similar goals for certain types of multithreaded programs at runtime. ConMem can well complement these works by exposing concurrency bugs before they escape to the production run.</p><p>Interleaving testing <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b26">27]</ref> works on systematically exploring the interleaving space. ConMem can complement these works by providing a different perspective on splitting the interleaving space. Deterministic execution works <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b31">32]</ref> also try to solve the interleaving space challenge. They try to achieve that by limiting the number of interleavings that a program can follow.</p><p>Concurrent program analysis and model checking A lot of inspiring research has been conducted on static analysis and model checking in concurrent programs. A recent study <ref type="bibr" target="#b6">[7]</ref> inventively proposes leveraging race detection to improve data flow analysis in concurrent programs. The idea is very inspiring. However, due to pointer-alias and other issues, there are still as many as 40% of all pointer dereferences in the program that cannot be proved to be safe in their experiments. ConMem has completely different design target with these static analysis tools. ConMem does not aim to provide any guarantee. Actually, ConMem also does not aim to report all potential memory errors in concurrent programs. By focusing on the concurrency-memory error pattern, ConMem can use relatively simple algorithms to effectively detect severe concurrency bugs. In addition, as a dynamic bug detection tool, ConMem naturally has the advantage of no pointer-alias problem and can achieve better accuracy and scalability.</p><p>Model checking can also be used to validate certain properties in concurrent programs. Recently, a lot of progress has been made <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b35">36]</ref> in model checking big concurrent programs. However, the state explosion problem still exists. We expect the effect-oriented approach and the error-propagation characteristics studied in this paper to help provide heuristics to future model checking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>General software failure diagnosis</head><p>The effect-oriented approach used in ConMem shares a similar flavor with failure diagnosis tools <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b44">45]</ref>. These tools look for the root causes of observed failures through data slicing. A failure that has already occurred and been recorded is essential to these tools. Different from them, ConMem searches for unknown interleaving errors that can cause previously unobserved failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusions and Future Work</head><p>This paper proposes an effect-oriented approach to detecting severe concurrency bugs. By focusing on the concurrency-memory errorpropagation pattern revealed by our characteristics study, ConMem effectively and predicatively detects concurrency bugs with crash effects. In our evaluation with 9 real-world severe concurrency bugs, ConMem detects more bugs with significantly fewer false positives than race and atomicity violation detectors. In addition, ConMem-v prunes out all false positives and provides reliable ways to expose all the true bugs reported by ConMem.</p><p>In general, ConMem has several nice features to help developers: predictive bug detection, no training requirement, easy-tovalidate bug results, high accuracy and high coverage on crasheffect concurrency bugs. By looking at the interleaving space from a different perspective, ConMem can well complement existing concurrency bug detection tools.</p><p>In the future, ConMem can be extended in the following ways. First, we could use static analysis to improve ConMem's ability to identify pointer variables and buffer index variables. Second, we could try to identify customized synchronizations and further decrease the remaining false positives of ConMem. Finally, we can also apply the effect-oriented idea to detecting other types of severe bugs (e.g., security vulnerability, silent data corruption, etc.) in both C programs and Java programs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A conceptual two-dimension interleaving space</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: A severe real-world concurrency bug from MySQL database server. (MySQL execution usually follows the dotted line, but it crashes when its interleaving follows the solid line.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A non-critical concurrency bug that existed in Mozilla for years without any complaint. (gOffset holds browsing statistics. Throughout Mozilla, it is read only once in a statistics-printing function.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The flow and components of ConMem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>= hash_lookup (key1); if ( id != INVALID_ID ) { } S3: printf ("%s\n", *p);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>(1) Identify all {wp,rp} pairs; (2) Analyze mutual exclusion synchronization; and (3) Analyze order synchronization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>is shared; S1 is expected to</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: A concurrency bug that leads to undefined read and finally causes crash (from Transmission-1.42)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: A concurrency bug that can lead to buffer overflow and crash (from Apache-2.0.45)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(consider A as wp and B as rp).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: ConMem-v perturbation illustration</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Table 10 :</head><label>10</label><figDesc>Causes of ConMem false positivesAutomated false positive pruning of ConMem-vAll the 73 bug reports of ConMem are sent to ConMem-v for validation. As a result, ConMem-v automatically prunes out all 53 false positives, without introducing any false negative regarding the bugs shown in Table</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Types of failures vs. types of faults (Note: Since this only includes fixed bugs, the real percentages of minor failures</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell cols="3">Crash Hang Minor Func. Issues</cell></row><row><cell>Atomicity Violation</cell><cell>26</cell><cell>3</cell><cell>19</cell></row><row><cell>Order Flip</cell><cell>11</cell><cell>3</cell><cell>6</cell></row><row><cell>Other</cell><cell>0</cell><cell>1</cell><cell>1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>.</figDesc><table><row><cell>pattern interleaving Certain Causes</cell><cell>intermediate errors correct intermediate states Propagation</cell><cell>Benign Minor Issues Crashes Others Hangs Effects</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 : Categorization of intermediate errors directly caused by buggy interleavings (*:memory bugs such as double-free and memory-leak are unlikely to happen as direct effects of buggy interleavings)</head><label>2</label><figDesc></figDesc><table><row><cell></cell><cell cols="4">Crash Hang Wrong Func. Total</cell></row><row><cell>Mozilla</cell><cell>24</cell><cell>4</cell><cell>12</cell><cell>40</cell></row><row><cell>MySQL</cell><cell>5</cell><cell>0</cell><cell>10</cell><cell>15</cell></row><row><cell>Apache</cell><cell>7</cell><cell>2</cell><cell>1</cell><cell>10</cell></row><row><cell>OpenOffice</cell><cell>1</cell><cell>1</cell><cell>3</cell><cell>5</cell></row><row><cell>ALL</cell><cell>37</cell><cell>7</cell><cell>26</cell><cell>70</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 : Effects (failure types) of concurrency bugs</head><label>3</label><figDesc></figDesc><table /><note><p>Finding 1 Approximately 50% of the studied non-deadlock bugs can cause program crashes, as shown in Table</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 5 : Breakdown of intermediate errors</head><label>5</label><figDesc></figDesc><table /><note><p>Finding 5 Concurrency-memory errors include four common patterns. As we can see in Table</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 6 : The conditions for Concurrency-Memory errors. (*: order synchronization represents barrier-style synchronizations). 4.2 Con-NULL Detection 4.2.1 What is a Con-NULL bug? Con</head><label>6</label><figDesc></figDesc><table><row><cell></cell><cell cols="2">Error Conditions</cell><cell cols="2">Can synchronization avoid the error?</cell></row><row><cell></cell><cell>Basic Ingredients</cell><cell>Timing Condition</cell><cell cols="2">Order Synch.* Mutual Exclusion</cell></row><row><cell>Con-</cell><cell>(1) rp: from t1, reads pointer ptr</cell><cell>(1) wp executes before rp</cell><cell>Yes</cell><cell>Yes</cell></row><row><cell>NULL</cell><cell>(2) wp: from t2, writes NULL to ptr</cell><cell>(2) No write to ptr between rp, wp</cell><cell></cell><cell></cell></row><row><cell></cell><cell>(1) r: from t1, reads variable v</cell><cell>r executes before w</cell><cell></cell><cell></cell></row><row><cell>Con-</cell><cell>(2) w: from t1, writes v before r</cell><cell></cell><cell>Yes</cell><cell>Not by itself</cell></row><row><cell>UnInit</cell><cell>(3) w: from t2, initializes v, usually before r</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Con-</cell><cell>(1) a: from t1, accesses memory m</cell><cell>a executes after Free(M)</cell><cell>Yes</cell><cell>Not by itself</cell></row><row><cell>Dangling</cell><cell>(2) Free(M): from t2, m ∈ M</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>(1) v: a buffer-index/boundary var.</cell><cell>Data race between a1 and a2</cell><cell></cell><cell></cell></row><row><cell>Con-</cell><cell>(1) a1: from t1, accesses v</cell><cell>(this is an approximated condition)</cell><cell>Yes</cell><cell>Yes</cell></row><row><cell>Overflow</cell><cell>(2) a2: from t2, accesses v</cell><cell></cell><cell></cell><cell></cell></row></table><note><p><p><p>-NULLs are NULL-pointer dereference errors directly caused by buggy interleavings. An example of Con-NULL is shown in Figure</p>3</p>. As we can see there, S2 from thread 1 dereferences a shared pointer variable thd→ proc info, and S3 from thread 1 assigns NULL to the same variable. Under a buggy interleaving, S3 executes right between S1 and S2, immediately causing a NULLpointer dereference and a MySQL crash. Of course, the above buggy interleaving occurs only rarely, and MySQL mostly behaves correctly.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 7 : 10 bugs in evaluation (Atom.: single-variable atomicity violation; Order: order violation; Multi-Atom.: multi-variable involved atomicity violation.)</head><label>7</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table 8 : Bugs detection results (are the bugs detected?)</head><label>8</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head>Table 9 (</head><label>9</label><figDesc>the ShrMem-Inst column), the number of dynamic memory accesses to memory locations that are truly shared among threads ranges from 978 to 182532. The interleaving space size grows exponentially to that number. Considering</figDesc><table><row><cell>App.</cell><cell cols="2"># ShrMem Inst</cell><cell cols="2">Races</cell><cell cols="2">Atom.</cell><cell cols="2">Con-Null</cell><cell cols="2">Con-Dangling</cell><cell cols="2">Con-UnInit</cell><cell cols="2">Con-Ovfl</cell><cell cols="2">ConMem Total</cell></row><row><cell></cell><cell>Static</cell><cell>Dynamic</cell><cell>#FP</cell><cell cols="2">#Bug #FP</cell><cell>#Bug</cell><cell>#FP</cell><cell cols="2">#Bug #FP</cell><cell>#Bug</cell><cell>#FP</cell><cell cols="2">#Bug #FP</cell><cell cols="2">#Bug #FP</cell><cell>#Bug</cell></row><row><cell>Apache</cell><cell>297</cell><cell>76540</cell><cell>14</cell><cell>1</cell><cell>157</cell><cell>2</cell><cell>4</cell><cell>0</cell><cell>6</cell><cell>3</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>1</cell><cell>10</cell><cell>4</cell></row><row><cell>MySQL</cell><cell>1086</cell><cell>17379</cell><cell>267</cell><cell>2</cell><cell>155</cell><cell>2</cell><cell>4</cell><cell>2</cell><cell>1</cell><cell>0</cell><cell>11</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>16</cell><cell>2</cell></row><row><cell>Transm.</cell><cell>507</cell><cell>978</cell><cell>42</cell><cell>0</cell><cell>33</cell><cell>0</cell><cell>8</cell><cell>0</cell><cell>5</cell><cell>0</cell><cell>3</cell><cell>1</cell><cell>0</cell><cell>0</cell><cell>16</cell><cell>1</cell></row><row><cell>PBZIP2</cell><cell>93</cell><cell>1744</cell><cell>17</cell><cell>6</cell><cell>21</cell><cell>4</cell><cell>6</cell><cell>6</cell><cell>0</cell><cell>2</cell><cell>3</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>9</cell><cell>8</cell></row><row><cell>FFT</cell><cell>205</cell><cell>182532</cell><cell>8</cell><cell>0</cell><cell>16</cell><cell>5</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>4</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>4</cell></row><row><cell>Cherokee</cell><cell>598</cell><cell>48502</cell><cell>8</cell><cell>2</cell><cell>28</cell><cell>2</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>1</cell><cell>0</cell><cell>1</cell></row><row><cell>Mozilla</cell><cell>76</cell><cell>18330</cell><cell>13</cell><cell>0</cell><cell>48</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>2</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>2</cell><cell>0</cell></row><row><cell cols="2">False Positive Rates</cell><cell></cell><cell cols="2">369:11</cell><cell cols="2">458:15</cell><cell></cell><cell>22:8</cell><cell></cell><cell>12:5</cell><cell></cell><cell>19:5</cell><cell></cell><cell>0:2</cell><cell></cell><cell>53:20</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head>Table 9 : Bug reports and false positives before ConMem-v pruning (Note: 1. the bug report number here is larger than that in Table 8, because some bug reports share one root cause. 2. #FP: # of false positive; #Bug: # of bugs; #ShrMem Inst: instructions that access variables truly shared with other threads.) that</head><label>9</label><figDesc>, the interleavings singled out by Race, Atom and ConMem are much fewer.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head>Table 11 : ConMem Run-time Performance (overhead %)</head><label>11</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head>Table 12 : Bug suspects pruned by synchronization analysis</head><label>12</label><figDesc>shows the number of bug suspects that are pruned out by this analysis. As we can see, the pruning is effective.</figDesc><table><row><cell>Bug-ID</cell><cell cols="3">Con-UnInit Con-Dangling Con-NULL</cell></row><row><cell>Apache</cell><cell>0</cell><cell>0</cell><cell>4</cell></row><row><cell>Mozilla</cell><cell>10</cell><cell>0</cell><cell>0</cell></row><row><cell>MySQL</cell><cell>62</cell><cell>2</cell><cell>74</cell></row><row><cell>PBZIP2</cell><cell>18</cell><cell>0</cell><cell>8</cell></row><row><cell>Cherokee</cell><cell>109</cell><cell>21</cell><cell>64</cell></row><row><cell>Transmission</cell><cell>25</cell><cell>0</cell><cell></cell></row><row><cell>FFT</cell><cell>28</cell><cell>0</cell><cell>0</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The original list in<ref type="bibr" target="#b21">[22]</ref> includes 74 bugs. 4 of them do not have enough error propagation information and are discarded in this study.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Data stored on stack is usually not shared across threads and is therefore ignored in our current prototype.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>One of these 9 bugs, PBZIP2-2, was not reported in previous document. It is detected in ConMem experiment.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Acknowledgments</head><p>We would like to thank our shepherd, Emery Berger, and the anonymous reviewers for their invaluable feedback. We thank the Opera group from UCSD for sharing with us their bug benchmarks. We also thank Mark Hill for his invaluable feedback and suggestions. This research is partially supported by a Claire Boothe Luce faculty fellowship.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">How important is the bug?</title>
		<author>
			<persName><forename type="first">Apache</forename><surname>Bugzilla</surname></persName>
		</author>
		<ptr target="http://issues.apache.org/bugwritinghelp.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Grace: safe multithreaded programming for c/c++</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Novark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">@</forename><surname>Bugzilla</surname></persName>
		</author>
		<author>
			<persName><surname>Mozilla</surname></persName>
		</author>
		<ptr target="https://bugzilla.mozilla.org/page.cgi?id=fields.html#severity" />
		<title level="m">A bug&apos;s life cycle</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Asserting and checking determinism for multithreaded programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Burnim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Klee: Unassisted and automatic generation of high-coverage tests for complex systems programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">jpredictor: A predictive runtime analysis tool for java</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Serbanuta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Dataflow analysis for concurrent programs using datarace detection</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Voung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Software quality and security analysis</title>
		<author>
			<persName><surname>Coverity</surname></persName>
		</author>
		<ptr target="http://www.coverity.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dmp: deterministic shared memory multiprocessing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Oskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Anomaly-based bug prediction, isolation, and validation: an automated approach for software debugging</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dimitrov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Multi-threaded java program test generation</title>
		<author>
			<persName><forename type="first">O</forename><surname>Edelstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Farchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Nir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ratsaby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Systems Journal</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Concurrent bug patterns and how to test them</title>
		<author>
			<persName><forename type="first">E</forename><surname>Farchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Nir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPDPS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Atomizer: a dynamic atomicity checker for multithreaded programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fasttrack: efficient and precise dynamic race detection</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Velodrome: a sound and complete dynamic atomicity checker for multithreaded programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Linux kernel developer responses to static analysis bug reports</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Purify: Fast detection of memory leaks and access errors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hastings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Joyce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Usenix Winter Technical Conference</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Backwards-compatible bounds checking for arrays and pointers in c programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H J</forename><surname>Kelly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated and Algorithmic Debugging</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Deadlock immunity: Enabling systems to defend against deadlocks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tralamazza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zamfir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07">July 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On-demand and semantic-free dynamic deadlock detection with speculative execution</title>
		<author>
			<persName><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lebeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sorin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Learning from mistakes -a comprehensive study of real world concurrency bug characteristics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">AVIO: detecting atomicity violations via access interleaving invariants</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Atom-aid: Detecting and surviving atomicity violations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hazelwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<ptr target="https://bugzilla.mozilla.org/showbug.cgi" />
		<title level="m">Mozilla Developers. Bug 123930 (deadlock)</title>
		<imprint/>
	</monogr>
	<note>?id=123930. Let them eat races</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Finding and reproducing heisenbugs in concurrent programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Basler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Nainar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Neamtiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Recording shared memory dependencies using strata</title>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automatically classifying benign and harmful data racesallusing replay analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tigani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Valgrind: a framework for heavyweight dynamic binary instrumentation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Improving the accuracy of data race detection</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H B</forename><surname>Netzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PPoPP</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Kendo: efficient deterministic multithreading in software</title>
		<author>
			<persName><forename type="first">M</forename><surname>Olszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ansel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Randomized active atomicity violation detection in concurrent programs</title>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Exposing atomicity violation bugs from their finding places</title>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><surname>Ctrigger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Pres: probabilistic replay with execution sketching on multiprocessors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Kiss: keep it simple and sequential</title>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Is transactional programming actually easier?</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Rossbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">S</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>WDDD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Cred: A practical dynamic buffer overflow detector</title>
		<author>
			<persName><forename type="first">O</forename><surname>Ruwase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Singletrack: A dynamic determinism checker for multithreaded programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Sadowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Eraser: A dynamic data race detector for multithreaded programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sobalvarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>ACM TOCS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Software bug contributed to blackout</title>
		<author>
			<persName><surname>Securityfocus</surname></persName>
		</author>
		<ptr target="http://www.securityfocus.com/news/8016" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Race directed random testing of concurrent programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Automated systematic testing of open distributed programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A comparison of software defects in database management systems and operating systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sullivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chillarege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In FTCS</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Algorithms for automatically computing the causal paths of failures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Sumner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fundamental Approaches to Software Engineering</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Associating synchronization constraints with data in an object-oriented language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vaziri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dolby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">The SPLASH-2 programs: Characterization and methodological considerations</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ohara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Torrie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A serializability violation detector for shared-memory server programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A case for an interleaving constrained shared-memory multi-processor</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Racetrack: Efficient detection of data race conditions via adaptive tracking</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rodeheffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Have things changed now? -an empirical study of bug characteristics in modern open source software</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASID workshop in ASPLOS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
