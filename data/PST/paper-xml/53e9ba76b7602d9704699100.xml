<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Let&apos;s ChronoSync: Decentralized Dataset State Synchronization in Named Data Networking</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zhenkai</forename><surname>Zhu</surname></persName>
							<email>zhenkai@cs.ucla.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexander</forename><surname>Afanasyev</surname></persName>
							<email>afanasev@cs.ucla.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Let&apos;s ChronoSync: Decentralized Dataset State Synchronization in Named Data Networking</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C9C2292339AF868F91B19361AF200D14</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In supporting many distributed applications, such as group text messaging, file sharing, and joint editing, a basic requirement is the efficient and robust synchronization of knowledge about the dataset such as text messages, changes to the shared folder, or document edits. We propose Chrono-Sync protocol, which exploits the features of the Named Data Networking architecture to efficiently synchronize the state of a dataset among a distributed group of users. Using appropriate naming rules, ChronoSync summarizes the state of a dataset in a condensed cryptographic digest form and exchange it among the distributed parties. Differences of the dataset can be inferred from the digests and disseminated efficiently to all parties. With the complete and up-to-date knowledge of the dataset changes, applications can decide whether or when to fetch which pieces of the data. We implemented ChronoSync as a C++ library and developed two distributed application prototypes based on it. We show through simulations that ChronoSync is effective and efficient in synchronization dataset state, and is robust against packet losses and network partitions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Applications such as file sharing, group text messaging, and collaborative editing are playing increasingly important roles in our lives. Many of such applications demand efficient and robust synchronization of datasets (file revisions, text messages, edit actions, etc.) among multiple parties. The research community has been working on distributed system synchronization since the early days of the Internet <ref type="bibr" target="#b0">[1]</ref> and has produced a rich literature of solutions. Quite a few popular applications like Dropbox and Google Docs, on the other hand, are implemented based on a centralized paradigm, which generally simplifies the application designs and brings many other advantages, but also results in single points of failure and centralized control of the data. At the same time, a number of different peer-to-peer solutions <ref type="bibr" target="#b1">[2]</ref>, including the recently announced BitTorrent Sync service <ref type="bibr" target="#b2">[3]</ref>, represent another direction in the searching of efficient dataset synchronization solutions, which requires either the maintenance of a sophisticated peer-to-peer network overlay structure or critical nodes for participants rendezvous.</p><p>The recently proposed communication paradigm, Named Data Networking (NDN) <ref type="bibr" target="#b3">[4]</ref>, where data is the first-class entity and multicast of data is naturally supported, brings new opportunities to efficiently solve the problem of dataset synchronizations in a completely distributed fashion. Thus, we propose ChronoSync, an efficient and robust protocol to synchronize dataset state among multiple parties in NDN. The core idea of ChronoSync is to compactly encode the state of a dataset into a crypto digest form (e.g., SHA256), which we call the state digest, or digest in short, and to exchange the state digests among all parties in a synchronization group. Each party sends out a broadcast interest with their respective state digest, calculated according to their knowledge of the dataset, to all others in the group. Such interests are directly broadcasted in small networks and are broadcasted via simple overlays in large networks. <ref type="foot" target="#foot_0">1</ref> If the state digest carried in the incoming interest is the same as the one locally maintained, indicating identical knowledge about the dataset, no action is required from the recipient. Otherwise, one of the two actions will be triggered:</p><p>• the differences of the dataset state can be directly inferred and sent as the response to the sync interest if the state digest is the same as one of the previous local state digests;</p><p>• a state reconciliation method is used to determine the differences of the knowledge if the state digest is unknown (for example, when recovering from a network partition). Actions will be triggered to eliminate the differences of the dataset state until the interests from all parties carry an identical state digest.</p><p>The rest of the paper is organized as follows. We first briefly introduce the NDN architecture in Section II. The main contribution of the paper is the design of the ChronoSync protocol as presented in Section III, which exploits the features of the NDN architecture to efficiently synchronize dataset state among a distributed group of users. Section IV and Section V demonstrate the implementation of ChronoSync and the evaluation results. Discussions and related work are presented in Section VI and Section VII respectively. We conclude the paper in Section VIII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. NDN ARCHITECTURE</head><p>In this section we briefly go over a few basic concepts of the NDN architecture <ref type="bibr" target="#b3">[4]</ref> that are essential to describe the design of ChronoSync.</p><p>NDN architecture has two basic communication units: interest packet and data packet, both carrying hierarchically structured names. An interest packet is sent when a consumer requests data. Each data packet is cryptographically signed, enabling the recipient to check the provenance and integrity of the data regardless of how it is obtained (from the data source, cache, or neighbor). A data packet can be used to satisfy an interest, as long as the name carried in the interest is a prefix of or identical to that of the data. An interest can also carry a selector field to specify preferences in case there are multiple data packets that can satisfy the interest.</p><p>All communication in NDN is receiver-driven, meaning that the only way for a data packet to be delivered is that a consumer explicitly sends out an interest requesting this data first. When receiving a interest, routers add an entry to the pending interest table (PIT), recording the interface from which the interest came, and use a forwarding strategy <ref type="bibr" target="#b4">[5]</ref> to determine where to forward the interest. As a result, a returning data packet can simply trace the reverse path back to the requester. When multiple interests for the same data come from the downstreams, NDN routers create only one PIT entry, remembering all the interfaces from which the interests came, and forward out only one interest to the upstream. As shown in Fig. <ref type="figure" target="#fig_0">1</ref>, this process essentially constructs a temporary multicast tree for each requested data item, along which the data is efficiently delivered to all requesters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. CHRONOSYNC DESIGN</head><p>In this section we describe the ChronoSync protocol design. We first present an overview of ChronoSync components, and then explain the naming rules in Section III-B. Section III-C shows how ChronoSync maintains the knowledge about the dataset and Section III-D describes how the changes to the dataset propagate to all participants. Section III-E and III-F discuss how ChronoSync handles simultaneous data generations and network partitions.</p><p>To better illustrate the basic components of the ChronoSync design, we use a group text chat application, ChronoChat, as an example throughout the paper. While a real chat application includes a number of essential components, such as roster maintenance, in our example we introduce only elements that are directly relevant to ChronoSync.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Overview</head><p>In the core of any ChronoSync-based application there are two interdependent components, as shown in Fig. <ref type="figure">2</ref>: the ChronoSync module that synchronizes the state of the dataset and the application logic module that responds to the change</p><formula xml:id="formula_0">!"#$%$&amp;'%( )*+,-./0#,, )*+,-./1$+/2$34$%567</formula><p>&amp;'%(/8%.,#,-.-&amp;'%(/)5.5 933:-3,(*;(/ ($&lt;&lt;=%*(54$% &gt;,($?,#'/8%.,#,-.-@$4;(54$%-/5A$=./("5%+,-/$B/C5.5-,./-.5.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ChronoSync-based application</head><p>App-specific logic and state storage (chat messages, file revisions, etc.) &gt;,($?,#'/)5.5 Fig. <ref type="figure">2</ref>: ChronoSync overview of the dataset state. In ChronoChat, ChronoSync module maintains the current user's knowledge about all the messages in the chatroom in the form of a digest tree, as well as history of the dataset state changes in the form of a digest log. After ChronoSync module discovers that there are new messages in the chatroom, it notifies ChronoChat logic module to fetch and store the messages.</p><p>To discover dataset changes, the ChronoSync module of each ChronoChat instance sends out a sync interest, whose name contains the state digest that is maintained at the root of the digest tree. Generally, with the help of digest tree and digest log, ChronoSync can infer dataset changes directly and reply to the sync interest with the data containing the changes, which we henceforth refer to as sync data. In cases of network partitioning, ChronoSync also uses recovery interests and recovery data to discover the differences in the dataset state.</p><p>ChronoSync focuses solely on facilitating the synchronization of the knowledge about new data items in the dataset, leaving the decision on what to do after ChronoSync discovers state changes at the application's discretion. For example, the sync data in ChronoChat brings back the names of messages newly added to the chatroom, and thus a user's knowledge of the dataset is brought up to date. However, the user may decide whether to fetch all the missing messages or just the most recent ones, if the total number of missing messages is large (e.g., after recovery from a network partition).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Naming rules</head><p>One of the most important aspects of application design in NDN is naming, as the names carry out several critical functions. The name carried in an interest packet is used by the network to figure out where to forward it and to determine which process to pass it to when it reaches the producer. Also proper naming rules can greatly simplify the design of applications.</p><p>There are two sets of naming rules in ChronoSync: one for application data names and one for sync data names. <ref type="foot" target="#foot_1">2</ref>/wonderland/alice/chronos/lunch-talk/791 We design the application data names to have routable name prefixes so that the interests can be forwarded towards the producers directly. These prefixes can be constructed by appending one or more components under a prefix assigned by the Internet provider. For example, part (1) of the chat data name in Fig. <ref type="figure">3a</ref> is such a prefix. The purpose of the part (2), which includes the application name and the chatroom name, is to demultiplex the interest once it reaches the data source: it identifies the process that is responsible for handling such interests.</p><formula xml:id="formula_1">(1)<label>(2) (3)</label></formula><p>The data generated by a user is named sequentially. For example, in ChronoChat, the initial message from a user to the chatroom has sequence number zero and whenever a new message is generated, be it a chat message or user presence message, the sequence number is incremented by one. As a result, the complete knowledge of the user can be compactly represented by just one name. Assume the name shown in Fig. <ref type="figure">3a</ref> is the latest chat data name used by Alice. We can infer from the naming rules that Alice has produced 792 pieces of chat data to this chatroom, with sequence numbers ranging from 0 to 791.</p><p>Similarly, the name for sync data (Fig. <ref type="figure">3b</ref>) also consists of three parts. Part (1) is the prefix in the broadcast namespace for a given broadcast domain. A broadcast prefix ensures that the sync interests are properly forwarded to all participants of a group, as it is often impossible to predict who will cause the next change to the dataset state. Part (2) serves the purpose of demultiplexing (similar to that of the application data name), and the last part carries the latest state digest of the interest sender.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Maintaining dataset state</head><p>The application dataset can be represented as the union of the subsets of data generated by all producers.</p><p>Since the knowledge of a data producer can be solely represented by its name prefix and the latest sequence number, ChronoSync tracks the latest application data name of each producer in order to maintain up-to-date knowledge of the dataset. For the sake of simplicity in writing, we refer to the latest application data name of a producer as its producer status.</p><p>Inspired by the idea of Merkle trees <ref type="bibr" target="#b5">[6]</ref>, ChronoSync uses a digest tree to quickly and deterministically compress knowledge about the dataset into a crypto digest, as illustrated in  To ensure that every participant calculates the same state digest when observing the same set of producer statuses, the child nodes are kept in the lexicographic order according to their application data name prefixes. The digest tree is always kept up-to-date to accurately reflect the current state of the dataset. Whenever a ChronoChat user sends a new chat message or learns about the name of a new message from another participant, the corresponding branch of the digest tree is updated and the state digest is re-calculated.</p><p>As an optimization, each party keeps a digest log along with the digest tree. This log is a list of key-value pairs arranged in chronological order, where the key is the state digest and the value field contains the producer statuses that caused the state change. An example of digest log is illustrated in Table <ref type="table" target="#tab_1">I</ref>. The log is useful in recognizing outdated state digests. For example, when a user resumes from a temporary disconnection and sends out a sync interest with an outdated state digest, other parties, if recognizing the old digest, can quickly infer the differences between the dataset states and promptly reply the sender with missing data names.</p><p>Although the digest log facilitates the process of state difference discovery in many cases, it is not essential ensure the correctness of the ChronoSync design. Depending on the available resources, applications can set an upper bound on the size of the digest log, purging old items when necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Propagating dataset changes</head><p>To detect dataset changes as soon as possible, every party keeps an outstanding sync interest with the current state digest. When all parties have the same knowledge about the dataset, the system is in a stable state, and sync interest from each party carries an identical state digest, resulting in efficient interest collapsing in NDN routers <ref type="bibr" target="#b3">[4]</ref>. Fig. <ref type="figure" target="#fig_2">5a</ref> shows an example of a system in stable state, where there is no ongoing conversation in a chatroom.</p><p>As soon as some party generates new data, the state digest changes, and the outstanding interest gets satisfied. For example in Fig. <ref type="figure" target="#fig_2">5b</ref>, when Alice sends a text to the chatroom, ChronoSync module on her machine immediately notices that its state digest is newer and hence proceeds to satisfy the sync interest with sync data that contains the name of text message. Because of the communication properties of NDN, the sync data is efficiently multicasted back to each party in the chatroom. Whoever receives the sync data updates the digest tree to reflect the new change to the dataset state, and sends out a new sync interest with the updated state digest, reverting the system to a stable state. Meanwhile, the users may send interests to request for Alice's text message using the data name directly. In other more complex applications, the sync data may prompt the applications to perform more sophisticated actions, such as fetching a new version of a file and applying changes to the local file system.</p><p>Normally, the state digest carried in the sync interest is recognized by the interest recipients: it is ether the same as the recipient's current state digest or the previous one if the recipient just generated new data. However, even in a lossfree environments, out-of-order packet delivery can result in receiving sync interests with digests that cannot be recognized. For instance, in Fig. <ref type="figure" target="#fig_2">5b</ref>  To cope with this problem, ChronoSync employs a randomized wait timer T w , with value being set approximately on the order of the propagation delay. More specifically, a recipient sets up the wait timer T w when an unknown digest is received and postpones the processing of the corresponding sync interest until the timer expires. In the example mentioned above, Bob's state digest would become the same as the new digest after Alice's reply reaches him, before T w expires.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Handling simultaneous data generations</head><p>In simultaneous data generation cases, more than one data producer reply to the outstanding sync interests. As one interest can only bring back one piece of data in NDN, simultaneous data generations would partition the system into two or more groups, with each group maintaining a different state digest, depending on whose sync data they have received. At the same time, users in different group will not be able to recognize each other's state digest. This is illustrated in Fig. <ref type="figure" target="#fig_3">6</ref>, where Alice and Bob reply to the sync interests at the same time and only Bob's sync data reaches Ted. Thus, the new state digest of Alice is different from that of the other two.</p><p>This problem can be solved with the exclude filter <ref type="bibr" target="#b6">[7]</ref>, which is one of the selectors that can be sent along with the interest to exclude data that the requester no longer needs. When the wait time T w times out, Ted proceeds to send a sync interest with the previous state digest again, but this time with an exclude filter that contains the hash of Bob's sync data. Routers understand that Bob's sync data, although has the same name as the one carried in the sync interest, cannot be used as the reply to the interest. As a result, this sync interest brings back Alice's sync data from router C's cache. Similarly, Alice and Bob also retrieve each other's sync data with the help of the exclude filter. At this point, all three users have obtained the knowledge about the simultaneously generated data and compute an identical state digest.</p><p>If there are more producers involved in a simultaneous data generation event, multiple rounds of sync interests with exclude filter have to be sent. Each of such interest has to exclude all the sync data of a particular state digest known to the requester so far.</p><p>/ndn/broadcast/chronos/lunch-talk/recovery/a01e99... When network partitions happens, the users become physically divided (as opposed to the logical division in the simultaneous data generation case) into multiple groups. Although within each group users may continue to communicate due to ChronoSync's decentralized design, there is a challenging synchronization problem when the network partition heals: parties in different groups accumulated different subsets of data and it is impossible for them to recognize each other's state digests. Different from what happens in simultaneous data generations, where multiple users reply to the same sync interest with different sync data, during network partitioning an unknown number of sync data with different state digests may have been generated by multiple parties, rendering the exclude filter ineffective in determining the differences of dataset. Hence, when the interest with exclude filter times out (such interests should have very short lifetime, as the sync data, if there is any, should already be cached in the routers), ChronoSync infers that the network partitions have happened and measures have to be taken to resolve the differences. Depending on specific application requirements, various set reconciliation algorithms <ref type="bibr" target="#b7">[8]</ref>- <ref type="bibr" target="#b9">[10]</ref> can be used to solve this problem.</p><p>For applications such as ChronoChat, for example, Chrono-Sync resorts to a simple but effective recovery procedure, outlined as follows. The recipient of the unknown digest sends out a recovery interest, as shown in Fig. <ref type="figure" target="#fig_4">7</ref>. It is similar to a normal sync interest, but has a "recovery" component before the digest and includes the unknown state digest, instead of the one in the root of the local digest tree. The purpose of such an interest is to request missing information about the dataset from those who produced or recognized the unknown state digest. Those who recognize the digest (e.g., having it in their digest log) reply the recovery interest with the most recent producer status of all users, and others simply ignore the recovery interest. Upon receiving the recovery reply, the recipient compares the producer statuses included in the reply with those stored in the local digest tree and updates the tree whenever the one in the reply is more recent. This recovery procedure guarantees that the system will revert to the steady state within few recovery rounds (e.g. one round for two groups that have different state digests).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. IMPLEMENTATION</head><p>We implemented the ChronoSync protocol as a C++ library, and also built a proof-of-concept ChronoChat application (Fig. <ref type="figure" target="#fig_5">8</ref> shows screenshot of a demo chat session) and tested it on both Linux and Mac OS X platforms with up to 20 participants. The chat messages were disseminated correctly </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EVALUATION</head><p>To understand characteristics and tradeoffs of the Chrono-Sync protocol, we conducted a number of simulation-based experiments of the group text chat service (ChronoChat) using NS-3 <ref type="bibr" target="#b10">[11]</ref> with ndnSIM module <ref type="bibr" target="#b11">[12]</ref>, which fully implements the NDN communication model. In particular, we are interested in confirming that ChronoSync propagates state information quickly and efficiently, even in face of network failures and packet losses. To get a baseline for the comparison, we also implemented a simple TCP/IP-based approximation of the centralized Internet Relay Chat (IRC) service, where the server reflects messages from a user to all others. For simplicity of the simulation, we did not implement heartbeat messages for either ChronoChat or IRC service simulations. Also, chat messages in the simulated ChronoChat application are piggybacked alongside with the sync data. That is, when, for example, Alice sends a new message, her ChronoChat app not only notifies others about the existence of a new message, but also includes the actual message data in the same packet.</p><p>In our evaluations we used the Sprint point-of-presence topology <ref type="bibr" target="#b12">[13]</ref>, containing 52 nodes and 84 links (Fig. <ref type="figure">9</ref>). Each link was assigned measurement-inferred delay, 100 Mbps bandwidth, and drop-tail queue with the capacity of 2000 packets. As the size of the text message is usually small, there is no congestion in the network. All nodes in the topology act as the participants of a single chatroom. The traffic pattern in the room was determined based on the multi-party chat traffic analysis by Dewes et al. <ref type="bibr" target="#b13">[14]</ref> as a stream of messages of sizes from 20 to 200 bytes with inter-message gap following the exponential distribution with the mean of 5 seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. State synchronization delay</head><p>ChronoSync-based applications are fast in synchronizing dataset state. To evaluate this property quantitatively, we define state synchronization delay to be the the time interval between the message generation and discovery of this message by all of the chatroom participants. We performed 20 runs of the chatroom simulation with 52 participants that produced together a total of 1000 messages under various network condition. Each individual simulation run featured different sets of messages injected to the chatroom, with different intermessage delays, different message sizes, and different order of participants talking. In the IRC case, we randomly chose one of the nodes in the topology as the position of the central server for each run. 1) Performance under normal network conditions: As an initial step, we evaluated ChronoChat under normal network conditions without network failures or packet losses, which allowed us to understand the baseline performance of ChronoSync protocol.</p><p>Since in ChronoChat sync data always follows optimal paths built by outstanding sync interests, the synchronization delay is significantly lower, compared to that of the client-server based IRC implementation, as shown in Fig. <ref type="figure" target="#fig_0">10</ref>: for ChronoChat, more than 40% of all messages sent in 20 runs experienced delay less than 20 ms, compared to ≈13% of messages in IRC case for the same delay range.</p><p>2) Performance in lossy environments: We evaluated ChronoChat in lossy network environment, with varying level of per-link random packet losses, ranging from 1% to 10%. Fig. <ref type="figure" target="#fig_0">11</ref> summarizes the simulation results in form of cumulative distribution function graphs for ChronoChat and IRC services (for better visual presentation, x-axis is presented in the exponential scale and y-axis is in the quadratic scale). A conclusion can be made from these results that the performance of ChronoChat stays practically unaffected if the network experiences moderate levels of random losses (≤1%). Moreover, even if network conditions deteriorate and random losses increase to abnormally high values (5%-10%), ChronoChat continues to show significantly shorter state synchronization delay, compared to IRC-like systems.</p><p>Overall, regardless of the random loss rate value, more messages in ChronoChat experienced smaller delay, compared to those in IRC. This trend is more clear as the loss rate grows: the percentage of messages with small delay drops rapidly in IRC and in ChronoChat it drops more gracefully. However, a careful reader may note that there is a small fraction of messages in ChronoChat that experienced longer delay, compared to IRC. This is because ChronoChat uses NDN's pull based model: a receiver needs to discover a new state first in order to request for it, as opposed to TCP/IP where the source keeps (re-)sending the data packets until it is acknowledged by the receivers. In cases where the sync interests or sync data are dropped so heavily that some participants are not aware of the state change, it has to wait until these participants re-express sync interests or another state change occurs before the message can be disseminated to all users. We believe that adaptive adjustment of sync interest reexpression interval, depending on application requirements and network conditions, should be able to keep synchronization delay within reasonable ranges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Synchronization resiliency to network failures</head><p>Another key feature of ChronoSync is its serverless design, which means that users can communicate with each other as long as they are connected. Even in the case of network partitioning, the group of participants in each partition should still be able to communicate with each other, and when the partition heals, different groups should synchronize the chatroom data automatically.</p><p>1) Basic verification of link failure resiliency: To verify this property we conducted a small-scale 4-node simulation with link failures and network partitioning (Fig. <ref type="figure" target="#fig_0">12</ref>). The total simulation time of 20 minutes was divided into 5 regions: 0-200 seconds with no link failures (Fig. <ref type="figure" target="#fig_0">12a</ref>), 200-400 seconds with one failed link between nodes 0 and 1 (Fig. <ref type="figure" target="#fig_0">12b</ref>), 400-800 seconds with two failed links between nodes 0, 1 and 2, 3 (partitioned network, Fig. <ref type="figure" target="#fig_0">12c</ref>), 800-1000 seconds with one failed link between nodes 2 and 3, and finally 1000-1200 seconds period with no link failures.</p><p>The results are depicted in Fig. <ref type="figure" target="#fig_0">13</ref>, visualizing node 0's knowledge about the current states of all other participants as a function of time. This figure not only confirms that the parties within a connected network continue to communication during the partitioning event, but also the fact that when the network recovers from partitioning, the state is getting synchronized as soon as interests start flowing through formerly failed links.</p><p>2) Impact of link failures: To quantify the effect of network failures on ability of text chat participants to communicate with each other, we again used our 52-node topology that is now subjected to varying level of link failures. In each individual run of the simulation we failed from 10 to  a violin plot <ref type="foot" target="#foot_3">4</ref> for this graph to highlight a bimodal nature of the distribution for the percent of communicating pairs in the centralized IRC service: with significantly high probability the users were almost not able to communicate at all (notice the portion of the violin plots near the bottom of the y-axis for IRC). ChronoChat, being completely distribute, always allows a substantial number of pairs able to communicate. For any centralized implementation, like IRC, there is always a single of point of failure and the communication can get completely disrupted even with a small level of link failures.</p><formula xml:id="formula_2">• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • IRC ChronoChat 0% 20%</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Network utilization pattern</head><p>To understand how the fast state synchronization and robustness to links failures in ChronoSync relates to the network utilization, for the same sets of experiments we collected statistics about the number of packets transferred over each </p><formula xml:id="formula_3">• • • • • • • • • • • • • • •• •••••••••••• • •••••••••••••••</formula><p>Different links Total number of packets (sqrt scale)</p><p>• IRC ChronoChat Fig. <ref type="figure" target="#fig_2">15</ref>: Number of packets in links (packet concentration) link in the topology (we call it packet concentration for a link).</p><p>When counting the packets, we included both interest and data packets in ChronoChat, and both TCP DATA and ACK packets in IRC. The obtained data for our 52-node topology experiment is summarized in Fig. <ref type="figure" target="#fig_2">15</ref>, <ref type="foot" target="#foot_4">5</ref> where the links were ordered and visualized by the packet concentration value ( with 97.5% confidence interval). The results presented in Fig. <ref type="figure" target="#fig_2">15</ref> show that ChronoChat more or less equally utilizes all of the available network links between participants. <ref type="foot" target="#foot_5">6</ref> Results for network utilization in IRC case show a completely different pattern. A few links close to the server have high packet concentrations, with value as large as ≈90,000 packets (≈90 times of the total number of messages in the chatroom) in the link directly adjacent to the server. Many links that are close to clients have a low packet concentration, while some links, which are not on the shortest path between clients and the server, are not utilized at all.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Overall overhead</head><p>The difference between network utilization patterns in ChronoChat and IRC highlights an important design tradeoff of ChronoSync protocol. As the primary objective of ChronoSync is to synchronize the state in a complete distribute manner as fast as possible, and with ability to mitigate network failures, it utilized more links in the topology compared to IRC. At the same time, as ChronoSync does not have triangular data distribution paths and NDN architecture ensures that each piece of data travels over a link no more than once, the overall overhead in ChronoChat can be even lower than that of the centralized solutions which are generally considered to be efficient in network utilization. For example, the cumulative sum of packet concentrations presented in Fig. <ref type="figure" target="#fig_9">16</ref> shows that in our experiments, where sync interests are distributed by broadcast, ChronoChat still has considerably lower overall overhead compared to that of the IRC service. Note that ChronoSync also features application-specific trade-offs, which can be directly related to the overall overhead. In particular, when an application seldom generates new data and can tolerate certain synchronization delay, it is not necessary to always keep an outstanding sync interest. Instead, the sync interests can be expressed with longer intervals to reduce the overall overhead.</p><formula xml:id="formula_4">100k 200k 300k 400k • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • •<label>20</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. DISCUSSIONS</head><p>In this section we briefly discuss application domain where ChronoSync fits the best, as well as the scalability and security issues of the ChronoSync protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Target application domain</head><p>ChronoSync strives to be an efficient general-purpose state synchronization protocol. At the same time, it is most suited for applications with the following features and properties:</p><p>1) state synchronization needs to be done in a distributed way, without relying on a mandatory central node; 2) parties contribute to the dataset in a non-deterministic fashion, i.e., it is hard or impossible to predict either who will be generating the new data or when the data generation will happen. 3) all parties wish to have the same knowledge about a dataset; 4) the probability of simultaneous data generations by a large number of parties is low. Decentralized synchronization keeps the local communication local. For example, synchronizing photos between a laptop and a nearby smartphone does not need to go through the cloud and should be able to happen even without a wireless access point. However, note that ChronoSync can easily work together with infrastructure based storage services without any special configurations. For example, if a chatroom in ChronoChat utilizes a backup service provided by a cloud storage server, the server can simply participate in the chatroom as a regular user.</p><p>The non-deterministic way of data generation and the desire to synchronize knowledge of a dataset are often natural for the applications in this domain. For example, in collaborative editing, every user wishes to have the up-to-date version of the !" #" $" Fig. <ref type="figure" target="#fig_4">17</ref>: Overlay broadcast network for ChronoSync document, but it is unrealistic to predict users' editing behavior. Furthermore, if the data generation pattern is predictable, one can simply request the data directly from the producers at the expected data generation time.</p><p>The last requirement ensures that ChronoSync can deduce the differences of dataset states efficiently using recent history of state digests for most of time, without resorting to relative costly state reconciliation methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. ChronoSync in large networks</head><p>ChronoSync uses the broadcast sync interests to exchange state digests. However, broadcasting sync interests to the parties scattered in large networks, such as the Internet, could be costly. A possible solution is to build an overlay broadcast network over NDN. As shown in Figure <ref type="figure" target="#fig_4">17</ref>, each network with users of ChronoSync-based applications sets up a gateway node, which knows how to forward sync interests to other overlay gateways. A gateway node relays the sync interests received from its local network to gateways in other networks. Vice versa, the sync interests received from other gateway nodes would also be broadcasted in the local network. As a result, the broadcast of sync interests is confined to networks where such interests are desired to be received. Gateways can learn each other's presence through configurations or some other means, but this is out of scope for this paper.</p><p>Furthermore, various different distributed applications based on ChronoSync can share the same gateway overlay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Security considerations</head><p>From the security point of view, ChronoSync needs to address two problems. First, outsiders and non-cooperative users should not be able to disrupt the state synchronization process by injecting false information about the statuses of other users. Second, non-authorized users should not have access to the data published by eligible users.</p><p>In solving both problems, we assume that users can obtain each other's public keys through a trustworthy key management system, such as manually configured key files, certificates signed by a trusted entity, or some other means.</p><p>The first problem can be solved by requiring parties to include a signature of the producer status when replying the sync interest. That is, whenever a party needs to reply the sync  interest with the producer statuses of other parties (e.g., to a recovery interest), it also needs to include the corresponding original signatures. Figure <ref type="figure" target="#fig_10">18</ref> shows an example of sync reply to a newcomer. The recipient can easily verify the validity of each producer status and update the digest tree only if the signature is valid.</p><p>Restricting access to the private data can be implemented through dataset sharing moderation. That is, each sharing group can have one or several moderators, who can grant or reject access to the data. The protected data should be encrypted using a shared secret key, effectively preventing outsiders from eavesdropping. To request access privilege to the protected data, a party would need to publish its encryption public key and to ask for permission from the moderator(s). As each data packet in NDN is signed, the moderator(s) can easily fetch the key and verify if the party is authorized to access the data based on the signing public key for the NDN packet signature (which is different from the encryption public key). If the access should be granted based on the policy, the moderator publishes a shared secret key, encrypted with the encryption key provided by the requester.</p><p>After a requester fetches and decrypts the shared key, it gains the ability to participate in the synchronization process with others who are already in the group.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. RELATED WORK</head><p>There is an extensive amount of research to bring multicast functionality, and in particular reliable multicast functionality <ref type="bibr" target="#b14">[15]</ref>- <ref type="bibr" target="#b16">[17]</ref> to the Internet. NDN architecture, based on which ChronoSync is designed, natively solves the multicasting problem, but requires applications to be implemented using a pullbased data delivery model, i.e., users need to explicitly request for data. ChronoSync protocol gives an opportunity for the classes of applications listed in Section VI-A to efficiently discover names for dynamically generated data.</p><p>To some extent, the design of ChronoSync protocol was inspired by the CCNx Synchronization protocol (ccnx-sync): the protocol to facilitate automatic synchronization of data collections in CCNx repositories <ref type="bibr" target="#b17">[18]</ref>. However, ChronoSync and ccnx-sync are completely different protocols with different objectives-synchronizing knowledge about the data collections versus synchronizing the data collection itself.</p><p>The key building block of ChronoSync design-a compact representation of the knowledge about the whole dataset as a hash value-is based on concept of Merkle trees (hash tree) <ref type="bibr" target="#b5">[6]</ref>. The Merkle tree is widely used in many different areas, including file systems to verify/maintain integrity of the data on disk <ref type="bibr" target="#b18">[19]</ref>, anti-entropy mechanism in distributed key/value stores <ref type="bibr" target="#b19">[20]</ref>, and many others.</p><p>Another component of ChronoSync design (reconciliation of knowledge about the date collection) is closely related to numerous research efforts that aim to efficiently discover differences in files, folders, and databases: RSYNC <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>, CDC in LBFS <ref type="bibr" target="#b22">[23]</ref>, TAPER <ref type="bibr" target="#b23">[24]</ref> to name a few. However, in most cases, the nature of applications for which ChronoSync was designed (see Section VI-A) allows efficient difference discovery without resorting to any complex state reconciliation procedures. For other types applications, ChronoSync supports the use of any of the existing or new promising algorithms, for example the algorithm crafted by Eppstein et al. <ref type="bibr" target="#b7">[8]</ref>, in addition to the simple state reconciliation approach described in Section III-F.</p><p>There is also a rich literature of peer-to-peer solutions <ref type="bibr" target="#b1">[2]</ref>. In general these solutions are designed to run over today's TCP/IP network and build an application level overlay to interconnect peers. Such an overlay can be subject to frequent changes as users join and leave, and are unaware of the underlying network topological connectivity. Even though some solutions offer application level multicast data delivery, the resulting data distributions tend to be inefficient due to the mismatch between the overlay and the underlay network topology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSION</head><p>In this paper we presented ChronoSync, a dataset synchronization protocol for distributed applications running in NDN networks. Leveraging on NDN's interest-data packet exchanges for fetching named data, ChronoSync effectively names the state of a dataset by its digest at a given time. Carrying the name of the dataset state, each sync interest is broadcasted to all participants in a synchronization group to solicit "data" that reports changes in the dataset. The design takes a completely distributed approach, and the resulting ChronoSync protocol removes both single point of failure and traffic concentration problems commonly associated with centralized implementations. Our simulation results also show that ChronoSync is highly robust in faces of packet losses, link failures, and network partitions.</p><p>We hope that ChronoSync represents a step towards a new direction of providing useful building blocks in supporting distributed applications development. The initial ChronoSync design emerged during our effort of developing a chatroom application to run over NDN. Since then we have also used ChronoSync in developing a rather different application, ChronoShare (a.k.a. NDN-Dropbox) that provides distributed file sharing among a set of users. To verify whether Chrono-Sync can support a wide range of distributed applications, or what needs to be changed to enable it, as part of our ongoing efforts we plan to apply ChronoSync to support more types of applications running over NDN. For example multi-party audio conferencing over NDN <ref type="bibr" target="#b24">[25]</ref> can leverage ChronoSync to propagate the speaker information and instruct the listeners to fetch the audio streams from active speakers; resource discovery applications such as zero configuration networking [26] could be another candidate to apply ChronoSync protocol.</p><p>We also hope that this work can help stimulate more discussions on the design space of distributed applications over NDN and identify and implement useful building blocks to lower the hurdle of application development.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Multicast of data is naturally supported in NDN</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>( a )Fig. 3 :</head><label>a3</label><figDesc>Fig. 3: Naming rules of ChronoSync</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: State change propagation in ChronoSync</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: An example of simultaneous data generation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: An example of recovery interest</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: ChronoChat: a distributed multi-user text chat app</figDesc><graphic coords="5,362.00,53.00,151.00,119.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 9 :Fig. 10 :</head><label>910</label><figDesc>Fig. 9: Sprint point-of-presence topology</figDesc><graphic coords="6,103.00,54.00,143.00,86.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 11 :Fig. 12 :Fig. 13 :Fig. 14 :</head><label>11121314</label><figDesc>Fig. 11: Packet delivery delay in face of packet losses</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 16 :</head><label>16</label><figDesc>Fig. 16: Cumulative sum of per-link packet concentrations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 18 :</head><label>18</label><figDesc>Fig. 18: Example of a sync reply to a newcomer</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I :</head><label>I</label><figDesc>An example of digest log Fig. 4.</figDesc><table /><note><p><p>3 </p>Each child node of the tree root holds a cryptographic digest calculated by applying, for example, SHA-256 hash function over a user's producer status. Recursively applying the same hash function to all child nodes of the root results in the digest that represents state of the whole dataset, which we refer to as the state digest.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>,</head><label></label><figDesc>Ted's sync interest with the new state digest (after incorporating Alice's sync data into digest tree,</figDesc><table><row><cell>/sync-prefix/d1</cell><cell></cell><cell></cell><cell>/sync-prefix/d1</cell></row><row><cell>Alice</cell><cell>A</cell><cell>B</cell><cell>Bob</cell></row><row><cell></cell><cell></cell><cell>2</cell><cell></cell></row><row><cell></cell><cell>1</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>C</cell><cell></cell></row><row><cell></cell><cell></cell><cell>0</cell><cell></cell></row><row><cell></cell><cell></cell><cell>Ted</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>/ndn/broadcast/chronos/lunch-talk/000...</figDesc><table><row><cell>Alice's name prefix</cell><cell>37</cell><cell>Alice's signature</cell></row><row><cell>Bob's name prefix</cell><cell>21</cell><cell>Bob's signature</cell></row><row><cell>Ted's name prefix</cell><cell>96</cell><cell>Ted's signature</cell></row><row><cell cols="3">NDN packet signature</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that the cost of broadcast interests in NDN is low, as identical interests are collapsed. Hence, there is at most one interest transmitted over a link in one direction regardless of the number of parties in the synchronization group.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The naming for recovery data will be discussed in Section III-F.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>While we use an one-level hash tree here, a more canonical form of hash trees can be used if the applications demand different naming rules.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>The violin plot is a combination of a box plot and a kernel density estimation plot. Wider regions represent higher probability for samples to fall within this region.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>the figure summarizes data about experiments under ideal network conditions, but results in lossy environments show similar trends</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p><ref type="bibr" target="#b5">6</ref> When not all nodes participate in chat sessions, the interest forwarding strategy would ensure that links that are not on the path between participants, will not be unnecessarily utilized. The specific implementation of a such strategy is one of our future research directions.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A survey of peer-to-peer content distribution technologies</title>
		<author>
			<persName><forename type="first">S</forename><surname>Androutsellis-Theotokis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Spinellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">BitTorrent Sync</title>
		<ptr target="http://labs.bittorrent.com/experiments/sync.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Named data networking (NDN) project</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<idno>NDN-0001</idno>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>PARC</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A case for stateful forwarding plane</title>
		<author>
			<persName><forename type="first">C</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Afanasyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Moiseenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Communications</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A certified digital signature</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Merkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Advances in Cryptology</title>
		<meeting>of Advances in Cryptology</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Ccnx techincal documentation: Ccnx interest message</title>
		<ptr target="http://www.ccnx.org/releases/latest/doc/technical/InterestMessage.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">What&apos;s the difference? Efficient set reconciliation without prior context</title>
		<author>
			<persName><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Uyeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGCOMM</title>
		<meeting>of SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Set reconciliation with nearly optimal communication complexity</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Minsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Info. Theory</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">l 1 -different algorithm for massive data streams</title>
		<author>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">ns-3: a discrete-event network simulator for Internet systems</title>
		<ptr target="http://www.nsnam.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">ndnSIM: NDN simulator for NS-3</title>
		<author>
			<persName><forename type="first">A</forename><surname>Afanasyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Moiseenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<idno>NDN-0005</idno>
	</analytic>
	<monogr>
		<title level="j">NDN</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Measuring ISP topologies with Rocketfuel</title>
		<author>
			<persName><forename type="first">N</forename><surname>Spring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">An analysis of Internet chat systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dewes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wichmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Feldmann</surname></persName>
		</author>
		<idno>IMC&apos;03</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A reliable multicast framework for light-weight sessions and application level framing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-G</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGCOMM</title>
		<meeting>of SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Active reliable multicast</title>
		<author>
			<persName><forename type="first">L.-W</forename><forename type="middle">H</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Tennenhouse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of INFOCOM</title>
		<meeting>of INFOCOM</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Reliable multicast transport protocol (RMTP)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Sabnani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhattacharyya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="407" to="421" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Ccnx synchronization protocol</title>
		<author>
			<persName><surname>Projectccnx</surname></persName>
		</author>
		<ptr target="http://www.ccnx.org/releases/latest/doc/technical/SynchronizationProtocol.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">End-to-end data integrity for file systems: a ZFS case study</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rajimwale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX conference on File and storage technologies</title>
		<meeting>USENIX conference on File and storage technologies</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Dynamo: Amazon&apos;s highly available key-value store</title>
		<author>
			<persName><forename type="first">G</forename><surname>Decandia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The rsync algorithm</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tridgell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mackerras</surname></persName>
		</author>
		<idno>TR-CS-96-05</idno>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On the scalability of data synchronization protocols for PDAs and mobile devices</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Starobinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Trachtenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A low-bandwidth network file system</title>
		<author>
			<persName><forename type="first">A</forename><surname>Muthitacharoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazieres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Taper: Tiered approach for eliminating redundancy in replica synchronization</title>
		<author>
			<persName><forename type="first">N</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tewari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Conference on File and Storage Technologies</title>
		<meeting>USENIX Conference on File and Storage Technologies</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">ACT: An audio conference tool over named data networking</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGCOMM ICN Workshop</title>
		<meeting>of SIGCOMM ICN Workshop</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
