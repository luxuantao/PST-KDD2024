<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Consistent Global Checkpoints that Contain a Given Set of Local Checkpoints</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><roleName>Member, IEEE Computer Society</roleName><forename type="first">Yi-Min</forename><surname>Wang</surname></persName>
							<email>ymwang@research.att.com</email>
							<affiliation key="aff0">
								<orgName type="institution">AT&amp;T Laboratories-Research</orgName>
								<address>
									<postCode>07974</postCode>
									<settlement>Murray Hill</settlement>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Consistent Global Checkpoints that Contain a Given Set of Local Checkpoints</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C25657ED149DB607BE8D94A164042D2C</idno>
					<note type="submission">received 1 July 1995; revised 1 Mar. 1996.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:08+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Algorithms</term>
					<term>distributed systems</term>
					<term>consistent global states</term>
					<term>distributed debugging</term>
					<term>deadlock recovery</term>
					<term>fault tolerance</term>
					<term>checkpointing</term>
					<term>rollback recovery</term>
					<term>message logging</term>
					<term>vector timestamps</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we consider the problem of constructing consistent global checkpoints that contain a given set of checkpoints. We address three important issues related to this problem. First, we define the maximum and minimum consistent global checkpoints containing a set S, and give algorithms to construct them. These algorithms are based on reachability analysis on a rollback-dependency graph. Second, we introduce a concept called "rollback-dependency trackability" that enables this analysis to be performed efficiently for a certain class of checkpoint and communication models. We define the least stringent of these models ("FDAS"), and put it in context with other models defined in the literature. Significant in this is a way to use FDAS to provide efficient rollback recovery for applications that do not satisfy perfect piecewise determinism. Finally, we describe several applications of the theorems and algorithms derived in this paper to demonstrate the capability of our approach to unify, generalize, and extend many previous works.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>checkpoint is a snapshot of the state of a process, saved on nonvolatile storage to survive process failures. It can be reloaded into volatile memory in case of a failure to reduce the amount of lost work. In a message-passing system with N processes, a global checkpoint <ref type="bibr" target="#b0">[1]</ref> is a set of N local checkpoints, one from each process. A global checkpoint M is consistent 1 if no message is sent after a checkpoint of M and received before another checkpoint of M <ref type="bibr" target="#b1">[2]</ref>. Most of the literature on checkpointing and rollback recovery considers hardware failures. The set of failed processes is uniquely determined by the physical failure, and the most recent consistent global checkpoint, called the recovery line, is uniquely determined by the volatile states of surviving processes and the nonvolatile checkpoints <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>. Many other applications of checkpointing, such as software error recovery <ref type="bibr" target="#b6">[7]</ref>, deadlock recovery <ref type="bibr" target="#b7">[8]</ref>, mobile computing <ref type="bibr" target="#b8">[9]</ref>, and distributed debugging <ref type="bibr" target="#b9">[10]</ref> pose a different problem: Given a target set of checkpoints, each from a different process, how to construct consistent global checkpoints that contain that set.</p><p>This paper has two main contributions.</p><p>1) Given a target set of checkpoints S, the motivation for finding the maximum consistent global checkpoint containing S is often clear: It minimizes the total rollback distance and hence the amount of lost work. The first contribution of this paper is to demonstrate that finding the minimum consistent global checkpoint containing S is an equally important concept that has not been explicitly identified in the literature. In general, it corresponds to the notions of "undo as much as possible during a rollback" or "move forward only if absolutely necessary during a failure-free execution." For a family of checkpoint and communication models, this concept becomes even more powerful because it is tightly coupled with dependency tracking <ref type="bibr" target="#b10">[11]</ref>. 2) In most previous work, only applications satisfying the piecewise deterministic (PWD) model <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref> can propagate the cumulative dependency information on-line in order to allow decentralized calculation of consistent global checkpoints. The second contribution of this paper is to allow such a decentralized calculation in a mixed PWD and non-PWD execution by forcing processes to take additional communication-induced checkpoints.</p><p>This paper is organized as follows. Section 2 defines rollback-dependency graphs and maximum and minimum consistent global checkpoints; the equivalence between rollback-dependency paths and zigzag paths <ref type="bibr" target="#b15">[16]</ref> is established. Section 3 derives algorithms for calculating the two consistent global checkpoints based on reachability analysis of rollback-dependency graphs, and proves their correctness. Section 4 defines rollback-dependency trackability which allows rollback dependencies to be propagated online; a family of checkpoint and communication models satisfying rollback-dependency trackability is introduced. Section 5 describes four applications of the presented theories and algorithms to demonstrate the capability of our approach to unify and generalize existing techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES 2.1 Rollback Dependency Graphs</head><p>Let c i,x (0 £ i £ N -1, x ≥ 0) denote the xth checkpoint of process P i , where i is called the process id and x the checkpoint index. Let I i,x (0 £ i £ N -1, x ≥ 1) denote the checkpoint interval (or interval) between c i,x-1 and c i,x , as shown in Fig. <ref type="figure" target="#fig_3">1a</ref>. Our presentation will be based on a directed rollback-dependency graph (or R-graph) in which each node represents a checkpoint and a directed edge is drawn from c i,x to c j,y if 1) i π j, and a message m is sent from I i,x and received in I j,y or 2) i = j and y = x + 1.</p><p>(The name "rollback-dependency graph" comes from the observation that if I i,x is rolled back, then I j,y must also be rolled back.) We assume each process P i starts its execution with an initial checkpoint c i,0 . Clearly, c i,0 cannot have any incoming edge and can have only one outgoing edge pointing to c i, <ref type="bibr" target="#b0">1</ref> .</p><p>The edges of an R-graph can be maintained locally by each process using the following direct dependency tracking <ref type="bibr" target="#b0">[1]</ref> mechanism: When process P i sends a message m from the interval I i,x , the pair (i, x) is piggybacked on m. When the receiver P j receives m in the interval I j,y , the Rgraph edge from c i,x to c j,y is recorded by P j .</p><p>The calculation of a consistent global checkpoint can be initiated by any of the N processes or a separate watchdog process <ref type="bibr" target="#b16">[17]</ref>. The initiating process broadcasts a depend- ency_request message to collect the existing direct dependencies from all the other processes, and constructs the complete R-graph. Each process stops its execution after it replies to the dependency_request message. The volatile checkpoint of each process P i , which represents the volatile state of P i when it stops the execution, and its associated direct dependencies are also included in the R-graph. An application-dependent target set of checkpoints S is determined and made available to the initiating process, which then performs reachability analysis on the R-graph to calculate a consistent global checkpoint containing S (as described in the next section). Fig. <ref type="figure" target="#fig_3">1b</ref> shows the R-graph for the example checkpoint and communication pattern <ref type="bibr" target="#b0">[1]</ref> in Fig. <ref type="figure" target="#fig_3">1a</ref>. To simplify the presentation, we use the same notation c i,x for both volatile and nonvolatile checkpoints in a given checkpoint and communication pattern.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Consistent Global Checkpoints that Contain a Given Set</head><p>In this paper, the two terms "checkpoint" and "node" will be used interchangeably; a path (or an R-path) always refers to a path in an R-graph. Additional notation is defined below.</p><p>• S (possibly with a subscript): A set of checkpoints, each from a different process; • S 1 AE S 2 : There exists a path from a checkpoint in the set S 1 to a checkpoint in the set S 2 . If S 1 (or S 2 ) contains only one checkpoint c, we use c AE S 2 (or S 1 AE c) as a simplified notation for {c} AE S 2 (or S 1 AE {c}). Also, we define c AE c. In other words, every checkpoint is reachable from itself. In general, the "AE" relation is not transitive; however, we do have that S 1 AE c and c AE S 3 implies S 1 AE S 3 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• S S 1 2</head><p>AE / : There exists no path from any checkpoint of S 1 to any checkpoint of S 2 ;</p><p>• S next : Given a set of checkpoints S, S next = {c i,x+1 : c i,x OE S such that c i,x is nonvolatile}; (the size of S next may be smaller than the size of S);</p><p>• T[i]: Given a set of checkpoints T, each from a different process, T[i] denotes the checkpoint from process P i ;</p><formula xml:id="formula_0">• index(T[i]): If T[i] = c i,x , then index(T[i]) = x.</formula><p>The definitions of the maximum and the minimum consistent global checkpoints used in this paper are based on the following partially ordered relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 1. Given two consistent global checkpoints M 1 and</head><formula xml:id="formula_1">M 2 , M 1 d M 2 if and only if index(M 1 [i]) £ index(M 2 [i]) for all 0 £ i £ N -1.</formula><p>The following lemma on the lattice property of the set of all consistent global checkpoints has been previously proved, based on the maximum-sized antichain <ref type="bibr" target="#b17">[18]</ref> model of consistent global checkpoints <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b18">[19]</ref>.</p><p>LEMMA 1. Given a checkpoint and communication pattern, let 0 denote the set of all consistent global checkpoints. Then, (0, d) forms a lattice. For any M 1 , M 2 OE 0, the join (least upper bound) J 1,2 = M 1 ⁄ M 2 and the meet (greatest lower bound) T 1,2 = M 1 Ÿ M 2 can be computed as follows.</p><p>For where max (min) gives the checkpoint with the higher (lower) index.</p><formula xml:id="formula_2">0 £ i £ N -1, J 1,2 [i] = max(M 1 [i], M 2 [i]) T 1,2 [i] = min(M 1 [i], M 2 [i])<label>(1)</label></formula><p>We next show that the set of consistent global checkpoints containing a given set S also possesses the lattice property. THEOREM 1. Given a target set of checkpoints, S, each from a different process, let 0 S denote the set of consistent global checkpoints containing S. If 0 S is not empty, then 1) (0 S , d) forms a lattice;</p><p>2) there exists a unique maximum consistent global checkpoint containing S, denoted by $ M , such that M M d $ for all M OE 0 S ; and </p><formula xml:id="formula_3">[i] = M 2 [i] = c i,x leads to J 1,2 [i] = T 1,2 [i] = c i,x by Lemma 1. Hence, J 1,2</formula><p>and T 1,2 both contain S and J 1,2 , T 1,2 OE 0 S . We have proved that (0 S , d) forms a lattice. The lattice prop- erty guarantees the existence and uniqueness of the maximum and the minimum consistent global checkpoints $ M and ( M .</p><p>The study of the lattice structures of consistent global checkpoints was inspired by the foundation work by Johnson and Zwaenepoel <ref type="bibr" target="#b4">[5]</ref>. In that paper, they proved that the set of recoverable system states that have occurred during any single execution of the system forms a lattice, and so there is always a unique maximum recoverable system state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Zigzag Paths</head><p>Netzer and Xu <ref type="bibr" target="#b15">[16]</ref> introduced the notion of zigzag paths, and derived a necessary and sufficient condition for a set of checkpoints to belong to the same consistent global checkpoint, as summarized in Definition 2 and the Consistency Theorem. Our approach is to establish the relationship between zigzag paths and R-paths in Lemma 2, and use Theorem 2, a corollary of the Consistency Theorem, to prove the properties of the maximum and minimum consistent global checkpoints. <ref type="bibr">DEFINITION</ref>  We note that zigzag paths and R-paths are not exactly equivalent notions because an R-path within the same process may not involve any message at all. However, since the Consistency Theorem concerns only zigzag paths from a checkpoint either to itself or to a checkpoint in another process, the following lemma shows that zigzag paths and R-paths are equivalent under such constraints. LEMMA 2. Given checkpoints c i,x and c j,y , where either 1) i π j or 2) x ≥ y, there is a zigzag path from c i,x to c j,y if and only if c i,x+1 AE c j,y in the R-graph.</p><p>PROOF. Suppose there is a zigzag path from c i,x to c j,y , corresponding to the message sequence as described in Definition 2. Also, suppose m 1 is sent between c i,x+n (n ≥ 0) and c i,x+n+1 and m n is received between c j,y-n¢-1 and c j,y-n¢ </p><formula xml:id="formula_4">(n¢ ≥ 0).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CONSTRUCTING MAXIMUM AND MINIMUM CONSISTENT GLOBAL CHECKPOINTS</head><p>We next describe the algorithms for constructing the unique maximum and minimum consistent global checkpoints containing a given set of checkpoints, and prove their correctness.</p><p>Algorithm $: Given a set of checkpoints S, each from a different process, start an R-graph search from every node in S next and mark all reachable nodes. </p><formula xml:id="formula_5">for all ¢ OE c M next $ . We then must have $ / $ M M next AE be- cause if there exist c M OE $ and ¢ OE c M next $ such that c¢ AE c, then S next AE c¢ AE c leads to S next AE c, a contradiction. From Theorem 2(2), $ M is consistent. $ M is the maxi- mum: If S next is empty, then $</formula><p>M consists of all volatile checkpoints and so must be the maximum; otherwise, for any global checkpoint M containing S such that  Fig. <ref type="figure" target="#fig_2">2</ref> gives example executions of the two algorithms. In Figs. <ref type="figure" target="#fig_2">2b</ref> and<ref type="figure" target="#fig_2">2c</ref>, black nodes represent the initially marked nodes for starting the search, shaded nodes represent marked nodes during the search, and checkpoints enclosed by solid lines indicate the consistent global checkpoints. In Fig. <ref type="figure" target="#fig_2">2b</ref>, to determine the maximum consistent global checkpoint containing A and B, the "next checkpoints" of A and B, namely, Y and C, respectively, are initially marked; the last unmarked node of each process after applying Algorithm $ forms the maximum consistent global checkpoint as shown. In Fig. <ref type="figure" target="#fig_2">2c</ref>, to determine the minimum consistent global checkpoint containing Y and Z, the two checkpoints Y and Z themselves are initially marked; the last marked node of each process (or the initial checkpoint as in P 3 's case) forms the minimum consistent global checkpoint.</p><formula xml:id="formula_6">$ [ ] [ ] M i M i &lt; for some 0 £ i £ N -1,</formula><formula xml:id="formula_7">M i M i [ ] [ ] &lt; ( for some 0 £ i £ N -1, ( M i [ ] cannot</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ROLLBACK-DEPENDENCY TRACKABILITY</head><p>In order to perform the reachability analysis on an R-graph, either a central process needs to collect the edge information from all processes, or the search may be performed in an inefficient, distributed fashion through a potentially large number of messages chasing the edges. One observation is that, if every checkpoint can have on-line knowledge of all the checkpoints that can reach it in the R-graph, then it is possible to develop efficient, decentralized algorithms to perform the reachability analysis. One possibility to achieve that is to use the following transitive dependency tracking mechanism <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b19">[20]</ref>: In a system with N processes, each process P i maintains a size-N transitive dependency vector D i . The entry D i [i] is initialized to 1, incremented every time a new checkpoint (or a logical checkpoint as described later) is encountered, and thus always represents the current interval index or, equivalently, the checkpoint index of the next checkpoint of P i ; every other entry D i [j], j π i, is initialized to 0 and records the highest index of any intervals of P j on which P i 's current state transitively depends. When P i sends a message m from the interval I i,x , P i 's current D i vector is piggybacked on m. When the receiver P j receives m in the interval I j,y , P j updates its D j vector to be the component-wise maximum of its current D j and the piggybacked</p><formula xml:id="formula_8">D i ; that is, D j [k] = max(D j [k], D i [k]), 0 £ k £ N -1.</formula><p>When P j reaches its next checkpoint c j,y , the vector D j at that instant is associated with c j,y and denoted by D j,y .</p><p>In the example shown in Figs. <ref type="figure" target="#fig_4">3a</ref> and<ref type="figure" target="#fig_4">3b</ref>, the message chain m 3m 2m 1 results in the transitive dependency vector D 0,2 = [2, 2, 1, 1], and so checkpoint c 0,2 knows that c 1,2 , c 2,1 , and c 3,1 are the last checkpoints of P 1 , P 2 , and P 3 , respectively, that can reach c 0,2 . In contrast, the R-paths c 2,2 AE c 0,2 and c 3,2 AE c 0,2 in Fig. <ref type="figure" target="#fig_4">3d</ref> cannot be tracked on-line. The message m 2 in Fig. <ref type="figure" target="#fig_4">3c</ref> is received by P 1 after m 1 was sent, and so the knowledge about the edge from c 2,2 to c 1,1 cannot possibly be piggybacked on m 1 . The message m 3 further demonstrates an extreme case: m 3 is generated in the future of c 0,2 and so c 0,2 has no way of knowing the existence of the edge from c 3,2 to c 2,2 . It becomes clear that, in order to allow transitive dependency tracking to carry full information about R-graph reachability, we need to impose some constraint on the checkpoint and communication pattern.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Efficient Decentralized Calculation of Consistent Global Checkpoints</head><p>We now define Rollback-Dependency trackability (or RDtrackability) which allows efficient decentralized implementations of the algorithms described in the previous section. In the next subsection, we describe a family of checkpoint and communication models that possess RDtrackability.</p><p>DEFINITION 3. A checkpoint and communication pattern is said to satisfy rollback-dependency trackability (or is RD-trackable) if the following property holds: For any two checkpoints c i,x (x π 0) and c j,y , c i,x AE c j,y if and only if D j,y [i] ≥ x.</p><p>(2)</p><p>Note that the above definition covers two cases: If j π i, it basically says, for every R-path, there exists a corresponding message chain; if j = i, then D i,y [i] = y ≥ x and (2) says that any checkpoint cannot reach earlier checkpoints of the same process in the R-graph <ref type="bibr" target="#b15">[16]</ref>.</p><p>With RD-trackability, Theorem 2, Algorithm $, and Algorithm % can then be transformed into Theorem 3, Algorithm $¢ and Algorithm %¢, respectively. THEOREM 3. With RD-trackability,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Given a set of checkpoints S, each from a different process, a consistent global checkpoint containing S exists if and only if D i,x [j] £ y for all c i,x , c j,y OE S; 2) A global checkpoint M is consistent if and only if D i,x [j]</head><p>£ y for all c i,x , c j,y OE M. Algorithm $¢: With RD-trackability, given a set of checkpoints S, each from a different process, the set of integer pairs (i, x) for every c i,x OE S is sent to every process. Algorithm %¢: With RD-trackability, given a set of checkpoints S, each from a different process, and their associated transitive dependency vectors D i,x for every c i,x OE S,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Each process P k can locally determine the kth entry of the</head><formula xml:id="formula_9">1) the minimum consistent global checkpoint ( M containing S can be computed as index M k D k c S k N i x i x ( d i n s e j = OE £ £ - max : , , ,<label>0 1 .</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) If the algorithm finds that index M i x ( [ ])</head><p>( &gt; for any c i,x OE S, then S cannot be contained in any consistent global checkpoint. We note that, while Algorithm $¢ in general requires every process to participate by scanning through its dependency vectors, Algorithm %¢ can be executed by the algorithm initiator alone if the dependency vectors associated with the checkpoints of S are also available to the initiator. This condition can be easily satisfied when S contains a single checkpoint c i,x and process P i is the initiator. In this special case, Algorithm %¢ reduces to the following Algorithm %¢¢, which has been used in several previous papers, as described in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CORRECTNESS</head><p>Algorithm %¢¢: With RD-trackability, given a single checkpoint c i,x and its associated transitive dependency vector D i,x , the  </p><formula xml:id="formula_10">( d i = £ £ - , ,<label>0 1 (3)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The FDAS Family of Rollback-Dependency Trackable Models</head><p>A class of checkpoint and communication patterns that satisfy certain common constraints is called a checkpoint and communication model. Fig. <ref type="figure" target="#fig_7">4</ref> illustrates a family of checkpoint and communication models that are RD-trackable. We will demonstrate that the new Fixed-Dependency-After-Send (FDAS) model at the top of the figure is a generalization of several previous models. By proving that the FDAS model is RD-trackable, RD-trackability of all the models in Fig. <ref type="figure" target="#fig_7">4</ref> (collectively called the FDAS family) follows immediately.</p><p>In particular, we show that the heavily-studied piecewise deterministic model can be viewed as a special case of the FDAS model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Fixed-Dependency-After-Send (FDAS) Model</head><p>The example in Figs. <ref type="figure" target="#fig_4">3c</ref> and<ref type="figure" target="#fig_4">3d</ref> indicates that R-paths are in general not on-line trackable. In particular, if a message m received in interval I i,x causes any new checkpoints to reach c i,x in the R-graph, the new R-path information would not have been propagated by any message m¢ sent from I i,x before the receipt of m. One way to avoid such a scenario is to take additional checkpoints so that the execution satisfies the Fixed-Dependency-After-Send (FDAS) model. In other words, after the first message-sending event in any interval, the transitive dependency vector remains unchanged until the next checkpoint. The FDAS structure can be maintained by requiring each process to follow the simple communicationinduced checkpointing protocol described below.</p><p>• reset the after_first_send flag to zero when taking a checkpoint; • upon sending a message, set the after_first_send flag to one if the flag is zero;</p><p>• before receiving a message, take a checkpoint if the flag is one and the transitive dependency vector is about to be changed.</p><p>We next prove RD-trackability of the FDAS model by starting with two lemmas. LEMMA 3. In the FDAS model, if there exists an R-graph edge from c i,x to c j,y , then</p><formula xml:id="formula_11">D j,y [k] ≥ D i,x [k] for all 0 £ k £ N -1.</formula><p>That is, all entries of the transitive dependency vector are nondecreasing along any R-graph edge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF. If i = j and y</head><formula xml:id="formula_12">= x + 1, then D j,y [k] = D i,x+1 [k] ≥ D i,x [k];</formula><p>otherwise, let m be any message that is sent from I i,x to I j,y and thus corresponds to the edge from c i,x to c j,y . Let D s denote the dependency vector of process P i when m was sent, and D r denote the dependency vector of process P j after m was received. Clearly, we have DEFINITION 4. A message chain from I i,x to I j,y is a sequence of messages that satisfies the following properties:</p><formula xml:id="formula_13">D j,y [k] ≥ D r [k] ≥ D s [k] for all 0 £ k £ N -</formula><p>1) it starts with a message sent from I i,x and ends with a message received in I j,y ; and 2) for any two consecutive messages m and m¢ in the sequence, if m is received by process P k , then m¢ is sent by P k after m is received.</p><p>LEMMA 4. For any two checkpoints c i,x and c j,y where i π j and x π 0, D j,y [i] ≥ x if and only if there exists a message chain from I i,x¢ , x¢ ≥ x, to I j,y¢ , y¢ £ y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF. [If part]</head><p>If the message chain exists, the first message in the chain must carry a dependency vector D m with D m [i] ≥ x. Since any entry of the vector must be nondecreasing along the chain, we have</p><formula xml:id="formula_14">D j,y [i] ≥ D j,y¢ [i] ≥ D m [i] ≥ x.</formula><p>[Only-if part] If there is no such a chain, suppose D j,y [i] ≥ x. Let e j be the event of process P j , at which D j [i] first became x. Since i π j and x π 0, e j must be a message-receiving event associated with a message m that carries D m [i] = x. Process P i cannot be the sender of m because that would result in a message chain from I i,x to I j,y¢ , y¢ £ y. By repeating the above back- tracing, we must eventually reach a process P k , k π i, which had not received any message before it sent out a message m¢ with D m¢ [i] = x. This contradicts the fact that D k [i] must have first become x at a messagereceiving event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THEOREM 4. Any checkpoint and communication pattern that</head><p>satisfies the FDAS model must be RD-trackable.</p><p>PROOF. We need to show that the if-and-only-if property described in <ref type="bibr" target="#b1">(2)</ref> holds in the FDAS model.</p><p>[Only-if part] Suppose c i,x AE c j,y . From Lemma 3, all entries of the dependency vector are nondecreasing along the R-graph edges in the FDAS model. So we have</p><formula xml:id="formula_15">D j,y [k] ≥ D i,x [k] for all 0 £ k £ N -1 and, in par- ticular, D j,y [i] ≥ D i,x [i] = x. [If part] Suppose D j,y [i] ≥ x. If j = i, then D j,y [i]</formula><p>= y and so y ≥ x, c i,x AE c j,y ; otherwise, for x π 0, there must exist a message chain from I i,x¢ , x¢ ≥ x, to I j,y¢ , y¢ £ y, according to Lemma 4. For any two consecutive messages m and m¢ along the chain, suppose m is sent from I m,u and received in I k,z and m¢ is sent from I k,z¢ , z¢ ≥ z, and received in <ref type="figure">AE c n,</ref><ref type="figure">v</ref> . Connecting all such R-paths yields an R-path from c i,x¢ to c j,y¢ . The path c i,x AE c j,y can then be obtained as c i,x AE c i,x¢ AE c j,y¢ AE c j,y .</p><formula xml:id="formula_16">I n,v . If z¢ = z, we have the R-path c m,u AE c k,z AE c n,v ; if z¢ &gt; z, we have the R-path c m,u AE c k,z AE c k,z¢</formula><p>The following corollary is an immediate result from RDtrackability of the FDAS model. COROLLARY 1. Algorithms $¢, %¢, and %¢¢, as described previously, can be used to find the maximum and the minimum consistent global checkpoints for the FDAS family.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Fixed-Dependency-Interval (FDI) Model</head><p>If we omit the after_first_send flag and force each process to take a checkpoint before processing any message which is about to change the transitive dependency vector, then we have the Fixed-Dependency-Interval (FDI) model; that is, the dependency vector remains unchanged throughout any checkpoint interval. The FDI model clearly possesses the FDAS structure and is therefore RD-trackable. A variation of the FDI model has been used in the Programmer-Transparent Coordination scheme <ref type="bibr" target="#b20">[21]</ref> in which additional branch recovery points are taken inside the recovery blocks to avoid the domino effect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">No-Receive-After-Send (NRAS) Model</head><p>Another special case of the FDAS model is to retain the af- ter_first_send flag, but take a checkpoint before processing any message if the flag is one, without checking whether or not the dependency vector will be changed. This effectively disallows any message to be received in any checkpoint interval once a message is sent, hence the name No-Receive-After-Send (NRAS) model. The NRAS model is equivalent to Russell's MRS model <ref type="bibr" target="#b21">[22]</ref> where M stands for Mark (or checkpoint), R for Receive and S for Send.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Checkpoint-After-Send (CAS) Model</head><p>One way to achieve the NRAS property is to end the current checkpoint interval whenever a message is sent, which we called the Checkpoint-After-Send (CAS) model. The scheme described by Wu et al. <ref type="bibr" target="#b22">[23]</ref> and Wu and Fuchs <ref type="bibr" target="#b23">[24]</ref> basically used the CAS model to eliminate any rollback propagation and hence the domino effect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.5">Checkpoint-Before-Receive (CBR) Model</head><p>By shifting the checkpoints in the CAS model from the sender side to the receiver side, the NRAS property can still be preserved. In the Checkpoint-Before-Receive (CBR) model, a checkpoint is placed before every message-receiving event. Since any checkpoint interval can have at most one message-receiving event and it must appear at the very beginning of the interval, dependency vector remains unchanged throughout any interval and so the CBR model also satisfies the FDI property, as shown in Fig. <ref type="figure" target="#fig_7">4</ref>. We next show that the piecewise deterministic (PWD) model <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b13">[14]</ref> can be viewed as an example of the CBR model.</p><p>In the PWD model, each process execution is divided into deterministic state intervals S i,x bounded by messagereceiving events or other nondeterministic events, as illustrated in Fig. <ref type="figure" target="#fig_8">5a</ref>. It is assumed that every nondeterministic event can be identified, recorded (or logged), and replayed. As a result, every process state can be recreated by replaying the event logs in their original order, even though the state is not directly checkpointed. For example, process P i in Fig. <ref type="figure" target="#fig_8">5a</ref> can recreate the state interval S i,x+1 by restoring the physical checkpoint C, and replaying m x , e, and m y in that order. Conceptually, it can be modeled as having an additional logical checkpoint <ref type="bibr" target="#b24">[25]</ref> at the end of each state interval, as shown in Fig. <ref type="figure" target="#fig_8">5b</ref>. The PWD model can then be viewed as having a logical checkpoint before every message-receiving event and so it must satisfy the CBR model.</p><p>In order to allow a uniform presentation for both physical and logical checkpoints, we will use the following terminology in later discussions: "taking a logical checkpoint" means "making the logical checkpoint nonvolatile" or, more precisely, "logging onto stable storage all the messages between the logical checkpoint and its immediate previous physical checkpoint."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.6">Checkpoint-After-Send-Before-Receive (CASBR) Model</head><p>The above logical checkpoint model was described in the context of recovery, which typically reconstructs an entire state interval. In general, the PWD model can be described as having a logical checkpoint anywhere that may be convenient, and so can be made as restrictive as possible. One example is the Checkpoint-After-Send-Before-Receive (CASBR) model which has a checkpoint after every message-sending event as well as before every message-receiving event. We will show in the next section that the CASBR model has been used in the debugging literature to introduce the notion of causal distributed breakpoints <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.7">Discussions</head><p>Making a program execution conform to the FDAS model generally requires processes to take additional checkpoints before receiving certain messages. The disadvantage is higher failure-free overhead. The advantage is that rollback dependencies can be propagated on-line through transitive dependency tracking so that less information needs to be exchanged in case of failure recovery. Such a trade-off may not be desirable for applications in which the primary performance measure is total execution time. For example, for most long-running scientific applications, an optimistic approach that minimizes failure-free overhead at the expense of recovery efficiency always wins because failures are rare events. However, for service-providing applications in which the primary performance measure is service availability <ref type="bibr" target="#b24">[25]</ref>, the above trade-off is often justifiable because of the following characteristics: First, such applications typically employ nontransparent critical-data checkpointing <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b25">[26]</ref>, so the checkpoint size is much smaller and checkpoint overhead is much lower; second, the underlying systems are usually designed to have extra capacities which can absorb reasonable failure-free overhead without causing noticeable service degradation; finally, fast recovery is extremely important because, while short system down time may not result in any service down time from customers' point of view, system down time that exceeds certain threshold may have a large negative impact on service quality. For example, many telecommunications systems have adopted pessimistic techniques that provide fast recovery at the expense of higher failure-free overhead <ref type="bibr" target="#b26">[27]</ref>.</p><p>Since the additional checkpoint overhead incurred by FDAS depends on the run-time checkpoint and communication pattern, to determine the viability of FDAS for particular applications would require implementation or simulation results which are beyond the scope of this paper. A class of applications that would most likely benefit from the FDAS model are service-providing applications whose executions satisfy the PWD model most of the time <ref type="bibr" target="#b27">[28]</ref>. In such applications, a small number of additional checkpoints can be taken to enforce the FDAS model in order to preserve the advantages of PWD.</p><p>The main purpose of introducing various models in the FDAS family is to provide a uniform view for several existing techniques that use communication-induced checkpointing to achieve RD-trackability in different application domains. As demonstrated in the next section, this approach has the following advantage: the models at the bottom of Fig. <ref type="figure" target="#fig_7">4</ref> are more restrictive than those at the top, and so in general require more additional checkpoints to be taken. Some previous work <ref type="bibr" target="#b8">[9]</ref> requires RD-trackability, but derives algorithms to maintain a more restrictive model than necessary. The overhead of their algorithms can be immediately reduced by maintaining the least restrictive FDAS model. When desirable, these models can also be used to provide a further trade-off between failure-free overhead and recovery efficiency. For example, although moving from FDAS to CASBR does not improve RDtrackability, it allows even faster recovery at the expense of higher failure-free overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">APPLICATIONS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Software Error Recovery</head><p>Although most rollback-recovery techniques are designed for tolerating transient hardware failures, studies have shown that most software errors in production software are also transient, and rollback retry can often provide an effective way of bypassing software bugs <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref>. The software fault tolerance library libft from AT&amp;T Bell Laboratories was designed to provide applications with rollback capabilities, and has been successfully integrated into various telecommunications applications to improve service availability <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref>. To further enhance the capability of software error recovery, a progressive retry mechanism has been developed and built into libft <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b32">[33]</ref>. The basic concept of progressive retry is to start the retry with a localized recovery of the failed process, and then escalate the recovery to a higher level by gradually increasing the scope of rollback when a previous retry fails. Experiences of using progressive retry to bypass boundary condition errors in a telecommunication billing system and a cross-connection system have been reported <ref type="bibr" target="#b24">[25]</ref>.</p><p>The concept of maximum and minimum consistent global checkpoints is used in progressive retry to improve recovery performance. We use the communication pattern in Fig. <ref type="figure" target="#fig_9">6a</ref> as an example. Suppose a software error is detected at the point marked "X." In the early steps of progressive retry, the goal is to minimize rollback distance using maximum consistent global checkpoints in order to achieve fast and localized recovery. Suppose a diagnosis procedure determines that the system should roll back to a state containing checkpoints Y and Z to maximize the chance of recovery because Y and Z do not contain the part of process state which eventually leads to a boundary condition. Algorithm $ can then be used to find the maximum consistent global checkpoint M containing Y and Z, as shown in Fig. <ref type="figure" target="#fig_9">6b</ref>.</p><p>If all early steps fail, the goal of later steps is to undo as much potentially erroneous state as possible by using a global rollback. However, if the rollback will involve revoking some outputs sent to the clients (as indicated by the shaded arrows in Fig. <ref type="figure" target="#fig_9">6a</ref>), it is often desirable to first perform a retry that does not revoke any output. For example, an output may involve setting a number of hardware switches to make a connection between clients, and revoking the output means tearing down that connection. For the example in Fig. <ref type="figure" target="#fig_9">6</ref>, this translates into finding the minimum consistent global checkpoint containing A and B, and Algorithm % can be used to obtain the global checkpoint M¢, as shown in Fig. <ref type="figure" target="#fig_9">6b</ref>.</p><p>Although rollback recovery techniques have been applied to telecommunications systems with great success <ref type="bibr" target="#b33">[34]</ref>, several limitations and weakness have also been observed. First, rollback recovery is not suitable for applications that are tightly controlled by real time. For example, when a periodic reporting process fails, it is often more important to get ready for the next report than to roll back its receivers. Second, rollback recovery may not be the best approach if the part of process state affected by each message is well-defined. For example, when a message sender is rolled back, it may be much more efficient for the receiver to cancel the effect of that message than to roll back the entire state. Finally, most rollback recovery techniques do not undo file updates. If an application performs nonidempotent file operations such as append( ), such a limitation can result in corrupted files <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b35">[36]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Causal Distributed Breakpoints</head><p>Fig. <ref type="figure" target="#fig_10">7a</ref> shows a checkpoint and communication pattern with logical checkpoints under the PWD assumption. Suppose A is a breakpoint specified by a debugger user, and the objective is to find a consistent distributed breakpoint that contains A. The minimum consistent global checkpoint containing A, which is computed as {A, B, C, D} by Algorithm %¢¢, is one possible choice. However, Fowler and Zwaenepoel <ref type="bibr" target="#b9">[10]</ref> argued that a distributed breakpoint containing A should reflect all the interesting states that causally affect A. For example, the state of P 1 at the point "X," which immediately follows the sending event of m 3 , may provide useful information as to why m 3 is generated to causally affect A. Such information may be destroyed if P 1 's state is reconstructed up to B. They then define a causal distributed breakpoint which is basically the minimum consistent global checkpoint containing a given breakpoint with an additional logical checkpoint (conceptually) being added to immediately follow every message-sending event, as illustrated by the CASBR structure in Fig. <ref type="figure" target="#fig_10">7b</ref>. Since it still satisfies the FDAS property, Algorithm %¢¢ can be used to determine the causal distributed breakpoint containing A to be {A, X, Y, Z}. Again, we can generalize the definition of causal distributed breakpoints to allow multiple userspecified breakpoints, and use Algorithm %¢ to compute the generalized causal distributed breakpoints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Guaranteed Deadlock Recovery</head><p>We next describe a deadlock recovery application which uses Theorem 2 for victim selection <ref type="bibr" target="#b36">[37]</ref> and uses Algorithm $ to determine the rollback state. Fig. <ref type="figure" target="#fig_11">8a</ref> gives an example of deadlocks in message-passing systems where request and grant are resource-related messages, and m is an interprocess communication message. Process P 1 sends a request message to resource manager M 1 , and M 1 grants P 1 the exclusive access to resource R 1 . Similarly, P 2 obtained the exclusive access to resource R 2 from M 2 . Later, a deadlock occurs because P 1 is waiting for R 2 while holding R 1 , and P 2 is waiting for R 1 while holding R 2 . One possibility to resolve the deadlock is to roll back M 1 to checkpoint A in order to reclaim R 1 from P 1 , and grant R 1 to P 2 instead. However, rollback propagation along the messages marked by dark arrows requires P 2 to roll back to checkpoint Z, which forces P 2 to withdraw its request for R 1 . Since the request from P 1 is the only outstanding request when M 1 is restarted, the system is likely to get into the same deadlock again. The example shows that message dependencies have to be taken into account when selecting a victim to resolve a deadlock. One way to guarantee deadlock recovery <ref type="bibr" target="#b7">[8]</ref> is to ensure that, when trying to reclaim a resource R i to give it to process P j , P j should remain in a state in which it is still waiting for R i . In other words, for the example in Fig. <ref type="figure" target="#fig_11">8</ref>, we would like to test if a consistent global checkpoint can be found to contain the checkpoint pair {A, B} or {C, D}. To also minimize the rollback distance, we can use Algorithm $ to try to find the maximum consistent global checkpoint containing one of the pairs. Since B (or D) is a volatile checkpoint and does not have a "next checkpoint," we only need to start the search from a (or c). The path a AE D AE B (as shown in dark edges in Fig. <ref type="figure" target="#fig_11">8b</ref>) indicates that A and B cannot belong to the same consistent global checkpoint by Theorem 2. In contrast, the absence of a path from c to either C or D indicates that Algorithm $ can find the maximum consistent global checkpoint {D, a, C, Y} containing both C and D. Hence, deadlock recovery can be guaranteed by forcing M 2 to roll back and then give resource R 2 to P 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Global Checkpoints Involving Mobile Hosts</head><p>Acharya and Badrinath <ref type="bibr" target="#b8">[9]</ref> described an algorithm for collecting consistent global checkpoints in distributed applications running on mobile computers. We will show that their algorithm basically computes the minimum consistent global checkpoint containing a given checkpoint. The intention is not to determine the earliest consistent global check-point, but to minimize the searching cost for locating the needed checkpoints by taking advantage of the simplicity and efficiency of Algorithm %¢¢ under the NRAS model.</p><p>A typical architecture for supporting mobile computing is illustrated in Fig. 9 <ref type="bibr" target="#b37">[38]</ref>. The entire geographic area is partitioned into wireless cells and each cell is covered by a Mobile Support Station (MSS) which provides wireless interface to communicate with mobile hosts (MH) in the cell. This architecture introduces three new issues for collecting consistent global checkpoints: first, the nonvolatile storage attached to mobile hosts cannot be considered as stable storage; second, mobile hosts may move from one cell to another; third, a mobile host may voluntarily disconnect from the rest of the network.</p><p>To address the first issue, the authors proposed that the checkpoints of a process running on a mobile host should be stored in its local MSS. Consequently, as a mobile host moves between cells, its successive checkpoints may be stored on different MSSs. To facilitate locating the checkpoints, each process P i maintains a location vector L i in which L i [j] records the cell id of the MSS that stores checkpoint c j,Di <ref type="bibr">[j]</ref> . The vector L i is also piggybacked on each outgoing message m, and the receiver P k of m sets L k [j] = L i [j] when it sets D k [j] = D i [j] in the component-wise maximum operation. Fig. <ref type="figure" target="#fig_13">10</ref> gives an example where P 2 moves between cells and P 3 voluntarily disconnects. Additional checkpoints (represented by horizontal bars) need to be taken under three conditions:  denotes the location vector of P i when checkpoint c i,x is taken.</p><p>The derivation in Section 4 shows that the above scheme can be easily improved in two directions. First, Algorithm %¢, instead of Algorithm %¢¢, can be used to compute the minimum consistent global checkpoint containing more than one checkpoint (for example, multiple checkpoints stored in the same MSS). In general, such a generalization allows us to obtain a "more recent" consistent global checkpoint, while still allowing the constituent checkpoints to be easily located. Second, processes need to maintain only FDAS structure, instead of NRAS, which can reduce the number of additional checkpoints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">SUMMARY</head><p>This paper has extended traditional recovery-related problems in two dimensions. First, the recovery lines may not always be uniquely determined by physical hardware failures; they can be specified to contain a target set of checkpoints for other recovery purposes such as software error recovery and deadlock recovery. While the maximum consistent global checkpoint appears to be the most natural concept for recovery, the minimum consistent global checkpoint is an equally important concept as it provides a unified framework for many recovery and debugging issues such as checkpointing mobile applications and causal distributed breakpoints. Second, for applications which are mostly piecewise deterministic, the notion of rollback dependency trackability and the model of Fixed-Dependency-After-Send allow the benefits of perfect piecewise determinism (such as efficient decentralized recovery line calculation) to be preserved.  cussions, and to Gaurav Suri (D.E. Shaw), Robert Netzer (Brown), Emerald Chung (Lucent), Arup Acharya (NEC), and the referees for their valuable comments.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. (a) Checkpoint and communication pattern (nonvolatile checkpoints are marked by black bars and volatile checkpoints are marked by shaded triangles), (b) rollback-dependency graph (R-graph).</figDesc><graphic coords="2,122.52,59.28,324.88,138.82" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>PROOF. 1 ) 1 .</head><label>11</label><figDesc>From Theorem 2, a consistent global checkpoint containing S exists if and only if, for every c i,x , c j,y OE S, Since y + 1 π 0, the above condition translates into D i,x [j] &lt; y + 1 or equivalently D i,x [j] £ y by Definition 3. The proof for Part 2) is similar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. (a) Example checkpoint and communication pattern; (b) maximum consistent global checkpoint containing A and B; (c) minimum consistent global checkpoint containing Y and Z.</figDesc><graphic coords="5,64.53,59.28,428.96,318.53" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>PROOF. 1 )</head><label>1</label><figDesc>In Algorithm %, there are two possible cases for each process P k with respect to any c i,x OE S. Case 1: Some checkpoints of P k can reach c i,x . Let c k,w denote the last one of them. With RD-trackability, c k,w AE c i,x and D i,x [k] ≥ w and D i,x [k] &lt; w + 1 (or c k,w+1 does not exist), respectively; hence, D i,x [k] = w. Case 2: None of the checkpoints of P k can reach c i,x . In particular, into D i,x [k] &lt; 1 under RD-trackability. Since D i,x [k] must be nonnegative, we have D i,x [k] = 0. Therefore, max({D i,x [k] : c i,x OE S}) either gives the index of the last checkpoint of P k , that can reach any c i,x OE S, or gives zero when none of the checkpoints of P k can reach any c i,x OE S. Compared to Algorithm %, this equivalently gives the index of the checkpoint of P k belonging to the minimum consistent global checkpoint containing S, and so exists c j,y OE S such that D j,y [i] &gt; x and so c i,x+1 AE c j,y by definition of RD-trackability.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. On-line tracking of R-paths. (a) and (b): The path c 3,1 AE c 0,2 can be tracked on-line; (c) and (d): the path c 3,2 AE c 0,2 cannot be tracked on-line.</figDesc><graphic coords="6,121.32,59.28,327.26,259.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>minimum consistent global checkpoint ( M containing c i,x can be computed as index M k D k k N i x</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>1 because of the component-wise maximum operation in the updates of dependency vectors. From the definition of the FDAS model, we have D i,x = D s . Therefore, we have D j,y [k] ≥ D i,x [k] for all 0 £ k £ N -1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. The FDAS family of models that are RD-trackable. (An arrow from, for example, the FDAS model to the NRAS model indicates that NRAS is a special case of FDAS.)</figDesc><graphic coords="7,144.28,59.28,269.50,168.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. (a) Piecewise deterministic model consisting of state intervals; (b) the CBR model of piecewise determinism consisting of logical checkpoint intervals.</figDesc><graphic coords="9,136.74,59.28,296.41,172.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. (a) Checkpoint and communication pattern with outputs (shaded arrows); (b) R-graph (M ¢ is the minimum consistent global checkpoint containing {A, B } and M is the maximum consistent global checkpoint containing {Y, Z }.</figDesc><graphic coords="10,115.13,59.28,339.67,159.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Piecewise deterministic model (a) with logical checkpoints (CBR); (b) with additional logical checkpoints (CASBR).</figDesc><graphic coords="11,87.72,59.28,382.62,159.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Guaranteed deadlock recovery: (a) Resource requests resulting in a deadlock; (b) R-graph.</figDesc><graphic coords="11,111.18,251.19,335.69,138.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Typical architecture for mobile computing with one Mobile Support Station (MSS) supporting all Mobile Hosts (MHs) in each cell.</figDesc><graphic coords="12,126.22,59.28,317.49,157.58" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Checkpoint and communication pattern with process P 2 moving between cells and P 3 disconnected. (Horizontal bars represent the addi- tional checkpoints for mobile applications.)</figDesc><graphic coords="12,156.57,249.45,256.79,153.78" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>OE 0 S . PROOF. For any M 1 , M 2 OE 0 S , we must have M 1 , M 2 OE 0 and so J 1,2 , T 1,2 OE 0. For any c i,x OE S, M 1</figDesc><table><row><cell>3) there exists a unique minimum consistent global checkpoint containing S, denoted by ( M , such that ( M M d for all M</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>1 )</head><label>1</label><figDesc>If any node of S is marked during the search, then S cannot belong to any consistent global checkpoint; 2) otherwise, after the search is finished, the set $ M of the last unmarked node of each process forms the maximum consistent global checkpoint containing S. If any node of S is marked, we have S next AE S and so S cannot belong to any consistent global checkpoint by Theorem 2(1). 2) otherwise, $ M exists: the existence of $ M is guaranteed by the existence of the initial checkpoints, any of which clearly cannot belong to S next and cannot be reachable from S next because of the absence of incom-</figDesc><table><row><cell>CORRECTNESS PROOF.</cell></row><row><cell>1)</cell></row></table><note><p>ing edges. $ M contains S: for any c OE S, since c is unmarked, and c next either does not exist or is marked (because it is reachable from itself), we have c M OE $ . $ M is consistent: If S next is empty, then $ M consists of all volatile checkpoints and must be consistent because no message is sent after any volatile checkpoint; otherwise, by construction, S c next AE / for all c M OE $ and S next AE c¢</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>be an initial checkpoint and so we must have M next AE S (by construction) and so M next AE M; hence, M is inconsistent by Theorem 2(2). We have proved that</figDesc><table><row><cell>( M</cell><cell>d</cell><cell>M</cell></row><row><cell cols="3">for any consistent global checkpoint M containing S, and so ( M is the minimum.</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The author wishes to express his sincere thanks to David Johnson (CMU) and Jian Xu (Brown) for their valuable dis-</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Consistent Global Checkpoints Based on Direct Dependency Tracking</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lowry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="223" to="230" />
			<date type="published" when="1994-05">May 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Distributed Snapshots: Determining Global States of Distributed Systems</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Computing Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="63" to="75" />
			<date type="published" when="1985-02">Feb. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Independent Checkpointing and Concurrent Rollback for Recovery-An Optimistic Approach</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bhargava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Lian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Reliable Distributed Systems</title>
		<meeting>IEEE Symp. Reliable Distributed Systems</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Space Reclamation for Uncoordinated Checkpointing in Message-Passing Systems</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-08">Aug. 1993</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Electrical and Computer Eng., Univ. of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="462" to="491" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An Algorithm for Minimizing Roll Back Cost</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hadzilacos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. Principles of Database Systems</title>
		<meeting>ACM Symp. Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="93" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Maximum and Minimum Consistent Global Checkpoints and Their Applications</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Reliable Distributed Systems</title>
		<meeting>IEEE Symp. Reliable Distributed Systems</meeting>
		<imprint>
			<date type="published" when="1995-09">Sept. 1995</date>
			<biblScope unit="page" from="86" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Guaranteed Deadlock Recovery: Deadlock Resolution with Rollback Propagation</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Merritt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Romanovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Pacific Rim Int&apos;l Symp. Fault-Tolerant Systems</title>
		<meeting>Pacific Rim Int&apos;l Symp. Fault-Tolerant Systems</meeting>
		<imprint>
			<date type="published" when="1995-12">Dec. 1995</date>
			<biblScope unit="page" from="92" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Checkpointing Distributed Applications on Mobile Computers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Badrinath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Int&apos;l Conf. Parallel and Distributed Information Systems</title>
		<meeting>Third Int&apos;l Conf. Parallel and Distributed Information Systems</meeting>
		<imprint>
			<date type="published" when="1994-09">Sept. 1994</date>
			<biblScope unit="page" from="73" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Causal Distributed Breakpoints</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int&apos;l Conf. Distributed Computing Systems</title>
		<meeting>IEEE Int&apos;l Conf. Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="134" to="141" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient Distributed Recovery Using Message Logging</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Welch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eighth ACM Symp. Principles of Distributed Computing</title>
		<meeting>Eighth ACM Symp. Principles of Distributed Computing</meeting>
		<imprint>
			<date type="published" when="1989-08">Aug. 1989</date>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Volatile Logging in n-Fault-Tolerant Distributed Systems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Strom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Bacon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Yemini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Fault-Tolerant Computing Symp</title>
		<meeting>IEEE Fault-Tolerant Computing Symp</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="44" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Crash Recovery with Little Overhead</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-Y</forename><surname>Juang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int&apos;l Conf. Distributed Computing Systems</title>
		<meeting>IEEE Int&apos;l Conf. Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="454" to="461" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Manetho: Transparent Rollback-Recovery with Low Overhead, Limited Rollback and Fast Output Commit</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Elnozahy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="526" to="531" />
			<date type="published" when="1992-05">May 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Message Logging: Pessimistic, Optimistic, and Causal</title>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Marzullo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int&apos;l Conf. Distributed Computing Systems</title>
		<meeting>IEEE Int&apos;l Conf. Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="229" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Necessary and Sufficient Conditions for Consistent Global Snapshots</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H B</forename><surname>Netzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="165" to="169" />
			<date type="published" when="1995-02">Feb. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Software Implemented Fault Tolerance: Technologies and Experience</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kintala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Fault-Tolerant Computing Symp</title>
		<meeting>IEEE Fault-Tolerant Computing Symp</meeting>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
			<biblScope unit="page" from="2" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">I</forename><surname>Anderson</surname></persName>
		</author>
		<title level="m">Combinatorics of Finite Sets</title>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Clarendon Press</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Checkpoint Space Reclamation for Uncoordinated Checkpointing in Message-Passing Systems</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Y</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="546" to="554" />
			<date type="published" when="1995-05">May 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Optimistic Recovery in Distributed Systems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Strom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yemini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Computing. Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="204" to="226" />
			<date type="published" when="1985-08">Aug. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A Scheme for Coordinated Execution of Independently Designed Recoverable Distributed Processes</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Abouelnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Fault-Tolerant Computing Symp</title>
		<meeting>IEEE Fault-Tolerant Computing Symp</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="130" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">State Restoration in Systems of Communicating Processes</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Russell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="194" />
			<date type="published" when="1980-03">Mar. 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Error Recovery in Shared Memory Multiprocessors Using Private Caches</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="231" to="240" />
			<date type="published" when="1990-04">Apr. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Recoverable Distributed Shared Virtual Memory</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="460" to="469" />
			<date type="published" when="1990-04">Apr. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Progressive Retry for Software Error Recovery in Distributed Systems</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Fault-Tolerant Computing Symp</title>
		<meeting>IEEE Fault-Tolerant Computing Symp</meeting>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
			<biblScope unit="page" from="138" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Software Tools and Libraries for Fault Tolerance</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kintala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin Technical Committee on Operating Systems and Application Environments (TCOS)</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="5" to="9" />
			<date type="published" when="1995">1995</date>
			<pubPlace>Winter</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Why Optimistic Message Logging Has Not Been Used in Telecommunications Systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Fault-Tolerant Computing Symp</title>
		<meeting>IEEE Fault-Tolerant Computing Symp</meeting>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="459" to="463" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">When Piecewise Determinism Is Almost True</title>
		<author>
			<persName><forename type="first">E</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Suri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Pacific Rim Int&apos;l Symp. Fault-Tolerant Systems</title>
		<meeting>Pacific Rim Int&apos;l Symp. Fault-Tolerant Systems</meeting>
		<imprint>
			<date type="published" when="1995-12">Dec. 1995</date>
			<biblScope unit="page" from="66" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">High-Availability Computer Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Siewiorek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="page" from="39" to="48" />
			<date type="published" when="1991-09">Sept. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Faults, Symptoms, and Software Fault Tolerance in the Tandem GUARDIAN90 Operating System</title>
		<author>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Fault-Tolerant Computing Symp</title>
		<meeting>IEEE Fault-Tolerant Computing Symp</meeting>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
			<biblScope unit="page" from="20" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A Software Fault Tolerance Platform</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kintala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Practical Reusable Software</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Krishnamurthy</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="223" to="245" />
			<date type="published" when="1995">1995</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Software Fault Tolerance in the Application Layer</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kintala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Fault Tolerance, M.R. Lyu</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="231" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">An Implementation and Performance Measurement of the Progressive Retry Technique</title>
		<author>
			<persName><forename type="first">G</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kintala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE Int&apos;l Computer Performance and Dependability Symp</title>
		<imprint>
			<biblScope unit="page" from="41" to="48" />
			<date type="published" when="1995-04">Apr. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Components for Software Fault Tolerance and Rejuvenation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kintala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AT&amp;T Technical J</title>
		<imprint>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1996-03">Mar. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Checkpointing and Its Applications</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Y</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kintala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Fault-Tolerant Computing Symp</title>
		<meeting>IEEE Fault-Tolerant Computing Symp</meeting>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="22" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A Recoverable Object Store</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Strom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Yemini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Bacon</surname></persName>
		</author>
		<idno>II-215-II-221</idno>
	</analytic>
	<monogr>
		<title level="j">Proc. Hawaii Int&apos;l Conf</title>
		<imprint>
			<date type="published" when="1988-01">Jan. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Deadlock Detection in Distributed Databases</title>
		<author>
			<persName><forename type="first">E</forename><surname>Knapp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="303" to="328" />
			<date type="published" when="1987-12">Dec. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Mobile Wireless Computing</title>
		<author>
			<persName><forename type="first">T</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Badrinath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="18" to="28" />
			<date type="published" when="1994-10">Oct. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
