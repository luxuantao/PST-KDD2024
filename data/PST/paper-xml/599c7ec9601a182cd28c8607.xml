<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Control-flow checking using branch sequence signatures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Liping</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Linlin</forename><surname>Ci</surname></persName>
							<email>cilinlin_bit@126.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author>
							<persName><roleName>ChengBin</roleName><forename type="first">Wei</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Control-flow checking using branch sequence signatures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/iThings-GreenCom-CPSCom-SmartData.2016.174</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T14:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Control-flow integrity</term>
					<term>Dynamic measurement</term>
					<term>Control-flow errors</term>
					<term>Error detection</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Dynamic checking the integrity of software at runtime is always a hot and difficult spot for trusted computing. In this paper we present a lightweight approach, Control-flow checking using branch sequence signatures (CFCBS), to checking violation of control flow integrity at run-time. Our solution assigns a unique branch sequence signature, which enhances the capability of fault coverage, to each basic block at compile time and upgrades the branch sequence signature when the program is executed. Control flow faults can be detected by comparing the run-time signature with the saved one at compile time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Distributed computing and worldwide business transactions over open networks, such as the Internet, increasingly demand for secure communication and secure operation due to rising online fraud <ref type="bibr" target="#b0">[1]</ref> and software attacks <ref type="bibr" target="#b2">[2]</ref>. Some of these vulnerabilities are due to the complexity and architectural constraints of the underlying execution environment (CPU hardware and commodity operating systems), some are due to poor software development practices and lack of software security in applications. In this context, the integrity of system software and applications is a fundamental requirement and necessary consequence in order to ensure trust in the computing infrastructure <ref type="bibr" target="#b3">[3]</ref>.</p><p>Trusted Computing as proposed by the Trusted Computing Group (TCG) offers a technology that is able to verify the integrity of executable content through remote attestation. The cores of trusted computing technology are trusted computing base and trusted chain <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5]</ref>,and trusted measurement is a key problem of this technology <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b7">7]</ref>. Trusted computing treats the integrity as a fundamental attribute of trust. However, such attestation mechanisms provide only integrity verification at load-time but not at run-time: An attacker can change the flow of execution of a program, e.g., via buffer overflow attacks that are despite numerous countermeasures still a great security concern in software systems today. SEU-induced soft errors have been known as one of the major threats to functionality and reliability of space-borne computers and their host spacecrafts. Soft errors may be explicit bit flips in latches or memories, or glitches in combinational logics that can propagate and be captured in latches <ref type="bibr" target="#b8">[8]</ref>. If not handled properly, such errors can cause illegal accesses to peripherals, memory overflow, data corruption, false and sometimes fatal data or action outputs, and so on. Therefore, it is necessary to detect and correct errors in control flows hopefully before damages are caused.</p><p>Various control-flow checking techniques have been proposed in previous papers. Many of them are based on additional hardware or modification of the existing hardware and cannot guarantee portability to various platforms. On the other hand, when the hardware cannot be changed, a pure software method is necessary. The basic idea of software control flow checking is to partition the program into basic blocks (branch-free parts of code) <ref type="bibr" target="#b9">[9]</ref>. For each block a deterministic signature is calculated and saved somewhere during compile time; then errors can be detected by comparing the run-time signature with the saved one. This method does not require any additional hardware and can be automatically applied for software control flow checking, the most important three solutions proposed in the literature are the techniques called Enhanced Control Flow Checking Using Assertions (ECCA) <ref type="bibr" target="#b10">[10]</ref> and Control Flow Checking by Software Signatures (CFCSS) <ref type="bibr" target="#b11">[11]</ref> and On-line Control Flow Error Detection Using Relationship Signatures Among Basic Blocks(RSCFC) <ref type="bibr" target="#b9">[9]</ref>. ECCA, firstly, assigns a unique prime number identifier (BID) to each basic block of a program; then a test assertion and a set assignment, which are composed of a global integer variable (id) and the BID, are individually inserted into the beginning and the end of each basic block. During the execution, the id is dynamically updated and it can transfer a control flow error into a divide by zero error. ECCA is able to detect all the single inter-block control flow error, except the faults that cause an incorrect decision on a conditional branch. Due to its complexity of the test and set assertions, ECCA has more higher memory and time overhead than CFCSS, which also assigns a unique signature si to each basic block and uses a global variable (G) to contain the run-time signature. When control transfers from one basic block to another, CFCSS uses the first instruction to compute the signatures of the destination block from the signature of the source block and a precomputed variable d, which is the EXOR difference between the signatures of the source and destination blocks, and updates G with the value at the beginning of the basic block; in the One of the works in this field is Relationship Signature CFC (RSCFC) in which the program is divided into some basic blocks. In the first stage, the relationship between blocks is extracted and then based on the kind of the relationship, a signature is assigned to each block in which the existing relationships are coded in it. The faults in the control flow of the program are detected by logic AND the runtime signatures with the information at the beginning and end of the blocks. In comparison to the previous works, this method has more fault coverage and a better efficiency and it also consumes more memory.</p><p>We propose a control flow checking technology using branch sequence (CFCBS) that is able to detect this new class of attack. CFCBS is a software-only solution and does not require any special hardware. This solution is inspired by <ref type="bibr" target="#b11">[11]</ref> and <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b14">14]</ref> and absorbs their advantages. CFCBS embed measurement instructions into applications using code rewriting techniques and check the control flow at runtime. The contributions of this work are as follows:</p><p>A novel branch sequence signature which contains the information of path length and branch selecting is employed to detect control flow fault.</p><p>A coarse granularity checking mechanism that checking instructions is only inserted into nodes whose in-degree is larger than two is exploited.</p><p>Several Fault Injection experiments have been performed on a set of benchmark programs, considering a particular fault model that emulates control flow errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. THE PROPOSED APPROACH</head><p>There is a trade-off between the error coverage obtained and the associated overhead involved among different techniques, depending on the number of checks inserted and the aliasing allowed in the particular technique <ref type="bibr" target="#b9">[9]</ref>. Fundamentally, there are three critical aspects of any signature based control flow protection scheme. The first is signature assignments, the second is signature computations (or updates) in each BB, and the third is signature comparisons (or checking) to check for erroneous control flow. The capacity of error coverage depends on signature assignments. Signature computations and signature comparisons are the main contributors to the performance overhead of signature-based control flow checking schemes. To enhance capacity of error coverage, we design a branch sequence signature which contains the information of path length and branch selecting for every BB. To reduce performance overhead, we insert only one instruction into each BB for signature updating, and perform signature comparing in branch-fan-in nodes instead of every node.</p><p>We introduce here some terminology that is used in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Basic Block</head><p>A Basic Block (BB) is a maximal set of ordered nonbranching instructions (except in the last instruction) or branch destinations (except in the first instruction) in which the execution always enters at the first instruction and leaves via the last instruction <ref type="bibr" target="#b10">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract Basic Block</head><p>An abstract basic Block does not contain any other effective instructions except an unconditional jump instruction and has only one successor node and one predecessor node <ref type="bibr" target="#b12">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Program Flow Graph</head><p>A program P can be represented with a graph composed of a set of nodes V and a set of edges E, P{V,E}, where v={v1,v2,…,vi ,…, vn} and E={e1,e2,…, ei ,…, em} Each node vi represents a basic block and each edge ei represents the branch bri,j from vi to vj .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Control-flow error</head><p>A control-flow error is said to have occurred if the sequence of instructions executed in presence of a fault is different from the fault-free sequence.</p><p>CFEs can be classified as internode and intranode CFEs.</p><p>1. Internode CFEs occur if the program control before and after the illegal jump resides in different basic block.</p><p>2. Intranode CFEs occur if the program control before and after the illegal jump resides in the same node <ref type="bibr" target="#b14">[14]</ref>.</p><p>Considering a Program Flow Graph { P ,V}, we define suc (vi) as the set of nodes successor of vi and pred(vi) as the set of nodes predecessor of vi. If and only if bri,j E, then the node vj suc(vi). Similarly, only if brj,i E, then the node vj pred(vi) <ref type="bibr" target="#b12">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Branch sequence</head><p>A program takes different paths depending on the input applied. A path, which is a sequence of basic blocks, is chosen depending on the outcome of the control instructions that are encountered at run-time <ref type="bibr" target="#b13">[13]</ref>.We called the sequence of basic blocks which will be executed at run-time a branch sequence. The CFCBS approach has the following steps:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Signature function</head><formula xml:id="formula_0">signature function f is defined as f(G,di) = G di</formula><p>1) Extracting the Basic Block and generating CFG of the program.</p><p>2) Assigning a signature si ,which is generated by a specific algorithm, to node vi in which si sj if i j, i,j = 1,2,...,N, N is the total number of nodes in the program.</p><p>3) Calculating the signature difference of the source node vs and the destination node vd of branch brsd and storing it in the destination node vd.</p><p>4) Inserting the appropriate instructions to the start of each Basic Block in order to update the signature in run-time phase. 5) Inserting the checking instructions to the end of each sequence in order to detect the control flow errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The generating signature algorithm</head><p>In this algorithm, an unique signature is assigned to each of the CFG nodes. A signature for each node has three fields that are branch sequence field, end bit field and supplement bit field. The branch sequence field consists of a series of 1s and 0s which indicate a branch taken or not taken respectively .The end bit field of a signature is '1' which indicates the end of a branch sequence field. The third field is exploit to fill in the rest of a register, therefore its length is not constant and is determined by the length of the first two fields and consists of a series of 0s <ref type="bibr" target="#b14">[14]</ref>.(see Fig. <ref type="figure" target="#fig_1">1</ref>).</p><p>The algorithm works as follows: at first, the branch sequence of a signature 1 is assigned to the first node which is the root of the CFG; then, for assigning each of the unassigned nodes, one of the following cases happens:</p><p>If the node with branch sequence S of a signature (X node) has two unassigned successor nodes then branch sequence S&amp;0 and S&amp;1 are assigned to these two nodes. Note: if one is assigned branch sequence S&amp;0 the other will be assigned branch sequence S&amp;1(see the Fig. <ref type="figure">2</ref>). If X node has only one unassigned successor node then branch sequence S&amp;1 is assigned to this node (see the Fig. <ref type="figure">3</ref>). Fig. <ref type="figure">3</ref>. A node has one successor node If the successor of X node has been assigned a signature si, then compare the length of the branch sequence of si and S&amp;0/S&amp;1, the longer will be assigned to the successor node (see the Fig. <ref type="figure" target="#fig_2">4</ref>). 2) If pred(vj) is a set of nodes vi1,vi2,...,viM , i.e. vj is a branch-fan-in node, then we choose a node vik as a reference node and insert an abstract BB into the branch brim,j, m = 1,2,...k-1,k+1,…,M , the signature difference of the inserted abstract BB is calculated by the signature difference between node vim and node vj, i.e. ,sim sj, what's more, the signature difference of node vj is set to sik sj. (see the Fig. <ref type="figure" target="#fig_3">5</ref>). The aliasing, which is mentioned in CFSS, i.e. multiple nodes are sharing multiple branch-fan-in nodes as their destination nodes, is resolved due to the exploit of abstract BB(discussed later in Sec IV).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Inserting the updating and checking instructions 1) Insert updating instruction G = G dj into node vj.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Insert checking instruction br (G sj) error into node vj where the comparison between the run-time signature G = Gi and the signature si is wanted (vj is not an abstract BB).</head><p>As shown in Fig. <ref type="figure" target="#fig_4">6</ref>, the basic block BBi consists of original instructions and additional checking instructions and signature updating instructions located at its beginning. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. CAPABILITIES OF THE CFCBS TECHNIQUE USING</head><p>As mentioned in CFCSS, if multiple nodes are sharing multiple branch-fan-in nodes as their destination nodes, an undetectable control flow error called aliasing may occur. The aliasing is caused by more than one signature difference is assigned to the same node. In order to solve the aliasing, abstract BB is introduced. The run-time adjusting signature D(called in CFCSS) is stored into abstract BB. Abstract BB does not contain any other effective instructions except an unconditional jump instruction and has only one successor node and one predecessor node. In CFCBS a updating instruction G = G dj is inserted into each abstract BB for signature updating. Thus, suppose that brij is an illegal branch, vi ∉ pred(vj). At node vi, G is equal to si. After the branch is taken, the new run-time signature is generated, G = Gj = Gi dj = si sk sj in which sk is the signature of reference node vk, where vk = pred(vj). Since si, sk, and sj are all different numbers, G = si sk sj≠sj. Mismatch occurs and the error is detected.</p><p>As mentioned in section , CFCBS primarily focus on internode CFEs, an internode CFE falls into the following two cases: a branch to a basic block vj not belonging to suc(vi) a branch from a basic block vi not belonging to pred(vj) CFCBS is capable of detecting all the internode CFEs.</p><p>Proof. Suppose that brij is an illegal branch, thus vj ∉suc(vi). At node vi, G is equal to si. After the branch is taken, the new run-time signature is generated, G = Gj = Gi ⊕ dj = si ⊕ sk ⊕ sj in which sk is the signature of node vk, where vk = pred(vj). If we suppose vi is not an abstract BB, since vk = pred(vj) and vj ∉suc(vi),therefore, si, sk, and sj are all different numbers, G = si ⊕ sk ⊕ sj ≠ sj. Mismatch occurs and the error is detected. If we suppose vi is an abstract BB ,since updating instruction G = G dj is inserted into each abstract BB, therefore, after the updating instruction G = Gj = Gi⊕dj =si⊕dj in which si is the signature of node vk, where vk ∉pred(vj), mismatch occurs and the error is detected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EXPERIMENTAL RESULTS</head><p>In order to assess the effectiveness of the proposed approach, five benchmark programs are chosen for the experiment: Quick sort (QS), Matrix Multiplication (MM), Bubble Sort (BS), Linked List (LL) and Binary Search Tree (BST). Performance overhead, memory size overhead, error detection latency and error detection coverage are imperative parameters for evaluating our approach. So all of these parameters are measured and reported. First of all, the memory overhead and the performance loss results of presented scheme are evaluated, then the average error detection latency of presented scheme is analyzed and the last part is allotted to the error detection coverage. We adopted this method in which the faults are injected into the program through modifying the assembly codes of the source file <ref type="bibr">[17,</ref><ref type="bibr">18]</ref>. One of the branch deletion, branch creation or branch operand change was randomly applied to the assembly codes. We considered four versions for each benchmark:</p><p>The original code.</p><p>A safe one, obtained by applying the CFCSS <ref type="bibr" target="#b11">[11]</ref> technique to the original code.</p><p>A safe one, obtained by applying the RSCFC <ref type="bibr" target="#b9">[9]</ref> technique to the original code.</p><p>A safe one, obtained by applying the CFCBS technique to the original code.</p><p>By comparing the size and the execution speed of the hardened programs and with respect to the original ones, we recorded the overheads reported in Table <ref type="table" target="#tab_1">1</ref>. As can be seen from the Table <ref type="table" target="#tab_1">1</ref>, CFCBS incurs the least memory compared with CFCSS and RSCFC, is comparable in performance overhead incurred with CFCSS and RSCFC. Detection latency can be quantified in processor cycles, and is defined as the number of processor cycles to run between the terminal of the illegal branching and the line detecting the error here <ref type="bibr" target="#b15">[15]</ref>. In CFCSS and CFCBS, the checking instruction is located at the top of each BB, therefore, the expectancy of detection latency is in positive correlation to the average length of BBs. In RSCRC, the test and set statement are also located at the top of each BB, however, the expectancy of detection latency is in positive correlation to the average length of BB groups. Obviously, the detection latency of RSCRC is several times larger than that of CFCSS and CFCBS.</p><p>The results we gathered during fault injection experiments are reported in Table <ref type="table" target="#tab_3">3</ref> and 4 where transients faults injected in the unhardened programs are categorized according to their effects (Table <ref type="table" target="#tab_2">2</ref>) and then compared with those injected in the 3 safe versions (CFCSS, RSCFC and CFCBS), as reported in Table <ref type="table" target="#tab_3">3</ref>. Fault effects are classified as follows:</p><p>Wrong Result (WR): the fault modifies the results of the program without being detected. OS detection (OS): the fault is detected by operating system or by the hardware. Software Detection (SD): the fault is detected by the software detection mechanisms employed. Two thousand errors including branch deletion faults, branch creation faults or branch operand change faults were injected for each assembly program, and then a machine code was generated by compiling the faulty assembly program.</p><p>Table <ref type="table" target="#tab_2">2</ref> shows the results of the faults injection experiments performed on all 20 executables. It can be seen that the presented technique, CFCBS, is comparable in performance overhead incurred with CFCSS, which is best among the previously proposed techniques in this metric. Instead of having a check point in every node, we inserted check points only at branch-fan-in nodes. This induced error detection latency but reduced the performance overhead with unchanged error coverage. The trade-off between error detection latency and performance overhead is the new research topic for our research group.  <ref type="table" target="#tab_4">2 and 3</ref> illustrates the fraction of faults that are not detected for the original programs and the hardened programs with CFCSS, RSCFC and CFCBS under each fault types. As it can be seen in Figure <ref type="figure" target="#fig_5">8</ref>, the average fault coverage for CFCSS, RSCFC and CFCBS are 87.92%, 90.09% and 90.06% respectively, while the averages of the evaluation factors [19] are 3.79, 2.94 and 4.40 respectively. Thus, CFCBS is comparable in the fault coverage obtained with the best of the previously proposed techniques. Meanwhile it has a higher evaluation factor because of lower memory overhead and performance overhead compared with other methods. Abstract basic block is introduced to resolve the aliasing. This results in CFCBS having high error coverage along with low performance overhead and memory overhead. Using error injection experiments on SPEC benchmarks, it is shown that CFCBS has higher method efficiency when compared with previous techniques.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>, and ss and sd are the signatures of the source node vs and the destination node vd of branch brsd.The signature difference dd (dd = ss sd).III. DESIGN OF BRANCH SEQUENCE SIGNATUREThe CFCBS checks the control flow of the program by using a dedicated register called the global signature register (GSR), which contains the run-time signature G associated with the current node (the node that contains the instruction currently executed) in the program flow graph. Every basic block (represented by a node vi in the program flow graph) is identified and assigned a unique signature si when the program is compiled. Let Gi be the run-time value of G when the program flow is in node vi. Under normal execution of the program (no errors), Gi should be equal to si. If G contains a number different from the signature associated with the current node, it means an error has occurred in the program<ref type="bibr" target="#b10">[10]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig.1. An example of the structure of a Signature</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig.4. One of the successors of X node has been assigned a signature B. Calculating and storing the signature difference For each node vj, j = 1,2,...,N. 1) If pred(vj) is only one node vi, i.e. vj is a not a branchfan-in node then the signature difference dj is calculated as dj = si sj.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig.5. Calculating the signature difference of branch-fan-in node</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig.6. A basic block with checking instruction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8</head><label>8</label><figDesc>Fig.8 generated according to the data in Tables2 and 3illustrates the fraction of faults that are not detected for the</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>Fig.8. The comparison of undetected faults under three fault types CONCLUSIONS In this article, a software-based control flow checking technique CFCBS is proposed. This method employed branch sequence signature which contains the information of path length and branch selecting to detect control flow fault.Abstract basic block is introduced to resolve the aliasing. This results in CFCBS having high error coverage along with low performance overhead and memory overhead. Using error injection experiments on SPEC benchmarks, it is shown that CFCBS has higher method efficiency when compared with previous techniques.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>IEEE International Conference on Internet of Things (iThings) and IEEE Green Computing and Communications (GreenCom) and IEEE Cyber, Physical and Social Computing (CPSCom) and IEEE Smart Data (SmartData) IEEE International Conference on Internet of Things (iThings) and IEEE Green Computing and Communications (GreenCom) and IEEE Cyber, Physical and Social Computing (CPSCom) and IEEE Smart Data (SmartData) IEEE International Conference on Internet of Things (iThings) and IEEE Green Computing and Communications (GreenCom) and IEEE Cyber, Physical and Social Computing (CPSCom) and IEEE Smart Data (SmartData) IEEE International Conference on Internet of Things (iThings) and IEEE Green Computing and Communications (GreenCom) and IEEE Cyber, Physical and Social Computing (CPSCom) and IEEE Smart Data (SmartData) IEEE International Conference on Internet of Things (iThings) and IEEE Green Computing and Communications (GreenCom) and IEEE Cyber, Physical and Social Computing (CPSCom) and IEEE Smart Data (SmartData)</figDesc><table><row><cell>following instruction, CFCSS then tests whether G is equal to</cell></row><row><cell>the destination block's signature. If the control can enter from</cell></row><row><cell>multiple blocks, then an adjusting signature (D) is assigned in</cell></row><row><cell>each source block and used in the destination block to compute the signature. In absence of errors, the signature contained in G</cell></row><row><cell>is equal to the signature of destination block. However, CFCSS</cell></row><row><cell>cannot cover control flow errors if multiple source blocks share</cell></row><row><cell>multiple branch-fan-in blocks as their destination blocks,</cell></row><row><cell>aliasing could occur between legal and illegal branches.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 1 .</head><label>1</label><figDesc>THE CFCBS'S MEMORY OVERHEAD</figDesc><table><row><cell>Program</cell><cell cols="3">Memory overhead (%) CFCSS RSCFC CFCBS</cell><cell cols="3">Performance overhead (%) CFCSS RSCFC CFCBS</cell></row><row><cell>QS</cell><cell>2.42</cell><cell>2.93</cell><cell>2.24</cell><cell>14.5</cell><cell>25.0</cell><cell>11.0</cell></row><row><cell>MM</cell><cell>2.17</cell><cell>1.36</cell><cell>1.94</cell><cell>6.50</cell><cell>14.2</cell><cell>5.51</cell></row><row><cell>BS</cell><cell>2.71</cell><cell>2.13</cell><cell>2.46</cell><cell>11.0</cell><cell>16.3</cell><cell>10.5</cell></row><row><cell>LL</cell><cell>2.56</cell><cell>1.23</cell><cell>1.35</cell><cell>6.02</cell><cell>9.05</cell><cell>5.23</cell></row><row><cell>BST</cell><cell>2.18</cell><cell>1.04</cell><cell>2.05</cell><cell>10.1</cell><cell>14.7</cell><cell>9.04</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 2 .</head><label>2</label><figDesc>EXPERIMENT RESULTS OF BRANCH-FAULT INJECTION INTO ORIGINAL PROGRAMS.</figDesc><table><row><cell>Original</cell><cell cols="2">Del (2000#) (%)</cell><cell cols="2">Change (2000#) (%)</cell><cell cols="2">Insert (2000#) (%)</cell></row><row><cell>Program</cell><cell>OS</cell><cell>WR</cell><cell>OS</cell><cell>WR</cell><cell>OS</cell><cell>WR</cell></row><row><cell>QS</cell><cell>31.2</cell><cell>36.7</cell><cell>71.2</cell><cell>25.4</cell><cell>52.4</cell><cell>28.7</cell></row><row><cell>MM</cell><cell>32.5</cell><cell>40.3</cell><cell>65.1</cell><cell>25.3</cell><cell>58.6</cell><cell>25.3</cell></row><row><cell>BS</cell><cell>35.1</cell><cell>48.7</cell><cell>67.9</cell><cell>26.7</cell><cell>57.9</cell><cell>16.7</cell></row><row><cell>LL</cell><cell>37.9</cell><cell>54.4</cell><cell>61.3</cell><cell>29.4</cell><cell>61.3</cell><cell>19.4</cell></row><row><cell>BST</cell><cell>36.6</cell><cell>40.9</cell><cell>64.5</cell><cell>30.9</cell><cell>64.5</cell><cell>26.5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 3 .</head><label>3</label><figDesc>A. EXPERIMENT RESULTS OF BRANCH DELETION AND BRANCH CHANGE FAULTS INJECTION INTO PROGRAMS WITH CFCSS, RSCFC AND CFCBS.</figDesc><table><row><cell>Program</cell><cell>OS</cell><cell>Del (2000#) (%) WR</cell><cell>SD</cell><cell>Change (2000#) (%) OS WR SD</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE 3 .</head><label>3</label><figDesc>B. EXPERIMENT RESULTS OF BRANCH CREATION FAULTS INJECTION INTO PROGRAMS WITH CFCSS, RSCFC AND CFCBS.</figDesc><table><row><cell>Programs</cell><cell>OS</cell><cell>Insert (2000#) (%) WR</cell><cell>SD</cell></row><row><cell>QS-CFCSS</cell><cell>25.1</cell><cell>7.46</cell><cell>56.2</cell></row><row><cell>MM-CFCSS</cell><cell>28.7</cell><cell>14.5</cell><cell>50.4</cell></row><row><cell>BS-CFCSS</cell><cell>15.2</cell><cell>8.64</cell><cell>64.3</cell></row><row><cell>LL-CFCSS</cell><cell>18.6</cell><cell>7.20</cell><cell>68.4</cell></row><row><cell>BST-CFCSS</cell><cell>21.4</cell><cell>11.6</cell><cell>60.1</cell></row><row><cell>QS-RSCFC</cell><cell>17.1</cell><cell>6.20</cell><cell>65.4</cell></row><row><cell>MM-RSCFC</cell><cell>23.5</cell><cell>13.3</cell><cell>54.6</cell></row><row><cell>BS-RSCFC</cell><cell>12.5</cell><cell>4.24</cell><cell>71.4</cell></row><row><cell>LL-RSCFC</cell><cell>12.5</cell><cell>7.26</cell><cell>74.3</cell></row><row><cell>BST-RSCFC</cell><cell>13.7</cell><cell>8.64</cell><cell>65.5</cell></row><row><cell>QS-CFCBS</cell><cell>16.5</cell><cell>4.75</cell><cell>67.7</cell></row><row><cell>MM-CFCBS</cell><cell>22.5</cell><cell>12.9</cell><cell>55.4</cell></row><row><cell>BS-CFCBS</cell><cell>12.8</cell><cell>4.64</cell><cell>72.2</cell></row><row><cell>LL-CFCBS</cell><cell>14.2</cell><cell>9.68</cell><cell>71.6</cell></row><row><cell>BST-CFCBS</cell><cell>15.8</cell><cell>6.78</cell><cell>61.3</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="978" xml:id="foot_0">-1-5090-5880-8/16 $31.00 © 2016 IEEE DOI 10.1109/iThings-GreenCom-CPSCom-SmartData.2016.174</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1">Authorized licensed use limited to: Tsinghua University. Downloaded on March 11,2022 at 09:38:32 UTC from IEEE Xplore. Restrictions apply.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<ptr target="http://www.ic3.gov/media/annualreport/2008_IC3Report.pdf" />
	</analytic>
	<monogr>
		<title level="j">Internet Crime Report</title>
		<imprint>
			<date type="published" when="2008">2008. 2008J</date>
			<publisher>Internet Crime Complaint Center</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Clerk</forename><surname>Maxwell</surname></persName>
		</author>
		<title level="m">A Treatise on Electricity and Magnetism</title>
				<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Clarendon</publisher>
			<date type="published" when="1892">1892</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="68" to="73" />
		</imprint>
	</monogr>
	<note>3rd ed.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><surname>Sans Institute</surname></persName>
		</author>
		<ptr target="http://www.sans.org/top20/2007/top20.pdf" />
		<title level="m">SANS Top-20 2007 Security Risks</title>
				<imprint>
			<date type="published" when="2007-11">Nov.2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Dynamic integrity measurement and attestation: Towards defense against return-oriented programming attacks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Workshop Scalable Trusted Comput</title>
				<meeting>ACM Workshop Scalable Trusted Comput</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="49" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Dynamic trust enhanced security model for trusted platform based services</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nagarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Varadharajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Generation Computer Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="564" to="573" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A hijacker s guide to communication interfaces of the trusted platform module</title>
		<author>
			<persName><forename type="first">J</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Dietrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Computers &amp;Mathematics with Applications</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="748" to="761" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Architecture support for dynamic integrity checking</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Kanuparthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zahran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="321" to="332" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Protecting the integrity of trusted applications in mobile phone systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Muthukumaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schiffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sawani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jaeger</surname></persName>
		</author>
		<imprint>
			<publisher>Security and Communication Networks</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">RADJAM: A Novel Approach for Reduction of Soft Errors in Logic Circuits</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bhattacharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ranganathan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="453" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On-line control flow error detection using relationship signatures among basic blocks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Electr. Eng. J</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="132" to="141" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Design and evaluation of system-level checks for on-line control flow error detection</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Alkhalifa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TransParallel Distribut Syst</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">41</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Control-Flow Checking by Software Signatures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Oh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Shirvani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Mccluskey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Reliability</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="111" to="122" />
			<date type="published" when="2002-03">Mar. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Tan</forename><surname>Li Jian-Li</surname></persName>
		</author>
		<author>
			<persName><surname>Qing-Ping</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lan-Fang</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><surname>Xu Jian-Jun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">control flow checking Method based on Abstract Basic Block and Formatted Signature ,Chinese Journal Of Computers</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">11</biblScope>
			<date type="published" when="2014">NOV.2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Low-Cost On-Line Fault Detection Using Control Flow Assertions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 9th IEEE International On-line Testing Symposium (IOLTS&apos;03)</title>
				<meeting>eeding of the 9th IEEE International On-line Testing Symposium (IOLTS&apos;03)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Soft-error detection using control flow assertions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goloubeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rebaudengo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Reorda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Violante</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th IEEE international symposium on defect and fault tolerance in VLSI systems</title>
				<meeting>the 18th IEEE international symposium on defect and fault tolerance in VLSI systems</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="581" to="588" />
		</imprint>
	</monogr>
	<note>DFT 03</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A software-based error detection technique using encoded signatures</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sedaghat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Miremadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fazeli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st IEEE International Symposium on Defect and Fault Tolerance in VLSI Systems, 2006. DFT &apos;06</title>
				<imprint>
			<date type="published" when="2006-10">Oct. 2006</date>
			<biblScope unit="page" from="389" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Design Methodology for Software Fault Injection in Embedded Systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jhaveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Abraham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP Int l Workshop Dependable Computing and Its Applications (DCIA 98)</title>
				<meeting>IFIP Int l Workshop Dependable Computing and Its Applications (DCIA 98)</meeting>
		<imprint>
			<date type="published" when="1998-01">Jan. 1998</date>
			<biblScope unit="page" from="237" to="248" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
