<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Distributed Constraint Satisfaction Problem: Formalization and Algorithms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Makoto</forename><surname>Yokoo</surname></persName>
							<email>yokoo@cslab.kecl.ntt.co.jp</email>
							<affiliation key="aff0">
								<orgName type="institution">NTT Communication Science Laboratories</orgName>
								<address>
									<addrLine>2-2 Hikaridai, Seika-cho, Soraku-gun</addrLine>
									<postCode>619-02</postCode>
									<settlement>Kyoto</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<postCode>48109</postCode>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Edmund</forename><forename type="middle">H</forename><surname>Durfee</surname></persName>
							<email>durfee@umich.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">NTT Communication Science Laboratories</orgName>
								<address>
									<addrLine>2-2 Hikaridai, Seika-cho, Soraku-gun</addrLine>
									<postCode>619-02</postCode>
									<settlement>Kyoto</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Toru</forename><surname>Ishida</surname></persName>
							<email>ishida@kuis.kyoto-u.ac.jp</email>
							<affiliation key="aff0">
								<orgName type="institution">NTT Communication Science Laboratories</orgName>
								<address>
									<addrLine>2-2 Hikaridai, Seika-cho, Soraku-gun</addrLine>
									<postCode>619-02</postCode>
									<settlement>Kyoto</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">NTT Research and Development Headquarters</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kazuhiro</forename><surname>Kuwabara</surname></persName>
							<email>kuwabara@rdh.ecl.ntt.co.jp</email>
							<affiliation key="aff0">
								<orgName type="institution">NTT Communication Science Laboratories</orgName>
								<address>
									<addrLine>2-2 Hikaridai, Seika-cho, Soraku-gun</addrLine>
									<postCode>619-02</postCode>
									<settlement>Kyoto</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">E</forename><forename type="middle">• H</forename><surname>Durfee</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Information Science</orgName>
								<orgName type="institution">Kyoto University</orgName>
								<address>
									<addrLine>Yoshida-honmachi, Sakyo-ku</addrLine>
									<postCode>606-01</postCode>
									<settlement>Kyoto</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">•</forename><forename type="middle">K</forename><surname>Kuwabara</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Nippon Telegraph and Telephone Corporation</orgName>
								<address>
									<addrLine>3-19-2 Nishi-shinjuku, Shinjuku-ku</addrLine>
									<postCode>163-19</postCode>
									<settlement>Tokyo</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Distributed Constraint Satisfaction Problem: Formalization and Algorithms</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7C0A7D2B20691BE7925234E10C92EAEE</idno>
					<note type="submission">received 21 Apr. 1996; revised 10 June 1997.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Backtracking algorithms</term>
					<term>constraint satisfaction problem</term>
					<term>distributed artificial intelligence</term>
					<term>iterative improvement algorithm</term>
					<term>multiagent systems</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we develop a formalism called a distributed constraint satisfaction problem (distributed CSP) and algorithms for solving distributed CSPs. A distributed CSP is a constraint satisfaction problem in which variables and constraints are distributed among multiple agents. Various application problems in Distributed Artificial Intelligence can be formalized as distributed CSPs. We present our newly developed technique called asynchronous backtracking that allows agents to act asynchronously and concurrently without any global control, while guaranteeing the completeness of the algorithm. Furthermore, we describe how the asynchronous backtracking algorithm can be modified into a more efficient algorithm called an asynchronous weak-commitment search, which can revise a bad decision without exhaustive search by changing the priority order of agents dynamically. The experimental results on various example problems show that the asynchronous weak-commitment search algorithm is, by far more, efficient than the asynchronous backtracking algorithm and can solve fairly large-scale problems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>ISTRIBUTED Artificial Intelligence (DAI) [1] is a subfield of artificial intelligence that is concerned with interaction, especially coordination among artificial automated agents. Since distributed computing environments are spreading very rapidly due to the advances in hardware and networking technologies, there are pressing needs for DAI techniques. Thus DAI is becoming a vital area of research in artificial intelligence.</p><p>In this paper, we develop a formalism called a distributed constraint satisfaction problem (distributed CSP). A distributed CSP is a constraint satisfaction problem (CSP) in which variables and constraints are distributed among multiple automated agents. A CSP is a problem to find a consistent assignment of values to variables. Even though the definition of a CSP is very simple, a surprisingly wide variety of AI problems can be formalized as CSPs. Similarly, various application problems in DAI that are concerned with finding a consistent combination of agent actions can be formalized as distributed CSPs.</p><p>For example, a multiagent truth maintenance system <ref type="bibr" target="#b0">[2]</ref> is a distributed version of a truth maintenance system <ref type="bibr" target="#b1">[3]</ref>. In this system, there exist multiple agents, each of which has its own truth maintenance system. Each agent has uncertain data that can be IN or OUT, i.e., believed or not believed, and each shares some data with other agents. Each agent must determine the label of its data consistently, and shared data must have the same label. The multiagent truth maintenance task can be formalized as a distributed CSP, where each of uncertain data is a variable whose value can be IN or OUT.</p><p>Another example is a distributed resource allocation problem in a communication network, which is described in <ref type="bibr" target="#b2">[4]</ref>. In this problem, each agent has its own tasks, and there are several ways (plans) to perform each task. Since resources are shared among agents, there exist constraints/ contention between plans. The goal is to find the combination of plans that enables all the tasks to be executed simultaneously. This problem can be formalized as a distributed CSP by representing each task as a variable, and possible plans as variable values.</p><p>Many other application problems that are concerned with finding a consistent combination of agent actions/decisions (e.g., distributed scheduling <ref type="bibr" target="#b3">[5]</ref> and distributed interpretation problems <ref type="bibr" target="#b4">[6]</ref>) can be formalized as distributed CSPs. Since a variety of DAI application problems can be formalized as distributed CSPs, we can consider distributed algorithms for solving distributed CSPs as an important infrastructure in DAI.</p><p>It must be noted that although algorithms for solving distributed CSPs seem to be similar to parallel/distributed processing methods for solving CSPs <ref type="bibr" target="#b5">[7]</ref>, <ref type="bibr" target="#b6">[8]</ref>, research motivations are fundamentally different. The primary concern in parallel/distributed processing is efficiency, and we can choose any type of parallel/distributed computer architecture for solving a given problem efficiently.</p><p>In contrast, in a distributed CSP there already exists a situation where knowledge about the problem (i.e., variables and constraints) is distributed among automated agents. Therefore, the main research issue is how to reach a solution from this given situation. If all knowledge about the problem can be gathered into one agent, this agent can solve the problem alone using normal centralized constraint satisfaction algorithms. However, collecting all information about a problem requires not only the communication costs but also the costs of translating one's knowledge into an exchangeable format. For example, a constraint might be stored as a very complicated specialized internal function within an agent. In order to communicate the knowledge of this constraint to other agent, which might be implemented on different computer architecture, the agent must translate the knowledge into an exchangeable format, such as a table of allowed (or not allowed) combinations of variable values. These costs of centralizing all information to one agent could be prohibitively high.</p><p>Furthermore, in some application problems, gathering all information to one agent is undesirable or impossible for security/privacy reasons. In such cases, multiple agents have to solve the problem without centralizing all information.</p><p>In this paper, we develop a basic algorithm for solving distributed CSPs called asynchronous backtracking. In this algorithm, agents act asynchronously and concurrently based on their local knowledge without any global control, while the completeness of the algorithm is guaranteed.</p><p>Furthermore, we describe how this asynchronous backtracking algorithm can be modified into a more efficient algorithm called asynchronous weak-commitment search, which is inspired by the weak-commitment search algorithm for solving CSPs <ref type="bibr" target="#b7">[9]</ref>. The main characteristic of this algorithm is as follows:</p><p>• Agents can revise a bad decision without an exhaustive search by changing the priority order of agents dynamically.</p><p>In the asynchronous backtracking algorithm, the priority order of agents is determined, and each agent tries to find a value satisfying the constraints with the variables of higher priority agents. When an agent sets a variable value, the agent is strongly committed to the selected value, i.e., the selected value will not be changed unless an exhaustive search is performed by lower priority agents. Therefore, in large-scale problems, a single mistake in the selection of values becomes fatal since such an exhaustive search is virtually impossible. This drawback is common to all backtracking algorithms. In the asynchronous weakcommitment search, when an agent cannot find a value consistent with the higher priority agents, the priority order is changed so that the agent has the highest priority. As a result, when an agent makes a mistake in selecting a value, the priority of another agent becomes higher; thus the agent that made the mistake will not commit to the bad decision, and the selected value is changed. We will show that the asynchronous weak-commitment search algorithm can solve various problems, such as the distributed 1,000-queens problem, the distributed graphcoloring problem, and the network resource allocation problem <ref type="bibr" target="#b8">[10]</ref> that the asynchronous backtracking algorithm fails to solve within a reasonable amount of time. These results are interesting since they imply that a flexible agent organization, in which the hierarchical order is changed dynamically, actually performs better than an organization in which the hierarchical order is static and rigid, if we assume that the priority order represents a hierarchy of agent authority, i.e., the priority order of decision making.</p><p>In the following sections, we describe the definition of a distributed CSP (Section 2). Then, we show two trivial algorithms for solving distributed CSPs (Section 3), and describe the asynchronous backtracking algorithm in detail (Section 4). We show how the asynchronous weakcommitment search algorithm is obtained by modifying the asynchronous backtracking algorithm (Section 5). Then, we present empirical results that compare the efficiency of these algorithms (Section 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DISTRIBUTED CONSTRAINT SATISFACTION PROBLEM</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">CSP</head><p>A CSP consists of n variables x 1 , x 2 , ..., x n , whose values are taken from finite, discrete domains D 1 , D 2 , ..., D n , respectively, and a set of constraints on their values. A constraint is defined by a predicate. That is, the constraint p k (x k1 , ¤, x kj ) is a predicate that is defined on the Cartesian product D k1 ¤ D kj . This predicate is true iff the value assignment of these variables satisfies this constraint. Solving a CSP is equivalent to finding an assignment of values to all variables such that all constraints are satisfied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Distributed CSP</head><p>A distributed CSP is a CSP in which the variables and constraints are distributed among automated agents. We assume the following communication model:</p><p>• Agents communicate by sending messages. An agent can send messages to other agents iff the agent knows the addresses of the agents. • The delay in delivering a message is finite, though random. For the transmission between any pair of agents, messages are received in the order in which they were sent.</p><p>It must be noted that this model does not necessarily mean that the physical communication network must be fully connected (i.e., a complete graph). Unlike most parallel/distributed algorithm studies, in which the topology of the physical communication network plays an important role, we assume the existence of a reliable underlying communication structure among the agents and do not care about the implementation of the physical communication network. This is because our primary concern is cooperation among intelligent agents, rather than solving CSPs by certain multiprocessor architectures.</p><p>Each agent has some variables and tries to determine their values. However, there exist interagent constraints, and the value assignment must satisfy these interagent constraints. Formally, there exist m agents 1, 2, ¤, m. Each variable x j belongs to one agent i (this relation is represented as belongs(x j , i)).</p><p><ref type="foot" target="#foot_0">1</ref> Constraints are also distributed among agents. The fact that an agent l knows a constraint predicate p k is represented as known(p k , l).</p><p>We say that a Distributed CSP is solved iff the following conditions are satisfied:</p><p>• "i, "x j where belongs(x j , i), the value of x j is assigned to d j , and "l, "p k where known(p k , l), p k is true under the assignment x j = d j .</p><p>Without loss of generality, we make the following assumptions while describing our algorithms for simplicity. Relaxing these assumptions to general cases is relatively straightforward<ref type="foot" target="#foot_1">2</ref> :</p><p>• Each agent has exactly one variable.</p><p>• All constraints are binary.</p><p>• Each agent knows all constraint predicates relevant to its variable.</p><p>In the following, we use the same identifier x i to represent an agent and its variable. We assume that each agent (and its variable) has a unique identifier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">TRIVIAL ALGORITHMS FOR SOLVING DISTRIBUTED CSP</head><p>The methods for solving CSPs can be divided into two groups, namely search algorithms (e.g., backtracking algorithms), and consistency algorithms <ref type="bibr" target="#b10">[12]</ref>. Consistency algorithms are preprocessing procedures that are invoked before search. Consistency algorithms in the Assumptionbased Truth Maintenance System framework <ref type="bibr" target="#b11">[13]</ref> are essentially monotonic and can be applied straightforwardly to distributed CSPs. Namely, if each agent has its own Assumption-based Truth Maintenance System, these agents can execute the consistency algorithm by exchanging their possible values, generating new constraints (nogoods) using hyper-resolution rules, and further exchanging obtained nogoods <ref type="bibr" target="#b12">[14]</ref>. Therefore, in this paper hereafter, we focus on search algorithms for distributed CSPs. We can consider two trivial algorithms for solving distributed CSPs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Centralized Method</head><p>The most trivial algorithm for solving a distributed CSP is to select a leader agent among all agents, and gather all information about the variables, their domains, and their constraints, into the leader agent. The leader then solves the CSP alone using normal centralized constraint satisfaction algorithms. However, as discussed in Section 1, the cost of collecting all information about a problem can be prohibitively high. Furthermore, in some application problems, such as software agents in which each agent acts as a secretary of an individual, gathering all information to one agent is undesirable or impossible for security/privacy reasons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Synchronous Backtracking</head><p>The standard backtracking algorithm for CSP can be modified to yield the synchronous backtracking algorithm for distributed CSPs. Assume the agents agree on an instantiation order for their variables (such as agent x 1 goes first, then agent x 2 , and so on). Each agent, receiving a partial solution (the instantiations of the preceding variables) from the previous agent, instantiates its variable based on the constraints that it knows about. If it finds such a value, it appends this to the partial solution and passes it on to the next agent. If no instantiation of its variable can satisfy the constraints, then it sends a backtracking message to the previous agent.</p><p>While this algorithm does not suffer from the same communication overhead as the centralized method, determining the instantiation order still requires certain communication costs. Furthermore, this algorithm cannot take advantage of parallelism.</p><p><ref type="foot" target="#foot_2">3</ref> Because, at any given time, only one agent is receiving the partial solution and acting on it, the problem is solved sequentially.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ASYNCHRONOUS BACKTRACKING</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Overview</head><p>Our asynchronous backtracking algorithm removes the drawbacks of synchronous backtracking by allowing agents to run concurrently and asynchronously. Each agent instantiates its variable and communicates the variable value to the relevant agents. We represent a distributed CSP in which all constraints are binary as a network, where variables are nodes and constraints are links between nodes. <ref type="foot" target="#foot_3">4</ref> Since each agent has exactly one variable, a node also represents an agent. We use the same identifier for representing an agent and its variable. We also assume that every link (constraint) is directed. In other words, one of the two agents involved in a constraint is assigned that constraint, and receives the other agent's value. A link is directed from the valuesending agent to the constraint-evaluating agent. For example, in Fig. <ref type="figure" target="#fig_0">1</ref> there are three agents, x 1 , x 2 , x 3 , with variable domains {1, 2}, {2}, {1, 2}, respectively, and constraints x 1 ¡ x 3 and x 2 ¡ x 3 . Each agent instantiates its variable concurrently and sends the value to the agents which are connected by outgoing links. After that, the agents wait for and respond to messages. Fig. <ref type="figure">2</ref> describes procedures executed by agent x i for receiving two kinds of messages. 5 One kind is an ok? message, that a constraint-evaluating agent receives from a value-sending agent asking whether the value chosen is acceptable (Fig. <ref type="figure">2i</ref>). The second kind is a nogood message that a value-sending agent receives, indicating that the constraint-evaluating agent has found a constraint violation (Fig. <ref type="figure">2ii</ref>). Each agent has a set of values from the agents that are connected by incoming links. These values constitute the agent's agent_view. The fact that x 1 's value is 1 is represented by a pair of the agent identifier and the value, (x 1 , 1). Therefore, an agent_view is a set of these pairs, e.g., {(x 1 , 1), (x 2 , 2)}. If an ok? message is sent on an incoming link, the evaluating agent adds the pair to its agent_view and checks whether its own value assignment (represented as (x i , current_value)) is consistent with its agent_view. Its own assignment is consistent with the agent_view if all constraints the agent evaluates are true under the value assignments described in the agent_view and (x i , current_value), and if all communicated nogoods are not compatible 6 with the agent_view and (x i , current_value). If its own assignment is not consistent with the agent_view, agent x i tries to change the current_value so that it will be consistent with the agent_view. A subset of an agent_view is called a nogood if the agent is not able to find any consistent value with the subset. For example, in Fig. <ref type="figure">3a</ref>, if agents x 1 and x 2 instantiate their variables to 1 and 2, the agent_view of x 3 will be {(x 1 , 1), (x 2 , 2)}. Since there is no possible value for x 3 which is consistent with this agent_view, this agent_view is a nogood. If an agent finds a subset of its agent_view is a nogood, 7 the assignments of other agents must be changed. Therefore, the agent causes a backtrack (Fig. <ref type="figure">2iii</ref>)) and sends a nogood message to one of the other agents.</p><p>5. Although the following algorithm is described in a way such that an agent reacts to messages sequentially, an agent can in fact handle multiple messages concurrently, i.e., the agent first revises the agent_view and nogood_list according to the messages, and performs check_agent_view only once.</p><p>6. A nogood is compatible with the agent_view and (x i , current_value) if all variables in the nogood have the same values in the agent_view and (x i , current_value).</p><p>7. Ideally, the nogoods detected in Fig. <ref type="figure">2iii</ref>-a should be minimal, i.e., no subset of them should be a nogood. However, since finding all minimal nogoods requires certain computation costs, an agent can make do with nonminimal nogoods. In the simplest case, it can use the whole agent_view as a nogood.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Avoiding Infinite Processing Loops</head><p>If agents change their values again and again and never reach a stable state, they are in an infinite processing loop. An infinite processing loop can occur if there exists a value changing loop of agents, such as if a change in x 1 causes x 2 to change, then this change in x 2 causes x 3 to change, which then causes x 1 to change again, and so on. In the network representation, such a loop is represented by a cycle of directed links.</p><p>One way to avoid cycles in a network is to use a total order relationship among nodes. If each node has an unique identifier, we can define a priority order among agents by using the alphabetical order of these identifiers (the preceding agent in the alphabetical order has higher priority). If a link is directed by using this priority order (from the higher priority agent to the lower priority agent), there will be no cycle in the network. This means that for each constraint, the lower priority agent will be an evaluator, and the higher priority agent will send an ok? message to the evaluator. Furthermore, if a nogood is found, a nogood message is sent to the lowest priority agent in the nogood (Fig. <ref type="figure">2iii-b</ref>). Similar techniques to this unique identifier method are used for avoiding deadlock in distributed database systems <ref type="bibr" target="#b13">[15]</ref>.</p><p>The knowledge each agent requires for this unique identifier method is much more local than that needed for synchronous backtracking. In synchronous backtracking, agents must act in a predefined sequential order. Such a sequential order cannot be obtained easily just by giving an unique identifier to each agent. Each agent must know the previous and next agent, which means polling all of the other agents to find the closest identifiers above and below it. On the other hand, in the unique identifier method for asynchronous backtracking, each agent has to know only the identifiers of an agent with which it must establish a constraint in order to direct the constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Handling Asynchronous Changes</head><p>Because agents change their instantiations asynchronously, an agent_view is subject to incessant changes. This can lead to potential inconsistencies, because a constraint-evaluating agent might send a nogood message to an agent that has already changed the value of an offending variable as a result of other constraints. In essence, the nogood message may be based on obsolete information, and the value-sending agent should not necessarily change its value again.</p><p>We introduce the use of context attachment to deal with these potential inconsistencies. In context attachment, an agent couples its message with the nogood that triggered it. This nogood is the context of backtracking. After receiving this message, the recipient only changes its value if the nogood is compatible with its current agent_view and its own assignment (Fig. <ref type="figure">2ii-a</ref>). Since the nogood attached to a nogood message indicates the cause of the failure, asynchronous backtracking includes the function of dependencydirected backtracking in CSPs <ref type="bibr" target="#b10">[12]</ref>.</p><p>A nogood can be viewed as a new constraint derived from the original constraints. By incorporating such a new constraint, agents can avoid repeating the same mistake. For example, in Fig. <ref type="figure">3b</ref>, the nogood {(x 1 , 1), (x 2 , 2)} represents a constraint between x 1 and x 2 . Since there is no link between x 1 and x 2 originally, a new link must be added between them. 8 Therefore, after receiving the nogood message, agent x 2 asks x 1 to add a link between them. In general, even if all the original constraints are binary, newly derived constraints can be among more than two variables. In such a case, one of the agents, which has the lowest priority in the constraint, will be an evaluator and the links will be added between each of the nonevaluator agents and the evaluator.</p><p>8. Since a link in the constraint network represents a logical relation between agents, adding a link does not mean adding a new physical communication path between agents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Example</head><p>In Fig. <ref type="figure">3a</ref>, by receiving ok? messages from x 1 and x 2 , the agent_view of x 3 will be {(x 1 , 1), (x 2 , 2)}. Since there is no possible value for x 3 consistent with this agent_view, this agent_view is a nogood. Agent x 3 chooses the lowest priority agent in the agent_view, i.e., agent x 2 , and sends a nogood message with the nogood. By receiving this nogood message, agent x 2 records this nogood. This nogood, {(x 1 , 1), (x 2 , 2)} contains agent x 1 , which is not connected with x 2 by a link. Therefore, a new link must be added between x 1 and x 2 . Agent x 2 requests x 1 to send x 1 's value to x 2 , and adds (x 1 , 1) to its agent_view (Fig. <ref type="figure">3b</ref>). Agent x 2 checks whether its value is consistent with the agent_view. Since the nogood received from agent x 3 is compatible with its assignment (x 2 , 2) and its agent_view {(x 1 , 1)}, the assignment (x 2 , 2) is inconsistent with the agent_view. The agent_view {(x 1 , 1)} is a nogood because x 2 has no other possible values. There is only one agent in this nogood, i.e., agent x 1 , so agent x 2 sends a nogood message to agent x 1 (Fig. <ref type="figure">3c</ref>). Furthermore, we illustrate the execution of the algorithm using a distributed version of the well-known n-queens problem (where n = 4). There exist four agents, each of which corresponds to a queen in each row. The goal of the agents is to find positions on a 4 4 chess board so that the queens do not threaten each other. It must be noted that the trace of the algorithm execution can vary significantly according to the timing/delay of the messages, and this example shows one possible trace of execution.</p><p>The initial values are shown in Fig. <ref type="figure" target="#fig_2">4a</ref>. Agents communicate these values with each other. The priority order is determined by the alphabetical order of identifiers. The agents except x 1 change their value, so that the new value is consistent with its agent_view (Fig. <ref type="figure" target="#fig_2">4b</ref>), i.e., agent x 2 changes its value to 3, which is consistent with x 1 's value. Agent x 3 changes its value to 4, which is consistent with x 1 's and x 2 's value (since x 2 changes its value, x 3 's value is no longer consistent with the new value.). Since there is no consistent value for agent x 4 , it sends a nogood message to x 3 , and changes its value so that the value is consistent with its agent_view, except the value of x 3 . Note that x 3 will ignore this nogood message since it has changed its value before it receives this message. The agents send ok? messages to other agents. Then, x 3 does not satisfy constraints with x 1 and x 2 , and there is no consistent value, while other agents' values are consistent with their agent_view. Therefore, x 3 sends a nogood message to x 2 . After receiving this nogood message, x 2 changes its value to 4 (Fig. <ref type="figure" target="#fig_2">4c</ref>). Then, x 3 changes its value to 2. There is no consistent value for agent x 4 , it sends a nogood message to x 3 , and changes its value so that the value is consistent with its agent_view, except the value of x 3 (Fig. <ref type="figure" target="#fig_2">4d</ref>). Again, this nogood message is ignored. There is no consistent value for agent x 4 , it sends a nogood message to x 3 . After receiving this message, x 3 has no other consistent value, so x 3 sends a nogood message to x 2 . After receiving this message, x 2 also has no other consistent value, so x 2 sends a nogood message to x 1 . Then, x 1 changes its value to 2 (Fig. <ref type="figure" target="#fig_2">4e</ref>). Then, x 3 changes its value to 1. There is no consistent value for agent x 4 , it sends a nogood message to x 3 , and changes its value so that the value is consistent with its agent_view, except the value of x 3 . Again, this nogood message is ignored, and a solution is found (Fig. <ref type="figure" target="#fig_2">4f</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Algorithm Soundness and Completeness</head><p>We will show that if there exists a solution, this algorithm reaches a stable state where all the variable values satisfy all the constraints, and all agents are waiting for an incoming message, 9 and if no solution exists, this algorithm discovers this fact and terminates. For the agents to reach a stable state, all their variable values must perforce satisfy all the constraints. Thus, the soundness of the algorithm is clear. Furthermore, the algorithm is complete, in that it finds a solution if one exists and terminates with failure when there is no solution.</p><p>A solution does not exist when the problem is overconstrained. In an overconstrained situation, our algorithm eventually generates a nogood corresponding to the empty set. Because a nogood logically represents a set of assignments that leads to a contradiction, an empty nogood means that any set of assignments leads to a contradiction. Thus, no solution is possible. Our algorithm thus terminates with failure if and only if an empty nogood is formed.</p><p>So far, we have shown that when the algorithm leads to a stable state, the problem is solved, and when it generates an empty nogood, the algorithm terminates with failure. What remains is to show that the algorithm reaches one of these conclusions in finite time. The only way that our algorithm might not reach a conclusion is when at least one agent is cycling among its possible values in an infinite processing loop. Given our algorithm, we can prove by induction that this cannot happen as follows.</p><p>In the base case, assume that the agent with the highest priority, x 1 , is in an infinite loop. Because it has the highest priority, x 1 only receives nogood messages. When it proposes a possible value, x 1 either receives a nogood message back, or else gets no message back. If it receives nogood messages for all possible values of its variable, then it will generate an empty nogood (any choice leads to a constraint violation) and the algorithm will terminate. If it does not receive a nogood message for a proposed value, then it will not change that value. Either way, it cannot be in an infinite loop. Now, assume that agents x 1 to x k-1 (k &gt; 2) are in a stable state, and agent x k is in an infinite processing loop. In this case, the only messages agent x k receives are nogood messages from agents whose priorities are lower than k, and these nogood messages contain only the agents x 1 to x k . Since agents x 1 to x k-1 are in a stable state, the nogoods agent x k receives must be compatible with its agent_view, and so x k 9. We should mention that the way to determine that agents as a whole have reached a stable state is not contained in this algorithm. To detect the stable state, distributed termination detection algorithms such as <ref type="bibr" target="#b14">[16]</ref> are needed. will change instantiation of its variable with a different value. Because its variable's domain is finite, x k will either eventually generate a value that does not cause it to receive a nogood (which contradicts the assumption that x k is in an infinite loop), or else it exhausts the possible values and sends a nogood to one of x 1 ¤ x k-1 . However, this nogood would cause an agent, which we assumed as being in a stable state, to not be in a stable state. Thus, by contradiction, x k cannot be in an infinite processing loop. Since constraint satisfaction is NP-complete in general, the worst-case time complexity of the asynchronous backtracking algorithm becomes exponential in the number of variables n. The worst-case space complexity of the algorithm is determined by the number of recorded nogoods. In the asynchronous backtracking algorithm, an agent can forget old nogoods after it creates a new nogood from them. Also, an agent does not need to keep the nogoods that are not compatible with the agent_view. Therefore, each agent x i needs to record at most |D i | nogoods, where |D i | is the number of possible values of x i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ASYNCHRONOUS WEAK-COMMITMENT SEARCH</head><p>In this section, we briefly describe the weak-commitment search algorithm for solving CSPs <ref type="bibr" target="#b7">[9]</ref> and describe how the asynchronous weak-commitment search algorithm is constructed by modifying the asynchronous backtracking algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Weak-Commitment Search Algorithm</head><p>In the weak-commitment search algorithm, all the variables have tentative initial values. A consistent partial solution is constructed for a subset of variables, and this partial solution is extended by adding variables one by one until a complete solution is found. When a variable is added to the partial solution, its tentative initial value is revised so that the new value satisfies all the constraints between the variables included in the partial solution, and satisfies as many constraints as possible between variables that are not included in the partial solution. This value ordering heuristic is called the min-conflict heuristic <ref type="bibr" target="#b15">[17]</ref>. When there exists no value for one variable that satisfies all the constraints between the variables included in the partial solution, this algorithm abandons the whole partial solution, and starts constructing a new partial solution from scratch, using the current value assignment as new tentative initial values.</p><p>This algorithm records the abandoned partial solutions as new constraints, and avoids creating the same partial solution that has been created and abandoned before. Therefore, the completeness of the algorithm (always finds a solution if one exists, and terminates if no solution exists) is guaranteed. Experimental results on various example problems in <ref type="bibr" target="#b7">[9]</ref> illustrate that this algorithm is three to 10 times more efficient than the min-conflict backtracking <ref type="bibr" target="#b15">[17]</ref> or the breakout algorithm <ref type="bibr" target="#b16">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Basic Ideas</head><p>The main characteristics of the weak-commitment search algorithm described in the previous subsection are as follows:</p><p>1) The algorithm uses the min-conflict heuristic as a value ordering heuristic. 2) It abandons the partial solution and restarts the search process if there exists no consistent value with the partial solution.</p><p>Introducing the first characteristic into the asynchronous backtracking algorithm is relatively straightforward. When selecting a variable value, if there exist multiple values consistent with the agent_view (those that satisfy the constraints with variables of higher priority agents), the agent prefers the value that minimizes the number of constraint violations with variables of lower priority agents.</p><p>In contrast, introducing the second characteristic into the asynchronous backtracking is not straightforward, since agents act concurrently and asynchronously, and no agent has exact information about the partial solution. Furthermore, multiple agents may try to restart the search process simultaneously.</p><p>In the following, we show that a distributed constraint satisfaction algorithm that commits to the partial solution weakly can be constructed by changing the priority order dynamically. We define the way of establishing the priority order by introducing priority values, and change the priority values by the following rules:</p><p>• For each variable/agent, a nonnegative integer value representing the priority order of the variable/agent is defined. We call this value the priority value. • The order is defined such that any variable/agent with a larger priority value has higher priority. • If the priority values of multiple agents are the same, the order is determined by the alphabetical order of the identifiers. • For each variable/agent, the initial priority value is 0.</p><p>• If there exists no consistent value for x i , the priority value of x i is changed to k + 1, where k is the largest priority value of related agents.</p><p>It must be noted that the asynchronous weak-commitment search algorithm is fundamentally different from backtracking algorithms with dynamic variable ordering (e.g., dynamic backtracking <ref type="bibr" target="#b17">[19]</ref> and dependency-directed backtracking <ref type="bibr" target="#b10">[12]</ref>). In backtracking algorithms, a partial solution is never modified unless it is sure that the partial solution cannot be a part of any complete solution (dynamic backtracking or dependency-backtracking is a way for finding out the true cause of the failure/backtracking). In the asynchronous weak-commitment search algorithm, a partial solution is not modified but completely abandoned after one failure/backtracking. Furthermore, in the asynchronous backtracking algorithm, agents try to avoid situations previously found to be nogoods. However, due to the delay of messages, an agent_view of an agent can occasionally be identical to a previously found nogood. In order to avoid reacting to such unstable situations, and performing unnecessary changes of priority values, each agent performs the following procedure:</p><p>• Each agent records the nogoods that it has sent. When the agent_view is identical to a nogood that it has already sent, the agent will not change the priority value and waits for the next message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Details of Algorithm</head><p>In the asynchronous weak-commitment search, each agent concurrently assigns a value to its variable, and sends the variable value to other agents. After that, agents wait for and respond to incoming messages. 10 In Fig. <ref type="figure" target="#fig_3">5</ref>, the procedures executed at agent x i by receiving an ok? message and a nogood message are described. 11 The differences between these procedures and the procedures for the asynchronous backtracking algorithm are as follows:</p><p>• In the asynchronous backtracking algorithm, each agent sends its variable value only to related lower priority agents, while in the asynchronous weakcommitment search algorithm, each agent sends its 10. As in the asynchronous backtracking, although the following algorithm is described in a way that an agent reacts to messages sequentially, an agent can handle multiple messages concurrently, i.e., the agent first revises the agent_view and nogood_list according to the messages, and performs check_agent_view only once.</p><p>11. As in the asynchronous backtracking, the way to determine that agents as a whole have reached a stable state is not contained in this algorithm.</p><p>variable value to both lower and higher priority agents connected by constraints. We call these related agents neighbors.</p><p>• The priority value, as well as the current value assignment, is communicated through the ok? message (Fig. <ref type="figure" target="#fig_3">5i</ref>). • The priority order is determined using the communicated priority values. If the current value is not consistent with the agent_view, i.e., some constraint with variables of higher priority agents is not satisfied, the agent changes its value so that the value is consistent with the agent_view, and also the value minimizes the number of constraint violations with variables of lower priority agents (Fig. <ref type="figure" target="#fig_3">5ii</ref>). • When x i cannot find a consistent value with its agent_view, x i sends nogood messages to other agents, and increments its priority value. If x i has already sent an identical nogood, x i will not change its priority value but will wait for the next message (Fig. <ref type="figure" target="#fig_3">5iii</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Example</head><p>We illustrate the execution of the algorithm using the distributed 4-queens problem described in Section 4.4.</p><p>The initial values are shown in Fig. <ref type="figure" target="#fig_4">6a</ref>. Agents communicate these values with each other. The values within parentheses represent the priority values. The initial priority values are 0. Since the priority values are equal, the priority order is determined by the alphabetical order of identifiers. Therefore, only the value of x 4 is not consistent with its agent_view. Since there is no consistent value, agent x 4 sends nogood messages and increments its priority value. In this case, the value minimizing the number of constraint violations is 3, since it conflicts with x 3 only. Therefore, x 4 selects 3 and sends ok? messages to the other agents (Fig. <ref type="figure" target="#fig_4">6b</ref>). Then, x 3 tries to change its value. Since there is no consistent value, agent x 3 sends nogood messages, and increments its priority value. In this case, the value that minimizes the number of constraint violations is 1 or 2. In this example, x 3 selects 1 and sends ok? messages to the other agents (Fig. <ref type="figure" target="#fig_4">6c</ref>). After that, x 1 changes its value to 2, and a solution is obtained (Fig. <ref type="figure" target="#fig_4">6d</ref>).</p><p>In the distributed 4-queens problem, there exists no solution when x 1 's value is 1. We can see that the bad decision of x 1 (setting its value to 1) can be revised without an exhaustive search in the asynchronous weakcommitment search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Algorithm Completeness</head><p>The priority values are changed if and only if a new nogood is found. Since the number of possible nogoods is finite, 12 the priority values cannot be changed infinitely. Therefore, after a certain time point, the priority values will be stable. Then, we show that the situations described below will not occur when the priority values are stable: 1) There exist agents that do not satisfy some constraints, and all agents are waiting for incoming messages. 2) Messages are repeatedly sent/received, and the algorithm will not reach a stable state (infinite processing loop).</p><p>If situation 1) occurs, there exist at least two agents that do not satisfy the constraint between them. Let us assume that the agent ranking kth in the priority order does not satisfy the constraint between the agent ranking jth (where j &lt; k), and that all the agents ranking higher than kth satisfy all constraints within them. The only case that the kth agent waits for incoming messages even though the agent does not satisfy the constraint between the jth agent 12. The number of possible nogoods is exponential in the number of variables n.</p><p>is that the kth agent has sent nogood messages to higher priority agents. This fact contradicts the assumption that higher priority agents satisfy constraints within them. Therefore, situation 1) will not occur.</p><p>Also, if the priority values are stable, the asynchronous weak-commitment search algorithm is basically identical to the asynchronous backtracking algorithm. Since the asynchronous backtracking is guaranteed not to fall into an infinite processing loop, situation 2) will not occur.</p><p>From the fact that neither situation 1) nor 2) will occur, we can guarantee that the asynchronous weak-commitment search algorithm will always find a solution, or find the fact that no solution exists.</p><p>Since constraint satisfaction is NP-complete in general, the worst-case time complexity of the asynchronous weakcommitment search algorithm becomes exponential in the number of variables n. Furthermore, the worst-case space complexity is exponential in n. This result seems inevitable since this algorithm changes the search order flexibly while guaranteeing its completeness. We can restrict the number of recorded nogoods in the asynchronous weakcommitment search algorithm, i.e., each agent records only a fixed number of the most recently found nogoods. In this case, however, the theoretical completeness cannot be guaranteed (the algorithm may fall into an infinite processing loop in which agents repeatedly find identical nogoods). Yet, when the number of recorded nogoods is reasonably large, such an infinite processing loop rarely occurs. Actually, the asynchronous weak-commitment search can still find solutions for all example problems when the number of recorded nogoods is restricted to 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Security/Privacy of Agents</head><p>One reason for solving a distributed CSP in a distributed fashion is that agents might not want to communicate all the information to the centralized leader agent. Then, how much information do agents reveal using the asynchronous backtracking/weak-commitment search algorithm?</p><p>In both algorithms, agents communicate current value assignments and nogoods. By observing the value assignments of agent x i , other agents can gradually accumulate the information about the domain of x i . However, other agents cannot tell whether the obtained information of x i 's domain is complete or not. There might be other values of x i , which are not selected because they violate some constraints with higher priority agents.</p><p>Furthermore, agent x i never reveals the information about its constraints directly. A nogood message sent from x i is a highly summarized information about its constraints and nogoods sent from other agents. Therefore, we can see that the amount of information revealed by these algorithms are much smaller than the centralized methods, in which agents must declare precise information about their variable domains and constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EVALUATIONS</head><p>In this section, we evaluate the efficiency of algorithms by a discrete event simulation, where each agent maintains its own simulated clock. An agent's time is incremented by one simulated time unit whenever it performs one cycle of computation. One cycle consists of reading all incoming messages, performing local computation, and then sending messages. We assume that a message issued at time t is available to the recipient at time t + 1. We analyze the performance in terms of the number of cycles required to solve the problem. <ref type="bibr" target="#b11">13</ref> One cycle corresponds to a series of agent actions, in which an agent recognizes the state of the world (the value assignments of other agents), then decides its response to that state (its own value assignment), and communicates its decisions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Comparison Between Synchronous and Asynchronous Backtracking</head><p>First, we are going to compare the synchronous backtracking algorithm and the asynchronous backtracking algorithm. Since agents can act concurrently in the asynchronous backtracking algorithm, we can expect that the asynchronous backtracking algorithm will be more efficient than the synchronous backtracking algorithm. However, the degree of speed-up is affected by the strength of the constraints among agents. If the constraints among agents are weak, we can expect that the agents can easily reach a solution, even if they concurrently set their values. On the other hand, if the constraints among agents are strong, we can assume that until higher priority agents set their values properly, the lower priority agents cannot choose consistent values; thus the overall performance of the asynchronous backtracking algorithm becomes close to the one for synchronous backtracking.</p><p>To verify these expectations, we performed experimental evaluations on the distributed n-queens problem explained in the previous section. Each agent corresponds to each queen in a row. Therefore, the distributed n-queens problem is solved by n agents. In the distributed n-queens problem, constraints among agents become weak as n increases. Our results are summarized in the graph shown in Fig. <ref type="figure" target="#fig_5">7</ref>. To make the comparisons fair, we included dependency-directed backtracking in the synchronous backtracking. Each agent randomly selects a value among the consistent values with higher priority agents. The graph shows the average of 100 trials. 14 In the distributed n-queens problem, there exist constraints between any pair 13. One drawback of this model is that it does not take into account the costs of communication. However, introducing the communication costs into the model is difficult since we don't have any standard way for comparing communication costs and computation costs.</p><p>14. In this evaluation, we did not include the cost of determining the sequential order in the synchronous backtracking, nor the cost of the termination detection in the asynchronous backtracking. of agents. Therefore, the synchronous backtracking algorithm is basically equivalent to the Network Consistency Protocol described in <ref type="bibr" target="#b5">[7]</ref>. As we expected, the obtained parallelism of the asynchronous backtracking becomes larger as n increases. When n &gt; 18, the asynchronous backtracking is approximately two times as fast as the synchronous backtracking. <ref type="bibr" target="#b13">15</ref> Traditionally, distributed artificial intelligence applications involve having agents work on nearly independent, loosely coupled subproblems [1]. These results confirm that, if the local subproblems are loosely coupled, solving the problem asynchronously by multiple agents is worthwhile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Comparison Between Asynchronous Backtracking and Asynchronous Weak-Commitment Search</head><p>We are going to compare the following three kinds of algorithms:</p><p>1) asynchronous backtracking, in which a variable value is selected randomly from consistent values, and the priority order is determined by alphabetical order, 2) asynchronous backtracking with min-conflict heuristic, in which the min-conflict heuristic is introduced, but the priority order is statically determined by alphabetical order, and 3) asynchronous weak-commitment search. <ref type="bibr" target="#b14">16</ref> We first applied these three algorithms to the distributed n-queens problem described in the previous section, varying n from 10 to 1,000. The results are summarized in Table <ref type="table" target="#tab_0">1</ref>. 17 For each n, we generated 100 problems, each of 15. Since the asynchronous backtracking algorithm requires more messages than the synchronous backtracking for each cycle, the synchronous backtracking might be as efficient as the asynchronous backtracking due to the communication overhead, even though it requires more cycles.</p><p>16. The amount of communication overhead of these algorithms are almost equivalent. The amounts of local computation performed in each cycle for 2) and 3) are equivalent. The amount of local computation for 1) can be smaller since it does not use the min-conflict heuristic, but for the lowest priority agent, the amounts of local computation of these algorithms are equivalent.</p><p>17. Since the the min-conflict heuristic is very effective when n is very large <ref type="bibr" target="#b7">[9]</ref>, <ref type="bibr" target="#b15">[17]</ref>, we did not include the results for n &gt; 1,000. which had different randomly generated initial values, and averaged the results for these problems. For each problem, in order to conduct the experiments within a reasonable amount of time, we set the limit for the number of cycles at 1,000, and terminated the algorithm if this limit was exceeded. We show the average of the successful trials, and the ratio of problems completed successfully to the total number of problems in Table <ref type="table" target="#tab_0">1</ref>.</p><p>The second example problem is the distributed graphcoloring problem. This is a graph-coloring problem in which each node corresponds to an agent. The graphcoloring problem involves painting nodes in a graph by k different colors so that any two nodes connected by an arc do not have the same color. We randomly generated a problem with n nodes/agents and m arcs by the method described in <ref type="bibr" target="#b15">[17]</ref>, so that the graph is connected and the problem has a solution. We evaluated the problem for n = 60, 90, and 120, where m = n 2 and k = 3. This parameter setting corresponds to the "sparse" problems for which <ref type="bibr" target="#b15">[17]</ref> reported poor performance of the minconflict heuristic. We generated 10 different problems, and for each problem, 10 trials with different initial values were performed (100 trials in all). As in the distributed n-queens problem, the initial values were set randomly. The results are summarized in Table <ref type="table" target="#tab_1">2</ref>.</p><p>Then, in order to examine the applicability of the asynchronous weak-commitment search to real-life problems rather than artificial random problems, we applied these algorithms to the distributed resource allocation problem in a communication network described in <ref type="bibr" target="#b8">[10]</ref>. In this problem, there exist requests for allocating circuits between switching nodes of NTT's communication network in Japan (Fig. <ref type="figure" target="#fig_6">8</ref>). For each request, there exists an agent assigned to handle it, and the candidates for the circuits are given. The goal is to find a set of circuits that satisfies the resource constraints. This problem can be formalized as a distributed CSP by representing each request as a variable and each candidate as a possible value for the variable. We generated problems based on data from a 400 Mbps backbone network extracted from the network configuration management database developed in NTT Optical Network Systems Laboratories <ref type="bibr" target="#b18">[20]</ref>. In each problem, there exist 10 randomly generated circuit allocation requests, and for each request, 50 candidates are given. These candidates represent reasonably short circuits for satisfying the request. We assume that these candidates are calculated beforehand. The constraints between requests are that they do not assign the same circuits. We generated 10 different sets of randomly generated initial values for 10 different problems (100 trials in all), and averaged the results. As in the previous  problems, the limit for the required number of cycles was set at 1,000. The results are summarized in Table <ref type="table" target="#tab_2">3</ref>. We can see the following facts from these results:</p><p>• The asynchronous weak-commitment search algorithm can solve problems that cannot be solved within a reasonable amount of computation time by asynchronous backtracking algorithms. By using only the min-conflict heuristic, although a certain amount of speed-up can be obtained, the algorithm fails to solve many problem instances. • When the priority order is static, the efficiency of the algorithm is highly dependent on the selection of initial values, and the distribution of required cycles is quite large. For example, in the network resource allocation problem, when only the min-conflict heuristic is used, the average number of required cycles for 63 successfully completed trials is only 92.8. However, the number of required cycles for 37 failed trials is more than 1,000. When the initial values of higher priority agents are good, the solution can easily be found. If some of these values are bad, however, an exhaustive search is required to revise these values;</p><p>this tends to make the number of required cycles exceed the limit. On the other hand, in the asynchronous weak-commitment search, the initial values are less critical, and a solution can be found even if the initial values are far from the final solution, since the variable values gradually come close to the final solution.</p><p>• We can assume that the priority order represents a hierarchy of agent authority, i.e., the priority order of decision making. If this hierarchy is static, the misjudgments (bad value selections) of agents with higher priority are fatal to all agents. On the other hand, by changing the priority order dynamically and selecting values cooperatively, the misjudgments of specific agents do not have fatal effects, since bad decisions are weeded out, and only good decisions survive. These results are intuitively natural, since they imply that a flexible agent organization performs better than a static and rigid organization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS</head><p>In this paper, we develop the formalism for distributed constraint satisfaction problems, which can represent various application problems in Distributed Artificial Intelligence. We developed a basic algorithm for solving distributed CSPs, called asynchronous backtracking, in which agents act asynchronously and concurrently without any global control. Furthermore, we developed a more efficient algorithm called asynchronous weak-commitment search, which can revise a bad decision without exhaustive search, just as the weak-commitment search algorithm does for CSPs. We presented a series of experimental results to compare the efficiency of these algorithms. These results show that the asynchronous weak-commitment search algorithm can solve fairly large-scale problems such as the distributed 1,000-queens problem, the distributed graph-coloring problem, and the network resource allocation problem, within a reasonable amount of time.</p><p>Our future work includes examining the effectiveness of the asynchronous weak-commitment search algorithm in more practical applications, introducing other heuristics (e.g., forward-checking) into the asynchronous weakcommitment search algorithm, and clarifying the appropriate agent/variable ordering heuristics when each agent has multiple variables.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Example of a constraint network.</figDesc><graphic coords="4,78.51,60.96,143.72,90.26" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .Fig. 3 .</head><label>23</label><figDesc>Fig. 2. Procedures for receiving messages (asynchronous backtracking).</figDesc><graphic coords="5,120.64,60.99,335.48,350.99" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Example of algorithm execution (asynchronous backtracking).</figDesc><graphic coords="6,102.13,60.99,360.45,53.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Procedures for receiving messages (asynchronous weak-commitment search).</figDesc><graphic coords="8,114.26,60.99,336.19,427.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Example of algorithm execution (asynchronous weak-commitment search).</figDesc><graphic coords="9,120.27,60.99,336.19,56.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Comparison between synchronous and asynchronous backtracking (distributed n-queens).</figDesc><graphic coords="10,324.08,60.99,180.70,169.09" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Example of the network resource allocation problem.</figDesc><graphic coords="12,36.36,60.99,228.02,231.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE 1 COMPARISON</head><label>1</label><figDesc>BETWEEN ASYNCHRONOUS BACKTRACKING AND ASYNCHRONOUS WEAK-COMMITMENT SEARCH (DISTRIBUTED N-QUEENS)</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 2 COMPARISON</head><label>2</label><figDesc>BETWEEN ASYNCHRONOUS BACKTRACKING AND ASYNCHRONOUS WEAK-COMMITMENT SEARCH (DISTRIBUTED GRAPH-COLORING PROBLEM)</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 3 COMPARISON</head><label>3</label><figDesc>BETWEEN ASYNCHRONOUS BACKTRACKING AND ASYNCHRONOUS WEAK-COMMITMENT SEARCH (NETWORK RESOURCE ALLOCATION PROBLEM)</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We can consider the case that several agents share a variable. However, such a case can be formalized as these agents have different variables, and there exist constraints that these variables must have the same value.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In<ref type="bibr" target="#b9">[11]</ref>, an algorithm in which each agent has multiple variables is described.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>In<ref type="bibr" target="#b5">[7]</ref>, a variation of the synchronous backtracking algorithm called the Network Consistency Protocol is presented. In this algorithm, agents construct a depth-first search tree. Agents act synchronously by passing privilege, but the agents that have the same parent in the search tree can act concurrently.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>It must be emphasized that this constraint network has nothing to do with the physical communication network. The link in the constraint network is not a physical communication link, but a logical relation between agents.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors thank N. Fujii and I. Yoda for providing the network configuration management database, and Y. Nishibe for providing the example problems.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Multiagent Truth Maintenance</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Huhns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Bridgeland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">445</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Truth Maintenance System</title>
		<author>
			<persName><forename type="first">J</forename><surname>Doyle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="231" to="272" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multistage Negotiation for Distributed Constraint Satisfaction</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Conry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Lesser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">477</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Distributed Constrained Heuristic Search</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Sycara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">461</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">DATMS: A Framework for Distributed Assumption Based Reasoning</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Distributed Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Gasser</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Huhns</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="293" to="318" />
			<date type="published" when="1989">1989</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On the Feasibility of Distributed Constraint Satisfaction</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Collin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int&apos;l Joint Conf</title>
		<meeting>12th Int&apos;l Joint Conf</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="318" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Parallel and Distributed Algorithms for Finite Constraint Satisfaction Problems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mackworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third IEEE Symp. Parallel and Distributed Processing</title>
		<meeting>Third IEEE Symp. Parallel and Distributed essing</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="394" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Weak-Commitment Search for Solving Constraint Satisfaction Problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Nat&apos;l Conf. Artificial Intelligence</title>
		<meeting>12th Nat&apos;l Conf. Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="313" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Speed-Up of Distributed Constraint Satisfaction and Its Application to Communication Network Path Assignments</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Nishibe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ishida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Systems and Computers in Japan</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="54" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dynamic Variable/Value Ordering Heuristics for Solving Large-Scale Distributed Constraint Satisfaction Problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int&apos;l Workshop Distributed Artificial Intelligence</title>
		<meeting>12th Int&apos;l Workshop Distributed Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="407" to="422" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Constraint Satisfaction</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mackworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Encyclopedia of Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Shapiro</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley-Interscience</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="285" to="293" />
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Comparison of ATMS and CSP Techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>De Kleer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Int&apos;l Joint Conf</title>
		<meeting>11th Int&apos;l Joint Conf</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="290" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Distributed Constraint Satisfaction for DAI Problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ishida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th Int&apos;l Workshop Distributed Artificial Intelligence</title>
		<meeting>10th Int&apos;l Workshop Distributed Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">System Level Concurrency Control for Distributed Database Systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Rosenkrantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stearns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lewis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="178" to="198" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Distributed Snapshots: Determining Global States of Distributed Systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Computer Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="63" to="75" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Minimizing Conflicts: A Heuristic Repair Method for Constraint Satisfaction and Scheduling Problems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Minton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Johnston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Philips</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Laird</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="161" to="205" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Breakout Method for Escaping from Local Minima</title>
		<author>
			<persName><forename type="first">P</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Nat&apos;l Conf. Artificial Intelligence</title>
		<meeting>11th Nat&apos;l Conf. Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="40" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Dynamic Backtracking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ginsberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="25" to="46" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Network Configuration Management Database</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Fujii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yamanaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Yoda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NTT R&amp;D</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1" to="509" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Distributed Constraint Satisfaction for Formalizing Distributed Problem Solving</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Durfee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ishida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th IEEE Int&apos;l Conf. Distributed Computing Systems</title>
		<meeting>12th IEEE Int&apos;l Conf. Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="614" to="621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Asynchronous Weak-Commitment Search for Solving Distributed Constraint Satisfaction Problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First Int&apos;l Conf. Principles and Practice of Constraint Programming</title>
		<meeting>First Int&apos;l Conf. Principles and Practice of Constraint Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="88" to="102" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
