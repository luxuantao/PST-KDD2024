<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scenario-based Software Architecture Reengineering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Perolof</forename><surname>Bengtsson</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><surname>Bosch</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Karlskrona</orgName>
								<address>
									<country>Ronneby</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Business Administration</orgName>
								<address>
									<postCode>S-372 25, +46 457, 787 41</postCode>
									<settlement>Ronneby</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scenario-based Software Architecture Reengineering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B39D412A0AF82508EF0F943068F48C30</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>software architecture</term>
					<term>reengineering</term>
					<term>design methods</term>
					<term>reuse</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents a method for reengineering software architectures. The method explicitly addresses the quality attributes of the software architecture. Assessment of quality attributes is performed primarily using scenarios. Design transformations are done to improve quality attributes that do not satisfy the requirements. Assessment and design transformation can be performed for several iterations until all requirements are met. To illustrate the method, we use the reengineering of a prototypical measurement system into a domain-specific software architecture as an example.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Reengineering of a software system is generally initiated by major changes in the requirements the system should fulfil. These changes are often concerned with the software qualities rather than the functional requirements. For example, due to architecture erosion <ref type="bibr" target="#b18">[20]</ref>, the maintainability of the software system may have deteriorated. To improve this, the system is reengineered.</p><p>To the best of our knowledge, few architecture reengineering methods have been defined. Traditional system design methods tend to focus on the functionality that is to be provided by the system. They spend much less effort on the software quality requirements that are to be fulfilled by the system. Object-oriented methods, e.g., <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">12,</ref><ref type="bibr" target="#b22">24]</ref>, address re-usability but, generally, no assessment of the achieved result is done. Other research communities, e.g., real-time <ref type="bibr" target="#b14">[16]</ref> and fault-tolerant <ref type="bibr" target="#b26">[28]</ref>, have proposed design methods that incorporate design steps for supporting their respective software. However, these approaches generally focus on a single software quality.</p><p>We have learned from our projects with industry <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b17">19]</ref> that a system never is a pure real-time system, or a fault-tolerant system, or a reusable system. Instead, systems should provide all these properties and perhaps more. However, as identified in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b16">18]</ref>, software quality requirements often conflict, e.g., real-time versus reusability, flexibility versus efficiency, reliability versus flexibility, etc. The difficulty of system design originates from the need for carefully balancing of the various software qualities. For the discussion in this paper, we distinguish between development related software qualities, e.g., reusability and maintainability, and operational related software qualities, e.g., reliability and performance.</p><p>The software architecture determines, to a considerable extent, the ability of a system to fulfil its software quality requirements. Once the application architecture is finalised, the boundaries for most quality attributes have been set. On the other hand, architectural design and reengineering are the steps in software development that are least understood and supported by traditional means.</p><p>The contribution of this paper, we believe, is that we present a practical method for reengineering software architectures and illustrated it using a real-world example.</p><p>The remainder of this paper is organised as follows. In the next section, the example system that will be reengineered is presented. We discuss our architecture reengineering method in section 3. Section 4 provides an introduction to the measurement systems domain, the software quality requirements that should be fulfilled and the scenarios used to assess the requirements. In section 5, we illustrate the use of the method</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Example: Beer Can Inspection</head><p>To illustrate the architecture reengineering method, we use a beer can inspection system as a basis for the discussion in the remainder of the paper. The inspection system is located at the beginning of a beer can filling process and its goal is to remove dirty beer cans from the input stream. Clean cans should just pass the system without any further action.</p><p>The system consists of a triggering sensor, a camera and an actuator that can remove cans from the conveyer belt. When the hardware trigger detects a can, it send an trigger event to the software system. After a predefined amount of time, the camera takes a number of image samples of the can. Subsequently, the measured values, i.e., images, are compared to the ideal images and a decision about removing or not removing the can is made. If the can should be removed, the system invokes the actuator at a predefined time point relative to the trigger event. Figure <ref type="figure" target="#fig_3">1</ref> presents the process graphically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1. Example beer cans measurement system</head><p>Figure <ref type="figure">2</ref> presents the application architecture of the beer can system. The architecture was designed based on the functional requirements of the system without any explicit design effort with respect to software quality requirements such as reusability and performance.</p><p>We use the architecture of the presented system as the basis for creating a domain-specific software architecture (DSSA) <ref type="bibr" target="#b9">[11,</ref><ref type="bibr" target="#b27">29]</ref> that allows the software engineer to instantiate applications in the domain of measurement systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Architecture Reengineering Method</head><p>According to our experience, software engineers generally handle software quality requirements by a rather informal process during architecture design and reengineering. Once the system is implemented, it is tested to determine whether the software quality requirements have been met. If not, parts of the system are redesigned. We consider this approach unsatisfactory since the iteration over system development is generally very costly and, secondly, the redesign cannot be planned and budgeted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. Object model of the beer can application</head><p>Conventional design methods, e.g., <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">12,</ref><ref type="bibr" target="#b22">24]</ref>, tend to focus on achieving the required system functionality, rather than software qualities. The various software quality-based research communities identified this as unsatisfactory, and have proposed their own design methods for developing realtime <ref type="bibr" target="#b14">[16]</ref>, high-performance <ref type="bibr" target="#b26">[28]</ref> and reusable systems <ref type="bibr" target="#b11">[13]</ref>, respectively. However, all these methods focus on a single quality attribute and treat all others as having secondary importance, if at all. We consider these approaches unsatisfactory since the software engineer needs to balance the various quality attributes for any realistic system. However, lacking a supporting method, the software engineer designs and reengineers system architectures in an ad-hoc and intuition-based manner, with the associated disadvantages.</p><p>To address this, we have defined an architecture reengineering method that provides a more objective and still practical approach. In the remainder of this section, we present an overview of the method and refer to <ref type="bibr" target="#b5">[6]</ref> for a more extensive overview of the method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>The input for the architecture reengineering method consists of the updated requirements specification and the existing software architecture. As output, an improved architectural design is generated. In figure <ref type="figure">3</ref>, the steps in the method are presented graphically. 4. Software quality assessment. The design is again evaluated and the process is repeated from 3 until all software quality requirements are met or until the software engineer decides that no feasible solution exists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 3. Outline of the method</head><p>The architecture reengineering method has evolved through its application, in three projects, i.e., for fire-alarm systems <ref type="bibr" target="#b17">[19]</ref>, measurement systems <ref type="bibr" target="#b3">[4]</ref> and dialysis systems. In the following sections, the individual stages of the method are described in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Functionality-based architecture redesign</head><p>Based on the updated requirement specification, a redesign of the top-level decomposition of the system into its main components is performed. The main issue during this phase is to find and evaluate the core abstractions in the system. Although these abstractions are modelled as objects, our experience, see e.g., <ref type="bibr" target="#b17">[19]</ref>, is that these objects are not found immediately in the application domain. Instead, they are the result of a creative process that, after analysing the various domain entities, abstracts the most relevant properties and models them as architecture entities. Once the abstractions are identified, the interactions between them are defined in more detail.</p><p>The process of identifying the entities that make up the architecture is different from, for instance, traditional objectoriented design methods <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">12,</ref><ref type="bibr" target="#b22">24]</ref>. Those methods start by modelling the entities present in the domain and organise these in inheritance hierarchies, i.e., a bottom-up approach. Our experience is that during architectural design and reengineering it is not feasible to start bottom-up since that would require dealing with the details of the system. Instead its better to use a top-down approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Assessing software quality requirements</head><p>One of the core features of the architecture reengineering method is that the software qualities of a system or application architecture are explicitly evaluated. For assessing the architecture of the existing system, the system itself can be used. After the first transformation, however, no concrete system is available for evaluation. It is not possible to measure the quality attributes for the final system based on the architecture design. That would imply that the detailed design and implementation are a strict projection of the architecture. Instead, the goal is to evaluate the potential of the designed architecture to reach the software quality requirements. For example, some architectural styles, e.g., layered architectures, are less suitable for systems where performance is a major issue, although the flexibility of this style is high.</p><p>Four different approaches for assessing quality attributes have been identified, i.e., scenarios, simulation, mathematical modelling and experience based reasoning. For each quality attribute, the engineer can select the most suitable approach for evaluation. In the subsequent sections, each approach is described in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Scenario-based evaluation.</head><p>The assessment of a software quality using scenarios is done in these steps:</p><p>1. Define a representative set of scenarios. A set of scenarios is developed that concretises the actual meaning of the attribute. For instance, the maintainability quality attribute may be specified by scenarios that capture typical changes in requirements, underlying hardware, etc. 2. Analyse the architecture. Each individual scenario defines a context for the architecture. The performance of the architecture in that context for this quality attribute is assessed by analysis. Posing typical question <ref type="bibr" target="#b16">[18]</ref> for the quality attributes can be helpful (section 3.3). 3. Summarise the results. The results from each analysis of the architecture and scenario are then summarised into an overall results, e.g., the number of accepted scenarios versus the number not accepted.</p><p>The usage of scenarios is motivated by the consensus it brings to the understanding of what a particular software quality really means. Scenarios are a good way of synthesising individual interpretations of a software quality into a common view. This view is both more concrete than the general software quality definition[10], and it is also incorporating the uniqueness of the system to be developed, i.e., it is more context sensitive.</p><p>In our experience, scenario-based assessment is particularly useful for development related software qualities. Software qualities such as maintainability can be expressed very naturally through change scenarios. In <ref type="bibr" target="#b12">[14]</ref> the use of scenarios for evaluating architectures is also identified. The software architecture analysis method (SAAM) however, uses </p><p>(3) only scenarios and only evaluates the architecture in cooperation with stakeholders prior to detailed design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Simulation.</head><p>Simulation of the architecture <ref type="bibr" target="#b28">[30]</ref> using an implementation of the application architecture provides a second approach for estimating quality attributes. The main components of the architecture are implemented and other components are simulated resulting in an executable system. The context, in which the system is supposed to execute, could also be simulated at a suitable abstraction level. This implementation can then be used for simulating application behaviour under various circumstances.</p><p>Simulation complements the scenario-based approach in that simulation is particularly useful for evaluating operational software qualities, such as performance or fault-tolerance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Mathematical modelling.</head><p>Various research communities, e.g., high-performance computing <ref type="bibr" target="#b26">[28]</ref>, reliability <ref type="bibr" target="#b23">[25]</ref>, real-time systems <ref type="bibr" target="#b14">[16]</ref>, etc., have developed mathematical models, or metrics, to evaluate especially operation related software qualities. Different from the other approaches, the mathematical models allow for static evaluation of architectural design models.</p><p>Mathematical modelling is an alternative to simulation since both approaches are primarily suitable for assessing operational software qualities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4">Experience-based reasoning.</head><p>A fourth approach to assessing software qualities is through reasoning based on experience and logical reasoning based on that experience. Experienced software engineers often have valuable insights that may prove extremely helpful in avoiding bad design decisions and finding issues that need further evaluation. Although these experiences generally are based on anecdotal evidence, most can often be justified by a logical line of reasoning.</p><p>This approach is different from the other approaches. First, in that the evaluation process is less explicit and more based on subjective factors as intuition and experience. Secondly, this technique makes use of the tacit knowledge of the involved persons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Architecture transformation</head><p>Once the architecture properties have been assessed, the estimated values are compared to the requirements specification. If one or more of the software qualities are not met, the architecture has to be changed to achieve those. In the architectural reengineering method discussed in this paper, changes to the architecture are performed as architecture transformations. Each transformation leads to a new version of the architecture that has the same functionality, but different values for its quality attributes.</p><p>Five categories of architecture transformations have been identified. In the sections below, each category is discussed in more detail. <ref type="bibr" target="#b24">[26]</ref> and Buschmann et al. <ref type="bibr" target="#b6">[7]</ref> present several architectural styles that improve certain quality attributes for the system the style is imposed upon and impair other software qualities. Certain styles, e.g., the layered architectural style, increase the flexibility of the system by defining several levels of abstraction, but generally decrease the performance. With each architectural style, a fitness for each system property is associated. The most appropriate style for a system depends primarily on its software quality requirements. Transforming architecture by imposing an architectural style results in a major reorganisation of the architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Impose architectural style. Shaw and Garlan</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Impose architectural pattern.</head><p>A second category of transformations is the use of architectural patterns <ref type="bibr" target="#b6">[7]</ref>. These are different from architectural styles in that they are not predominant in the architecture. They are also different from design patterns since they affect the larger part of the architecture. Architectural patterns generally impose a rule <ref type="bibr" target="#b21">[23]</ref> on the architecture that specifies how the system will deal with one aspect of its functionality, e.g., concurrency or persistence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3">Apply design pattern.</head><p>A less dramatic transformation is the application of a design pattern <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b6">7]</ref> on a part of the architecture. For instance, an Abstract Factory pattern might be introduced to abstract the instantiation process for its clients. The Abstract Factory increases maintainability, flexibility and extensibility of the system since it encapsulates the actual component types(s) that are instantiated. Nevertheless, it decreases the efficiency of creating new instances due to the additional computation, thereby reducing performance and predictability. Different from imposing an architectural style or pattern, causing the complete architecture to be reorganised, the application of a design pattern generally affects only a limited number of components in the architecture. In addition, a component can be involved in multiple design patterns without creating inconsistencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.4">Convert quality requirements to functionality.</head><p>Another type of transformation is the conversion of a software quality requirement into a functional solution. This solution consequently extends the architecture with functionality not related to the problem domain but is used to fulfil a software quality requirement. Exception handling is a well-known example that adds functionality to a component to increase the fault-tolerance of the component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.5">Distribute requirements.</head><p>The final type of transformation deals with software quality requirements using the divide-and-conquer principle: a software quality requirement at the system level is distributed to the subsystems or components that make up the system. Thus, a software quality requirement X is distributed over the n components that make up the system by assigning a software quality requirement x i to each component c i such that X=x 1 + ... +x n . A second approach to distribute requirements is by dividing the software quality requirement into two or more software quality requirements. For example, in a distributed system, fault-tolerance can be divided into fault-tolerant computation and faulttolerant communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Measurement Systems</head><p>The domain of measurement systems denotes a class of systems used to measure the relevant values of a process or product. These systems are different from the, better known, process control systems in that the measured values are not directly, i.e., as part of the same system, used to control the production process that creates the measured product or process. Industry uses measurement systems for quality control on produced products, e.g., to separate acceptable from unacceptable products or to categorise the products in quality grades.</p><p>The goal of the reengineering project was to define a DSSA that provides a reusable and flexible basis for instantiating measurement systems. Although the software architecture of the beer can inspection system introduced in section 2 is a rather prototypical instance of a measurement system, we used it as a starting point. This application architecture, obviously, does not fulfil the software quality requirements of a DSSA. Consequently, it needs to be re-engineered and transformed to match the requirements.</p><p>The challenge of reengineering projects is to decide when one has achieved the point where the reengineered architecture fulfils its requirements. The functional requirements generally can be evaluated relatively easy by tracing the requirements in the design. Software quality requirements such as reusability and robustness, on the other hand, are much harder to assess. In the next section, we describe our approach to evaluating some of the software quality requirements put on the measurement system DSSA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Software quality requirements</head><p>The DSSA for measurement systems should fulfil a number of requirements. The most relevant software quality requirements in the context of this paper are reusability and maintainability. Measurement systems also have to fulfil real-time and robustness requirements, but we leave these out of the discussion in this paper.</p><p>As was described in section 3, development related software qualities are generally easiest assessed using scenarios. The assessment process consists of defining a set of scenarios for each software quality, manually executing the scenarios for the architecture and subsequently interpreting the result. The assessment can be performed in a complete or a statistical manner. In the first approach, a set of scenarios is defined that combined cover the concrete instances of the software quality. For instance, for reusability, all relevant ways of reusing the architecture or parts of it are represented by a scenario. If all scenarios are executed without problems, the reusability of the architecture is optimal. The second approach is to define a set of scenarios that is a representative sample without covering all possible cases. The ratio between scenarios that the architecture can handle and scenarios not handled well by the architecture provides an indication of how well the architecture fulfils the software quality requirements. Both approaches, obviously, have their disadvantages. A disadvantage of the first approach is that it is generally impossible to define a complete set of scenarios. The definition of a representative set of scenarios is the weak point in the second approach since it is unclear how does one decide that a scenario set is representative.</p><p>Despite these disadvantages, scenarios are a useful technique for evaluating development related software qualities. As Poulin <ref type="bibr" target="#b19">[21]</ref> concluded for reusability, no predominant approach to assessing the quality attribute exists. Although scenario-based evaluation depends on the objectivity and creativity of the software engineers that define and execute them. We have not experienced this to be a major problem in our projects. In the next two sections, the scenarios used for evaluating reusability and maintainability are defined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Reusability.</head><p>The reusability quality attribute provides a balance between the two properties; generality and specifics. First, the architecture and its components should be general because they should be applied in other similar situations. For example, a weight sensor component can be sufficiently generic to be used in several applications. Secondly, the architecture should provide concrete functionality that provides considerable benefit when it is reused.</p><p>To evaluate the existing application architecture we use scenarios. However, reusability is a difficult software property to assess. We evaluate by analysing the architecture with respect to each scenario and assess the ratio of components reused as-is and total number of components. Note that the scenarios are presented as vignettes <ref type="bibr" target="#b12">[14]</ref> for reasons of space.</p><p>R1 Product packaging quality control. For example, sugar packages that are both measured with respected to intact packaging and weight.</p><p>R2 Surface finish quality control where multiple algorithms may be used to derive a quality figure to form a basis for decisions.</p><p>R3 Quality testing of microprocessors where each processor is either rejected or given a serial number and test data logged in a quality history database in another system. R4 Product sorting and labelling, e.g., parts are sorted after tolerance levels and labelled in several tolerance categories and are sorted in different storage bins. R5 Intelligent quality assurance system, e.g., printing quality assurance. The system detects problems with printed results and rejects occasional misprints, but several misprints in a sequence might cause rejection and raising an alarm.</p><p>All presented scenarios require behaviour not present in the initial software architecture. However, the scenarios are realistic and measurement systems exist that require the functionality defined by the scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Maintainability.</head><p>In software-intensive systems, maintainability is generally considered important. A measurement system is an embedded software system and its function is very dependent on its context and environment. Changes to that environment often inflict changes to the software system. The goal for maintainability in this context is that the most likely changes in requirements are incorporated in the software system against minimal effort.</p><p>In addition, maintainability of the DSSA is assessed using scenarios. For the discussion in this paper, the following scenarios are applied on the DSSA. Again, the scenarios are presented as vignettes for reasons of space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M1</head><p>The types of input or output devices used in the system is excluded from the suppliers assortment and need to be changed. The corresponding software needs to be updated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M2</head><p>Advances in technology allows a more accurate or faster calculation to be used. The software needs to be modified to implement new calculation algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M3</head><p>The method for calibration is modified, e.g., from user activation to automated intervals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M4</head><p>The external systems interface for data exchange change. The interfacing system is updated and requires change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M5</head><p>The hardware platform is updated, with new processor and I/O interface.</p><p>These are the scenarios we have found to be representative for the maintenance of existing measurement systems. Of course, other changes may possibly be required, but are less likely to appear.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Applying the Method</head><p>In this section, we transform the application architecture using an iterative process in order to satisfy the software quality requirements put on the DSSA. First, we evaluate the software qualities of the application architecture. Subsequently, we identify the most prominent deficiency and transform the architecture to remove the deficiency. we repeat this process until all quality attributes have satisfactory levels for the defined software quality requirements.</p><p>For reasons of space, we do not present a complete analysis of the resulting architecture after every transformation, but summarise the results in table 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Application evaluation</head><p>We analyse the application architecture by asking a typical question for reusability, i.e., How much will I be able to reuse of the software<ref type="foot" target="#foot_0">1</ref> in the context of each reuse scenario. The results from this analysis and the transformations are shown in table 1. Every scenario is assigned a quote number of affected components in the scenario divided by the total number of components in the current architecture. For reusability this should be as close to one as possible, i.e., as many of the components as possible should be reusable as-is. For maintainability, this should be as low as possible, i.e., as few components as possible should need to be modified. These are the results:</p><p>Analysing the initial application using R1, we find that we can probably reuse the camera and the lever components. These are not necessarily dependent on the rest of the components to be useful. We get similar results from R2.</p><p>In R3, we find that the sensing device will have to be more complex and include sophisticated algorithms to work. The same goes for the actuating device that now also needs to be fed the data to imprint on the product. Therefore, it is most likely that none of the components can be reused. Similar for R4 we find increasingly complex actuation schemes. Hence, we cannot expect any reuse in this scenario either.</p><p>In R5 we find that the actuation device possibly could be reused. Because of using previous results, i.e., the actuation history, we need more sophisticated measurement items.</p><p>Then we follow the same procedure with the maintenance scenario. The question replaced, by How easy is it to fix<ref type="foot" target="#foot_1">2</ref> in the context of each maintenance scenario. These are the results:</p><p>In M1, we see that changing hardware interface for the lever, the trigger or the camera is possible to do without modification to any other components. It is concise enough. For one change only one component has to be modified.</p><p>It is worse for the result of M2. Modifying the calculation algorithm in the initial architecture is impossible for us to exclude changes to any of the components. Possibly, all components will have to be updated. Similar is the situation for M3. We cannot exclude any component that requires no modification.</p><p>In the case of M4, we may if the detailed design was done well enough get by with modification to only one component. Again, we cannot exclude any of the other components.</p><p>The last maintenance scenario, M5, will most likely require modification to all the components. No component can be excluded as not using any hardware specific services from the platform.</p><p>Based on the results from the analysis we make the following conclusions about the application architecture.</p><p>• Reusability is not to good in the initial architecture. The classes are tightly coupled and the reuse scenarios show limited possibilities to reuse as-is.</p><p>• Maintainability could also be better. One of the scenarios (M1) is satisfied. The other scenarios however, are not supported satisfactory. The main problem seems to be that a change is not very concise and not at all simple.</p><p>The results of the analysis indicate that the reusability and maintainability attributes of the architecture are not satisfying. In the remainder of this section, we present transformations for improving these attributes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Transformations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Component level transformations.</head><p>Problem. Although the beer cans application is a small set of classes, the task of changing or introducing a new type of items require the source code of most components to be changed. In all the specified reuse scenarios, the use of new types of measurement item is involved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Alternatives.</head><p>From the set of transformations categories described in section 5.2 first look for an architectural style that might fit our needs. An alternative could be to organise the system into a pipe&amp;filter architecture with sensing, data interpreting and actuation filters. A second alternative, and perhaps more natural for object oriented designers, is to capture the real-world correspondents of these classes and define relevant abstractions, i.e., to define them as components with an interface and behaviour. Support for this can be found in the scenarios.</p><p>Transformation. The pipes &amp; filters alternative requires changes to more than one filter for several scenarios, i.e., R2-R5 and M3-M5. Instead, we choose to 'componentify' the classes into the generic component definitions. The DSSA should be able to deal with the different kinds of items in a uniform way, and therefore the abstraction MeasurmentItem is introduced. Subsequently, component types Actuator, for the Re- moveLever, and Sensor, for the LineCamera, are defined. Different types of actuators can be defined as components of the type Actuator. The Trigger is defined as a specialised sensor component, with interface additions. The redesigned architecture is presented in figure <ref type="figure" target="#fig_1">4</ref>. In addition, the affected components are marked with (1) in figure <ref type="figure" target="#fig_2">5</ref>.</p><p>Problem resolved. The components introduced reduced the coupling between the components by use of the principle programming towards an interface and not an implementation. General software engineering experience tell us that this principle of programming give us benefits both in situations of reuse and maintenance. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Separation of component creation from trigger.</head><p>Problem. The introduction of the component types facilitates the introduction of several concrete components but does not remove the problem of type dependence at the time of component creation. Every time a client creates a component it needs to know the actual sensor, actuator and measurement item types. From a maintainability perspective, this is not at all concise or simple to modify.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Alternatives.</head><p>One can identify two alternatives to address this problem. The first is to introduce pre-processor macros in the source code to easily change all instances of component creation of the affected types. The second alternative is to use the Abstract Factory <ref type="bibr" target="#b8">[9]</ref> to centralise the information about concrete types.</p><p>Transformation. There are a number of drawbacks with the macro alternative; for example, it is a static solution that when changed, it must be recompiled. The ItemFactory could have an interface for changing the instantiation scheme. Therefore the Abstract Factory pattern is selected and a factory component is introduced to handle the instantiation of actuators, sensors and measurement items. See (2) in figure <ref type="figure" target="#fig_2">5</ref>.</p><p>Problem resolved. The trigger need no longer to know the actual type of measurement item to be created, but instead requests a new measurement item from the ItemFactory. The Trigger Sensor MeasurementItem Actuator MeasurementValue use of the Abstract Factory pattern did eliminate that problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Changing to strategies.</head><p>Problem. Different components in the measurement system perform similar tasks. Changes to these tasks require updating the source code of every component containing the same implementation for the task. For example, the measurement of a measurement item aspect could be performed by different methods. A change to the similar parts is not concise enough in the current design and inhibits the maintainability. The measurement item may pull data from sensor, the sensor may push data to measurement item or the sensors may pass on data whenever they are changed. These alternatives are common to all sensors, independent of their types, and a way of reusing this aspect of the sensor is desired.</p><p>Alternatives. The Strategy pattern <ref type="bibr" target="#b8">[9]</ref> allows more distinction between the method for getting input data and the method of deriving the actual value for the actuation decision.</p><p>Transformation. This increases the conciseness and the modularity of the architecture and should improve the maintainability. Since the reuser selects one out of many strategies will be somewhat reduced since we will have reuse smaller number of components as is. However, the benefits for maintainability outweigh the liabilities with loss in reusability. The Strategy pattern is applied to all components where we can identify a similar need • Sensor update strategy. The three variations (push, pull, on change) apply to how sensors pass their data. The strategies are OnChangeUpdate, ClientUpdate, and Peri- odicUpdate.</p><p>• Calculation strategy: Calculation of derived data and decisions show that there are similar methods to perform different tasks of different objects. Different calculation strategies can be defined. These strategies can be used by sensors, measurement items and actuators.</p><p>The newly introduced components are marked with (3) in figure <ref type="figure" target="#fig_2">5</ref>.</p><p>Problem resolved. Maintainability improved greatly from this transformation, to the cost of some reusability. The gain was substantial enough to motivate the trade-off.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4">Unification of actuation and calibration.</head><p>Problem. Calibration is performed by letting the system measure a manually inspected item and the values are stored as ideal. In normal service, deviations from the ideal values measured are considered faults. The calibration is supposed to be carried out at different times in run-time. Calibration of the measurement system is considered a special service not implemented using the concepts of the current architecture. This makes the system more tightly coupled, in the sense that the factory, the measurement item and the sensors need to be aware of the calibration state. This makes several components dependent of a common state and changes to modify calibration becomes complex. This is not good for maintainability, or for reusability. Alternatives. Two alternatives to decreasing the coupling due to dependency of the common state exist. First, the calibration is defined as a separate service that all sensors and measurement items must implement. Each component checks if its current state is calibration and then call its calibration services instead of the normal services. The second alternative is to use the strategy design pattern and identify that most of the calibration is really the same as for the normal measuring procedure. The difference is that the ideal measures have to be stored for later referencing.</p><p>Transformation. The first alternative is not desirable since this introduces behaviour that is not really the components responsibility. Instead we favour the second alternative and introduce a special case of an actuation strategy, i.e., the CalibrationStrategy. The result is that the calibration is performed with the calibration actuation strategy, and when invoked stores the ideal values where desired. See (4) in figure <ref type="figure" target="#fig_2">5</ref>.</p><p>Problem resolved. The use of the calibration strategy as a special type of actuation removes the dependence on a global state. This reduces the need to modify several components when modifying the calibration behaviour. Consequently, we have improved the maintainability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.5">Adding prototype to factory.</head><p>Problem. The introduction of the calibration strategy addressed most of the identified problems. However, there is a problem remaining, i.e., the calibration strategy is dependent on the implementation type the measurement item compo- </p><p>(1)</p><formula xml:id="formula_2">(1) (2) (3) (3) (3) (5)<label>(1)</label></formula><p>nent. This couples these two, so that the calibration strategy cannot be reused separate from the measurement item.</p><p>Alternatives. One alternative solution is to decrease the coupling by introducing intermediate data storage, e.g., a configuration file, where the ideal values are stored. The second alternative is to apply the Prototype design pattern <ref type="bibr" target="#b8">[9]</ref>. The ideal measurement item is stored in the ItemFactory and used as a template for subsequent measurement item instances.</p><p>Transformation. We decide to apply a variant of the prototype pattern. The calibration of the system is performed by setting the ItemFactory into calibration mode. When a realworld item triggers the ItemFactory, it creates a new measurement item with the normal sensors associated. The measurement item collects the data by reading the sensors, but when invoking the actuation strategy, instead of invoking the actuators, the calibration strategy causes the measurement item to store itself as a prototype entity at the item factory. The affected relation is marked (5) in figure <ref type="figure" target="#fig_2">5</ref>.</p><p>Problem resolved. The Prototype pattern was applied to the ItemFactory. Consequently, the calibration strategy no longer needs to know the concrete implementation of the measurement item. The only component in the system with knowledge about concrete component types is the ItemFactory. The information has been localised in a single entity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Final assessment</head><p>In table 1, the results from the final assessment of the domain specific software architecture for measurement systems are presented. Figure <ref type="figure" target="#fig_2">5</ref> contains the most relevant classes of the DSSA. As shown in the evaluation, the scenario M5 is not supported by the DSSA. However, since we estimate the like-lihood for scenario M5 rather low, we accept the bad score for that scenario. The results of the second transformation are especially relevant, since it illustrates the trade-off between reusability and maintainability (see figure <ref type="figure" target="#fig_4">6</ref>). Overall, we find the result from the transformations satisfying and the analysis of the scenarios shows substantial improvement. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>To the best of our knowledge, no architecture reengineering methods exists to date. Traditional design methods often focus on the system functionality <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">12,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b28">30]</ref> or on a single software quality, e.g., high-performance <ref type="bibr" target="#b26">[28]</ref>, real-time <ref type="bibr" target="#b14">[16]</ref> and reusable systems <ref type="bibr" target="#b11">[13]</ref>. Architecture design methods have been proposed by Shlaer &amp; Mellor <ref type="bibr" target="#b25">[27]</ref>, Kruchten <ref type="bibr" target="#b13">[15]</ref> and Bosch &amp; Molin <ref type="bibr" target="#b5">[6]</ref>. Different from architecture reengineering, architecture design methods start from the requirement specification only. <ref type="bibr">Boehm [3]</ref> discusses conflicts between, what he calls, quality requirements, but focuses on identifying these conflicts and solving them during requirement specification rather than during architectural design or reengineering.</p><p>Architecture evaluation is discussed by Kazman et al. <ref type="bibr" target="#b12">[14]</ref>. Their SAAM method also uses scenarios, but does not discuss other techniques for architecture evaluation. In addition, no relation to architecture (re)design is made. Further, the work described in <ref type="bibr" target="#b0">[1]</ref> primarily uses scenarios for architecture evaluation.</p><p>Architecture transformation uses the notions of architectural styles <ref type="bibr" target="#b24">[26]</ref>, architectural patterns <ref type="bibr" target="#b6">[7]</ref> and design patterns <ref type="bibr" target="#b8">[9]</ref>. However, rather than viewing these concepts as ready designs, we treat styles and patterns as active entities transforming an architecture from one version to another.  This paper presented method for reengineering software architectures that provides a practical approach to evaluating and redesigning architectures. The method uses four techniques for architecture evaluation, i.e., scenarios, simulation, mathematical modelling and experience based reasoning. To improve the architecture, five types of architecture transformations are available; to impose architectural style, to apply architectural pattern, to use design pattern, convert quality requirements to functionality and distribute quality requirements.</p><p>We illustrated the method using a concrete system from the measurement systems domain, i.e., a beer can inspection system. This system was reengineered into a domain-specific software architecture for measurement systems. The focus in this paper was on the reusability and maintainability requirements on the DSSA. Scenarios were defined for assessing each requirement. Although no predominant approach to assessing quality attributes of systems exists, this paper shows that scenarios provide a powerful means for practitioners. Architecture transformations provide an objective way to redesign since associated with each transformation, a problem is explicitly addressed, alternative transformations are investigated and the rationale for the design decisions is captured.</p><p>Future work includes the extensions of the reengineering method for more quality requirements and the application of the method in more industry case studies and projects.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Model after first transformation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. The Measurement Systems DSSA 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 .</head><label>1</label><figDesc>The UML notation for inheritance is used to show the equivalence in interfaces</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. The effect of each transformation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 : Analysis of architecture</head><label>1</label><figDesc></figDesc><table><row><cell>1,00</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0,80</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0,60</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0,00 0,20 0,40</cell><cell>1 2 3 4</cell><cell>5</cell><cell>6</cell><cell>R5</cell><cell>R4</cell><cell>R3</cell><cell>R2</cell><cell>R1</cell><cell>M1</cell><cell>M2</cell><cell>M3</cell><cell>M4</cell><cell>M5</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Modified from the original, 'Will I be able to reuse some of the software?' in<ref type="bibr" target="#b16">[18]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Modified from the original, 'Can I fix it?' in<ref type="bibr" target="#b16">[18]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors wish to thank Will Tracz for his constructive and detailed comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Recommend Best Industrial Practice for Software Architecture Evaluation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Abowd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Northrop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Moormann</forename><surname>Zaremski</surname></persName>
		</author>
		<idno>CMU/SEI-96-TR-025</idno>
		<imprint>
			<date type="published" when="1997-01">January 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Object-Oriented Analysis and Design with Applications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Booch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Benjamin/Cummings Publishing Company</publisher>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Aids for Identifying Conflicts Among Quality Requirements</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boehm</surname></persName>
			<affiliation>
				<orgName type="collaboration">IEEE Software</orgName>
			</affiliation>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Requirements Engineering (ICRE96)</title>
		<meeting><address><addrLine>Colorado</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-03">April 1996. March 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Design of an Object-Oriented Measurement System Framework</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>submitted</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Object-oriented Frameworks: Problems and Experiences</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Molin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mattsson</surname></persName>
		</author>
		<author>
			<persName><surname>Po Bengtsson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>submitted</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Software Architecture Design: Evaluation and Transformation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Molin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>submitted</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Buschmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jäkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Meunier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Rohnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stahl</surname></persName>
		</author>
		<title level="m">Pattern-Oriented Software Architecture -A System of Patterns</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">E</forename><surname>Fenton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Pfleeger</surname></persName>
		</author>
		<title level="m">Software Metrics -A Rigorous &amp; Practical Approach</title>
		<imprint>
			<publisher>International Thomson Computer Press</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Design Patterns Elements of Reusable Design</title>
		<author>
			<persName><surname>Gamma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison.Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>D'ippolito</surname></persName>
		</author>
		<idno>CMU/SEI-88-TR-30</idno>
		<title level="m">Proceedings of the Workshop on Domain-Specific Software Architectures</title>
		<meeting>the Workshop on Domain-Specific Software Architectures</meeting>
		<imprint>
			<date type="published" when="1990-07">July 1990</date>
		</imprint>
		<respStmt>
			<orgName>Software Engineering Institute</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Objectoriented software engineering. A use case approach</title>
		<author>
			<persName><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Christerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jonsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Övergaard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Software Reuse A Holistic Approach</title>
		<author>
			<persName><forename type="first">E</forename><surname>Karlsson Ed</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">SAAM: A Method for Analyzing the Properties of Software Architectures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Abowd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Webb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Software Engineering</title>
		<meeting>the 16th International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The 4+1 View Model of Architecture</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Krutchen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="page" from="42" to="50" />
			<date type="published" when="1995-11">November 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient Methods of Validating Timing Constraints</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced in Real-Time Systems</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Son</surname></persName>
		</editor>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="199" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Specification and Analysis of System Architecture Using Rapide</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Luckham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering, Special Issue on Software Architecture</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="336" to="355" />
			<date type="published" when="1995-04">April 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Mccall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Quality Factors, Software Engineering Encyclopedia</title>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="958" to="971" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Points &amp; Deviations -A pattern language for fire alarm systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Molin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ohlsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pattern Languages of Program Design</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Foundations for the Study of Software Architecture</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="40" to="52" />
			<date type="published" when="1992-10">October 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Measuring Software Reusability</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Poulin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Conference on Software Reuse</title>
		<meeting>the Third Conference on Software Reuse<address><addrLine>Rio de Janeiro, Brazil</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-11">November 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m">The RAISE Development Method, The RAISE Method Group</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Software Testing at the Architectural Level</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Software Architecture Workshop</title>
		<meeting>the Second International Software Architecture Workshop<address><addrLine>San Francisco, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-10">October 1996</date>
			<biblScope unit="page" from="68" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Blaha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Premerlani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Eddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
		<title level="m">Object-oriented modeling and design</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Statistical Usage Testing for Software Reliability Control</title>
		<author>
			<persName><forename type="first">P</forename><surname>Runeson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wohlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Informatica</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="195" to="207" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Software Architecture -Perspectives on an Emerging Discipline</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Recursive Design of an Application-Independentt Architecture</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shlaer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Mellor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="page" from="61" to="72" />
			<date type="published" when="1997-02">February 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Performance Engineering of Software Systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">U</forename><surname>Smith</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">DSSA (Domain-Specific Software Architecture) Pedagogical Example</title>
		<author>
			<persName><forename type="first">W</forename><surname>Tracz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="49" to="62" />
			<date type="published" when="1995-07">July 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Designing Object-Oriented Software</title>
		<author>
			<persName><forename type="first">B</forename><surname>Wirfs-Brock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName><surname>Wiener</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
