<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">HySAT: An efficient proof engine for bounded model checking of hybrid systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2006-12-21">21 December 2006</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Martin</forename><surname>Fränzle</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution" key="instit1">Research Group Hybrid Systems</orgName>
								<orgName type="institution" key="instit2">Carl-von-Ossietzky Universität</orgName>
								<address>
									<postCode>D-26111</postCode>
									<settlement>Oldenburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution" key="instit1">Research Group Hybrid Systems</orgName>
								<orgName type="institution" key="instit2">Carl-von-Ossietzky Universität</orgName>
								<address>
									<postCode>D-26111</postCode>
									<settlement>Oldenburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><surname>Herde</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution" key="instit1">Research Group Hybrid Systems</orgName>
								<orgName type="institution" key="instit2">Carl-von-Ossietzky Universität</orgName>
								<address>
									<postCode>D-26111</postCode>
									<settlement>Oldenburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution" key="instit1">Research Group Hybrid Systems</orgName>
								<orgName type="institution" key="instit2">Carl-von-Ossietzky Universität</orgName>
								<address>
									<postCode>D-26111</postCode>
									<settlement>Oldenburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">HySAT: An efficient proof engine for bounded model checking of hybrid systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2006-12-21">21 December 2006</date>
						</imprint>
					</monogr>
					<idno type="MD5">77240B7FFE2B21FF94E15CE3B346E495</idno>
					<idno type="DOI">10.1007/s10703-006-0031-0</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Verification</term>
					<term>Bounded model checking</term>
					<term>Hybrid systems</term>
					<term>Infinite-state systems</term>
					<term>Decision procedures</term>
					<term>Satisfiability</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we present HySAT, a bounded model checker for linear hybrid systems, incorporating a tight integration of a DPLL-based pseudo-Boolean SAT solver and a linear programming routine as core engine. In contrast to related tools like MathSAT, ICS, or CVC, our tool exploits the various optimizations that arise naturally in the bounded model checking context, e.g. isomorphic replication of learned conflict clauses or tailored decision strategies, and extends them to the hybrid domain. We demonstrate that those optimizations are crucial to the performance of the tool.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>During the last ten years, formal verification of digital systems has evolved from an academic subject to an approach accepted by the industry, with dozens of commercial tools now available and used by major companies. Among the most successful methods in formal verification of discrete systems is bounded model checking (BMC), as suggested by Groote et al. <ref type="bibr" target="#b21">[22]</ref> and by Biere et al. <ref type="bibr" target="#b7">[8]</ref>. The idea of BMC is to encode the next-state relation of a system as a propositional formula, unroll this to some given finite depth k, and to augment it with a corresponding finite unravelling of the tableau of (the negation of) a temporal formula in order to obtain a propositional SAT problem which is satisfiable iff an error trace of length k exists. Enabled by the impressive gains in performance of propositional SAT checkers in recent years, BMC can now be successfully applied even to very large finite-state designs.</p><p>Though originally formulated for discrete transition systems only, the basic idea of BMC to reduce the search for an error path to a satisfiability problem of a formula also applies to hybrid discrete-continuous systems. However, the BMC formulae arising from such systems are no longer purely propositional, but usually comprise complex Boolean combinations of arithmetic constraints over real-valued variables, thus entailing the need for new decision procedures to solve them.</p><p>Our tool HySAT provides a decision procedure that is tailored to fit the needs of BMC of infinite-state systems with piecewise linear variable updates, e.g. of linear hybrid automata. HySAT tightly integrates a state-of-the-art Davis-Putnam style SAT solver for pseudo-Boolean constraints with a linear programming routine, combining the virtues of both methods: Linear programming adds the capability of solving large conjunctive systems of linear inequalities over the reals, whereas the SAT solver accounts for fast Boolean search and efficient handling of disjunctions.</p><p>The idea to combine algorithms for SAT with decision procedures for conjunctions of numerical constraints in order to solve arbitrary Boolean combinations thereof has been pursued by several groups. A tight integration of a resolution based SAT checker with linear programming has first been proposed and successfully applied to planning problems by Wolfman and Weld <ref type="bibr" target="#b38">[39]</ref>. More recently, Audemard et al. <ref type="bibr" target="#b1">[2]</ref> have followed up with MathSAT, a tool combining SAT solving with a Bellman-Ford algorithm for difference logic constraints and a simplex algorithm for general linear constraints, used for applications in the context of temporal reasoning and model checking of timed automata. Tools supporting a more general class of formulae are CVC <ref type="bibr" target="#b4">[5]</ref> and ICS <ref type="bibr" target="#b13">[14]</ref>, both integrating decision procedures for various theories, including Boolean logic, linear real arithmetic, uninterpreted function symbols, functional arrays, and abstract data types.</p><p>However, except for HySAT, all tools mentioned above lack some or all of the particular optimizations that arise naturally in the bounded model checking context. As observed by Strichman <ref type="bibr" target="#b33">[34]</ref>, BMC yields SAT instances that are highly symmetric as they comprise a k-fold unrolling of the systems transition relation. This special structure can be exploited to accelerate solving, e.g. by copying the explanation for a conflict which was encountered during the backtrack search performed by the SAT solver, to all isomorphic parts of the formula in order to prune similar conflicts from the search tree. This technique, in the following referred to as isomorphy inference, has been shown to yield considerable performance gains when performing BMC with propositional SAT engines. To the best of our knowledge, HySAT is the first solver that extends isomorphy inference accross transitions, as well as other domain-specific optimizations described in <ref type="bibr" target="#b33">[34]</ref>, to the hybrid domain. We will show that, compared to purely propositional BMC, similar or even higher performance gains can be accomplished within this context. The reason is that an inference step in the hybrid domain is computationally much more expensive than in propositional logic, as now richer logics have to be dealt with.</p><p>The paper is organized as follows. In the following two sections we explain the logical language solved by our SAT checker and review briefly how a linear hybrid automaton can be translated into a predicative formula suitable for bounded model checking. In Section 4 we explain in detail the algorithmic ingredients of HySAT. In particular, we discuss the BMC-specific optimizations implemented in our tool. In Section 5 we report some experimental results, and Section 6 draws conclusions and describes directions for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The logics</head><p>As we are aiming at automated state-exploratory analysis of linear hybrid automata <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25]</ref> without prior finite-state abstraction, HySAT addresses satisfiability problems in a twosorted logics entailing Boolean-valued and real-valued variables. When encoding properties of linear hybrid automata, the Boolean variables are used for encoding the discrete state components, while the real variables represent the continuous state components.</p><p>The formulae are actually propositional, being conjunctions of linear zero-one constraints <ref type="bibr" target="#b18">[19]</ref> (also known as pseudo-Boolean constraints <ref type="bibr" target="#b5">[6]</ref>) for the Boolean part and of guarded linear constraints <ref type="bibr" target="#b38">[39]</ref> for the real-valued part:</p><formula xml:id="formula_0">formula ::= {clause ∧} * clause clause ::= linear ZO constraint | boolean var =⇒ linear constraint</formula><p>Here, linear constraint denotes a conjunction of linear inequalities over real-valued variables, i.e. the constraint part of an arbitrary linear program, while linear ZO constraint denotes a linear inequality over Boolean-valued variables. The reason for using linear zeroone constraint clauses instead of, e.g., disjunctive clauses (like in conjunctive normal forms) is that linear zero-one constraints are much more concise than disjunctive clauses and that we have a very efficient SAT solver-called "Goblin" <ref type="bibr" target="#b18">[19]</ref>-for such constraint systems, yielding the base engine for HySAT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Zero-one linear constraints</head><p>Rewriting arbitrary propositional formulae to conjunctive normal form (CNF) yields a worstcase exponential blowup in formula size if the number of propositional variables is to be preserved. To avoid this, all practical verification environments take advantage of satisfiabilitypreserving transformations that yield linear-size encodings through introduction of a linear number of auxiliary variables <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b36">37]</ref>. The price for introducing a linear number of auxiliary variables is, however, a worst-case exponential blow-up in the size of the search tree upon backtrack search. Yet, it has been observed that both causes of blow-up can often be avoided, as the Davis-Putnam-Loveland-Logemann search procedure for satisfying valuations generalizes smoothly to zero-one linear constraint systems (ZOLCS), which are the constraint parts of zero-one linear programs <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b37">38]</ref>. Zero-one linear constraint systems are expressive enough to facilitate a linear-size encoding of, e.g., gate-level netlists without use of auxiliary variables.</p><p>In a zero-one linear constraint system or linear pseudo-Boolean constraint systems, formulae are conjunctions of linear zero-one constraints. A linear zero-one constraint is of the form a 1 x 1 + a 2 x 2 + • • • a n x n ≥ k, where the x i are literals, i.e. positive or negated propositional variables, the a i are natural numbers, called the weights of the individual literals, and k ∈ N is the threshold.</p><p>Given a Boolean valuation of the propositional variables, a zero-one constraint is satisfied iff its left hand side evaluates to a value exceeding the threshold when the truth values false and true of the literals are identified with 0 and 1, respectively. Zero-one constraints can represent a wide class of monotonic Boolean functions, e.g. 1a where BV is a countable set of Boolean variable names.</p><formula xml:id="formula_1">+ 1b + 1c + 1d ≥ 1 is equivalent to a ∨ b ∨ c ∨ d, 1a + 1b + 1c + 1d ≥ 4 is equivalent to a ∧ b ∧ c ∧ d, and 1a + 1b + 3c + 1d ≥ 3 is equivalent to c =⇒ (a ∧ b ∧ d).</formula><p>Zero-one constraints are interpreted over Boolean valuations σ B :</p><formula xml:id="formula_2">BV total -→ B of the propositional variables. σ B satisfies a constraint a 1 x 1 + a 2 x 2 + • • • a n x n ≥ k iff a 1 χ σB (x 1 ) + a 2 χ σB (x 2 ) + • • • a n χ σB (x n ) ≥ k, where χ σB (x) = ⎧ ⎪ ⎨ ⎪ ⎩ 0 i fx ∈ V and σ B (x) = false, 1 i fx ∈ V and σ B (x) = true,</formula><p>1 -χ σB (y) if x ≡ y for some y ∈ V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Guarded linear constraints</head><p>Zero-one constraints can only express constraints on Boolean variables. A second kind of clauses in our logics is Boolean-guarded linear constraints which express (linear) constraints between real-valued variables, as well as their interdependence with the Boolean valuation.</p><p>A guarded linear constraint simply is an implication boolean var =⇒ linear constraint between a Boolean variable and a linear constraint over real-valued variables, i.e. a conjunction of linear inequations. Such a guarded linear constraint is interpreted over a valuation</p><formula xml:id="formula_3">σ = (σ B , σ R ) ∈ (BV total -→ B) × (RV total -→ R)</formula><p>, where RV is the set of real variables occurring in linear constraints. The guarded linear constraint v =⇒ c is satisfied by σ</p><formula xml:id="formula_4">= (σ B , σ R ) iff σ R satisfies the linear constraint c or if σ B (v) = false.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Satisfaction of formulae</head><p>A formula φ is a conjunction of linear zero-one constraints and of guarded linear constraints and is thus interpreted over valuations</p><formula xml:id="formula_5">σ = (σ B , σ R ) ∈ (BV total -→ B) × (RV total -→ R).</formula><p>Obviously, φ is satisfied by σ = (σ B , σ R ), denoted σ |= φ, iff all linear zero-one constraints in φ are satisfied by σ B and all guarded linear constraints in φ are satisfied by (σ B , σ R ).</p><p>When solving satisfiability problems of formulae with Davis-Putnam-like procedures, we will build valuations incrementally such that we have to reason about partial valua- -→ B) × (RV part.</p><p>-→ R) of variables. We say that a variable v ∈ BV ∪ RV is unassigned in ρ iff v ∈ dom(ρ B ) ∪ dom(ρ R ). A partial valuation ρ is called consistent for a formula φ iff there exists a total extension σ: (BV total -→ B) × (RV total -→ R) of ρ that satisfies φ. Otherwise, we call ρ inconsistent for φ. Furthermore, a partial valuation ρ is said to satisfy φ iff all its total extensions satisfy φ. As this definition of satisfaction agrees with the previous one on total valuations, we will use the same notation ρ |= φ for satisfaction by partial and by total valuations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Predicative encoding of linear hybrid automata</head><p>A linear hybrid automaton A = ( , T, R, inv, l, u, m, g, ass, init), as depicted in Fig. <ref type="figure" target="#fig_1">1</ref>, consists of r a finite set of locations, r a finite set T of transitions, r a finite set R of continuous state components, r a family inv = (inv σ ) σ ∈ of state invariants, where each state invariant inv σ is a linear predicate over R which constrains the valuations of the continuous state components when control resides in the discrete location σ , r two families l = (l σ,x ) σ ∈ ,x∈R and u = (u σ,x ) σ ∈ ,x∈R assigning to each location σ ∈ and each continuous state component x ∈ R the minimum and maximum slope of x while control resides in location σ . The individual l σ,x are constants in Q ∪ {-∞} and similarly</p><formula xml:id="formula_6">u σ,x ∈ Q ∪ {∞}.</formula><p>r a mapping m : T total -→ 2 assigning to each transition the pair of source and sink state of the transition, r a family g = (g t ) t∈T assigning to each transition a transition guard enabling that transition, where the transition guard is a linear predicate over R, r a family ass = (ass t ) t∈T assigning to each transition a (possibly nondeterministic) assign- ment which is a linear predicate over R and R , where R denotes primed variants of the state components in R. The interpretation is that undecorated state components x ∈ R refer to the state immediately before the transition, while the primed variant x ∈ R refers to the state immediately thereafter. r a family init = (init σ ) σ ∈ of initial state predicates, where each init σ is a linear predicate over R which constrains the valuations of the continuous state components when control resides initially in the discrete location σ . <ref type="foot" target="#foot_0">1</ref>Hybrid automata engage in an alternation of continuous evolutions and discrete transitions. A continuous evolution of A = ( , T, R, inv, l, u, m, g, ass, init) can be represented by a tuple (σ, x, δ, x ) consisting of a discrete state σ ∈ the automaton resides in, a source continuous state x ∈ (R total -→ R) and a target continuous state x ∈ (R total -→ R), as well as a duration δ ∈ R ≥0 . Such a tuple is a continuous evolution of A iff for each y ∈ R it holds that x (y) ≥ x(y) + l σi ,y • δ and x (y) ≤ x(y) + u σi ,y • δ, and both x and x satisfy inv σ . Thus, δ represents the duration of A residing in state σ , and all continuous variables y evolve according to their slope bounds, and the invariant is true in the start and the end state (and thus, by convexity, in between). Similarly, an immediate transition can be represented by a tuple (σ, x, σ , x ) consisting of a discrete source state σ ∈ and a discrete target state σ , plus a continuous source state x ∈ (R total -→ R) and a continuous target state x ∈ (R total -→ R). Such a tuple is an immediate transition iff there is a transition t ∈ T with m(t) = (σ, σ ) such that x satisfies g t and such that ass t is satisfied if x is substituted for the variables in R and x is substituted for the variables in R .</p><p>A run r = (σ 0 , x 0 , δ 0 , x 0 ), . . . ,</p><formula xml:id="formula_7">(σ n , x n , δ n , x n ) ∈ ( × (R total -→ R) × R ≥0 × (R total -→ R))</formula><p>* is a sequence of continuous evolutions of A linked by immediate transitions and grounded in a viable initial state. I.e., a run r satisfies the following properties:</p><formula xml:id="formula_8">r Initialization: x 0 satisfies init σ 0 .</formula><p>r Progression by continuous evolution: for all i, the tuple (</p><formula xml:id="formula_9">σ i , x i , δ i , x i ) is a continuous evolution of A.</formula><p>r Progression by immediate transitions: the tuple (σ i , x i , σ i+1 , x i+1 ) is an immediate tran- sition of A for all i &lt; n.</p><p>In order to perform bounded model checking (BMC) <ref type="bibr" target="#b7">[8]</ref> with HySAT, i.e. checking of validity of temporal properties on finite unrollings of a transition system, we need to encode all runs of a given length k ∈ N in HySAT's logics. There are various ways of doing this, all with specific strengths and weaknesses. Yet all the reasonable ones share the property of featuring a plethora of structurally similar sub-formulae stemming from the iterated application of the transition relation and from the iterated continuous evolution in the k-fold unrolling. In order to exemplify this, we present here one particular form of such an unrolling which is very similar to the one used by Audemard et al. for MathSAT-based BMC of linear hybrid automata <ref type="bibr" target="#b2">[3]</ref> and by Bemporad et al. for MILP-based BMC of linear hybrid automata <ref type="bibr" target="#b6">[7]</ref>.</p><p>Let A = ( , T, R, inv, l, u, m, g, ass, init) be a linear hybrid automaton. In order to encode a transition sequence of A of some given length k ∈ N, we proceed as follows:</p><p>1. For each discrete state σ ∈ we take k + 1 Boolean variables σ i , with 0 ≤ i ≤ k. The value of σ i encodes whether the automaton A is in state σ in step i. Here, we take "onehot" encoding, i.e. σ i = true iff A is in state σ in step i. With one-hot encoding, there consequently is, for any i ≤ k, exactly one σ ∈ such that σ i holds, which is enforced in the BMC formula by the 2k + 2 linear zero-one constraints</p><formula xml:id="formula_10">k i=0 σ ∈ 1σ i ≤ 1 ∧ k i=0 σ ∈ 1σ i ≥ | | -1 2.</formula><p>For each transition t ∈ T we take k Boolean variables t i , with 1 ≤ i ≤ k. The value of t i encodes via one-hot encoding whether the ith move in the run is transition t.</p><p>Wellformedness of the unrolling in the sense that exactly one transition is taken in each step is guaranteed by conjunctively adding the 2k linear zero-one constraints</p><formula xml:id="formula_11">k i=1 t∈T 1t i ≤ 1 ∧ k i=1 t∈T 1t i ≥ |T | -1</formula><p>to the formula. 3. For each continuous state component x ∈ R we take k + 1 real-valued variables x i and another k + 1 real-valued variables x i , with i ≤ k. The value of x i encodes the value of x immediately after the ith transition in the run, whereas x i represents the value immediately before transition (i + 1). For each i ≤ k we do, furthermore, take one real-valued variable δ i representing the time spent in the ith state of the run. This allows us to formalize the continuous evolutions by conjoining the guarded linear constraint</p><formula xml:id="formula_12">σ i =⇒ (x i ≥ x i + l σ,x δ i ∧ x i ≤ x i + u σ,x δ i )</formula><p>for each σ ∈ and each i ≤ k to the formula. <ref type="foot" target="#foot_1">2</ref> Furthermore, we have to keep track of the state invariants, which are enforced by the guarded linear constraints</p><formula xml:id="formula_13">σ i =⇒ inv σ i x i 1 , . . . , x i n x 1 , . . . , x n ∧ inv σ i x i 1 , . . . , x i n x 1 , . . . , x n ,</formula><p>where {x 1 , . . . , x n } = R. 4. The interplay between discrete states and transitions requires that t i implies σ i-1 and σ i for (σ, σ ) = m(t). With linear zero-one constraints, this can be expressed by a single constraint</p><formula xml:id="formula_14">2t i + 1σ i-1 + 1 σ i ≥ 2</formula><p>for each t ∈ T and each 1 ≤ i ≤ k. Furthermore, enabledness of the transition, i.e. validity of the transition guard, is enforced through the guarded linear constraint</p><formula xml:id="formula_15">t i+1 =⇒ g t x i 1 , . . . , x i n x 1 , . . . , x n .</formula><p>Likewise, assignments are dealt with by</p><formula xml:id="formula_16">t i+1 =⇒ ass t x i 1 , . . . , x i n x 1 , . . . , x n x i 1 , . . . , x i n x 1 , . . . , x n</formula><p>5. Finally, we have to add constraints describing the allowable initial states through the guarded linear constraint system</p><formula xml:id="formula_17">σ ∈ (σ 0 =⇒ init σ )</formula><p>Satisfying valuations of the formula thus obtained are in one-to-one correspondence to the runs of A of length k. As in BMC <ref type="bibr" target="#b7">[8]</ref>, satisfaction of temporal properties on all runs of depth k can thus be checked by adding to the formula the k-fold unrolling of a tableaux of the (negated) property, then checking the resulting formula for unsatisfiability. Using standard techniques from predicative semantics <ref type="bibr" target="#b22">[23]</ref>, the translation scheme can be extended to both shared variable and synchronous message-passing parallelism, thereby yielding formulae of size linear in the number of parallel components. Note that, except for step (5) of above encoding scheme, all steps generate multiple copies of the same basic formula, where the k or k + 1 individual copies differ just in a consistent renaming of the variables. Therefore, a satisfiability checker tailored towards BMC of hybrid automata should exploit such isomorphies between subformulae for accelerating satisfiability checking, which is the distinguishing feature of HySAT. In order to simplify detection of isomorphic copies, HySAT is in fact fed with just a single copy of the transition and evolution predicates and performs the unrolling itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Ingredients of HySAT</head><p>The predicative encoding outlined above yields formulae which are Boolean combinations of linear arithmetic contraints. To deal with such formulae, HySAT's main components are r the solver core, consisting of a tight integration of a SAT solver with a linear programming routine, described in Section 4.1, and enhanced with domain-specific optimizations for BMC, as explained in Section 4.2, r an API to the solver core, providing methods for formula generation, simplification, com- mon subexpression eliminiation, and for rewriting the resulting formula into a conjunctive form, namely a conjunction of zero-one linear constraints and guarded linear constraints, which is the input format of the solver core, r a frontend, consisting of HySAT's input language and a bounded model checker, which performs the unwinding of the transition relation and controls the solver core via API calls.</p><p>To fit the needs of BMC, which involves checking the same system on different unrolling depths, the solver core and the API are designed to work in an incremental fashion in the sense that they allow to add (as well as delete) successively sets of constraints to (from) an existing problem and then redo the satisfiability check without starting SAT search from scratch each time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Integration of DPLL-SAT and linear programming</head><p>Before addressing the integration of a propositional SAT solver with linear programming, we first briefly review some basics of the individual methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Boolean SAT</head><p>The best currently known procedures for deciding Boolean SAT problems implement variants of the classical Davis-Putnam-Loveland-Logemann (DPLL) procedure <ref type="bibr" target="#b12">[13]</ref> and are based on backtracking in the space of partial value assignment. Given a Boolean formula in conjunctive normal form (CNF) and a partial valuation ρ, which is empty at the start, the DPLL procedure incrementally extends ρ until either ρ |= φ holds or ρ turns out to be inconsistent for φ, in which case another extension is tried through backtracking. Extensions are constructed by performing decision steps, which entail selecting an unassigned variable "blindly" and assigning a truth-value to it, each followed by a deduction phase, involving the search for propagating clauses that require certain assignments in order to preserve their satisfiability, where execution of the implied assignments might cause the need for further such assignments, in this context also referred to as implications. However, deduction may also yield a conflicting clause which has all its literals assigned false, indicating the need for backtracking.</p><p>Like all pure backtracking algorithms, the classical DPLL procedure suffers from thrashing, i.e. repeated failure due to the same reason. To overcome this problem, modern SAT solvers implement a technique called conflict-driven learning <ref type="bibr" target="#b39">[40]</ref>, which attempts to derive sufficiently general reasons for conflicts being encountered and stores them for future guidance of the search. The standard scheme traces the reason back to a small (ideally minimal) number of assignments that triggered the particular conflict, and stores this reason by adding the negation of that assignment as as clause, termed conflict clause, to the clause database. Besides learning, state-of-the-art SAT solvers, as the one being integrated in HySAT, enhance the basic DPLL procedure by sophisticated heuristics for selecting the assignment performed at decision steps <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b28">29]</ref>, and add various algorithmic refinements, among them non-chronological backtracking <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b28">29]</ref>, random restarts <ref type="bibr" target="#b3">[4]</ref> and lazy clause evaluation <ref type="bibr" target="#b28">[29]</ref>, to accelerate the proof search.</p><p>A pecularity of HySAT's SAT solver is its ability to directly handle linear zero-one constraint systems, a considerably more concise language than CNF.</p><p>DPLL on linear zero-one constraints. The DPLL procedure can easily be generalized from CNF to ZOLCS through adapting its deduction procedure to the following propagation rule for linear zero-one constraints: A zero-one constraint a i x i ≥ k propagates a literal x j iff setting this literal to false would make the constraint unsatisfiable, i.e. iff a ia j &lt; k. Note, that in contrast to a CNF clause, a zero-one constraint can propagate several literals simultaneously. As an example consider the constraint 5a + 3b + 3c + 1d + 1e ≥ 7 which propagates b and c immediately after setting a to false. Carrying out the assignments b → false and c → true reduces the constraint to 1d + 1e ≥ 1 which shows that, as opposed to CNF-SAT, a zero-one constraint is not necessarily satisfied after propagation, and might thus become propagating more than once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generalization of lazy clause evaluation.</head><p>While the above generalization of the DPLL procedure to ZOLCS has already been proposed by <ref type="bibr">Barth [6]</ref>, its acceleration through lazy clause evaluation for zero-one constraints is a recent addition by Chai and Kuehlmann <ref type="bibr" target="#b9">[10]</ref> and the authors of this paper <ref type="bibr" target="#b19">[20]</ref>.</p><p>A naive implementation of the deduction phase of DPLL would identify propagating clauses by visiting, after each assignment, all clauses containing the literal falsified by that assignment, as such clauses might have become propagating. The key idea of the enhanced algorithm is to watch only a subset of literals in each clause, and not to visit the clause when any other literal is assigned, as the watched set provides evidence for the clause to be non-propagating.</p><p>To apply lazy clause evaluation to zero-one constraints we have to determine a subset of unassigned literals from each constraint such that watching these literals is sufficient for detecting change of clause state from normal to propagating. Obviously, we are looking for minimal sets with this property in order to avoid unnecessary visits of constraints.</p><p>To this end, we arrange the literals of each constraint with respect to their weights, such that the literal with the largest weight is the leftmost one. Then we read the constraint from left to right and select the literals to be watched as follows:</p><p>1) The leftmost unassigned literal is selected.</p><p>2) The following literals are selected from the remaining unassigned ones until the sum of their weights, not including the weight of the leftmost unassigned literal, is greater than or equal to the constant on the righthand side of the constraint.</p><p>If a watched literal of a zero-one constraint is assigned false, our algorithm tries to reestablish a set of literals which is in accordance to rules (1) and ( <ref type="formula">2</ref>). This requires the search for a minimal set of literals which are either unassigned or true and whose weights sum up to a value that at least equals that of the watched literal which has been assigned false. If such a set exists then it is added to the set of watched literals to replace the one which has dropped out. If no such set exists then this indicates that the constraint has become a propagating one. The resulting propagations are determined by application of the propagation rule from the previous paragraph. Figure <ref type="figure" target="#fig_2">2</ref> illustrates the actions performed by the lazy clause-evaluation scheme by means of an example clause.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Linear programming</head><p>Linear programming deals with finding extremal values of a linear objective function when the variables are constrained by linear (in)equations, i.e. with problems that can be put in the general form maximize c T x</p><formula xml:id="formula_18">subject to A x ≥ b (1)</formula><p>where x is the vector of variables to be solved for, and A, b and c are given matrices or vectors of known coefficients. The linear expression c T x is called the objective function, (1) is referred to as a linear program. HySAT uses LP as a black-box method to decide the feasibility of a set of linear constraints, i.e. to check whether for a given system of inequations A x ≥ b the set of solutions { x ∈ R | A x ≥ b} is non-empty, as well as a means for efficiently deriving explanations for infeasibility. The main reason for preferring LP over other methods of detecting feasibility of linear constraint systems (e.g., Fourier-Motzkin Elimination <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b29">30]</ref>) is that linear programming is known to be polynomial and scales extremely well in practice, even though the most frequently used codes are actually based on the non-polynomial Simplex method. Commercial codes like CPLEX tackle instances with more than 10 6 variables. In HySAT, however, we use the free LP library glpk <ref type="foot" target="#foot_3">3</ref> by Andrew Makhorin which provides a simplex solver, an interior point solver, and a solver supporting mixed integer linear programming (MILP), where some of the variables are required to be integer.</p><p>Checking feasibility of a system of linear inequations by linear programming is straightforward and requires only a hand-over of the unmodified or slightly modified (in case of strict inequations being entailed) linear constraint system to the LP, plus generation of a trivial (in case of only equations and non-strict inequations) or very simple objective function. To cope with systems containing strict inequations, which cannot be handled by LP directly, we use the standard trick of introducing a fresh slack variable ε and of replacing each strict inequation n j=1 A i, j x j &gt; b i by n j=1 A i, j x j -ε ≥ b i . Instrumenting the resultant linear constraint system with the objective function ε to be maximized yields an LP which is feasible with strictly positive optimum iff the original constraint system is feasible.</p><p>Extraction of explanations for infeasibility of a linear constraint system, on the other hand, can be performed by analyzing the solutions to adequately instrumented duals of the original constraint system. What we actually want to obtain is, in case that the original constraint system</p><formula xml:id="formula_19">C = k i=1 n j=1 A i, j x j ≥ b i ∧ n i=k+1 n j=1 A i, j x j &gt; b i</formula><p>is infeasible, a subset I ⊆ {1, . . . , n} such that the subsystem C| I of the constraint system containing only the conjuncts from I also is infeasible, yet the subsystem is irreducible in the sense that any proper subset J of I designates a feasible system C| J . Such an irreducible infeasible subsystem (IIS) is a prime implicant of all the possible reasons for failure of the constraint system C, and is thus a natural counterpart to the conflict clauses in the propositional setting as it prevents the proof search from visiting the same or related inconsistent constraint sets again. In case that the constraint system C contains only nonstrict inequations (i.e., k = n), it is a well-known fact of linear programming (closely related to Farkas' Lemma) that extraction of irreducible infeasible subsystems can be reduced to finding extremal solutions of a dual system of linear inequations <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b31">32]</ref>. We use the LP where</p><formula xml:id="formula_20">w i = -1 if b i ≤ 0, 0 ifb i &gt; 0</formula><p>where the objective function together with the choice of w guarantees boundedness such that an optimal solution exists whenever the LP is feasible. For such a solution, I = {i | y i = 0} is an IIS. I.e., in case of systems containing only non-strict (in)-equations, we extract an IIS by just a single call to the LP procedure. In case k &lt; n, we do first relax the strict inequations to non-strict ones, then search an IIS I of the relaxed system by solving the above dual system, <ref type="foot" target="#foot_4">4</ref>and finally apply a deletion filter <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> to C I (i.e., the reduction to I of the original constraint system entailing strict inequations) to further reduce I , if possible. <ref type="foot" target="#foot_5">5</ref> Such deletion filters entail multiple calls to the constraint solver in order to check for satisfiability of the constraint system with individual constraints being "switched off" (i.e., removed from I ), thus requiring a worst-case linear number of calls to the LP. By applying deletion filters only to the (in general, substantially) reduced subsystem C I instead of the original system C, HySAT does, however, gain considerable performance compared to traditional deletion-filter methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Coupling SAT and LP</head><p>The basic idea of the integration is to guard each non-propositional constraint occuring in the input formula with a new Boolean variable and to pass the corresponding constraint to the linear programming routine whenever the SAT solver assigns that variable to true.</p><p>In turn, constraints are removed from the LP-solver's database when their guard variables are unassigned again due to backtracking. <ref type="foot" target="#foot_6">6</ref> The integration thus is an instance of the lazy theorem proving paradigm <ref type="bibr" target="#b15">[16]</ref>.</p><p>After each deduction phase in which no Boolean conflict was encountered, the SAT solver checks if new constraints have been added to the linear program since its last evaluation. If so, the linear programming routine is called to decide the feasibility of the set of constraints residing in its database. If the linear program turns out to be inconsistent, a conflict is reported to the SAT solver. Otherwise the SAT solver can proceed with the next decision step.</p><p>In case of a conflict, however, HySAT invokes a conflict-analysis routine that extracts an irreducible infeasible subsystem from the constraint set, as described in the previous section. The IIS, providing a minimal (however in general not unique) reason for the conflict, is communicated back to the SAT solver, which uses the guard variables of the linear constraints involved to construct a conflict clause which prevents that particular combination of constraints to be investigated again. The resulting interaction between DPLL proof search and feasibility check via LP is illustrated in Fig. <ref type="figure">3</ref>.</p><p>Besides learning from arithmetic conflicts, HySAT is also able to perform forward arithmetic inference, thereby deriving new arithmetic facts from feasible sets of linear constraints. Given a set C = {C 1 , . . . , C n } of currently active arithmetic constraints, HySAT employs linear programming to determine for each continuous variable x occurring in C the minimum value x min and the maximum value x max consistent with n i=1 C i . If either of these values exists, HySAT adds the respective bound constraint, i.e. x ≥ x min or x ≤ x max , Fig. <ref type="figure">3</ref> Backtrack-search tree arising in a tight integration of DPLL proof search with linear programming. x and y are real-valued, while e, f, g and A, B, C, D are Boolean. A, B, C, D are, furthermore, guard variables for arithmetic facts guarded by a fresh Boolean variable p, to its database, together with a propositional clause which is responsible for triggering the activation of the new constraint. To this end, the propositional clause is of form p Ci 1 ∧ • • • ∧ p Ci m → p, where the variables p Ci j are the guard variables of a minimal set of constraints C i j ∈ C whose conjunction implies the new bound constraint. <ref type="foot" target="#foot_7">7</ref>When learning a new bound constraint, HySAT also adds Boolean clauses capturing all propositional dependencies between bound constraints concerning the same continuous variable, i.e. implicative dependencies between bounds as induced by the linear order on the reals. If the solver e.g. learns that in a certain branch of the search tree x ≥ 5 holds, it will therefore immediately exclude all combination of assignments to guard variables that would cause the activation of bound constraints x ≤ c with c &lt; 5, thereby considerably pruning the search tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Optimizations for BMC</head><p>Compared to related tools like ICS which aim at being general-purpose decision procedures suitable for arbitrary formulae, HySAT's decision procedure has been tuned to exploit the unique characteristics of BMC formulae.</p><p>As observed by Strichman <ref type="bibr" target="#b33">[34]</ref>, the highly symmetric structure of the k-fold unrolling as shown in Section 3 as well as the incremental nature of BMC can both be exploited for various optimizations in the underlying decision procedure. Currently, HySAT implements three optimizations which are described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Isomorphy inference</head><p>The learning scheme employed in propositional SAT solvers accounts for a substantial fraction of the solver's running time as it entails a non-trivial analysis of the implications that led to an inconsistent valuation. The creation of a conflict clause is in general even considerably more expensive in a combined solver like HySAT, as the analysis of a conflict involving non-propositional constraints requires the computationally expensive extraction of an IIS.</p><p>Isomorphy inference uses the (almost) symmetric structure of a BMC formula in order to add isomorphic copies of a conflict clause to the problem, thus multiplying the benefit taken from the time-consuming reasoning process which was required to derive the original conflict clause.</p><p>The concept is best illustrated using an example. Suppose that while solving a BMC instance the solver has encountered a conflict which yields the conflict clause C 0 = (x</p><formula xml:id="formula_21">j1 3 ∨ x j2 4 ∨ x j3 9</formula><p>), relating three variables from cycles j 1 , j 2 and j 3 . The solver then not only adds C 0 to φ k , but also all possible clauses</p><formula xml:id="formula_22">C i = (x j1±i 3 ∨ x j2±i 4 ∨ x j3±i 9</formula><p>), i = 1, 2, . . . , obtained from C 0 simply by index shifting.</p><p>Note, however, that BMC is not fully symmetric because of the initialization properties of runs (clause (5) of the translation scheme of Section 3) and perhaps the verification goal. This implies that only conflict clauses inferred from facts which are independent from such asymmetric formula parts may be soundly replicated. Such dependency can be traced cheaply by marking initialization/goal predicates and dominantly inheriting such marks upon all inferences, inhibiting isomorphy inference whenever a mark is encountered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Constraint sharing</head><p>When carrying out BMC incrementally for longer and longer unrollings, the consecutive formulae passed to the solver share a large number of clauses. Thus, when moving from the k-instance to the (k + 1)-instance, we can simply conjoin the conflict clauses derived when solving k-instance to the formula for step k + 1. However, this is only allowed for conflict clauses that were inferred from clauses which are common to both instances. We do currently decide this based on simple syntactic criteria, namely that the conflict clause was inferred purely from clauses stemming from the automaton. I.e. the inference may not involve the verification goal, which tends to become a weaker predicate on longer instances, as it usually entails reachability or recurrence. More elaborate schemes have, however, been investigated for propositional BMC in <ref type="bibr" target="#b25">[26]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Tailored decision strategy</head><p>When applying general-purpose decision strategies to BMC formulae one can observe the phenomenon described in <ref type="bibr" target="#b33">[34]</ref> that during the SAT search large sets of constraints belonging to distant cycles of the transition relation are being satisfied independently, until they finally turn out to be incompatible, often entailing the need for backtracking over long distances in the search tree.</p><p>In HySAT we adopt the solution proposed by Strichman <ref type="bibr" target="#b33">[34]</ref> to avoid this problem: The heuristics of the SAT solver selects the decision variables in the natural order induced by the variable dependency graph of the BMC formula, i.e. either using a forward scheme, starting with variables from x 0 , then from x 1 , etc., or vice versa, engaging in a backward scheme. This allows conflicts to be detected and resolved more locally, speeding up the search, as witnessed by the results shown in Fig. <ref type="figure">8</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Benchmark results</head><p>For an evaluation of HySAT we conducted a series of experiments on BMC problems of hybrid automata in which we (a) compared our tool with the ICS solver <ref type="bibr" target="#b13">[14]</ref>, and (b) investigated the impact of the individual optimizations by comparing the computation times of our tool when running with and without the respective optimization beeing enabled. The unwindings fed to ICS were obtained through SRI's infinite-state BMC frontend to ICS as distributed in the SAL tool-set <ref type="bibr" target="#b14">[15]</ref>. Our benchmarks are r The "leaking gas burner" and "water-level monitor" included in the SAL distribution, r An elastic approach to distance control of trains running on the same track, similar to the car platooning system used in the PATH project. Here, trains can accelerate or decelerate freely if they do not violate their mutual safety envelopes, yet an automatic speed control takes authority over a train if another train gets close, thereby controlling acceleration proportional (within physical limits) to the front and/or back proximity of the neighboring trains.</p><p>r A hybrid model of a car equipped with robotized five-speed transmission and a cruise control system which aims at maintaining a certain preset speed by actuating throttle and brake using two PI controllers. We adopted the model as reported in <ref type="bibr" target="#b34">[35]</ref> and modified it by adding a realistic clutch behaviour in the initial acceleration phase.</p><p>The results of our experiments are shown in Figs. <ref type="figure">4</ref><ref type="figure">5</ref><ref type="figure">6</ref><ref type="figure">7</ref><ref type="figure">8</ref>, with each data point representing a single BMC instance solved by two engines. Points lying on the diagonal, which is drawn as a solid line in all figures, indicate equal running times of both tools; points lying above (below) the diagonal represent instances that were solved faster by the engine whose running times can be read off from the x-axis (y-axis). Note the logarithmic scaling of the axes in Figs. <ref type="figure">4</ref> and<ref type="figure">5</ref>.</p><p>It can be seen that the individual optimizations yield consistent performance benefits, with the merits becoming more evident with increasing unrolling depth, corresponding to computationally more costly SAT instances.</p><p>This holds in particular for isomorphy inference, an exception being however the extremely deterministic gasburner model, see Fig. <ref type="figure">5a</ref>), where a strict state alternation is enforced by the discrete part such that learning of infeasible subsystems provides negligible extra information. With respect to the decision strategy it turns out that there is no single optimal strategy. Depending on the specific shape of the initial state set and the target region, forward or backward strategies, though in general both better than the standard strategy, may be more beneficial. We are experimenting with randomized approaches to on-the-fly strategy switch to overcome the problem of selecting an appropriate strategy a priori. With the current case studies, which are reachability properties in hybrid automata, measures of the first kind clearly have the predominant effect. Yet experiments with bounded model construction for the metric-time temporal logic Duration Calculus provide evidence that the conciseness gain from using linear zero-one constraint systems instead of CNF formulae will be essential to tractability once observers for metric-time temporal-logic formulae come into play <ref type="bibr" target="#b16">[17]</ref>.</p><p>HySAT's techniques for exploiting the particular structure of the verification conditions arising in bounded model checking (BMC) include inheritance of inference results along the temporal axis within an BMC instance, sharing of inference results across BMC instances, and decision heuristics in the SAT-solver that pay attention to the causal relationship between problem variables by doing chaining along the transition sequence. These algorithms have been inspired by similar optimizations developed by Strichman for finite-state BMC <ref type="bibr" target="#b33">[34]</ref>; however such optimizations exhibit an even better payoff on the two-sorted logics used here, as the price for copying inferences increases only marginally while the computational cost of the individual inference grows dramatically in the hybrid-state case. Consequently, the individual optimization yield speedups of up to, and sometimes even considerably exceeding, an order of magnitude.</p><p>An interesting aspect of isomorphically copying inference results, as in inheritance along the temporal axis or in sharing across BMC instances, is that even extremely costly inferences may amortize, provided that their results can be reused sufficiently often. Future versions of HySAT will thus incorporate more advanced-and computationally more costly-inference techniques combined with heuristics deciding when to use them. The rationale is here that a costly inference is more beneficial when there is sufficient chance for reuse of its result, i.e. when it is performed in early phases of the proof search, thus providing aggressive proof-tree pruning.</p><p>Another direction for future development is the extension of HySAT to nonlinear arithmetic constraints, including transcendental functions, thereby extending the lazy theorem proving approach to undecidable domains which arise naturally in the verification of hybrid discrete-continuous systems. While undecidable theories are in general out-of-scope of the lazy theorem proving approach, as their processing requires extremely frequent calls to interactive theorem provers as subordinate procedures of the satisfiability solver, we exploit structural and topological properties of typical engineering problems to extend this approach far into undecidable arithmetic domains without entering into interactive verification schemes. Specifically addressing robust verification conditions, i.e. proof obligations that do not change their truth value under minor variation of the constants involved, we will integrate robust constraint solving procedures (e.g. those of <ref type="bibr" target="#b32">[33]</ref>) with the lazy theorem proving paradigm. Given the ability of robust constraint solving to decide truth of robust formulae in real arithmetic including transcendental and other smooth functions, we thus obtain a fully symbolic procedures for the analysis of hybrid systems with large discrete state spaces and rich continuous dynamics .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Consequently, ZOLCS can be exponentially more concise than CNF: a CNF expressing that at least n out of k variables should be true requires k k-n+1 disjunctive clauses of length kn + 1 each, i.e. is of size O k k-n+1 • n , whereas the corresponding ZOLCS has size linear in k and logarithmic in n. Formally, the syntax of linear zero-one constraints is linear ZO constraint ::= linear term ≥ threshold linear term ::= {weight literal +} * weight literal weight ::∈ N literal ::= boolean var | boolean var boolean var ::∈ BV threshold ::∈ N</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 A</head><label>1</label><figDesc>Fig.1A linear hybrid automaton and a sample trajectory. l x and u x denote the lower and upper bounds on the slope of x in the corresponding states, while x ≤ 10 and x ≥ 4 are state invariants constraining x itself</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Changes of the set of watched literals when successively setting g, c, and b to false. Watched literals are marked with grey boxes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>maximize w T y subject to A T y = 0 b T y = 1 y ≥ 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 Fig. 5 Fig. 6</head><label>456</label><figDesc>Fig. 4 Performancs of HySAT relative to ICS: BMC times for (a) gasburner model, (b) water-level monitor</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 Fig. 8</head><label>78</label><figDesc>Fig. 7 Impact of constraint sharing on BMC runtimes for (a) train distance control model, (b) car model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="13,53.06,57.10,333.12,330.96" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>A discrete location σ not to be taken initially takes the predicate init σ = false.Springer</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>If l σ,x = -∞ or u σ,x = ∞, the corresponding part of the constraint is left out. Springer</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Springer</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>http://www.gnu.org/software/glpk/glpk.html.Springer</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>Note that the relaxed system may turn out to be satisfiable. In this case, the following phase pursuing a deletion filter can be started on the full constraint system C instead of C| I .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>Actually, application of the deletion filter is optional in HySAT, as the subsystems obtained from the first, LP-based phase are often tight enough (i.e., only marginally larger than the prime implicants) such that the overhead incurred from deletion-filtering is not amortized by the reduction in search space of the SAT procedure.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Instead of actually adding (retracting) a linear constraint to (from) the LP, our implementation uses the standard LP mechanism of just activating it on demand by enabling the respective row bounds in the LP, thus allowing the simplex algorithm to restart solving from the dual solution whose feasibility is not affected by changing bounds in the primal LP.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_7"><p>It's noteworthy that the extraction of the minimal set {C i j | 1 ≤ j ≤ m} ⊆ C does not entail any computational overhead, but is delivered by the LP solver as a byproduct of determining the bound on the respective continuous variable.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements This work was partly supported by the German Research Council (DFG) as part of the Transregional Collaborative Research Center "Automatic Verification and Analysis of Complex Systems" (SFB/TR 14 AVACS). See www.avacs.org for more information. The authors are grateful for the tight cooperation within the project area "Hybrid Systems" of the Transregional Research Action "AVACS" funded by the Deutsche Forschungsgemeinschaft. Special thanks go to Bernd Becker, Erika Ábrahám, Felix Klaedtke, and Jan-Georg Smaus for their kind hospitality and for many fruitful discussions during research visits to Freiburg, as well as to Fritz Eisenbrand and Markus Behle for their help in finding an efficient solution to the IIS extraction problem.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Generic ILP versus specialized 0-1 ILP: An update</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A</forename><surname>Aloul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">L</forename><surname>Markov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM/IEEE international conference computer-aided design (ICCAD)</title>
		<meeting>the ACM/IEEE international conference computer-aided design (ICCAD)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="450" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A SAT-based approach for solving formulas over boolean and linear mathematical propositions</title>
		<author>
			<persName><forename type="first">G</forename><surname>Audemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bertoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kornilowics</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th international conference on automated deduction</title>
		<title level="s">Lecture notes in artificial intelligence</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting>the 18th international conference on automated deduction</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="193" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Verifying industrial hybrid systems with MathSAT</title>
		<author>
			<persName><forename type="first">G</forename><surname>Audemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bozzano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ENTCS</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Complete search restart strategies for satisfiability</title>
		<author>
			<persName><forename type="first">L</forename><surname>Baptista</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lynce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marques-Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IJCAI&apos;01 workshop on stochastic search algorithms</title>
		<meeting>the IJCAI&apos;01 workshop on stochastic search algorithms</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>IJCAI-SSA</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Checking satisfiability of first-order formulas by incremental translation to SAT</title>
		<author>
			<persName><forename type="first">C</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stump</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th international conference on computer-aided verification</title>
		<meeting>the 14th international conference on computer-aided verification</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">A Davis-Putnam based enumeration algorithm for linear pseudo-boolean optimization</title>
		<author>
			<persName><forename type="first">P</forename><surname>Barth</surname></persName>
		</author>
		<idno>MPI-I-95-2-003</idno>
		<imprint>
			<date type="published" when="1995">1995</date>
			<pubPlace>Saarbrücken, Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Max-Planck-Institut für Informatik</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Verification of hybrid systems via mathematical programming</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bemporad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Morari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid systems: computation and control (HSCC&apos;99)</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Vaandrager</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Van Schuppen</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="31" to="45" />
		</imprint>
	</monogr>
	<note>Lecture notes in computer science</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Symbolic model checking without BDDs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Lecture notes in computer science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>TACAS&apos;99</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Implementation of Fourier-Motzkin elimination</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wijshoff</surname></persName>
		</author>
		<idno>TR94-42</idno>
		<imprint>
			<date type="published" when="1994">1994</date>
			<pubPlace>The Netherlands</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Dpt. of Computer Sceince, University of Leiden</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A fast pseudo-boolean constraint solver</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kuehlmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th design automation conference (DAC 2003)</title>
		<meeting>the 40th design automation conference (DAC 2003)<address><addrLine>Anaheim, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="830" to="835" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Finding a useful subset of constraints for analysis in an infeasible linear program</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Chinneck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">INFORMS J Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="164" to="174" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Locating minimal infeasible constraint sets in linear programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Chinneck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dravnieks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ORSA J Comput</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="157" to="168" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A machine program for theorem proving</title>
		<author>
			<persName><forename type="first">M</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Logemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Loveland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun ACM</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="394" to="397" />
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The ICS decision procedures for embedded deduction</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ruess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rushby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd international joint conference on automated reasoning (IJCAR)</title>
		<meeting>the 2nd international joint conference on automated reasoning (IJCAR)<address><addrLine>Cork, Ireland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3097</biblScope>
			<biblScope unit="page" from="218" to="222" />
		</imprint>
	</monogr>
	<note>Lecture notes in computer science</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Lecture notes in computer science</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Rueß</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rushby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sorea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-aided verification, CAV 2004</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</editor>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3114</biblScope>
			<biblScope unit="page" from="496" to="500" />
		</imprint>
	</monogr>
	<note>SAL 2</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Lazy theorem proving for bounded model checking over infinite domains</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Rueß</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sorea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th international conference on automated deduction</title>
		<meeting>the 18th international conference on automated deduction</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="438" to="455" />
		</imprint>
	</monogr>
	<note>Lecture notes in computer science</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Bounded model construction for duration calculus</title>
		<author>
			<persName><forename type="first">J</forename><surname>Enslev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A-S</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fränzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th nordic workshop on programming theory (NWPT 05)</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Jones</surname></persName>
		</editor>
		<meeting>the 17th nordic workshop on programming theory (NWPT 05)</meeting>
		<imprint>
			<publisher>Københavns Universitet</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Solution d&apos;une qestion particulière du calcul des inégalités</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fourier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nouveau Bulletin par la Société Philomathique des Paris</title>
		<imprint>
			<biblScope unit="page" from="99" to="100" />
			<date type="published" when="1826">1826</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient SAT engines for concise logics: Accelerating proof search for zeroone linear constraint systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fränzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Herde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic for programming, artificial intelligence, and reasoning (LPAR 2003)</title>
		<title level="s">Lecture notes in artificial intelligence</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient SAT engines for concise logics: Accelerating proof search for zeroone linear constraint systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fränzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Herde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic for programming, artificial intelligence and reasoning (LPAR 2003), vol 2850. LNCS, subseries LNAI</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Moshe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Vardi</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="302" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Identifying minimally infeasible subsystems of inequalities</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gleeson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ORSA J Comput</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="61" to="63" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The safety guaranteeing system at station hoornkersenboogerd</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jwc</forename><surname>Koorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sfm</forename><surname>Van Vlijmen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Compass &apos;95: 10th annual conference on computer assurance</title>
		<meeting><address><addrLine>Gaithersburg, Maryland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="57" to="68" />
		</imprint>
		<respStmt>
			<orgName>National Institute of Standards and Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Predicative programming</title>
		<author>
			<persName><forename type="first">Ecr</forename><surname>Hehner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="134" to="151" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">HyTech: The next generation</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P-H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th annual IEEE real-time systems symposium (RTSS 1995)</title>
		<meeting>the 16th annual IEEE real-time systems symposium (RTSS 1995)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="56" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">What&apos;s decidable about hybrid automata</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Kopke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Puri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Varaiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th Annual ACM symposium on the theory of computing</title>
		<meeting>the 27th Annual ACM symposium on the theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="373" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An incremental algorithm to check satisfiability for bounded model checking</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary proceeding of BMC&apos;04</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">O</forename><surname>Strichman</surname></persName>
		</editor>
		<imprint>
			<publisher>ETH Zürich</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The impact of branching heuristics in propositional satisfiability algorithms</title>
		<author>
			<persName><forename type="first">Marques-Silva Jp</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th portuguese conference on artificial intelligence (EPIA)</title>
		<meeting>the 9th portuguese conference on artificial intelligence (EPIA)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">GRASP: A search algorithm for propositional satisfiability</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Marques-Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Comput</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="506" to="521" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Chaff: engineering an efficient SAT solver</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Madigan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th design automation conference</title>
		<meeting>the 38th design automation conference</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>DAC&apos;01</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Beiträge zur Theorie der linearen Ungleichungen</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Motzkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1936">1936</date>
		</imprint>
		<respStmt>
			<orgName>Universität Zürich</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Doctoral dissertation</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Computing small clause normal forms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nonnengart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Weidenbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of automated reasoning</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Robinson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier Science B</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">The maximum feasible subsystem problem and vertex-facet incidences of polyhedra</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Pfetsch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
		<respStmt>
			<orgName>TU Berlin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Doctoral dissertation</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Continuous first-order constraint satisfaction with equality and d isequality constraints</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ratschan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th international conference on principles and practice of constraint programming</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Van Hentenryck</surname></persName>
		</editor>
		<meeting>the 8th international conference on principles and practice of constraint programming</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="680" to="685" />
		</imprint>
	</monogr>
	<note>Lecture notes in computer science</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Tuning SAT checkers for bounded model checking</title>
		<author>
			<persName><forename type="first">O</forename><surname>Strichman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer aided verification (CAV 2000), vol 1855. Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="480" to="494" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Modeling and reach-set computation for analysis and optimal control of discrete hybrid automata</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">D</forename><surname>Torrisi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>ETH Zürich</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Doctoral dissertation</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On the complexity of derivations in propositional calculus</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tseitin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Slisenko A (ed) Studies in constructive mathematics and mathematical logics</title>
		<imprint>
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A linear-time transformation of linear inequalities into conjunctive normal form</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Warners</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf Process Lett</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="63" to="69" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">SATIRE: A new incremental satisfiability engine</title>
		<author>
			<persName><forename type="first">J</forename><surname>Whittemore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the design automation conference</title>
		<meeting>the design automation conference<address><addrLine>Las Vegas, Nevada, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="542" to="545" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The LPSAT engine &amp; its application to resource planning</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Wolfman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Weld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 16th international joint conference on i artificial intelligence</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Dean</surname></persName>
		</editor>
		<meeting>eeding of the 16th international joint conference on i artificial intelligence</meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="310" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Efficient conflict driven learning in a Boolean satisfiability solver</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Madigan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the international conference on computer-aided design</title>
		<meeting>eeding of the international conference on computer-aided design</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="279" to="285" />
		</imprint>
	</monogr>
	<note>ICCAD•01</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
