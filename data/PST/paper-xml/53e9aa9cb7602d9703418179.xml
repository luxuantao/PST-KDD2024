<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">THE ULTIMATE PLANAR CONVEX HULL ALGORITHM?*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">G</forename><surname>Kirkpatrickf</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Raimund</forename><surname>Seidel</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of British Columbia</orgName>
								<address>
									<postCode>V6T W5</postCode>
									<settlement>Vancouver</settlement>
									<region>B.C</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Cornell University</orgName>
								<address>
									<postCode>14853. 287</postCode>
									<settlement>Ithaca</settlement>
									<region>New York</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">THE ULTIMATE PLANAR CONVEX HULL ALGORITHM?*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">50AC5CEB6073D9066133B01F89F16BC5</idno>
					<note type="submission">Received by the editors November 15, 1983, and in revised form August 15, 1984, This research was</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a new planar convex hull algorithm with worst case time complexity O(n log H) where n is the size of the input set and H is the size of the output set, i.e. the number of vertices found to be on the hull. We also show that this algorithm is asymptotically worst case optimal on a rather realistic model of computation even if the complexity of the problem is measured in terms of input as well as output size. The algorithm relies on a variation of the divide-and-conquer paradigm which we call the "marriage- before-conquest" principle and which appears to be interesting in its own right.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"> 1. <p>Introduction. The convex hull of a finite point set S in the plane is the smallest convex polygon containing the set. The vertices (corners) of this polygon must be points of S. Thus in order to compute the convex hull of a set S it is necessary to find those points of S which are vertices of the hull. For the purposes of constructing upper bounds we define the convex hull problem, as the problem of constructing the ordered sequence of points of S which constitute the sequences of vertices around the hull.</p><p>The convex hull problem was one of the first problems in the field of computational geometry to have been studied from the point of view of computational complexity.</p><p>In fact, efficient algorithmic solutions were proposed even before the term "computa- tional geometry" was coined. This, along with its very extensive analysis in recent years, reflects both the theoretical and practical importance of the problem.</p><p>Of the convex hull algorithms proposed so far several have O(n log n) worst case time bounds <ref type="bibr" target="#b4">[4]</ref>, <ref type="bibr" target="#b8">[8]</ref>, <ref type="bibr" target="#b14">[14]</ref>, <ref type="bibr" target="#b15">[15]</ref>, [17], where n is the size of the input point set. Shamos <ref type="bibr" target="#b17">[17]</ref> even argued that the O(n log n) time bound is worst case optimal. He observed that a set S of n real numbers could be sorted by finding the convex hull of the planar set S' {(x, X2)IX E S}. But sorting, of course, has an l(n log n) lower bound on a wide range of computational models. Yao  <ref type="bibr" target="#b19">[19]</ref> and on weaker computational models Avis [21, van Emde Boas <ref type="bibr" target="#b7">[7]</ref>, and Preparata and Hong [15] proved the lq(n log n) bound for a less demanding version of the convex hull problem: just the vertices of the convex hull are to be identified, irrespective of their sequence.</p><p>In contrast to the results above, it is interesting to observe that algorithms exist which solve the planar convex hull problem in O(nH) time, where H is the number of vertices found to be on the hull [61, <ref type="bibr" target="#b9">[9]</ref>. For small H, these algorithms seem to be superior to the O(n log n) methods. (This, of course, does not contradict the previously cited lower bound results, as H could be as large as n). It is notable, however, that all of the lower bound arguments mentioned above are insensitive to H in that they assume that some fixed fraction of the data points are vertices of the convex hull.</p><p>In this paper we present a convex hull algorithm with worst case time complexity O(n log H). Thus its running time is not 0nly sensitive to both n and H, but it is also worst case optimal in the traditional sense when the running time is measured as a function of n only. However, we also show that our algorithm is asymptotically worst case optimal even if the complexity of the proble m is measured as a function of both n and H.</p><p>Our algorithm is based on a variation of the divide-and-conquer paradigm that appears to be interesting in its own right. Traditional divide-and-conquer algorithms adhere to the following strategy: First break the problem into subproblems (divide), then recursively solve the subproblems (conquer), and finally combine the subsolutions to form the global solution (marry). Our algorithm reverses the last two steps. After dividing the problem it first determines how the solutions of the subproblems will combine (without actually computing them!) and then proceeds to solve the subprob- lems recursively. We thus call this approach the "marriage-before-conquest" principle. Its advantage lies in the fact that it allows to remove parts of the subproblems that upon merging (or marrying) turn out to be redundant. Thus it reduces the sizes of the subproblems that are to be solved recursively. We have recently been able to apply the marriage-before-conquest principle also successfully to the maximal vector problem <ref type="bibr" target="#b10">[10]</ref>. It remains to be seen whether this principle has other applications.</p><p>Sections 2 and 3 of this paper describe our new algorithm. In 4 we show how our algorithm can be randomized, and 5 deals with the lower bound aspects of the convex hull problem. Throughout the paper, unless stated otherwise, we deal with sets of points in the plane. For a point p, x(p) and y(p) denote its standard cartesian coordinates. We will feel free to use loose but descriptive geometric terminology such as "vertical line", "a point lies above a line", etc.</p><p>2. The main algorithm. In this section we show how the "marriage-before- conquest" principle can be used for an improved convex hull algorithm. We construct the convex hull in two pieces, the upper hull and the lower hull (see Fig. <ref type="figure">2</ref>.1). It should be clear that if the two chains forming the upper and lower hull are given, they can be concatenated in constant time (at most two vertical edges may need to be inserted) to yield the sequence of vertices around the hull. Also observe that an algorithm for constructing the upper hull could easily be modified to constructthe lower hull also. Therefore we concentrate at first on constructing an algorithm for finding the sequence of vertices on the upper hull. Exploiting the "marriage-before-conquest" principle, our convex hull algorithm should do something like the following: First find a vertical line that divides the given point set in two approximately equal sized parts. Next determine the "bridge" crossing this line, i.e. the edge of the upper hull that intersects this line. Eliminate the points that lie underneath the bridge, and finally apply the algorithm recursively to the two sets of the remaining points on the left and right side of the vertical line.</p><p>The only difficult part in such an algorithm appears to be the construction of the bridge. We show a linear time solution to this problem in 3.</p><p>The following PIDGIN-ALGOL routine presents our convex hull algorithm in some detail. It takes as input a set S {Pl, , Pn} of n points in the plane and prints the sequence of indices of the vertices on the upper hull of S. It uses the function BRIDGE specified in 3, which given a set S c R E and a real a returns the indices to  Procedure UPPER-HULL(S)</p><p>1. Initialization</p><p>Let rain and max be the indices of two points in S that form the left and right endpoint of the upper hull of S respectively, i.e.</p><p>x(p,,,) -&lt;_ x(p,) -&lt;_ x(p,,ax) and y(p,,,) _-&gt; y(p,) if x(p,,,,) x(p,), Y(P,,,ax)&gt;--Y(P,) if x(p,.x) =x(p,) for i= 1,..., n.</p><p>If min max then print min and stop.</p><p>Let T := {p,,,,, P,,,x} U {p SIx(pmin &lt; x(p) &lt; X(Pmax)}.</p><p>2. CONNECT(min, max, T) where CONNECT (k, m, S) is begin 2.1</p><p>Find a real number a such that</p><p>x(p,)&lt;-_a for [Isi/2] points in S and</p><p>x(p,)-&gt; a for /IsI/2J points in S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.2</head><p>Find the "bridge" over the vertical line L {(x, y)lx a}, i.e.</p><p>(i,j) := BRIDGE (S, a).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">2 Let Slyt</head><formula xml:id="formula_0">:= {p,} U {p Six(p) &lt; x(p,)}. Let S,ght := {p} [-J {P Six(p) &gt; x(p)}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.4</head><p>If i= k then print (i) else CONNECT (k, i, Sleft).</p><p>Ifj rn then print (j)</p><p>else CONNECT (j, m, Sre,ht).</p><p>end.</p><p>THEOREM 2.1. Algorithm UPPER-HULL correctly determines the sequence of vertices on the upper hull of S in O(n) space and O(n log H) time, where H is the number of edges on the upper hull of S.</p><p>Proof. If the upper hull of S consists of only one vertex (i.e. all of S lies on one vertical line) then the algorithm is trivially correct and reports that vertex in linear time in step 1.</p><p>Otherwise the correctness of the algorithm follows from an inductive argument.</p><p>A call CONNECT (k, m, $) discovers a previously unknown edge (p, p) on the upper hull. If p turns out to be the leftmost vertex of the upper hull its index will be printed, otherwise the recursive call CONNECT (k, i, Seyt) will cause the sequence of vertices of the upper hull from Pk up to p to be printed. Similarly, if p is the rightmost vertex of the upper hull its index will be printed, otherwise the call CONNECT (j, m, Srht)</p><p>will cause the portion of the upper hull from p up to p,, to be printed.</p><p>For the complexity bounds first observe that step 1 of the algorithm can easily be implemented to run in linear time. Thus it remains to show that the procedure In the case that two edges of the upper hull, (p, p) and (p, pk), intersect L, i.e. vertex p lies on L, BRIDGE will return (j, k).</p><p>Stft contains p and the points of S to the left of the vertical line through p. M. McQueen from McGill University has pointed out that Slft could be restricted to contain pk, p and all the points of S above the straight line through Pk and p. Sash, can be restricted analogously.</p><p>CONNECT takes no more than O(n log Hu) time. Note that using the median finding algorithm of Blum et al. 1, p. 99] and using our bridge finding algorithm of 3, steps 2.1 to 2.3 can be implemented to run in linear time. Thus the running time of CONNECT is determined by f([S[, H) where the function f must satisfy the recurrence relation</p><formula xml:id="formula_1">f(n,h)&lt;{ cn= { ()(+ n )} ifh=2, cn + max f n ht f hr if h &gt; 2, hl+hr= h</formula><p>where c is some positive constant and n &gt;-h &gt; 1.  We claim that f(n, h) O(n log h). To prove this we show that f(n, h) cn log h satisfies the above recurrence relation. This is trivially true for the base case h 2. For h &gt; 2 note that f(n,h) &lt;cn+ max c logh+c loghr cn +cn max (log (hih)}.</p><p>hl+hr=h Using elementary calculus it is easy to verify that the maximum is realized when hi h hi2. Thus f n, h) &lt;= cn +cn log cn + cn log cn + cn log h cn cn log h.</p><p>The linear space bound is trivial. Q.E.D.</p><p>COROLLARY. The convex hull of a set of n points in the plane can be found in time O(n log H) using O(n) space, where H is the number of vertices found to be on the hull 3. Finding the Iridge. We are given a set S of n points in the plane and a vertical line L which has points of S to its left and right. We are to find the edge of the upper hull of S that intersects L. If two edges intersect L, i.e. L contains a vertex v of the upper hull, we want to identify the edge for which v is the left endpoint. Call this edge the bridge and its endpoints bridge points (see Fig. <ref type="figure">3</ref>.1). Let us define a supporting FIG. 3.1   line of $ to be a nonvertical straight line which contains at least one point of S but has no points of S above it. Obviously the bridge must be contained in some supporting line. Call this line b and let Sb be the slope of b.</p><p>For our purposes, finding the bridge means identifying the two bridge points. One possible way of achieving this is to successively eliminate points from S as candidates for bridge points. For this purpose we pair up the points of S into In/21 couples. The Downloaded 05/15/13 to 128.230.234.162. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php following two lemmas show how forming pairs of points facilitates the elimination of candidates for bridge points. LEMMA 3.1. Let p, q be a pair of points of S. If x(p)=x(q) and y(p) &gt; y(q) then q cannot be a bridge point.</p><p>Proof. Trivial. LEMMA 3.2. Let p, q be a pair of points of S with x(p)&lt;x(q), and let Spq be the slope of the straight line h through p and q.</p><p>(1) If Spq &gt; Sb then p cannot be a bridge point.</p><p>(2) If Spq &lt; Sb then q cannot be a bridge point. Proof (for case (1); the proof for case (2) is symmetrical). Assume p was a bridge point. By virtue of Spq &gt; Sb and x(p)&lt; x(q), q would lie above the bridge line b which would contradict the fact that b is a supporting line of $ (see Fig. <ref type="figure">3</ref>.2). Q.E.D.</p><formula xml:id="formula_2">FIG. 3.2</formula><p>These two lemmas can be used to eliminate a bridgepoint candidate from every one of the [n/2J pairs. However, it is not clear at first how a condition like Spq&gt; Sb can be tested without explicitly knowing Sb, the slope of b, and hence knowing the bridge, which after all is the entity that we want to compute. The solution to this problem is suggested by the following lemma.</p><p>LEMMA 3.3. Let h be the supporting line of S with slope Sh.</p><p>(1) Sh &lt; Sb iff h contains only points of S that are strictly to the right of L.</p><p>(2) Sh Sb iff h contains a point of S that is strictly to the right of L and a point of S that is to the left of or on L.</p><p>(3) Sh &gt; Sb iff h contains only points of S that are to the left of or on L. Proof. Trivial.</p><p>Thus to test whether Spq &gt; Sb it suffices to find the supporting line h of S with slope Spq and to determine whether h contains points of S to the right or to the left of L. Of course, finding this supporting line h requires linear time which is clearly too expensive to be done for every one of the In/2] pairs individually. However, this problem can be overcome by judiciously choosing a slope Sh with the property that if Sh &gt; Sb then Spq &gt; Sh (and hence Spq &gt; Sb) for a large number of pairs p, q and, if Sh &lt; Sb then Spq &lt; Sh (and hence Spq &lt; Sb) for a large number of pairs p, q. A natural choice for an Sh with this property is the median of the slopes of the lines defined by the [n/2J pairs of points. Now we are ready to give a more detailed PIDGIN-ALGOL description of our bridge finding algorithm. The function BRIDGE(S, a) takes as parameters a set S--{Pl,"" ", Pn} of n &gt; 1 points and a real number a representing the vertical line L= {(x, y)lx a}. It is assumed that the point P,,in in $ with minimum x-coordinate is unique and that x(pmi,) &lt;-a. Similarly, the point P,,ax in S with maximum x-coordinate is assumed to be unique and with x(pmax)&gt; a. BRIDGE (S, a) returns as its value a pair (i,j), where p and pj are the left and right bridge point respectively. </p><formula xml:id="formula_3">f(n)=lf(-) +O(n), n&gt;2.</formula><p>But it is well known that such a recursive function is O(n) [1, p. 64]. Q.E.D.</p><p>At this point we want to mention that our bridge finding algorithm was inspired by the linear time two variable linear programming algorithms of M. Dyer <ref type="bibr" target="#b5">[5]</ref> and N. Megiddo <ref type="bibr" target="#b13">[13]</ref>. A closer look even shows that the bridge problem can be formulated as a linear programming problem. However, for the sake of simplicity and completeness it seems worthwhile to spell out the bridge finding algorithm explicitly. 4. The expected time case. The divide-and-conquer algorithms in the two preceding sections are not terribly complicated. At first sight it even seems possible to actually implement these algorithms in some high level programming language in an hour's time, or so. However, one quickly discovers that the major obstacle to doing so is the median find algorithm. Thus quite naturally the question arises whether it is possible to do without it.</p><p>The median find algorithm is used in our algorithms to find a vertical line that divides a given point set evenly. What happens if we follow the example of Quicksort and choose a separating line at random? Ample experimental results have shown that Quicksort is one of the fastest sorting algorithms and these results have been supported by a careful theoretical analysis of the.algorithm 11 ], 16]. As it turns out the method of choosing a separator at random can also be successfully applied to our algorithms, thus changing the worst case time complexity to O(n2) but retaining the O(n log H) expected case time complexity. THEOREM 4.1. If step 2.1 in Algorithm 2.1 is replaced by 2.1. Let a x(pi), where pi is randomly chosen from S-{pm} such that the choice of every point in S--{pm} is equally likely.</p><p>then the modified algorithm has O(n log Hu) expected case time complexity.</p><p>Proof The expected case running time of the modified algorithm can be bounded by the function g that must satisfy the following relation:</p><formula xml:id="formula_4">g(n'h)&lt;{bn if n -&gt;_ h 2, max {g(i,h)+g(n-i, hr)} ifn&gt;=h&gt;2, hl+hr h</formula><p>where b is some positive constant.</p><p>We claim that g(n, h)= O(n log h), i.e. there is positive real constant c, such that for all n &gt;-h &gt;_-2, g(n, h) &lt;-cn log h. 3 We prove our claim by induction.</p><p>The claim is trivially true for all n if h 2 and for all n-&lt; 5 otherwise. Now we want to show the claim for some n &gt; 5 and h &lt; n on the assumption that g(n', h')&lt;-_ cn' log h' for all n' &lt; n and h' &lt; h. By definition of g and our inductive assumption we thus have 1 g(n,h)&lt;-bn+ max {ciloght+c(n-i) loghr}.</p><formula xml:id="formula_5">n 1 1='1&lt; hl+hr=h</formula><p>In this proof we use w.l.o.g, the natural logarithm.</p><p>Using elementary calculus it is easy to show that for every the maximum is realized when h= ih/n and hr=(n-i)h/n. (n 1) l&lt;_i&lt;n As E1_-&lt;,&lt;,, log &lt;= 1/2n 2 log n -1/4n 2 (see 1, p. 94]) and E 1=&lt;,&lt;,, 1/2n(n 1) we have g( n, h) &lt;= bn + cn log h cn log n + c n c n 2 n log n--</p><formula xml:id="formula_6">n-1 2n-1 c log n &lt;= bn n + cn+ cn log h. 2 n-1</formula><p>As log n/(n-1)&lt; 1 / 2 for all integers n &gt; 5, there exists a real constant c &gt; 0 such that bn-1/2cn+cn(log n/(n-1))&lt;O for all n&gt; 5 and hence g( n, h) &lt;-cn log h. Q.E.D.</p><p>The median find algorithm is used on one more occasion in our algorithms: in the bridge finding procedure. Again we can dispense with the median find algorithm and use random choice instead. The worst case complexity of such a modified bridge finding procedure is O(n2); however the expected case running time is still O(n).</p><p>THEOREM 4.2. If step 4 of Algorithm 3.1 is replaced by 4. Randomly choose an element (pi, Pj) from PAIRS such that the choice of every element is equally likely, and let K := k(pi, pj), then the modified algorithm has expected case time complexity O( n).</p><p>Proof. In the worst case no points are eliminated in step 3 of the modified function BRIDGE, and all the slopes k(p, p;) generated in that step are distinct. By the random choice of K, the cardinalities of SMALL and LARGE are uniformly distributed between 0 and N-1, where N= tlsI/2J, the cardinality of PAIRS.</p><p>Assume pessimistically that whenever ISMALL[ &lt;-N/2, the supporting line h contains only points to the right of L, and by step 9 only ISMALLI+ 1 points are eliminated. Symmetrically, assume that if ILARGEI &lt; N/2, h contains only points to the left or on L, and step 8 is applied.</p><p>With these pessimistic assumptions the expected case running time of the modified algorithm is bounded from above by the function f, where for some positive constant b bn 4</p><formula xml:id="formula_7">f(n) bn +-E FI l&lt;_i&lt;_n/4 if n -&lt;_ 2, f(n-i) ifn &gt;2.</formula><p>It is an easy exercise in induction to show that f(n)= O(n). Q.E.D. upper bound for the convex hull problem is the best possible on a quite general model of computation. Specifically, we prove an (n log H) lower bound for this problem on dth order algebraic decision trees, for any fixed d. There exist at least four variants of the convex hull problem characterized by increasingly stringent conditions on the form of the output. Let S {Pl," ", Pn} be a set of points in RE, and let ext(S) denote the set of vertices of the convex hull of S.</p><p>The convex hull sequence problem asks for the elements of ext(S) in consecutive cyclic order. The convex hull set problem asks for the elements of ext(S) in arbitrary order.</p><p>The convex hull multiset problem asks for a listing, in arbitrary order, of elements of S that coincide with elements of ext(S). (This differs from the set problem only if S is a multiset). Finally, the convex hull size problem asks for the cardinality of ext(S) (i.e. H).</p><p>It should be clear that the algorithm outlined in 3 can be adapted to solve all of these problem variants in worst case time O(n log H). Furthermore, since the sequence variant is at least as hard as the set variant, which in turn is at least as hard as the size variant, it will suffice to demonstrate a lower bound on the convex hull size problem, preferably using input point sets with no multiplicities. In fact we establish a lower bound on the even weaker convex hull size verification problem: given S and H, confirm that [ext(S)]-H. We show that any dth order algebraic decision tree algorithm for this verification problem must take l)(n log H) steps in t.he worst case, even if it can be assumed that all input points are distinct.</p><p>We follow Steele and Yao <ref type="bibr" target="#b18">[18]</ref> and Ben-Or <ref type="bibr" target="#b2">[3]</ref> in adopting algebraic decision trees as our model of computation. A dth order algebraic decision-tree algorithm (hereafter a tree algorithm) T for testing membership in a set W c R is a rooted tree whose internal nodes are labelled by multivariate polynomials of degree at most d and whose leaves are labelled either YES or NO. Each internal node has out-degree three; the edges are labelled &lt;, =, and &gt; reflecting possible outcomes on comparison with 0. Every input R" determines a unique root to leaf path in T in the obvious way.</p><p>We say that T decides membership in W if, for every R", : leads to a YES leaf of T if and only if W. Yao <ref type="bibr" target="#b19">[19]</ref> establishes an (n log n) worst case lower bound for the convex hull set problem on algebraic decision trees of order two. This result is generalized by Ben-Or [3], who demonstrates the same fl(n log n) lower bound for the convex hull size problem on algebraic decision trees of any fixed order d. Ben-Or's result is just one of a number of applications of the following general theorem concerning tree algorithms.</p><p>THEOREM 5.1 [3, Thm. 8]. Let W c R" be any set and let T be any dth order algebraic decision tree that solves the membership problem for W. If W has N disjoint connected components, then T must have height (and hence worst case complexity) l)(log N n).</p><p>We use the following generalization of the element distinctness problem <ref type="bibr" target="#b2">[3]</ref> to establish our lower bound. The multiset size verification problem asks to confirm, given a multiset Z {zl,. ., z,} c R and an integer k, that Z has k distinct elements.</p><p>COROLLARY 5.1. The multiset size verification problem requires l)( n log k) steps in the worst case, with any dth order decision algorithm. ;'=(Xl+(X-g)e, x2+2(x2-)e,''',x,,+n(x,,-)e) and fi'= (Yl + (Yl-fi)e, Y2 + 2(y2-37) e, ", Yn + n(yn -fi)e).</p><p>Clearly, the degree of each ,k is at most d.</p><p>Let T be the transformed versions of T, 1, 2, 3. The transformed version of the full subtree is given by Fig. Note that T' does not depend on e. Furthermore, a straightforward inductive argument shows that height (T')-&lt; (d + 1)height (T). The correctness of T' follows from the following observations.</p><p>(i) If e &gt; 0 is chosen to be sufficiently small, then for center-free (, 37) the set {(xi + (xi g) e, y + (y ) e), 1 &lt;_-&lt;-n} has distinct elements.</p><p>(ii) The decision tree T' with input (,)7) agrees with the decision tree T with input (', 3Y), for all sufficiently small e &gt; 0.</p><p>Observation (ii) holds since for any (, 37) the polynomial f(', 97')=0 for all sufficiently small e &gt;0 if[ f,k(, 37) --0 for all k, and otherwise the sign of f(', 37') for all sufficiently small e &gt; 0 agrees with the sign of f,k(, 37) for the least k with ,(,)o.</p><p>Thus T' decides membership of center-free (, 37) in P, without assuming that all of the pairs (xi, yi) are distinct. Q.E.D.</p><p>The next lemma shows that deciding membership for Pn is no easier than the multiset size verification problem. LEMMA 5.2. The multiset size verification problem reduces to the membership problem for center-free tuples in Pn.</p><p>Proof. It suffices to note that as no three distinct points on a parabola can be collinear 2 (Xl," xn) Ml-i iff (xl,   xn, x2,</p><p>x,) Pn, and that (xl, , x,, x21, , x2) is center-free (except for the uninteresting case when all xi are identical). Q.E.D.</p><p>The preceding corollary and lemmas immediately yield the final theorem.</p><p>THEOREM 5.3. The convex hull size verification problem requires O( n log H) steps, in the worst case, with any dth order decision tree algorithm, even if the input points may be assumed to be distinct. 6. Conclusions. We have introduced a variation of the familiar divide-and-conquer paradigm and have illustrated this approach in the development of a new algorithm for the planar convex hull problem. Our algorithm unifies and improves the best worst case complexity bounds known for this problem in terms of the size of input and output (i.e. number of data points and number of hull vertices). In fact, we demonstrate that the algorithm is worst case optimal in terms of these two parameters in a very general model of computation.</p><p>In a companion paper <ref type="bibr" target="#b10">[10]</ref> we apply the same strategy to the maximal vector problem. We are able to demonstrate an O(n log V) upper bound for the 2-dimensional maximal vector problem, where V is the number of maximal vectors found. The same upper bound applies to the 3-dimensional maximal vector problem, and also to the d-dimensional maximal vector problem, d &gt; 3, when V is sufficiently small compared to n. These bounds tighten the best bounds known for the maximal vector problem. It remains to be seen whether our "marriage-before-conquest" approach can be applied successfully to other problems.</p><p>The results of this paper suggest other more specific open problems as well. In particular, it is natural to ask whether our results on planar convex hulls (like those for the maximal vector problem) extend to higher dimensions. For example, does there exist an O(n log H) algorithm for the 3-dimensional convex hull problem?</p><p>Another practical open question is whether, like the algorithm of Bentley and Shamos <ref type="bibr" target="#b4">[4]</ref>, our convex hull algorithm modified as suggested in footnote 2 has linear expected time complexity for reasonable input point distributions. We suspect that this is the case.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>FIG. 5.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Downloaded 05/15/13 to 128.230.234.162. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php the left and right endpoint of the edge of the, upper hull that intersects the vertical line L {(x, y)lx a}.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Downloaded 05/15/13 to 128.230.234.162. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc><table><row><cell>are bounded by</cell><cell></cell></row><row><cell>fO(1),</cell><cell>n=2,</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Downloaded 05/15/13 to 128.230.234.162. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php 5. Lower bounds. The results of this section demonstrate that our O(n log H)</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>5.2.   </figDesc><table /><note><p>FIG. 5.2</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Downloaded 05/15/13 to 128.230.234.162. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We are grateful to John Gilbert for his very careful reading of the manuscript.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>supported by the Natural Sciences and Engineering Research Council of Canada, grant A3583.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Function BRIDGE (S, a)  O. CANDIDATES :=</p><p>1. If IS1=2 then return ((i,j)), where S={p,,pj} and x(p,)&lt;x(pj).</p><p>2. Choose [[S[/2] disjoint sets of size 2 from S.</p><p>If a point of S remains, then insert it into CANDIDATES.</p><p>Arrange each subset to be an ordered pair (Pi, P), such that x(pi)&lt;-x(p).</p><p>Let PAIRS be the set of these ordered pairs. 3. Determine the slopes of the straight lines defined by the pairs.</p><p>In case the slope does not exist for some pair, apply Lemma 3.1, i.e."</p><p>For all (p, p) in PAIRS do if x(p) x(p) then delete (p, pj) from PAIRS if y(p) &gt; y(p) then insert pi into CANDIDATES else insert p into CANDIDATES else let k(p,, p) := Y(P')-Y(P)</p><p>x(p,) x(pj)"</p><p>4. Determine K, the median of {k(p, P)I(P, P) PAIRS}.</p><p>5. Let SMALL:= {(p,, p) PAIRS]k(p,, p) &lt; K}.</p><p>Let EQUAL:= {(p,, pj) PAIRSIk(p,, p)-K}.</p><p>Let LARGE := {(p,, p) PAdRSIk(p,, p) &gt; K}. 6. Find the set of points of S which lie on the supporting line h with slope K, i.e.: Let MAX be the set of points p S, s.t. y(p)-K x(p) is maximum.</p><p>Let Pk be the point in MAX with minimum x-coordinate. Let p,, be the point in MAX with maximum x-coordinate.</p><p>7. Determine if h contains the bridge, i.e."</p><p>if X(pk) &lt; ---a and x(p,,) &gt; a then return((k, m)).</p><p>8. h contains only points to the left of or on L: if x(p,,) -&lt;_ a then for all (p, p) LARGE [_J EQUAL insert pj into CANDIDATES. for all (pi, p) SMALL insert p and p into CANDIDATES. 9. h contains only points to the right of L: if X(pk) &gt; a then for all (p, p) SMALL [.J EQ UAL insert p into CANDIDATES. for all (p, p) LARGE insert pi and pj into CANDIDATES. 10. return(BRIDGE (CANDIDATES, a)). Proof. The algorithm is trivially correct if S contains only two points. As long as S contains more than two points, BRIDGE either finds the bridge in step 7 or discards redundant points of S applying the rules of Lemmas 3.1 and 3.2 (steps 3, 8, 9) and calls itself recursively with a smaller pointset.</p><p>Using the linear time median algorithm of Blum et al. [1, p. 99], the body of BRIDGE without the recursive call can be executed in linear time and space. Further- more, at least one quarter of the points of S are eliminated and not contained in CANDIDATES. Thus the worst case time and space requirements for the algorithm Consider all tuples (Zl," ", Zn) with zl," ", Zk set to distinct integers between 1 and k, and Zk+I," ", Zn set to arbitrary integers in that range. There are k! k n-k such tuples and each of them must lie in a different connected component of Mk. Q.E.D.</p><p>We are now prepared to demonstrate our lower bound. THEOREM 5.2. The convex hull size verification problem requires ( n log H) steps, in the worst case, with any dth order decision tree algorithm.</p><p>Proof. We reduce the multiset size verification problem to the convex hull size verification problem in the following obvious way: Let Z-(z,..., z} and k be an instance of the multiset size verification problem. Define S-(Pl,'",P}C R 2 by Pi (zi, z). Then the set ext(S) has exactly k elements if and only if Z has exactly k distinct elements. Q.E.D.</p><p>The proof of the above theorem is somewhat disappointing in that the convex hull problem formed in the reduction has multiplicities on the convex hull. This straightforward reduction leaves open the possibility that there exists an algorithm solving the convex hull size verification problem (or any of the other variants) in o(n log H) steps for point sets that are known a priori to contain no duplicates.</p><p>Fortunately, we can strengthen our lower bound to include tree algorithms based on this rather dubious assumption as well. We will show that a convex hull algorithm that is only guaranteed to be correct when the input points are distinct could be used to solve a certain perturbed convex hull problem without input restrictions. An algorithm for this perturbed problem in turn yields a solution for the multiset size problem.</p><p>For the sake of notation let (, fi) be shorthand for (x,..., x, y,..., y) and let g and denote (l/n) i= x and (l/n) "i=1 Y' respectively. We call a tuple (, fi)   center-free iit (, ) (x, y) for 1 -&lt; &lt;_-n. Define Cn {(, fi) R 2" ]ext({(x,, y,)]l -&lt;_ i_ &lt; n}) H} and Pn {(, ) R 2" [ext({(x, + i(x,-g)e, Yi + i(y,-fi)e)]l -&lt; _-&lt; n})l H} for all e &gt; 0 sufficiently small. Note that testing membership in CH is the convex size verification problem. The intuitive meaning for PH is the following: Pn encodes the point sets {(x, y) RE11 =&lt; =&lt; n) with the property that if each point p-(x, yi) moved radially away from ff (, )   for sufficiently small but positive time e at speed proportional to the index and proportional to the distance from p to/, then the convex hull of the new point set would have H extreme points. Observe therefore, that if (, fi) CH and the encoded 2-dimensional point set has no point on a convex hull edge, then (, fi) P/.</p><p>The following lemma shows that the convex hull size verification problem with this dubious distinctness restriction is no easier to solve than the general membership problem in PH for center-free tuples. LEMMA 5.1. Let T be any dth order decision tree algorithm for deciding membership in CH, assuming that all of the points (x, y), 1 &lt;-_ &lt;-n, are distinct. Then there exists a dth order decision tree T', with height (T') &lt;-d + 1) height (T), that decides membership of center-free tuples in PH without the distinctness assumption.</p><p>Proofi We define a transformation on every subtree of T. The leaves of T are not changed (i.e. they retain their YES.-NO labels). Consider an arbitrary subtree rooted at a vertex vj with label f(, fi) (see Fig. <ref type="figure">5</ref>.1). Define the multivariate polynomials f.o,f,l," ", f,d by the equality fj()t, fit) fj,0(), ) ._A1 () )E -''" "+'fj,d (), )E d, Downloaded 05/15/13 to 128.230.234.162. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Computer Algorithms</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the complexity offinding the convex hull of a set ofpoints</title>
		<author>
			<persName><forename type="first">D</forename><surname>Avis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">School of Computer Science</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1979">1979</date>
		</imprint>
		<respStmt>
			<orgName>McGill Univ., Montreal</orgName>
		</respStmt>
	</monogr>
	<note>Report SOCS</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Lower bounds for algebraic computation trees</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th ACM STOC</title>
		<meeting>15th ACM STOC</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="80" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Redistribution subject to SIAM license or copyright</title>
		<idno>Downloaded 05/15/13 to 128.230</idno>
		<ptr target="http://www.siam.org/journals/ojsa.php" />
		<imprint>
			<biblScope unit="volume">234</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Divide and conquer for linear expected time</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Shamos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Proc. Lett</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="87" to="91" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Two variable linear programs are solvable in linear time</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Dyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Manuscript, Dept. Mathematics and Statistics</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>Teesside Polytechnic</publisher>
			<pubPlace>Middlesborough, Cleveland, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A new convex hull algorithm for planar sets</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">F</forename><surname>Eddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Math. Software</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="411" to="412" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the O(n log n) lower-bound for convex hull and maximal vector determination</title>
		<author>
			<persName><forename type="first">P</forename><surname>Van Emde</surname></persName>
		</author>
		<author>
			<persName><surname>Boas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Proc. Let</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="132" to="136" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An efficient algorithm for determining the convex hull of a finite planar set</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Proc. Lett</title>
		<imprint>
			<biblScope unit="page" from="132" to="133" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the identification of the convex hull of a finite set of points in the plane</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Jarvis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Proc. Lett</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="18" to="21" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Output size sensitive algorithms for finding maximal vectors</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symposium on Computational Geometry</title>
		<meeting>ACM Symposium on Computational Geometry</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="89" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The Art of Computer Programming</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="volume">3</biblScope>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On finding the maxima of a set of vectors</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Kung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Luccio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Preparata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="469" to="476" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Linear-time algorithms for linear programming in R .and related problems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Megiddo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd FOCS</title>
		<meeting>23rd FOCS</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="329" to="338" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An optimal real time algorithm for planar convex hulls</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Preparata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="402" to="405" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Convex hulls offinite sets ofpoints in two and three dimensions</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Preparata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="87" to="93" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">R</forename><surname>Sedgewick</surname></persName>
		</author>
		<author>
			<persName><surname>Quicksort</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<pubPlace>Stanford, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Stanford Univ.</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Computational geometry</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Shamos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
			<pubPlace>New Haven, CN</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Yale Univ.</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Lower bounds for algebraic decision trees</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Steele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1" to="8" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A lower bound to finding convex hulls</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="780" to="789" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
