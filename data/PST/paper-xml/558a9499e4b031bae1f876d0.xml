<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Circuit Representation Technique for Automated Circuit Design</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jason</forename><forename type="middle">D</forename><surname>Lohn</surname></persName>
							<email>jlohn@ptolemy.arc.nasa.gov</email>
						</author>
						<author>
							<persName><forename type="first">Silvano</forename><forename type="middle">P</forename><surname>Colombano</surname></persName>
							<email>scolombano@mail.arc.nasa.gov</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Caelum Research Corporation at NASA Ames Research Center</orgName>
								<address>
									<addrLine>Mail Stop 269-1</addrLine>
									<postCode>94035-1000</postCode>
									<settlement>Moffett Field</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Computational Sciences Division of NASA Ames Research Center</orgName>
								<address>
									<addrLine>Mail Stop 269-1</addrLine>
									<postCode>94035-1000</postCode>
									<settlement>Moffett Field</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Circuit Representation Technique for Automated Circuit Design</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F6CC3C293D36672C9E32EAE7C296389F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:08+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>automated design</term>
					<term>analog circuit synthesis</term>
					<term>genetic algorithms</term>
					<term>circuit representation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a method of automatically generating circuit designs using evolutionary search and a set of circuit-constructing primitives arranged in a linear sequence. This representation has the desirable property that virtually all sets of circuit-constructing primitives result in valid circuit graphs. While this representation excludes certain circuit topologies, it is capable of generating a rich set of them including many of the useful topologies seen in hand-designed circuits. Our system allows circuit size (number of devices), circuit topology, and device values to be evolved. Using a parallel genetic algorithm and circuit simulation software, we present experimental results as applied to three analog filter and two amplifier design tasks. In all tasks, our system is able to generate circuits that achieve the target specifications. Although the evolved circuits exist as software models, detailed examinations of each suggest that they are electrically well behaved and thus suitable for physical implementation. The modest computational requirements suggest that the ability to evolve complex analog circuit representations in software is becoming more approachable on a single engineering workstation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. Introduction</head><p>Analog circuits are of great importance in electronic system design since the world is fundamentally analog in nature. While the amount of digital design activity far outpaces that of analog design, most digital systems require analog modules for interfacing to the external world. It was recently estimated that approximately 60% of CMOS-based application-specific integrated circuit (ASIC) designs incorporated analog circuits <ref type="bibr" target="#b0">[1]</ref>. With challenging analog circuit design problems and fewer analog design engineers, there are economic reasons for automating the analog design process, especially time-tomarket considerations.</p><p>Techniques for analog circuit design automation began appearing about two decades ago. These methods incorporated heuristics <ref type="bibr" target="#b17">[18]</ref>, knowledge-bases <ref type="bibr" target="#b4">[5]</ref>, and simulated annealing <ref type="bibr" target="#b14">[15]</ref>. Efforts using techniques from evolutionary computation have appeared over the last few years. These include the use of genetic algorithms (GAs) <ref type="bibr" target="#b5">[6]</ref> to select filter component sizes <ref type="bibr" target="#b6">[7]</ref>, to select filter topologies <ref type="bibr" target="#b2">[3]</ref>, and to design operational amplifiers using a small set of topologies <ref type="bibr" target="#b12">[13]</ref>. The research of Koza and collaborators <ref type="bibr" target="#b10">[11]</ref> on analog circuit synthesis by means of genetic programming (GP) <ref type="bibr" target="#b9">[10]</ref> is likely the most successful evolutionary computation-based approach to date. Unlike previous systems, the component values, number of components, and the circuit topologies are evolved. The genetic programming system begins with minimal knowledge of analog circuit design and generates circuits using a cellular encoding technique <ref type="bibr" target="#b3">[4]</ref> and circuit-constructing program trees. Various analog filter design problems have been solved using genetic programming (e.g., <ref type="bibr" target="#b11">[12]</ref>), and an overview of these techniques, including eight analog circuit synthesis problems, is found in <ref type="bibr" target="#b10">[11]</ref>. A comparison of geneticbased techniques applied to filter design appears in <ref type="bibr" target="#b18">[19]</ref> and work on evolving CMOS transistors for function approximation <ref type="bibr" target="#b16">[17]</ref> has also appeared recently.</p><p>The evolutionary computation-based approaches mentioned above and described in this paper are all offline hardware evolution approaches -software simulators are used to evolve software models of hardware. It should be noted that a growing number of researchers are using real hardware to evaluate a circuit's fitness during evolutionary search -the online approach. For example, in this issue, a system that employs a software-reconfigurable analog circuit to control frequency filtering in cellular phones is reported <ref type="bibr" target="#b13">[14]</ref>. They demonstrate how genetic algorithms are used to shrink circuit sizes and improve manufacturing yield. Another study that uses online evolution (and also appears in this issue <ref type="bibr" target="#b7">[8]</ref>) investigated the use of evolutionary search to make a field-programmable gate array (FPGA) function like an oscillator. Oscillators are difficult to design using only digital logic gates, so in practice they are made using more expensive analog components. Since FPGAs are digital, the design task is challenging. The authors reported results from 30 genetic algorithm runs that produced accurate oscillators for half of the target frequencies.</p><p>Our investigation centers on whether a linear representation and unfolding technique, coupled with modest computer resources, could be effective for evolving analog filters and transistor-based amplifiers. Our circuit representation has the desirable property that all sets of circuit-constructing primitives result in valid circuit graphs, with the exception of a few trivial cases. Thus application of genetic operators will result in valid circuit graphs. While certain circuit topologies are excluded, our representation is capable of generating a rich set of them including many of the useful topologies seen in hand-designed circuits. Another motivation in designing our representation was to minimize the amount of computer processing and hence run time of our system. Since virtually all of the graph structures generated are valid circuits, our system does not need to perform functions such as the pruning of unconnected circuit branches.</p><p>Our technique presented below differs from the previously mentioned GA techniques in that we allow both topology and component sizes to be evolved. In <ref type="bibr" target="#b18">[19]</ref>, a GA approach is presented in which topologies and component values are evolved, however that system allowed only a small number of components (15 components maximum). Because our genome resembles a computer program, and because our GA acts upon dynamically-sized representations, it has some elements in common with genetic programming. Our genomes are fixed to hold a maximum of 150 circuit components, a limit arrived at by surveying the circuit design literature for the design tasks we are interested in. Using a cluster of six engineering workstations (1996 Sun Ultra), we present evolved circuit solutions to four circuit design tasks. Although the evolved circuits exist as software models, detailed examinations of each suggest that they are electrically well-behaved and thus suitable for physical implementation.</p><p>The remainder of this paper is organized as follows. The circuit representation technique is introduced and described in Section II. Section III presents the evolutionary computation, and in Section IV our experimental results are presented and analyzed. We discuss our conclusions in Section V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. Circuit Representation</head><p>In designing an effective circuit representation for use in evolutionary search, the following properties are among the most desirable. First, the representation should permit any circuit or at least a wide range of circuits to be represented. If it is known a priori that certain topologies are well suited to a specific design task, topological restrictions inherent in the representation may be beneficial since the search space will be reduced. Conversely, not having this limitation may bring to light novel designs that human designers have never envisioned. Second, the genotype conversion algorithm (the circuit constructing process) should run as fast as possible. Clearly if numerous traversals of the circuit graph structure are required in order to guarantee a valid circuit graph, the performance hit will be commensurate. For an n-component circuit, a reasonable upper bound would be O(n). Third, the representation should be syntactically closed so that genetic operators do not create invalid circuit graphs<ref type="foot" target="#foot_0">1</ref> from those that are valid. The circuit representation we present here was designed to have these properties.</p><p>Circuit designs are constructed by an automaton that is programmed via a set of low-level instructions. The automaton is called a circuit-constructing robot or cc-bot, and the "language" that programs it is small and, in its current incarnation, contains only component-placing instructions (e.g., control instructions are not included). The set of cc-bot instructions has the desirable property that virtually all possible sequences of instructions result in a valid electrical circuit. This property is important because it greatly limits the "out-of-bounds" regions of the search space containing invalid circuit graphs. Thus, evolutionary search will spend nearly all its time generating valid circuit graphs. While this is a beneficial, non-trivial achievement, we do lose the ability to generate every possible circuit topology. This is not considered a drawback for the circuit types we investigated since a vast number of topologies and existing circuit designs could be encoded using the cc-bot approach.</p><p>Each cc-bot instruction places a circuit component and directs the movement of the cc-bot. The five basic instruction types are: x-move-to-new, x-cast-to-previous, x-cast-to-ground, x-cast-input, x-cast-to-output, where x can be replaced by R (resistor), C (capacitor), L (inductor), or transistor configuration. In a circuit design task involving only inductors and capacitors (an LC circuit), ten opcodes would be available to construct circuits (five for capacitors and five for inductors).</p><p>The meanings of each instruction are summarized in Table <ref type="table" target="#tab_0">I</ref>. The move-to-new instruction places one end of a component at the active node and the other at a newly created node (the "active" node is the current location of the cc-bot). The newly created node then becomes the active node. The cast-to instructions place one end of the component at the active node and the other at either the ground, input, output, or previously-created node. After executing a cast-to instruction, the cc-bot remains at the active node. The input and output nodes are the overall input and output nodes of the circuit as opposed to the input and output of the placed component. Illustrations of two instructions that place resistors are shown in Fig. <ref type="figure" target="#fig_0">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Instruction</head><p>Outgoing Node Active Node x-move-to-new newly-created node becomes the newly-created node x-cast-to-previous previous node unchanged x-cast-to-ground ground node unchanged x-cast-to-input input node unchanged x-cast-to-output output node unchanged  The circuit is constructed by the cc-bot inside of a template circuit. The design tasks presented here use a template having one input and one output terminal as shown in Fig. <ref type="figure" target="#fig_1">2</ref>. An ideal voltage source v s is connected to ground and to a source resistor R s . The circuit's output voltage is taken across a load resistor R l .</p><p>The lists of cc-bot instructions manipulated by the GA are variable-length lists so that the size of the circuit can be evolved. When the cc-bot reaches the last component to place in the circuit, we arbitrarily chose to have the last active node connected to the output terminal by a wire (accomplished by connection of a 1µΩ resistor). By doing so, we eliminate unconnected branches. As assembly language instructions are mapped to opcodes, cc-bot instructions are mapped to bytecodes. Instructions are represented by up to four bytecodes. For instructions that take a component value as an argument, the first byte is the instruction, and the next three represent the component value (resistance, capacitance, and inductance values). For transistors, component values are not needed. Using three bytes allows the component values to take on one of 256 3 values, a sufficiently fine-grained resolution. The raw numerical value of these bytes was then scaled into a reasonable range, depending on the type of component. Resistor values were scaled sigmoidally between 1 and 100K ohms using 1/(1 + exp(-1.4(10x -8))) so that roughly 75% of the resistor values were biased to be less than 10K ohms. Capacitor values were scaled between approximately 10 pF and 200 µF and inductors between roughly 0.1 mH and 1.5 H.</p><p>Transistors are current amplifying and switching devices that have three terminals. <ref type="foot" target="#foot_1">2</ref> In this paper we use bipolar junction transistors as shown in Fig. <ref type="figure" target="#fig_2">3</ref>. Using devices with three terminals makes it harder to design a circuit representation that achieves the properties that we desire. If a cc-bot were to connect one terminal of a transistor at a node, then two active nodes would result each requiring its own cc-bot. This could happen repeatedly resulting in an exponential growth of cc-bots constructing the circuit in parallel. Two problems are obvious: how will the multiple constructing "threads" interconnect, and how will the dangling nodes that will likely appear at the end of the circuit constructing process be handled. To allow interconnections between constructing threads, one can introduce a spatial dimension and let the cc-bots form interconnections as they criss-cross each other's path. To handle the dangling node problem, one can determinstically tie dangling nodes to each other, to internal nodes, or to the output node for example. Another solution is to simply prune those nodes. Although we have considered these and other solutions, a simpler way of handling transistors is also a viable alternative: treating them as having only two terminals. To work with transistors as devices with two terminals, we have the third terminal hardwired (fixed) to one of the following pre-existing circuit nodes: ground, power supply (positive or negative), input, output, the previously placed node, or even to itself. Such a scheme allows a wide variety of configurations. To understand these configurations we label the terminals in a generic way: incoming, outgoing, and fixed (see Fig. <ref type="figure" target="#fig_3">4</ref>). The incoming terminal is the terminal that the cc-bot will connect to the active node. The outgoing terminal will become the new active node (for move-to instructions) or it will be cast to a pre-existing circuit node. The fixed terminal is hardwired as its name implies. To give a sense of the types of transistor configurations possible, the chart in Fig. <ref type="figure" target="#fig_5">5</ref> illustrates 52 configurations for an npn transistor whose base terminal is designated incoming. Each entry shows the connections that the cc-bot makes when executing the instruction listed in the first column. The last two columns show self-connections, some of which are frequently used by circuit designers. Similar charts can be produced for npn transistors having the collector and emitter serve as the incoming terminal, as well as the three analogous charts for pnp transistors. There are configuration redundancies so that each chart will not have exactly 52 configurations. In addition we exclude emitter-collector self-connections since this shorts out the transistor.  The cc-bot approach to representing circuits embodies the desirable properties outlined above. The encoding has syntactic closure since any combination of instructions produces a valid circuit graph, and since every instruction contained in the genome results in a circuit component, there are no noncoding genome segments. The circuit construction process is O(n) since it does not require any repair (e.g., removal of unconnected nodes) operations. Lastly, the cc-bot approach can generate a wide range of circuit graph topologies. The topological restriction is as follows: circuit branches off of the main constructing thread cannot, in general, contain more than one node (there are some exceptions to this). The constructing thread is the sequence of components that are created by the move-to-new instructions. The constructing thread itself can be of varying lengths and can contain both series and parallel configurations. In spite of these limitations, our system allows the creation of circuits with a large variety of topologies, including numerous topologies seen in hand-designed circuits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. Evolutionary Search</head><p>The evolutionary search employed in our experiments is based on the genetic algorithm. The GA operates on a population of dynamically-sized bytecoded arrays. In practice we imposed a maximum size of about 400 bytes (100-150 circuit components) in order to accommodate population sizes of up to 18,000 individuals. The crossover rate was set at 0.8 and mutation (per locus) rates were set between 0.05-0.20. Crossover was single-point with each parent having a separately chosen crossover point. Crossover points were randomly selected and were constrained to lie on component boundaries and to yield circuits having at least 10 components and at most 150 components.</p><p>An overview of the evaluation process is depicted in Fig. <ref type="figure" target="#fig_6">6</ref>. As in the GP system mentioned above, we used the public-domain Berkeley SPICE (Simulation Program with Integrated Circuit Emphasis) circuit simulation program <ref type="bibr" target="#b15">[16]</ref> to simulate our circuits. The array of bytecodes was interpreted in the manner previously described, and resulted in a SPICE netlist representation. The netlist is processed by SPICE and the output from SPICE is then used to compute fitness for the individual.</p><p>Since most of the processing time is spent simulating circuit designs, which are independent of one another (within a generation), parallelizing the system is greatly beneficial. The parallel GA implemented uses master/slave-style parallelism <ref type="bibr" target="#b1">[2]</ref> over a network of UNIX-based workstations. A controlling host computer performs GA operators and distributes a population of bytecoded-individuals to a specified number of worker nodes using socket connections (Fig. <ref type="figure" target="#fig_7">7</ref>). The worker nodes decode the individuals into SPICE netlists that are then fed into SPICE via FIFO pipes to minimize disk activity. Fitness is calculated using SPICE's output, and then sent back to the host. Hundreds of individuals (and fitness scores) are packaged into a single message so that external network congestion delays are minimized. The SPICE program itself required minor modifications since it runs as a separate process. Written in the C programming language, the system currently runs on Sun workstations and a variety of other UNIX systems (e.g., SGIs, PCs running Linux), giving us the ability to mix various workstations in a single workstation cluster. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. Experiments and Results</head><p>The goal of the experiments was to automatically design analog filters and transistor-based amplifiers using evolutionary search. The choice of using passive analog filters was inspired by the previous studies and is a good choice for testing the effectiveness of our system for three reasons. First, all components have two terminals which is suited for the cc-bot technique. If the proposed system could not evolve useful circuits using devices with two terminals, then attempting to evolve circuits using more complex components (e.g., transistors) would likely prove ineffective. Second, there are no energy sources required within the circuit which further reduces the complexity. Lastly, filter design is a well-understood discipline within circuit design. Its "design space" has been greatly explored <ref type="bibr" target="#b8">[9]</ref> which allows us to compare our evolved designs to well-known designs. Amplifiers are very common in analog circuit design and are a good choice for our experiments for many of the same reasons that filters are. We use transistors in the amplifier design experiments since the vast majority of such designs today are transistor-based.</p><p>All of the evolved designs presented below meet the target specifications. For filters, that meant satisfying four parameters. For the amplifier circuits, our gain target was a range of values: from 70 dB to the maximum gain attainable for the circuit. Each evolved circuit was hand-probed using simulation software so that we could verify that internal currents and voltages remained at realistic values. This step suggests that these circuits could be physically implemented.</p><p>A low-pass filter is a circuit that allows low frequencies to pass through it, but stops high frequencies from doing so. In other words, it is frequency selective in that it "filters out" frequencies above a specified frequency. The unshaded area in Fig. <ref type="figure" target="#fig_8">8</ref> depicts the region of operation for low-pass filters. Below the frequency f p the input signal is passed to the output, potentially reduced (attenuated) by K p decibels (dB). This region is known as the passband. Above the frequency f s , in the region is called the stopband, the input signal is markedly decreased by K s decibels. Between the passband and stopband the frequency response curve transitions from low to high attenuation. The parameter located in this region, f c , is known as the cutoff frequency. One of the design tasks concerned designing a circuit within the class of "Butterworth" filters. Butterworth filters are very common and circuits that implement them are readily found in filter design tables <ref type="bibr" target="#b8">[9]</ref>. The attenuation (negative gain) of Butterworth filters is of the form 1/(1 + (f/f c ) 2N ) where f is the input frequency and N is the order of the filter. The higher order a filter has, the sharper the "knee" of its gain curve, and the more complex the circuit. A plot of the attenuation for a third-order Butterworth filter is shown in Fig. <ref type="figure" target="#fig_9">9</ref>. Amplifier circuits generate an output signal that consists of the input signal multiplied by a gain factor, A. Voltage gain is denoted A v and is equivalent to the ratio of output to input voltages (v o /v i ). It is common to express gain values in decibels (dB) using 20 log 10 (A). Amplifiers may be either inverting or non-inverting, where an inverted output signal has a 180 degree phase shift compared to the input. The dc gain of an amplifier refers to the gain when only constant voltage/current sources are applied. The ac or small-signal gain is the gain of an ac input signal irrespective of any dc components in the output signal. A dc component that shifts the entire ac signal up or down is called the dc bias of the circuit. For simple amplifiers, like filters, there are published volumes available that catalog many designs. Since there are numerous parameters in amplifier design (e.g., input/output impedance, power dissipation, distortion, common-mode rejection, power supply rejection), the design task can become quite challenging and may require an experienced designer. For the amplifier design experiments below, we take into account only dc and ac gain, dc bias, and linearity, although future experiments will include more design parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Filter Design Tasks</head><p>Three filter design experiments were performed. In each experiment, 10 runs were performed and we present the circuit having the highest fitness value across all runs. The experiments increased in difficulty so that filter 3 represents a challenging design task, while filter 1 is least challenging.  The GA parameters remained the same within a given experiment, but varied in the number of evaluations (circuit simulations): filter 1 runs had 30,000 evaluations, filter 2 had 3.6 million, and filter 3 had 1 million. These values were arrived at by experimentation and constrained by practical issues such as the availability of workstations.</p><p>For the filter experiments, fitness was calculated to promote the regression of the evolved circuit's frequency response toward that of the target. Error values were computed as the absolute value of the difference of the individual's output and the target output. These error values were summed across evaluation points to arrive at a fitness value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Electronic Stethoscope Circuit</head><p>The first filter design task was set up to generate a filter suitable for use in an electronic stethoscope. In this application, it is desired to filter out the extraneous high-frequency sounds picked up by a microphone which make it difficult to listen to (low-frequency) bodily sounds (e.g., a heart beating). As such, the frequency response specifications do not need to be extremely accurate since the human ear cannot discern frequencies that are close together. The target frequency response data was taken from an actual electronic stethoscope, which was built with a cutoff frequency of 796 Hz corresponding to an output voltage of approximately 1 volt. This circuit is relatively easy to design and so we chose it as our first design task. The cc-bot instruction set consisted of ten instructions, five for resistors and five for capacitors, which allowed for the construction of an RC low-pass filter. The evolved circuit is shown in Fig. <ref type="figure" target="#fig_10">10(a</ref>) and its frequency response, which matches almost exactly the target is shown in Fig. <ref type="figure" target="#fig_10">10(b)</ref>. It was found in generation 3 of a 10-generation run that had a population size of 3000, an indication that this design task was relatively easy. The circuit exhibits the standard design for simple low-pass filters: a resistor (R 2 ) in series with the source to form a voltage divider at low frequencies (C 1 open), and a capacitor (C 1 ) across the output to short it at high frequencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Butterworth Low-pass Filter</head><p>The second low-pass filter design task had specifications that were more difficult to achieve than the first filter: both the passband and the stopband were longer, thus requiring the transition to be sharper. We chose a circuit that can be built using a 3rd-order Butterworth filter and having a frequency response of the form seen in Fig. <ref type="figure" target="#fig_9">9</ref>. The specifications are listed under filter number two in Table <ref type="table" target="#tab_0">II</ref>.</p><p>Such a filter design can be derived using a ladder topology containing two capacitors and one inductor and component values found in published tables. Because we wanted to design an LC low-pass filter, the cc-bot instruction set consisted of only capacitor and inductor instructions. The evolved circuit that meets these specifications is shown in Fig. <ref type="figure" target="#fig_11">11</ref> and its frequency response is shown in Fig. <ref type="figure" target="#fig_12">12</ref>. It was found in generation 22 of a run that had a population size of 18,000.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Third Low-pass Filter</head><p>The third low-pass filter design task had specifications that were the most stringent: in addition to the passband and stopband being increased, the attenuation parameters were tightened (see Table <ref type="table" target="#tab_0">II</ref>). These specifications are similar to the fifth-order elliptic filter described in <ref type="bibr" target="#b10">[11]</ref>. In that work, the evolved LC circuit satisfies K p = 0.3 dB and K s = 60 dB. Another evolved low-pass filter circuit <ref type="bibr" target="#b18">[19]</ref> had the same stopband and passband frequencies, but less demanding attenuation specifications (K p = 1.6 dB and K s = 24.8 dB). The evolved circuit is shown in Fig. <ref type="figure" target="#fig_13">13</ref> and its frequency response is seen in Fig. <ref type="figure" target="#fig_3">14</ref>. Micro-ohm resistors were added as a convergence aid for the circuit simulator, and can be ignored for analytical purposes. This circuit was found in generation 997 of a run that had a population size of 1000. The cc-bot instruction sequence and SPICE netlist for this circuit are included for reference in the Appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Amplifier Design Tasks</head><p>Two amplifier design experiments were performed. In each experiment, 10 runs were performed and we present the highest performance circuits found across all runs. The goal was to design an inverting amplifier capable of a dc voltage gain up to a maximum of either 100 dB or 120 dB, while minimizing dc bias and maximizing linearity over the dc gain. Population size was set to 1200 individuals, and each run proceeded for 5000 generations, giving a total of 6 million circuit evaluations per run. The difference between the two sets of experiments is that in the first set, the maximum gain was set to be 120 dB, and in the second set, 100 dB was the maximum gain. The maximum gain possible is set by using feedback resistors (labeled R F B ). For an ideal inverting amplifier (as shown in Fig. <ref type="figure" target="#fig_5">15</ref>), the magnitude of the gain of the amplifier is simply R F B /R S , where R S is the source resistor. Fitness was calculated in a manner similar to the work on amplifiers in <ref type="bibr" target="#b10">[11]</ref>. An error value is computed as the sum of the dc gain penalty (the target gain minus the observed gain), the dc bias (zero dc bias is ideal), and the degree to which the dc gain is linear.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1 75 dB Inverting Amplifier</head><p>In the first set of experiments the maximum voltage gain was set at 120 dB (10 6 ). The amplifier having the best performance had a dc gain of 74.53 dB (5324.40). Figure <ref type="figure" target="#fig_15">16</ref> shows the schematic for this circuit. It was found in generation 4866, and had a dc bias of 3.64 volts and a power dissipation of 0.82 watts.</p><p>The dc behavior is best understood by examining the major current pathways in the circuit. The current through the load is the key quantity since it is converted to a voltage by the load resistor and hence forms the circuit's output. Nearly all of the dc current flowing through the load resistor originates from the power supply connected to transistor Q7's collector. Q7 is biased in such a way as to supply Q8's base with approximately 36.4 mA of current. This current is divided so that 18.1 mA flows out of Q8's emitter and 18.3 mA out of Q8's collector. Resistor R2 is a tiny resistance that was positioned in order to connect transistor Q9 to the output (the last component is forced to connect to the output terminal). Thus R2 can be ignored, and transistor Q9's 18.4 mA current flows into the output node. Currents are summed at node 255 to give the load current of 36.4 mA which flows through the load resistance to give 3.64 volts output. Because there is a negligible amount of current flowing through transistors Q1 through Q4, the utility of these transistors is unclear. Components that are essentially non-functional, are quite commonly seen in evolutionary design applications. Figure <ref type="figure" target="#fig_16">17(a)</ref> shows the time domain response. Amplification of a 1 kHz sine wave having a 1 microvolt amplitude can clearly be seen. Figure <ref type="figure" target="#fig_16">17(b)</ref> shows the frequency response. The ac gain remains flat at 74.36 dB until it loses 3 dB at 7.59 kHz (its 3 dB bandwidth). Figure <ref type="figure" target="#fig_8">18</ref> shows the dc transfer characteristic. The dc bias of 3.64 volts can be seen at the voltage input of zero volts. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 85 dB Amplifier</head><p>In the second set of amplifier experiments the maximum voltage gain was set at 100 dB (10 5 ). The amplifier having the best performance had a dc gain of 85.41 dB <ref type="bibr">(18, 642.33)</ref>. Figure <ref type="figure" target="#fig_9">19</ref> shows the schematic for this circuit. It was found in generation 3635, and had a dc bias of 5.44 volts and a power dissipation of 8.17 watts.</p><p>Figure <ref type="figure" target="#fig_9">19</ref> shows the schematic for the amplifier. The dc current delivered to the load is mostly supplied by the 15 volt battery attached to the collector of transistor Q7. Transistor Q7 is conducting with the sum of its base and collector currents flowing out of its emitter. Q7's base current of 13 mA is supplied by transistor Q6. As in the previous amplifier, the utility of transistors Q1 through Q3 is unclear.</p><p>Input signal inversion and amplification are seen in Figure <ref type="figure" target="#fig_1">20</ref>(a) which shows the time domain response to an ac input of 1 microvolt at 1 kHz. The circuit has a flat-band gain of 85.46 dB and a 3 dB bandwidth of 282.8 kHz (Figure <ref type="figure" target="#fig_1">20(b)</ref>). The 3 dB bandwidth is significantly better than the previous amplifier. Figure <ref type="figure" target="#fig_1">21</ref> shows the dc transfer characteristic. The dc bias of 5.44 volts can be seen at the voltage input of zero volts. The slope, the magnitude of which is the gain, is negative since the amplifier is inverting the signal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. Discussion</head><p>We have shown that a linear circuit representation and evolutionary search can automatically produce circuit designs of low to medium difficulty in two applications. Detailed simulations of the evolved designs suggest that all are electrically well behaved and thus suitable for physical implementation. While the evolved designs presented do not exhibit the level of performance of their hand-designed  predecessors, our main point was to show that a new representation technique with many desirable properties could automatically design practical circuits. The circuit representation method devised permits a wide range of circuits to be constructed, and results in a construction process that is unburdened with repair operations. In addition, the representation is syntactically closed, making it well suited for evolutionary search. For other applications, the instruction set can be easily extended to incorporate other devices not mentioned, such as CMOS transistors. The main limitation of our approach is the inherent restriction on circuit topologies. Such restrictions can be overcome by augmenting the instruction set, and this is one line of investigation we are pursuing. To gain performance on par with circuits designed by engineers, it will be necessary to place further constraints into the fitness functions. For example, practical amplifiers are typically judged by a dozen or so specifications.</p><p>To evolve an amplifier that would perform as well would require using a multiobjective fitness function that accounts for each specification. This is another area for future work. With the encouraging results of our system, we are optimistic that a subset of analog circuit design tasks may be routinely accomplished by means of evolutionary computation in the future.   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Effect of placing a resistor with (a) move-to-new, and (b) cast-to-ground instructions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig.2. Template circuit: the evolved circuit is located between fixed input and output terminals. v s is an ideal voltage source, R s is the source resistance, R l is the load resistance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Bipolar junction transistor symbols: (a) npn; (b) pnp.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Labeling of terminals: (a) devices with two terminals have incoming and outgoing terminals; (b) devices with three terminals are treated as two-terminal devices by having a fixed connection at the third terminal.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Transistor configurations showing the outgoing and fixed connections when the incoming terminal is the transistor's base terminal. Terminals labeled in upper case letters denote the fixed terminal connection. In the last two columns the fixed connection is a self-connection. "PS" denotes the power supply (only the positive version is shown), and "N.A." denotes "not applicable." Only npn transistors are shown although analogous configurations are present for pnp transistors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig.6. Overview of circuit evaluation process starting with cc-bot instructions and ending with calculation of fitness.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Parallelization of genetic algorithm. Running circuit simulations in parallel greatly reduces runtime since nearly all of the processing time is spent simulating circuits.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8 .</head><label>8</label><figDesc>Fig.8. Low-pass filter terminology and specifications. The shaded regions represent out-of-specification areas. An example frequency response curve that meets specifications is shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9 .</head><label>9</label><figDesc>Fig.9. Gain on a logarithmic amplitude scale for a third-order Butterworth filter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. (a) Evolved low-pass filter for use in an electronic stethoscope (units are ohms and farads); (b) Nearly identical frequency response curves for evolved and actual electronic stethoscope circuit. The frequency axis is scaled logarithmically.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Evolved 3rd-order Butterworth low-pass filter (units are ohms, farads, and henries).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Frequency response curve for evolved 3rd-order Butterworth low-pass filter. Attenuation specifications are also shown. The frequency axis is scaled logarithmically.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 13 .</head><label>13</label><figDesc>Fig.<ref type="bibr" target="#b12">13</ref>. Evolved circuit satisfying target specifications for filter number three.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 14 .Fig. 15 .</head><label>1415</label><figDesc>Fig. 14. Frequency response for filter number three.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. Circuit schematic of evolved 75 dB amplifier.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 17 .</head><label>17</label><figDesc>Fig. 17. Small signal behavior of 75 dB evolved amplifier: (a) time domain input waveform is 1 kHz (bottom) which is inverted and amplified (top); (b) frequency response showing 3 dB bandwidth of 7.59 kHz.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 18 .Fig. 19 .</head><label>1819</label><figDesc>Fig. 18. DC transfer characteristic of 75 dB amplifier.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 20 .Fig. 21 .</head><label>2021</label><figDesc>Fig. 20. Small signal behavior of 85 dB evolved amplifier: (a) time domain input waveform is 1 kHz (bottom) which is inverted and amplified (top); (b) frequency response showing a flatband gain of 85.46 dB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I</head><label>I</label><figDesc>Summary of opcode types used in current system. x denotes the component type: resistor, capacitor, inductor, or transistor configuration.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Table II lists the target specifications for each of the experiments.</figDesc><table><row><cell cols="5">Filter No. f p (Hz) f s (Hz) K p (dB) K s (dB)</cell></row><row><cell>1</cell><cell>100</cell><cell>4000</cell><cell>1.29</cell><cell>27.12</cell></row><row><cell>2</cell><cell>925</cell><cell>3200</cell><cell>3.01</cell><cell>22.00</cell></row><row><cell>3</cell><cell>1000</cell><cell>2000</cell><cell>0.01</cell><cell>63.50</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Fig. 22. Instruction sequence to generate evolved filter number three.Fig. 23. SPICE circuit netlist for evolved filter number three.</figDesc><table><row><cell>Fifth order elliptical lowpass filter VSOURCE1 256 0 DC 0V AC 2V RSOURCE1 256 1 1000 RLOAD001 255 0 1000 CAPC0001 1 2 1.083701e-04 CAPC0002 2 3 3.547581e-05 CAPC0003 3 2 9.862769e-05 RSTR0001 3 2 1.042709e+04 LIND0001 1 3 2.147189e-01 LIND0002 3 2 5.285780e-03 LIND0003 3 4 7.713100e-01 CAPC0004 4 6 2.519509e-05 CAPC0005 0 6 1.048100e-07 LIND0004 1 6 2.008357e-01 RSTR0002 6 7 3.648645e+04 CAPC0006 7 6 1.261844e-04 LIND0005 1 7 2.113217e-01</cell><cell>LIND0006 LIND0007 CAPC0007 LIND0008 LIND0009 LIND0010 CAPC0008 LIND0011 LIND0012 CAPC0009 LIND0013 RSTR0003 *** End netlist 7 7 0 8 1 8 0 9 9 0 10 10 255 6 8 8 7 8 9 9 8 10 10 9 *** Total of 25 components 1.017696e-03 1.131617e+00 2.449500e-07 1.579361e+00 3.300694e-01 5.376858e-01 2.506300e-07 4.863538e-01 4.364222e-01 1.256400e-07 4.489818e-01 1.000000e-06 .AC DEC 20 1 100K .PRINT AC VM(255) .END</cell></row><row><cell>C_MOVE_TO_NEW C 1 2 10837006 C_MOVE_TO_NEW C 2 3 3547581 C_CAST_TO_PREV C 3 2 9862769 L_CAST_TO_PREV L 3 2 6880711 L_CAST_TO_INPUT L 1 3 7668359 R_CAST_TO_PREV R 3 2 10844497 L_CAST_TO_INPUT L 1 3 6794434 L_CAST_TO_INPUT L 1 3 10915194 L_CAST_TO_INPUT L 1 3 10360067 L_CAST_TO_PREV L 3 2 53267 L_MOVE_TO_NEW L 3 4 7713100 C_MOVE_TO_NEW C 4 5 3568044 C_MOVE_TO_NEW C 5 6 8573596 C_CAST_TO_GND C 0 6 10481 L_CAST_TO_INPUT L 1 6 10897482 L_CAST_TO_INPUT L 1 6 2462113 R_MOVE_TO_NEW R 6 7 12757499</cell><cell>L_CAST_TO_PREV L 7 6 10259 C_CAST_TO_PREV C 7 6 10161281 L_CAST_TO_INPUT L 1 7 2452274 C_CAST_TO_PREV C 7 6 2457158 L_CAST_TO_INPUT L 1 7 15284140 L_CAST_TO_PREV L 7 6 1272684 L_MOVE_TO_NEW L 7 8 11316166 C_CAST_TO_GND C 0 8 24495 L_CAST_TO_PREV L 8 7 15793607 L_CAST_TO_INPUT L 1 8 3300694 L_MOVE_TO_NEW L 8 9 5376858 C_CAST_TO_GND C 0 9 25063 L_CAST_TO_PREV L 9 8 4863538 L_MOVE_TO_NEW L 9 10 4364222 C_CAST_TO_GND C 0 10 12564 L_CAST_TO_PREV L 10 9 4489818 .</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that a graph could be a valid circuit graph, yet not make sense as an electrical circuit -for example, dissimilar voltage sources connected in parallel.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Four if the substrate terminal is included, but we connect the substrate to ground and hence ignore it.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Manuscript received on</head><p>. This work was supported by the NASA New Horizons Research Program.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Symbolic Analysis for Automated Design of Analog Integrated Circuits</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gielen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Sansen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Boston, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Goldberg</surname></persName>
		</author>
		<title level="m">Genetic Algorithms in Search, Optimization, and Machine Learning</title>
		<meeting><address><addrLine>Reading, Mass</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automatic Analogue Network Synthesis using Genetic Algorithms</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Grimbleby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First Int. Conf. Genetic Algorithms in Engineering Systems: Innovations and Applications (GALESIA)</title>
		<meeting>First Int. Conf. Genetic Algorithms in Engineering Systems: Innovations and Applications (GALESIA)</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="53" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Artificial Cellular Development in Optimization and Compilation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Gruau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Toward Evolvable Hardware</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Sanchez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Tomassini</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1062</biblScope>
			<biblScope unit="page" from="48" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Prototype Framework for Knowledge-Based Analog Circuit Synthesis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Harjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Rutenbar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Carey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Design Automation Conf</title>
		<meeting>24th Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Holland</surname></persName>
		</author>
		<title level="m">Adaptation in Natural and Artificial Systems</title>
		<meeting><address><addrLine>Ann Arbor</addrLine></address></meeting>
		<imprint>
			<publisher>Univ. of Michigan Press</publisher>
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Genetically Derived Filters using Preferred Value Components</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M A</forename><surname>Khalifa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEE Colloq. on Linear Analogue Circuits and Systems</title>
		<meeting>IEE Colloq. on Linear Analogue Circuits and Systems<address><addrLine>Oxford, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Evolving Oscillators in Silico</title>
		<author>
			<persName><forename type="first">L</forename><surname>Huelsbergen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rietman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Slous</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>appears in this issue</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Active and Passive Analog Filter Design</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Huelsman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>McGraw-Hill</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Genetic Programming: On the Programming of Computers by Means of Natural Selection</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automated Synthesis of Analog Electrical Circuits by Means of Genetic Programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Andre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Keane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dunlap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="109" to="128" />
			<date type="published" when="1997-07">July, 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Use of Architecture-Altering Operations to Dynamically Adapt a Three-Way Analog Source Identification Circuit to Accommodate a New Source</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Lohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dunlap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Keane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Andre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Genetic Programming 1997 Conference</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Deb</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Dorigo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Fogel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Garzon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Iba</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Riolo</surname></persName>
		</editor>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="213" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Analog Design Automation using Genetic Algorithms and Polytopes</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Kruiskamp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<pubPlace>Eindhoven, The Netherlands</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Dept. of Elect. Engr., Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Murakawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yoshizawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Adachi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Suzuki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takasuka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Iwata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Higuchi</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Title TBD],&quot; appears in this issue</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Synthesis of High-Performance Analog Circuits in ASTRX/OBLX</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Ochotta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Rutenbar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Carley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="273" to="294" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Quarles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Newton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">O</forename><surname>Pederson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<title level="m">SPICE 3 Version 3F5 User&apos;s Manual</title>
		<meeting><address><addrLine>Berkeley, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Electrical Engineering and Computer Science, Univ. of California</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On Hardware Evolvability and Levels of Granularity</title>
		<author>
			<persName><forename type="first">A</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1997 Int. Conf. Intell. Systems and Semiotics</title>
		<meeting>1997 Int. Conf. Intell. Systems and Semiotics</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="244" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Heuristic Techniques in Computer-Aided Circuit Analysis</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Sussman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Stallman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Comparison of Different Evolutionary Methodologies Applied to Electronic Filter Design</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Zebulum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Pacheco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vellasco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Int. Conf. on Evolutionary Computation</title>
		<imprint>
			<biblScope unit="page" from="434" to="439" />
			<date type="published" when="1998">1998. 1998</date>
			<publisher>IEEE Press</publisher>
			<pubPlace>Piscataway, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
