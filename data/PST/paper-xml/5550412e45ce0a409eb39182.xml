<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Recurrent Models of Visual Attention</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Volodymyr</forename><surname>Mnih</surname></persName>
							<email>vmnih@google.com</email>
						</author>
						<author>
							<persName><forename type="first">Nicolas</forename><surname>Heess</surname></persName>
							<email>heess@google.com</email>
						</author>
						<author>
							<persName><forename type="first">Alex</forename><surname>Graves</surname></persName>
							<email>gravesa@google.com</email>
						</author>
						<author>
							<persName><forename type="first">Koray</forename><surname>Kavukcuoglu</surname></persName>
							<email>korayk@google.com</email>
						</author>
						<author>
							<persName><forename type="first">Google</forename><surname>Deepmind</surname></persName>
						</author>
						<title level="a" type="main">Recurrent Models of Visual Attention</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9413B4CF8608E60CA45FBA4C78AB9CF9</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Applying convolutional neural networks to large images is computationally expensive because the amount of computation scales linearly with the number of image pixels. We present a novel recurrent neural network model that is capable of extracting information from an image or video by adaptively selecting a sequence of regions or locations and only processing the selected regions at high resolution. Like convolutional neural networks, the proposed model has a degree of translation invariance built-in, but the amount of computation it performs can be controlled independently of the input image size. While the model is non-differentiable, it can be trained using reinforcement learning methods to learn task-specific policies. We evaluate our model on several image classification tasks, where it significantly outperforms a convolutional neural network baseline on cluttered images, and on a dynamic visual control problem, where it learns to track a simple object without an explicit training signal for doing so.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Neural network-based architectures have recently had great success in significantly advancing the state of the art on challenging image classification and object detection datasets <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b18">19]</ref>. Their excellent recognition accuracy, however, comes at a high computational cost both at training and testing time. The large convolutional neural networks typically used currently take days to train on multiple GPUs even though the input images are downsampled to reduce computation <ref type="bibr" target="#b11">[12]</ref>. In the case of object detection processing a single image at test time currently takes seconds when running on a single GPU <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b18">19]</ref> as these approaches effectively follow the classical sliding window paradigm from the computer vision literature where a classifier, trained to detect an object in a tightly cropped bounding box, is applied independently to thousands of candidate windows from the test image at different positions and scales. Although some computations can be shared, the main computational expense for these models comes from convolving filter maps with the entire input image, therefore their computational complexity is at least linear in the number of pixels.</p><p>One important property of human perception is that one does not tend to process a whole scene in its entirety at once. Instead humans focus attention selectively on parts of the visual space to acquire information when and where it is needed, and combine information from different fixations over time to build up an internal representation of the scene <ref type="bibr" target="#b17">[18]</ref>, guiding future eye movements and decision making. Focusing the computational resources on parts of a scene saves "bandwidth" as fewer "pixels" need to be processed. But it also substantially reduces the task complexity as the object of interest can be placed in the center of the fixation and irrelevant features of the visual environment ("clutter") outside the fixated region are naturally ignored.</p><p>In line with its fundamental role, the guidance of human eye movements has been extensively studied in neuroscience and cognitive science literature. While low-level scene properties and bottom up processes (e.g. in the form of saliency; <ref type="bibr" target="#b10">[11]</ref>) play an important role, the locations on which humans fixate have also been shown to be strongly task specific (see <ref type="bibr" target="#b8">[9]</ref> for a review and also e.g. <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b21">22]</ref>). In this paper we take inspiration from these results and develop a novel framework for attention-based task-driven visual processing with neural networks. Our model considers attention-based processing of a visual scene as a control problem and is general enough to be applied to static images, videos, or as a perceptual module of an agent that interacts with a dynamic visual environment (e.g. robots, computer game playing agents).</p><p>The model is a recurrent neural network (RNN) which processes inputs sequentially, attending to different locations within the images (or video frames) one at a time, and incrementally combines information from these fixations to build up a dynamic internal representation of the scene or environment. Instead of processing an entire image or even bounding box at once, at each step, the model selects the next location to attend to based on past information and the demands of the task. Both the number of parameters in our model and the amount of computation it performs can be controlled independently of the size of the input image, which is in contrast to convolutional networks whose computational demands scale linearly with the number of image pixels. We describe an end-to-end optimization procedure that allows the model to be trained directly with respect to a given task and to maximize a performance measure which may depend on the entire sequence of decisions made by the model. This procedure uses backpropagation to train the neural-network components and policy gradient to address the non-differentiabilities due to the control problem.</p><p>We show that our model can learn effective task-specific strategies for where to look on several image classification tasks as well as a dynamic visual control problem. Our results also suggest that an attention-based model may be better than a convolutional neural network at both dealing with clutter and scaling up to large input images.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Previous Work</head><p>Computational limitations have received much attention in the computer vision literature. For instance, for object detection, much work has been dedicated to reducing the cost of the widespread sliding window paradigm, focusing primarily on reducing the number of windows for which the full classifier is evaluated, e.g. via classifier cascades (e.g. <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b23">24]</ref>), removing image regions from consideration via a branch and bound approach on the classifier output (e.g. <ref type="bibr" target="#b12">[13]</ref>), or by proposing candidate windows that are likely to contain objects (e.g. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b22">23]</ref>). Even though substantial speedups may be obtained with such approaches, and some of these can be combined with or used as an add-on to CNN classifiers <ref type="bibr" target="#b7">[8]</ref>, they remain firmly rooted in the window classifier design for object detection and only exploit past information to inform future processing of the image in a very limited way.</p><p>A second class of approaches that has a long history in computer vision and is strongly motivated by human perception are saliency detectors (e.g. <ref type="bibr" target="#b10">[11]</ref>). These approaches prioritize the processing of potentially interesting ("salient") image regions which are typically identified based on some measure of local low-level feature contrast. Saliency detectors indeed capture some of the properties of human eye movements, but they typically do not to integrate information across fixations, their saliency computations are mostly hardwired, and they are based on low-level image properties only, usually ignoring other factors such as semantic content of a scene and task demands (but see <ref type="bibr" target="#b21">[22]</ref>). Some works in the computer vision literature and elsewhere e.g. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b19">20]</ref> have embraced vision as a sequential decision task as we do here. There, as in our work, information about the image is gathered sequentially and the decision where to attend next is based on previous fixations of the image. <ref type="bibr" target="#b3">[4]</ref> employs the learned Bayesian observer model from <ref type="bibr" target="#b4">[5]</ref> to the task of object detection. The learning framework of <ref type="bibr" target="#b4">[5]</ref> is related to ours as they also employ a policy gradient formulation (cf. section 3) but their overall setup is considerably more restrictive than ours and only some parts of the system are learned.</p><p>Our work is perhaps the most similar to the other attempts to implement attentional processing in a deep learning framework <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b16">17]</ref>. Our formulation which employs an RNN to integrate visual information over time and to decide how to act is, however, more general, and our learning procedure allows for end-to-end optimization of the sequential decision process instead of relying on greedy action selection. We further demonstrate how the same general architecture can be used for efficient object recognition in still images as well as to interact with a dynamic visual environment in a task-driven way. x t ρ(x t , l t-1 )</p><formula xml:id="formula_0">θ g 0 θ g 1 θ g 2 Glimpse Network : f g ( θ g ) l t-1 g t l t a t l t g t+1 l t+1 a t+1 h t h t+1 f g (θ g ) h t-1 f l (θ l ) f a (θ a ) f h (θ h ) f g (θ g ) f l (θ l ) f a (θ a ) f h (θ h ) x t ρ(x t , l t-1 ) l t-1 Glimpse Sensor A) B) C)</formula><p>Figure <ref type="figure">1</ref>: A) Glimpse Sensor: Given the coordinates of the glimpse and an input image, the sensor extracts a retina-like representation ρ(x t , l t-1 ) centered at l t-1 that contains multiple resolution patches. B) Glimpse Network: Given the location (l t-1 ) and input image (x t ), uses the glimpse sensor to extract retina representation ρ(x t , l t-1 ). The retina representation and glimpse location is then mapped into a hidden space using independent linear layers parameterized by θ 0 g and θ 1 g respectively using rectified units followed by another linear layer θ 2 g to combine the information from both components. The glimpse network f g (.; {θ 0 g , θ 1 g , θ 2 g }) defines a trainable bandwidth limited sensor for the attention network producing the glimpse representation g t . C) Model Architecture: Overall, the model is an RNN. The core network of the model f h (.; θ h ) takes the glimpse representation g t as input and combining with the internal representation at previous time step h t-1 , produces the new internal state of the model h t . The location network f l (.; θ l ) and the action network f a (.; θ a ) use the internal state h t of the model to produce the next location to attend to l t and the action/classification a t respectively. This basic RNN iteration is repeated for a variable number of steps. information only in a local region or in a narrow frequency band. The agent can, however, actively control how to deploy its sensor resources (e.g. choose the sensor location). The agent can also affect the true state of the environment by executing actions. Since the environment is only partially observed the agent needs to integrate information over time in order to determine how to act and how to deploy its sensor most effectively. At each step, the agent receives a scalar reward (which depends on the actions the agent has executed and can be delayed), and the goal of the agent is to maximize the total sum of such rewards. This formulation encompasses tasks as diverse as object detection in static images and control problems like playing a computer game from the image stream visible on the screen. For a game, the environment state would be the true state of the game engine and the agent's sensor would operate on the video frame shown on the screen. (Note that for most games, a single frame would not fully specify the game state). The environment actions here would correspond to joystick controls, and the reward would reflect points scored. For object detection in static images the state of the environment would be fixed and correspond to the true contents of the image. The environmental action would correspond to the classification decision (which may be executed only after a fixed number of fixations), and the reward would reflect if the decision is correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Model</head><p>The agent is built around a recurrent neural network as shown in Fig. <ref type="figure">1</ref>. At each time step, it processes the sensor data, integrates information over time, and chooses how to act and how to deploy its sensor at next time step:</p><p>Sensor: At each step t the agent receives a (partial) observation of the environment in the form of an image x t . The agent does not have full access to this image but rather can extract information from x t via its bandwidth limited sensor ρ, e.g. by focusing the sensor on some region or frequency band of interest.</p><p>In this paper we assume that the bandwidth-limited sensor extracts a retina-like representation ρ(x t , l t-1 ) around location l t-1 from image x t . It encodes the region around l at a high-resolution but uses a progressively lower resolution for pixels further from l, resulting in a vector of much lower dimensionality than the original image x. We will refer to this low-resolution representation as a glimpse <ref type="bibr" target="#b13">[14]</ref>. The glimpse sensor is used inside what we call the glimpse network f g to produce the glimpse feature vector g t = f g (x t , l t-1 ; θ g ) where θ g = {θ 0 g , θ<ref type="foot" target="#foot_1">1</ref> g , θ 2 g } (Fig. <ref type="figure">1B</ref>). Internal state: The agent maintains an interal state which summarizes information extracted from the history of past observations; it encodes the agent's knowledge of the environment and is instrumental to deciding how to act and where to deploy the sensor. This internal state is formed by the hidden units h t of the recurrent neural network and updated over time by the core network:</p><formula xml:id="formula_1">h t = f h (h t-1 , g t ; θ h ).</formula><p>The external input to the network is the glimpse feature vector g t .</p><p>Actions: At each step, the agent performs two actions: it decides how to deploy its sensor via the sensor control l t , and an environment action a t which might affect the state of the environment. The nature of the environment action depends on the task. In this work, the location actions are chosen stochastically from a distribution parameterized by the location network f l (h t ; θ l ) at time t: l t ∼ p(•|f l (h t ; θ l )). The environment action a t is similarly drawn from a distribution conditioned on a second network output a t ∼ p(•|f a (h t ; θ a )). For classification it is formulated using a softmax output and for dynamic environments, its exact formulation depends on the action set defined for that particular environment (e.g. joystick movements, motor control, ...). Finally, our model can also be augmented with an additional action that decides when it will stop taking glimpses. This could, for example, be used to learn a cost-sensitive classifier by giving the agent a negative reward for each glimpse it takes, forcing it to trade off making correct classifications with the cost of taking more glimpses.</p><p>Reward: After executing an action the agent receives a new visual observation of the environment x t+1 and a reward signal r t+1 . The goal of the agent is to maximize the sum of the reward signal 1  which is usually very sparse and delayed: R = T t=1 r t . In the case of object recognition, for example, r T = 1 if the object is classified correctly after T steps and 0 otherwise.</p><p>The above setup is a special instance of what is known in the RL community as a Partially Observable Markov Decision Process (POMDP). The true state of the environment (which can be static or dynamic) is unobserved. In this view, the agent needs to learn a (stochastic) policy π((l t , a t )|s 1:t ; θ) with parameters θ that, at each step t, maps the history of past interactions with the environment s 1:t = x 1 , l 1 , a 1 , . . . x t-1 , l t-1 , a t-1 , x t to a distribution over actions for the current time step, subject to the constraint of the sensor. In our case, the policy π is defined by the RNN outlined above, and the history s t is summarized in the state of the hidden units h t . We will describe the specific choices for the above components in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Training</head><p>The parameters of our agent are given by the parameters of the glimpse network, the core network (Fig. <ref type="figure">1C</ref>), and the action network θ = {θ g , θ h , θ a } and we learn these to maximize the total reward the agent can expect when interacting with the environment.</p><p>More formally, the policy of the agent, possibly in combination with the dynamics of the environment (e.g. for game-playing), induces a distribution over possible interaction sequences s 1:N and we aim to maximize the reward under this distribution:</p><formula xml:id="formula_2">J(θ) = E p(s 1:T ;θ) T t=1 r t = E p(s 1:T ;θ) [R],</formula><p>where p(s 1:T ; θ) depends on the policy Maximizing J exactly is non-trivial since it involves an expectation over the high-dimensional interaction sequences which may in turn involve unknown environment dynamics. Viewing the problem as a POMDP, however, allows us to bring techniques from the RL literature to bear: As shown by Williams <ref type="bibr" target="#b25">[26]</ref> a sample approximation to the gradient is given by</p><formula xml:id="formula_3">∇ θ J = T t=1 E p(s 1:T ;θ) [∇ θ log π(u t |s 1:t ; θ)R] ≈ 1 M M i=1 T t=1 ∇ θ log π(u i t |s i 1:t ; θ)R i ,<label>(1)</label></formula><p>where s i 's are interaction sequences obtained by running the current agent π θ for i = 1 . . . M episodes.</p><p>The learning rule (1) is also known as the REINFORCE rule, and it involves running the agent with its current policy to obtain samples of interaction sequences s 1:T and then adjusting the parameters θ of our agent such that the log-probability of chosen actions that have led to high cumulative reward is increased, while that of actions having produced low reward is decreased.</p><p>Eq. ( <ref type="formula" target="#formula_3">1</ref>) requires us to compute ∇ θ log π(u i t |s i 1:t ; θ). But this is just the gradient of the RNN that defines our agent evaluated at time step t and can be computed by standard backpropagation <ref type="bibr" target="#b24">[25]</ref>.</p><p>Variance Reduction : Equation (1) provides us with an unbiased estimate of the gradient but it may have high variance. It is therefore common to consider a gradient estimate of the form</p><formula xml:id="formula_4">1 M M i=1 T t=1 ∇ θ log π(u i t |s i 1:t ; θ) R i t -b t ,<label>(2)</label></formula><p>where R i t = T t =1 r i t is the cumulative reward obtained following the execution of action u i t , and b t is a baseline that may depend on s i 1:t (e.g. via h i t ) but not on the action u i t itself. This estimate is equal to (1) in expectation but may have lower variance.</p><formula xml:id="formula_5">It is natural to select b t = E π [R t ] [21],</formula><p>and this form of baseline known as the value function in the reinforcement learning literature. The resulting algorithm increases the log-probability of an action that was followed by a larger than expected cumulative reward, and decreases the probability if the obtained cumulative reward was smaller. We use this type of baseline and learn it by reducing the squared error between R i t 's and b t . Using a Hybrid Supervised Loss: The algorithm described above allows us to train the agent when the "best" actions are unknown, and the learning signal is only provided via the reward. For instance, we may not know a priori which sequence of fixations provides most information about an unknown image, but the total reward at the end of an episode will give us an indication whether the tried sequence was good or bad.</p><p>However, in some situations we do know the correct action to take: For instance, in an object detection task the agent has to output the label of the object as the final action. For the training images this label will be known and we can directly optimize the policy to output the correct label associated with a training image at the end of an observation sequence. This can be achieved, as is common in supervised learning, by maximizing the conditional probability of the true label given the observations from the image, i.e. by maximizing log π(a * T |s 1:T ; θ), where a * T corresponds to the ground-truth label(-action) associated with the image from which observations s 1:T were obtained. We follow this approach for classification problems where we optimize the cross entropy loss to train the action network f a and backpropagate the gradients through the core and glimpse networks. The location network f l is always trained with REINFORCE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>We evaluated our approach on several image classification tasks as well as a simple game. We first describe the design choices that were common to all our experiments:</p><p>Retina and location encodings: The retina encoding ρ(x, l) extracts k square patches centered at location l, with the first patch being g w × g w pixels in size, and each successive patch having twice the width of the previous. The k patches are then all resized to g w × g w and concatenated. Glimpse locations l were encoded as real-valued (x, y) coordinates<ref type="foot" target="#foot_2">2</ref> with (0, 0) being the center of the image x and (-1, -1) being the top left corner of x.</p><p>Glimpse network: The glimpse network f g (x, l) had two fully connected layers. Let Linear(x) denote a linear transformation of the vector x, i.e. Linear(x) = W x+b for some weight matrix W and bias vector b, and let Rect(x) = max(x, 0) be the rectifier nonlinearity. The output g of the glimpse network was defined as g = Rect(Linear(h g ) + Linear(h l )) where h g = Rect(Linear(ρ(x, l))) and h l = Rect(Linear(l)). The dimensionality of h g and h l was 128 while the dimensionality of g was 256 for all attention models trained in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Location network:</head><p>The policy for the locations l was defined by a two-component Gaussian with a fixed variance. The location network outputs the mean of the location policy at time t and is defined as f l (h) = Linear(h) where h is the state of the core network/RNN.   <ref type="table">1</ref>: Classification results on the MNIST and Translated MNIST datasets. FC denotes a fullyconnected network with two layers of rectifier units. The convolutional network had one layer of 8 10 × 10 filters with stride 5, followed by a fully connected layer with 256 units with rectifiers after each layer. Instances of the attention model are labeled with the number of glimpses, the number of scales in the retina, and the size of the retina.  Core network: For the classification experiments that follow the core f h was a network of rectifier units defined as h t = f h (h t-1 ) = Rect(Linear(h t-1 ) + Linear(g t )). The experiment done on a dynamic environment used a core of LSTM units <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Image Classification</head><p>The attention network used in the following classification experiments made a classification decision only at the last timestep t = N . The action network f a was simply a linear softmax classifier defined as f a (h) = exp (Linear(h)) /Z, where Z is a normalizing constant. The RNN state vector h had dimensionality 256. All methods were trained using stochastic gradient descent with minibatches of size 20 and momentum of 0.9. We annealed the learning rate linearly from its initial value to 0 over the course of training. Hyperparameters such as the initial learning rate and the variance of the location policy were selected using random search <ref type="bibr" target="#b2">[3]</ref>. The reward at the last time step was 1 if the agent classified correctly and 0 otherwise. The rewards for all other timesteps were 0.</p><p>Centered Digits: We first tested the ability of our training method to learn successful glimpse policies by using it to train RAM models with up to 7 glimpses on the MNIST digits dataset. The "retina" for this experiment was simply an 8 × 8 patch, which is only big enough to capture a part of a digit, hence the experiment also tested the ability of RAM to combine information from multiple glimpses. We also trained standard feedforward and convolutional neural networks with two hidden layers as a baselines. The error rates achieved by the different models on the test set are shown in Table <ref type="table">1a</ref>. We see that the performance of RAM generally improves with more glimpses, and that it eventually outperforms a the baseline models trained on the full 28 × 28 centered digits. This demonstrates the model can successfully learn to combine information from multiple glimpses.</p><p>Non-Centered Digits: The second problem we considered was classifying non-centered digits. We created a new task called Translated MNIST, for which data was generated by placing an MNIST digit in a random location of a larger blank patch. Training cases were generated on the fly so the effective training set size was 50000 (the size of the MNIST training set) multiplied by the possible number of locations. Figure <ref type="figure" target="#fig_3">2a</ref> contains a random sample of test cases for the 60 by 60 Translated MNIST task. Table <ref type="table">1b</ref> shows the results for several different models trained on the Translated MNIST task with 60 by 60 patches. In addition to RAM and two fully-connected networks we also trained a network with one convolutional layer of 16 10 × 10 filters with stride 5 followed by a rectifier nonlinearity and then a fully-connected layer of 256 rectifier units. The convolutional network, the RAM networks, and the smaller fully connected model all had roughly the same number of parameters. Since the convolutional network has some degree of translation invariance built in, it Table <ref type="table">2</ref>: Classification on the Cluttered Translated MNIST dataset. FC denotes a fully-connected network with two layers of rectifier units. The convolutional network had one layer of 8 10 × 10 filters with stride 5, followed by a fully connected layer with 256 units in the 60 × 60 case and 86 units in the 100 × 100 case with rectifiers after each layer. Instances of the attention model are labeled with the number of glimpses, the size of the retina, and the number of scales in the retina.</p><p>All models except for big fully connected network had roughly the same number of parameters. attains a significantly lower error rate of 1.62% than the fully connected networks. However, RAM with 4 glimpses gets slightly better performance than the convolutional network and outperforms it further for 6 and 8 glimpses, reaching 1.2% error. This is possible because the attention model can focus its retina on the digit and hence learn a translation invariant policy. This experiment also shows that the attention model is able to successfully search for an object in a big image when the object is not centered.</p><p>Cluttered Non-Centered Digits: One of the most challenging aspects of classifying real-world images is the presence of a wide range clutter. Systems that operate on the entire image at full resolution are particularly susceptible to clutter and must learn to be invariant to it. One possible advantage of an attention mechanism is that it may make it easier to learn in the presence of clutter by focusing on the relevant part of the image and ignoring the irrelevant part. We test this hypothesis with several experiments on a new task we call Cluttered Translated MNIST. Data for this task was generated by first placing an MNIST digit in a random location of a larger blank image and then adding random 8 by 8 subpatches from other random MNIST digits to random locations of the image. The goal is to classify the complete digit present in the image. Figure <ref type="figure" target="#fig_3">2b</ref> shows a random sample of test cases for the 60 by 60 Cluttered Translated MNIST task.</p><p>Table <ref type="table">2a</ref> shows the classification results for the models we trained on 60 by 60 Cluttered Translated MNIST with 4 pieces of clutter. The presence of clutter makes the task much more difficult but the performance of the attention model is affected less than the performance of the other models. RAM with 4 glimpses reaches 4.96% error, which outperforms fully-connected models by a wide margin and the convolutional neural network by over 3%, and RAM trained with 6 and 8 glimpses achieves even lower error. Since RAM achieves larger relative error improvements over a convolutional network in the presence of clutter these results suggest the attention-based models may be better at dealing with clutter than convolutional networks because they can simply ignore it by not looking at it. Two samples of learned policy is shown in Figure <ref type="figure" target="#fig_4">3</ref> and more are included in the supplementary materials. The first column shows the original data point with the glimpse path overlaid. The location of the first glimpse is marked with a filled circle and the location of the final glimpse is marked with an empty circle. The intermediate points on the path are traced with solid straight lines. Each consecutive image to the right shows a representation of the glimpse that the network sees. It can be seen that the learned policy can reliably find and explore around the object of interest while avoiding clutter at the same time. Finally, Table <ref type="table">2a</ref> also includes results for an 8-glimpse RAM model that selects glimpse locations uniformly at random. RAM models that learn the glimpse policy achieve much lower error rates even with half as many glimpses.</p><p>To further test this hypothesis we also performed experiments on 100 by 100 Cluttered Translated MNIST with 8 pieces of clutter. The test errors achieved by the models we compared are shown in Table <ref type="table">2b</ref>. The results show similar improvements of RAM over a convolutional network. It has to be noted that the overall capacity and the amount of computation of our model does not change from 60 × 60 images to 100 × 100, whereas the hidden layer of the convolutional network that is connected to the linear layer grows linearly with the number of pixels in the input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Dynamic Environments</head><p>One appealing property of the recurrent attention model is that it can be applied to videos or interactive problems with a visual input just as easily as to static image tasks. We test the ability of our approach to learn a control policy in a dynamic visual environment while perceiving the environment through a bandwidth-limited retina by training it to play a simple game. The game is played on a 24 by 24 screen of binary pixels and involves two objects: a single pixel that represents a ball falling from the top of the screen while bouncing off the sides of the screen and a two-pixel paddle positioned at the bottom of the screen which the agent controls with the aim of catching the ball. When the falling pixel reaches the bottom of the screen the agent either gets a reward of 1 if the paddle overlaps with the ball and a reward of 0 otherwise. The game then restarts from the beginning.</p><p>We trained the recurrent attention model to play the game of "Catch" using only the final reward as input. The network had a 6 by 6 retina at three scales as its input, which means that the agent had to capture the ball in the 6 by 6 highest resolution region in order to know its precise position.</p><p>In addition to the two location actions, the attention model had three game actions (left, right, and do nothing) and the action network f a used a linear softmax to model a distribution over the game actions. We used a core network of 256 LSTM units.</p><p>We performed random search to find suitable hyper-parameters and trained each agent for 20 million frames. A video of the best agent, which catches the ball roughly 85% of the time, can be downloaded from http://www.cs.toronto.edu/ ˜vmnih/docs/attention.mov.</p><p>The video shows that the recurrent attention model learned to play the game by tracking the ball near the bottom of the screen. Since the agent was not in any way told to track the ball and was only rewarded for catching it, this result demonstrates the ability of the model to learn effective task-specific attention policies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>This paper introduced a novel visual attention model that is formulated as a single recurrent neural network which takes a glimpse window as its input and uses the internal state of the network to select the next location to focus on as well as to generate control signals in a dynamic environment. Although the model is not differentiable, the proposed unified architecture is trained end-to-end from pixel inputs to actions using a policy gradient method. The model has several appealing properties. First, both the number of parameters and the amount of computation RAM performs can be controlled independently of the size of the input images. Second, the model is able to ignore clutter present in an image by centering its retina on the relevant regions. Our experiments show that RAM significantly outperforms a convolutional architecture with a comparable number of parameters on a cluttered object classification task. Additionally, the flexibility of our approach allows for a number of interesting extensions. For example, the network can be augmented with another action that allows it terminate at any time point and make a final classification decision. Our preliminary experiments show that this allows the network to learn to stop taking glimpses once it has enough information to make a confident classification. The network can also be allowed to control the scale at which the retina samples the image allowing it to fit objects of different size in the fixed size retina.</p><p>In both cases, the extra actions can be simply added to the action network f a and trained using the policy gradient procedure we have described. Given the encouraging results achieved by RAM, applying the model to large scale object recognition and video classification is a natural direction for future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(a) Translated MNIST inputs. (b) Cluttered Translated MNIST inputs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Examples of test cases for the Translated and Cluttered Translated MNIST tasks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Examples of the learned policy on 60 × 60 cluttered-translated MNIST task. Column 1: The input image with glimpse path overlaid in green. Columns 2-7: The six glimpses the network chooses. The center of each image shows the full resolution glimpse, the outer low resolution areas are obtained by upscaling the low resolution glimpses back to full image size. The glimpse paths clearly show that the learned policy avoids computation in empty or noisy parts of the input space and directly explores the area around the object of interest.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>× 8, 1 scale 3.79% RAM, 3 glimpses, 8 × 8, 1 scale 1.51% RAM, 4 glimpses, 8 × 8, 1 scale 1.54% RAM, 5 glimpses, 8 × 8, 1 scale 1.34% RAM, 6 glimpses, 8 × 8, 1 scale 1.12% RAM, 7 glimpses, 8 × 8, 1 scale 1.07% 12 × 12, 3 scales 1.54% RAM, 6 glimpses, 12 × 12, 3 scales 1.22% RAM, 8 glimpses, 12 × 12, 3 scales 1.2%</figDesc><table><row><cell>a) 28x28 MNIST FC, 2 layers (256 hiddens each) Model Convolutional, 2 layers RAM, 2 glimpses, 8 (b) 60x60 Translated MNIST Error 1.69% 1.21% Model FC, 2 layers (64 hiddens each) FC, 2 layers (256 hiddens each) Convolutional, 2 layers</cell><cell>Error 6.42% 2.63% 1.62%</cell></row><row><cell>RAM, 4 glimpses, Table</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>glimpses, 12 × 12, 4 scales 9.41% RAM, 6 glimpses, 12 × 12, 4 scales 8.31% RAM, 8 glimpses, 12 × 12, 4 scales 8.11% RAM, 8 random glimpses 28.4%</figDesc><table><row><cell cols="2">a) 60x60 Cluttered Translated MNIST Model Error FC, 2 layers (64 hiddens each) 28.58% FC, 2 layers (256 hiddens each) 11.96% Convolutional, 2 layers 8.09%</cell><cell>(b) 100x100 Cluttered Translated MNIST Model Error Convolutional, 2 layers 14.35% RAM, 4</cell></row><row><cell cols="2">RAM, 4 glimpses, 12 × 12, 3 scales 4.96%</cell></row><row><cell cols="2">RAM, 6 glimpses, 12 × 12, 3 scales 4.08%</cell></row><row><cell cols="2">RAM, 8 glimpses, 12 × 12, 3 scales 4.04%</cell></row><row><cell>RAM, 8 random glimpses</cell><cell>14.4%</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>The Recurrent Attention Model (RAM)In this paper we consider the attention problem as the sequential decision process of a goal-directed agent interacting with a visual environment. At each point in time, the agent observes the environment only via a bandwidth-limited sensor, i.e. it never senses the environment in full. It may extract</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>Depending on the scenario it may be more appropriate to consider a sum of discounted rewards, where rewards obtained in the distant future contribute less: R = T t=1 γ t-1 rt. In this case we can have T → ∞.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>We also experimented with using a discrete representation for the locations l but found that it was difficult to learn policies over more than 25 possible discrete locations.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">What is an object?</title>
		<author>
			<persName><forename type="first">Bogdan</forename><surname>Alexe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Deselaers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vittorio</forename><surname>Ferrari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Searching for objects driven by context</title>
		<author>
			<persName><forename type="first">Bogdan</forename><surname>Alexe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Heess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yee</forename><forename type="middle">Whye</forename><surname>Teh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vittorio</forename><surname>Ferrari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Random search for hyper-parameter optimization</title>
		<author>
			<persName><forename type="first">James</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="281" to="305" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Optimal scanning for faster object detection</title>
		<author>
			<persName><forename type="first">Nicholas</forename><forename type="middle">J</forename><surname>Butko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><forename type="middle">R</forename><surname>Movellan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">I-pomdp: An infomax model of eye movement</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J</forename><surname>Butko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Movellan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th IEEE International Conference on Development and Learning, ICDL &apos;08</title>
		<meeting>the 7th IEEE International Conference on Development and Learning, ICDL &apos;08</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="139" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Learning where to attend with deep architectures for image tracking</title>
		<author>
			<persName><forename type="first">Misha</forename><surname>Denil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Loris</forename><surname>Bazzani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugo</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nando</forename><surname>De Freitas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Computation</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="2151" to="2184" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Cascade object detection with deformable part models</title>
		<author>
			<persName><forename type="first">Pedro</forename><forename type="middle">F</forename><surname>Felzenszwalb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ross</forename><forename type="middle">B</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Mcallester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Rich feature hierarchies for accurate object detection and semantic segmentation</title>
		<author>
			<persName><forename type="first">Ross</forename><forename type="middle">B</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Darrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jitendra</forename><surname>Malik</surname></persName>
		</author>
		<idno>CoRR, abs/1311.2524</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Eye movements in natural behavior</title>
		<author>
			<persName><forename type="first">Mary</forename><surname>Hayhoe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dana</forename><surname>Ballard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trends in Cognitive Sciences</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="188" to="194" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Long short-term memory</title>
		<author>
			<persName><forename type="first">Sepp</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jürgen</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1735" to="1780" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A model of saliency-based visual attention for rapid scene analysis</title>
		<author>
			<persName><forename type="first">L</forename><surname>Itti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Niebur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1254" to="1259" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Imagenet classification with deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoff</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1106" to="1114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Beyond sliding windows: Object localization by efficient subwindow search</title>
		<author>
			<persName><forename type="first">Christoph</forename><forename type="middle">H</forename><surname>Lampert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">B</forename><surname>Blaschko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Hofmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Learning to combine foveal glimpses with a third-order boltzmann machine</title>
		<author>
			<persName><forename type="first">Hugo</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Action from still image dataset and inverse optimal control to learn task specific visual scanpaths</title>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Mathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Sminchisescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Q-learning of sequential attention for visual object recognition from informative local descriptors</title>
		<author>
			<persName><forename type="first">Lucas</forename><surname>Paletta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christin</forename><surname>Seifert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On Learning Where To Look</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ranzato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ArXiv e-prints</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The dynamic representation of scenes</title>
		<author>
			<persName><forename type="first">Ronald</forename><forename type="middle">A</forename><surname>Rensink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Visual Cognition</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="17" to="42" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Overfeat: Integrated recognition, localization and detection using convolutional networks</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Sermanet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Eigen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiang</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Mathieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Fergus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yann</forename><surname>Lecun</surname></persName>
		</author>
		<idno>CoRR, abs/1312.6229</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Evolving a roving eye for go</title>
		<author>
			<persName><forename type="first">Kenneth</forename><forename type="middle">O</forename><surname>Stanley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Risto</forename><surname>Miikkulainen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Policy gradient methods for reinforcement learning with function approximation</title>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">S</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mcallester</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Satinder</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yishay</forename><surname>Mansour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="1057" to="1063" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Contextual guidance of eye movements and attention in real-world scenes: the role of global features in object search</title>
		<author>
			<persName><forename type="first">Antonio</forename><surname>Torralba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aude</forename><surname>Oliva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Monica</forename><forename type="middle">S</forename><surname>Castelhano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">M</forename><surname>Henderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Psychol Rev</title>
		<imprint>
			<biblScope unit="page" from="766" to="786" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Segmentation as Selective Search for Object Recognition</title>
		<author>
			<persName><forename type="first">K E A</forename><surname>Van De Sande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R R</forename><surname>Uijlings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W M</forename><surname>Gevers</surname></persName>
		</author>
		<author>
			<persName><surname>Smeulders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Rapid object detection using a boosted cascade of simple features</title>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">A</forename><surname>Viola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Solving deep memory pomdps with recurrent policy gradients</title>
		<author>
			<persName><forename type="first">Daan</forename><surname>Wierstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Foerster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Peters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juergen</forename><surname>Schmidhuber</surname></persName>
		</author>
		<idno>ICANN. 2007</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Simple statistical gradient-following algorithms for connectionist reinforcement learning</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="229" to="256" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
