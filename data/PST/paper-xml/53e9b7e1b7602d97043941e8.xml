<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Symbolic execution of floating-point computations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2005-10-06">6 October 2005</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Bernard</forename><surname>Botella</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Thales Aerospace</orgName>
								<address>
									<addrLine>2, avenue Gay-Lussac</addrLine>
									<postCode>F-78851</postCode>
									<settlement>Elancourt Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Arnaud</forename><surname>Gotlieb</surname></persName>
							<email>arnaud.gotlieb@irisa.fr</email>
							<affiliation key="aff1">
								<orgName type="institution">IRISA/INRIA</orgName>
								<address>
									<addrLine>Campus Universitaire de Beaulieu</addrLine>
									<postCode>F-35042</postCode>
									<settlement>Rennes Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Claude</forename><surname>Michel</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">CNRS</orgName>
								<address>
									<addrLine>930 route des Colles, BP 154</addrLine>
									<postCode>I3S-, F-06903</postCode>
									<settlement>Sophia Antipolis Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">IRISA/INRIA</orgName>
								<address>
									<addrLine>Campus Universitaire de Beaulieu</addrLine>
									<postCode>F-35042</postCode>
									<settlement>Rennes Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Symbolic execution of floating-point computations</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2005-10-06">6 October 2005</date>
						</imprint>
					</monogr>
					<idno type="MD5">CB68C27737E57276D09ACD099BAD6478</idno>
					<idno type="DOI">10.1002/stvr.333</idno>
					<note type="submission">Received 4 October 2004 Accepted 22 June 2005</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>symbolic execution</term>
					<term>floating-point computations</term>
					<term>automatic test data generation</term>
					<term>constraint solving</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Symbolic execution is a classical program testing technique which evaluates a selected control flow path with symbolic input data. A constraint solver can be used to enforce the satisfiability of the extracted path conditions as well as to derive test data. Whenever path conditions contain floating-point computations, a common strategy consists of using a constraint solver over the rationals or the reals. Unfortunately, even in a fully IEEE-754-compliant environment, this leads not only to approximations but also can compromise correctness: a path can be labelled as infeasible although there exists floating-point input data that satisfy it. In this paper, the peculiarities of symbolic execution of programs with floating-point numbers are addressed. Issues in the symbolic execution of this kind of program are carefully examined and a constraint solver is described that supports constraints over floating-point numbers. Preliminary experimental results demonstrate the value of the approach proposed.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Structural testing is usually required to find a test set that activates control flow paths that cover a selected testing criterion (e.g. 'all statements', 'all branches', . . . ). Introduced by King in the context of software testing <ref type="bibr" target="#b0">[1]</ref>, symbolic execution consists of statically evaluating statements of a program to find a test datum that activates a given control flow path. Input variables are replaced by symbolic input data and each statement of the path is evaluated by replacing internal references with an expression over the symbolic input data. Symbolic execution computes so-called path conditions that are constraints on the symbolic input data that characterize the selected path. Solving the path conditions permits input data to be obtained that activate the path. As only input values are generated, float foo1(float x) { float y = 1.0e12, z ; 1. if (x &gt; 0.0) 2.</p><p>z = x + y ; 3. if (z == y) 4.</p><p>. . . such an approach relies on the availability of an oracle. An oracle is just a procedure that checks the computed outcomes and produces a testing verdict. Symbolic execution can be used to address the path feasibility problem <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>. When the constraint set equivalent to the path conditions is unsatisfiable, then the selected path is shown to be infeasible. Note, however, that finding all the infeasible paths of a program is a classical undecidable problem <ref type="bibr" target="#b3">[4]</ref>. Symbolic execution has been used in numerous applications, such as automatic structural test data generation <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref>, mutation-based testing <ref type="bibr" target="#b11">[12]</ref>, program specialization <ref type="bibr" target="#b12">[13]</ref>, parallelizing compilers <ref type="bibr" target="#b13">[14]</ref>, program and property proving <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>, just to name a few.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Issues in floating-point computations</head><p>It is well known that reasoning over the reals or the rationals leads to some inconsistencies when the results are directly mapped over to the floating-point numbers <ref type="bibr" target="#b16">[17]</ref>. In such a case, even in an environment which complies with the IEEE-754 standard for binary floating-point arithmetic <ref type="bibr" target="#b17">[18]</ref>, the symbolic execution of a program path which involves floating-point variables can produce not only inexact results but also incorrect ones. For example, consider the C program given in Figure <ref type="figure" target="#fig_0">1</ref> and the symbolic execution of path 1 → 2 → 3 → 4. The associated path conditions can be written as {x &gt; 0.0, x + 1.0e12 = 1.0e12}. It is trivial to verify that these constraints do not have any solution over the reals or the rationals and a solver over the reals like the IC library of the Eclipse Prolog system <ref type="bibr" target="#b18">[19]</ref> will immediately detect this. However, any IEEE-754 single-format floating-point numbers of the closed interval <ref type="bibr">[1.</ref>401 298 464 324 817e-45, 32 767.999 023 4] is a solution of these path conditions. Hence, a symbolic execution tool working over the reals or the rationals will declare this path as being infeasible although this is clearly incorrect. Conversely, consider the path conditions {x &lt; 10 000.0, x + 1.0e12 &gt; 1.0e12} which could easily be extracted by the symbolic execution of path 1 → 2 → 3 → 4 of program foo2 of Figure <ref type="figure" target="#fig_1">2</ref>. All the reals of the open interval (0, 10 000) are solutions of these path conditions. However, there is no single floating-point value able to activate the path 1 → 2 → 3 → 4. Indeed, for any single floating-point number x f in (0, 10 000), it is the case that x f + 1.0e12 = 1.0e12 ‡ . Hence the path 1 → 2 → 3 → 4 is actually infeasible although a symbolic execution tool over the reals or the rationals would have declared it as feasible.</p><p>float foo2(float x) { float y = 1.0e12, z ; 1. if (x &lt; 10000.0) 2.</p><p>z = x + y ; 3. if (z &gt; y) 4.</p><p>. . . This kind of behaviour can be obtained with any of the available solvers over the reals or the rationals. These solvers use a linear programming algorithm as in the clpr or in the clpq framework, or interval propagation with floating-point numbers to bound the reals such as in Ilog Solver, Eclipse IC <ref type="bibr" target="#b18">[19]</ref>, RealPaver <ref type="bibr" target="#b19">[20]</ref> or Interlog <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref>. The key issue here is that these solvers obey mathematical rules which do not hold for floating-point arithmetic. As a matter of fact, floating-point arithmetic is quite poor. For example, with floating-point numbers, x + (y + z) is not in general equal to (x + y) + z. Moreover, interval propagation based solvers assume that if z = x + y then x = zy. Unfortunately, due to rounding operations, this does not hold for floating-point arithmetic.</p><p>Such problems might be seen as unavoidable. By contrast, this paper introduces techniques required to handle these kinds of issues correctly. The approach is based on the following two steps.</p><p>• In a first step, complex expressions over the floating-point numbers are translated into equivalent relations which capture all the semantics of the floating-point operations; these relations are binary or ternary constraints over the floating-point numbers. • In a second step, a solver dedicated to floating-point numbers is used to solve the resulting constraints; this solver handles these constraints according to the semantics of floating-point arithmetic.</p><p>For example, consider again the path conditions extracted from Figure <ref type="figure" target="#fig_0">1</ref> and assume that the initial domain of variable x is [-INF, +INF]. The first constraint x &gt; 0.0 reduces the interval of x to [1.401 298 464 324 817e-45, +INF], the lower bound of which is the smallest non-zero positive number that can be represented in IEEE single-format floating-point arithmetic. Then, the second constraint x + 1.0e12 = 1.0e12 reduces § the domain of x to [1.401 298 464 324 817e-45, 32 767.999 <ref type="bibr">023 4]</ref>. In this example, all the values of the resulting interval are solutions of the path conditions. Hence, it suffices to take any of the single floating-point values of this interval to find a test datum that activates path 1 → 2 → 3 → 4 of the foo1 program. However, this is not generally the case and one must resort to enumeration to find a solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Contributions of the paper</head><p>This paper introduces new techniques to symbolically execute programs which involve floatingpoint computations. The paper extends the theoretical work of Michel <ref type="bibr" target="#b23">[23]</ref> on the design of exact projection functions of constraints over the floating-point numbers. Practical details on how to build correct and efficient projection functions over floating-point intervals are given. The paper covers not only arithmetic operators but also comparison and format-conversion operators. FPSE, a symbolic execution tool for ANSI C floating-point computations, has been developed to validate the proposed approach. This paper describes its design and implementation and reports some initial experimental results. Note, however, that the paper does not address the general problem of testing floating-point computations. In particular, it does not study the difficult problem of obtaining a correct (but not necessarily exact) oracle in the presence of floating-point computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Contents</head><p>Section 2 briefly recalls the main principles of symbolic execution and reviews how several symbolic execution tools handle the problem of floating-point computations. Section 3 explains the essence of the IEEE-754 standard for binary floating-point arithmetic and indicates the limitations of the proposed approach. Section 4 presents the design of efficient projection functions over floating-point variables. Section 5 explains how to deal with symbolic values such as infinities. Section 6 describes FPSE and reports some experimental results. Finally, the last section describes directions for further work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Only a few studies deal with floating-point computations in the software testing community. According to the authors' knowledge, the only directly related work is that of Miller and Spooner <ref type="bibr" target="#b24">[24]</ref>. Thirty years ago, they studied how to generate automatically floating-point test data for imperative programs. Their work opened the door for execution-based test data generation methods that do not suffer from the above-mentioned problems. However, their approach only makes use of program executions and does not rely on symbolic reasoning. Thus, it cannot be used to study path feasibility. At a time when no standard for floating-point arithmetic was available, symbolic execution was pioneered by King <ref type="bibr" target="#b0">[1]</ref>, Clarke <ref type="bibr" target="#b4">[5]</ref>, Howden <ref type="bibr" target="#b5">[6]</ref> and others <ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref> in several systems. SELECT <ref type="bibr" target="#b6">[7]</ref> and DAVE <ref type="bibr" target="#b4">[5]</ref> exploited linear programming algorithms to solve linear path conditions over the reals. CASEGEN <ref type="bibr" target="#b7">[8]</ref> utilized ad hoc procedures based on try-by-value methods to solve nonlinear equations and used inequalities over the reals to find test data that activated a selected path in the control flow graph. Although these systems were using floating-point operations in their computations, they solved path conditions over the reals. Thus, they did not conform to the floating-point computations of the program under test.</p><p>SMOTL <ref type="bibr" target="#b8">[9]</ref> and more recently GODZILLA <ref type="bibr" target="#b11">[12]</ref> took advantage of domain reduction techniques to reduce the search space of integer inequalities. Gotlieb et al. <ref type="bibr" target="#b25">[25]</ref> applied constraint logic programming over finite domains to solve constraints extracted from imperative programs in the tool INKA <ref type="bibr" target="#b26">[26]</ref>. The proposed framework dealt only with constraints over integers (possibly nonlinear) to generate test data automatically. SMOTL, GODZILLA and INKA did not address the problem of floating-point computations in symbolic execution but they did use domain and interval propagation techniques to solve constraint systems. The method used in the current paper to solve path conditions over floatingpoint variables is closely related to these techniques.</p><p>More recently, Meudec <ref type="bibr" target="#b10">[11]</ref> followed a similar approach and proposed solving path conditions over floating-point variables by means of a constraint solver over the rationals in the ATGen symbolic execution tool. The clpq library <ref type="bibr" target="#b27">[27]</ref> of the constraint logic programming system ECLIPSE was used to solve linear constraints over rationals computed with an arbitrary precision using an extended version of the simplex algorithm. Although this approach appears to be of particular interest, in practice it fails to handle correctly floating-point computations.</p><p>Hence, the problems of floating-point computations in symbolic execution have not been seriously addressed in the past. Although several works deal with floating-point computations, none of them provide a correct handling of floating-point computations. Indeed, floating-point computation cannot be correctly handled either with constraint solvers over the reals or with constraint solvers over the rationals. Dealing with floating-point computations requires the development of a new constraint solver dedicated to floating-point numbers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PRELIMINARIES</head><p>This section introduces the arithmetical model specified by the IEEE-754 standard for binary floatingpoint arithmetic <ref type="bibr" target="#b17">[18]</ref> and explains the limitations and notation of the proposed approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">IEEE-754</head><p>IEEE-754 specifies two basic binary floating-point formats (single and double) and two extended formats. Each floating-point number is a triple (s, e, f ) of bit patterns where s is the sign bit, e the biased exponent, and f the significand. The single format occupies 32 bits (1 bit for the sign, 8 for the exponent and 23 for the significand) while the double occupies 64 bits (1 bit for the sign, 11 for the exponent and 52 for the significand). The standard does not give a strict specification of the extended formats, but it does prescribe some minimal requirements over their sizes. For example, a double extended must occupy at least 79 bits. Each format defines several classes of numbers: normalized numbers, denormalized numbers, signed zeros, infinities and NaNs (which stands for Not-a-Number). For the single format, normalized numbers correspond to an exponent value 0 &lt; e &lt; 255 and a value given by the formula: (-1) s 1.f 2 e-127 . Denormalized numbers correspond to an exponent e = 0 and a value given by (-1) s 0.f 2 -126 where f = 0. Note that the significand possesses a hidden bit which is 1 for normalized numbers and 0 for denormalized. Note also that the bias is equal to 127 for the single format ¶ and the exponent is -126 for denormalized numbers. There are two infinities (denoted +INF, -INF with e = 255, f = 0) and two signed zeros (denoted +0.0, -0.0 with e = 0, f = 0) that allow certain algebraic properties to be maintained <ref type="bibr" target="#b16">[17]</ref>. NaNs (e = 255, f = 0) are used to represent the results of invalid computations such as a division or a subtraction of two infinities. They allow the program execution to continue without being halted by an exception. IEEE-754 indicates four types of rounding directions: toward the nearest representable value, with 'even' values preferred whenever there are two nearest representable values (to-the-nearest), toward negative infinity (down), toward positive infinity (up) and toward zero (chop). The most important requirement of IEEE-754 arithmetic is the accuracy of floating-point computations: each of the following operationsadd, subtract, multiply, divide, square root, remainder, conversions and comparisons-must deliver to its destination the exact result if possible or the floating-point number that requires the least modification of the exact result with respect to (w.r.t.) the prescribed rounding mode and the result format destination. It is said that these operations are correctly rounded . For example, the singleformat result of 999 999 995 904+10 000 is * * 999 999 995 904 which is the single-format floating-point number nearest to the exact result over the reals. This example shows that the accuracy requirement of IEEE-754 does not prevent surprising results from arising (the second operand is absorbed by the addition operator).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Limitations and notation</head><p>In the remainder of this paper, an IEEE-754 compliant floating-point unit (FPU) is assumed. The types of floating-point numbers manipulated by the program are limited to the single and the double format. The proposed framework currently handles only the to-the-nearest rounding direction, which is the default rounding mode in most programming languages. A decimal constant (such as 1.0e12) denotes a floating-point value, and thus has to be understood as the nearest floating-point number according to the default rounding mode (i.e. as 999 999 995 904 with a to-the-nearest rounding mode). Zeros and infinities are handled but NaNs are not. Thus any floating-point unknown is assumed to take only a numerical or infinity value. Henceforth x + (respectively x -) denotes the smallest (respectively greatest) floating-point number greater (respectively smaller) than x, with respect to its format. Moreover, mid(a, b) denotes the floating-point number at the middle † † of a and b. Finally, let ⊕, , ⊗, denote floating-point operations (i.e. the format-dependent result of a to-the-nearest rounding of the exact result), whereas +, -, * , / denote the same operations over the reals. This paper addresses only the problem of dealing with floating-point variables in symbolic execution; other issues such as dealing with loops, arrays and pointers in symbolic execution are out of the scope of this paper. These problems are discussed in more detail elsewhere <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b28">[28]</ref><ref type="bibr" target="#b29">[29]</ref><ref type="bibr" target="#b30">[30]</ref>. Finally, the combination of integers and floating-point expressions into a symbolic execution framework are not detailed here. Hence, programs are limited to floating-point data types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SYMBOLIC EXECUTION</head><p>Symbolic execution has been formally described by Clarke and Richardson <ref type="bibr" target="#b28">[28]</ref>. This technique is based on the selection of a single path of the control flow graph and the computation of symbolic states. When one has to deal with floating-point computations, special attention must be paid to the way expressions are evaluated, as described in this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Control flow graph and paths</head><p>The control flow graph of a program P is a connected oriented graph composed of a set of vertices, a set of edges and two distinguished nodes, e the unique entry node, and s the unique exit node. Each node represents a basic block and each edge represents a possible branching between two basic blocks. A path of P is a finite sequence of edge-connected nodes of the control flow graph which starts on e. Var(P ) denotes the set of variables of P .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Symbolic states and expressions</head><p>Symbolic execution works by computing symbolic states for a given path. A symbolic state for path</p><formula xml:id="formula_0">e → n 1 → • • • → n k in P is a triple (e → n 1 → • • • → n k , {(v, φ v )} v∈Var(P ) , c 1 ∧ • • • ∧ c n )</formula><p>where φ v is a symbolic expression associated with the variable v and c 1 ∧ • • • ∧ c n is a conjunction of symbolic expressions, called path conditions. A symbolic expression is either a symbolic value (possibly undefined, denoted undef) or a well parenthesized expression composed over symbolic values. In fact, when computing a new symbolic expression, each internal variable reference is replaced by its previous symbolic expression. For example, the symbolic state of path 1 → 2 → 3 → 4 in the program of Figure <ref type="figure" target="#fig_0">1</ref> can be obtained by the following sequence of symbolic states:</p><formula xml:id="formula_1">(1 → 2, {(x, X), (y, 1.0e12), (z, undef)}, X &gt; 0.0) (1 → 2 → 3, {(x, X), (y, 1.0e12), (z, X ⊕ 1.0e12)}, X &gt; 0.0) (1 → 2 → 3 → 4, {(x, X), (y, 1.0e12), (z, X ⊕ 1.0e12)}, X &gt; 0.0 ∧ X ⊕ 1.0e12==1.0e12)</formula><p>where X is the symbolic value of the input variable x. Usually, symbolic expressions and path conditions hold only over symbolic input values. However, when floating-point computations are involved in the path, other symbolic values can appear in the symbolic expressions, as described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Forward/backward analysis</head><p>Symbolic states are computed by induction on their path by a forward or a backward analysis <ref type="bibr" target="#b28">[28]</ref>. Each statement of each node of the path is symbolically evaluated using an evaluation function which computes the symbolic states. Forward analysis follows the statements of the selected path in the same direction as that of actual program execution, whereas backward analysis uses the reverse direction. Backward analysis is usually preferred when one only wants to compute the path conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Normalization</head><p>In the presence of floating-point computations, special attention must be paid to conform to the actual execution of the program under consideration. It is necessary to take into account the evaluation order and the precedence of expression operators as specified by the language * . The idea is to exploit the expression's shape of the abstract syntax tree built by the compiler of the program without any rearrangement or any simplification due to optimizations † . When symbolic expressions are directly extracted from the abstract syntax tree then, not only the operator precedence is respected but also the order in which operands are evaluated. This is not always the case when symbolic expressions are extracted from source code by an analyser. Preserving the order of evaluation in the analyser is essential with floating-point computations as simple algebraic properties such as associativity or distributivity are lost. An approach called normalization is proposed here. It decomposes expressions and takes into account the above requirements. Normalization makes symbolic expressions over the floating-point numbers independent of the compiling environment.</p><p>Any of the symbolic expressions is decomposed into a sequence of assignments where fresh temporary variables ‡ are introduced bearing in mind that the order of evaluation must be preserved. For example, let</p><formula xml:id="formula_2">E = v 1 ⊗ v 2 ⊗ v 3 ⊕ v 4 then the resulting decomposition is E = t 1 ⊕ v 4 ∧ t 1 = t 2 ⊗ v 3 ∧ t 2 = v 1 ⊗ v 2 because</formula><p>⊗ has a higher priority than ⊕ and operands are evaluated from left to right. This decomposition requires that intermediate results of an operation conform to the type of storage of its operands § . In the previous example, if v 1 and v 2 are of single format, then the temporary variable t 2 must also be single format. As a result, path conditions are only composed of binary or ternary symbolic expressions that have a single operator over a known floating-point format. This form is called the normalized form of a symbolic expression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">SOLVING PATH CONDITIONS OVER THE FLOATING-POINT NUMBERS</head><p>In this section, the floating-point variables are supposed to take a numerical value. It is assumed here that the computations do not overflow or raise exceptions. These behaviours are handled by means of infinities and NaNs and will be considered in the next section.</p><p>Path conditions are composed of normalized symbolic expressions over floating-point input and temporary variables. Each of these variables takes its numerical values within a finite interval of possible floating-point values w.r.t. its format. Intervals are represented by a pair of bounds that could possibly be provided by the user. By default, any numerical single-format floatingpoint value belongs to [-3.402 823 47e38, 3.402 823 47e38] and any double-format value belongs to [-1.797 693 134 862 315 8e308, 1.797 693 134 862 315 8e308].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Interval propagation</head><p>The solving process is based on interval propagation <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b32">32]</ref>, which is a classical technique used to compute the set of solutions of nonlinear constraints over the reals. The technique takes advantage of interval arithmetic <ref type="bibr" target="#b33">[33]</ref> and relational arithmetic <ref type="bibr" target="#b34">[34]</ref> to reduce the domains of the variables. Relational arithmetic allows the constraints to be decomposed into projection functions over intervals. For example, the constraint z = x + y is decomposed into three projection functions:</p><formula xml:id="formula_3">I z ← I x+y ∩ I z , I x ← I z-y ∩ I x , I y ← I z-x ∩ I y</formula><p>A constraint propagation algorithm uses these projection functions to compute a conservative approximation of the solutions of the constraint system. The following example of a constraint system over the reals illustrates this technique.</p><p>Example 1. Let x ∈ (-∞, +∞), y ∈ (-∞, +∞) be two real unknowns in the constraint system y = log(x), x +y = 0. After a decomposition of the constraints into projection functions, the following successive approximations of x and y are obtained by interval propagation:</p><formula xml:id="formula_4">x ∈ (-∞, +∞) x ∈ [0, +∞) x ∈ [0, 1] x ∈ [0.56, 1] x ∈ [0.56, 0.57] . . . y ∈ (-∞, +∞) y ∈ (-∞, 0] y ∈ [-1, 0] y ∈ [-1, -0.56] y ∈ [-0.57, -0.56] . . .</formula><p>Interval propagation has been applied in several systems <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b35">35]</ref> and two authors of the present paper contributed to the development of one of them, namely Interlog <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref>. The work presented here mainly consists of adapting a real-based interval propagation system to floating-point numbers. It essentially requires modifying projection functions to handle conservatively the domains of floatingpoint variables. In the next subsections, interval propagation of floating-point intervals and projection functions for floating-point constraints are described.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Propagation over floating-point intervals</head><p>During interval propagation, projection functions are incrementally introduced into a propagation queue. An iterative algorithm manages each function one by one in this queue by filtering the domains of floating-point variables of their inconsistent values. Filtering algorithms consider only the bounds of the domains to eliminate inconsistent values. When the domain of a variable has been narrowed then the algorithm reintroduces in the queue all the projection functions in which this variable appears in order to propagate this information. The algorithm iterates until the queue becomes empty, which corresponds to a state where no more domain reduction can be performed (a fixpoint).</p><p>When selected in the propagation queue, each function is added into a constraint store. The constraint store is contradictory when the domain of at least one variable becomes empty during the propagation. In this case, the set of constraints (path conditions) is known to be unsatisfiable and the corresponding path is shown to be infeasible. The interval propagation process reaches a fixpoint because only a finite number of floating-point values can be removed from the domains. This fixpoint is a conservative overestimation (Cartesian product of intervals) of the possible floating-point values for the input variables.</p><p>As is usually the case with interval propagation solvers, propagation over floating-point intervals does not ensure that the set of constraints is satisfiable when a fixpoint is reached. Hence, one must resort to enumeration to locate particular solutions. This is done by a labelling procedure which tries to systematically assign a floating point to a variable and initiate propagation through the constraint store. This process is repeated until all the uninstantiated variables become bound. If this valuation leads to a contradiction then the process backtracks to other possible values or variables. </p><formula xml:id="formula_5">[r l , r h ] ← [a l ⊕ b l , a h ⊕ b h ] ∩ [r l , r h ] when = ⊕ [r l , r h ] ← [a l b h , a h b l ] ∩ [r l , r h ] when = [r l , r h ] ← [min(a l ⊗ b l , a l ⊗ b h , a h ⊗ b l , a h ⊗ b h ), max(a l ⊗ b l , a l ⊗ b h , a h ⊗ b l , a h ⊗ b h )] ∩ [r l , r h ] when = ⊗ [r l ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Floating-point variable projections</head><p>In the proposed approach, each normalized symbolic expression is decomposed into ternary and binary symbolic expressions. These expressions could be directly translated into elementary constraints. Each of these constraints is a ternary or binary constraint and is itself decomposed into projection functions. A ternary symbolic expression r = a b where denotes one of the four arithmetical operations ⊕, , ⊗, , is decomposed into three projections: the direct projection proj(r, r = a b), the first inverse projection proj(a, r = a b) and the second inverse projection proj(b, r = a b).</p><p>Inverse means that projection is performed on a right operand of an assignment. The variable a in proj(a, r = a b) is called the projected variable. Note that single assignment r = a can be treated as the ternary symbolic expression r = a +0.0 because a +0.0 = a even when a = -0. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1.">Computing direct projections for ternary symbolic expressions</head><p>Let [r l , r h ], [a l , a h ], [b l , b h ] be the current floating-point domains of r, a, b, respectively, then the direct projection proj(r, r = a b) computes new bounds r l , r h for the domain of r by using the formulae of Figure <ref type="figure" target="#fig_3">3</ref>. Although this remains implicit, it is important to bear in mind that these formulae are based on the to-the-nearest rounding mode. Note also that they were inspired by interval arithmetic <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b36">36]</ref> but differ from it ¶ . Thanks to the monotonicity of the to-the-nearest rounding direction, these formulae can be deduced directly from the interval arithmetic. The special case where +0.0 or -0.0 belongs to the right operand of the operator can easily be handled by using infinities; this will be explained in the next section. Note also that the intersection of two intervals can be computed by using the formula ordered (even for both -0.0 and +0.0). Figure <ref type="figure" target="#fig_5">4</ref> shows an example of application of the formula for the operator ⊕. The intervals of a, b, r are shown with vertical lines and the non-vertical arrows represent the actual computation of the new bounds of r, before rounding. In this example, the new inferior bound of r is rounded up, although the result over the reals a l + b l is strictly less than the to-the-nearest rounded result of a l ⊕ b l . This is due to the fact that a l + b l is strictly greater than mid((a l ⊕ b l ) -, a l ⊕ b l ). This shows that the formula does not usually retain the solutions over the reals but handles all the solutions over the floating-point numbers.</p><p>Note that these formulae for direct projections lead to an optimal reduction of the interval of r, because IEEE-754 guarantees that the four arithmetic operations are correctly rounded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2.">Computing inverse projections</head><p>Inverse projections are a little bit more complicated to compute. The first inverse projection proj(a, r = a b) computes new bounds a l , a h for the domain of a whereas the second inverse projection proj(b, r = a b) computes new bounds b l , b h for the domain of b. The formulae to compute these inverse projections are given in Figure <ref type="figure">5</ref>. Note that the first and second projections for ⊕ and ⊗ are the same. Thus, only one of them is given here.</p><p>First, all inverse projections compute the middle of (r l , r - l ) and the middle of (r h , r + h ). The reason for this is that r is the result of a to-the-nearest rounding. More precisely, as the implemented operations are correctly rounded, they might be seen as rounding to-the-nearest of the result r R over the reals of the same operation over the reals. Thus, if the floating-point number r l is the result of a to-the-nearest rounding, r R has to belong to the interval [mid(r l , r - l ), mid(r l , r + l )]. The same reasoning applies</p><p>[mid(r l , r - l ), mid(r l , r + l )] is a conservative overestimation. A more precise interval could be computed if one takes into account the value of the least significant bit of r l (or r h ). a rounding towards negative infinity. However, a to-the-nearest rounding computes a conservative value for a h , i.e. a value that is equal to or greater than the optimal value, and avoids the cost of a modification of the rounding mode. As a consequence, the formulae given here for computing the inverse projections are not always optimal but offer a conservative overestimation of the set of floating-point values that satisfy a given normalized symbolic expression. Considering the least significant bit of r l and r h can lead to slightly more shrinking <ref type="bibr" target="#b23">[23]</ref> but requires changing the rounding mode several times during the computation of each projection function. Note also that interesting results from the literature can be used to improve the computation of inverse projections. For example, a classical result <ref type="bibr" target="#b37">[37]</ref> says that if x ⊕y underflows to a denormalized number then x ⊕ y is exactly equal to x + y. In such a case, the computation of the middle mid(r h , r + h ) might be avoided.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Handling comparisons and conversions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1.">Comparisons</head><p>Relational operators such as ==, &gt;, &gt;=, &lt;, &lt;=, ! = are handled by ordered set properties because the finite set of numerical floating-point variables is totally ordered. The formulae are similar for the first and the second projections; hence only the first are given in These formulae are mainly inspired by interval arithmetic <ref type="bibr" target="#b33">[33]</ref> but differ slightly from it for the computation of modified bounds. Here, the computation benefits from the fact that it operates over a finite set of floating-point values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[a l , a h ] ← [max(a l , b l ), min(a h , b h )]</head><p>for proj(a,</p><formula xml:id="formula_6">a == b) [a l , a h ] ← [max(a l , b l ), a h ] for proj(a, a ≥ b) [a l , a h ] ← [max(a l , b l ) + , a h ] for proj(a, a &gt; b) [a l , a h ] ← [a l , min(a h , b h )] for proj(a, a ≤ b) [a l , a h ] ← [a l , min(a h , b h ) -] for proj(a, a &lt; b) [a l , a h ] ← [if (a l = b l = b h ) then a + l else a l , if (a h = b l = b h ) then a - h else a h ]</formula><p>for proj(a, a!=b)</p><p>Figure <ref type="figure" target="#fig_7">7</ref>. Formulae for projections arising from comparison operators.</p><formula xml:id="formula_7">[r l , r h ] ← [max f ((float)a l , r l ), min f ((float)a h , r h )] for proj(r f , r f = (float)a d ) [a l , a h ] ← [max d(a l , mid(r l , r - l )), min d(a h , mid(r h , r + h ))] for proj(a d , r f = (float)a d ) [r l , r h ] ← [max d(a l , r l ), min d(a h , r h )] for proj(r d , r d = (double)a f ) [a l , a h ] ← [max f (a l , r l ), min f (a h , r h )]</formula><p>for proj(a f , r d = (double)a f ) where r f , a f denote single-format variables, and r d , a d denote double-format variables, max f, min f operate over the singles and max d, min d operate over the doubles Figure <ref type="figure">8</ref>. Formulae for projections arising from conversion operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.2.">Conversions</head><p>According to the restrictions of Section 3.2, only two format conversions are allowed: r = (float)a where a is a double and r = (double)a where a is a single. Formulae that compute the bounds of projected variables with direct and inverse projections of conversion operators are given in Figure <ref type="figure">8</ref>. Note that any single-format value can be converted exactly into a double-format value. Thus, some conversions do not require any computation and remain implicit in the formulae.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">HANDLING SYMBOLIC VALUES</head><p>IEEE-754 distinguishes two kinds of symbolic values: infinities and NaNs. The cases where infinities and NaNs can be produced as the result of a computation are detailed by Goldberg <ref type="bibr" target="#b16">[17]</ref>. However, implementing projection functions over symbolic values requires further analysis of how to combine infinities, numerical values, zeros and NaNs and how to deal with exceptions <ref type="bibr" target="#b37">[37]</ref>.</p><p>In the proposed approach, the numerical domain is merely extended with both infinities and remains totally ordered. Roughly speaking, the main idea for computing projections consists of isolating the infinities from the numerical values of the domains, computing the projected variable's domain in the numerical case, combining the symbolic values between themselves, and merging the results of both the symbolic and the numerical cases. </p><formula xml:id="formula_8">Table II. Value of a in first inverse projection proj(a, r = a ⊕ b). r b -INF -0.0 +0.0 Nv +INF -INF Nv ∪ {-INF, ±0.0} ⊥ ⊥ ⊥ ⊥ -0.0 -INF -0.0 +0.0 Nv +INF +0.0 -INF ⊥ ± 0.0 Nv +INF Nv Nv ∪ {-INF} ⊥ Nv ∪ {±0.0} Nv ∪ {±0.0} Nv ∪ {+INF} +INF ⊥ ⊥ ⊥ ⊥ Nv ∪ {+INF, ±0.0}</formula><p>To compute the projections of ⊕ (direct and inverse), Tables I and II are required. Note that Nv stands for any non-zero numerical value and ±INF denotes either of the two infinities. Some combinations of symbolic values are impossible. For example, when r = +0.0 and b = +INF, the first inverse projection proj(a, r = a ⊕ b) computes an empty domain for variable a. Thus, there exists no floating-point value of a able to satisfy the equation +0.0 = a ⊕ +INF. These cases are indicated by the presence of the symbol ⊥. When the operands of a projection are known and ⊥ is encountered in the tables then the projection is refuted and the constraint store is shown to be contradictory. Note that when the sum of two opposite operands is exactly zero and the rounding mode is the to-the-nearest mode, then the result is +0.0 (and not -0.0). The cases where infinity is produced as a result of an operation over two numerical values (such as in Nv ⊕ Nv) usually correspond to an overflow.</p><p>More frequently, operands are just known by their interval of possible values. Hence, when a combination of bounds is ⊥, such as in proj(a, r = a ⊕ b) where r ∈ [-INF, +INF] and b ∈ [-INF, +INF], ⊥ is just ignored and the interval of a is left unchanged (although +0.0 belongs to the interval of r). The new bounds of r are computed using the formula of the numerical case</p><formula xml:id="formula_9">([r l , r h ] ← [a l ⊕ b l , a h ⊕ b h ] ∩ [r l , r h ]).</formula><p>Signed zeros, infinities and overflows are just special cases of this computation. If signed zeros belong to the intervals of a or b then the numerical case (Nv ⊕ Nv) of the table is applied. If an overflow occurs then the bounds are updated with the corresponding infinities.</p><p>The same procedure can be used for the computation of the projections of , ⊗, using the tables given in the Appendix. Note that the negative and positive numerical cases have not been distinguished in these tables. Although this is useful for implementing better reduction of domains, these cases are not difficult to determine as simple sign rules remain valid in the context of non-zero numerical floatingpoint values. Note that the only cases where NaN is produced when operands are non-NaNs are ∞-∞ for ⊕, and 0 * ∞, 0/0, ∞/∞ for ⊗ and . These cases are handled by ⊥ in the proposed approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">A LABELLING PROCEDURE</head><p>As previously said, projection functions only reduce the domains of the variables. Thus, constraint propagation ensures neither that the path conditions are satisfiable nor that a test datum can be found in the general case. Note, however, that this process is efficient as it only requires O(md) operations in the worst case where m denotes the number of constraints and d denotes the size of the largest domain <ref type="bibr" target="#b21">[22]</ref>. To find a solution, a labelling procedure has to be implemented. Some heuristics are used to choose the variables and the values to be enumerated first. Several heuristics have been discussed by Michel et al. <ref type="bibr" target="#b38">[38]</ref> and can easily be implemented. Note that in a symbolic execution framework, only the input variables need to be instantiated as all the other internal variables are computed in terms of these. As soon as a value is given to an uninstantiated variable, the interval propagator wakes up all the projection functions where this variable appears, thereby propagating the choice through the constraint system. In the applications of symbolic execution over floating-point variables, two difficult situations may sometimes occur at the end of the initial propagation step: either the path conditions have no solutions (i.e. the corresponding path is infeasible) but this has not been detected, or the path conditions have solutions but the resulting intervals are too approximate for them to be found. In these two related situations the labelling process is time-consuming and cannot be completed in all the cases. However, note there are always less than 2 32 (respectively 2 64 ) possible values in the domain of a single-format (respectively double-format) floating-point value. So the process is no more time-consuming than the one used in constraint-based automatic test data generation environments over integers <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b39">39]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">IMPLEMENTATION AND EXPERIMENTAL RESULTS</head><p>The current authors have implemented a symbolic execution tool for ANSI C floating-point computations, called the Floating Point Symbolic Execution (FPSE) system. The tool extracts path conditions and symbolic expressions by a forward analysis and tries to solve them using the principles described in this paper. The constraint propagation engine of FPSE is written in Prolog whereas the projection functions are written in C.</p><p>FPSE handles floating-point computations that strictly conform to IEEE-754 and are intended to run on Sparc architectures. ANSI C accommodates the IEEE-754 floating-point standard by not adopting any constraints on floating-point computations which are contrary to this standard. In particular, it allows operations on float to be performed in single precision calculations. Note, however, that ANSI C gives the compiler a large degree of freedom in how to interpret and evaluate a floating-point expression to a precision wider than that normally associated with its type. While compiling the tested </p><formula xml:id="formula_10">T 2 = 2.0e-30 ⊕ 1.0e30, T 1 = T 2 1.0e30, X = T 1 1.0e-30 3 2 g2.c = B 2 -4 * A * C with A = 1.22, B = 3.34, C = 2.28 T 1 = B ⊗ B, T 2 = A ⊗ C, T 3 = 4.0 ⊗ T 2 , = T 1 T 3 4 3 g2.c = B 2 -4 * A * C with A = 1.22, B = 3.34, = 0 T 1 = B ⊗ B, T 2 = A ⊗ C, T 3 = 4.0 ⊗ T 2 , = T 1 T 3 , == 0.0 5 4 power.c (X = 10, Y = -40) a-b-c-{d-e} 40 - d-f-g-h RES = X Y with X = 10, Y = -40 W 1 = 0.0 Y, Z 1 = 1.0, {Z i+1 = Z i * X, W i+1 = W i -1.0} i=1..40 , Z 42 = 1.0 Z 41 , RES = Z 42 84 5 power.c (X = 10, Y = -350) a-b-c-{d- e} 350 -d-f-g-h RES = X Y with X = 10, Y = -350 W 1 = 0.0 Y, Z 1 = 1.0, {Z i+1 = Z i * X, W i+1 = W i -1.0} i=1..350 , Z 352 = 1.0 Z 351 , RES = Z 352<label>704</label></formula><p>No. of Program Path condition over R Normalized FPSE path conditions constraints 6 foo1.c X &gt; 0, X + 10 12 = 10 12 X &gt; 0.0, T 1 = X ⊕ 1.0e12, T 1 = 1.0e12 3 7 foo2.c X &lt; 10 4 , X + 10 12 &gt; 10 12 X &lt; 10000.0, Secondly, path feasibility experiments were performed with FPSE on path conditions extracted from programs foo1.c and foo2.c given in the introductory part of the paper (Figures <ref type="figure" target="#fig_0">1</ref> and<ref type="figure" target="#fig_1">2</ref>), from the program howden.c, which is a small-sized numeric computation extracted from the work of Howden <ref type="bibr" target="#b40">[40]</ref> and from the program power.c (Figure <ref type="figure" target="#fig_9">9</ref>). For these programs, path conditions are given in the bottom part of Table <ref type="table" target="#tab_0">III</ref>. The third column provides the expressions as they appear in the literature. In particular, note that the path conditions of Examples 8-11 result from a simplification process which has eliminated several redundant constraints. This process, as proposed for several symbolic execution tools <ref type="bibr" target="#b9">[10]</ref>, is unsound over floating-point variables as algebraic properties (such as associativity and distributivity) are not preserved. The fourth column of Table <ref type="table" target="#tab_0">III</ref> contains the normalized symbolic expressions as they are computed by the FPSE tool in the normalization process (Section 4). Finally, the last column contains the number of constraints present in the normalized path conditions.</p><formula xml:id="formula_11">T 1 = X ⊕ 1.0e12, T 1 &gt; 1.0e12 3 8 howden.c A * B +2 &gt; 100, 48-A * B &gt; 0 T 1 = A ⊗ B, X 1 = T 1 ⊕ 2.0, X 1 &gt; 100.0, X 2 = 100.0 X 1 , X 3 = X 2 50.0, X 3 &gt; 50.0 6 9 power.c (X, Y unknown) a-b-c-d-f-g-h Y &lt; 0, Y ≥ 0 Y &lt; 0.0, W = +0.0 Y, W ≤ 0.0 3 10 power.c (X, Y unknown) a-b-c-{d-e} 40 - d-f-g-h Y &lt; 0, Y &lt; -39, Y ≥ -40 Y &lt; 0.0, W 1 = 0.0 Y, {W i &gt; 0.0, W i+1 = W i -1.0} i=1..40 , W 41 ≤ 0.0 83 11 power.c (X, Y unknown) a-b-c-{d- e} 350 -d-f-g-h Y &lt; 0, Y &lt; -349, Y ≥ -350 Y &lt; 0.0, W 1 = 0.0 Y, {W i &gt; 0.0, W i+1 = W i -1.0}<label>i=1</label></formula><p>All programs were compiled with gcc † † on an ultra Sparc FPU under Solaris 2.7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.2.">Results</head><p>In all the cases, the CPU time required to get the results with any of the four solvers (FPSE, IC, clpr, clpq) is less than a few seconds, so it is not shown. The second column of Table <ref type="table">IV</ref> contains the expected results computed either by executions of the C program or by manual analysis. In both cases, the results over the singles and the doubles are provided. Binary floating-point numbers are represented by decimal constants, denoted with 16 decimals. The third column of Table <ref type="table">IV</ref> contains the results computed by the solvers over the reals and the rationals (IC, clpr and clpq). These solvers do not use single-format floating-point numbers; hence, only the results over the double-format or the rationals is given. The last column of Table <ref type="table">IV</ref> contains the results computed by FPSE over both formats. Note that for any of the solvers (including FPSE), the labelling process has not been triggered and the results that are shown are obtained just after the constraint propagation step. Note that, as Eclipse IC is based on interval propagation, interval bounds are only changed if the absolute and relative changes of the bounds exceed a given propagation threshold, which is set to 1.0e-8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.3.">Analysis</head><p>First, the examples illustrate that the four evaluators may produce distinct results. In Example 1, the results computed by both clpr and clpq are incorrect not only w.r.t. the expected result over the floats (second column of Table <ref type="table">IV</ref>) but also over the expected solutions over the reals (i.e. +1.0e-30). The IC library provides a correct but useless result over the reals as the superior bound of the computed interval is greater than 10 To conclude, these experiments demonstrate that the proposed approach is suitable for dealing efficiently with small-sized C floating-point computations. Of course, the set of experiments is too restricted to extrapolate the results easily to larger computations but this work is a first attempt to address the problem of floating-point computations in symbolic execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">FURTHER WORK</head><p>In this paper, a new symbolic execution framework able to correctly handle IEEE-754-compliant floating-point computations has been introduced. The definitions of correct and efficient projection functions for solving normalized symbolic expressions have been given. Handling other rounding modes than the to-the-nearest number appears as being a tedious but not difficult extension of the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A</head><p>This appendix contains the tables used in direct and inverse projections when infinities are involved in the computations. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Program foo1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Program foo2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>If I x = [a, b] and I y = [c, d] then interval arithmetic says that I x+y = [a + c, b + d] contains all 105 possible values for the expression x +y when x ∈ I x and y ∈ I y . In the same way, I x-y = [a-d, b-c], I x * y = [min(a * c, a * d, b * c, b * d), max(a * c, a * d, b * c, b * d)], I exp(x) = [exp(a), exp(b)], etc.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Formulae for direct projections proj(r, r = a b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>0. A binary symbolic expression a = (type)b where type is either float or double is decomposed into a direct projection proj(a, a = (type)b) and an inverse one proj(b, a = (type)b). A binary symbolic expression a rel b where rel denotes any of the six relational operators ==, &lt;, &lt;=, &gt;, &gt;=, ! = is decomposed into two projections: proj(a, a rel b) and proj(b, a rel b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Computation of direct projection proj(r, r = a ⊕ b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>SYMBOLICFigure 6 .</head><label>6</label><figDesc>Figure 6. Computing the first inverse projection proj(a, r = a ⊕ b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 .</head><label>7</label><figDesc>The floating-point domain of a (respectively b) is [a l , a h ] (respectively [b l , b h ]) and the domain of the result a is [a l , a h ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>TableI. Value of r in direct projection proj(r, r = a ⊕ b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Control flow graph of program power.c.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>14 . As expected, FPSE provides the result strictly conforming to the evaluation of the program over the floating-point numbers (single and double), without any overestimation. Examples 2 and 3 show that even when expressions are not targeted to exemplify floating-point computation problems (g2.c computes the roots of the second-order equation), the results given by the three solvers over the reals and the rationals (IC, clpr, clpr) do not conform to the ones computed by program executions. In Example 3, FPSE returns an interval of two floating-point values (in both cases) but only one of them satisfies the symbolic expression. Examples 4 and 5 show situations where floating-point numbers are flushed to zero by the computations, leading to a divergence with the computations over the reals (the program returns +0.0 instead of a strict positive quantity). FPSE provides the expected result, as 1.0 +INF results in +0.0. Examples 6 and 7 have already been discussed in the introduction of the paper. Examples 8 and 9 demonstrate path infeasibility. In Example 8, both clpr and clpq return an unsolved nonlinear constraint system. Solvers based on interval propagation (IC, FPSE) are not restricted to dealing with linear constraints, hence path infeasibility is shown. In Example 9, all the four solvers provide the expected result. Finally, Examples 10 and 11 illustrate the capacity of the solvers to deal with a realistic number of constraints, even when inverse projections are involved. In Examples 8-11, IC and FPSE return the same (possibly overestimated) correct results at the end of the constraint propagation step, but only FPSE is trustworthy over the floating-point numbers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Table AI. Value of r in direct projection proj(r, r = a b). , +0.0} -INF +INF +INF +INF +INF +INF ⊥ Table AII. Value of r in direct projection proj(r, r = a ⊗ b). Table AIII. Value of r in direct projection proj(r, r = a b). Table AIV. Value of a in first inverse projection proj(a, r = a b). Table AV. Value of a in first inverse projection proj(a, r = a ⊗ b). Table AVI. Value of a in first inverse projection proj(a, r = a b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table III .</head><label>III</label><figDesc>Programs and FPSE expressions.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>No. of</cell></row><row><cell>Program</cell><cell>Symbolic expression over R</cell><cell>Normalized FPSE expression</cell><cell>contraints</cell></row><row><cell>1 g1.c</cell><cell>X = (2  *  10 -30 + 10 30 ) -10 30 -10 -30</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>§ In IEEE-754 single-format, the constant 1.0e12 is interpreted as 999 999 995 904. Copyright c 2005 John Wiley &amp; Sons, Ltd. Softw. Test. Verif. Reliab. 2006; 16:97-121</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>Copyright c 2005 John Wiley &amp; Sons, Ltd. Softw. Test. Verif. Reliab. 2006; 16:97-121</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>¶  The actual value of the exponent is Ebias, where E is the exponent value in the floating-point number representation. Thus, with single-format floating-point numbers, the maximum value of the exponent is 127 and the minimum value is -126.Copyright c 2005John Wiley &amp; Sons, Ltd. Softw. Test. Verif. Reliab. 2006; 16:97-121</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>† Compiler optimization flags are not allowed here, particularly when they rearrange instructions. ‡ The introduction of temporary variables does not change the semantics of floating-point computations as long as it maps the behaviour of the compiler and of the floating-point unit.§ This property is not a requirement of IEEE-754 and consequently it is not always true. For example, on Intel's architectures extended formats are used by default to store intermediate results.Copyright c 2005 John Wiley &amp; Sons, Ltd. Softw. Test. Verif. Reliab. 2006; 16:97-121 SYMBOLIC EXECUTION OF FLOATING-POINT COMPUTATIONS</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>¶  For example, the expected result over the reals of the sum of two numbers x and y can be captured by the interval [z, z] where z (respectively z) denotes the rounded toward negative (respectively positive) infinity result of x + y<ref type="bibr" target="#b16">[17]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_5"><p>† † gcc-3.3.3 -g -Wall -DFPSE SPARC -lm -std=gnu89 -ffloat-store -mhard-float -msoftquad-float -munaligned-doubles (some default options). Copyright c 2005 John Wiley &amp; Sons, Ltd. Softw. Test. Verif. Reliab. 2006; 16:97-121</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors are very grateful to Andy King for his careful reading of the paper and also wish to thank Michel Rueher for fruitful discussions on this work. This work is partially supported by the FNS funded project V3F.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>[a l , a h ] ← [min(mid(r l , r - l ) ⊗ b l , mid(r l , r - l ) ⊗ b h , mid(r h , r to r h . The computation of the middle of two single-format or double-format floating-point variables can easily be computed, as a wider format is almost always available * * : the middle of two singles is captured by a double and the middle of two doubles is captured by an extended double. Note that the operations themselves are performed over a wider format, such as in the inverse projection of ⊕: mid(r l , r - l ) b h as shown in Figure <ref type="figure">6</ref>. Here, both operands of are first converted into a greater format, although this remains implicit in the formulae.</p><p>Second, special attention must be paid to the computation of the bounds of the projected variable. Operators ⊕, , ⊗, are correctly rounded. Thus, they can be used to compute their inverse. The complete proof of this statement has been given by Michel <ref type="bibr" target="#b23">[23]</ref> and only an outline of it is given here. Consider the computation of a h for the addition in Figure <ref type="figure">6</ref>. As explained above, r h is the result of a to-the-nearest rounding of the addition of a and b over the reals. Thus, over the reals, the following inequality holds:</p><p>Over the reals, this inequality leads to a h ≤ mid(r h , r + h )b l . In order to obtain a h , that is to say, in order to find the greatest floating-point number less than or equal to mid(r h , r + h )b l (which is nothing but the definition of a rounding towards negative infinity), one would have to compute mid(r h , r + h )b l with SYMBOLIC EXECUTION OF FLOATING-POINT COMPUTATIONS 113 programs, it is necessary to avoid the use of compiler options that activate code optimizations as well as options that allow the storage of floating-point values into extended formats.</p><p>In practice, it is very difficult to guarantee that the symbolic execution will strictly conform to the actual execution for several reasons: (1) the lack of documentation of the compiler options and design, (2) the existence of unexpected hardware optimizations such as the fused multiply-add a + b * c, (3) the unexpected change of rounding modes by user actions, (4) the defaults in the compiler implementation, and so on. These limitations have to be taken into account when interpreting the results of FPSE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.">Experimental results</head><p>To evaluate the approach, the results provided by FPSE were compared with expected floating-point results computed by hand and the results obtained with three available solvers over the reals and the rationals. Distributed as part of the ECLIPSE Prolog system are the following three distinct solvers.</p><p>(1) The IC library <ref type="bibr" target="#b18">[19]</ref> which is a hybrid integer/real interval arithmetic constraint solver based on interval propagation. As in any other interval propagation solver over the reals (e.g. Ilog solver, RealPaver <ref type="bibr" target="#b19">[20]</ref>, Interlog <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref>), each real number is represented by a pair of floatingpoint bounds and any arithmetic operation is performed by using these bounds. The resulting interval is then widened to take into account any possible error in the operation, thus ensuring the resulting interval contains the true answer over the reals. This contrasts with the approach of this paper where floating-point numbers and operations are correctly approximated by relations over finite sets of floating-point numbers (also represented by a pair of floating-point bounds). ( <ref type="formula">2</ref>) The clpr library <ref type="bibr" target="#b27">[27]</ref> that solves linear constraints over the reals. clpr makes use of floatingpoint numbers to approximate computations over the reals. (3) The clpq library <ref type="bibr" target="#b27">[27]</ref> that solves linear constraints over rationals computed with an arbitrary precision. In clpq, each rational is treated as a pair of integers and any arithmetic computation remains exact.</p><p>Both solvers clpr and clpq exploit the simplex method and a Fourier-Motzkin algorithm to solve linear constraints. In addition, they provide several isolation axioms to take into account some restricted shapes of nonlinear constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.1.">Programs</head><p>Several floating-point programs of small size were extracted from the literature to be carefully examined. Two distinct uses of symbolic execution were considered: output symbolic expression computation and path feasibility. Firstly, symbolic expressions were extracted from the work of Goldberg <ref type="bibr" target="#b16">[17]</ref> and implemented in programs g1.c, g2.c. Program g1.c contains the C expression X = ((2.0e-30 + 1.0e30) -1.0e30) -1.0e-30 whereas g2.c contains == B 2 -4AC. For the latter, two symbolic expressions were computed: the first corresponds to the direct evaluation of the expression by taking A = 1.22, B = 3.34, C = 2.28, whereas the second corresponds to the inverse evaluation where C is unknown and == +0.0. Symbolic expressions were extracted from paths of the program power.c that computes x y , given in Figure <ref type="figure">9</ref>. The two selected paths contain a number of iterations (40 and 350) that lead to overflows. All these symbolic expressions are given in the top part of Table <ref type="table">III</ref> single:X = -1.000 000 003 171 076 9e-30 -1.000 000 003 171 076 9e-30 clpr: X = 0.0 double:X = -1.000 000 000 000 000 1e-30 double:X = clpq: X = -1.000 000 000 000 000 1e-30 1/999 999 999 999 999 879 147 136 483 328   proposed framework. In the same spirit, handling the square root function is straightforward: this function is included in the IEEE-754 standard and is correctly rounded. Dealing with extended formats appears to be an interesting extension as computations require more and more precision. This extension probably requires using multiple-precision floating-point numbers, as exploited in some computer algebra systems. The most difficult extension concerns the transcendental functions as there is nothing to guarantee that the computation is correctly rounded in these cases. This problem, known as the 'table maker dilemma' problem, is likely to be the more expected part of future work on this topic.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Symbolic execution and program testing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="385" to="394" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Applications of feasible path analysis to program testing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zimmerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Software Testing and Analysis (ISSTA&apos;94)</title>
		<meeting>the International Symposium on Software Testing and Analysis (ISSTA&apos;94)<address><addrLine>Seattle, WA; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1994-08">August 1994. 1994</date>
			<biblScope unit="page" from="80" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Test data generation and feasible path analysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jasper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Brennan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Williamson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Currier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zimmerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Software Testing and Analysis (ISSTA&apos;94)</title>
		<meeting>the International Symposium on Software Testing and Analysis (ISSTA&apos;94)<address><addrLine>Seattle, WA; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1994-08">August 1994. 1994</date>
			<biblScope unit="page" from="95" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Translatability and decidability questions for restricted classes of program schemas</title>
		<author>
			<persName><forename type="first">E</forename><surname>Weyuker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Computing</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="587" to="598" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A system to generate test data and symbolically execute programs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="215" to="222" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reliability of the path analysis testing strategy</title>
		<author>
			<persName><forename type="first">W</forename><surname>Howden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="208" to="214" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">SELECT-a formal system for testing and debugging programs by symbolic execution</title>
		<author>
			<persName><forename type="first">R</forename><surname>Boyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Elspas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Levitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="234" to="245" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the automated generation of program test data</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ramamoorthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><forename type="middle">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="293" to="300" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SMOTL-a system to construct samples for data processing program debugging</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bičevskis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Borzovs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Straujums</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zarinš</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="60" to="66" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Symbolic Execution of Software-The SYM-BOL System</title>
		<author>
			<persName><forename type="first">D</forename><surname>Coward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ince</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>London</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic test data generation using constraint logic programming and symbolic execution</title>
		<author>
			<persName><forename type="first">C</forename><surname>Meudec</surname></persName>
		</author>
		<author>
			<persName><surname>Atgen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Testing, Verification and Reliability</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="81" to="96" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Experimental results from an automatic test case generator</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Demillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Offutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="109" to="127" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Software specialization via symbolic execution</title>
		<author>
			<persName><forename type="first">A</forename><surname>Coen-Porisini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>De Paoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ghezzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mandrioli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="884" to="899" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A unified symbolic evaluation framework for parallelizing compilers</title>
		<author>
			<persName><forename type="first">T</forename><surname>Fahringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Scholz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1105" to="1125" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Using symbolic execution for verifying safety-critical systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Coen-Porisini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Denaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ghezzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pezzè</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th European Software Engineering Conference (ESEC/FSE&apos;01)</title>
		<meeting>the 8th European Software Engineering Conference (ESEC/FSE&apos;01)<address><addrLine>Vienna, Austria; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001-09">September 2001. 2001</date>
			<biblScope unit="page" from="142" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Semi-proving: An integrated method based on global symbolic evaluation and metamorphic testing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Tse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Software Testing and Analysis (ISSTA&apos;02)</title>
		<meeting>the International Symposium on Software Testing and Analysis (ISSTA&apos;02)<address><addrLine>Roma, Italy; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002-07">July 2002. 2002</date>
			<biblScope unit="page" from="191" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">What every computer scientist should know about floating-point arithmetic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="48" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Standard for binary floating-point arithmetic</title>
		<author>
			<persName><surname>Ieee-754</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="9" to="25" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">P</forename><surname>Brisset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">El</forename><surname>Sakkout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Frühwirth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gervet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Harvey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Novello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Le</forename><surname>Provost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schimpf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wallance</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ECLiPSe Constraint Library Manual, Releases 5.8. International Computers Limited and Imperial College London</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>London</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">RealPaver User&apos;s Manual: Solving Nonlinear Constraints by Interval Computations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Granvilliers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>University of Nantes: France</orgName>
		</respStmt>
	</monogr>
	<note>Release 0.3.</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Constraint logic programming on numeric intervals</title>
		<author>
			<persName><forename type="first">B</forename><surname>Botella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Taillibert</surname></persName>
		</author>
		<author>
			<persName><surname>Interlog</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Workshop on Software Engineering, Artificial Intelligence and Expert Systems in High Energy and Nuclear Physics</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Becks</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Perret-Gallix</surname></persName>
		</editor>
		<meeting>the Third International Workshop on Software Engineering, Artificial Intelligence and Expert Systems in High Energy and Nuclear Physics<address><addrLine>Oberammergau, Bayern, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>World Scientific</publisher>
			<date type="published" when="1993-10-08">4-8 October 1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Boosting the interval narrowing algorithm</title>
		<author>
			<persName><forename type="first">O</forename><surname>Lhomme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gotlieb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rueher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Taillibert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP&apos;96)</title>
		<meeting>the Joint International Conference and Symposium on Logic Programming (JICSLP&apos;96)<address><addrLine>Bonn; Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1996-09">September 1996. 1996</date>
			<biblScope unit="page" from="378" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Ltd. Softw. Test. Verif. Reliab</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="97" to="121" />
			<date type="published" when="2005">2005. 2006</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Exact projection functions for floating point number constraints</title>
		<author>
			<persName><forename type="first">C</forename><surname>Michel</surname></persName>
		</author>
		<ptr target="http://rutcor.rutgers.edu/∼amai/aimath02/PAPERS/21.ps" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Symposium on Artificial Intelligence and Mathematics</title>
		<meeting>the Seventh International Symposium on Artificial Intelligence and Mathematics<address><addrLine>Fort Lauderdale, FL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Automatic generation of floating-point test data</title>
		<author>
			<persName><forename type="first">W</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Spooner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="223" to="226" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Automatic test data generation using constraint solving techniques</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gotlieb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Botella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rueher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Software Testing and Analysis (ISSTA&apos;98)</title>
		<meeting>the International Symposium on Software Testing and Analysis (ISSTA&apos;98)<address><addrLine>Clearwater Beach, FL; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998-03">March 1998. 1998</date>
			<biblScope unit="page" from="53" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A CLP framework for computing structural test data</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gotlieb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Botella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rueher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Computational Logic (CL&apos;2000)</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<meeting>Computational Logic (CL&apos;2000)<address><addrLine>London, U.K.; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000-07">July 2000. 2000</date>
			<biblScope unit="volume">1891</biblScope>
			<biblScope unit="page" from="399" to="413" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">OEFAI clp(q,r) Manual Rev. 1.3.2, TR-95-09</title>
		<author>
			<persName><forename type="first">C</forename><surname>Holzbaur</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
		<respStmt>
			<orgName>Austrian Research Institute for Artificial Intelligence: Vienna</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<author>
			<persName><forename type="first">L</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Richardson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Program Flow Analysis: Theory and Applications</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Muchnick</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Jones</surname></persName>
		</editor>
		<imprint>
			<publisher>Englewood Cliffs</publisher>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
	<note>ch. 9</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Array representation in symbolic execution</title>
		<author>
			<persName><forename type="first">A</forename><surname>Coen-Porisini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>De Paoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Languages</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="197" to="216" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Automatic test data generation from embedded C code</title>
		<author>
			<persName><forename type="first">E</forename><surname>Dillon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Meudec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SAFECOMP&apos;04</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>SAFECOMP&apos;04<address><addrLine>Potsdam, Germany; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004-09">September 2004. 2004</date>
			<biblScope unit="volume">3219</biblScope>
			<biblScope unit="page" from="180" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">CLP (Intervals) revisited</title>
		<author>
			<persName><forename type="first">F</forename><surname>Benhamou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcallester</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Hentenryck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1994 International Symposium on Logic Programming (ILPS&apos;94)</title>
		<meeting>the 1994 International Symposium on Logic Programming (ILPS&apos;94)<address><addrLine>Ithaca, New York; Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1994-11">November 1994. 1994</date>
			<biblScope unit="page" from="124" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Applying interval arithmetic to real, integer and boolean constraints</title>
		<author>
			<persName><forename type="first">F</forename><surname>Benhamou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Older</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interval Analysis</title>
		<imprint>
			<publisher>Englewood Cliffs</publisher>
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Logical arithmetic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Cleary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Computing Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="125" to="149" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Extending Prolog with constraints arithmetic on real intervals. Proceedings of IEEE Canadian Conference on Electrical and Computer Engineering</title>
		<author>
			<persName><forename type="first">W</forename><surname>Older</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vellino</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>IEEE Computer Society Press</publisher>
			<pubPlace>Los Alamitos, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Interval arithmetic: From principles to implementation</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Hickey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Ju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Van Emden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of ACM</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1038" to="1068" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Handling floating-point exceptions in numeric programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="139" to="174" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Solving constraints over floating-point numbers. Proceedings of Principles and Practices of Constraint Programming (CP&apos;01)</title>
		<author>
			<persName><forename type="first">C</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rueher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lebbah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2239</biblScope>
			<biblScope unit="page" from="524" to="538" />
			<date type="published" when="2001-11">November 2001. 2001</date>
			<publisher>Springer</publisher>
			<pubPlace>Paphos, Cyprus; Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Constraint-based automatic test data generation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Demillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Offutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="900" to="910" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Validation of scientific programs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Howden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="193" to="227" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
