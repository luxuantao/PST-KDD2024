<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Yet Another Compressed Cache: A Low-Cost Yet Effective Compressed Cache</title>
				<funder ref="#_skJPmJH">
					<orgName type="full">European Research Council Advanced</orgName>
				</funder>
				<funder ref="#_kM5u82R #_WDBEgHV #_N5n5sbe #_DEPgGvP #_nPTz6cq">
					<orgName type="full">National Science Foundation</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Somayeh</forename><surname>Sardashti</surname></persName>
							<email>somayeh@cs.wisc.edu</email>
						</author>
						<author>
							<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">IRISA/INRIA DAVID A. WOOD</orgName>
								<orgName type="institution" key="instit1">University of Wisconsin-Madison ANDRE SEZNEC</orgName>
								<orgName type="institution" key="instit2">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Sciences</orgName>
								<orgName type="institution">University of Wisconsin</orgName>
								<address>
									<addrLine>1210 West Dayton Street</addrLine>
									<postCode>53706-1685</postCode>
									<settlement>Madison, Madison</settlement>
									<region>WI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">A. Seznec</orgName>
								<orgName type="institution" key="instit2">IRISA</orgName>
								<address>
									<addrLine>Campus de Beaulieu</addrLine>
									<postCode>35042</postCode>
									<settlement>RENNES Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Publications Dept</orgName>
								<orgName type="institution">ACM, Inc</orgName>
								<address>
									<addrLine>2 Penn Plaza, Suite 701</addrLine>
									<settlement>New York</settlement>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Yet Another Compressed Cache: A Low-Cost Yet Effective Compressed Cache</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/2976740</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Compression</term>
					<term>cache design</term>
					<term>energy efficiency</term>
					<term>performance</term>
					<term>multicore systems</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Cache memories play a critical role in bridging the latency, bandwidth, and energy gaps between cores and off-chip memory. However, caches frequently consume a significant fraction of a multicore chip's area and thus account for a significant fraction of its cost. Compression has the potential to improve the effective capacity of a cache, providing the performance and energy benefits of a larger cache while using less area. The design of a compressed cache must address two important issues: (i) a low-latency, low-overhead compression algorithm that can represent a fixed-size cache block using fewer bits and (ii) a cache organization that can efficiently store the resulting variable-size compressed blocks. This article focuses on the latter issue.</p><p>Here, we propose Yet Another Compressed Cache (YACC), a new compressed cache design that targets improving effective cache capacity with a simple design. YACC uses super-blocks to reduce tag overheads while packing variable-size compressed blocks to reduce internal fragmentation. YACC achieves the benefits of two state-of-the art compressed caches-Decoupled Compressed Cache (DCC) [Sardashti and Wood 2013a,  2013b]  and Skewed Compressed Cache (SCC) <ref type="bibr" target="#b26">[Sardashti et al. 2014</ref>]-with a more practical and simpler design. YACC's cache layout is similar to conventional caches, with a largely unmodified tag array and unmodified data array. Compared to DCC and SCC, YACC requires neither the significant extra metadata (i.e., back pointers) needed by DCC to track blocks nor the complexity and overhead of skewed associativity (i.e., indexing ways differently) needed by SCC. An additional advantage over previous work is that YACC enables modern replacement mechanisms, such as RRIP.</p><p>For our benchmark set, compared to a conventional uncompressed 8MB LLC, YACC improves performance by 8% on average and up to 26%, and reduces total energy by 6% on average and up to 20%. An 8MB YACC achieves approximately the same performance and energy improvements as a 16MB conventional cache at a much smaller silicon footprint, with only 1.6% greater area than an 8MB conventional cache. YACC performs comparably to DCC and SCC but is much simpler to implement.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Cache memories play an increasingly critical role in bridging the latency, bandwidth, and energy gaps between cores and main memory. However, caches frequently consume a significant fraction of a multicore chip's area and thus account for a significant fraction of its cost. Compression has the potential to improve the effective capacity of a cache, providing the performance and energy benefits of a larger cache while using less area. Prior work has proposed compression algorithms suitable for last-level cache (LLC) designs, with low latencies and efficient hardware implementations <ref type="bibr" target="#b3">[Alameldeen and Wood 2004;</ref><ref type="bibr" target="#b38">Ziv et al. 1977</ref><ref type="bibr" target="#b39">Ziv et al. , 1978;;</ref><ref type="bibr" target="#b14">Huffman 1952;</ref><ref type="bibr" target="#b34">Vitter 1987;</ref><ref type="bibr" target="#b23">Pekhimenko et al. 2012]</ref>. Other work has focused on the organization of a compressed cache, which must efficiently compact and retrieve variable-size compressed cache blocks <ref type="bibr" target="#b3">[Alameldeen and Wood 2004;</ref><ref type="bibr" target="#b13">Hallnor and Reinhardt 2005;</ref><ref type="bibr" target="#b17">Kim et al. 2002;</ref><ref type="bibr">Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b;</ref><ref type="bibr" target="#b26">Sardashti et al. 2014]</ref>.</p><p>A compressed cache organization must provide tags to map additional blocks, support variable-size data allocation, and maintain the mappings between tags and data. The tag array must allow a compressed cache to hold more compressed than uncompressed blocks but without incurring large area overheads. Variable-size data allocation allows compressed blocks to be stored in the cache with low internal fragmentation (i.e., low wasted space) but may require expensive recompaction when a block changes and requires more space. In addition, the combination of additional tags and variable-size blocks makes it challenging to maintain the mapping between tags and data. Finally, a compressed cache would ideally enable advanced LLC replacement policies, such as RRIP <ref type="bibr" target="#b16">[Jaleel et al. 2010]</ref>.</p><p>State-of-the-art compressed caches-Decoupled Compressed Cache (DCC) <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref> and Skewed Compressed Cache (SCC) <ref type="bibr" target="#b26">[Sardashti et al. 2014</ref>]-try to achieve some of these goals, although at extra costs and complexities. DCC <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref> proposes tracking compressed blocks at super-block level to reduce tag overhead. DCC uses super-block tags, in which one tag tracks up to four neighboring blocks. DCC compresses each 64-byte block into zero to four 16-byte sub-blocks and uses a decoupled tag-data mapping to allow them to be stored anywhere in a cache set. This flexible sub-block allocation eliminates recompaction overheads when a block size grows but requires the additional area and complexity of backward pointers to maintain the decoupled mapping.</p><p>SCC <ref type="bibr" target="#b26">[Sardashti et al. 2014</ref>] also uses super-block tags but eliminates DCC's backward pointers. SCC makes tag-data mapping simpler by fixing a block's possible positions in the cache. Depending on the compressibility of the data, SCC will map a block to a particular set of cache ways. This limits the effective associativity, thus potentially increasing the cache miss rate. SCC compensates using a skewed-associative design, where each (group of) cache way(s) is indexed using a different hash function <ref type="bibr" target="#b29">[Seznec 1993</ref><ref type="bibr" target="#b31">[Seznec , 2004]]</ref>. Prior results show that skewing roughly doubles the effective cache associativity. Overall, SCC achieves similar performance and energy benefits as DCC but with lower complexity and area overhead.</p><p>However, SCC has several limitations that keep it from being an ideal compressed cache design. Skewed associativity has not found widespread adoption by the industry. Since each cache way is indexed by a different hash function, SCC needs a separate address decoder for each tag way, increasing area and complexity. SCC also cannot use modern cache replacement policies, as skewing eliminates the conventional notion of a cache set. Thus, this makes it difficult or impossible to exploit many of the modern LLC cache replacement policies that have been proposed in the past decade <ref type="bibr" target="#b16">[Jaleel et al. 2010]</ref>.</p><p>In this article, we propose Yet Another Compressed Cache (YACC). The main goal of YACC is to achieve the effectiveness of the DCC and SCC proposals but with a simple and low overhead design. DCC requires changes to the tag array (to add back pointers as well as other state bits) and data array (to access sub-blocks). SCC requires changes only to the tag array but requires separate decoders to implement the different hash functions as well as adding additional state bits. On the other hand, YACC can be used with a largely unmodified tag array and an unmodified data array.</p><p>To achieve these goals, YACC inherits the main sources of efficiencies in DCC and SCC:</p><p>? YACC uses super-block tags (i.e., each tag tracks up to four neighboring blocks) to lower tag area overhead. ? YACC compacts neighboring blocks with similar compression ratios in one data entry (i.e., 64 bytes) and tracks them with a super-block tag. In this way, it can track up to four times more compressed blocks with low tag area overhead. ? YACC keeps a compressed block within a data entry in the cache (i.e., not scattering sub-blocks across a set), eliminating the need for an alignment network.</p><p>On the other hand, YACC addresses the remaining sources of complexities in previous work:</p><p>? Unlike SCC and DCC, YACC's cache layout is similar to conventional caches, with a largely unmodified tag array and unmodified data array. Independent of a block's compression ratio, YACC allows it be allocated in any way of a conventional set. ? Unlike SCC and DCC, YACC's simple, conventional tag mapping allows designers to implement the whole spectrum of recently proposed LLC replacement policies. ? Compared to DCC, YACC uses less area and a simpler access path by eliminating the backward pointers and using a conventional data array. ? Unlike previous variable-size compressed caches that could store sub-blocks of a compressed block across different cache ways, YACC makes cache design simpler by storing a compressed block in one cache way. Thus, similar to a regular cache, on an access to a block, YACC activates only one cache way and thus does not need any extra alignment network. ? Unlike SCC, YACC eliminates the extra area and complexity of skewing.</p><p>? Unlike either DCC or SCC, YACC can also use modern replacement policies, such as RRIP <ref type="bibr" target="#b16">[Jaleel et al. 2010]</ref>, further reducing cache design complexity.</p><p>? YACC also provides some additional mechanisms to improve effective cache efficiencies. For example, YACC allows in-place expansion of a block, if the block size grows and is the only resident of a data entry. In such a case, SCC will invalidate the block and reallocate that to a different data entry, incurring higher overheads. In addition, unlike SCC, which stores blocks of a super-block in order, YACC could store nonadjacent blocks of a super-block together.</p><p>On our set of benchmarks, YACC improves system performance and energy by an average of 8% and 6%, respectively, and up to 26% and 20%, respectively, compared to a regular uncompressed 8MB cache. Similar to DCC or SCC, YACC achieves comparable performance and energy as a conventional cache of twice the size while using far less area.</p><p>This article is organized as follows. We discuss basics of compressed caching and related work in Section 2. Section 3 presents our proposed YACC. Section 4 explains our simulation infrastructure and workloads. In Section 5, we present our evaluations. Section 6 concludes the article.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND AND RELATED WORK</head><p>The past decade and a half has seen several compressed cache proposals. Early work <ref type="bibr" target="#b17">[Kim et al. 2002;</ref><ref type="bibr" target="#b19">Lee et al. 2000</ref>] limits the maximum benefit of compression to a fac-tor of 2 by providing exactly twice as many tags and always allocating at least a half cache block regardless of the data compressibility. More recently, DCC <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref> has proposed using decoupled super-blocks to address these limits, although at some extra cost and complexity due to the extra level of indirection (i.e., backward pointers) and the need to separately manage block and super-block replacements. SCC <ref type="bibr" target="#b26">[Sardashti et al. 2014</ref>] eliminates DCC's backward pointers and simplifies cache replacement but adds the complexity of skewed associativity, complicating the tag array design and limiting the choice of replacement policy. In this section, we summarize the basics of compressed cache designs and discuss these previous works and their trade-offs in more detail. In the next section, we explain our proposed YACC design that addresses these remaining issues with SCC, achieving the same benefits from compression with a much simpler design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Compressed Cache Fundamentals</head><p>In general, for a compressed cache design, designers pick one or more compression algorithms to represent a cache block's data using fewer bits and use a compaction mechanism to store variable-size compressed blocks in the cache. Several compression algorithms have been proposed that trade off low decompression latency (on the cache's critical access path), low complexity (area overhead), and compressibility for small cache blocks <ref type="bibr" target="#b3">[Alameldeen and Wood 2004;</ref><ref type="bibr" target="#b23">Pekhimenko et al. 2012;</ref><ref type="bibr" target="#b9">Chen et al. 2010]</ref>.</p><p>Our work is largely independent of the specific compression algorithm. In this study, we use the C-PACK+Z algorithm <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref>, which is a variation of the C-PACK algorithm <ref type="bibr" target="#b9">[Chen et al. 2010]</ref> with support to detect zero blocks. C-PACK+Z has been shown to have low hardware overheads and decompression latency, with a fairly high compression ratio <ref type="bibr" target="#b9">[Chen et al. 2010;</ref><ref type="bibr">Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref>. C-PACK+Z uses a combination of spatial-value compression (e.g., representing values near zero using fewer bits) and temporal-value compression (e.g., using a 16-entry dictionary to replace (partially) recurring values with a table index). In recent CMOS technologies, CPACK+Z has a decompression latency of nine cycles, which is low enough for use with a compressed LLC. There are other low-overhead algorithms appropriate for cache compression that we expect would give largely equivalent results.</p><p>Given a compression algorithm, a compaction mechanism is needed to fit more compressed blocks in the same space than a regular uncompressed cache. Such a mechanism needs tags to track the additional blocks and a means to map between a block's tag and its corresponding data. The second issue arises because compressed blocks will have different sizes, breaking the traditional direct one-to-one, tag-data mapping of conventional caches. Thus, a compaction mechanism needs to address the following issues: (i) how to provide extra tags in the tag array at a reasonable storage overhead and (ii) how to allocate compressed blocks and provide an efficient tag-data mapping. This work focuses on providing a simple yet effective compaction mechanism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Design Trade-Offs in Compressed Caches</head><p>Previous work has proposed several design alternatives to address these issues, each with different trade-offs. We summarize them in Table <ref type="table">I</ref> and discuss them in the following.</p><p>Super-block versus block tags. In general, there are two main approaches to provide extra tags: simply increasing the number of tags or managing the tag array at super-block granularity. Several designs <ref type="bibr" target="#b3">[Alameldeen and Wood 2004;</ref><ref type="bibr" target="#b17">Kim et al. 2002;</ref><ref type="bibr" target="#b6">Baek et al. 2013]</ref> simply increase the number of tags, such as doubling the number of tags per set. However, doubling the number of tags increases the overall cache size by 6% to 7% for 64-byte blocks, making this approach unattractive for designs that target more than twice as many tags. Alternatively, DCC and SCC use super-block tags to track multiple neighboring blocks (e.g., up to four blocks) with a single tag <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref>. Super-blocks can substantially reduce tag overhead but may suffer significant internal fragmentation for workloads that lack spatial locality.</p><p>Direct versus decoupled tag-data mapping. Given a matched tag, the next step is to locate the corresponding block in the data array. We can categorize existing techniques into (conventional) direct tag-data mapping and decoupled tag-data mapping. Direct mapping associates a tag with a particular data entry, similar to regular uncompressed caches. Conversely, decoupled mapping techniques add a level of indirection and thus require extra metadata to locate a block in the data array. This metadata can either be an explicit pointer (either forward or backward) or encode other information, such as the allocation size, that can be used to compute an offset. The level of indirection in the decoupled mapping may allow multiple blocks to be stored more compactly in the data array but comes with additional area overhead for the metadata and design complexity. Conversely, using direct tag-data mapping makes compressed cache designs simpler, as the matching tag's location uniquely identifies the location of the block in the data array.</p><p>Variable-size versus fixed-sized compressed blocks. Early design proposals supported only a single, fixed-size compressed block (i.e., half of an uncompressed block) even if data were highly compressible. These proposals, which we call FixedC <ref type="bibr" target="#b17">[Kim et al. 2002;</ref><ref type="bibr" target="#b19">Lee et al. 2000]</ref>), facilitate direct tag-data mappings but limit the benefit of compression to at most a factor of 2 and often achieve much less. Conversely, the effective capacity of the cache can be increased significantly using variable-size allocation for compressed blocks. Typically, this involves allocating a variable number of fixed-size sub-blocks (e.g., 8 to 16 bytes each) to hold a block's data. In some designs, sub-blocks must be contiguously allocated (e.g., VSC <ref type="bibr" target="#b3">[Alameldeen and Wood 2004]</ref>), and in others, they may be noncontiguous (e.g., IIC-C <ref type="bibr" target="#b13">[Hallnor and Reinhardt 2005]</ref> and DCC <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref>). Variable-size allocation reduces internal fragmentation and can substantially increase the effective cache capacity.</p><p>Recompaction overhead. Updating a compressed cache block may change the compressibility of its data and thus the amount of space needed to store the block. Hence, an update to a compressed cache may result in the need to write back one or more cache blocks to make room for a new, larger (and potentially uncompressed block). This problem arises with all compressed caches but occurs more frequently with variablesize compressed blocks due to their lower internal fragmentation. It is particularly significant with VSC, which requires that all allocated sub-blocks be contiguous; thus, changing the size of one block may require moving all allocated sub-blocks in a cache set. IIC-C and DCC use forward and backward pointers, respectively, to eliminate unnecessary recompaction overheads. As updates happen frequently in some workloads, unnecessary recompaction can add significant overheads to cache dynamic energy.</p><p>Data alignment. Cache compression complicates the data array access, as some blocks will be uncompressed and others require fetching, and potentially aligning, a variable number of bits, bytes, or sub-blocks. The greater the flexibility in data allocation, the greater the complexity and delay of the resulting alignment network. Most prior work limits the allocation granularity to sub-blocks, ranging in size from 8 to 32 bytes, but differ in how they allocate sub-blocks across a set. VSC and DCC treat the entire cache set as a pool of sub-blocks, eliminating the conventional notion of a (data) cache way. Although VSC requires a complex data alignment network, Sardashti and Wood explained how to extend the AMD Bulldozer cache design to read out sub-blocks without an alignment network <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b</ref>]. However, their technique still requires changes to the data array and only works when the LLC datapath is no larger than the sub-block size. Conversely, SCC and YACC support variable-size compression but always access a full cache block and thus require no changes to the data array or explicit data alignment network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">SCC: A State-of-the-Art Compressed Cache</head><p>SCC <ref type="bibr" target="#b26">[Sardashti et al. 2014</ref>] is a state-of-the-art compressed cache design that picks the best of the alternatives discussed in Section 2.2. SCC uses super-block tags and variable-size compressed blocks to allow many compressed blocks to be packed in the cache while incurring only low tag overhead. Furthermore, SCC uses direct tag-data mapping to eliminate the need for explicit pointers, substantially reducing the amount of additional metadata. Finally, SCC eliminates unnecessary recompaction on updates, never changing a cache block's storage location because a different block changes size.</p><p>SCC does this using a novel sparse super-block tag, which tracks anywhere from one block to all blocks in a super-block, depending on their compressibility. As illustrated in Figure <ref type="figure" target="#fig_0">1</ref>, a single sparse super-block tag can track all four blocks in a super-block, if each is compressible to 16 bytes (e.g., blocks I, J, K, and L); two adjacent blocks, if each is compressible to 32 bytes (e.g., blocks S and T); and only one block, if it is not compressible (e.g., block Y). By allowing variable-size compressed blocks-16, 32, and (uncompressed) 64 bytes-SCC is able to tightly compact blocks and achieve high compression effectiveness.</p><p>Figure <ref type="figure" target="#fig_1">2</ref>(a) shows one set of an SCC tag array and its corresponding dataset for a fourway associative cache. Like a regular cache, SCC has the same number of tags as data entries (e.g., four tags and four data entries per set). However, as shown in Figure <ref type="figure" target="#fig_1">2</ref>(a), each tag entry includes the super-block tag address and per-block coherency/valid states. For this example, compared to a regular cache, each super-block tag entry only requires an additional 7 bits of storage: 9 additional coherency/valid bits for the three additional blocks but 2 fewer tag address bits, as each tag maps a 256-byte (four-block) super-block.</p><p>Figure <ref type="figure" target="#fig_1">2</ref>(b) shows the partitioning of addresses in SCC. Assuming a 64-byte block, the first 5 bits of address is used to access a particular byte in a block. The next 2 bits (block ID) are then used to distinguish a block in a four-block super-block. As with a regular cache, higher-order bits will be used to index a set and as the tag address. As we explain later, for this mapping, SCC will use A 9 A 8 for mapping a block to some ways.</p><p>Unlike a regular cache that can allocate a block in any cache way, SCC must use a block's compressibility to determine where to allocate it.</p><formula xml:id="formula_0">W 1 W 0 = A 9 A 8 ? CF 1 CF 0 (1)</formula><p>Equation ( <ref type="formula">1</ref>) shows that the block compression factor (CF 1 CF 0 ) is exclusive-ORed with 2 address bits (A 9 A 8 ) to select the appropriate way group (W 1 W 0 ). The block compression factor is zero if the block is not compressible (CF 1 CF 0 = 0b00), one if compressible to 32 bytes (CF 1 CF 0 = 0b01), and two or three if compressible to 16 bytes (CF 1 CF 0 = 0b1X). 1 Blocks compressible to 16 bytes will map to two-way groups since CF 0 , and thus W 0 , are "don't cares." Because SCC uses address bits A 9 A 8 to select the way group, it does not use them as part of the set index. This also ensures that even if all cache blocks are uncompressible (CF == 0), they will spread out among all cache ways.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> illustrates the interaction of skewing with compression. Block A maps to way group 0 (four ways), way group 1 (four ways), or way groups 2 and 3 (eight ways), when it compresses to 32 bytes, 64 bytes (uncompressed), and 16 bytes, respectively.</p><formula xml:id="formula_1">Set Index = h 0 ({A 49 -A 10 , A 7 A 6 }) if CF == 0 h 1 ({A 49 -A 10 , A 7 }) if CF == 1 h 2 ({A 49 -A 10 }) i fC F== 2 or 3 (2)</formula><p>SCC uses different set index functions to prevent conflicts between blocks in the same super-block. Just using bit selection (e.g., the consecutive bits beginning with A 10 ) would result in all blocks in the same super-block mapping to the same set in a way group, resulting in unnecessary conflicts. For example, if none of the blocks were compressible, then all uncompressed blocks would compete for the entries in the selected way group (in Figure <ref type="figure" target="#fig_1">2</ref>). To prevent this, SCC uses the index hash functions shown in Equation ( <ref type="formula">2</ref>), which draw address bits from the block ID for the less compressible blocks. These functions map neighboring blocks to the same set only if they can share a data entry (based on their compression factor). SCC also uses different hash functions <ref type="bibr" target="#b31">[Seznec 2004</ref>] for different ways in the same way group to further reduce the possibility of conflicts.</p><p>Within a 64-byte data entry, a compressed block's location depends only on its compression factor and address, eliminating the need for extra metadata such as forward or backward pointers. Equation (3) shows the function to compute the byte offset for a compressed block within a data entry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Byte Offset</head><formula xml:id="formula_2">= none if CF == 0 A 6 &lt;&lt; 5 if CF== 1 A 7 A 6 &lt;&lt; 4 if CF == 2 or 3 (3)</formula><p>On a cache lookup, SCC must check all of the block's corresponding positions in all cache ways since the block's compressibility is not known. To determine which index hash function to use for each way, SCC uses Equation (4), the inverse of Equation (1).</p><p>For example, in Figure <ref type="figure" target="#fig_1">2</ref>, when accessing block A, the tag entries in set #1 of way groups #2 and #3, set #2 of way group #1, and set #6 of way group #0 (i.e., all hatched red tag entries) are checked for a possible match. A cache hit occurs if its encompassing super-block is present (i.e., a sparse super-block tag match), and the block state is valid. On a read hit, SCC uses the compression factor and appropriate address bits (using Equation ( <ref type="formula">3</ref>)) to determine which of the corresponding sub-blocks should be read from the data array.</p><formula xml:id="formula_3">CF 1 CF 0 = A 9 A 8 ? W 1 W 0 (4)</formula><p>SCC achieves performance comparable to the more complex DCC algorithm, but it does so with significantly less metadata overhead due to the elimination of the backward pointer metadata. SCC also simplifies the replacement policy, compared to DCC, as it always replaces an entire sparse super-block. Like DCC, SCC must decompress compressed blocks before writing them back to memory and uses a perbank write-back buffer to reduce contention for the bank's decompression hardware. Because SCC has multiple banks, and thus multiple decompressors, we observe little contention in practice.</p><p>Yet Another Compressed Cache 27:9</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Limitations of SCC</head><p>Despite being an improvement over DCC, SCC has several limitations that keep it from being an ideal compressed cache design. We discuss these in turn next.</p><p>Limited effective associativity. SCC limits the effective associativity of the cache. This occurs because SCC uses a block's compression factor to determine in which subset of ways it should be allocated. Thus, in a 16-way SCC, a particular block may only be allocated to one of four ways (or eight ways if compressible to 16 bytes), substantially reducing the effective associativity of the cache. Additional skewing (within a way group) can help reduce conflict misses but adds additional complexity and overheads. Furthermore, additional intra-way group skewing does not provide uniform benefit for all workloads.</p><p>Multiple tag decoders. Address lookups to a regular, nonskewed cache require only a single address decoder to select the appropriate set in the tag array. Thus, all tags can be checked in parallel with one decode operation. Skewed-associative caches need a separate decoder for each hash function. Thus, SCC requires a separate decoder per way group (e.g., one per compression factor). To address intra-way group skewing (in addition to the inter-way groups skewing based on compression factor), SCC would need one decoder per cache way. Increasing the number of decoders increases the area, static, and dynamic energy of the tag array.</p><p>Constrained replacement policies. Ideally, a compressed cache should be able to use any replacement policy; however, that is not the case for many proposals. DCC must make separate but dependent decisions on when to replace blocks and super-blocks. For example, allocating space for a single cache block could result in DCC replacing multiple blocks and multiple super-blocks. SCC simplifies replacement compared to DCC by always replacing an entire super-block. However, it inherits all of the replacement issues associated with skewed associative caches. Skewing limits the choice of replacement policy because each cache way (or way group) uses a different index, eliminating the traditional notion of a cache set. Thus, skewed-associative caches (including SCC) are not directly compatible with set-based replacement policies (e.g., conventional pseudo-LRU) and modern scan-resistant replacement policies (e.g., RRIP). Skewed-associative caches can use the replacement policy from Zcache <ref type="bibr" target="#b25">[Sanchez and Kozyrakis 2010]</ref>, although at the expense of significant complexity.</p><p>Difficult to understand behavior. Skewed-associative caches tend to eliminate conflict misses on average <ref type="bibr" target="#b29">[Seznec 1993</ref>], but the multiple hash functions make it difficult to guarantee that two addresses will not conflict. Thus, a compiler or sophisticated programmer may find it difficult to explicitly manage cache capacity, as is often done when tiling scientific workloads.</p><p>Despite the potential for skewed-associative caches to reduce conflict misses, they have not-to our knowledge-been adopted in commercial LLCs. We believe that this reluctance stems, at least in part, from a combination of the last three limitations discussed earlier. And, to the extent that this reluctance continues, we find this compelling motivation to develop a nonskewed version of SCC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">YACC : YET ANOTHER COMPRESSED CACHE</head><p>YACC is a new compressed cache design that seeks to preserve the good aspects of SCC while eliminating the limitations associated with skewing. YACC essentially de-skews SCC, increasing the effective associativity to that of a conventional cache. In addition to simplifying the tag array, YACC allows the use of any replacement policy and (by eliminating skewing) leads to more predictable behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">YACC Architecture</head><p>Figure <ref type="figure">3</ref>(a) shows a high-level overview of an eight-way associative YACC design. Like SCC, YACC uses sparse super-block tags to exploit both spatial locality (i.e., there are many neighboring blocks in the cache) and compression locality (i.e., neighboring blocks tend to have similar compressibility). YACC stores neighboring blocks in one data entry if they have similar compressibility and could fit in one data entry.</p><p>Figure <ref type="figure">3</ref>(b) shows how YACC partitions the address. For the sake of simplicity, throughout this article, the (uncompressed) data block size is 64 bytes and superblocks have four blocks. Thus, the lowest 6 bits in the address (bits A 5 -A 0 , labeled Byte in Figure <ref type="figure">3(b)</ref>) refer to the byte offset in a block. The next 2 address bits (bits A 7 -A 6 , labeled Blk ID in Figure <ref type="figure">3(b)</ref>) identify which block is accessed in a super-block.</p><p>Unlike SCC's skewed-associative design, YACC keeps the tag-data mapping simple by using a simple bit-selection hash function to select a conventional set. Figure <ref type="figure">3(b)</ref> illustrates that YACC uses the bits just above the block ID to index both the tag and data arrays. Cache hits are detected by comparing the super-block tag and checking the corresponding block's 3-bit coherence/valid state.</p><p>YACC eliminates the implementation issues that make DCC and SCC less than ideal designs. YACC uses a conventional super-block tag array and an unmodified data array. In contrast, DCC requires significant changes to both the tag array (to add back pointers as well as other state bits) and data array (to access sub-blocks). SCC requires changes to only the tag array but requires separate decoders to implement the different hash functions and add additional state bits. YACC only requires the addition of a few state bits to the tag array, which is a relatively simple change. We will next discuss YACC design in more detail.</p><p>3.1.1 YACC Tag Format. Like SCC, YACC uses sparse super-block tags <ref type="bibr" target="#b26">[Sardashti et al. 2014]</ref> to map the blocks that are compressed in the corresponding data. In Figure <ref type="figure">3(a)</ref>, blocks E, F, G, and H of super-block SB2 are each compressible to one 16-byte sub-block and YACC stores all four in one 64-byte data entry. Thus, this implementation of YACC has the potential to increase the cache capacity by a factor of 4. Conversely, blocks M and P of super-block SB4 are each compressible only to 32-bytes, and blocks O and N are not compressible; therefore, SB4 requires three separate data entries to hold its blocks: one for blocks M and P and one each for blocks O and N. Super-block SB1 represents the worst case, where each of its blocks A, B, C, and D require a separate data entry. Note that since all blocks in a super-block map to the same set, workloads that exhibit spatial locality but are not compressible will have less effective associativity.</p><p>Figure <ref type="figure">3(c-e</ref>) illustrates the structure of YACC tag entries. Each sparse super-block tag includes metadata that tightly encodes which blocks of a super-block are stored in the corresponding data entry. Each tag includes the super-block tag address, the compression factor of the blocks, and per-block coherency/valid states. To represent this information with minimum bits, YACC uses a different format for each compression factor and even exploits the "don't care" in the compression factor encoding for blocks compressible to 16 bytes. Specifically, Figure <ref type="figure">3</ref>(c) shows that only CF1 is stored in this important case; this is possible since CF0 is a "don't care." The remaining 12 bits encode a 3-bit coherence state for each of the four sub-blocks. For example, Figure <ref type="figure">3(a)</ref> shows that the tag for super-block SB2 has all four block states set to "V," indicating that each of blocks E, F, G, and H are valid and stored in the same data entry. If CF1 is not 1, then the next (less significant) bit is CF0, which differentiates between the uncompressed and 32-byte compressed formats. Figure <ref type="figure">3</ref>(d) illustrates the case that CF1 = 0 and CF0 = 1, and thus the tag entry can map two data blocks compressed to 32 bytes each. Note that in addition to the two 3-bit coherence fields, this format also has two 2-bit index fields that identify which blocks are compressed. This allows YACC Fig. <ref type="figure">3</ref>. YACC architecture. In an eight-way associative cache, YACC associates one tag entry (sparse superblock tag) per data entry (i.e., 64 bytes). Each tag entry tracks up to four neighboring blocks if they have similar compressibility and could fit in one 64-byte data entry (e.g., SB2). If neighboring blocks have different levels of compressibility, they would be allocated in different data entries in the same set (e.g., in SB4, M and P are stored together, whereas N and O are allocated separately). For each data entry, the corresponding tag indicates which blocks are present.</p><p>to store nonadjacent blocks from the same super-block in a single entry, a significant advantage compared to SCC, which requires that they be adjacent. This is illustrated in Figure <ref type="figure">3</ref>(a) for blocks M and P of super-block SB2; block M has index 3 and block P has index 0. Finally, Figure <ref type="figure">3</ref>(e) illustrates the case that the block is uncompressible, with CF1 = 0 and CF0 = 0. In this case, there is a single coherence state field and a single block index. Figure <ref type="figure">3</ref>(a) shows that the tags for blocks A or D use this format.</p><p>3.1.2 How to Allocate Compressed Blocks? Like SCC, YACC uses a direct tag-data mapping to keep compressed block allocation simple. It compresses blocks into a power of two numbers of sub-blocks (e.g., one, two, or four 16-byte sub-blocks). It then stores blocks with the same compression factor in a single data entry if they fit (e.g., blocks E, F, G, and H of SB2). Otherwise, YACC stores them in one or more other data entries in the same dataset. For example, blocks I, J, and L from SB3 are each compressible to half a block. YACC fits I and J in one data entry (way 3 of set 0) and stores L in a separate data entry in the same set (way 0 of set 0). Later, if we access block K from SB3, YACC could compress and store it in the same data entry as L if it is compressible to 32 bytes.</p><p>In case blocks belonging to the same super-block are not compressible, such as blocks A, B, C, and D of SB1, YACC stores these blocks separately in different data entries (e.g., in ways 7, 5, 2, and 1) in the same cache set (set #3). In this way, these blocks compete for the same set in the cache. Thus, an application featuring low data compressibility and high spatial locality might suffer from a limited visible associativity, as we will discuss in Section 5.</p><p>No cache skewing. A major goal of YACC is to eliminate the use of skewed associativity, which complicates the design of SCC. In SCC, a block is mapped to a particular way group depending on its address and compressibility. Because this limits the effective associativity (e.g., an uncompressed block can only map to one way group), additional skewing is done within a way group.</p><p>Figure <ref type="figure" target="#fig_2">4</ref> presents a high-level comparison of SCC and YACC. On a lookup, where the block size is unknown, SCC checks all possible positions of the block (eight in the illustrated eight-way associative cache). SCC skews each cache way with a different hash function. For example, in Figure <ref type="figure" target="#fig_2">4</ref>(b), the colored blocks (yellow and red) show the tags being checked on a lookup. Note that because of skewing, each tag is in a different row. Therefore, SCC requires eight decoders on the tag array, one per cache way. This complicates the tag array design, area, and possibly layout and routing. On the other hand, YACC stores a block in any cache way in a given cache set (indexed by superblock index bits). For example, in Figure <ref type="figure" target="#fig_2">4</ref>(a), on a lookup, all tags of set 1 (in yellow and red) will be checked for a possible hit. In this way, YACC uses a conventional tag array design, only requiring one decoder for the whole tag array. Note that the extra decoders in SCC are only needed for the tag array and not the data array. In both SCC and YACC, when a tag matches, we will then index and access the corresponding data entry in the data array (colored in red in Figure <ref type="figure" target="#fig_2">4</ref>).</p><p>In addition to complicating tag array design, skewing would also limit the choice of replacement policy. In SCC, any block could map to a different set of rows. Thus, there is no fixed notion of a cache set, making it difficult to employ many replacement policies. On the other hand, YACC can use any replacement policy, such as RRIP <ref type="bibr" target="#b16">[Jaleel et al. 2010]</ref>.</p><p>In-place block expansion. YACC allows in-place expansion of a block on a write-back from lower cache levels if the block size grows and it is the only resident of a data entry. For example, if block L's size grows so that it becomes uncompressible (requiring 64 bytes), YACC will store it in the same data entry. It only changes its status in the Yet Another Cache 27:13 corresponding tag. SCC will need to invalidate and reallocate that block to a different data entry on a block update.</p><p>Storing nonadjacent blocks together. To compact more blocks, YACC does not necessarily compact blocks of a super-block in the same order. For example, blocks M and P from SB4 are compressible to 32 bytes each. Although they are not contiguous neighbors, YACC would still pack them together. In previous work, SCC did not support this mode, as it stored blocks in strict order. In a similar situation, SCC would map these blocks to a different entry and allocate a data entry for each. For example, SCC would allocate M and P in different data entries using 128 bytes (2 * 64 bytes) instead of 64 bytes (2 * 32 bytes) in YACC. To locate these blocks, YACC encodes the tag entry differently for difference compression factors (shown in Figure <ref type="figure">3</ref>). The tag entry includes block ID (2 bits) and coherence state (3 bits) of the blocks stored into or the upper half of the corresponding data entry. For example, the tag entry in way #4 of set #7 indicates that block #3 of SB4 (block M) and block #1 of SB4 (block P) are stored in upper and lower halves of the corresponding data entry, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">YACC Cache Operations</head><p>3.2.1 Cache Read. Figure <ref type="figure" target="#fig_3">5</ref> shows a block diagram of main cache operations in YACC. On a cache read, YACC indexes a set of the tag array using super-block index bits from the address. For example, in Figure <ref type="figure">3</ref>, to read block A of SB1, YACC will index set #3. It then checks all tag entries in that set for a possible hit. A cache hit occurs if the tag address matches and the corresponding coherence state is valid. For example, YACC finds block A in way #7 of set #3, as the super-block tag address in that tag entry matches the SB1 tag address and the tag entry indicates that block A is valid (block #3 exists in the Valid state).</p><p>Note that since YACC maps all blocks of a super-block to the same set, it is possible to have more than one tag entry matching the super-block tag address but only a single corresponding valid tag match. For example, the tag entry in way #1 of set #3 also tracks part of SB1 (i.e., block D), so it also has the same super-block tag address, but block A is invalid. On a read hit, YACC would read out and decompress the corresponding sub-blocks from the data array. On a cache miss, YACC would allocate the block in the cache. set of the tag array using the super-block index bits from the address. In that set, YACC first tries to fit the block in an already existing SB. To do so, YACC first checks for a tag entry with the same super-block tag address and compression factor. If so, it then checks to see if the block can fit in the corresponding data entry. For example, YACC can allocate block K (from SB3) in the same entry as block L if K is also compressible to half. On a write-back (or update) to an existing block, if the block size grows, YACC might need to invalidate the previous version of this block before reallocating it. If the block is the only block in that entry, such as block L, YACC will not invalidate or reallocate it. It simply stores the block in the same entry and only updates the tag. Otherwise, if it does not fit in its previous entry, it would invalidate and allocate it in the cache as just explained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Cache</head><p>In case there is no matching tag entry with enough space for the accessing block, YACC needs to replace a victim sparse super-block first before allocating this block. Finding the victim tag is straightforward and basically similar to a regular cache. Depending on the replacement policy, it finds the victim tag and evicts the blocks resident in its entry. For example, if YACC picks way #4 of set #7 as the victim, it would evict blocks M and P of SB4 and free that entry. Note that other blocks of SB4 (i.e., blocks N and O), which are not resident of this particular entry, will still stay in the cache.</p><p>When replacing a victim super-block, similar to a regular cache, YACC writes back dirty blocks to the main memory. Since we are assuming that blocks are stored in uncompressed format in the memory, YACC needs to decompress compressed blocks when evicting them. Similar to DCC and SCC, YACC uses one compression unit and one decompression unit per cache bank. Thus, while decompressing and evicting blocks, other cache banks could still be used. In addition, when evicting a super-block, we can read and copy the whole data block (64 bytes) once to a local buffer, then decompress and send its blocks to memory in the background.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">METHODOLOGY</head><p>To evaluate YACC, we use the same evaluation framework that was used to evaluate SCC and DCC-the full-system cycle-accurate GEMS simulator <ref type="bibr" target="#b20">[Martin et al. 2005</ref>]. We model YACC with an eight-core multicore system with OOO cores, per-core private L1 and L2 caches, and one shared LLC (L3). We implement YACC and other compressed caches at L3. Table <ref type="table">II</ref> shows the main parameters. We use 64-byte cache block sizes. For YACC, SCC <ref type="bibr" target="#b26">[Sardashti et al. 2014]</ref> and DCC <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref>, we use four-block super-blocks (each tag tracks one to four neighbors) and 16-byte sub-blocks (i.e., each block compresses from zero to four sub-blocks).</p><p>We use CACTI 6.5 <ref type="bibr" target="#b8">[CACTI 2008]</ref> to model power at 32nm. We also use a detailed DRAM power model developed based on the Micron Corporation power model  <ref type="table">II</ref>. In this section, we report total system energy that includes energy consumption of processors (cores and caches), an on-chip network (using Orion), and off-chip memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Applications</head><p>We use several applications with different characteristics from SPEC OMP <ref type="bibr" target="#b5">[Aslot et al. 2001]</ref>, PARSEC <ref type="bibr" target="#b7">[Bienia and Li 2009]</ref>, commercial workloads <ref type="bibr">[Alameldeen et al. 2003</ref>], and SPEC CPU 2006. From SPEC CPU 2006 benchmarks, we run mixes (mix1 to mix8) of multiprogrammed workloads that are memory-and compute bound. For example, for omnetpp-lbm, we run four copies of each benchmark. Table <ref type="table" target="#tab_2">III</ref> shows our applications. We classify these workloads into low memory intensive, medium memory intensive, and high memory intensive based on their LLC misses per kilo of executed instructions (MPKI) for the Baseline configuration (a regular uncompressed LLC). We classify a workload as low memory intensive if LLC MPKI is lower than one, as medium memory intensive if LLC MPKI is between one and five, and as high memory intensive if MPKI is greater than five.</p><p>Figure <ref type="figure" target="#fig_4">6</ref> shows the distribution of neighboring blocks in a conventional LLC with a tag per 64-byte block. Neighboring blocks are defined as those in a four-block aligned super-block (i.e., aligned 256-byte region). The graph shows the fraction of blocks that are part of a Quad (all four blocks in a super-block co-reside in the cache), Trios (three blocks out of four co-reside), Pairs (two blocks out of four co-reside), and Singletons (only one block out of four resides in the cache). Pairs and Trios are not necessarily contiguous blocks but represent two or three blocks, respectively, that could share a super-block tag. Although access patterns differ, the majority of cache blocks reside as part of a Quad, Trio, or Pair. For applications with streaming access patterns (e.g., mgrid) Quads account for essentially all blocks. Other workloads exhibit up to 29%  singletons (canneal), but Quads or Trios account for greater than 50% of blocks for all but two of our workloads (canneal and gcc).</p><p>We run each workload for more than 500 million instructions (1 billion for several workloads). We use warmed-up caches and fast forward for about 100 million instructions. To address workload variability, we simulate each workload for a fixed number of work units (e.g., transactions) and report the average over multiple runs <ref type="bibr">[Alameldeen and Wood 2003]</ref>. Table III also shows the compression ratio (original size/compressed size) for each workload using the C-PACK+Z algorithm <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b;</ref><ref type="bibr" target="#b9">Chen et al. 2010]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Configurations</head><p>We evaluate the following configurations for the LLC:</p><p>? Baseline is a conventional uncompressed 16-way 8MB LLC.</p><p>? 2X Baseline is a conventional 32-way 16MB LLC.</p><p>? DCC models <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref> with four-block super-blocks and 16-byte sub-blocks. We use an LRU-based replacement algorithm for both superblock and block-level replacements. In addition to latencies of the L3 cache shown in Table <ref type="table">II</ref>, DCC adds one extra cycle to cache access latency for its sub-block selection logic <ref type="bibr">[Sardashti and</ref><ref type="bibr">Wood 2013a, 2013b]</ref>. We consider this extra overhead in our simulation. ? SCC models <ref type="bibr" target="#b26">[Sardashti et al. 2014]</ref> with four-block super-blocks and 16-byte subblocks. We use an LRU-based replacement algorithm for super-block replacements. ? YACC models our proposal with four-block super-blocks and 16-byte sub-blocks. We also use an LRU-based replacement algorithm for super-block replacements. Unlike DCC, SCC and YACC do not add additional latency to cache accesses, as they use a direct tag-data mapping. ? Baseline-RRIP is also an uncompressed eight-way 8MB LLC, but we use RRIP for the replacement policy <ref type="bibr" target="#b16">[Jaleel et al. 2010</ref>]. ? YACC-RRIP is similar to the YACC (or YACC LRU) configuration, but we use RRIP for the replacement policy <ref type="bibr" target="#b16">[Jaleel et al. 2010</ref>].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Hardware Overheads</head><p>Table <ref type="table" target="#tab_4">IV</ref> shows the area overhead of YACC and state-of-the-art DCC and SCC. We assume a 48-bit physical address space. Compressed caches use the same data array space but usually increase tag array space to track more blocks. In the table, we show the number of bits needed per set in a 16-way cache. We categorize tag space into bits needed to represent tags (e.g., tag addresses and LRU information), extra metadata needed for coherence information, and extra metadata for compression (e.g., compression factor).</p><p>State-of-the-art DCC uses super-block tags to track more blocks at lower tag overhead. It uses the same number of tags, but each tracks up to four blocks of a super-block. The tags use fewer bits for the matching address (27-bit super-block tags vs. 29-bit regular tags). DCC keeps LRU information separately per super-blocks (4 bits to find the LRU super-block) and blocks (6 bits to find the LRU block). Since DCC can fit up to four times more blocks in the same space, it keeps four times more coherence state (3 bits assuming MOESI). It also keeps 1 valid bit per super-block. DCC decouples tagdata mapping, requiring extra metadata to hold the backward pointers that identify a block's location. DCC keeps one 6-bit backward pointer entry per sub-block in a set. In addition, it stores 1 bit in the tag per block showing if the block is compressible or not. Overall, DCC more than doubles tag area, incurring about 6.7% area overhead on total LLC area (tag array and data array).</p><p>SCC cuts down on these extra tag bits. SCC keeps LRU information for super-blocks only and completely eliminates extra compression metadata. In this way, SCC increases tag array area by about 24% and total LLC area by only 1.5%. Here we are only counting the overheads in terms of extra bits stored. SCC, however, requires 16 tag decoders instead of one, which we are not counting here.</p><p>In terms of tag and metadata bits stored per set, YACC is quite similar to SCC. The only difference is that it keeps 1 extra bit per super-block, representing if the blocks are compressible to a factor of 4 (CF = 4?). Compared to a conventional cache, YACC uses only 8 extra bits (10 extra coherence bits -2 fewer tag address bits) per tag entry, as also shown in Table <ref type="table" target="#tab_4">IV</ref>. Unlike SCC, YACC does not change tag array layout; it requires only one tag decoder and no hash function hardware to address the cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Cache Effective Capacity</head><p>In general, compressed caches increase cache utilization by fitting more blocks in compressed format in the same space as an uncompressed cache. Figure <ref type="figure" target="#fig_5">7</ref> shows the effective capacity of different designs normalized to Baseline. To calculate the effective capacity of a cache, we count the number of valid blocks in the cache when allocating a new block and report the average number over all counts. In the figure, we report the effective capacity of each configuration, normalized to Baseline. For an ideal compressed cache, the effective capacity should be the same as the average compression ratio for each benchmark. However, low memory intensive workloads with even good compressibility, such as ammp, do not have that large working set. That is why even  when doubling the cache size (2X Baseline), these workloads cannot use the whole cache (i.e., average normalized capacity of 1.6 with 2X Baseline).</p><p>By packing compressed blocks, YACC improves effective capacity by up to 3.5 times for mix3 and on average by 84%. YACC on average improves cache effective capacity similar to 2X Baseline while it has almost half the area. Among our workloads, high memory intensive workloads benefit the most from YACC and in general compression. YACC increases cache capacity more than twice for these workloads.</p><p>Although similar to SCC, YACC compacts neighboring blocks with similar compressibility and improves effective capacity over YACC. YACC proposes in-place expansion, avoiding extra replacements when a block is the only resident in one data entry. It also packs two noncontiguous neighbors (like M and P in Figure <ref type="figure">3</ref>) with a CF of two in one entry. Thus, due to these optimizations, YACC achieves better effective capacity over SCC.</p><p>In previous work, DCC provided higher normalized effective capacity than SCC and YACC. In SCC and YACC, only neighbors with similar compressibility share the space. In DCC, however, blocks can be stored anywhere in the cache, so the space freed by compressing one block can be used to store a non-neighboring block. Thus, overall, DCC provides the highest effective capacity but at the cost of more than four times the area overhead than YACC and SCC and a more complex data access path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Cache Miss Rate</head><p>By improving cache effective capacity, compressed caches tend to reduce the cache miss rate. Figure <ref type="figure" target="#fig_6">8</ref> shows the LLC MPKI for different cache designs. When doubling the cache size, 2X Baseline improves LLC MPKI by an average of 15% and up to 40% for apache. However, these benefits come at a twice as large LLC area, which is already one of the largest on-chip components.</p><p>YACC improves LLC MPKI by compressing blocks. It achieves most of the benefits of 2X Baseline, with about half the area. YACC improves LLC MPKI by about 10% on average and up to 30%. In previous work, YACC performed similar to SCC. SCC uses compression but limits cache effective associativity by only mapping a block into 4 out of 16 cache ways. On the other hand, it employs skewing to compensate for possible loss of associativity. Thus, for some workloads, such as apache, skewing combined with compression can improve the overall miss rate, achieving lower LLC MPKI than  YACC. In others, such as mix5, skewing would not compensate lower associativity in SCC. DCC lowers MPKI more than YACC and SCC but at higher design complexity and overheads. Also note that on a few applications (applu, mix3, freq), doubling the cache size has virtually no impact on the miss rate; therefore, a large compression factor on mix3 does not significantly help to reduce the misprediction rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">System Performance and Energy</head><p>By improving cache effective capacity and lowering the cache miss rate, compressed caches can improve system performance and energy. Figures 9 and 10 show system performance and energy of different cache designs. We report total energy of cores, caches, on-chip network, and main memory, including both leakage and dynamic energy.</p><p>YACC improves performance by up to 26% and on average 8%. It similarly lowers total energy by up to 20% and on average 6% by reducing the number of accesses to main memory and lowering the runtime. Overall, cache-sensitive applications, for which miss rate reduces when increasing the cache size, benefit the most from compression. Among our evaluated workloads, many applications from the medium and high memory intensive category, such as jbb, apch, and mix8, benefit the most from YACC. On the other hand, cache-insensitive workloads, which include low memory intensive workloads as well as some with a very high miss rate, would not benefit from YACC. For example, libquantum (mix3), which has about 43 MPKI, does not benefit from compression despite its high compressibility.</p><p>YACC achieves similar performance and energy benefits as 2X Baseline and previous works (SCC and DCC) with lower design complexity and overheads. In general, memory-intensive workloads benefit the most from a larger cache capacity and compression. YACC achieves on average a 12% shorter runtime for high memory intensive workloads, such as apache and zeus. On the other hand, it achieves the lowest benefit (2% better performance on average) for low and medium memory intensive workloads, such as equake (equa) and wupwise (wupw).</p><p>Figure <ref type="figure" target="#fig_9">11</ref>(b) shows how energy breakdown changes over Baseline in YACC. For example, in ammp, using compression would hurt the performance for about 3%. This would cause a similar increase in static energy of the system. In addition to add, because of compression and decompression, we will have about 1% higher dynamic energy in caches. Overall, we see about 4% higher energy usage for ammp. On the other hand, for mix8, where we have about 26% lower runtime, we see an overall of 19% lower energy. For this application, in addition to saving static energy, the majority of benefit (11% out of 19%) comes from lowering the dynamic energy of off-chip memory by reducing the L3 cache miss rate.</p><p>YACC achieves similar performance and energy benefits as DCC and SCC, but YACC has a simpler design that can easily employ any replacement policy. In Figure <ref type="figure" target="#fig_10">12</ref>, we illustrate the performance of YACC when using the RRIP replacement policy <ref type="bibr" target="#b16">[Jaleel et al. 2010]</ref>. For this experiment, we use static RRIP and 2 bits per super-block tag to store four possible re-reference prediction values (RRPV). When allocating a super-block tag for the first time, we set its RRPV to 2 (3-1). On a hit, we promote that super-block tag by setting its RRPV to 0. When replacing, YACC-RRIP would pick the super-block tag with an RRPV of 3. We tested YACC-RRIP with 3-bit RRPV (eight  levels) as well. In addition, we considered promoting a super-block tag when inserting a block to that data entry. However, those configurations performed similar to what we presented here. For Baseline-RRIP, we use a similar configuration. We use 2-bit RRPV per block and promote on cache hits.</p><p>As shown in Figure <ref type="figure" target="#fig_10">12</ref>, when using RRIP, on average, YACC (YACC-RRIP) performs similar to using LRU (YACC-LRU). A regular uncompressed cache with an RRIP replacement policy (Baseline-RRIP) also performs, on average, similar to Baseline-LRU, improving performance for some workloads (e.g., zeus) while lowering or not impacting performance for others (e.g., mix1 and ammp). Overall, this experiment shows that YACC can use alternative replacement policies while providing its benefits from compression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS</head><p>In the past few years, several proposals have addressed many issues preventing the effective hardware implementation of compressed caches. Our previous proposals, DCC and SCC, reduce the extra hardware complexity induced for storing and retrieving compressed data blocks. Compared to SCC <ref type="bibr" target="#b26">[Sardashti et al. 2014]</ref>, we addressed most of the issues of the compaction in caches: very limited tag and metadata overhead, direct tag-data matching, and no need for defragmentation. However, this comes at the cost of using skewing that induces using one decoder per tag way and has not been widely adopted by the industry.</p><p>In this article, we introduce YACC-a simple hardware compressed cache design achieving the high benefits of previous proposals while significantly simplifying the design. We show that YACC achieves performance and energy benefits comparable to that of a conventional cache with twice the capacity and previous works (DCC and SCC). However, YACC does this with lower complexity (no skewing) and very limited storage overheads (only 8 extra tag bits per 64 bytes of storage).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Skewed Compressed Cache.</figDesc><graphic url="image-1.png" coords="6,89.87,95.21,344.78,148.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. (a) One set of SCC. (b) SCC address partitioning.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Cache physical layout with YACC (a) and SCC (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. YACC cache operations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Distribution of cache blocks in LLC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Normalized LLC effective size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Normalized LLC miss rate (MPKI). Applications are ordered based on their Baseline MPKI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Normalized performance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Normalized total energy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. (a) Energy breakdown of Baseline configuration. (b) Energy breakdown of YACC normalized to Baseline configuration.</figDesc><graphic url="image-2.png" coords="22,50.57,85.45,384.00,249.12" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. YACC performance using RRIP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Allocate and Cache Replacement. On a cache allocate (e.g., caused by a cache miss), a cache write, or write-back, YACC first compresses the block. It then indexes a</figDesc><table><row><cell>Yet Another Compressed Cache</cell><cell>27:15</cell></row><row><cell></cell><cell>Table II. Simulation Parameters</cell></row><row><cell>Processors</cell><cell>8, 3.2GHz, 4-wide issue, out-of-order</cell></row><row><cell>L1 Caches</cell><cell>32KB 8-way split, 2 cycles</cell></row><row><cell>L2 Caches</cell><cell>256KB 8-way, 10 cycles</cell></row><row><cell>L3 Caches</cell><cell>8MB 16-way, 8 banks, 27 cycles</cell></row><row><cell></cell><cell>? 4GB, 16 banks, 800MHz DDR3</cell></row><row><cell>Memory</cell><cell>? 60.35nJ per read, 66.5nJ per write, and</cell></row><row><cell></cell><cell>4.25W static power</cell></row><row><cell>Block Size</cell><cell>64 bytes</cell></row><row><cell cols="2">Super-Block Size 4-block super-blocks</cell></row><row><cell>Sub-Block Size</cell><cell>16 bytes</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table III .</head><label>III</label><figDesc>Applications</figDesc><table><row><cell></cell><cell>Compression</cell><cell>Baseline LLC</cell><cell></cell></row><row><cell>Application</cell><cell>Ratio</cell><cell>MPKI</cell><cell>Category</cell></row><row><cell>ammp</cell><cell>3.0</cell><cell>0.01</cell><cell></cell></row><row><cell>blackscholes canneal</cell><cell>4.0 2.8</cell><cell>0.13 0.51</cell><cell>Low memory intensive</cell></row><row><cell>freqmine</cell><cell>3.3</cell><cell>0.65</cell><cell></cell></row><row><cell>bzip2 (mix1)</cell><cell>4.0</cell><cell>1.7</cell><cell></cell></row><row><cell>equake</cell><cell>5.0</cell><cell>2.2</cell><cell></cell></row><row><cell>oltp</cell><cell>2.0</cell><cell>2.3</cell><cell>Medium memory intensive</cell></row><row><cell>jbb</cell><cell>2.6</cell><cell>2.7</cell><cell></cell></row><row><cell>wupwise</cell><cell>1.3</cell><cell>4.3</cell><cell></cell></row><row><cell>gcc-omnetpp-mcf-bwaves-lbm-milc-cactus-bzip (mix7)</cell><cell>3.9</cell><cell>8.4</cell><cell></cell></row><row><cell>libquantum-bzip2 (mix2)</cell><cell>3.7</cell><cell>9.3</cell><cell></cell></row><row><cell>astar-bwaves (mix5)</cell><cell>3.8</cell><cell>9.3</cell><cell></cell></row><row><cell>zeus gcc-166 (mix4)</cell><cell>2.9 4.2</cell><cell>9.3 10.1</cell><cell>High memory intensive</cell></row><row><cell>apache</cell><cell>2.8</cell><cell>10.6</cell><cell></cell></row><row><cell>omnetpp-lbm(mix8)</cell><cell>4.7</cell><cell>11.2</cell><cell></cell></row><row><cell>cactus-mcf-milc-bwaves (mix6)</cell><cell>4.8</cell><cell>13.4</cell><cell></cell></row><row><cell>applu</cell><cell>1.7</cell><cell>25.9</cell><cell></cell></row><row><cell>libquantum(mix3)</cell><cell>4.0</cell><cell>43.9</cell><cell></cell></row></table><note><p><p>[Micron 2007</p>] with energy per operation listed in Table</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table IV .</head><label>IV</label><figDesc>Compressed Caches Area Overhead</figDesc><table><row><cell></cell><cell>Baseline</cell><cell>DCC</cell><cell>SCC</cell><cell>YACC</cell></row><row><cell>Tags per Set (bits)</cell><cell>16 ? 29+4 =</cell><cell>16 ? 27+4+6 =</cell><cell>16 ? 27+4 =</cell><cell>16 ? 27+4 = (468 -</cell></row><row><cell></cell><cell>468</cell><cell>(468 -26)</cell><cell>(468 -32)</cell><cell>32)</cell></row><row><cell>Coherence</cell><cell></cell><cell>16 ? (4 ? 3 + 1)</cell><cell>16 ? 4 ? 3 =</cell><cell>16 ? (4 ? 3 + 1) =</cell></row><row><cell>Metadata per Set</cell><cell>16 ? 3 = 48</cell><cell>= (48 + 160)</cell><cell>(48 + 144)</cell><cell>(48 + 160)</cell></row><row><cell>(bits)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Compression</cell><cell></cell><cell>16 ? 4 ? 6 + 16</cell><cell></cell><cell></cell></row><row><cell>Metadata per Set</cell><cell>0</cell><cell>? 4 ? 1 = (0 +</cell><cell>0</cell><cell>0</cell></row><row><cell>(bits)</cell><cell></cell><cell>448)</cell><cell></cell><cell></cell></row><row><cell>Total LLC Tag Array Overhead (%)</cell><cell>0</cell><cell>113%</cell><cell>25%</cell><cell>28%</cell></row><row><cell>Total LLC Overhead (%)</cell><cell>0</cell><cell>6.7%</cell><cell>1.5%</cell><cell>1.6%</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Transactions on Architecture and Code Optimization, Vol. 13, No. 3, Article 27, Publication date: September 2016.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>The original SCC work used a compression factor of</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>for blocks compressible to 16 bytes and three for blocks compressed to 8 bytes. However, simulation results generally show that it is better to compress to a minimum size of 16 bytes.ACM Transactions on Architecture and Code Optimization, Vol. 13, No.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>3, Article 27, Publication date: September 2016.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>The authors would like to acknowledge <rs type="person">Hamid Reza Ghasemi</rs>, members of the <rs type="institution">Multifacet research group</rs>, and our anonymous reviewers for their helpful comments.</p></div>
			</div>
			<div type="funding">
<div><p>This work is supported in part by the <rs type="funder">European Research Council Advanced</rs> Grant <rs type="grantNumber">DAL 267175</rs> and the <rs type="funder">National Science Foundation</rs> (<rs type="grantNumber">CNS-1117280</rs>, <rs type="grantNumber">CCF-1218323</rs>, <rs type="grantNumber">CNS-1302260</rs>, <rs type="grantNumber">CCF-1438992</rs>, and <rs type="grantNumber">CCF-1533885</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_skJPmJH">
					<idno type="grant-number">DAL 267175</idno>
				</org>
				<org type="funding" xml:id="_kM5u82R">
					<idno type="grant-number">CNS-1117280</idno>
				</org>
				<org type="funding" xml:id="_WDBEgHV">
					<idno type="grant-number">CCF-1218323</idno>
				</org>
				<org type="funding" xml:id="_N5n5sbe">
					<idno type="grant-number">CNS-1302260</idno>
				</org>
				<org type="funding" xml:id="_DEPgGvP">
					<idno type="grant-number">CCF-1438992</idno>
				</org>
				<org type="funding" xml:id="_nPTz6cq">
					<idno type="grant-number">CCF-1533885</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Performance of hardware compressed main memory</title>
		<author>
			<persName><forename type="first">Bulent</forename><surname>Abali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hubertus</forename><surname>Franke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaowei</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><forename type="middle">E</forename><surname>Poff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Basil</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th IEEE Symposium on High-Performance Computer Architecture</title>
		<meeting>the 7th IEEE Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Simulating a $2M commercial server on a $2K PC</title>
		<author>
			<persName><forename type="first">Alaa</forename><forename type="middle">R</forename><surname>Alameldeen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><forename type="middle">J</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">E</forename><surname>Mauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Min</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">D</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName><surname>Sorin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="50" to="57" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Variability in architectural simulations of multi-threaded workloads</title>
		<author>
			<persName><forename type="first">A</forename><surname>Alameldeen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th IEEE Symposium on High-Performance Computer Architecture</title>
		<meeting>the 9th IEEE Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Adaptive cache compression for high-performance processors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Alameldeen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st Annual International Symposium on Computer Architecture</title>
		<meeting>the 31st Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">SC2: A statistical compression cache scheme</title>
		<author>
			<persName><forename type="first">Angelos</forename><surname>Arelakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Per</forename><surname>Stenstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Annual International Symposium on Computer Architecture</title>
		<meeting>the 41st Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">SPEComp: A new benchmark suite for measuring parallel computer performance</title>
		<author>
			<persName><forename type="first">V</forename><surname>Aslot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Domeika</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Eigenmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gaertner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parady</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on OpenMP Applications and Tools</title>
		<meeting>the Workshop on OpenMP Applications and Tools</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">ECM: Effective capacity maximizer for high-performance compressed caching</title>
		<author>
			<persName><forename type="first">Seungcheol</forename><surname>Baek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gyu</forename><surname>Hyung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chrysostomos</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junghee</forename><surname>Nicopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jongman</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on High-Performance Computer Architecture</title>
		<meeting>the IEEE Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">PARSEC 2.0: A new benchmark suite for chip-multiprocessors</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Bienia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Modeling, Benchmarking, and Simulation</title>
		<meeting>the Workshop on Modeling, Benchmarking, and Simulation</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Home Page</title>
		<author>
			<persName><surname>Cacti</surname></persName>
		</author>
		<ptr target="http://www.hpl.hp.com/research/cacti/" />
		<imprint>
			<date type="published" when="2008-08-16">2008. August 16. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">C-pack: A high-performance microprocessor cache compression algorithm</title>
		<author>
			<persName><forename type="first">Xi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lei</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">P</forename><surname>Dick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Shang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haris</forename><surname>Lekatsas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1196" to="1208" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Zero-content augmented caches</title>
		<author>
			<persName><forename type="first">Julien</forename><surname>Dusser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Piquet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andr?</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Supercomputing</title>
		<meeting>the 23rd International Conference on Supercomputing</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Decoupled zero-compressed memory</title>
		<author>
			<persName><forename type="first">Julien</forename><surname>Dusser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andre</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on High Performance and Embedded Architectures and Compilers</title>
		<meeting>the 6th International Conference on High Performance and Embedded Architectures and Compilers</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A robust main-memory compression scheme</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ekman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stenstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="74" to="85" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A unified compressed memory hierarchy</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hallnor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reinhardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Symposium on High-Performance Computer Architecture</title>
		<meeting>the 11th International Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A method for the construction of minimum-redundancy codes</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Huffman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IRE</title>
		<meeting>the IRE</meeting>
		<imprint>
			<date type="published" when="1952">1952</date>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="1098" to="1101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">6th Generation Intel Core i7 Processors</title>
		<author>
			<persName><surname>Intel</surname></persName>
		</author>
		<ptr target="http://www.intel.com/products/processor/corei7/" />
		<imprint>
			<date type="published" when="2016-08-16">2016. August 16. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">High performance cache replacement using re-reference interval prediction (RRIP)</title>
		<author>
			<persName><forename type="first">Aamer</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">B</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><forename type="middle">C</forename><surname>Steely</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">Joel</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th International Symposium on Computer Architecture (ISCA&apos;10)</title>
		<meeting>the 37th International Symposium on Computer Architecture (ISCA&apos;10)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Low-energy data cache using sign compression and cache line bisection</title>
		<author>
			<persName><forename type="first">Nam Sung</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Mudge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd Annual Workshop on Memory Performance Issues</title>
		<meeting>the 2nd Annual Workshop on Memory Performance Issues</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Residue Cache: A low-energy low-area L2 cache architecture via compression and partial hits</title>
		<author>
			<persName><forename type="first">Soontae</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesung</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jongmin</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seokin</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 44th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An on-chip cache compression technique to reduce decompression overhead and design complexity</title>
		<author>
			<persName><forename type="first">Jang-Soo</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Won-Kee</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shin-Dug</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems Architecture</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="1365" to="1382" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Multifacet&apos;s general execution-driven multiprocessor simulator (GEMS) toolset</title>
		<author>
			<persName><forename type="first">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Alameldeen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="92" to="99" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Calculating Memory System Power for DDR3</title>
		<idno>TN-41-01</idno>
	</analytic>
	<monogr>
		<title level="j">Micron Technology</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Boise, ID</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Micron</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Linearly compressed pages: A low-complexity, low-latency main memory compression framework</title>
		<author>
			<persName><forename type="first">Gennady</forename><surname>Pekhimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vivek</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoongu</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongyi</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phillip</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Base-delta-immediate compression: Practical data compression for on-chip caches</title>
		<author>
			<persName><forename type="first">Gennady</forename><surname>Pekhimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vivek</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phillip</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on Parallel Architectures and Compilation Techniques (PACT&apos;12)</title>
		<meeting>the 21st International Conference on Parallel Architectures and Compilation Techniques (PACT&apos;12)<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="377" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The pool of subsectors cache design</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Rothman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Supercomputing</title>
		<meeting>the International Conference on Supercomputing</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The ZCache: Decoupling ways and associativity</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Sanchez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Kozyrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 43rd Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Skewed Compressed Caches</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sardashti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 47th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page">47</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">2013a. Decoupled Compressed Cache: Exploiting spatial locality for energy optimization</title>
		<author>
			<persName><forename type="first">Somayeh</forename><surname>Sardashti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Micro Top Picks from the 2013 Computer Architecture Conferences</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Decoupled Compressed Cache: Exploiting spatial locality for energy-optimized compressed caching</title>
		<author>
			<persName><forename type="first">Somayeh</forename><surname>Sardashti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A case for two-way skewed-associative caches</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Annual International Symposium on Computer Architecture</title>
		<meeting>the 20th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Decoupled sectored caches: Conciliating low tag implementation cost and low miss ratio</title>
		<author>
			<persName><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture</title>
		<meeting>the International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Concurrent support of multiple page sizes on a skewed associative TLB</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="924" to="927" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Skewed-Associative Caches</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bodin</surname></persName>
		</author>
		<idno>RR1655. INRIA</idno>
		<ptr target="http://hal.inria.fr/docs/00/07/49/02/PDF/RR-1655.pdf" />
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
	<note type="report_type">Research Report</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Dynamic zero compression for cache energy reduction</title>
		<author>
			<persName><forename type="first">Luis</forename><surname>Villa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Microarchitecture</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>Proceedings of the 33rd Annual ACM</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Design and analysis of dynamic Huffman codes</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vitter</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="825" to="845" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Frequent value locality and its applications</title>
		<author>
			<persName><forename type="first">Jun</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajiv</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Embedded Computing Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="79" to="105" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Yet Another Compressed Cache</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page">25</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A framework for coarse-grain optimizations in the on-chip memory hierarchy</title>
		<author>
			<persName><forename type="first">Jason</forename><surname>Zebchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elham</forename><surname>Safi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 40th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A universal algorithm for sequential data compression</title>
		<author>
			<persName><forename type="first">Jacob</forename><surname>Ziv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abraham</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="337" to="343" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Compression of individual sequences via variable-rate coding</title>
		<author>
			<persName><forename type="first">Jacob</forename><surname>Ziv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abraham</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="530" to="536" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
