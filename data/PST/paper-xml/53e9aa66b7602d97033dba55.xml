<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Behavioral Distance for Intrusion Detection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Debin</forename><surname>Gao</surname></persName>
							<email>dgao@ece.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Electrical &amp; Computer Engineering Department</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Pittsburgh</settlement>
									<region>Pennsylvania</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
							<email>reiter@cmu.edu</email>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Electrical &amp; Computer Engineering Department</orgName>
								<orgName type="department" key="dep2">Computer Science Department, and CyLab</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Pittsburgh</settlement>
									<region>Pennsylvania</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dawn</forename><surname>Song</surname></persName>
							<email>dawnsong@cmu.edu</email>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Electrical &amp; Computer Engineering Department</orgName>
								<orgName type="department" key="dep2">Computer Science Department, and CyLab</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Pittsburgh</settlement>
									<region>Pennsylvania</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Behavioral Distance for Intrusion Detection</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">27009688973F8E99002C7E7FAEB52742</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>intrusion detection</term>
					<term>system call</term>
					<term>behavioral distance</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce a notion, behavioral distance, for evaluating the extent to which processes-potentially running different programs and executing on different platforms-behave similarly in response to a common input. We explore behavioral distance as a means to detect an attack on one process that causes its behavior to deviate from that of another. We propose a measure of behavioral distance and a realization of this measure using the system calls emitted by processes. Through an empirical evaluation of this measure using three web servers on two different platforms (Linux and Windows), we demonstrate that this approach holds promise for better intrusion detection with moderate overhead.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Numerous attacks on software systems result in a process' execution deviating from its normal behavior. Prominent examples include code injection attacks on server processes, resulting from buffer overflow and format string vulnerabilities. A significant amount of research has sought to detect such attacks through monitoring the behavior of the process and comparing that behavior to a model of "normal" behavior. Typically this model of "normal" is obtained either from the process' own previous behavior <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b36">37]</ref> or the behavior prescribed by the source code or executable of the program it executes <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref>.</p><p>In this paper we present a new approach for detecting anomalous behavior of a process, in which the model of "normal" is a "replica" of the process running in parallel with it, operating on the same inputs. At a high level, our goal is to detect any behavioral deviation between replicas operating on the same inputs, which will then indicate that one of the replicas has been compromised. As we will show, this approach will better detect mimicry attacks <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b30">31]</ref> than previous approaches. In addition, this approach has immediate application in fault-tolerant systems, which often run replicas and compare their responses (not behavior) to client requests to detect (e.g., <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b1">2]</ref>) or mask (e.g., <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b38">39]</ref>) faults. When considering attacks, it is insufficient to simply compare the responses to detect faults, because certain intrusions may not result in observable deviation in the responses (but may nevertheless go on to attack the interior network, for example). Our method of detecting behavioral deviation between replicas can significantly improve the resilience of such fault-tolerant systems by detecting more stealthy attacks.</p><p>Monitoring for deviations between replicas would be a relatively simple task if the replicas were identical. However, in light of the primary source of attacks with which we are concerned-i.e., software faults and, in particular, code injection attacks that would corrupt identical replicas identically-it is necessary that the "replicas" be as diverse as possible. We thus take as our goal the task of measuring the behavioral distance between two diverse processes, be they distinct implementations of the program (e.g., as in n-version programming <ref type="bibr" target="#b4">[5]</ref>), the same implementation running on different platforms (e.g., one Linux, one Windows), or even distinct implementations on diverse platforms. In this paper, we propose a method to measure behavioral distance between replicas and show that our method can work with competing, off-the-shelf, diverse implementations without modification.</p><p>We can measure behavioral distance using many different observable attributes of the replicas. As a concrete example, the measure of "behavior" for a replica that we adopt is the sequence of system calls it emits, since a process presumably is able to affect its surroundings primarily through system calls. Because the replicas are intentionally diverse, even how to define the "distance" between the system call sequences they induce is unclear. When the replicas execute on diverse platforms, the system calls supported are different and not in one-to-one correspondence. When coupled with distinct implementations there is little reason to expect any similarity whatsoever between the system call sequences induced on the platforms when each processes the same request.</p><p>A key observation in our work, however, is that even though the system call sequences might not be similar in any syntactic way, they will typically be correlated in the sense that a particular system call subsequence emitted by one replica will usually coincide with a (but syntactically very different) subsequence emitted by the other replica. These correlations could be determined either through static analysis of the replica executables (and the libraries), or by first subjecting the replicas to a battery of well-formed (benign) inputs and observing the system call sequences induced coincidentally. The former is potentially more thorough, but the latter is more widely applicable, being unaffected by difficulties in static analysis of binaries for certain platforms 1 or, in the future, 1 For example, the complexity of static analysis on x86 binaries is well documented.</p><p>This complexity stems from difficulties in code discovery and module discovery <ref type="bibr" target="#b23">[24]</ref>, with numerous contributing factors, including: variable instruction size (Prasad and Chiueh claim that this renders the problem of distinguishing code from data undecidable <ref type="bibr" target="#b21">[22]</ref>); hand-coded assembly routines, e.g., due to statically linked libraries, that may not follow familiar source-level conventions (e.g., that a function has a single entry point) or use recognizable compiler idioms <ref type="bibr" target="#b25">[26]</ref>; and indirect branch instructions such as call/jmp reg32 that make it difficult or impossible to identify the target location <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b21">22]</ref>. Due to these issues and others, x86 binary analysis tools have strict restrictions on their applicable targets <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b21">22]</ref>.</p><p>of software obfuscated to render static analysis very difficult for the purposes of digital rights management (e.g., <ref type="bibr" target="#b6">[7]</ref>). So, we employ the latter method here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Comparison with related work</head><p>Utilizing an intrusion detection system to monitor the system calls of a single (non-replicated) process is a thoroughly explored alternative to the approach we explore here for detecting software faults and code-injection attacks. However, all such techniques of which we are aware are vulnerable to mimicry attacks, whereby code injected by an attacker issues attack system calls within a longer sequence that is consistent with normal behavior of the program <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b12">13]</ref>. In the same fashion, independent system call monitoring of each of two diverse replicas does not address this problem, provided that the code injected successfully into one replica uses mimicry. However, as we will show, the alternative we consider here, in which replicas are monitored in a coordinated fashion, makes such an attack far more difficult. The reason is that mimicry of any valid system call sequence on a replica is not sufficient to avoid detection. Rather, to remain undetected, mimicry must induce a system call sequence that is typically observed coincidentally with the sequence emitted by the other, uncorrupted replica. Viewed more broadly, our approach can be considered a form of intrusion detection that seeks to correlate events from multiple distinct components of a system. Often these events are themselves intrusion detection alerts (e.g., <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b20">21]</ref>); in contrast, in our approach the events are system calls produced in the course of the system running normally. As such, our work bears a conceptual similarity to other efforts that correlate seemingly benign events across multiple systems to identify intrusions (e.g., <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b37">38]</ref>). However, we are unaware of any that demonstrate this capability at the system call level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Contributions</head><p>In this paper we introduce the notion of behavioral distance for intrusion detection, and detail the design, implementation and performance of a system for dynamically monitoring the behavioral distance of diverse replicas. We detail our measure of behavioral distance and our method for divining the correlated system call subsequences of two replicas. We show through empirical analysis with three different http server implementations and two different platforms (Linux and Windows) that thresholds for behavioral distance can typically be set so as to induce low false positive (i.e., false alarm) rates while detecting even a minimal attack consisting of merely an open and a write-even if the attacker knows that our defense is being used. Moreover, the false alarm rate can be further reduced in exchange for some possibility of an attack going undetected (a false negative), though we believe that this tradeoff can be tuned to detect the richer attacks seen in practice with virtually no false alarms. Perhaps more importantly, as a first step in analyzing the behavioral distance of diverse implementations and platforms, we believe this work can lay the framework for future research to improve this tradeoff further.</p><p>The behavioral distance that we define should detect semantic similarity/difference when replicas process the same input. That is, provided that replicas process responses in the same way semantically, the behavioral distance should be small. However, because the two replicas may be constructed differently and may run on different operating systems, the two execution traces will naturally differ syntactically. To bridge this apparent discrepancy, we use the fact that since the replicas process the same input, during normal program execution the two syntactically-different executions should represent the same semantic action.</p><p>So, our problem is as follows: let s 1 and s 2 denote sequences of observed behaviors of two replicas, respectively. We need to define (and train) a distance measure Dist(s 1 , s 2 ) that returns a small value when the replicas operate semantically similarly, and returns a large value when they semantically diverge. The quality of the distance measure function Dist() directly impacts the false positive and false negative rates of the system.</p><p>To the best of our knowledge, the problem of developing an accurate behavioral distance measure for detecting software faults and intrusions has not been studied before. Some techniques have been developed to evaluate the semantic equivalence of two sequences of program instructions, though these techniques are difficult to scale to large programs. Also, the problem of semantic equivalence is different from the behavioral distance problem that we study here, since diverse replicas may not behave in exactly the same way. We thus believe we are the first to pose and explore this problem. We also believe that research on this topic could lead to other applications.</p><p>There are many ways to monitor the "behavior" of a process. For example, one could look at sequence of instructions executed, or patterns in which process's internal states change. In this paper, we propose a specific measure for behavioral distance, by using system call sequences emitted by processes. A system call is a service provided by the operating system and has been used in many intrusion/anomaly detection systems <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref>. It is a reliable way of monitoring program behavior because in most modern operating systems, a system call is the only way for user programs to interact with the operating system. Also, system calls are natural places to intercept a program and perform monitoring, since system calls often require a context switch. Thus, system call monitoring could introduce lower overhead than intercepting the program at other points for monitoring.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Behavioral Distance Using System Call Sequences</head><p>In this section, we describe how we construct the behavioral distance measure using system call sequences. The goal is to design a quantitative measure such that system call sequences resulting from the same/similar behavior on replicas will have a small "distance" value, and system call sequences resulting from different behavior will have a large "distance" value. As pointed out in Section 1, our objective is to develop such a distance measure without analyzing the program source code or executable, i.e., the distance measure function Dist(s 1 , s 2 ) is defined by first subjecting the server replicas to a battery of well-formed (benign) requests and observing the system call sequences induced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>Defining such a behavioral distance measure based on system call sequences is non-trivial. A system call observed is simply an integer, which is the system call ID used in the operating system and carries little meaning. <ref type="foot" target="#foot_0">2</ref> The two replicas may run on two different operating systems such as Linux and Windows; therefore the same system call ID is likely to mean very different things on two different operating systems. However, because the replicas process the same request and generate the same response, there is a strong correlation on the semantics of the system call sequences made by the replicas. Thus, we can evaluate the behavioral distance by identifying the semantic correspondence of the syntactically unrelated system call sequences.</p><p>The sequence of system calls made by a replica can be broken into subsequences of system calls, which we call system call phrases. A system call phrase is a subsequence of system calls that frequently appear together in program executions, and thus might correspond to a specific task on the operating system or a basic block in the program's source code. If we can learn the correspondence between these phrases, i.e., phrases on two replicas that perform the same/similar task, we can then break sequences of system calls into phrases, and compare the corresponding phrases to find the behavioral distance. A large behavioral distance indicates an attack or a fault on one of the replicas.</p><p>Motivated by the above intuition, we propose to calculate the behavioral distance as follows. We first obtain a distance table, which indicates the distance between any two system call phrases from two replicas. Ideally, the distance associated with two phrases that perform the same task is low, and otherwise is high. Next, we break system call sequences s 1 and s 2 into sequences of system call phrases. (Details are covered in Section 3.5.) The two sequences may have different numbers of phrases, and the corresponding phrases (those that perform similar tasks) might not be at the same location in the two sequences. We handle this problem by inserting insertion/deletion phrases (denoted as I/D phrases or σ in the following sections) to obtain two equal-length sequences of phrases s 1,1 , . . . , s 1,n and s 2,1 , . . . , s 2,n . We then look up the distances between the corresponding phrases in the distance table and compute the behavioral distance as the sum of these distances: 1≤i≤n dist(s 1,i , s 2,i ).</p><p>In the rest of this section, we first explain more formally how we calculate the behavioral distance, and then describe how we obtain the distance table through learning. Finally we briefly explain how we identify the system call phrases by pattern extraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Behavioral Distance Calculation</head><p>In this subsection, we first give the intuition behind our approach by explaining a related problem in molecular biology and evolution. We then formally define our behavioral distance calculation.</p><p>A related problem to behavioral distance has been studied in molecular biology and evolution. Roughly speaking, the problem is to evaluate evolutionary change between DNA sequences. When two DNA sequences are derived from a common ancestral sequence, the descendant sequences gradually diverge by changes in the nucleotides. For example, a nucleotide in a DNA sequence may be substituted by another nucleotide over time; a nucleotide may also be deleted or a new nucleotide can be inserted.</p><p>To evaluate the evolutionary change between DNA sequences, Sellers <ref type="bibr" target="#b27">[28]</ref> proposed a distance measure called evolutionary distance, by counting the number of nucleotide changes (including substitutions, deletions and insertions) and summing up the corresponding distances of substitutions, deletions and insertions. The calculation is easy when nucleotides in the two sequences are aligned properly, i.e., corresponding nucleotides are at the same location in the two sequences. However, it becomes complicated when there are deletions and/or insertions, because the nucleotides are misaligned. Therefore, the correct alignment needs to be found by inferring the locations of deletions and insertions. Figure <ref type="figure">1</ref> shows an example with two nucleotide sequences and a possible alignment scheme <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Original Sequence</head><p>Aligned Sequence</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ATGCGTCGTT ATGC-GTCGTT ATCCGCGAT</head><p>AT-CCG-CGAT</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 1. Example of two nucleotide sequences</head><p>Our behavioral distance calculation is inspired by the evolutionary distance method proposed by Sellers <ref type="bibr" target="#b27">[28]</ref>, where the evolutionary distance is calculated as the sum of the costs of substitutions, deletions and insertions. In behavioral distance calculations, we also have the "misalignment" problem. Misalignments between system call phrases are mainly due to the diverse implementations or platforms of the replicas. For example, the same task can be performed by different numbers of system call phrases on different replicas. Figure <ref type="figure">2</ref> shows an example with two sequences of system call phrases observed when two replicas are processing the same request. Due to implementation differences, s 2 has an extra system call phrase idle 2 which does not perform any critical operation.</p><p>To calculate the behavioral distance, we thus need to perform an alignment procedure by inserting I/D phrases (inserting an I/D phrase in one sequence is equivalent to deleting a corresponding phrase from the other sequence) so that s1 = open1, read1, write1, close1 s2 = open2, read2, idle2, write2, close2 Fig. <ref type="figure">2</ref>. Example of system call sequences observed on two replicas system call phrases that perform similar tasks will be at the same position in the two aligned sequences. Given a "proper" alignment, we can then calculate the sum of the distances between the phrases at the same position (Section 3.3 discusses how we obtain the distances between any two phrases) in the two sequences and use this sum as the behavioral distance.</p><p>Given a pair of misaligned system call sequences, there are obviously more than one way of inserting I/D phrases into the sequences. Different ways of inserting them will result in different alignments and hence different behavioral distances between the two sequences. What we are most interested in here is to find the behavioral distance between two sequences when the phrases are aligned "properly", i.e., when phrases that perform similar tasks are aligned to each other. Although it is not clear how to find such an alignment for any given pair of sequences, we know that the "best" alignment should result in the smallest behavioral distance between the two sequences, among all other ways of inserting I/D phrases, because phrases that perform similar tasks have a low behavioral distance, as explained in Section 3.3. Therefore, we consider different alignments and choose the one that results in the smallest as the behavioral distance between the two sequences.</p><p>Assume that a sequence of system calls s is given in the form of a sequence of system call phrases. Let prs(s) denote the number of system call phrases in the sequence. Given two sequences s 1 and s 2 , we define Ext(s i , n) as the set of sequences obtained by inserting nprs(s i ) I/D phrases into s i , at any locations (i ∈ {1, 2}). n = f 1 (prs(s 1 ), prs(s 2 )) is the length of the extended sequences after inserting I/D phrases. In order to give more flexibility in the phrase alignments, f 1 () ensures that n &gt; max(prs(s 1 ), prs(s 2 )). (The definition of f 1 () used in our experiments is shown in Section 3.6.)</p><p>We define the behavioral distance between two system call sequences s 1 and s 2 as</p><formula xml:id="formula_0">Dist(s 1 , s 2 ) = min s 1 ,s 2 n i=1 dist(s 1,i , s 2,i )</formula><p>where</p><formula xml:id="formula_1">s 1 ∈ Ext(s 1 , n) s 2 ∈ Ext(s 2 , n) s 1,i is the i th phrase in s 1 s 2,i is the i th phrase in s 2 .</formula><p>The minimum is taken over all possible values of s 1 and s 2 . dist() is the entry in the distance table, which defines the distance between any two phrases from the two replicas. (Section 3.3 discusses how we obtain the distance table . Here we assume that the distance table is given.)</p><p>For example, in the case where each phrase is of length one, the calculation of Dist(s 1 , s 2 ) from the example in Figure <ref type="figure">2</ref> may indicate that the minimum is obtained when</p><formula xml:id="formula_2">s 1 = open 1 , read 1 , σ, write 1 , close 1 s 2 = open 2 , read 2 , idle 2 , write 2 , close 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Learning the Distance Table</head><p>The calculation of behavioral distance shown in Section 3.2 assumes that the distances between any two system call phrases are known. In this subsection, we detail how we obtain the distance table by learning. To make the explanations clearer, we assume that the two replicas are running Linux and Microsoft Windows<ref type="foot" target="#foot_1">3</ref> operating systems.</p><p>One way to obtain the distance table is to analyze the semantics of each phrase and then manually assign the distances according to the similarity of the semantics. There are several difficulties with this approach. First, this is labor intensive. (Note that the set of system call phrases is likely to be different for different programs.) Second, the information may not be available, e.g., most system calls are not documented in Windows. Third, even if they are well documented, e.g., as in Linux, the distances obtained in this way will be general to the operating system, and might not be able to capture any specific features of the program running on the replicas.</p><p>Instead, we propose an automatic way for deriving the distance table by learning. As pointed out in Section 1, our objective is to find the correlation between system call phrases by first subjecting the server replicas to a battery of well-formed (benign) requests and observing the system calls induced. We use the pairs of system call sequences (i.e., system call sequences made by the two replicas when processing the same request) in the training data to obtain the distance table, which contains distances between any two system call phrases observed in the training data. To do that, we first initialize the distance table, and then run a number of iterations to update the entries in the distance table. The iterative process stops when the distance table converges, i.e., when the distance values in the table change by only a small amount for a few consecutive iterations. In each iteration, we calculate the behavioral distance between any system call sequence pairs in the training data (using the modified distance values from the previous iteration), and then use the results of the behavioral distance calculation to update the distance table. We explain how we initialize and update the distance table in the following two subsections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initializing the Distance Table</head><p>The initial distance values in the distance table play an important role in the performance of the system. Improper values might result in converging to a local minimum, or slower convergence. We introduce two approaches to initialize these distances. We use the first approach to initialize entries in the distance table that involve system calls for which we know the behavior, and use the second approach for the rest. Intuitively, distance between phrases that perform similar tasks should be assigned a small value.</p><p>The first approach The first approach to initialize these distances is by analyzing the semantics of individual system calls in Linux and Windows. We first assign similarity values to each pair of system calls in Linux and Windows. Let C L and C W be the set of system calls in Linux and Windows, respectively. We analyze each Linux system call and Windows system call and assign a value to sim(c L i , c W j ), where c L i ∈ C L for all i ∈ {1, 2, . . . , |C L |} and c W j ∈ C W for all j ∈ {1, 2, . . . , |C W |}. System calls that perform similar functions are assigned a small similarity value. We then initialize the distances between two system call phrases based on these similarity values.</p><p>Let P L and P W be the set of Linux system call phrases and Windows system call phrases observed, respectively. We would like to calculate dist(p L i , p W j ), i.e., the distance between two phrases where p L i ∈ P L and p W j ∈ P W . (Let dist 0 (p L i , p W j ) denote the initial distance.) We use len(p) to denote the number of system calls in a phrase p. dist 0 (p L i , p W j ) can now be calculated as</p><formula xml:id="formula_3">dist 0 (p L i , p W j ) =f 2 {sim(p L i,k , p W j,l ) | k ∈ {1, 2, . . . , len(p L i )}; l ∈ {1, 2, . . . , len(p W j )}}</formula><p>where</p><formula xml:id="formula_4">p L i,k ∈ C L is the k th system call in phrase p L i p W j,l ∈ C W is the l th system call in phrase p W j .</formula><p>Intuitively, if system calls in the two phrases have small similarity values with each other, the distance between the two phrases should be low. (The definition of f 2 () used in our experiments is shown in Section 3.6.)</p><p>The main difficulty of this approach is that Windows system calls are not well documented. We have managed to obtain the system call IDs of 94 exported Windows system calls with their function prototypes <ref type="bibr" target="#b18">[19]</ref>. <ref type="foot" target="#foot_2">4</ref> We then assign distances to these 94 Windows system calls and the Linux system calls by comparing their semantics. Since we do not know the system call IDs and semantics of the rest of the Windows system calls, we propose a second method to initialize the distance table for phrases that involve the rest of the system calls.</p><p>The second approach The second approach to initialize the distance between two phrases is to use frequency information. Intuitively, if two system call phrases perform similar tasks on two replicas, they will occur in the system call sequences in the training data with similar frequencies. We obtain the frequency information when the phrases are first identified by a phrase extraction algorithm and a phrase reduction algorithm; see Section 3.5. The phrase extraction algorithm analyzes system call sequences from sample executions, and outputs a set of system call phrases. The phrase reduction algorithm takes this result and outputs a subset of the system call phrases that are necessary to "cover" the training data, in the sense described below.</p><p>The phrase reduction algorithm runs a number of rounds to find the minimal subset of system call phrases identified by the phrase extraction algorithm that can cover the training data. Each round in the phrase reduction algorithm outputs one system call phrase that has the highest coverage (number of occurrences times length of the phrase) in the training data. After the phrase with the highest coverage is found in each round, the system call sequences in the training data are modified by removing all occurrences of that phrase. The phrase reduction algorithm terminates when the training data becomes empty. Let cnt(p L i ) and cnt(p W j ) denote the number of occurrences of phrases p L i and p W j in the training data when they are identified and removed by the phrase reduction algorithm, and let cnt(P L ) and cnt(P W ) denote the total number of occurrences of all phrases. The frequency with which phrases p L i and p W j are identified can be calculated as</p><formula xml:id="formula_5">cnt(p L i ) cnt(P L ) and cnt(p W j )</formula><p>cnt(P W ) , respectively. The idea is that system call phrases identified with similar frequencies in the training data are likely to perform the same task, and therefore will be assigned a lower distance.</p><formula xml:id="formula_6">dist 0 (p L i , p W j ) = f 3 cnt(p L i ) cnt(P L ) , cnt(p W j ) cnt(P W ) .</formula><p>f 3 () compares the frequencies with which phrases p L i and p W j are identified and assigns a distance accordingly. (The definition of f 3 () that we use in our experiments is shown in Section 3.6.) Distances between a system call phrase and the I/D phrase σ are assigned a constant. dist(σ, σ) is always zero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Iteratively Updating the Distance Table</head><p>In this subsection, we show how we use the system call sequences in the training data to update the distance table iteratively. We run a number of iterations. The distances are updated in each iteration, and the process stops when the distance table converges, i.e., when the distance values in the table change by only a small amount in a few consecutive iterations. In each iteration, we first calculate the behavioral distance between any pairs of system call sequences (i.e., system call sequences made by the two replicas when processing the same request) in the training data, using the updated distance values from the previous iteration, and then use the results of the behavioral distance calculation to update the distance table.</p><p>Note that the result of the behavioral distance calculation not only gives the minimum of the sum of distances over different alignment schemes, but also the particular alignment that results in the minimum. Thus, we analyze the result of the behavioral distance calculation to find out the frequencies with which two phrases are aligned to each other, and use this frequency information to update the corresponding value in the distance table.</p><p>Let occ z (p L i , p W j ) denote the total number of times that p L i and p W j are aligned to each other in the results of the behavioral distance calculation in the z th iteration. We then update dist(p L i , p W j ) as</p><formula xml:id="formula_7">dist z+1 (p L i , p W j ) = f 4 dist z (p L i , p W j ), occ z (p L i , p W j ) .</formula><p>Intuitively, the larger occ z (p L i , p W j ) is, the smaller dist z+1 (p L i , p W j ) should be. (The definition of f 4 () used in our experiments is shown in Section 3.6.) dist(p L i , σ) and dist(σ, p W j ) are updated in the same way, and dist(σ, σ) = 0. After the distances are updated, we start the next iteration, where we calculate the behavioral distances between system call sequences in the training data using the new distance values. The process of behavioral distance calculation and distance table updating repeats until the distance table converges, i.e., when the distance values in the table change by a small amount for a few consecutive iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Real-time Monitoring</head><p>After obtaining the distance table by learning, we use the system for real-time monitoring. Each request from a client is sent to both replicas, and such a request results in a sequence of system calls made by each replica. We collect the two system call sequences from both replicas in real time and calculate the behavioral distance between the two sequences. If the behavioral distance is higher than a threshold, an alarm is raised.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">System Call Phrases</head><p>Before we start calculating the behavioral distance, we need to break a system call sequence into system call phrases. System call phrases have been used in intrusion/anomaly detection systems <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b12">13]</ref>. Working on system call phrases significantly improves the performance of behavioral distance calculation, since a relatively long system call sequence is recognized as a short sequence of system call phrases.</p><p>We use the phrase extraction algorithm TEIRESIAS <ref type="bibr" target="#b22">[23]</ref> and the phrase reduction algorithm in <ref type="bibr" target="#b36">[37]</ref>, which are also used in intrusion/anomaly detection systems <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b12">13]</ref>, to extract system call phrases. The TEIRESIAS algorithm analyzes system call sequences from sample executions, and outputs a set of system call phrases that are guaranteed to be maximal <ref type="bibr" target="#b22">[23]</ref>. Maximal phrases (the number of occurrences of which will decrease if the phrases are extended to include any additional system call) capture system calls that are made in a fixed sequence, and therefore intuitively should conform to basic blocks/functions in the program source code. The phrase reduction algorithm takes the result from TEIRESIAS and outputs a subset of the system call phrases that are necessary to cover the training data. Note that other phrase extraction and reduction algorithms can be used.</p><p>For any given system call sequence, there might be more than one way of breaking it into system call phrases. Here we consider all possible ways of breaking it for the behavioral distance calculation and use the minimum as the result. We also group repeating phrases in a sequence and consider only one occurrence of such phrase. The objective is not to "penalize" requests that require longer processing. For example, http requests for large files normally result in long system call sequences with many repeating phrases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Parameter Settings</head><p>The settings of many functions and parameters may affect the performance of our system. In particular, the most important ones are the four functions f 1 (), f 2 (), f 3 () and f 4 (). There are many ways to define these functions. Good definitions can improve the performance, especially in terms of the false positive and false negative rates. Below we show how these functions are defined in our experiments. We consider as future work to investigate other ways to define these functions, in order to improve the false positive and false negative rates.</p><p>These functions are defined as follows in our experiments:</p><formula xml:id="formula_8">f 1 (x, y) = max(x, y) + 0.2 min(x, y) f 2 (X) = m avg(X) f 3 (x, y) = m(|x -y|) f 4 (x, y) = m(0.8x + 0.2m y)</formula><p>where m and m are normalizing factors used to keep the sum of the costs in the distance table constant in each iteration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluations and Discussions</head><p>In this section we evaluate an implementation of our system. We show that the system is able to detect sophisticated mimicry attacks with a low false positive rate. We also show that the performance overhead of our system is moderate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Experimental Setup</head><p>We setup a system with two replicas running two webservers and one proxy to serve http requests. Replica L runs Debian Linux on a desktop computer with a 2.2 GHz Pentium IV processor, and replica W runs Windows XP on a desktop computer with a 2.0 GHz Pentium IV processor. We use another desktop computer with a 2.0 GHz Pentium IV processor to host a proxy server P. All the three machines have 512 MB of memory. The Linux kernel on L is modified such that system calls made by the webserver are captured and sent to P. On W, we develop a kernel driver to capture the system calls made by the webserver. A user program obtains the system calls from the kernel driver on W and sends them to P.</p><p>P accepts client http requests and forwards them to both L and W. After processing the requests, L and W send out responses and the system call sequences made by the server programs. P calculates the behavioral distance between the two system call sequences, raising an alarm if the behavioral distance exceeds a threshold, and forwards the response to the client if responses from L and W are the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Behavioral Distance Between System Call Sequences</head><p>We run our experiments on three different http server programs: Apache <ref type="bibr" target="#b10">[11]</ref>, Myserver <ref type="bibr" target="#b0">[1]</ref> and Abyss <ref type="bibr" target="#b31">[32]</ref>. We choose these servers mainly because they work on both Linux and Windows. A collection of html files of size from 0 to 5 MB are served by these http servers. Training and testing data is obtained by simulating a client that randomly chooses a file to download. The client sends 1000 requests, out of which 800 are used as training data and the remaining 200 are used as testing data.</p><p>We run two sets of tests. In the first set of tests we run the same server implementation on the replicas, i.e., both L and W run Apache, Myserver or Abyss. Training data is used to learn the distances between system call phrases, which are then used to calculate the behavioral distance between system call sequences in the testing data. Results of the behavioral distance calculations on the testing data are shown in Figure <ref type="figure">3</ref> in the form of cumulative distribution functions (x-axis shows the behavioral distance, and y-axis shows the percentage of requests with behavioral distance smaller than the corresponding value on x-axis.). Figure <ref type="figure">3</ref> clearly shows that legitimate requests result in system call sequences with small behavioral distance.</p><p>In the second set of tests, we run different servers on L and W. Figure <ref type="figure">4</ref>(a) shows the results when L is running Myserver and W is running Apache, and Figure <ref type="figure">4(b)</ref> shows results when L is running Apache and W is running Myserver. Although the behavioral distances calculated are not as small as those obtained in the first set of tests, the results are still very encouraging. This set of tests shows that our system cannot only be used when replicas are running the same servers on different operating systems, but also be used when replicas are running different servers. Our approach is thus an alternative to output voting for server implementations that do not always provide identical responses to the same request (c.f., <ref type="bibr" target="#b3">[4]</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Resilience against Mimicry Attacks</head><p>Section 4.2 shows that legitimate requests to the replicas result in system call sequences with small behavioral distances. In this section, we show that attack traffic will result in system call sequences of large behavioral distances. However, our emphasis is not on simple attacks which can be detected by intrusion/anomaly detection systems on individual replicas. (We did try two known attacks on an Abyss webserver, and results show that they are detected by isolated anomaly detection systems <ref type="bibr" target="#b36">[37]</ref> on any one of the replicas.) Instead, we focus on more sophisticated attacks, namely mimicry attacks <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b30">31]</ref>. An attack that injects code into the address space of a running process, and then causes the process to jump to the injected code, results in a sequence of system calls issued by the injected code. In a mimicry attack, the injected code is crafted so that the "attack" system calls are embedded within a longer sequence that is consistent with the program that should be running in the process. As shown in <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b12">13]</ref>, mimicry attacks are typically able to evade detection by hostbased intrusion/anomaly detection systems that monitor system call sequences.</p><p>We analyze a very general mimicry attack, in which the attacker tries to make system call open followed by system call write, when the vulnerable server is processing a carefully crafted http request with attack code embedded. This simple attack sequence is extremely common in many attacks, e.g., the addition of a backdoor root account into the password file. We assume that the attacker can launch such an attack on only one of the replicas using a single request; i.e., either the vulnerability exists only on one of the replicas, or if both replicas are vulnerable, an attacker can inject code that makes system calls of his choice on only one of the replicas. To our knowledge, there is no existing code-injection attacks that violate this assumption, when the replicas are running Linux and Microsoft Windows; nor do we know how to construct one except in very specialized cases.</p><p>We perform two tests with different assumptions. The first test assumes that the attacker is trying to evade detection by an existing anomaly detection technique running on one of the replicas. In particular, the anomaly detection technique we consider here is one that uses variable-length system call phrases in modeling normal behavior of the running program <ref type="bibr" target="#b36">[37]</ref>. In other words, the first test assumes that the attacker does not know that we are utilizing a behavioral distance calculation between replicas (or indeed that there are multiple replicas). In the second test, we assume that the attacker not only understands that our behavioral distance calculation between replicas is being used, but also has a copy of the distance table that is used in the behavioral distance calculation. This means that an attacker in the second test is the most powerful attacker, who knows everything about our system. In both tests, we exhaustively search for the best mimicry attack. In the first test, the "best" mimicry attack is that which makes the minimal number of system calls while remaining undetected. In the second test, the "best" mimicry attack is that which results in the smallest behavioral distance between system call sequences from the two replicas. We assume that the mimicry attack in both cases results in a request to the uncorrupted replica that produces a "page not found" response.</p><p>Results of both tests are shown in Table <ref type="table" target="#tab_0">1</ref>. For each individual test, Table <ref type="table" target="#tab_0">1</ref> shows the behavioral distance of the best mimicry attack, and the percentage of testing data (from Section 4.2) that has a smaller behavioral distance. That is, the percentage shown in Table <ref type="table" target="#tab_0">1</ref> indicates the true acceptance rate of our system when the detection threshold is set to detect the best mimicry attack. As shown, these percentages are all very close to 100%, which means that the false alarm rate of our technique is relatively low, even when the system is configured to detect the most sophisticated mimicry attacks. Moreover, by comparing results from the two sets of tests, we can also see the trade-off between better detection capability and lower false positive rate. For example, by setting the threshold to detect any mimicry attacks that could have evaded detection by an isolated intrusion/anomaly detection system on one of the replicas (results in test 1), our system will have a much lower false positive rate (between 0% and 0.5%). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Performance Overhead</head><p>Section 4.2 and Section 4.3 show that our method for behavioral distance is more resilient against mimicry attacks than previous approaches and has low false positive rate. In this section, we evaluate the performance overhead of our implementation of the behavioral distance calculation by measuring the throughput of the http servers and the average latency of the requests. The performance evaluation shows that the performance overhead is moderate. Also note that our current implementation is unoptimized, so the performance overhead will be even lower with an optimized implementation.</p><p>We run two experiments to evaluate our performance overhead. First, we evaluate the performance degradation of a single server due to the overhead of having to extract and send the system call information to another machine to compute the behavioral distance. Second, we show our performance overhead in comparison to a fault-tolerant system that compares the responses from replicas before returning the response to the client ("output voting").</p><p>Performance Overhead of Extracting and Sending System Call Information In this experiment, we run two different tests on one single server running Windows operating system (with a 2.0 GHz Pentium IV processor and 512 MB memory). In both tests, we utilize the static test suite shipped with WebBench 5.0 <ref type="bibr" target="#b33">[34]</ref> to test the throughput and latency of the server when the server is fully utilized. In the first test, the machine simply runs the Abyss X1 webserver. In the second test, the machine runs the same webserver and also extracts and sends out the system call information to another machine for the behavioral distance calculation (though this calculation is not on the critical path of the response). We compared the difference in throughput and latency between the two tests. Our experiment results show that the second test has a 6.6% overhead in throughput and 6.4% overhead in latency compared to the first test. This shows that intercepting and sending out system call information causes very low performance overhead on a single server in terms of both throughput and latency.</p><p>Performance Overhead Compared to Output Voting We perform three tests to measure the performance overhead of our implementation of the behavioral distance on a replicated system with Abyss X1 webservers. The experimental setup is the same as shown in Section 4.1, except that we use another machine T (with a 2.0 GHz Pentium IV processor and 512 MB memory) to generate client requests, and in one of the tests we also have yet another machine C to perform the behavioral distance calculation. We use the benchmark program WebBench 5.0 <ref type="bibr" target="#b33">[34]</ref> in all the three tests. All tests utilize the static test suite shipped with WebBench 5.0, except that we simulate 10 concurrent clients throughout the tests. Each test was run for 80 minutes with statistics calculated at 5-minute intervals. Results are shown in Figure <ref type="figure" target="#fig_3">5</ref>.   In the first test, replicas L and W only serve as webservers, without the kernel patch (on Linux) or kernel driver (on Windows) to capture the system call sequences. Proxy P does output voting, which means that responses from L and W are compared before being sent to the client T. This test is used as the reference in our evaluation.</p><p>In the second test, besides output voting on P, replicas L and W capture the system calls made by the webservers and send them to machine C, which does the behavioral distance calculation. Note that in this test the behavioral distance calculation is not on the critical path of responding to the client. The purpose of this test is to show the overhead for capturing the system call information (and analyzing it off-line). As seen from Figure <ref type="figure" target="#fig_3">5</ref>, this results in very small overhead: 3.58% in throughput and 0.089 millisecond in latency on average.</p><p>In the last test, output voting and the behavioral distance calculation are both performed on the proxy P on the critical path of responding to the client, i.e., the response is sent to the client only after the behavioral distance calculation and output comparison complete. To improve performance, P caches behavioral distance calculations, so that identical calculations are not performed repeatedly. Figure <ref type="figure" target="#fig_3">5</ref> shows that the proxy needs about 50 minutes to reach its optimal performance level. After that, clients experience about a 24.3% reduction in throughput and 0.848 millisecond overhead in latency, when compared to results from the first test.</p><p>The results suggest that we need to use a slightly more powerful machine for the proxy, if we want to do behavioral distance calculation on the critical path of server responses, for servers to remain working at peak throughput. However, even in our tests the overhead in latency is less than a millisecond.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>In this paper, we introduce behavioral distance for evaluating the extent to which two processes behave similarly in response to a common input. Behavioral distance can be used to detect a software fault or attack on a replica, particularly one that does not immediately yield evidence in the output of the replica. We propose a measure of behavioral distance and a realization of this measure using the system calls emitted by processes. Through an empirical evaluation of this measure using three web servers on two different platforms (Linux and Windows), we demonstrate that this approach is able to detect sophisticated mimicry attacks with low false positive rate and moderate overhead.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 3 .Fig. 4 .</head><label>34</label><figDesc>Fig. 3. CDF of behavioral distances when replicas are running the same server</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>requests + send syscall sequences to C P: output voting + behavioral distance calculation L&amp;W: serve requests + send syscall sequences to P (a) Throughput</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>requests + send syscall sequences to C P: output voting + behavioral distance calculation L&amp;W: serve requests + send syscall sequences to P (b) Latency</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Performance overhead</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Behavioral distance of mimicry attacks</figDesc><table><row><cell>Server on L</cell><cell>Apache</cell><cell>Abyss Myserver Myserver Apache</cell></row><row><cell>Server on W</cell><cell>Apache</cell><cell>Abyss Myserver Apache Myserver</cell></row><row><cell>Mimicry on L (test 1)</cell><cell cols="2">10.283194 9.821795 26.656983 6.908590 32.764897 99.9093 % 100 % 100 % 99.4555 % 100 %</cell></row><row><cell>Mimicry on W (test 1)</cell><cell cols="2">6.842813 5.492936 9.967780 13.354194 5.280875 99.4555 % 99.9093 % 99.4555 % 100 % 99.4555 %</cell></row><row><cell>Mimicry on L (test 2)</cell><cell cols="2">3.736 98.9111 % 99.8185 % 100 % 98.9111 % 100 % 1.828 13.657 2.731 13.813</cell></row><row><cell>Mimicry on W (test 2)</cell><cell cols="2">2.65 98.7296 % 99.8185 % 98.0944 % 98.9111 % 97.8221 % 2.687 2.174 2.187 2.64</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>We could consider the arguments to system calls as well, which would supply additional information (e.g.,<ref type="bibr" target="#b15">[16]</ref>). However, we leave this to future work.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>System calls in Microsoft Windows are usually called native API or system services. In this paper, however, we use the term "system call" for both Linux and Microsoft Windows for simplicity.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Nebbett [19]  lists 95 exported Windows system calls, but we only managed to find 94, which are not exactly the same as those listed by Nebbett.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>Myserver</surname></persName>
		</author>
		<ptr target="http://www.myserverproject.net" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fault detection for Byzantine quorum systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Malkhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2001-09">September 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Distributed on-line diagnosis in the presence of arbitrary faults</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Buskens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jr</forename><forename type="middle">R P</forename><surname>Bianchini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Symposium on Fault-Tolerant Computing</title>
		<meeting>the 23rd International Symposium on Fault-Tolerant Computing</meeting>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
			<biblScope unit="page" from="470" to="479" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Base: Using abstraction to improve fault tolerance</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems (TOCS)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="236" to="269" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">n-version programming: A fault-tolerance approach to reliability of software operation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Avizienes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Symposium on Fault-Tolerant Computing</title>
		<meeting>the 8th International Symposium on Fault-Tolerant Computing</meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="3" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The design of GrIDS: A graph-based intrusion detection system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Crawford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dilger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hoagland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Levitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rowe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staniford-Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Yip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zerkle</surname></persName>
		</author>
		<idno>CSE-99-2</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>U.C. Davis</publisher>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Manufacturing cheap, resilient, and stealthy opaque constructs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Collberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Thomborson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Low</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Principles of Programming Languages</title>
		<meeting>the ACM Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1998-01">January 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Formalizing sensitivity in static analysis for intrusion detection</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Giffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2004 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Anomaly detection using call stack information</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">M</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fogla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Gong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2003 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A sense of self for unix processes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Langstaff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1996 IEEE Symposium on Security and Privacy</title>
		<meeting>the 1996 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<ptr target="http://httpd.apache.org" />
		<title level="m">The Apache Software Foundation. Apache http server</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Gray-box extraction of execution graph for anomaly detection</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM Conference on Computer &amp; Communication Security</title>
		<meeting>the 11th ACM Conference on Computer &amp; Communication Security</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On gray-box program tracking for anomaly detection</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th USENIX Security Symposium</title>
		<meeting>the 13th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Detecting manipulated remote call streams</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Giffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Security Symposium</title>
		<meeting>the 11th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient context-sensitive intrusion detection</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Giffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Symposium on Network and Distributed System Security</title>
		<meeting>Symposium on Network and Distributed System Security</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the detection of anomalous system call arguments</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Valeur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th European Symposium on Research in Computer Security (ESORICS 2003)</title>
		<meeting>the 8th European Symposium on Research in Computer Security (ESORICS 2003)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The implementation of reliable distributed multiprocess systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Computer Networks</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A Linux executable editing library</title>
		<author>
			<persName><forename type="first">X</forename><surname>Lu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Computer and Information Science Department, National Unviersity of Singpaore</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Windows NT/2000 Native API Reference</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nebbett</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Sams Publishing</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Molecular Evolution and Phylogenetics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Analyzing intensive intrusion alerts via correlation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Reeves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recent Advances in Intrusion Detection</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2516</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A binary rewriting defense against stack based buffer overflow attacks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Prasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chiueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference</title>
		<meeting>the USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Combinatorial pattern discovery in biological sequences</title>
		<author>
			<persName><forename type="first">I</forename><surname>Rigoutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Floratos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="67" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Instrumentation and optimization of win32/intel executables using etch</title>
		<author>
			<persName><forename type="first">T</forename><surname>Romer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Voelker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wolman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the USENIX Windows NT Workshop</title>
		<meeting>eeding of the USENIX Windows NT Workshop</meeting>
		<imprint>
			<date type="published" when="1997-08">August 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Implementing fault-tolerant services using the state machine approach: A tutorial</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="299" to="319" />
			<date type="published" when="1990-12">December 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Disassembly of executable code revisited</title>
		<author>
			<persName><forename type="first">B</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Debray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Andrews</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the Working Conference on Reverse Engineering</title>
		<meeting>eeding of the Working Conference on Reverse Engineering</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="45" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A fast automaton-based method for detecting anomalous program behaviors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bendre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dhurjati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bollineni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2001 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On the theory and computation of evolutionary distances</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Sellers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="787" to="793" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Diagnosis of processors with Byzantine faults in a distributed computing system</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ramanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Symposium on Fault-Tolerant Computing</title>
		<meeting>the 17th International Symposium on Fault-Tolerant Computing</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="55" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The DIDS (Distributed Intrusion Detection System) prototype</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Snapp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Smaha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Teal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Grance</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Summer USENIX Conference</title>
		<meeting>the Summer USENIX Conference</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="227" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Hiding intrusions: From the abnormal to the normal and beyond</title>
		<author>
			<persName><forename type="first">K</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mchugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Killourhy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Workshop on Information Hiding</title>
		<meeting>the 5th International Workshop on Information Hiding</meeting>
		<imprint>
			<date type="published" when="2002-10">October 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><forename type="first">Aprelium</forename><surname>Technologies</surname></persName>
		</author>
		<ptr target="http://www.aprelium.com" />
		<title level="m">Abyss web server</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Probabilistic alert correlation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Valdes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Skinner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recent Advances in Intrusion Detection</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2212</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName><surname>Veritest</surname></persName>
		</author>
		<author>
			<persName><surname>Webbench</surname></persName>
		</author>
		<ptr target="http://www.veritest.com/benchmarks/webbench/default.asp" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Intrusion detection via static analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2001 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Mimicry attacks on host-based intrusion detection systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Soto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM Conference on Computer and Communications Security</title>
		<meeting>the 9th ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Intrusion detection using variable-length audit trail patterns</title>
		<author>
			<persName><forename type="first">A</forename><surname>Wespi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dacier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Debar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2000 Recent Advances in Intrusion Detection</title>
		<meeting>the 2000 Recent Advances in Intrusion Detection</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Seurat: A pointillist approach to anomaly detection</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>O'hallaron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recent Advances in Intrusion Detection</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2004-09">September 2004</date>
			<biblScope unit="volume">3224</biblScope>
			<biblScope unit="page" from="238" to="257" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Separating agreement from execution for Byzantine fault tolerant services</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM Symposium on Operating System Principles</title>
		<meeting>the 19th ACM Symposium on Operating System Principles</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
