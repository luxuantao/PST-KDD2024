<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Structure and Content Scoring for XML</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sihem</forename><surname>Amer-Yahia</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Nick</forename><surname>Koudas</surname></persName>
							<email>koudas@cs.toronto.edu</email>
						</author>
						<author>
							<persName><forename type="first">Amélie</forename><surname>Marian</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Divesh</forename><surname>Srivastava</surname></persName>
							<email>divesh@research.att.com</email>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Toman</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Columbia University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University of Waterloo</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Structure and Content Scoring for XML</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8C86A8BCCA4FEC861AA66E3EF0358BB6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>XML repositories are usually queried both on structure and content. Due to structural heterogeneity of XML, queries are often interpreted approximately and their answers are returned ranked by scores. Computing answer scores in XML is an active area of research that oscillates between pure content scoring such as the well-known tf*idf and taking structure into account. However, none of the existing proposals fully accounts for structure and combines it with content to score query answers. We propose novel XML scoring methods that are inspired by tf*idf and that account for both structure and content while considering query relaxations. Twig scoring, accounts for the most structure and content and is thus used as our reference method. Path scoring is an approximation that loosens correlations between query nodes hence reducing the amount of time required to manipulate scores during top-query processing. We propose efficient data structures in order to speed up ranked query processing. We run extensive experiments that validate our scoring methods and that show that path scoring provides very high precision while improving score computation time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>XML data is now available in different forms ranging from persistent repositories such as the INEX and the US Library of Congress collections to streaming data such as stock quotes and news <ref type="bibr" target="#b15">[16]</ref>. Such data is often queried on both structure and content <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19]</ref>. Due to Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proceedings of the 31st VLDB Conference, Trondheim, Norway, 2005</head><p>the structural heterogeneity of XML data, queries are usually interpreted approximately <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b14">15]</ref> and topanswers are returned ranked by their relevance to the query. The term frequency (tf) and inverse document frequency (idf) measures, proposed in Information Retrieval (IR) <ref type="bibr" target="#b12">[13]</ref>, are widely used to score keyword queries, i.e., queries on content. However, although some recent proposals <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b14">15]</ref> attempted to propose scoring methods that account for structure for ranking answers to XML queries, none of them fully captures both structure and content and uses query relaxation in computing answer scores.</p><p>In this paper, we propose scoring methods inspired by tf*idf to capture scoring and ranking queries both on structure and content. These methods rely on query relaxation techniques applied to structural predicates, i.e., XPath axes, such as in <ref type="bibr" target="#b0">[1]</ref>. We define twig scoring as our method of reference as it accounts for all structural and content correlations in the query. However, it is time and space consuming because it requires computation of the scores of all relaxed versions of a query. Therefore, we propose path scoring as an approximation of twig scoring that loosens correlations between query nodes when computing scores, thereby reducing the amount of time required to compute and access scores during top-query processing. The key idea in path scoring is to decompose the twig query into paths, compute the score of each path assuming independence between paths, and combine these scores into an answer score. This is in the same spirit as the vector space model of IR <ref type="bibr" target="#b12">[13]</ref> where independence is assumed between query keywords and answer scores are computed as a combination of individual query keywords' scores.</p><p>In <ref type="bibr" target="#b9">[10]</ref>, we proposed binary scoring that also accounts for structural predicates and that computes answer scores by combining scores of individual child and descendants predicates in the query thereby assuming independence between all predicates. This scoring method is in fact an approximation of twig and path scoring that needs less time and space in exchange for a degradation in score quality.</p><p>Efficient top-processing requires the ability to prune partial query matches, i.e., those that will never make the top-answer list, as early as possible during query evalua-tion. Given a query and a scoring method, different answers might have different scores depending on which relaxed form of the query they satisfy. In addition, the same answer might have a different score from one scoring method to another. However, all our scoring methods guarantee that more precise answers to the user query are assigned higher scores. This property can be used by any top-algorithm since pruning is based on determining the most accurate score of a partial match using the query that the match satisfies best at a certain point in query evaluation and, identifying the best score growth of a partial match. Developing the right data structure and access method to store scores is a key factor in the efficient evaluation of ranked query answers <ref type="bibr" target="#b12">[13]</ref>. We show how organizing query relaxations with their scores in a DAG structure, and using a matrix to quickly determine the score of a partial match, leads to efficient query evaluation and top-processing.</p><p>To summarize, we make the following contributions:</p><p>¡ We propose twig scoring, a reference method for XML that is inspired by tf*idf in order to capture scoring query answers on both structure and content while accounting for query relaxation. We also propose path scoring, an approximation of twig scoring that reduces processing time. In addition, we discuss another approximation, binary scoring, that we previously proposed in <ref type="bibr" target="#b9">[10]</ref>. All these scoring methods rely on the ability to evaluate structural predicates approximately.</p><p>¡ We propose a DAG to maintain precomputed idf scores for all possible relaxed queries that a partial match may satisfy. We use a matrix representation for queries, their relaxations, and partial matches to quickly determine the relaxed query that is best satisfied by a partial match during top-query processing and prune irrelevant partial query matches.</p><p>¡ We implemented all our scoring methods in conjunction with a top-processing algorithm. We ran extensive experiments on real and synthetic datasets and queries and showed that, compared to twig scoring, path scoring achieves very high precision for topqueries while requiring moderate time; and that binary scoring results in high savings in time and space, but exhibits significant degradation in answer quality.</p><p>Related work is given in Section 2. Section 3 contains examples to motivate relaxation, scoring and top-processing. Section 4 gives definitions and the implementation of our scoring. Experiments are detailed in Section 5. We conclude outlining several open issues in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Scoring for XML is an active area of research <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19]</ref>. However, with the exception of <ref type="bibr" target="#b9">[10]</ref>, none of the existing proposals accounts for structural query relaxations while scoring on both structure and content. However, we show in this paper that the binary scoring method that we proposed in <ref type="bibr" target="#b9">[10]</ref>, while efficient, does not provide high quality answers compared to the reference twig scoring method.</p><p>The INitiative for the Evaluation of XML retrieval (INEX) 1 promotes new scoring methods for XML. INEX now provides a collection of documents as a testbed for various scoring methods in the same spirit as TREC was designed for keyword queries. Unfortunately, none of the proposed methods used in INEX as yet is based on structural relaxations to compute scores. As a result, the INEX datasets and queries would need to be extended to account for structural heterogeneity. Therefore, they could not be used to validate our scoring methods. As part of this effort, XIRQL <ref type="bibr" target="#b5">[6]</ref> is based on a probabilistic approach <ref type="bibr" target="#b11">[12]</ref> to compute scores at document edges and combines them to compute answer scores. The score of each keyword uses a path expression associated to the keyword in a query instead of document-based scores as in traditional IR <ref type="bibr" target="#b12">[13]</ref>. However, no relaxations are applied to path expressions. Similarly, JuruXML <ref type="bibr" target="#b2">[3]</ref> allows users to specify path expressions along with query keywords and modifies vector space scoring by incorporating a similarity measure based on the difference in length, referred to as length normalization, between the path expression provided in the query and the closest path in the data. We believe that relying on a principled way of applying relaxations to XPath queries carries more semantics than length normalization.</p><p>In <ref type="bibr" target="#b17">[18]</ref>, the authors study the relationship between scoring methods and XML indices for efficient ranking. They classify existing methods according to keyword and path axes. Based on that classification, they show that ranking on both structure and content are poorly supported by existing XML indices and propose IR-CADG, an extension to dataguides to account for keywords, that better integrates ranking on both structure and content. They show experimentally that this index outperforms existing indices that separate structure and content. This work is complementary to ours. It considers simple path queries and does not account for relaxations. It would be interesting to see how our DAG structure could be combined with the IR-CADG index to explore both structural relaxations and a tighter integration of indices on structure and on keywords.</p><p>Several query relaxation strategies for graph <ref type="bibr" target="#b7">[8]</ref> and tree <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b14">15]</ref> queries have been proposed before. In this paper, we adopt the relaxation framework defined in <ref type="bibr" target="#b0">[1]</ref> since it captures most previously proposed relaxations and is general enough to incorporate new relaxations. While in <ref type="bibr" target="#b0">[1]</ref>, the focus was on defining a relaxation framework and query evaluation strategies assuming a given scoring function, in this paper, we focus on scoring methods and data structures to evaluate top-XML queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Motivation</head><p>We represent XML data as forests of node labeled trees. Figure <ref type="figure" target="#fig_0">1</ref> shows a database instance containing fragments   of heterogeneous news documents <ref type="bibr" target="#b15">[16]</ref>. Figure <ref type="figure" target="#fig_1">2</ref> gives examples of several queries drawn as trees: the root nodes represent the returned answers, single and double edges the descendant and child axes, respectively, and node labels names of elements or keywords to be matched. Intuitively, it makes sense to return all three news documents as candidate matches, suitably ranked based on their similarity to query (a) in Figure <ref type="figure" target="#fig_1">2</ref>. Queries (b), (c) and (d) in Figure <ref type="figure" target="#fig_1">2</ref>, correspond to structural relaxations of the initial query (a) as defined in <ref type="bibr" target="#b0">[1]</ref>.</p><formula xml:id="formula_0">¢ ¤£ ¦¥ ¨ § © § ¨ § ! #" %$ '&amp; ( %) ¦0 ©( 1&amp; #" 2$ %&amp; ( %3 4 %5 '6 ¢ ¤£ ¥ § § ¦ ! ¨ § ¤ ! #" %$ '&amp; ( %) ¦0 ©( ©&amp; #" 7$ %&amp; ( %3 4 25 86 ¢ ¤£ ¥ § ¤ § ! § © #" 7$ 7&amp; ( %) #0 ©( &amp; 9" 7$ 7&amp; ( %3 4 @5 96 ¢ £ ¤¥ ¨ § © § ¦ § © &amp; #" %$ 7&amp; ( %3 4 %5 '6 A ¥ ©B A C B A ¢ B A D B ¢ £ ¥ ¨ § § ! § A ©B ¢ £ ¥ © § © § ! &amp; 9" 7$ 7&amp; ( %3 4 %5 '6 A E B &amp; #" 2$ 7&amp; ( %3 4 %5 86</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Query Relaxation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Different queries match different news documents in</head><p>In the same manner, none of the three documents in Figure <ref type="figure" target="#fig_0">1</ref> matches query (e) because none of their S WG TS HF XU s contains a cb Pd fe b ga ih qp r ts Tu . Query (f), on the other hand, is matched by all documents because the scope of a cb Pd ve b Pa ih qp r ts Tu is broader than in query (e). It is thus desirable to return these documents suitably ranked on their similarity to query (e).</p><p>In order to achieve the above goals, we use three relaxations: edge generalization (replacing a child axis with a descendant axis), leaf deletion (making a leaf node op-tional) and subtree promotion (moving a subtree from its parent node to its grand-parent). These relaxations capture all the structural and content approximations described in the examples. However, approximate keyword queries based on techniques such as stemming and ontologies <ref type="bibr" target="#b16">[17]</ref>, are orthogonal to and beyond the scope of this work.</p><p>Our relaxations capture approximate answers but still guarantee that exact matches to the original query continue to be matches to the relaxed query. For example, query (b) can be obtained from query (a) by applying edge relaxation to the axis between G TS HU PV and S WG PS YF XU and still guarantees that documents where S WG TS YF qU is a child of G TS HU TV are matched. Query (c) is obtained from query (a) by composing edge generalization between G TS HU TV and S WG PS YF XU and subtree promotion (applied to the subtree rooted at F YG PI `Q ). Finally, query (d) is obtained from query (c) by applying leaf deletion to the nodes w xb Pd fe b Pa ch Py b P h , S fG TS YF XU and G TS HU TV . Query (d) is a relaxation of query (c) which is a relaxation of query (b) which is a relaxation of query (a). Similarly, query (f) in Figure <ref type="figure" target="#fig_1">2</ref> can be obtained from query (e) by a combination of subtree promotion and leaf deletion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Answer Scoring</head><p>In order to distinguish between answers to different relaxations of the same query, we need a scoring method to compute the relevance of each query answer to the initial user query. The traditional tf*idf measure is defined in IR for keyword queries against a document collection. The idf, or inverse document frequency, quantifies the relative importance of an individual keyword in the collection of documents. The tf, or term frequency, quantifies the relative importance of a keyword in an individual document. In the vector space model <ref type="bibr" target="#b12">[13]</ref>, query keywords are assumed to be independent of each other, and the tf*idf contribution of each keyword is added to compute the final score of a document.</p><p>In our context, the most accurate scoring method would compute the score of an answer taking occurrences of all structural and content (i.e., keyword) predicates in the query. For example, a match to query (c) would be assigned an idf score based on the fraction of the number of T Y I `I HU RF nodes that have a child G TS HU PV with a descendant S fG TS YF XU containing the keyword w b Pd ve b Pa ih Py b P h and a descendant F YG PI RQ that contains the keyword a cb gd fe b Pa ih p r ts Tu . Such a match would be assigned a tf score based on the number of query matches for the specific T H I `I YU RF answer. We refer to this method as twig scoring.</p><p>While twig scoring captures all correlations between nodes in the query, it is time and memory consuming because it requires to compute the scores of each relaxed query. Therefore, we define path scoring that loosens the correlations between query nodes by assuming independence between root-to-leaf paths in the query, computing their scores and combining those scores to compute an answer score. For example, for query (a) in Figure <ref type="figure" target="#fig_1">2</ref>, twig scoring is based on the number of T Y I XI YU RF nodes that have an G TS HU TV with a S fG TS YF XU containing w b Pd fe b ga ih Py b P h and a F YG PI `Q containing a Tb Pd fe b Pa ch qp r ts Tu while path scoring relies on decomposing the query into its two paths, computing their scores separately and combining them to computer an answer score. Hence, it might not always distinguish between answers to different relaxed queries as well as twig scoring.</p><p>The scoring method proposed in <ref type="bibr" target="#b9">[10]</ref> is another approximation of twig scoring. We refer to it as binary scoring because it scores binary predicates with respect to the query root, and assumes independence between those predicates. In query (a) in Figure <ref type="figure" target="#fig_1">2</ref>, that would amount to computing the scores of the child predicate between P Y I `I YU `F and G TS HU TV and the scores of descendant predicates between T Y iI `I YU RF and each one of the remaining nodes in the query including keyword nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Top-Processing</head><p>Scores need to be organized in such a way that helps to determine the highest score of a partial match during topprocessing in order to speed up pruning of irrelevant answers. To avoid computing scores on-demand, query evaluation could take advantage of the fact that idfs are shared across all partial matches that satisfy the same (relaxed) query. For example, all answers that match query (b) in Figure <ref type="figure" target="#fig_1">2</ref> and not query (a) would have the same idf. Therefore, we propose to precompute and store idfs for all possible relaxations of the user query. This allows for fast access to score values during query processing. We use two data structures: a Query Relaxations DAG, and a Query Matrix, discussed in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Scoring</head><p>In this section, we formally define approximate answers to twig queries based on the notion of query relaxation and the corresponding scoring methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Twig Queries and Relaxations</head><p>We use previously defined twig queries, an important subset of XPath. A twig query (on nodes) is a rooted tree with string-labeled nodes and two types of edges, (a child edge) and q (a descendant edge). <ref type="foot" target="#foot_0">2</ref> We call the root node ¨ X q © of the distinguished answer node.</p><p>We use the term match to denote the assignments of query nodes to document nodes that satisfy the constraints imposed by the query and the term answer to denote document nodes for which there is a match that maps the root of the query to such a node. Note that for a particular answer there can be multiple matches in a document. For example, in the document " d g e fd g h f i " there are two matches but only one answer to the query H id . We denote ji ¦k 1l the set of all answers to in a document k . Definition 1 Let and nm be twig queries. We say that nm subsumes if ji #k ol qp r m i #k 1l for all documents k .</p><p>To capture approximate answers to a given twig query we generate relaxed twig queries on a subset of the query nodes based on the following notion of query relaxation: Definition 2 (Relaxation) Let be a twig query. We say that m is a simple relaxation of (and write ts u v m ) if m has been obtained from in one of the following ways: -an edge generalization relaxation: a edge in is replaced by a q edge to obtain m ; -a subtree promotion relaxation: a pattern xw d w jy gz 8 q i n{ cz is replaced by xw d w jy gz 7 X| ~} vp q i n{ cz ; or -a leaf node deletion relaxation: a pattern xw jy P X| ~} Yp d z</p><p>where is the root of the query and d is a leaf node is replaced by xw y tz .</p><p>We say that m is a relaxation of (and write s u r m ) if it is obtained from by a composition of simple relaxations ( ).</p><p>Note that, given a query with the root labeled by , the most general relaxation is the query . We denote this query by . Every exact answer to a relaxation of is an approximate answer to , and the set of all approximate answers to in a document k is equal to i #k ol . The relaxations defined above do not capture approximating content such as using stemming or ontologies on keywords <ref type="bibr" target="#b16">[17]</ref>. While a detailed discussion of this direction is beyond the scope of the paper, the actual way of relaxing matches to keywords is orthogonal to the remaining development in the paper.</p><p>We organize the set of all relaxations of a query into a directed acyclic graph (DAG) in which edges relate relaxations in a subsumption relation. We need two preliminary lemmas:</p><p>Lemma 3 Let and m be twig queries such that s u m . Then ji ¦k 1l p m i #k 1l for all documents D. Proof: Each simple relaxation satisfies the statement of the lemma (by inspection); the rest follows from transitivity of the inclusion relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4 Let and m be two twig queries such that</head><p>s u m and m s u . Then m . Proof: From Lemma 3 we know that ji #k ol 1p m i #k 1l and m #i #k 1l p ji #k 1l for all documents k . Thus nm . However, this is only possible if m (syntactically) as each simple relaxation produces a strictly less restrictive query.</p><p>Equipped with these two lemmas we can organize the relaxations in a DAG as follows:</p><p>Definition 5 (Relaxation DAG) Let be a twig query. We define  Proof: For a query relaxation node in the DAG and for every node in that relaxation the algorithm applies all al-lowed simple relaxations (cf. Definition 2: only one simple relaxation applies per node in a query). Nodes representing these relaxations become the children of this node in the DAG; new nodes are only created when they don't already exist. The reminder of the proof is a simple induction on the distance of a node from the root of the DAG. Termination of the algorithm is guaranteed as there are only finitely many relaxations of a given query.</p><formula xml:id="formula_1">g 2 ¡ i £¢ T m ¤ ¥s u m 9¦ q § ¢ qi ¦ m § m m l ¤ s u m q¨ m s u m m ¦ l</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Scoring Twig Answers</head><p>As the approximate answers to a query are simply answers to the relaxation , our goal in this section is to rank elements of i ¦k 1l by assigning numerical values using a scoring function. The basic idea is that scores are based on considering best matches for a given answermatches to the least relaxed query in the DAG. We base our scoring function on the tf*idf measure proposed in IR <ref type="bibr" target="#b12">[13]</ref>. However, we have to modify this measure to distinguish among matches to different relaxations of the original query. We first define the modification of the inverse document frequency (idf ): Definition 7 (idf of a Relaxation) Let and m be twig queries such that «s u x m and k an XML document. We define</p><formula xml:id="formula_2">¬ x ® i m l ¯ ¤ i ¦k 1l ¤ ¤ m i #k 1l ¤ °W</formula><p>e extend this measure to all approximate answers b ± 1 by defining</p><formula xml:id="formula_3">¬ x ® i #b ql ¯ ² j³ iv¢ ¬ ® i m l ¤ b ± 1 m i ¦k 1l § ¥s u m ¦ p</formula><p>We say that a relaxation m that maximizes</p><formula xml:id="formula_4">¬ x ®</formula><p>i #b ql is a most specific relaxation of for b and denote the set of these relaxations by µ j ¶ x• ® i #b ql .</p><p>Our idf scoring guarantees that answers to less approximate queries obtain idf scores at least as high as scores to more approximate ones; this is also the basis for assuring that the score-monotonicity requirement is met by the overall score of an answer. In particular: Lemma 8 Let m and m m be two relaxations of such that m s u m m . Then</p><formula xml:id="formula_5">¬ x ® i m l ¬ ® i m m l for any document k .</formula><p>Proof: By definition, any answer to m m is an answer to m , as m m is a relaxed version of m . Therefore, the denominator value in the idf function for the computation of m m is greater than or equal to the denominator value in the idf function for the computation of . It results that</p><formula xml:id="formula_6">¬ x ® i ¦ m l ¬ x ® i ¦ m m l .</formula><p>Thus, since the idf score for an answer b is defined as the maximal idf value of all relaxations of having b as an answer, the above lemma also shows that</p><formula xml:id="formula_7">¬ ® i ¦b ql ¬ x ®</formula><p>i #b m l whenever the best match for b matches a less relaxed query than the best match for b im .</p><p>Intuitively, the idf measure of a query quantifies the extent to which answers to in k additionally satisfy . Thus, more selective queries are assigned higher idf scores. This is akin to the IR case: keywords that appear in a document collection less frequently are assigned higher idf scores.</p><p>Note, however, that the idf measure defined above assigns the same idf score to all exact matches to a query . In general, all answers having their best match with respect to the same relaxed query are given the same idf score. On the other hand, the idf measure becomes useful once we allow for relaxed matches to the query , as described in Section 3. The idf scores are then used to rank relaxed matches based on how closely they match the relaxed query. To distinguish between matches of the same relaxed query we use the analogue of the term frequency (tf ) measure: Definition 9 (tf of an Answer) Let be a twig query and k an XML document. Then, for an answer</p><formula xml:id="formula_8">b ± ¸ i #k 1l , we define ¹ ® i #b § m l ¯ ¤ ¢ cº ¤ º j³ ² j³ ¨» ½¼ n i¾ m q¿ 7À k § º ¯i ¨ ` © ÂÁ l ¯ Ãb ¦ `¤</formula><p>for m a most specific relaxation of for b , and</p><formula xml:id="formula_9">¹ ® i #b ql ¯ ² j³ if¢ ¹ ® i #b § m l ¤ m ± Äµ j ¶ x• ® i #b ql ¦ p</formula><p>Intuitively, the tf score of an answer quantifies the number of distinct ways in which an answer matches a query. This is again akin to the IR case where the term frequency increases with the number of occurrences of a keyword in a document. The final scoring function for twig queries is based on combining the idf and tf scores. We use a lexicographical i idf § tfl ordering to satisfy the score monotonicity requirement.</p><p>Definition 10 (Lexicographical Score) Let k be an XML document, a query, and b and b m approximate answers to</p><formula xml:id="formula_10">in k . We define b nÅ b m ¿ ¾ i ¬ x ® i #b ql q ¬ x ® i #b m l ©l q i ¬ x ® i #b ql ¯ ¬ x ® i #b m l W³ À HAE ¹ ® i ¦b l qÅ ¹ ® i #b m l ©l</formula><p>Using this definition and Lemma 8 we have: Note that the more common combinations of the tf and idf scores, e.g., the</p><formula xml:id="formula_11">Theorem</formula><formula xml:id="formula_12">¹ ® i #b ql PÇ ¬ x ®</formula><p>i ¦b ql function, do not adhere to our requirement of matches to less relaxed queries to be ranked higher. Consider, for example, the query H id posed over the concatenation of two documents " È d g c " and " É o Êr Êd g «p 2p %p ~ ¥ ir É " with Ë { nested "d " elements. Then the idf scores for H id and the relaxation H q id are { and y , respectively. However, the tf measures are y and Ë . Thus the more common tf*idf ranking would prefer the second (less precise) answer. Note also, that dampening the tf factor, e.g., using a Ì function, cannot solve this inversion problem as we can choose Ë to be arbitrarily large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Scoring for Path/Binary Approximations</head><p>We use twig scoring as the reference measure of correctness since it accounts for the most structure and content. However, to compute the scores of answers we need to have access to the idf scores associated to all relaxations of the original query. As we pointed out in the previous section, computing (or even precomputing whenever possible) these scores can be very expensive. Thus in order to improve efficiency of the overall query processing, we define approaches based on decomposing an original twig query to simpler queries and this way we reduce the number of different idf scores needed. Also, in many cases the scores for such simpler queries are easier to compute. In particular, we consider two decompositions Í Î PÏ tÐ YÑ nÒ qi l for a twig query :</p><p>Path Decomposition the set of all paths in leading from the root of to any other node in ; and Binary Decomposition the set of all queries Ó Ô ¨ ` Tu or Ó Õ © ` q q Tu for u a node in such that «p r nÓ . The decompositions for our example query are as follows:</p><p>Example <ref type="bibr" target="#b11">12</ref> The sets of queries</p><formula xml:id="formula_13">¢ » ½¼ ³ À HÀ g ¿ ² È ¿ % § » ½¼ ³ À YÀ g ¿ ² È ¿ 7À HÖ ¦ q § ¢ » ½¼ ³ À HÀ g ¿ ² § » ½¼ ³ À HÀ g ¿ % § » ½¼ ³ À HÀ g q ¿ %À HÖ ¦</formula><p>are the Path and Binary Decompositions, respectively, of a twig query " » ½¼ ³ À HÀ g ¿ ² ow p ¿ 2 z 8 ¿ 7À HÖ ".</p><p>For each decomposition, we also need to define how the scores for the individual fragments are combined into a final answer score. The idf measure depends on whether we consider joint (correlated) matches only or assume independence between matches to the individual components of a twig query. Hence, we have two definitions of idf : one for the correlated case and one for the independent case. Definition 13 (Path/Binary idf Score) Let be a twig query, m a relaxation of , and k an XML document. We define</p><formula xml:id="formula_14">¬ x ® i ¦ m l ¯ ¤ n i #k 1l ¤ ¤ × ÕØ ¤Ù iÚ ©Û 9Ü #Ý Þ xß à % Á @á Ó i #k ol ¤</formula><p>for correlated scoring, and</p><formula xml:id="formula_15">¬ ® i m l ¯ â Ø Ù iÚ ©Û 9Ü #Ý Þ xß à % ÕÁ á ¤ n ãi ¦k 1l ¤ ¤ Ó i #k 1l ¤</formula><p>for independent scoring.</p><p>The idf score of an answer under the above assumptions is again the maximal idf of a relaxation containing the answer.</p><p>The tf measure is the same in both cases as it is defined on a per-answer basis: Definition 14 (tf for Path/Binary) Let be a twig query, m a relaxation of and k an XML document. Then, for b n± o ji ¦k 1l , we define</p><formula xml:id="formula_16">¹ ® i #b § m l ä å Ø Ù iÚ ©Û #Ü 9Ý Þ xß !à 2 ÕÁ á ae ae ae ae ç º ¤ º j³ ² j³ ¨» ½¼ i¾ Ó ¿ 7À k § º ¯i © ` q © Ø l ä b è ae ae ae ae</formula><p>where m is a most specific relaxation for b , and</p><formula xml:id="formula_17">¹ ® i #b ql ¯ ² j³ if¢ ¹ ® i #b § m l ¤ m ± Äµ j ¶ x• ® i #b ql ¦ p</formula><p>Similarly to the twig scoring, we can show that the lexicographical i idf § tfl ordering of query answers based on the scores obeys the score monotonicity requirement. Note that the distinction between independent and correlated scoring only applies for binary and path scoring. Altogether we have defined five scoring methods, listed in the order of increasing precision: binary-independent that considers all predicates to be independent, binarycorrelated that takes into account correlations between individual binary predicates, path-independent that assumes independence between query paths, path-correlated, that takes into account the correlation both within paths and across paths in the query, and twig, the reference scoring method, that takes all of the query twig correlations into account.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Top-Query Processing</head><p>In this section, we discuss data structures that can be used by any top-processing algorithm to compute top-answers to XML queries efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Using the DAG</head><p>As mentioned earlier, our DAG provides a convenient, constant-time access to the idf value of any partial match during query processing (see Figure <ref type="figure">3</ref> for an example). This value can be computed using selectivity estimation techniques for twig queries <ref type="bibr" target="#b10">[11]</ref>.</p><p>Note that every (even partial) match is an exact match to a relaxation of the original query. Also, for matches we have:</p><p>Lemma 15 Let be a query, k an XML document, and º a match for an answer b Ã± é i #k 1l . Then there is a unique query nm ± g % ¡ such that º is a match for b ê± Ã m i ¦k 1l and º is not a match for b in m m i #k 1l for any ancestor m m of m in g 2 ¡ .</p><p>Thus it is sufficient to associate a single score with every match. At each DAG node, we keep the maximum theoretical upper bound for a partial match that satisfies the twig query associated with that node: if the query at that node includes all nodes of the original query, then a partial match that satisfies this twig query cannot be further extended, and its score upper bound value is equal to its idf value; however, if the twig query does not include all the nodes from the original query, e.g., if it is a relaxation of the original query where some leaf deletion operations were applied, we store a pointer in the DAG to the DAG node containing the best relaxation such an incomplete partial match could satisfy. In the same manner, we can keep pointers in the DAG to access information such as the score upper bound values of all possible configurations of partial matches (some nodes missing, some nodes unknown), or the maximum score increase (in idf value) that would be gained from checking one of possible unknown nodes in the partial match. During query evaluation, idf s are accessed in constant time using a hash table to check the query partial matches against the twig queries stored in the DAG.</p><p>From Lemma 8, it follows that the deeper a query is in the DAG, the lower its idf is. An example of a query relaxation DAG for the (simplified) query from Figure <ref type="figure" target="#fig_1">2</ref>(a) is given in Figure <ref type="figure">3</ref>. Note that a, the lowest (most relaxed) query in the DAG, has an idf of 1 as it consists of returning every single distinguished node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">Using the Matrix</head><p>We propose a query matrix used to apply relaxations to queries during the DAG building step and, more importantly, to map a partial match to its corresponding query using matrix subsumption during query evaluation. By representing both partial matches and queries in the same framework, we can compare them efficiently, by only requiring a matrix comparison.</p><p>The matrix is defined for twig queries on u nodes; we assume that the nodes are named ¢ g| äë § p gp gp | ~ì ¦ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 16 (Matrix Representation)</head><p>Let be a twig query on at most u nodes. We define a u îí eu matrix ï as follows:</p><formula xml:id="formula_18">¡ ï w ð § ð ¦z f if the node | Ó ± 1 has label ; ï w ð § ð ¦z f ñ if the node | ÕÓ ò ± ; ï w ð § ð ¦z f ó otherwise; ¡ ï w ð § ¦ô z f Ê if | Ó T| fõ ± 1 ; ï w ð § ¦ô z Â if there is a path from | Ó to | fõ in but | ~Ó ¤ T| õ ò ± 1 ; ï w ð § ¦ô z ä ñ if | ~Ó § | õ ± e</formula><p>and there is no path from</p><formula xml:id="formula_19">| ~Ó to | õ ; ï w ð § ¦ô z f ó otherwise.</formula><p>A subsumption order between the symbols stored in the matrix cells is defined as follows: öó , Ä ö ¸ ó , and ñ Ô ÷ó . The reflexive subsumption order Å is the above order extended with the diagonal relation on the symbols. A partial match matrix can be defined similarly.</p><p>It is easy to see that a lower matrix is sufficient to capture all the information represented in as queries are trees. Figure <ref type="figure" target="#fig_5">4</ref> shows the query matrix 4(a) for the (simplified) query from Figure <ref type="figure" target="#fig_1">2</ref>(a), and several possible partial matches to this query that can be computed during query evaluation: 4(b) is a partial match that has not yet been  checked against title, hence the corresponding entries are set to "?"; the relationship between channel and item for that partial match has been relaxed to "//". 4(c) is the same partial match as 4(b), with no title nodes found, the corresponding matrix entries are then equal to "X". Finally, 4(d) is a extension of 4(b) for which an exact match for node title has been found. Matrices are created for partial matches by checking their binary node relationships. Operations on matrices are performed in three situations: to create a relaxed version of a query in the DAG building process (e.g., by replacing all entries involved in an edge generalization with their relaxation), to check whether a query is a relaxation of another query (matrix subsumption), or to check whether a partial match maps to a query pattern (matrix subsumption).</p><p>Matrix creation and subsumption operations need i 9u 1ø P { `l comparison where u is the number of query nodes. Since queries are expected to be fairly small, most often no larger than 10 nodes, this produces efficient computation times. Each matrix entry has a maximum of 4 possible entries therefore there are at most ù ì ãú ¨û ø relaxations of a given query; the actual number tends to be much lower as most matrix combinations are not possible. This loose upper bound also gives us an upper bound on the size of the DAG, as there is only one DAG node per query relaxation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.3">Top-Algorithm</head><p>In this paper, we do not claim the top-processing algorithm as a contribution since we use the adaptive processing algorithm developed in <ref type="bibr" target="#b9">[10]</ref>. However, our DAG and matrix data structures could be used by any top-algorithm to determine (i) the highest score of a partial match during query evaluation and (ii) if a partial match should be pruned or not depending on its score upper bound.</p><p>Algorithm 2 is a sketch of the top-algorithm that we use. It starts by evaluating the query root node. Then, it determines the partial matches with the highest score potential using getHighestPotential which relies on score upper bounds extracted from the DAG to prioritize partial matches. The algorithm then expands those matches by computing the next best query node for each one of them. Note that the algorithm treats each partial match individually (as opposed to a batch processing). When a partial match is generated, it is checked against the top-list (updateTopK). The partial match may be used to update the top-list or it may be carried to the next step or it may be pruned. The algorithm stops when all query nodes have been evaluated for all matches in the top-list and there is no other match that is waiting to be processed. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Evaluation</head><p>In this section we briefly discuss our implementation of top-query processing techniques and then present extensive quality and efficiency evaluations of the proposed XML scoring methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Summary of Results</head><p>Our experimental evaluation compares the five scoring methods: binary-independent, binary-correlated, pathindependent, path-correlated, and twig. Twig results in the perfect top-answer. Our results show that the binary scoring methods allow for fast DAG preprocessing and query execution times, in exchange for degraded answer quality. When score quality is important, both path methods offer good quality answers, but path-correlated requires high preprocessing times. In contrast, path-independent offers good answer quality (often perfect), while saving in terms of preprocessing times. We implemented our top-strategies such that all idf s and score upper bounds are accessed through the DAG. Our (idf,tf) scoring measure (see Section 4.2) assigns the same idf s to matches that share the same (relaxed) query pattern. Ties on such matches are broken based on the answers tf s. Since, unlike idf, each match has an individual tf score, it is more efficient to estimate the tf of a match during query evaluation based on selectivity estimates (which can be stored in the DAG). However, in order to avoid skewing results in our experimental evaluation of idf scoring, we do not take tf s into account.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experimental Setup</head><p>We implemented the DAG and query matrix structures, as well as the top-query processing strategies from <ref type="bibr" target="#b9">[10]</ref> in C++. We ran our experiments on a Red Hat 7.1 Linux 1.4GHz dual-processor machine with 2Gb of RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Data and Queries</head><p>To offer a comprehensive evaluation of our scoring methods, in terms of time and space, as well as their effect on query processing, we performed experiments on synthetic XML data. Results on real data are given in Section 5.3.5.</p><p>We generated heterogeneous collections of documents using the Toxgene document generating tool 3 . In order to enable query relaxation, documents of various sizes were generated using heterogeneous DTDs. For our synthetic experiments, the created documents contain simple node labels (e.g., &lt;a&gt; and &lt;b&gt;), and U.S. state names as text content. We then ran our experiments on different datasets by assembling documents based on size (in terms of number of nodes). We also performed experiments on collections where we varied the parameters of the datasets such as correlation or number of exact answers. We measured the correlation of a dataset as the type of matches to query predicates that are present in the dataset: simple binary predicates (no correlation), binary predicates only, binary predicates and simple path predicates, binary and path predicates, and mixed (all three types of predicates are present in the dataset). The number of exact answers is a percentage of the top-answers that are exact answers to the query. We report our values for correlation and the number of exact answers with respect to our default query ü cý .</p><p>We evaluated our scoring methods on 18 different queries exhibiting different sizes, query structures (twig shapes), and content predicates. We chose these 18 queries to illustrate the different possible query relaxation structures that may happen in a real-world scenario.</p><formula xml:id="formula_20">þ ÿ : a[./b/c] þ ¡ : a[./b][./c] þ £¢ : a[./b/c/d] þ £¤ : a[./b[./c/]/d] þ ¦¥ : a[./b][./c][./d] þ £ § : a[./b/c/d/e] þ £¨: a[./b[./c]/d/e] þ © : a[./b/c/d/e/f] þ £ : a[./b[./c/d]/e/f] þ £ : a[./b[./c[./e]/f]/d][./g] þ ¡ ©ÿ : a[contains(./b,"AZ")] þ ¡ : a[contains(.,"WI") and contains(.,"CA")] þ ¡ ¢ : a[contains(./b/c,"AL")] þ ¡ ¤ : a[</formula><p>contains(./b,"AL") and contains(./b,"AZ")] þ ¡ ¥ : a[contains(.,"WA") and contains(.,"NV") and contains(.,"AR")]  We performed our synthetic data experiments varying different parameters: query size, query shape, document size (in terms of number of nodes that satisfy each query node), document correlation, number of exact answers, . The default parameters we used for our experiments are summarized in Table <ref type="table">1</ref>.</p><p>Finally, we also ran several experiments on a real dataset: the XML version of the Wall Street Journal Treebank<ref type="foot" target="#foot_1">4</ref> corpora. Treebank provides text annotations of English sentences, the dataset we use consists of annotated Wall Street Journal text. Sentences are broken using tags representing various grammatical (phrases) and speech structures. For instance, &lt;NP&gt; represents a noun phrase within a sentence (&lt;S&gt;), the noun phrase can include different part-of-speech such as a singular noun (&lt;NN&gt;). Tags used in the queries we tested include: prepositional phrase (&lt;PP&gt;), verb phrase (&lt;VP&gt;), determiner (&lt;DT&gt;), interjection, (&lt;UH&gt;), comparative adverb (&lt;RBR&gt;), and possessive ending (&lt;POS&gt;). We ran experiments on 6 queries of different sizes and shapes: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Evaluation Measures</head><p>To compare the performance of the idf scoring mechanisms, we used the following measures:</p><p>DAG Size: Memory size needed to store the DAG structure. This shows the memory size needed for each method. DAG Preprocessing Time: Time needed to build the DAG, compute the idf scores and all optional information stored in the DAG. In order to isolate the effect on scores approximation due to binary and path scoring methods, we computed the exact idf scores by exploring all matches. This preprocessing step can be improved using selectivity estimation methods such as in <ref type="bibr" target="#b10">[11]</ref>. Precision: Percentage of top-answers (and their ties) that are correct top-answers (or ties to the correct top-answer), according to the exact twig scoring method. Answer ties are answers to the query that share the same idf as the returned answer. Our Precision measure takes possible ties into account in order to penalize scoring methods that produce too many possible top-results (i.e., scoring methods that produce many answers with the same score) compared to the twig method. The precision measure gives some information about the quality of the answers returned. Query Processing Time: Time needed to compute the topanswer to the query, in addition to the DAG preprocessing time. This measure shows how score distribution impacts query processing time. Mixed (with respect to ü cý ) 12% (with respect to ü cý ) 25</p><p>Table <ref type="table">1</ref>: Experimental Default Settings Figure <ref type="figure">5</ref>: A Query Relaxations DAG for binary Scoring</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Experimental Results</head><p>We now present our experimental results for the evaluation of our different scoring strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">DAG Size</head><p>The path and twig scoring potentially result in different idf score values for each node in the relaxation DAG described in Section 4. Binary scoring does not assign different idf s to all DAG nodes, but only to those that result in different binary query structures. In order to save memory space, and DAG preprocessing time, it is therefore possible to only build a subset of the relaxation DAG when considering binary scores. A simple way to implement this optimization is to convert the original query into a binary predicate query, and build the relaxation DAG from this transformed query. Figure <ref type="figure">5</ref> shows the DAG that results from binary scoring (assuming independent predicate scoring for the idf scores) of the query in Figure <ref type="figure">3</ref>. Since the binary version of the query is much simpler than the query itself and results in fewer possible relaxations, its DAG is smaller than, or the same size as the original relaxation DAG; 12 nodes vs. 36 nodes in our example. Experimental evaluation shows that for queries that do not only consist of binary predicates but also offer some complex structural patterns, the DAGs for the twig and path scoring methods are an order of magnitude larger than the DAGs for the binary scoring methods. However, these more complex DAGs are still of a reasonable size (1MB for our larger query ü ! ), and can therefore be easily kept in main memory during top-query processing. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Comparing Scoring Methods</head><p>The preprocessing times needed to build the DAGs and compute the idf scores for each of our scoring methods are shown, for all 18 queries over a small dataset, in Figure <ref type="figure" target="#fig_9">6</ref> (logarithmic scale). The path-correlated method is the most expensive and its cost grows rapidly with the query size, with times greater than 100,000 secs for ü #" , ü !$ , ü ! , ü y &amp;% and ü y " ; its high cost is mostly due to very expensive score computation and propagation. Path-independent and twig are faster, with path-independent faster than twig for all non-chain queries. For chain queries: ü , ü { , ü (' , ü #" , ü y , ü y P{ and ü y &amp;% , the preprocessing times of twig and path-independent are similar. For these two methods, exploring all matches dominates preprocessing time. In the case of chain queries, the matches considered are the same for twig and path-independent, path-independent is slightly slower due to some score propagation (sum computation overhead). Note that this overhead will become negligible as the document collection size increases. The two binary methods are faster than their path counterparts, as they work on a smaller DAG, but they offer smaller score ranges. Binary-correlated can be expensive as the query size increases, and is often more expensive than twig. Since both correlated methods are outperformed by twig, we will not report further results for these methods in this paper.</p><p>Figure <ref type="figure">7</ref> shows the precision of top-query evaluation strategies when using the three remaining methods. The twig method has the perfect precision. Path-independent has very good precision, often equal to 1, or close. binaryindependent has the worst precision, as it does not offer a fine granularity of scores. If time is the main constraint, then binary-independent allows for fast preprocessing time in exchange for some degradation in score quality. If score quality is important, for chain queries, the twig approach is the best as it provides perfect precision, and is as fast as path-independent; for queries having more q 0 q 1 q 2 q 3 q 4 q 5 q 6 q 7 q 8 q 9 q 1 0 q 1 1 q 1 2 q 1 3 q 1 4 q 1 5 q 1 6 q 1 7</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DAG Preprocessing Time (in sec)</head><p>Twig Path-Correlated Path-Independent Binary-Correlated Binary-Independent q 0 q 1 q 2 q 3 q 4 q 5 q 6 q 7 q 8 q 9 q 1 0 q 1 1 q 1 2 q 1 3 q 1 4 q 1 5 q 1 6 q 1 7</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DAG Preprocessing Time (in sec)</head><p>Twig Path-Correlated Path-Independent Binary-Correlated Binary-Independent  We also compared the processing time needed to evaluate a top-query with the different scoring methods using the top-query evaluation strategies from <ref type="bibr" target="#b9">[10]</ref>. The twig and path techniques results in similar query execution times. However, we observed that the binary approaches may result in slightly faster query processing times, as more partial matches end up with the highest scores, allowing to identify a top-set earlier in the execution and discard low-quality matches faster. This makes binaryindependent the method of choice when time is an issue. An in-depth comparison of the performance of top-query processing strategies is beyond the scope of this paper. We refer the reader to <ref type="bibr" target="#b9">[10]</ref> for more details on this subject.</p><p>In the rest of this section, we study the different parameters that affect quality and speed of our proposed scoring methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3">Varying the Document Collection Size</head><p>Figures 8 shows the effect of document size, in terms of the number of document nodes that match each query node, on the precision of path-independent on a subset of the synthetic data queries. While precision is mostly affected by data distribution, larger documents may end up producing more ties to the top-answers, which in turn leads to lower precision values. Precision results for path-independent q 0 q 1 q 2 q 3 q 4 q 5 q 6 q 7 q 8 q 9 q 1 0 q 1 1 q 1 2 q 1 3 q 1 4 q 1 5 q 1 6 q 1 7 q 0 q 1 q 2 q 3 q 4 q 5 q 6 q 7 q 8 q 9 q 1 0 q 1 1 q 1 2 q 1 3 q 1 4 q 1 5 q 1 6 q 1 7 DAG Preprocessing Time (in sec)  (Figure <ref type="figure" target="#fig_13">8</ref>) are good overall. The queries that suffer the most from the simplified path scoring compared to the complex twig scoring are those queries that have twig patterns that have branching nodes below the root node, as the correlation in these patterns is lost by the path-independent scoring. Note that the chain queries ü { , ü (' and ü #" have low precision for one dataset: this is partly due to the fact that most of the answers to these queries are relaxed answers, and exhibit a twig pattern (due to subtree promotion), and to the presence of multiple ties in the answer set. Since our precision measure penalizes scoring approaches that produce many ties to the top-answers, some queries exhibit low values of precision for path-independent. In these cases, many answers tend to be assigned high scores, resulting in low precision values, although the exact answers are part of the high scoring answers. Note that this behavior is data-and query-dependent, which is the reason why ü { has low precision for the medium dataset, while ü (' and ü #" have low precision for the large dataset. In addition, we compared path-independent and twig preprocessing times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DAG Preprocessing Time (in sec)</head><note type="other">Twig Path-Correlated Path-Independent Binary-Correlated Binary-Independent</note><note type="other">Twig Path-Independent Binary-Independent</note><p>The results are consistent with those in Figure <ref type="figure" target="#fig_9">6</ref>, and show that path-independent allows for faster DAG preprocessing times than twig when the query does not consist of a single chain. When queries have multiple paths (or binary) predicates, the savings in preprocessing time can be significant: up to 83% for the binary query ü ù , and 72% for the twig query ü % .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.4">Effect of Correlation</head><p>We now look at the effect of data correlation on the quality of top-answers. Figure <ref type="figure" target="#fig_16">9</ref> shows the precision for our scoring methods for ü cý on datasets exhibiting different answer types; for example, the binary dataset only produces answers that consist of binary predicates, while the mixed dataset produces answers that exhibit all three predicate patterns: binary, path and twig. As expected, as soon as some of the answers have complex predicates (twig or binary), the precision of the binary-independent scoring method drops. Interestingly, path-independent precision stays equal to one for all datasets, with the notable exception of the binary non-correlated path dataset. Note that q 0 q 1 q 2 q 3 q 4 q 5 q 6 q 7 q 8 q 9 q 1 0 q 1 1 q 1 2 q 1 3 q 1 4 q 1 5 q 1 6 q 1 7</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DAG Preprocessing Time (in sec)</head><p>Twig Path-Correlated Path-Independent Binary-Correlated Binary-Independent q 0 q 1 q 2 q 3 q 4 q 5 q 6 q 7 q 8 q 9 q 1 0 q 1 1 q 1 2 q 1 3 q 1 4 q 1 5 q 1 6 q 1 7</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DAG Preprocessing Time (in sec)</head><p>Twig Path-Correlated Path-Independent Binary-Correlated for that particular dataset, path-independent top-answers have an accuracy of 64% (64% of the returned answers are part of the top answers as returned by twig), however, the precision is much lower, as path-independent returns a high number of ties.</p><p>Path-independent has a perfect precision for datasets that produce correlated paths and twig answers. While path-independent does not take this correlation into account, the score ordering of the answers is not impacted, as the underlying predicate distribution is uniform. When individual path predicates have very different idf values, path-independent answers may be of low quality because the score ordering of answers may be different from that of twig. In effect, this means that sibling DAG nodes (DAG nodes that do not have an ancestor/descendant relationship, and therefore have no ordering constraint on their scores) may have their score ordering reversed between the twig and path-independent DAGs. We believe that this situation does not happen very often in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.5">Real Document Collections</head><p>Figure <ref type="figure" target="#fig_19">10</ref> shows the precision values for our 6 queries over the Treebank dataset. We considered two fragments of the dataset, with different sizes. Results are consistent with what we observed for synthetic data, with binaryindependent offering low precision, and path-independent offering high precision, often perfect. For our real data experiments, path-independent lowest precision was 0.4, but in two thirds of the query tested path-independent exhibited perfect precision.</p><p>As future work, we plan to extend the INEX datasets and queries in order to validate our scoring methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We presented a family of scoring methods, inspired by the tf*idf approach, that account both for the structure and the content in XML documents. Our methods score relaxed answers to XML queries in a way that guarantees that the closer an answer is to the exact query, the higher is its score. We also proposed efficient implementation structures to speed up XML top-query evaluation in this setting. We are planning to investigate streaming scenarios, where new data is constantly added to the dataset. By keeping the DAG structures for queries that users are interested in and updating the score information in a dynamic fashion we believe that we can provide an efficient and high quality top-query answering approach for a throughput-oriented streaming framework .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Heterogeneous XML Database Example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Query Tree Patterns and Relaxations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig- ure 1 .</head><label>1</label><figDesc>For example, query (a) in Figure2matches document (a) exactly, but would neither match document (b) (since F HG PI RQ is not a child of G TS RU TV ) nor document (c) (since G TS HU TV is entirely missing). Query (b) matches document (a) too since the only difference between this query and query (a) is the descendant axis between G TS RU TV and S WG TS HF XU . Query (c) matches both documents (a) and (b) since F YG PI `Q is not required to be a child of G TS RU TV while query (d) matches all documents in Figure1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :Figure 3 ,</head><label>33</label><figDesc>Figure 3: A Query Relaxations DAG Figure 3, disregarding the numerical scores attached to nodes, shows the DAG created for a simplified query (a) in Figure 2. Given a query , Algorithm 1 is used to build the DAG in a top-down fashion, starting with a node containing the query , applying the simple relaxation steps, and merging identical DAG nodes on the fly. This leads to the following result: Algorithm 1 buildDAG Function</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>11</head><label>11</label><figDesc>Let b § b m ± r i #k 1l , m and m m be the most specific relaxations of for b and b m in k , respectively, such that nm vs u m m . Then b cm xÅ b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Query Matrices</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>þ ¡ § : a[contains(./b,"NY") and contains(./b/d,"NJ")] þ ¡ ¨: a[contains(./b/c/d/e,"TX")] þ ¡ ¦© : a[contains(./b/c,"TX") and contains(./b/e,"VT")]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>3</head><label></label><figDesc>http://www.cs.toronto.edu/tox/toxgene/</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>TB0: S[./UH and contains(./VP,"There")] TB1: S[./NN[./NP]/DT] TB2: NP[./S/PP/NN] TB3: VP[./S/[./NP]/PP/NN] TB4: VP[./S/NP/PP/NN] TB5: S[./VP[./RBR][./POS] and contains(./VP,"should")]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: DAG Preprocessing Time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Figure 7: Top-Precision</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Top-Precision for path-Independent Scoring complex shapes, path-independent provides the best quality/preprocessing time tradeoff.We also compared the processing time needed to evaluate a top-query with the different scoring methods using the top-query evaluation strategies from<ref type="bibr" target="#b9">[10]</ref>. The twig and path techniques results in similar query execution times. However, we observed that the binary approaches may result in slightly faster query processing times, as more partial matches end up with the highest scores, allowing to identify a top-set earlier in the execution and discard low-quality matches faster. This makes binaryindependent the method of choice when time is an issue. An in-depth comparison of the performance of top-query processing strategies is beyond the scope of this paper. We refer the reader to<ref type="bibr" target="#b9">[10]</ref> for more details on this subject.In the rest of this section, we study the different parameters that affect quality and speed of our proposed scoring methods.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Precision for Datasets with various degrees of Correlation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Precision for the Treebank Datasets</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>Our scoring methods can be defined for twig queries with any XPath axis edges. Edge generalization and composition (subtree promotion) of edges can be defined for all XPath axes, e.g., a/parent::b can be generalized to a/ancestor::b, a/child::b/following-sibling::c can have the subtree promotion a[./child::b]/child::c. For simplicity of exposition, we do not investigate this issue further in this paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>http://www.cis.upenn.edu/ treebank/home.html http://www.cs.washington.edu/research/xmldatasets/ www/repository.html</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Amer-Yahia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pandit</surname></persName>
		</author>
		<title level="m">FleXPath: Flexible Structure and Full-Text Querying for XML</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">XQuery/IR: Integrating XML Document and Data Retrieval</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gertz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Searching XML Documents via XML Fragments</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carmel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">S</forename><surname>Maarek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mandelbrod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Soffer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Expressive and Efficient Ranked Querying of XML Data</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename><surname>Chinenyanga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kushmerick</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Uniform Approach for Querying Large Tree-structured Data through a Mediated Schema</title>
		<author>
			<persName><forename type="first">C</forename><surname>Delobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Foundations of Models for Information Integration FMII</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">XIRQL: An Extension of XQL for Information Retrieval</title>
		<author>
			<persName><forename type="first">N</forename><surname>Fuhr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Grossjohann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGIR Workshop on XML and Information Retrieval</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">XRANK: Ranked Keyword Search over XML Documents</title>
		<author>
			<persName><forename type="first">L</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Botev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shanmugasundaram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Flexible Queries over Semistructured Data</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kanza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PODS</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">On the Integration of Structure Indices and Inverted Lists</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Adaptive Processing of Top-) Queries in XML</title>
		<author>
			<persName><forename type="first">A</forename><surname>Marian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amer-Yahia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Approximate XML Query Answers</title>
		<author>
			<persName><forename type="first">N</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ioannidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Probability Ranking Principle in IR</title>
		<author>
			<persName><forename type="first">S</forename><surname>Robertson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Documentation</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Introduction to Modern Information Retrieval</title>
		<author>
			<persName><forename type="first">G</forename><surname>Salton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mcgill</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>McGraw-Hill</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">BUS: An Effective Indexing and Retrieval Scheme in Structured Documents</title>
		<author>
			<persName><forename type="first">D</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Conf. on Dig. Lib</title>
		<meeting>3rd Int. Conf. on Dig. Lib</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Schema-Driven Evaluation of Approximate Tree-Pattern Queries</title>
		<author>
			<persName><forename type="first">T</forename><surname>Schlieder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<ptr target="http://news.bbc.co.uk/rss/newsonlineworldedition/technology/rss091.xml" />
		<title level="m">Streaming News in XML</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Index-Based XXL Search Engine for Querying XML Data with Relevance Ranking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EDBT</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Weigel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Meuss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">U</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bry</surname></persName>
		</author>
		<title level="m">Content and Structure in Indexing and Ranking XML</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Searching and Browsing Collections of Structural Information</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Wolff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Flörke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Cremers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Forum on Research and Technology Advances in Dig</title>
		<meeting>IEEE Forum on Research and Technology Advances in Dig</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
