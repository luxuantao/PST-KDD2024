<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Better Security for Deterministic Public-Key Encryption: The Auxiliary-Input Setting</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zvika</forename><surname>Brakerski</surname></persName>
							<email>zvika.brakerski@weizmann.ac.il</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Applied Mathematics Weizmann Institute of Science</orgName>
								<address>
									<postCode>76100</postCode>
									<settlement>Rehovot</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gil</forename><surname>Segev</surname></persName>
							<email>gil.segev@microsoft.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<postCode>94043</postCode>
									<settlement>Mountain View</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Better Security for Deterministic Public-Key Encryption: The Auxiliary-Input Setting</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A5F2BEE2BAB30FDE2B36833825EA1444</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Deterministic public-key encryption, introduced by Bellare, Boldyreva, and O'Neill (CRYPTO '07), provides an alternative to randomized public-key encryption in various scenarios where the latter exhibits inherent drawbacks. A deterministic encryption algorithm, however, cannot satisfy any meaningful notion of security when the plaintext is distributed over a small set. Bellare et al. addressed this difficulty by requiring semantic security to hold only when the plaintext has high min-entropy from the adversary's point of view.</p><p>In many applications, however, an adversary may obtain auxiliary information that is related to the plaintext. Specifically, when deterministic encryption is used as a building block of a larger system, it is rather likely that plaintexts do not have high min-entropy from the adversary's point of view. In such cases, the framework of Bellare et al. might fall short from providing robust security guarantees.</p><p>We formalize a framework for studying the security of deterministic public-key encryption schemes with respect to auxiliary inputs. Given the trivial requirement that the plaintext should not be efficiently recoverable from the auxiliary input, we focus on hard-to-invert auxiliary inputs. Within this framework, we propose two schemes: the first is based on the decisional Diffie-Hellman (and, more generally, on the d-linear) assumption, and the second is based on a rather general class of subgroup indistinguishability assumptions (including, in particular, quadratic residuosity and Paillier's composite residuosity). Our schemes are secure with respect to any auxiliary input that is subexponentially hard to invert (assuming the standard hardness of the underlying computational assumptions). In addition, our first scheme is secure even in the multi-user setting where related plaintexts may be encrypted under multiple public keys. Constructing a scheme that is secure in the multi-user setting (even without considering auxiliary inputs) was identified by Bellare et al. as an important open problem.</p><p>1 Note that this is effectively a collection of injective trapdoor functions (assuming the decryption algorithm is deterministic as well).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Public-key encryption is one of the most basic cryptographic tasks. A public-key encryption scheme consists of three algorithms: a key-generation algorithm that produces a secret key and a corresponding public key, an encryption algorithm that uses the public key for mapping plaintexts into ciphertexts, and a decryption algorithm that uses the secret key for recovering plaintexts from ciphertexts. For modeling the security of public-key encryption schemes, the fundamental notion of semantic security was introduced in the seminal work of Goldwasser and Micali <ref type="bibr" target="#b21">[20]</ref>. Semantic security asks that it should be infeasible to gain any effective information on the plaintext by seeing the ciphertext and the public key. More specifically, whatever can be computed efficiently from the ciphertext, the public key and possibly some auxiliary information, can essentially be computed efficiently from the public key and the auxiliary information alone.</p><p>Together with its rigorous, robust, and meaningful modeling of security, semantic security inherently carries the requirement for a randomized encryption algorithm. In some cases, however, a randomized encryption algorithm may suffer from various drawbacks. In terms of efficiency, ciphertexts are not length preserving (and might be significantly longer than their corresponding plaintexts), and are in general not efficiently searchable. These properties severely limit the deployment of public-key encryption schemes in applications involving, for example, massive data sets where the ciphertext expansion is crucial, or global deduplication-based storage systems where searches are highly frequent (e.g., <ref type="bibr" target="#b28">[26]</ref>). In addition, in terms of security, the security guarantees provided by randomized public-key encryption, and by randomized cryptographic primitives in general, are typically highly dependant on the availability of true and fresh random bits (see, for example, <ref type="bibr" target="#b3">[3]</ref> and the references therein).</p><p>Deterministic public-key encryption. For dealing with these kind of drawbacks, Bellare, Boldyreva, and O'Neill <ref type="bibr" target="#b1">[2]</ref> initiated the study of deterministic public-key encryption schemes. These are public-key encryption schemes in which the encryption algorithm is deterministic 1 . In this setting, where fullfledged sematic security is out of reach, Bellare et al. put forward the goal of formalizing a notion of security that captures semantic security as much as possible. An immediate consequence of having a deterministic encryption algorithm, however, is that essentially no meaningful notion of security can be satisfied if the plaintext is distributed over a set of polynomial size. Indeed, in such a case an adversary who is given a public key pk and an encryption c of some plaintext m under the public key pk, can simply encrypt all possible plaintexts, compare each of them to the given ciphertext c, and thus recover the plaintext m.</p><p>Bellare et al. addressed this problem by requiring security to hold only when the plaintext is sampled from a distribution of high min-entropy. Subject to this restriction, they adapted semantic security to the setting of deterministic encryption: For any high-entropy plaintext distribution, whatever can be computed efficiently from the ciphertext and the public key, can also be computed efficiently from the public key alone. Constructions of deterministic public-key encryption schemes satisfying this and similar notions of security were proposed in the random oracle model by Bellare et al. <ref type="bibr" target="#b1">[2]</ref>, and then in the standard model by Bellare, Fischlin, O'Neill, and Ristenpart <ref type="bibr" target="#b4">[4]</ref>, by Boldyreva, Fehr, and O'Neill <ref type="bibr" target="#b5">[5]</ref>, and by O'Neill <ref type="bibr" target="#b24">[23]</ref>. We refer the reader to Section 1.2 for an elaborated discussion of these constructions.</p><p>Security with respect to auxiliary information. In typical applications, a deterministic public-key encryption scheme is used as building block of a larger system. In such a setting, an adversary usually has additional information that it can use when trying to break the security of the scheme. This danger becomes even more critical when such additional information is related to the encrypted plaintext. In general, security with respect to auxiliary information is essential towards obtaining composable security (see, for example, <ref type="bibr" target="#b11">[11]</ref> and the references therein). More closely related to our approach are the studies of security with respect to auxiliary information in the contexts of perfect one-way functions <ref type="bibr" target="#b10">[10]</ref>, program obfuscation <ref type="bibr" target="#b20">[19]</ref>, and leakage-resilient encryption <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b8">8]</ref>.</p><p>For example, when using a deterministic public-key encryption scheme for enabling efficient searches on encrypted databases, as suggested by Bellare et al. <ref type="bibr" target="#b1">[2]</ref>, it is not unlikely that the same plaintext belongs to more than one database, and is therefore encrypted under several public keys; or that various statistics of the database are publicly available. A more acute example is when using a deterministic public-key encryption scheme for a key-encapsulation mechanism that "hedges against bad randomness" <ref type="bibr" target="#b3">[3]</ref>. In such a case an adversary that observes the usage of the encapsulated key (say, as a key to a symmetric-key encryption scheme) may in fact obtain a huge amount of additional information on the encapsulated key.</p><p>In this light, the notion of security proposed by Bellare et al. <ref type="bibr" target="#b1">[2]</ref> might fall short of capturing the likely case where auxiliary information is available. That is, although a plaintext may be sampled from a distribution with high minentropy to begin with, it might still have no entropy, from the point of view of an adversary, in many realistic scenarios. We note that already in the setting of deterministic symmetric-key encryption of high-entropy messages, Dodis and Smith <ref type="bibr" target="#b14">[14]</ref> observed that the main weakness of an approach that does not take into account auxiliary information, is the lack of composable security. It is thus a highly desirable task to model and to construct secure deterministic encryption schemes in the setting of auxiliary information, as a crucial and essential step towards obtaining more realistic security guarantees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contributions</head><p>In this paper we introduce a framework for modeling the security of deterministic public-key encryption schemes with respect to auxiliary inputs. Within this framework we propose constructions that are based on standard cryptographic assumptions in the standard model (i.e., without random oracles). Our framework is a generalization of the one formalized by Bellare et al. <ref type="bibr" target="#b1">[2]</ref> (and further studied in <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b24">23]</ref>) to the auxiliary-input setting, in which an adversary possibly obtains additional information that is related to the encrypted plaintext, and might even fully determine the encrypted plaintext information theoretically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Modeling auxiliary information.</head><p>An immediate consequence of having a deterministic encryption algorithm is that no meaningful notion of security can be satisfied if the plaintext can be recovered from the adversary's auxiliary information (see Section 3 for a discussion of this inherent constraint<ref type="foot" target="#foot_1">2</ref> ). Thus, we focus our attention on the case of hard-to-invert auxiliary inputs, where the source of hardness may be any combination of information-theoretic hardness (where the auxiliary-input function is many-to-one) and computational hardness (where the auxiliary input function is injective, but is hard to invert by efficient algorithms).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notions of security.</head><p>Following <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b5">5]</ref> we formalize three notions of security with respect to auxiliary inputs, and prove that all three are equivalent. The first is a simulation-based notion, capturing the intuitive meaning of semantic security: whatever can be computed efficiently given a public key, an encryption of a message, and hard-to-invert auxiliary input, can be computed efficiently given only the public key and the auxiliary input. The second is a comparisonbased notion, which essentially serves as an intermediate notion towards an indistinguishability-based one that is somewhat easier to handle in proofs of security. The high-level approach of the equivalence proofs is motivated by those of <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5]</ref>, but the existence of auxiliary inputs that may fully determine the encrypted messages introduces various difficulties that our techniques overcome.</p><p>Constructions. We propose two constructions in the standard model satisfying our notions of security. At a first glance, one might hope that the constructions proposed in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b24">23]</ref> can be naturally extended to the auxiliary-input setting by replacing the notion of statistical min-entropy with an appropriate notion of computational min-entropy. This, however, does not seem to be the case (at least without relying on random oracles), as these constructions seem to heavily rely on information-theoretic properties that might not have natural computational analogues <ref type="foot" target="#foot_2">3</ref> .</p><p>Our first construction is based on the decisional Diffie-Hellman assumption, (and more generally, on any of the d-linear assumptions), and our second construction is based on a rather general class of subgroup indistinguishability assumptions as defined in <ref type="bibr" target="#b8">[8]</ref> (including, in particular, the quadratic residuosity assumption, and Paillier's composite residuosity assumption <ref type="bibr" target="#b25">[24]</ref>). The resulting schemes are secure with respect to any auxiliary input that is subexponentially hard to invert <ref type="foot" target="#foot_3">4</ref> . In addition, our first scheme is secure even in the multi-user setting where related messages may be encrypted under multiple public keys. In this setting we obtain security (with respect to auxiliary inputs) for any polynomial number of messages and users as long as the messages are related by invertible linear transformations. Constructing a scheme that is secure is the multi-user setting (even without considering auxiliary inputs) was identified as an important open problem by Bellare et al. <ref type="bibr" target="#b1">[2]</ref>. Finally, we note that this scheme also exhibits an interesting homomorphic property: it allows homomorphic additions and one multiplication, in the spirit of <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b16">16]</ref>. This property may be found especially useful in light of the possible applications of deterministic public-key encryption schemes in database systems <ref type="bibr" target="#b1">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>Exploiting the entropy of messages to prove otherwise-impossible security was first proposed by Russell and Wang <ref type="bibr" target="#b27">[25]</ref>, followed by Dodis and Smith <ref type="bibr" target="#b14">[14]</ref>. These works achieved information-theoretic security for symmetric-key encryption with short keys.</p><p>In the setting of public-key encryption, deterministic encryption for high minentropy messages was proposed by Bellare, Boldyreva, and O'Neill <ref type="bibr" target="#b1">[2]</ref> who formalized a definitional framework, which was later refined and extended by Bellare, Fischlin, O'Neill, and Ristenpart <ref type="bibr" target="#b4">[4]</ref>, by Boldyreva, Fehr, and O'Neill <ref type="bibr" target="#b5">[5]</ref>, and by O'Neill <ref type="bibr" target="#b24">[23]</ref>. Bellare et at. <ref type="bibr" target="#b1">[2]</ref> presented two constructions in the random oracle model: The first relies on any semantically-secure public-key encryption scheme; whereas the second relies on the RSA function (and is in fact length preserving). Constructions in the standard model (i.e., without random oracles), were then presented in <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5]</ref>. Bellare et al. <ref type="bibr" target="#b4">[4]</ref> presented a construction based on trapdoor permutations, which is secure as long as the messages are (almost) uniformly distributed. Boldyreva et al. <ref type="bibr" target="#b5">[5]</ref> presented a construction based on lossy trapdoor functions, which is secure as long as its n-bit messages have minentropy at least n for some constant 0 &lt; &lt; 1. These constructions, however, fall short in two interesting cases: In the multi-message setting, where arbitrarily related messages are encrypted under the same public key; and in the multiuser setting where the same message is encrypted under several (independently chosen) public keys. Recently, O'Neill <ref type="bibr" target="#b24">[23]</ref> made a step towards addressing the former, by presenting a scheme that can securely encrypt any fixed number q of messages, but whose parameters depend polynomially on q. The latter case remained unexplored until this work.</p><p>Deterministic public-key encryption was used by Bellare et al. <ref type="bibr" target="#b3">[3]</ref> who defined and constructed "hedged" public-key encryption schemes. These are schemes that are semantically secure in the standard sense, and maintain a meaningful and realistic notion of security even when "corrupt" randomness is used for the encryption, so long as the joint message-randomness pair has sufficient min-entropy. The definition of security in the latter case takes after that of deterministic public-key encryption.</p><p>The tools underlying our constructions in this paper are inspired by the line of research on "encryption in the presence of auxiliary input", initiated by Dodis, Kalai, and Lovett <ref type="bibr" target="#b13">[13]</ref> in the context of symmetric-key encryption, and then extended in <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b8">8]</ref> to public-key encryption. These works consider encryption schemes where the adversary may obtain a hard-to-invert function of the secret key -extending the frameworks of "bounded leakage" <ref type="bibr" target="#b0">[1]</ref> and "noisy leakage" <ref type="bibr" target="#b23">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Overview of Our Approach</head><p>In this section we provide a high-level overview of our approach and techniques. We begin with a brief description of the notions of security that we consider in the auxiliary-input setting, and then describe the main ideas underlying our two constructions. For simplicity, in what follows we consider the case where one message is encrypted under one public key, and refer the reader to the relevant sections for the more general case.</p><p>Defining security with respect to auxiliary inputs. Towards describing our notions of security, we first discuss our notion of hard-to-invert auxiliary inputs. We consider any auxiliary input f (x) from which it is hard to recover the input x. The source of hardness may be any combination of informationtheoretic hardness (where the function f is many-to-one), and computational hardness (where f (x) fully determines x, but x is hard to recover by efficient algorithms). Informally, we say that a function f is -hard-to-invert with respect to a distribution D, if for every efficient algorithm A it holds that A(f (x)) = x with probability at most , over the choice of x ← D and the internal coin tosses of A.</p><p>As discussed in Section 1.1, we formalize three notions of security with respect to auxiliary inputs, and prove that all three are equivalent. For concreteness we focus here on the simulation-based definition, which captures the intuitive meaning of semantic security: Whatever can be computed efficiently given a public key, an encryption of a message, and hard-to-invert auxiliary input, can be computed efficiently given only the public key and the auxiliary input. A bit more formally, we say that a scheme is secure with respect to -hard-to-invert auxiliary inputs if for any probabilistic polynomial-time adversary A, and for any efficiently samplable plaintext distribution M, there exists a probabilistic polynomial-time simulator S, such that for any efficiently computable function f that is -hard-toinvert with respect to M, and for any function g ∈ {0, 1} * → {0, 1} * , the probabilities of the events A (pk, Enc pk (m), f(m)) = g(m) and S (pk, f (m)) = g(m) are negligibly close, where m ← M. We note that the functions f and g may be arbitrary related <ref type="foot" target="#foot_4">5</ref> . This is a generalization of the definitions considered in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b24">23]</ref>.</p><p>The scheme of Boldyreva et al. <ref type="bibr" target="#b5">[5]</ref>. Our starting point is the scheme of Boldyreva et al. <ref type="bibr" target="#b5">[5]</ref> that is based on lossy trapdoor functions. This is in fact the only known construction in the standard model (i.e., without random oracles) that is secure for arbitrary plaintext distributions with high (but not nearly full) min-entropy. In their construction, the public key consists of a function h that is sampled from the injective mode of the collection of lossy trapdoor functions, and a pair-wise independent permutation π. The secret key consists of the trapdoor for inverting h (we assume that π is efficiently invertible). The encryption of a message m is defined as Enc pk (m) = h(π(m)), and decryption is naturally defined.</p><p>In a high level, the proof of security in <ref type="bibr" target="#b5">[5]</ref> considers the joint distribution of the public key and the ciphertext (pk, Enc pk (m)), and argues that it is computationally indistinguishable from a distribution that is independent of the plaintext m. This is done by considering a distribution of malformed public keys, that is computationally indistinguishable from the real distribution. Specifically, the injective function h is replaced with a lossy function h to obtain an indistinguishable public key pk. The next step is to show that the ciphertext c = Enc pk (m) can be described by the following two-step process. First, an analogue of a strong extractor is applied to m (where the seed is the permutation π that lies in pk) to obtain v = ext pk (m). Then, the output of the extractor is used to compute the ciphertext c = g( pk, v). From this point of view, it is evident that so long as the plaintext m is drawn from a distribution with high min-entropy, it holds that v = ext pk (m) is statistically close to a uniform distribution (over some domain). This holds even given the malformed public key, and does not depend on the distribution of m. This methodology of using an analog of a strong extractor relies on the crooked leftover hash lemma of Dodis and Smith <ref type="bibr" target="#b14">[14]</ref>, that enables to base the construction on any collection of lossy trapdoor functions.</p><p>Our constructions. In our setting, we wish to adapt this methodology to rely on computational hardness instead of min-entropy. However, there is currently no known analog of the crooked leftover hash lemma in the computational setting. This is an interesting open problem. We overcome this difficulty by relying of specific collections of lossy trapdoor functions, for which we are in fact able to extract pseudorandomness from computational hardness. We do this by replacing the strong extractor component with a hard-core function of the message (with respect to the auxiliary input). Specifically, our encryption algorithm (when using the malformed public key) can be interpreted as taking an inner product between our message m (viewed as a vector of bits) and a random vector a, where the resulting ciphertext depends only on (a, m, a ). This is similar to the Goldreich-Levin hard-core predicate <ref type="bibr" target="#b19">[18]</ref>, except that the vector a is not binary and the inner product is performed over some large Z-module and not over the binary field. We thus require the generalized Goldreich-Levin theorem of Dodis et al. <ref type="bibr" target="#b12">[12]</ref> to obtain that even given the auxiliary input, the distributions (a, m, a ) and (a, u) are computationally indistinguishable, where u is uniformly distributed and does not depend on the distribution of m.</p><p>To be more concrete, let us consider our DDH-based scheme (formally presented in Section 4) which is based on the lossy trapdoor functions of Freeman et al. <ref type="bibr" target="#b15">[15]</ref>. The scheme is instantiated by a DDH-hard group G of prime order q that is generated by g. The message space is {0, 1} n (where n is polynomial in the security parameter) and the public key is g A , for a random n × n matrix A over Z q . Encryption is done by computing Enc g A (m) = g A•m and decryption is performed using sk = A -1 . 6 6 We overload the notation g x to matrices as follows: for X ∈ Z k×n q , we let g X ∈ G k×n denote the matrix defined as (g X )i,j = g (X) i,j .</p><p>For analyzing the security of the scheme, we consider the joint distribution of the public key, ciphertext and auxiliary input (pk, Enc pk (m), f(m)) = (g A , g A•m , f(m)). The malformed distribution pk is obtained by taking A to be a random rank-1 matrix (rather than completely random). DDH implies that pk and pk are computationally indistinguishabile. Such a low-rank matrix takes the form A = r • b T , and therefore A • m = r • b T • m, for random vectors r and b. Thus, our ciphertext depends only on (b, b, m ) which is indistinguishable from (b, u), for a uniformly random u, even given f (m), by the generalized Goldreich-Levin theorem <ref type="bibr" target="#b12">[12]</ref>. Our initial distribution is therefore indistinguishable from the distribution (g r•b T , g r•u , f(m)) as required.</p><p>In the multi-user setting, we observe that any polynomial number of public keys g A1 , . . . , g A are computationally indistinguishable, by DDH, from having joint rank-1. Namely, in this case the distributions (g A1 , . . . , g A ) and (g r 1 •b T , . . . , g r •b T ) are computationally indistinguishable, where the same vector b is used for all keys. Encrypting a message m under all such public keys results in a set of ciphertexts (g r1•b T •m , . . . , g r •b T •m ), where all elements depend on (b, b, m ). This enables to apply the above approach, and we show that it in fact extends to linearly-related messages.</p><p>Our second scheme (based on subgroup indistinguishability assumptions) is analyzed quite similarly. We rely on the lossy trapdoor functions of <ref type="bibr" target="#b22">[21]</ref> and can again show that our public key distribution is indistinguishable from one over rank-1 matrices. However, the groups under consideration might be non-cyclic. This adds additional complications into the analysis. In addition, this scheme does not seem to allow a "joint rank" argument as above, and we leave it as an open problem to construct an analogous scheme that is secure in the multi-user setting.</p><p>Paper organization. The remainder of this paper is organized as follows. In Section 2 we formalize a general notion for hard-to-invert auxiliary inputs. In Section 3 we introduce a framework for modeling the security of deterministic public-key encryption schemes with respect to auxiliary inputs, consisting of three main notions of security. In Section 4 we present a construction based on the decisional Diffie-Hellman assumption (and, more generally, on any of the d-linear assumptions), and in Section 5 we present a construction based on subgroup indistinguishability assumptions.</p><p>Due to space limitations, not all results and proofs appear in this extended abstract. We refer the reader to the full version of this paper <ref type="bibr" target="#b9">[9]</ref> for more details.</p><p>Notation. Throughout the paper we denote scalars in plain lowercase letters (x ∈ {0, 1}). We use the term "vector" both in the algebraic sense, where it indicates an element in a vector space and denoted by bold lowercase letters (x ∈ {0, 1} k ); and in the "combinatorial" sense, indicating an ordered set of elements (not necessarily having any algebraic properties) for which we use the notation x. We denote a combinatorial vector whose elements are algebraic vectors by x, combinatorial vector of combinatorial vectors by x, and combinatorial vector of combinatorial vectors of algebraic vectors by x. Matrices (always algebraic) are denoted in bold uppercase (X ∈ {0, 1} k×n ). The k × k identity matrix is denoted I k . All vectors are column vectors by default, and a row vector is denoted by x T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Hard-to-Invert Auxiliary Inputs</head><p>In this work we consider any auxiliary input f (x) from which it is hard to recover the input x. The source of hardness may be any combination of informationtheoretic hardness (where the function f is many-to-one) and computational hardness (where f (x) fully determines x, but x is hard to recover by efficient algorithms). Informally, we say that a function f is -hard-to-invert with respect to a distribution D, if for every efficient algorithm A it holds that A(f (x)) = x with probability at most over the choice of x ← D and the internal coin tosses of A.</p><p>For our purposes, we formalize a slightly more general notion in which D is a distribution over vectors of inputs x = (x 1 , . . . , x t ), and for every i ∈ {1, . . . , t} it should be hard to efficiently recover x i when given f ( x). In addition, we also consider a blockwise variant of this notion, in which it should be hard to efficiently recover x i when given (x 1 , . . . , x i-1 , f( x)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1. An efficiently computable function</head><formula xml:id="formula_0">F = {f k } k∈N is (k)-hard- to-</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>invert with respect to an efficiently samplable distribution D = {D k } k∈N over vectors of t(k) inputs, if for every probabilistic polynomial-time algorithm A and for every i ∈ {1, . . . , t(k)} it holds that</head><formula xml:id="formula_1">Pr A 1 k , f k ( x) = x i ≤ (k) ,</formula><p>for all sufficiently large k, where the probability is taken over the choice of x = (x 1 , . . . , x t(k) ) ← D k , and over the internal coin tosses of A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.2. An efficiently computable function F = {f k } k∈N is (k)-blockwise-hard-to-invert with respect to an efficiently samplable distribution D = {D k } k∈N over vectors of t(k) inputs, if for every probabilistic polynomial-time algorithm A and for every i ∈ {1, . . . , t(k)} it holds that</head><formula xml:id="formula_2">Pr A 1 k , x 1 , . . . , x i-1 , f k ( x) = x i ≤ (k) ,</formula><p>for all sufficiently large k, where the probability is taken over the choice of x = (x 1 , . . . , x t(k) ) ← D k , and over the internal coin tosses of A.</p><p>Note that Definition 2.1 implies in particular that the distribution D is such that each x i has min-entropy at least log(1/ (k)). Furthermore, Definition 2.2 implies that the distribution D is a block source in which each block x i has (average) min-entropy at least log(1/ (k)) conditioned on the previous blocks (x 1 , . . . , x i-1 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Modeling Security in the Auxiliary-Input Setting</head><p>In this section we present a framework for modeling the security of deterministic public-key encryption schemes with respect to auxiliary inputs. Our framework is obtained as a generalization of those considered in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b5">5]</ref> to a setting in which the encrypted plaintexts may be fully determined by some auxiliary information that is available to the adversary. Following <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b5">5]</ref> we formalize three notions of security with respect to auxiliary inputs, and prove that all three are equivalent. The first is a simulation-based semantic security notion (PRIV-SSS), capturing the intuitive meaning of semantic security: whatever can be computed given an encryption of a message and auxiliary input, can also be computed given only the auxiliary input. The second is a comparison-based semantic-security notion (PRIV-CSS), which essentially serves as an intermediate notion towards an indistinguishability-based one (PRIV-IND) that is somewhat easier to handle in proofs of security.</p><p>In the remainder of this paper we use the following notation. For a deterministic public-key encryption scheme Π = (KeyGen, Enc, Dec), a public key pk, and a vector of messages m = (m 1 , . . . , m t ) we denote by Enc pk ( m) the vector (Enc pk (m 1 ), . . . , Enc pk (m t )). When considering a distribution M over vectors of messages m = (m 1 , . . . , m t ) all of which are encrypted under the same public key, then for the case of hard-to-invert auxiliary inputs we make in this paper the simplifying assumption that m i = m j for every i = j (a bit more formally, one should require that all distributions have identical equality patterns -see <ref type="bibr" target="#b1">[2]</ref>). In the case of blockwise-hard-to-invert auxiliary inputs this assumption is not necessary. In addition, for simplicity we present our definitions for the case of hard-to-invert auxiliary inputs, and note that they naturally extend to the case of blockwise-hard-to-invert auxiliary inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.1 (Simulation-based security).</head><p>A deterministic public-key encryption scheme Π = (KeyGen, Enc, Dec) is PRIV-SSS-secure with respect tohard-to-invert auxiliary inputs if for any probabilistic polynomial-time algorithm A and for any efficiently samplable distribution M = {M k } k∈N , there exists a probabilistic polynomial-time algorithm S, such that for any efficiently computable function F = {f k } k∈N that is -hard-to-invert with respect to M, and for any function g ∈ {0, 1} * → {0, 1} * , there exists a negligible function ν(k) such that</p><formula xml:id="formula_3">Adv PRIV-SSS Π,A,M,S,F ,g (k) def = Real PRIV-SSS Π,A,M,F ,g (k) -Ideal PRIV-SSS Π,S,M,F ,g (k) ≤ ν(k)</formula><p>for all sufficiently large k, where</p><formula xml:id="formula_4">Real PRIV-SSS Π,A,M,F ,g (k) = Pr A 1 k , pk, Enc pk ( m), f k ( m) = g( m) Ideal PRIV-SSS Π,S,M,F ,g (k) = Pr S 1 k , pk, f k ( m) = g( m) ,</formula><p>and the probability is taken over the choices of m ← M k , (sk, pk) ← KeyGen(1 k ), and over the internal coin tosses of A and S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.2 (Comparison-based security).</head><p>A deterministic public-key encryption scheme Π = (KeyGen, Enc, Dec) is PRIV-CSS-secure with respect to -hard-to-invert auxiliary inputs if for any probabilistic polynomial-time algorithm A, for any efficiently samplable distribution M = {M k } k∈N , for any efficiently computable function F = {f k } k∈N that is -hard-to-invert with respect to M, and for any function g ∈ {0, 1} * → {0, 1} * , there exists a negligible function ν(k) such that</p><formula xml:id="formula_5">Adv PRIV-CSS Π,A,M,F ,g (k) def = Adv PRIV-CSS Π,A,M,F ,g (k, 0) -Adv PRIV-CSS Π,A,M,F ,g (k, 1) ≤ ν(k)</formula><p>for all sufficiently large k, where</p><formula xml:id="formula_6">Adv PRIV-CSS Π,A,M,F ,g (k, b) = Pr A 1 k , pk, Enc pk ( m b ), f k ( m 0 ) = g( m 0 ) ,</formula><p>and the probability is taken over the choices of m 0 ← M k , m 1 ← M k , (sk, pk) ← KeyGen(1 k ), and over the internal coin tosses of A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.3 (Indistinguishability-based security).</head><p>A deterministic public-key encryption scheme Π = (KeyGen, Enc, Dec) is PRIV-IND-secure with respect to -hard-to-invert auxiliary inputs if for any probabilistic polynomial-time algorithm A, for any two efficiently samplable distributions M 0 = {M 0,k } k∈N and M 1 = {M 1,k } k∈N , and for any efficiently computable function F = {f k } k∈N that is -hard-to-invert with respect to both M 0 and M 1 , there exists a negligible function ν(k) such that</p><formula xml:id="formula_7">Adv PRIV-IND Π,A,M0,M1,F (k) def = Adv PRIV-IND Π,A,M0,M1,F (k, 0) -Adv PRIV-IND Π,A,M0,M1,F (k, 1) ≤ ν(k)</formula><p>for all sufficiently large k, where</p><formula xml:id="formula_8">Adv PRIV-IND Π,A,M0,M1,F (k, b) = Pr A 1 k , pk, Enc pk ( m b ), f k ( m 0 ) = 1 ,</formula><p>and the probability is taken over the choices of m 0 ← M 0,k , m 1 ← M 1,k , (sk, pk) ← KeyGen(1 k ), and over the internal coin tosses of A.</p><p>The hard-to-invert requirement. We emphasize that in the setting of deterministic public-key encryption the requirement that the encrypted messages cannot be efficiently recovered from the auxiliary input is essential (unlike in the setting of randomized encryption, where the notion of semantic security takes into account any auxiliary input -see, for example, <ref type="bibr" target="#b18">[17,</ref><ref type="bibr">Ch. 5]</ref>). This is easily observed using our indistinguishability-based formulation (Definition 3. Relation to previous notions. We note that any constant function ishard-to-invert with respect to any message distribution of min-entropy at least log(1/ ). Thus, our notion of auxiliary-input security strictly generalizes previous security notions, in which auxiliary input is not considered, and the message distributions need to have sufficient min-entropy <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b24">23]</ref>.</p><p>Access to the public key. As observed by Bellare et al. <ref type="bibr" target="#b1">[2]</ref> it is essential that the "target" function g does not take the public key as input. Specifically, with a deterministic encryption algorithm the ciphertext itself is a non-trivial information that it leaked about the plaintext, and can clearly be computed efficiently using the public key. We refer the reader to <ref type="bibr" target="#b1">[2]</ref> for a more elaborated discussion.</p><p>The randomness of sampling. For our notions of security we in fact allow the auxiliary-input function f and the "target" function g to take as input not only the of message m, but also the random string r ∈ {0, 1} * that was used for sampling m from the distribution D k . When this aspect plays a significant role we explicitly include r as part of the input for f and g, and denote by m ← D k (r) the fact that m is sampled using the random string r. When this aspect does not play a significant role we omit it for ease of readability (in particular, we omitted it from the above definitions).</p><p>PRIV1: focusing on a single message. As in <ref type="bibr" target="#b5">[5]</ref> we also consider the PRIV1variants of our notion of security that focus on a single message (instead of vectors of any polynomial number of messages). In the full version <ref type="bibr" target="#b9">[9]</ref> we also provide proof that security for a vector of messages with respect to a blockwisehard-to-invert auxiliary input is in fact equivalent to security for a single message with respect to a hard-to-invert auxiliary input.</p><p>The multi-user setting. So far our notions of security considered vectors of messages that are encrypted under the same public key. Our definitions in this section naturally generalize to the multi-user setting, where there are multiple public keys, each of which is used for encrypting a vector of messages. Due to space limitations, we refer the reader to the full version <ref type="bibr" target="#b9">[9]</ref> for this generalization.</p><p>An even stronger notion of security. Note that in Definition 3.3 the algorithm A is given as input the vector 1 k , pk, Enc pk ( m b ), f k ( m 0 ) , and that a seemingly stronger definition would even consider the vector</p><formula xml:id="formula_9">1 k , pk, Enc pk ( m b ), Enc pk ( m 1-b ), f k ( m 0 ), f k ( m 1 )</formula><p>as its input. As indicated by the equivalence of our three definitions, such a stronger variant is not needed for capturing the intuitive meaning of semantic security as in Definition 3.1. Nevertheless, our schemes in this paper in fact satisfy this stronger variant. We refer to this notion as strong indistinguishability (PRIV-sIND), formally defined as follows:</p><p>Definition 3.4. A deterministic public-key encryption scheme Π = (KeyGen, Enc, Dec) is PRIV-sIND-secure with respect to -hard-to-invert auxiliary inputs if for any probabilistic polynomial-time algorithm A, for any two efficiently samplable distributions M 0 = {M 0,k } k∈N and M 1 = {M 1,k } k∈N , and for any efficiently computable function F = {f k } k∈N that is -hard-to-invert with respect to both M 0 and M 1 , there exists a negligible function ν(k) such that</p><formula xml:id="formula_10">Adv PRIV-sIND Π,A,M0,M1,F (k) def = Adv PRIV-sIND Π,A,M0,M1,F (k, 0) -Adv PRIV-sIND Π,A,M0,M1,F (k, 1) ≤ ν(k)</formula><p>for all sufficiently large k, where</p><formula xml:id="formula_11">Adv PRIV-sIND Π,A,M0,M1,F (k, b) = Pr A 1 k , pk, Enc pk ( m b ), Enc pk ( m 1-b ), f k ( m 0 ), f k ( m 1 ) = 1 ,</formula><p>and the probability is taken over the choices of m 0 ← M 0,k , m 1 ← M 1,k , (sk, pk) ← KeyGen(1 k ), and over the internal coin tosses of A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Scheme Based on the d-Linear Assumption</head><p>In this section we present our d-linear-based based deterministic encryption scheme and discuss its properties. We show that the d-linear-based lossy trapdoor function of Freeman et al. <ref type="bibr" target="#b15">[15]</ref> is in fact a deterministic public-key encryption that is secure with respect to hard-to-invert auxiliary inputs.</p><p>The scheme Π Lin . Let GroupGen be a probabilistic polynomial-time algorithm that takes as input a security parameter 1 k , and outputs a triplet (G, q, g) where G is a group of prime order q that is generated by g ∈ G, and q is a k-bit prime number. For describing the scheme we overload the notation g x to matrices: for X ∈ M k×n , we let g X ∈ G k×n denote the matrix defined as (g X ) i,j = g (X)i,j . The scheme is parameterized by the security parameter k and the message length n = n(k).</p><p>-Key generation. The key-generation algorithm KeyGen(1 k ) samples (G, q, g)←GroupGen(1 k ), and a matrix A ← Z n×n q . It then outputs pk = (G, q, g, g A ) and sk = A -1 (note that A is invertible with all but a negligible probability).</p><p>-Encryption. The encryption algorithm Enc pk (m), where m ∈ {0, 1} n ⊆ Z n q , outputs the ciphertext g c = g A•m . -Decryption. The decryption algorithm Dec sk (g c ), where g c ∈ G n , first computes g m = g A -1 •c . Then, note that if m ∈ {0, 1} n then it can be efficiently extracted from g m . In such case it outputs m, and otherwise it outputs ⊥.</p><p>Correctness follows immediately as in <ref type="bibr" target="#b15">[15]</ref>. We prove the following theorem:</p><p>Theorem 4.1. Let d ∈ N be some integer. Then under the d-linear assumption, for any constant 0 &lt; μ &lt; 1 and for any sufficiently large message length n = n(k), the scheme Π Lin is PRIV-IND-secure with respect to 2 -n μ -blockwise-hardto-invert auxiliary inputs.</p><p>Due to space limitations, we only describe the main ideas underlying the security of the scheme. The full proof can be found in the full version <ref type="bibr" target="#b9">[9]</ref>. For simplicity, we focus here on the case d = 1 (i.e., we rely on the DDH assumption). Given a distribution M over messages m ∈ {0, 1} n , and an auxiliaryinput function f that is sub-exponentially hard to invert with respect to M, we argue that an encryption of a messages m sampled from the distribution M is computationally indistinguishable from being completely independent of the public key pk and the auxiliary input f (m). More specifically, we prove that (pk, Enc pk (m), f(m)) c ≈ (pk, g u , f(m)), for a uniformly chosen vector u. Transforming this into either one of our notions of security from Section 3 is rather standard.</p><p>Consider the joint distribution (pk, Enc pk (m), f(m)) = (g A , g A•m , f(m)) of the public key, the ciphertext, and the auxiliary input. The DDH assumption implies that replacing the uniformly chosen matrix A with a random matrix of rank 1 results in a computationally indistinguishable distribution. Such a lowrank matrix can be written as A = r • b T , for random vectors r and b, and therefore</p><formula xml:id="formula_12">A • m = r • b T • m. However b T • m = b,</formula><p>m is indistinguishable from the uniform distribution, even given b and f (m), according to the generalized Goldreich-Levin theorem of <ref type="bibr" target="#b12">[12]</ref>. Our initial distribution is thus indistinguishable from the distribution (g r•b T , g r•α , f(m)). Now, notice that the matrix [r</p><formula xml:id="formula_13">• b T r • α] ∈ Z n×(n+1) q</formula><p>is essentially a random matrix of rank 1. Relying on the DDH assumption once again, it can be replaced with a completely random matrix while preserving computational indistinguishability. This yields the distribution (g A , g u , f(m)), where A and u are chosen uniformly at random. Homomorphic properties. The scheme naturally exhibits homomorphic properties w.r.t. multiplication by a scalar or addition of two ciphertexts over Z n q . This follows from "arithmetics in the exponent". We stress, however, that the output of such homomorphic operations will be decryptable if it lies in the message space of our scheme, {0, 1} n , which is a proper subset of the domain Z n q on which these operations are performed. More generally, decryption is possible as long as each entry of the encrypted plaintext vector belongs to a predetermined set of logarithmic size.</p><p>In addition, if the underlying group G is associated with a bilinear map, then our scheme enjoys an additional homomorphism w.r.t. one matrix multiplication. This is similar to the homomorphism style achieved in <ref type="bibr" target="#b6">[6]</ref> and in <ref type="bibr" target="#b16">[16]</ref>. We stress that in such case we base the security of the scheme on the d-linear assumption for d ≥ 2 (as the 1-linear, i.e. DDH, cannot hold in such a group). Formally, let G, q, and g be as in the parameters of our scheme, and let G T be a (different) group of order q. A bilinear map e : G × G → G T has the following properties. Bilinearity: for all x, y ∈ G, a, b ∈ Z it holds that e(x a , y b ) = e(x, y) ab ; Nondegeneracy: e(g, g) = 1. It follows that g T def = e(g, g) generates G T . Homomorphic matrix multiplication, thus, is performed in our scheme as follows: Given two ciphertexts g Am1 and g Am2 , one can compute e(g, g) Am1m T 2 A T .</p><p>This ciphertext can be decrypted by multiplying by A -1 from the left (in the exponent) and A -T from the right (again, in the exponent) to obtain e(g, g) m1•m T 2 . Since m 1 and m 2 are binary, m 1 • m T 2 is binary as well and can be extracted from the exponent.</p><p>The multi-user setting. We now show that Π Lin is secure (with respect to auxiliary inputs) even in the multi-user setting, where related messages may be encrypted under multiple public keys. We allow any polynomial number of users, and for simplicity we assume that each public key encrypts one message. As in the single-user setting, this natural extends to the case where several messages are encrypted under each public key with blockwise-hard-to-invert auxiliary input. In addition, we require that the messages to be encrypted come from an affine distribution, a term we define below. Intuitively, this means that there are publicly known invertible linear relations (over Z n q ) between the messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.2 (Affine message distributions).</head><p>Let n = n(k) and = (k) be integer functions of the security parameter, and let M = {M} k ⊆ ({0, 1} n ) be a distribution ensemble. <ref type="foot" target="#foot_5">7</ref> Then M is affine if there exist invertible and efficiently computable (given k) matrices V 2 , . . . , V ⊆ Z n×n q and vectors w 2 , . . . , w ∈ Z n q , such that for all (m 1 , . . . , m ) in the support of M and for all i ∈ {2, . . . , } it holds that m i = V i • m 1 + w i (where arithmetics is over Z q ). Note that we require that messages are taken over the space {0, 1} n , and arithmetics is over Z q . In particular, this captures the case of "broadcast encryption" where encrypting the same message under many public keys. Furthermore, this also captures XORing with a constant vector over the binary field, or permuting the coordinates of a binary vector (a tool used, e.g., in <ref type="bibr" target="#b7">[7]</ref>). The result is formally stated below. For proof, see full version <ref type="bibr" target="#b9">[9]</ref>. Theorem 4.3. Let d ∈ N be some integer. Then under the d-linear assumption, for any constant 0 &lt; μ &lt; 1 and for any sufficiently large message length n = n(k), the scheme Π Lin is PRIV1-IND-MU-secure with respect to 2 -n μ -hard-toinvert auxiliary inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">A Scheme Based on Subgroup Indistinguishability Assumptions</head><p>In this section we present our second deterministic encryption scheme, which is based on a rather general class of subgroup indistinguishability. For concreteness we first describe the scheme based on the quadratic residuosity assumption, and then describe the more general case. We show that (a slight generalization of) the QR-based lossy trapdoor function of Hemenway and Ostrovsky <ref type="bibr" target="#b22">[21]</ref> is in fact a deterministic public-key encryption scheme that is secure against subexponentially hard-to-invert auxiliary inputs.</p><p>The scheme Π QR . Let GroupGen be a probabilistic polynomial-time algorithm that takes as input a security parameter 1 k , and outputs an integer N = P Q, where P and Q are k-bit prime numbers, and P ( mod 4) = Q ( mod 4) = 3 (i.e., N is a Blum integer). In addition, recall that y←g x denotes an application of an isomorphism transforming an element x in the module M QR N into an element y in the group QR N (since we will never express elements in the module explicitly, we do not care which isomorphism is used). We let ĝ denote the isomorphism between the group J N and the corresponding module, such that the generating set that corresponds to ĝ is the same as that of g, appended with (-1). The scheme is parameterized by the security parameter k and the message length n = n(k).</p><p>- Correctness follows immediately by definition. Security is stated below. The proof appears in the full version <ref type="bibr" target="#b9">[9]</ref>.</p><p>Theorem 5.1. Under the quadratic residuosity assumption, for any constant 0 &lt; μ &lt; 1 and for any sufficiently large message length n = n(k), the scheme Π QR is PRIV-IND-secure with respect to 2 -n μ -blockwise-hard-to-invert auxiliary inputs.</p><p>Extension to general subgroup indistinguishability. As mentioned above, this construction can be extended to general subgroup indistinguishability assumptions <ref type="bibr" target="#b8">[8]</ref> (these include, in particular, Paillier's composite residuosity assumption <ref type="bibr" target="#b25">[24]</ref>). These assumptions are defined in a setting where G U = G M ×G L is a product group such that G U and G L are computationally indistinguishable (there are of course additional requirements, we refer the reader to <ref type="bibr" target="#b8">[8]</ref> for details). Specifically, quadratic residuosity fits into this setting by letting G U = J N , G L = QR N , G M = {±1}. To generalize our construction, we let M be the module that corresponds to G L and replace (-1) with a generator h of G M . Namely, our keys become pk = (g w T , h In • g r•w T ) and sk = r; encryption of a message m ∈ {0, 1} n is done by computing c = (g w T •m , h m • g r•w T •m ); and decryption of c = (ĝ v , ĝy ) is done by computing ĝ(y-r•v) = h m and extracting m. The proof of security in this case is similar to that of the QR-based scheme.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>3): an algorithm that on input f k ( m 0 ) (where m 0 = (m 0,1 , . . . , m 0,t(k) )) can recover one of the m 0,i values can then encrypt this value under pk, compare the resulting ciphertext with the i-th component of Enc pk ( m b ), and thus learn the bit b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Key generation. The key-generation algorithm KeyGen(1 k ) samples N ← GroupGen(1 k ), a vector g w T ← QR n N , and a vector r ← [N 2 ] n . It then outputs pk = (N, g w T , (-1) In • g r•w T ) and sk = r.The matrix dot product above refers to element-wise multiplication:(-1) In • g r•w T i,j = (-1) In i,j • g r•w T i,j.To be completely explicit, we emphasize that pk∈ N × J 1×N N × J n×n N and sk ∈ N n .-Encryption. The encryption algorithm Enc pk (m), where pk = (N, ĝw T , ĝT ) and m ∈ {0, 1} n , outputs the ciphertext c = (ĝ w T •m , ĝT•m ). We note that this computation can be performed efficiently and that c ∈ J N × J n N . For a legally generated public key pk = (N, g w T , (-1) In • g r•w T ) and sk = r, we get c = (g w T •m , (-1) m • g r•w T •m ).-Decryption. The decryption algorithm Dec sk (c), where c = (ĝ v , ĝy ), first computes ĝ(y-r•v) . If the output is of the form (-1) m , for m ∈ {0, 1} n , then it outputs m and otherwise it outputs ⊥.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>P. Rogaway (Ed.): CRYPTO 2011, LNCS 6841, pp. 543-560, 2011. c International Association for Cryptologic Research 2011</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This is somewhat similar to the observation that security is impossible to achieve when the plaintext is distributed over a small set.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>A prime example is the generalized crooked leftover hash lemma<ref type="bibr" target="#b5">[5]</ref>, for which a computational analogue may seem somewhat challenging to devise.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>We emphasize that in this paper we rely on standard computational assumptions (i.e., d-linear or quadratic residuosity), and only the auxiliary inputs are assumed to have subexponential hardness.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>In fact, the "target" function g is allowed to take as input also the randomness that is used for sampling m, and any other public randomness -see Section 3.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>To be absolutely precise should write that M k is a distributions over (({0, 1} n ) t ) for t = 1, but this space is trivially isomorphic to the one we consider.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Simultaneous hardcore bits and cryptography against memory attacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Akavia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2009</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5444</biblScope>
			<biblScope unit="page" from="474" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Deterministic and efficiently searchable encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2007</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4622</biblScope>
			<biblScope unit="page" from="535" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hedged public-key encryption: How to protect against bad randomness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yilek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2009</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5912</biblScope>
			<biblScope unit="page" from="232" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Deterministic encryption: Definitional equivalences and constructions without random oracles</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
			<biblScope unit="page" from="360" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On notions of security for deterministic encryption, and efficient constructions without random oracles</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
			<biblScope unit="page" from="335" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Evaluating 2-DNF formulas on ciphertexts</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-J</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2005</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3378</biblScope>
			<biblScope unit="page" from="325" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Circular-secure encryption from decision Diffie-Hellman</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hamburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
			<biblScope unit="page" from="108" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Circular and leakage resilient public-key encryption under subgroup indistinguishability -(or: Quadratic residuosity strikes back)</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2010</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Better security for deterministic public-key encryption: The auxiliary-input setting</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2011">2011/209 (2011</date>
		</imprint>
	</monogr>
	<note>Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Towards realizing random oracles: Hash functions that hide all partial information</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1997</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Kaliski</surname><genName>Jr</genName></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1294</biblScope>
			<biblScope unit="page" from="455" to="469" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Universally composable security: A new paradigm for cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd Annual IEEE Symposium on Foundations of Computer Science</title>
		<meeting>the 42nd Annual IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="136" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Public-key encryption schemes with auxiliary inputs</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tauman Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2010</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Micciancio</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">5978</biblScope>
			<biblScope unit="page" from="361" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On cryptography with auxiliary input</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lovett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 41st Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="621" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Entropic security and the encryption of high entropy messages</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2005</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3378</biblScope>
			<biblScope unit="page" from="556" to="577" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">More constructions of lossy and correlation-secure trapdoor functions</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2010</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6056</biblScope>
			<biblScope unit="page" from="279" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A simple BGN-type cryptosystem from LWE</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2010</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="506" to="522" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<title level="m">Foundations of Cryptography</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>Basic Applications</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A hard-core predicate for all one-way functions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 21st Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the impossibility of obfuscation with auxiliary input</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th Annual IEEE Symposium on Foundations of Computer Science</title>
		<meeting>the 46th Annual IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="553" to="562" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Probabilistic encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="270" to="299" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Lossy trapdoor functions from smooth homomorphic hash proof systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hemenway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<idno>TR09-127</idno>
	</analytic>
	<monogr>
		<title level="j">Electronic Colloquium on Computational Complexity</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems resilient to key leakage</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2009</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5677</biblScope>
			<biblScope unit="page" from="18" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Deterministic public-key encryption revisited</title>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">533</biblScope>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems based on composite degree residuosity classes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1999</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1592</biblScope>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">How to fool an unbounded adversary with a short key</title>
		<author>
			<persName><forename type="first">A</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1130" to="1140" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Avoiding the disk bottleneck in the data domain deduplication file system</title>
		<author>
			<persName><forename type="first">B</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th USENIX Conference on File and Storage Technologies</title>
		<meeting>the 6th USENIX Conference on File and Storage Technologies</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="269" to="282" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
