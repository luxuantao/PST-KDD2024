<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Transactional storage for geo-replicated systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yair</forename><surname>Sovran</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">New York University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Russell</forename><surname>Power</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">New York University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marcos</forename><forename type="middle">K</forename><surname>Aguilera</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Microsoft Research Silicon Valley</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jinyang</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">New York University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Transactional storage for geo-replicated systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9EFB5DDC1BA7B20502D3E5267D49ED95</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.4 [Computer-Communication Networks]: Distributed Systems-client/server</term>
					<term>distributed applications</term>
					<term>distributed databases</term>
					<term>D.4.5 [Operating Systems]: Reliability-fault-tolerance</term>
					<term>H.3.4 [Information Storage and Retrieval]: Systems and Software-distributed systems Algorithms, Design, Experimentation, Performance, Reliability Transactions, asynchronous replication, geo-distributed systems, distributed storage, key-value store, parallel snapshot isolation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe the design and implementation of Walter, a key-value store that supports transactions and replicates data across distant sites. A key feature behind Walter is a new property called Parallel Snapshot Isolation (PSI). PSI allows Walter to replicate data asynchronously, while providing strong guarantees within each site. PSI precludes write-write conflicts, so that developers need not worry about conflict-resolution logic. To prevent write-write conflicts and implement PSI, Walter uses two new and simple techniques: preferred sites and counting sets. We use Walter to build a social networking application and port a Twitter-like application.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Popular web applications such as Facebook and Twitter are increasingly deployed over many data centers or sites around the world, to provide better geographic locality, availability, and disaster tolerance. These applications require a storage system that is geo-replicated-that is, replicated across many sites-to keep user data, such as status updates, photos, and messages in a social networking application. An attractive storage choice for this setting is a key-value store <ref type="bibr" target="#b15">[16]</ref>, which provides good performance and reliability at low cost.</p><p>We describe Walter, a geo-replicated key-value store that supports transactions. Existing geo-distributed key-value stores provide no transactions or only restricted transactions (see <ref type="bibr">Section 9)</ref>. Without transactions, an application must carefully coordinate access to data to avoid race conditions, partial writes, overwrites, and other hard problems that cause erratic behavior. Developers must address these same problems for many applications. With transactions, developers are relieved from concerns of atomicity, consistency, isolation, durability, and coordination. For example, in a social networking application, one may want to remove user A from B's friends list and vice versa. Without transactions, developers must write code carefully to prevent one removal from happening without the other. With transactions, developers simply bundle . those updates in a transaction.</p><p>Transactions in Walter ensure a new isolation property called Parallel Snapshot Isolation (PSI), which provides a balance between consistency and latency <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b53">54]</ref>, as appropriate for web applications. In such applications, a user might log into the site closest to her, where she accesses application servers, ad servers, authentication servers, etc. These hosts should observe a consistent storage state. For example, in a social network, a user expects to see her own posts immediately and in order. For that reason, the storage system should provide a strong level of consistency among hosts in her site. Across sites, weaker consistency is acceptable, because users can tolerate a small delay for their actions to be seen by other users. A weaker consistency is also desirable, so that transactions can be replicated across sites asynchronously (lazy replication).</p><p>Eventual consistency <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b46">47]</ref> is often the property provided by asynchronous replication. When different sites update the same data concurrently, there is a conflict that must be resolved by application logic. This logic can be complex, and we want to avoid forcing it upon developers.</p><p>With PSI, hosts within a site observe transactions according to a consistent snapshot and a common ordering of transactions. Across sites, PSI enforces only causal ordering, not a global ordering of transactions, allowing the system to replicate transactions asynchronously across sites. With causal ordering, if Alice posts a message that is seen by Bob, and Bob posts a response, no user can see Bob's response without also seeing Alice's original post. Besides providing causal ordering, PSI precludes write-write conflicts (two transactions concurrently writing to the same object) so that developers need not write conflict resolution logic.</p><p>To prevent write-write conflicts and implement PSI, Walter relies on two techniques: preferred sites and counting sets. In web applications, writes to an object are often made by the user who owns the object, at the site where this user logs into. Therefore, we assign each object to a preferred site, where objects can be written more efficiently. For example, the preferred site for the wall posts of a user is the site closest to the user. Preferred sites are less restrictive than primary sites, as we discuss in Section 2.</p><p>Preferred sites may not always suffice. For example, a friends list can be updated by users in many sites. The second technique in Walter to avoid conflicts is to use a new simple data type called a counting set (cset), inspired by commutative data types <ref type="bibr" target="#b28">[29]</ref>. A cset is like a set, except that each element has an integer count. Unlike sets, csets operations are commutative, and so they never conflict <ref type="bibr" target="#b24">[25]</ref>. Therefore, transactions with csets can commit without having to check for conflicts across sites. When developing applications for Walter, we used csets extensively to store friend lists, message walls, photo albums, and message timelines. We found that csets were versatile and easy to use.</p><p>Walter uses multi-version concurrency control within each site, and it can quickly commit transactions that write objects at their preferred sites or that use csets. For other transactions, Walter resorts to two-phase commit to check for conflicts. We found that the latter type of transaction can be avoided in the applications we built.</p><p>Using Walter as the storage system, we build WaltSocial, a Facebook-like social networking application, and we port a third-party Twitter-clone called ReTwis <ref type="bibr" target="#b1">[2]</ref>. We find that the transactions provided by Walter are effective and efficient. Experiments on four geographic locations on Amazon EC2 show that transactions have low latency and high throughput. For example, the operation to post a message on a wall in WaltSocial has a throughput of 16500 ops/s and the 99.9-percentile latency is less than 50 ms.</p><p>In summary, our contributions are the following:</p><p>• We define Parallel Snapshot Isolation, an isolation property well-suited for geo-replicated web applications. PSI provides a strong guarantee within a site; across sites, PSI provides causal ordering and precludes write-write conflicts. • We describe the design and implementation of Walter, a georeplicated transactional key-value store that provides PSI. Walter can avoid common write-write conflicts without cross-site communication using two simple techniques: preferred sites and csets. • We give distributed protocols to execute and commit transactions in Walter. • We use Walter to build two applications and demonstrate the usefulness of its transactional guarantees. Our experience indicates that Walter transactions simplify application development and provide good performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">OVERVIEW</head><p>Setting. A geo-replicated storage system replicates objects across multiple sites. The system is managed by a single administrative entity. Machines can fail by crashing; addressing Byzantine failures is future work. Network partitions between sites are rare: sites are connected by highly-available links (e.g., private leased lines or MPLS VPNs) and there are redundant links to ensure connectivity during planned periods of link maintenance (e.g., using a ring topology across sites). We wish to provide a useful back-end storage system for web applications, such as social networks, web email, social games, and online stores. The storage system should provide reliability, a simple interface and semantics, and low latency.</p><p>Why transactions? We illustrate the benefit of transactions in a social networking application, where users post photos and status updates, befriend other users, and write on friends' walls. Each site has one or more application servers that access shared user data. When Alice adds a new photo album, the application creates an object for the new album, posts a news update on Alice's wall, and updates her album set. With transactions, the application groups these writes into an atomic unit so that failures do not leave behind partial writes (atomicity) and concurrent access by other servers are not intermingled (isolation). Without transactions, the application risks exposing undesirable inconsistent state to end users. For example, Bob may see the wall post that Alice has a new album but not find the album. Developers can sometimes alleviate these inconsistencies manually, by finding and ensuring proper ordering of writes.</p><p>For example, the application can create the new album and wait for it to be replicated before posting on the wall. Then, concurrent access by Bob is not a problem, but a failure may leave behind an orphan album not linked to any user. The developer can deal with this problem by logging and replaying actions-which amounts to implementing rudimentary transactions-or garbage collecting dangling structures. This non-transactional approach places significant burden on developers.</p><p>We are not the first to point out the benefits of transactions to data center applications. Sinfonia uses transactions for infrastructure services <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>, while Percolator <ref type="bibr" target="#b37">[38]</ref> uses them for search indexing. Both systems target applications on a single site, whereas we target geo-replicated applications that span many sites. One way to provide transactions in a geo-replicated setting is to partition the data across several databases, where each database has its primary at a different site. The databases are replicated asynchronously across all sites, but each site is the primary for only one of the partitions. Unfortunately, with this solution, transactions cannot span multiple partitions, limiting their utility to applications. Key features. Walter provides a unique combination of features to support geo-replicated web applications:</p><p>• Asynchronous replication across sites. Transactions are replicated lazily in the background, to reduce latency. • Efficient update-anywhere for certain objects. Counting sets can be updated efficiently anywhere, while other objects can be updated efficiently at their preferred site. • Freedom from conflict-resolution logic, which is complex and burdensome to developers. • Strong isolation within each site. This is provided by the PSI property, which we cover below. Existing systems do not provide some of the above features. For instance, eventually consistent systems such as <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b46">47]</ref> require conflict-resolution logic; primary-copy database systems do not support any form of update-anywhere. We discuss related work in more detail in Section 9.</p><p>Overview of PSI. Snapshot isolation <ref type="bibr" target="#b7">[8]</ref> is a popular isolation condition provided by commercial database systems such as Oracle and SQLServer. Snapshot isolation ensures that (a) transactions read from a snapshot that reflects a single commit ordering of transactions, and (b) if two concurrent transactions have a write-write conflict, one must be aborted. By imposing a single commit ordering, snapshot isolation forces implementations to coordinate transactions on commit, even when there are no conflicts (Section 3.1).</p><p>Parallel snapshot isolation extends snapshot isolation by allowing different sites to have different commit orderings. For example, suppose site A executes transactions T 1, T2 and site B executes transactions T3, T4. PSI allows site A to first incorporate just T1, T2 and later T3, T4, while site B first incorporates T3, T4 and later T1, T2. This flexibility is needed for asynchronous replication: site A (or site B) can commit transactions T1, T2 (or T3, T4) without coordinating with the other site and later propagate the updates.</p><p>Although PSI allows different commit orderings at different sites, it still preserves the property of snapshot isolation that committed transactions have no write-write conflicts, thereby avoiding the need for conflict resolution. Furthermore, PSI preserves causal ordering: if a transaction T2 reads from T1 then T1 is ordered before T2 at every site. We give a precise specification of PSI in Section 3.</p><p>We believe PSI provides strong guarantees that are well-suited for web applications. Intuitively, PSI provides snapshot isolation for all transactions executed within a single site. PSI's relaxation over snapshot isolation is acceptable for web applications where each user communicates with one site at a time and there is no need for a global ordering of all actions across all users. In a social networking application, Alice in site A may post a message at the same time as Bob in site B. Under PSI, Alice may see her message first before seeing Bob's message, and Bob sees the opposite ordering, which is reasonable since Alice and Bob post concurrently. As another example, in an auction application, PSI allows bids on different objects to be committed in different orders at different sites. (In contrast, snapshot isolation requires the same ordering at all sites.) Such relaxation is acceptable since the auction application requires bid ordering on each object separately, not across all objects.</p><p>Avoiding conflicts efficiently. To avoid write-write conflicts across sites, and implement PSI, Walter uses two techniques.</p><p>• Preferred sites. Each object is assigned a preferred site, which is the site where writes to the object can be committed without checking other sites for write conflicts. Walter executes and commits a transaction quickly if all the objects that it modifies have a preferred site where the transaction executes.</p><p>Objects can be updated at any site, not just the preferred site.</p><p>In contrast, some database systems have the notion of a primary site, which is the only site that can update the data. This notion is more limiting than the notion of a preferred site. For instance, suppose objects O1 and O2 are both replicated at sites 1 and 2, but the primary of O1 is site 1 while the primary of O2 is site 2. A transaction executing on site 1 can read both objects (since they are both replicated at site 1), but because the primary of O2 is not site 1, the transaction can write only O1-which is limiting to applications. In practice, this limitation is even more severe because database systems assign primary sites at the granularity of the whole database, and therefore non-primary sites are entirely read-only. • Conflict-free counting set objects. Sometimes an object is modified frequently from many sites and hence does not have a natural choice for a preferred site. We address this problem with counting set (cset) objects. Transactions in Walter support not just read and write operations, but also operations on csets. Csets have the desirable property that transactions concurrently accessing the cset object never generate write-write conflicts. A cset is similar to a multiset in that it keeps a count for each element. But, unlike a multiset, the count could be negative <ref type="bibr" target="#b24">[25]</ref>. A cset supports an operation add(x) to add element x, which increments the counter of x in the cset; and an operation rem(x) to remove x, which decrements the counter of x. Because increment and decrement commute, add and rem also commute, and so operations never conflict. For example, a group of concurrent cset operations can be ordered as add(x), add(y), rem(x) at one site, and ordered as rem(x), add(x), add(y) at another site. Both reach the final state containing just y with count 1. Note that removing element x from an empty cset results in -1 copies of element x, which is an anti-element: later addition of x to the cset results in the empty cset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PARALLEL SNAPSHOT ISOLATION</head><p>In this section, we precisely specify PSI-the guarantee provided by Walter-and we discuss its properties and implications. We start by reviewing snapshot isolation and explaining the framework that we use to specify properties (Section 3.1). Then, we give the exact specification of PSI and discuss its properties (Section 3.2). We next explain how to extend PSI to include set operations (Section 3.3). We then explain how developers can use PSI (Section 3.4) and csets (Section 3.5) to build their applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Snapshot isolation</head><p>We specify snapshot isolation by giving an abstract specification code that an implementation must emulate. The specification code is centralized to make it as simple as possible, whereas an implementation can be distributed, complex, and more efficient. An implementation code satisfies the specification code if both codes produce the same output given the same input (e.g., <ref type="bibr" target="#b31">[32]</ref>). The input  is given by calls to operations to start a transaction, read or write data, commit a transaction, etc. The output is the return value of these operations. Many clients may call the operations of the specification concurrently, resulting possibly in many outstanding calls; however, the body of each operation is executed one at a time, using a single thread. The specification is given in Figures <ref type="figure">1</ref> and<ref type="figure">2</ref> and depicted in Figure <ref type="figure">3</ref>. It is assumed that clients start a transaction x with x initially ⊥, then perform a sequence of reads and/or writes, and then try to commit the transaction. The behavior is unspecified if any client fails to follow this discipline, say by writing to a transaction that was never started. To start transaction x, the code obtains a new monotonically increasing timestamp, called the start timestamp of x. The timestamp is stored as an attribute of x; in the code, x is passed by reference. To write an object in transaction x, the code stores the object id and data in a temporary update buffer. To read an object, the code uses the update buffer-to check for any updates to the object written by the transaction itself-as well as a snapshot of the state when the transaction began. To determine the snapshot, the code maintains a Log variable with a sequence of object ids, data, and timestamps for the writes of previously-committed transactions. Only committed transactions are in the log, not outstanding ones. A read of an object reflects the updates in Log up to the transaction's start timestamp. To commit transaction x, the code obtains a new monotonically increasing timestamp, called the commit timestamp of x. It then determines the outcome of a transaction according to the function in Figure <ref type="figure">2</ref>. This function indicates the cases when the outcome is abort, commit, or either one chosen nondeterministically. <ref type="foot" target="#foot_0">1</ref> The code considers what happens after x started: if some write-conflicting transaction committed then the outcome is abort, where a write-conflicting transaction is one that writes an object that x also writes. Otherwise if some write-conflicting transaction has aborted or is currently executing-meaning it has started but its outcome has not been chosen-then the outcome is either abort or commit, chosen nondeterministically. Otherwise, the outcome is commit. If the outcome is commit, the writes of x are appended to Log with x's commit timestamp.</p><p>Note that the specification keeps internal variables-such as the log, timestamps, and other attributes of a transaction-but an implementation need not have these variables. It needs to emulate only the return values of each operation.</p><p>The above specification of snapshot isolation implies that any implementation must satisfy two key properties <ref type="bibr">[</ref> Here, we say that two committed transactions are concurrent if one of them has a commit timestamp between the start and commit timestamp of the other.</p><p>Snapshot isolation is inadequate for a system replicated at many sites, due to two issues. First, to define snapshots, snapshot isolation imposes a total ordering of the commit time of all transactions, even those that do not conflict <ref type="foot" target="#foot_1">2</ref> . Establishing such an ordering when transactions execute at different sites is inefficient. Second, the writes of a committed transaction must be immediately visible to later transactions. Therefore a transaction can commit only after its writes have been propagated to all remote replicas, thereby precluding asynchronous propagation of its updates. <ref type="foot" target="#foot_2">3</ref> We define PSI to address these problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Specification of PSI</head><p>We define PSI as a relaxation of snapshot isolation so that transactions can propagate asynchronously and be ordered differently across sites. Note that the PSI specification does not refer to preferred sites, since they are relevant only to the implementation of PSI. The specification code is given in Figures <ref type="figure" target="#fig_2">4</ref> and<ref type="figure">5</ref> and depicted in Figure <ref type="figure">6</ref>. As before, the specification is abstract and centralized-there is a single thread that executes the code without interleaving-but we expect that implementations will be distributed. Each transaction x has a site attribute denoted site(x). There is a log per site, kept in a vector Log indexed by sites. A transaction has one commit timestamp per site. A transaction first commits locally, by writing its updates to the log at its site; subsequently, the transaction propagates to and commits at the remote sites. This propagation is performed by the upon statement which, at some non-deterministic time, picks a committed transaction x and a site s to which x has not been propagated yet, and then writes the updates of x to the log at s. (For the moment, we ignore the second line of the upon statement in the code.) As Figure <ref type="figure">5</ref> shows,  if some write-conflicting transaction has committed at site(x) after x started or is currently propagating to site(x) // text has definition of "propagating" then return ABORTED else if some write-conflicting transaction has aborted after x started or is currently executing then return (either ABORTED or COMMITTED ) else return COMMITTED a transaction is aborted if there is some write-conflicting transaction that has committed at site(x) after x started or that is currently propagating to site(x); a transaction y is propagating to a site s if its status is committed but it has not yet committed at site sthat is, y.status=COMMITTED and y.commitTs[s]=⊥. Otherwise, if there is some concurrent write-conflicting transaction that has not committed, the outcome can be abort or commit. Otherwise, the outcome is commit. The outcome of a transaction is decided only once: if it commits at its site, the transaction is not aborted at the other sites. In Section 5.7, we discuss what to do when a site fails. The above specification contains code that may be expensive to implement directly, such as monotonic timestamps and checks for write conflicts of transactions in different sites. We later give a distributed implementation that can avoid these inefficiencies.</p><p>From the specification, it can be seen that PSI replaces property 1 of snapshot isolation with the following: PSI PROPERTY 1. (Site Snapshot Read) All operations read the most recent committed version at the transaction's site as of the time when the transaction began.</p><p>Intuitively, a transaction reads from a snapshot established at its site. In addition, PSI essentially preserves property 2 of snapshot operation setAdd(x, setid, id) append setid, ADD(id) to x.updates return OK operation setDel(x, setid, id) append setid, DEL(id) to x.updates return OK operation setRead(x, setid) return state of setid from x.updates and Log[site(x)] up to timestamp x.startTs isolation. To state the exact property, we say two transactions T1 and T2 are concurrent at site s if one of them has a commit timestamp at s between the start and commit timestamp of the other at s. We say the transactions are somewhere-concurrent if they are concurrent at site(T1) or at site(T2).</p><formula xml:id="formula_0">PSI PROPERTY 2. (No Write-Write Conflicts)</formula><p>The write sets of each pair of committed somewhere-concurrent transactions must be disjoint.</p><p>This property prevents the lost update anomaly (Section 3.4). The specification of PSI also ensures causal ordering: PSI PROPERTY 3. (Commit Causality Across Sites) If a transaction T1 commits at a site A before a transaction T2 starts at site A, then T1 cannot commit after T2 at any site.</p><p>This property is ensured by the second line of the upon statement in Figure <ref type="figure" target="#fig_2">4:</ref> x can propagate to a site s only if all transactions that committed at x's site before x started have already propagated to s. The property prevents a transaction x from committing before y at a remote site when x has observed the updates of y. The property also implies that write-conflicting transactions are committed in the same order at all sites, to prevent the state at different sites from diverging permanently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">PSI with cset objects</head><p>In the specification of PSI in Section 3.2, transactions operate on objects via read and write operations, but it is possible to extend the specification to support objects with other operations. We give the extension for cset objects, but this extension should apply to any object with commutative operations. To add an element to a cset, the code appends an entry setid, ADD, id to the transaction's update buffer (x.updates) and, on commit, appends this entry to the log. Similarly, to remove an element from a cset, the code appends entry setid, DEL, id . To read a cset, the code computes the state of the cset: for each element, it sums the number of ADD minus the number of DEL in the log and the update buffer, thus obtaining a count for each element. Only elements with a non-zero count are returned by the read operation. Because the operations to add and remove elements in a cset commute, these operations do not cause a write conflict. Note that a cset object does not support a write operation since it does not commute with ADD. Figure <ref type="figure" target="#fig_4">7</ref> shows the code of the specification.</p><p>A cset may have many elements, and reading the entire cset could return large amounts of data. It is easy to extend the specification with an operation setReadId to return the count of a chosen element on a cset, by simply computing the state of the cset (using the log) to extract the count of that element.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Using PSI</head><p>One way to understand an isolation property is to understand what type of anomalous behavior it allows, so that developers know  Long fork. Transactions make concurrent disjoint updates causing the state to fork. After they commit, the state may remain forked but it is later merged back. Example. Initially A=B=0. T1 reads A=B=0, writes A←1, and commits; then T2 reads A=1, B=0. T3 and T4 execute concurrently with T1 and T2, as follows. T3 reads A=B=0, writes B←1, and commits; then T4 reads A=0, B=1. Finally, after T1, . . . , T4 finish, T5 reads A=B=1.  what to expect. In this section, we consider PSI from that standpoint, and we compare it against snapshot isolation and serializability. It is well-known that the weaker a property is, the more anomalous behaviors it has, but at the same time, the more efficiently it can be implemented. The anomalies allowed by PSI can be seen as the price to pay for allowing asynchronous replication.</p><p>Figure <ref type="figure" target="#fig_7">8</ref> shows various anomalies and whether each isolation property has those anomalies. Eventual consistency is very weak and allows all anomalies. The first three anomalies are well-known (e.g., <ref type="bibr" target="#b23">[24]</ref>). Snapshot isolation and PSI prevent dirty and nonrepeatable reads, because a transaction reads from a snapshot, and they prevent lost updates because there are no write-write conflicts. Snapshot isolation allows the state to fork, because two or more transactions may read from the same snapshot and make concurrent updates to different objects. We call this a short fork, also known as write skew, because the state merges after transactions commit. With PSI, the state may remain forked after transactions commit (when they execute in different sites), but the state is later merged when the transactions propagate across sites. Due to its longer du-ration, we call this a long fork. A conflicting fork occurs when the states diverges due to conflicting updates, which is not allowed by PSI.</p><p>Long forks are acceptable in web applications when users in a site do not expect their updates to be instantly visible across all sites. If the user wants to know that her updates are visible everywhere, she can wait for her transaction to commit at all sites. In some cases, the fork may be noticeable to users: say, Alice posts a message on her social network wall saying that she is the first to flag a new promotion; she then confirms her statement by reading her friend's walls and seeing nothing there. With a long fork, Bob could be simultaneously doing the same thing from a different site, so that both Alice and Bob believe they posted their message first. One way to avoid possible confusion among users is for the application to show an "in-flight" mark on a freshly posted message; this mark is removed only when the message has been committed at all sites. Then, when Alice sees the mark, she can understand that her in-flight message may not yet be visible to all her friends.</p><p>Having discussed the anomalies of PSI, we now discuss ways that an application can use and benefit from PSI.</p><p>Multi-object atomic updates. With PSI, updates of a transaction occur together, so an application can use a transaction to modify many objects without exposing partial updates on each object.</p><p>Snapshots. With PSI, a transaction reads from a fixed consistent snapshot, so an application can use a transaction to ensure that it is reading consistent versions of different objects.</p><p>Read-modify-write operations. Because PSI disallows write-write conflicts, a transaction can implement any atomic read-modify-write operation, which reads an object and writes a new value based on the value read. Such operations include atomic increment and decrement of counters, atomic appends, and atomic edits.</p><p>Conditional writes. A particularly useful type of read-modifywrite operation is a conditional write, which writes an object only if its content or version matches a value provided by the application. With PSI, this is performed by reading the object, evaluating the condition and, if it is satisfied, writing the object. This scheme can be extended to check and write many objects at once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Using cset operations</head><p>A cset is a mapping from ids to counts, possibly negative. The mapping indicates how many times the element with a given id appears in the cset. There are two ways to use csets. First, when the count is useful to the application, a cset can be used as is. For example, a cset can keep the number of items in a shopping cart or inventory, the number of accesses to a data item, or the number of references to an object.</p><p>The second way to use a cset is as a conventional set, by hiding the counts from the user. For example, a cset can keep a list of friends, messages, active users, or photo albums. In these cases, the count has no meaning to the user. The application should be designed to keep the counts of elements at zero or one: the application should not add an element to a cset when the element is already present, or remove an element from a cset when the element is not there. In some cases, however, concurrent updates may cause the count to raise above one or drop below zero. For example, a user may add the same friend to her friends list, and do so concurrently at two different sites: the application sees a count of zero in both sites, and so it adds the friend once at each site. This situation is rare, because there must be updates to the same element in the same cset, and those updates must be concurrent, but it may happen. This is addressed by treating a count of one or more as present in the set, and count of zero or less as absent from the set. For example, when showing the list to the user, friends with negative counts are excluded. When the user adds a friend, if the count is negative, the application adds the friend enough times for the count to be one. When removing a friend, the application removes her enough times for the count to be zero. This is done by the application, transparently to the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SERVICE</head><p>This section describes how clients view and use Walter. Each site contains a Walter server and one or more application clients. Walter stores key-value object pairs grouped in containers (Section 4.1), where each container is replicated across multiple sites. The Walter client interface is exposed as a user-level library with functions to start transactions, read and write data, and commit transactions (Section 4.2). Walter provides fault tolerance by replicating data across sites (Section 4.3), and it allows users to trade-off durability for availability (Section 4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Objects and containers</head><p>Walter stores objects, where an object has a key and a value. There are two types of objects: regular and cset. In a regular object, the value is an uninterpreted byte sequence, while in cset object, the value is a cset.</p><p>Each object is stored in a container, a logical organization unit that groups objects with some common purpose. For example, in a Web application, each user could have a container that holds all of her objects. To reduce space overhead, all objects in a container have the same preferred site, and Walter stores this information only once, as an attribute of the container. Administrators choose the preferred site to be the site most likely to modify the objects. For example, each user may have a designated site where she logs into the system (if she tries to log into a different site, she is redirected), and this would be the preferred site of her objects.</p><p>Object ids consist of a container id and a local id. The container id indicates to which container the object belongs, and the local id differentiates objects within a container. Since the container id is part of the object id, the container of an object cannot be changed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Interface</head><p>Walter provides a client library for starting a transaction, manipulating objects, and committing a transaction, with the PSI semantics and operations explained in Sections 3.2 and 3.3. For regular objects, the available operations are read and write; for cset objects, the available operations are read, add element, and delete element.</p><p>Walter replicates transactions asynchronously, and the interface allows a client to receive a callback when (a) the transaction is disaster-safe durable (Section 4.4), and (b) the transaction is globally visible, meaning it has been committed at all sites.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Replication</head><p>Walter provides both durability and availability by replicating data within a single site and across multiple sites. Replication is transparent to clients: all the replicas of an object have the same object id, and the system accesses the replica closest to the client. An object need not be replicated at all sites and clients can read objects even if they are not replicated at the local site, in which case Walter fetches the data from a remote site. <ref type="foot" target="#foot_3">4</ref> A transaction commits at every site, even where it is not replicated, following the semantics of PSI in Section 3.2: once a transaction is committed at a site, reads from that site see the effects of the transaction. Administrators choose how many replicas and where they are. These settings are stored as attributes of a container, so all objects of a container are replicated similarly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Durability and availability</head><p>Walter provides two levels of durability:</p><p>(Normal Durability) When a transaction commits at its site, writes have been logged to a replicated cluster storage system <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b47">48]</ref>, so writes are not lost due to power failures. Data may be lost if an entire data center is wiped out by a disaster.</p><p>(Disaster-safe Durability) A transaction is considered disaster-safe durable if its writes have been logged at f +1 sites, where parameter f determines the desired fault tolerance level: up to f sites may fail without causing data loss. The default value of f is 1.</p><p>If an entire site s fails temporarily or is unreachable due to crosssite network issues, it may have transactions that were locally committed but not yet propagated to other sites. In that case, the application has two choices:</p><p>(Conservative) Wait for the site s to come back online, so that it can propagate the missing transactions. But then clients cannot write to objects whose preferred site is s until s comes back online-a loss of availability for some writes.</p><p>(Aggressive) Sacrifice the durability of a few committed transactions at site s for better availability, by replacing site s and abandoning its non-propagated transactions. Technically, this choice violates PSI, but one could extend the PSI definition to allow for lost committed transactions when a site fails or disconnects. Applications can wait for important transactions to be marked disaster-safe durable before confirming them to users.</p><p>Availability within a site comes from the availability of the cluster storage system: if the Walter server at a site fails, the system starts a new server, which can access the same cluster storage system. Availability under network partitions or disasters comes from cross-site replication. If a site fails, an application can warn users before they are redirected to another site, because users may see a different system state at the new site due to the semantics of PSI. In practice, the state at different sites diverges by only a few seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">DESIGN AND ALGORITHMS</head><p>This section describes Walter's design, emphasizing the protocols for executing and committing transactions. We first give an overview of the basic architecture (Section 5.1) and object versioning (Section 5.2). We then explain how to execute transactions (Section 5.3) and how to commit certain common transactions quickly (Section 5.4). Next, we explain how to commit other transactions (Section 5.5) and how transactions are replicated asynchronously (Section 5.6). Lastly, we consider failure recovery (Section 5.7) and scalability (Section 5.8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Basic architecture</head><p>There are multiple sites numbered 1, 2, . . . Each site contains a local Walter server and a set of clients. A client communicates with the server via remote procedure calls implemented by the API library. The server executes the actual operations to start and commit transactions, and to access objects.</p><p>Walter employs a separate configuration service to keep track of the currently active sites, and the preferred site and replica set At Serveri:</p><p>/ / i denotes the site number CurrSeqNo i : integer with last assigned local sequence number CommittedVTSi: vector indicating for each site how many transactions of that site have been committed at site i History i [oid]: a sequence of updates of the form data, version to oid, where version = j:n for some j, n GotVTSi: vector indicating for each site how many transactions of that site have been received by site i for each object container. The configuration service tolerates failures by running as a Paxos-based state machine replicated across multiple sites. A Walter server confirms its role in the system by obtaining a lease from the configuration service, similar to what is done in <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b45">46]</ref>. The lease assigns a set of containers to a preferred site, and it is held by the Walter server at that site. A Walter server caches the mapping from a container to its replica sites to avoid contacting the configuration service at each access. Incorrect cache entries do not affect correctness because a server rejects requests for which it does not hold the corresponding preferred site lease.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Versions and vector timestamps</head><p>The PSI specification is centralized and uses a monotonic timestamp when a transaction starts and commits. But monotonic timestamps are expensive to produce across multiple sites. Thus, to implement PSI, Walter replaces them with version numbers and vector timestamps. A version number (or simply version) is a pair site, seqno assigned to a transaction when it commits; it has the site where the transaction executed, and a sequence number local to that site. The sequence number orders all transactions within a site. A vector timestamp represents a snapshot; it contains a sequence number for each site, indicating how many transactions of that site are reflected in the snapshot. A transaction is assigned a vector timestamp startVTS when it starts. For example, if startVTS = 2, 4, 5 then the transaction reads from the snapshot containing 2 transactions from site 1, 4 from site 2, and 5 from site 3.</p><p>Given a version v= site, seqno and a vector timestamp startVTS, we say that v is visible to startVTS if seqno ≤ startVTS[site]. Intuitively, the snapshot of startVTS has enough transactions from site to incorporate version v.</p><p>Figure <ref type="figure" target="#fig_8">9</ref> shows the variables at the server at site i. Variable CurrSeqNo i has the last sequence number assigned by the server, and CommittedVTSi[j] has the sequence number of the last transaction from each site j that was committed at site i. We discuss History i and GotVTSi in Sections 5.3 and 5.6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Executing transactions</head><p>To execute transactions, the server at each site i maintains a history denoted History i [oid] with a sequence of writes/updates for each object oid, where each update is tagged with the version of the responsible transaction. This history variable is similar to variable Log in the PSI specification, except that it keeps a list per object, and it has versions not timestamps. When a transaction x starts, Walter obtains a new start vector timestamp startVTS containing the sequence number of the latest transactions from each site that were committed at the local site. To write an object, add to a cset, or remove from a cset, Walter stores this update in a temporary buffer x.updates. To read an object, Walter retrieves its state from the snapshot determined by startVTS and any updates in x.updates. Specifically, for a regular object, Walter returns the last update in x.updates or, if none, the last update in the history visible to startVTS. For a cset object, Walter computes its state by  applying the updates in the history visible to startVTS and the updates in x.updates.</p><p>The above explanation assumes an object is replicated locally. If not, its local history History i [oid] will not have all of the object's updates (but it may have some recent updates). Therefore, to read such an object, Walter retrieves the data from the object's preferred site and merges it with any updates in the local history and in x.updates. To write, Walter buffers the write in x.updates and, upon commit, stores the update in the local history while it is being replicated to other sites; after that, the local history can be garbage collected. Figure <ref type="figure">10</ref> shows the detailed pseudocode executed by a server. Recall that clients invoke the operations at the local server using a remote procedure call (not shown). The code is multi-threaded and we assume that each line is executed atomically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Fast commit</head><p>For transactions whose write-set has only objects with a local preferred site, Walter uses a fast commit protocol. The write-set of a transaction consists of all oids to which the transaction writes; it excludes updates to set objects. To fast commit a transaction x, Walter first determines if x can really commit. This involves two checks for conflicts. The first check is whether all objects in the write-set are unmodified since the transaction started. To perform this check, Walter uses the start vector timestamp: specifically, we say that an object oid is unmodified since x.startVTS if all versions of oid in the  history of the local site are visible to x.startVTS. The second check is whether all objects in the write-set of x are unlocked; intuitively, a locked object is one being committed by the slow commit protocol (Section 5.5). If either check fails, then x is aborted. Otherwise, Walter proceeds to commit x, as follows. It assigns a new local sequence number to x, and then applies x's updates to the histories of the modified objects. Walter then waits until the local transaction with preceding sequence number has been committed. This typically happens quickly, since sequence numbers are assigned in commit order. Finally, transaction x is marked as committed and Walter propagates x to remote sites asynchronously as described in Section 5.6. Figure <ref type="figure" target="#fig_9">11</ref> shows the detailed pseudocode. The notation site(oid) denotes the preferred site of oid. As before, we assume that each line is executed atomically. A vertical bar indicates a block of code with multiple lines that is executed atomically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Slow commit</head><p>Transactions that write a regular object whose preferred site is not local must be committed using the slow commit protocol, which employs a type of two-phase commit among the preferred sites of the written objects (not across all replicas of the objects). The purpose of two-phase commit is to avoid conflicts with instances of fast commit and other instances of slow commit. To commit a transaction x, the server at the site of the transaction acts as the coordinator in the two-phase protocol. In the first phase, the coordinator asks the (servers at the) preferred sites of each written object to vote based on whether those objects are unmodified and unlocked. If an object is modified at the preferred site, then an instance of fast commit conflicts with x; if the object is locked at the preferred site, then another instance of slow commit conflicts with x. If either case occurs, the site votes "no", otherwise the site locks the objects and votes "yes". If any vote is "no", the coordinator tells the sites to release the previously acquired locks. Otherwise, the coordinator proceeds to commit x as in the fast commit protocol: it assigns a sequence number to x, applies x's updates to the object histories, marks x as committed, and propagates x asynchronously. When x At Serveri: / / i denotes the site number function propagate(x) send PROPAGATE , x to all servers wait until ∀oid∈x.writeset: received PROPAGATE-ACK , x.tid from f +1 sites replicating oid including site(oid) mark x as disaster-safe durable send DS-DURABLE , x to all servers wait until received VISIBLE , x.tid from all sites mark x as globally visible when received PROPAGATE , x from Serverj and GotVTSi ≥ x.startVTS and GotVTSi[j] = x.seqno-1 do if i = j then update(items in x.updates replicated in this site, j : x.seqno ) // when i = j, update has been applied already when transaction committed GotVTSi commits, a site releases the acquired locks when x is propagated to it. Figure <ref type="figure" target="#fig_10">12</ref> shows the detailed pseudocode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Asynchronous propagation</head><p>After a transaction commits, it is propagated asynchronously to other sites. The propagation protocol is simple: the site of a transaction x first copies the objects modified by x to the sites where they are replicated. The site then waits until sufficiently many sites indicate that they received (a) transaction x, (b) all transactions that causally precede x according to x.startVTS, and (c) all transactions of x's site with a smaller sequence number. "Sufficiently many sites" means at least f +1 sites replicating each object including the object's preferred site, where f is the disaster-safe tolerance parameter (Section 4.4). At this point, x is marked as disaster-safe durable and all sites are notified. Transaction x commits at a remote site j when (a) site j learns that x is disaster-safe durable, (b) all transactions that causally precede x are committed at site j, and (c) all transactions of x's site with a smaller sequence number are committed at site j. When x has committed at all sites, it is marked as globally visible. The pseudocode is shown in Figure <ref type="figure" target="#fig_11">13</ref>. Vector GotVTS i keeps track of how many transactions site i has received from each other site. Note that when a site i receives a remote transaction and updates the history of its objects, the transaction is not yet committed at i: it commits only when CommittedVTSi[j] is incremented. The code omits simple but important optimizations: when server i propagates transaction x to a remote server, it should not send all the updates of x, just those updates replicated at the remote server. Similarly, when it sends a DS-DURABLE message, a server need not include the updates of x again.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Handling failures</head><p>Recovering from client or server failure. If a client crashes, its outstanding transactions are aborted and any state kept for those transactions at the server is garbage collected. Each server at a site stores its transaction log in a replicated cluster storage system. When a Walter server fails, the replacement server resumes propagation for those committed transactions that have not yet been fully propagated.</p><p>Handling a site failure. An entire site s may fail due to a disaster or a power outage. Such failure is problematic because there may be committed transactions at s that were not yet replicated at other sites. As explained in Section 4.4, Walter offers two site recovery options: conservative and aggressive. Recall that the conservative option is to wait for s to come back online, while the aggressive option is to remove s and reassign the preferred site of its containers to another site. To remove a failed site, Walter uses the configuration service (Section 5.1). Each configuration indicates what sites are active. Before switching to a new configuration that excludes site s, the configuration service must find out the transactions committed by s that will survive across the configuration change. Transaction x of site s survives if x and all transactions that causally precede x and all transactions of s with a smaller sequence number have been copied to a site in the new configuration. The configuration service queries the sites in the new configuration to discover what transactions survive. Then, it asks each site to discard the replicated data of non-surviving transactions and, in the background, it completes the propagation of surviving transactions that are not yet fully replicated. Finally, the configuration service reassigns the preferred site of containers of s to another site, by having another site take over the appropriate leases. While reconfiguration is in progress, sites that are still active continue to commit transactions, except transactions that write to objects whose preferred site was s, which are postponed until those objects get a new preferred site.</p><p>Re-integrating a previously failed site. When a previously removed site s recovers, it must be re-integrated into the system. The configuration service starts a new reconfiguration that includes s. To switch to the new configuration, s must first synchronize with its replacement site s to integrate modifications committed by s . Once synchronization is finished, s takes over the lease for being the preferred site for the relevant containers, and the new configuration takes effect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.8">Scalability</head><p>Walter relies on a single server per site to execute and commit transactions, which can become a scalability bottleneck. A simple way to scale the system is to divide a data center into several "local sites", each with its own server, and then partition the objects across the local sites in the data center. This is possible because Walter supports partial replication and allows transactions to operate on an object not replicated at the site-in which case, the transaction accesses the object at another site within the same data center. We should note that PSI allows sites to diverge; to avoid exposing this divergence to users, applications can be designed so that a user always log into the same local site in the data center. Another approach to scalability, which we do not explore in this paper, is to employ several servers per site and replace the fast commit protocol of Section 5.4 with distributed commit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">IMPLEMENTATION</head><p>The Walter implementation has a client-side library and a server, written in C++, with a total of 30K lines of code. There is also a PHP interface for web development with 600 lines of code. The implementation differs from the design as follows. First, each Walter server uses direct-attached storage devices, instead of a cluster storage system. Second, we have not implemented the scheme to reintegrate a failed site (Section 5.7): currently, the administrator must invoke a script manually to do that. Third, the client interface, shown in Figure <ref type="figure" target="#fig_12">14</ref>, differs cosmetically from the specification in Section 3.2, due to the specifics of C++ and PHP. In C++, there is a Transaction class and operations are methods of this class. Functions read, setRead, and setReadId return the data via a parameter (the C++ return value is a success indication). setRead provides an  iterator for the ids in a cset. setReadId indicates the count of an identifier in a cset. commit can optionally inform the client via supplied callbacks-not shown-when the transaction is disaster-safe durable and globally visible (i.e., committed at all sites). There is a function newid to return a fresh oid, explained below.</p><p>There are no specialized functions to create or destroy objects. Conceptually, all objects always exist and are initialized to nil, without any space allocated to them. If a client reads a never-written object, it obtains nil. Function newid returns a unique oid of a never-written object of a chosen type (regular or cset) in a chosen container. Destroying a regular object corresponds to writing nil to it, while destroying a cset object corresponds to updating its elements so that they have zero count. There are some additional functions (not shown), including (a) management functions for initialization, shutdown, creating containers, and destroying containers; and (b) functions that combine multiple operations in a single RPC to the server, to gain performance; these include functions for reading or writing many objects, and for reading all objects whose ids are in a cset. The functions to create and destroy containers run outside a transaction; we expect them to be used relatively rarely. Identifiers for containers and objects are currently restricted to a fixed length, but it would be easy to make them variable-length.</p><p>The server stores object histories in a persistent log and maintains an in-memory cache of recently-used objects. The persistent log is periodically garbage collected to remove old entries. The entries in the in-memory cache are evicted on an LRU basis. Since it is expensive to reconstruct csets from the log, the eviction policy prefers to evict regular objects rather than csets. There is an in-memory index that keeps, for each object, a list of updates to the object, ordered from most to least recent, where each update includes a pointer to the data in the persistent log and a flag of whether the data is in the cache. To speed up system startup and recovery, Walter periodically checkpoints the index to persistent storage; the checkpoint also describes transactions that are being replicated. Checkpointing is done in the background, so it does not block transaction processing. When the server starts, it reconstructs the index from the checkpointed state and the data in the log after the checkpoint.</p><p>To improve disk efficiency, Walter employs group commit to flush many commit records to disk at the same time. To reduce the number of threads, the implementation makes extensive use of asynchronous calls and callbacks when it invokes blocking and slow operations. To enhance network efficiency, Walter propagates transactions in periodic batches, where each batch remotely copies all transactions that committed since the last batch.  The protocol for slow commit may starve because of repeated conflicting instances of fast commit. A simple solution to this problem is to mark objects that caused the abort of slow commit and briefly delay access to them in subsequent fast commits: this delay would allow the next attempt of slow commit to succeed. We have not implemented this mechanism since none of our applications use slow commit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">APPLICATIONS</head><p>Using Walter, we built a social networking web site (WaltSocial) and ported a third-party Twitter-like application called ReTwis <ref type="bibr" target="#b1">[2]</ref>. Our experience suggests that it is easy to develop applications using Walter and run them across multiple data centers.</p><p>WaltSocial. WaltSocial is a complete implementation of a simple social networking service, supporting the common operations found in a system such as Facebook. These include befriend, statusupdate, post-message, read-info as well as others. In WaltSocial, each user has a profile object for storing personal information (e.g., name, email, hobbies) and several cset objects: a friend-list has oids of the profile objects of friends, a message-list has oids of received messages, an event-list has oids of events in the user's activity history, and an album-list has oids of photo albums, where each photo album is itself a cset with the oids of photo objects.</p><p>WaltSocial uses transactions to access objects and maintain data integrity. For example, when users A and B befriend each other, a transaction adds A's profile oid to B's friend-list and vice versa (Figure <ref type="figure" target="#fig_13">15</ref>). To post-message from A to B, a transaction writes an object m with the message contents and adds its oid to B's messagelist and to A's event-list.</p><p>Each user has a container that stores her objects. The container is replicated at all sites to optimize for reads. The system directs a user to log into the preferred site of her container. User actions are confirmed when transactions commit locally.</p><p>ReTwis. ReTwis is a Twitter-clone written in PHP using the Redis key-value store <ref type="bibr" target="#b0">[1]</ref>. Apart from simple get/put operations, this application makes extensive use of Redis's native support for certain atomic operations, such as adding to or removing from a list, and adding or subtracting from an integer. In Redis, cross-site replication is based on a master-slave scheme. For our port of ReTwis, we replace Redis with Walter, so that ReTwis can update data on multiple sites. We use Walter transactions and csets to provide the equivalent atomic integer and list operation in Redis.</p><p>For each user, ReTwis has a timeline that tracks messages posted by the users that the user is following. In the original implementation, a user's timeline is stored in a Redis list. When a user posts a message, ReTwis performs an atomic increment on a sequence number to generate a postID, stores the message under the postID, and appends the postID to each of her followers' timelines. When a user checks postings, ReTwis displays the 10 most recent messages from her timeline. To port ReTwis to use Walter, we make several changes: we use a cset object to represent each user's timeline so that different sites can add posts to a user's timeline without conflicts. To post a message, we use a transaction that writes a message under a unique postID, and adds the postID to the timeline of every follower of the user.</p><p>We found the process of porting ReTwis to Walter to be quite simple and straightforward: a good programmer without previous Walter experience wrote the port in less than a day. Transactions allow the data structure manipulations built into Redis to be implemented by the application, while providing competitive performance (Section 8.7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">EVALUATION</head><p>We evaluate the performance of Walter and its applications (Walt-Social, ReTwis) using Amazon's EC2. The highlights of our results are the following:</p><p>• Transactions that modify objects at their preferred sites commit quickly, with a 99.9-percentile latency of 27ms on EC2.</p><p>Committed transactions are asynchronously replicated to remote sites within twice the network round-trip latency. • Transactions that modify csets outside of their preferred sites also commit quickly without cross-site coordination. Walt-Social uses csets extensively and processes user requests with a 99.9-percentile latency under 50ms. • The overhead for supporting transactions in Walter is reasonable. ReTwis running on Walter has a throughput 25% smaller than running on Redis in a single site, but Walter allows ReTwis to scale to multiple sites.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Experimental setup</head><p>Unless stated otherwise, experiments run on Amazon's EC2 cloud platform. We use machines in four EC2 sites: Virginia (VA), California (CA), Ireland (IE), and Singapore (SG), with the following average round-trip latencies within and across sites (in ms): Within a site, the bandwidth between two hosts is over 600 Mbps; across sites, we found a bandwidth limit of 22 Mbps.</p><p>We use extra-large EC2 virtual machine instances, with 7 GB of RAM and 8 virtual cores, each equivalent to a 2.5 GHz Intel Xeon processor. Walter uses write-ahead logging, where commit logs are flushed to disk at commit time. Since one cannot disable writecaching at the disk on EC2, where indicated we run experiments on a private cluster outside of EC2, with machines with two quad core Intel Xeon E5520 2.27 GHz processors and 8 GB of RAM.</p><p>Each EC2 site has a Walter server, and we run experiments with different numbers of sites and replication levels, as shown below: Our microbenchmark workload (Sections 8.2-8.5) consists of transactions that read or write a few randomly chosen 100-byte objects. (Changing the object size from 100 bytes to 1 KB yields similar results.) We choose to evaluate small transactions because our applications, WaltSocial and ReTwis, only access a few small objects in each transaction. We consider a transaction to be disastersafe durable when it is committed at all sites in the experiment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Base performance</head><p>We first evaluate the base performance of Walter, and compare it against Berkeley DB 11gR2 (BDB), a commercial open-source developer database library. The goal is to understand if Walter provides a usable base performance.</p><p>Benchmark setup. We configure BDB to use B-trees with default pagesize and snapshot isolation; parameters are chosen for the best performance. We configure BDB to have two replicas with asynchronous replication. Since BDB allows updates at only one replica (the primary), we set up the Walter experiment to also update at one site. To achieve good throughput in BDB, we must use many threads at the primary to achieve high concurrency. However, with many threads, EC2 machines perform noticeably worse than private machines. Therefore, we run the primary BDB replica in our private cluster (with write-caching at the disk enabled), and the other replica at the CA site of EC2. We do the same for Walter. Clients and the server run on separate hosts. For BDB, we use an RPC server to receive and execute client requests.</p><p>The workload consists of either read or write transactions each accessing one 100-byte object. We populate BDB and Walter with 50,000 keys, which fits in the 1 GB cache of both systems. Walter includes an optimization to reduce the number of RPCs, where the start and commit of each transaction are piggybacked onto the first and last access, respectively. Thus, transactions with one access require just one RPC in Walter and in BDB.</p><p>Results. Figure <ref type="figure">16</ref> shows that throughput of read and write transactions of Walter is comparable to that of BDB. Read throughput is CPU-bound and mainly limited by the performance of our RPC library in both systems. Walter's read throughput is slightly lower because it does more work than BDB by acquiring a local lock and assigning a start timestamp vector when a transaction starts. The commit and replication latency of BDB and Walter are also similar and not shown here (see Section 8.3 for Walter's latency).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Fast commit on regular objects</head><p>This microbenchmark evaluates the performance of transactions on regular objects, using fast commit.</p><p>Benchmark setup. The experiments involve one to four sites. Objects are replicated at all sites, and their preferred sites are assigned evenly across sites. At each site, we run multiple clients on different hosts to issue transactions as fast as possible to its local Walter server. There are several workloads: read-only, write-only, and mixed. Read-only or write-only transactions access one or five 100byte objects. The mixed workload consists of 90% read-only transactions and 10% write-only transactions.</p><p>Result: throughput. Figure <ref type="figure" target="#fig_4">17</ref> shows Walter's aggregate throughput across sites as the number of sites varies. Read throughput is bounded by the RPC performance and scales linearly with the number of sites, reaching 157 Ktps (thousands of transactions per second) with 4 sites. Write throughput is lower than read throughput due to lock contention within a Walter server. Specifically, when a transaction commits, a thread needs to acquire a highly contended lock to check for transaction conflicts. Moreover, write throughput does not scale as well as read throughput as the number of   sites increases. This is because data is replicated at all sites, so the amount of work per write transaction grows with the number of sites. Yet, the cost of replication is lower than that of committing because replication is done in batches. Thus, the write throughput still grows with the number of sites, but not linearly. Note that the read and write throughput for transactions of size 1 in Figure <ref type="figure" target="#fig_4">17</ref> is only 50-60% of that in Figure <ref type="figure">16</ref> as a result of running this experiment on EC2 instead of the private cluster. In the mixed workload, performance is mostly determined by how many operations a transaction issues on average. For example, when there are 90% read-only transactions each reading one object and 10% write-only transactions each writing 5 objects, a transaction issues on average only 1.4 requests to the server. As a result, a relatively high aggregate throughput of 80 Ktps is reached across 4 sites. Result: latency. We measure the fast commit latency for writeonly transactions accessing 5 objects. We record the time elapsed between issuing a commit and having the server acknowledge the commit completion. Figure <ref type="figure" target="#fig_15">18</ref> shows the latency distribution measured on EC2, and in our private cluster with and without write caching at the disk. The measurements were taken for a moderate workload in which clients issued enough requests to achieve 70% of maximal throughput. The points at the lower-end of the distributions in Figure <ref type="figure" target="#fig_15">18</ref> show latencies that we observe in a lightly loaded system.</p><p>Because there is no cross-site coordination, fast commit is quick: On EC2 the 99-percentile latency is 20 ms and the 99.9-percentile is 27 ms. Since the network latency within a site is low at 0.5 ms, the commit latency is dominated by the effects of queuing inside the Walter server and of flushing the commit log to disk when committing transactions at a high throughput. Figure <ref type="figure" target="#fig_15">18</ref> also shows the effect of disabling write-caching at the disk, measured on our private cluster. Even in that case, the 99.9-percentile latency of a fast commit is under 90 ms.</p><p>The latency for a committed transaction to become disaster-safe durable is dominated by the network latency across sites. As shown in Figure <ref type="figure" target="#fig_16">19</ref>, the latency is distributed approximately uniformly between [RTT max, 2 * RTTmax] where RTTmax is the maximum roundtrip latency between VA and the other three sites. This is because Walter propagates transactions in batches to maximize throughput, so a transaction must wait for the previous batch to finish.</p><p>The latency for a committed transaction to become globally visible is an additional RTTmax after it has become disaster-safe durable (not shown).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Fast commit on cset objects</head><p>We now evaluate transactions that modify csets.</p><p>Benchmark setup. We run the 4-site experiment in which each transaction modifies two 100-byte objects at the preferred site and adds an id to a cset with a remote preferred site.</p><p>Results. The latency distribution curve for committing transactions (not shown) is similar to the curve corresponding to EC2 in Figure <ref type="figure" target="#fig_15">18</ref>. This is because transactions modifying csets commit via the same fast commit protocol as transactions modifying regular objects at their preferred site. Across 4 sites, the aggregate throughput is 26 Ktps, which is lower than the single-write transaction throughput of 52 Ktps shown in Figure <ref type="figure" target="#fig_4">17</ref>. This is because the cset transactions issue 4 RPCs (instead of 1 RPC for the transactions in Figure <ref type="figure" target="#fig_4">17</ref>), to write two objects, modify a cset, and commit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Slow commit</head><p>We now evaluate the slow commit protocol for transactions modifying objects with different preferred sites. Unlike fast commit, slow commit requires cross-site coordination.</p><p>Benchmark setup. We run the 4-site experiments and have clients  issue write-only transactions at the VA site. We vary the size of a transaction from 2 to 4 objects. Each object written has a different preferred site: the first, second, third, and fourth object's preferred sites are VA, CA, IE, and SG respectively.</p><p>Results. Figure <ref type="figure" target="#fig_17">20</ref> shows the commit latency (left-most three lines) and the latency for achieving disaster-safe durability (right-most three lines). The commit latency is determined by the round-trip time between VA and the farthest preferred site of objects in the writeset. This is because slow commit runs a two-phase protocol among the preferred sites of the objects in the writeset. For example, for transactions of size 3, the commit latency is 87 ms, which is the round-trip time from VA to IE. The latency for disastersafe durability is the commit latency plus the replication latency. The replication latency is the same as for fast commit: it is uniformly distributed between [RTT max, 2 * RTTmax], where RTTmax is the round-trip time between VA and SG.</p><p>To optimize performance, applications should minimize the use of slow commits. Both WaltSocial and ReTwis avoid slow commits by using csets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">WaltSocial performance</head><p>Transactions make it easy to develop WaltSocial. Our experiments also show that WaltSocial achieves good performance.</p><p>Workload setup. The WaltSocial experiments involve 4 sites in EC2. We populate Walter with 400, 000 users, each with 10 status updates and 10 wall postings from other users. We run many application clients at each site, where each client issues WaltSocial operations. An operation corresponds to a user action, and it is implemented by executing and committing a transaction that reads and/or writes several data objects (Section 7). We measure the latency and aggregate throughput for each operation. We also evaluate two mixed workloads: mix1 consists of 90% read-info operations and 10% update operations including status-update, postmessage and befriend; mix2 contains 80% read-info operations and 20% update operations. Operation throughput. Figure <ref type="figure">21</ref> shows the throughput in thousands operations per second (Kops/s) for each WaltSocial operation and for the mixed workloads. The read-info operation issues read-only transactions; it has the highest aggregate throughput at 40 Kops/s. The other operations issue transactions that update objects; their throughput varies from 16.5 Kops/s to 20 Kops/s, depending on the number of objects read and written in the transactions. The mixed workloads are dominated by read-info operations, hence their throughput values are closer to that of read-info. The achieved throughput is likely sufficient for small or medium social networks. To handle larger deployments, one might deploy several sites per data center to scale the system (Section 5.8) . Operation latency. Figure <ref type="figure">22</ref> shows the latency of WaltSocial operations when the system has a moderate load. Operations finish  quickly because the underlying transactions involve no cross-site communication: transactions always read a local replica for any object and transactions that update data use cset objects. The 99.9percentile latency of all operations in Figure <ref type="figure">22</ref> is below 50 ms. As each WaltSocial operation issues read/write requests to Walter in series, the latency is affected by the number of objects accessed by different WaltSocial operations. The read-info operation involves fewest objects and hence is faster than other operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.7">ReTwis performance</head><p>We compare the performance of ReTwis using Walter and Redis as the storage system, to assess the cost of Walter.</p><p>Workload setup. The Walter experiments involve one or two sites. Redis does not allow updates from multiple sites, so the Redis experiments involve one site. Since Redis is a semi-persistent keyvalue store optimized for in-memory operations, we configure both Walter and Redis to commit writes to memory. We run multiple front-end web servers (Apache 2.2.14 with PHP 5.3.2) and client emulators at each site. We emulate 500, 000 users who issue requests to post a message (post), follow another user (follow), or read postings in their own timeline (status). The mixed workload consists of 85% status, 7.5% post and 7.5% follow operations.</p><p>Throughput comparison. Figure <ref type="figure" target="#fig_0">23</ref> shows the aggregate throughput (Kops/s) for different workloads when running ReTwis with Walter and Redis. As can be seen, with one site, ReTwis with Walter has similar performance as ReTwis with Redis: the slowdown is no more than 25%. For example, the throughput of the post operation for Walter (1 site) is 4713 ops/s, compared to 5740 ops/s for Redis. But ReTwis with Walter can use multiple sites to scale the throughput. For example, the throughput of post using ReTwis with Walter on two sites is 9527 ops/s-twice the throughput of one site.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">RELATED WORK</head><p>Transactions in data centers. Early transactional storage for data centers include Bigtable <ref type="bibr" target="#b11">[12]</ref>, Sinfonia <ref type="bibr" target="#b3">[4]</ref>, Percolator <ref type="bibr" target="#b37">[38]</ref>, and distributed B-trees <ref type="bibr" target="#b2">[3]</ref>. Unlike Walter, these systems were designed for a single data center only.</p><p>Storage systems that span many data centers often do not provide transactions (e.g., Dynamo <ref type="bibr" target="#b15">[16]</ref>), or support only restricted transactional semantics. For example, PNUTS <ref type="bibr" target="#b13">[14]</ref> supports only one-record transactions. COPS <ref type="bibr" target="#b30">[31]</ref> provides only read-only transactions. Megastore <ref type="bibr" target="#b6">[7]</ref> partitions data and provides the ACID properties within a partition but, unlike Walter, it fails to provide full transactional semantics for reads across partitions.</p><p>Transactions in disconnected or wide-area systems. Perdis <ref type="bibr" target="#b18">[19]</ref> is an object store with a check-out/check-in model for wide-area operations: it creates a local copy of remote data (check-out) and later reconciles local changes (check-in), relying on manual repair when necessary. For systems with mobile nodes, tentative update transactions <ref type="bibr" target="#b22">[23]</ref> can commit at a disconnected node. Tentative commits may be aborted later due to conflicts when the hosts re-connect to servers, which requires reconciliation by an external user. In contrast to the above systems, Walter does not require burdensome operations for manual repair or reconciliation. Mariposa <ref type="bibr" target="#b44">[45]</ref> is a wide-area system whose main focus is on incentivizing a site to run third-party read-only queries.</p><p>Database replication. There is much work on database replication, both commercially and academically. Commercial database systems support master-slave replication across sites: one site is the primary, the others are mirrors that are often read-only and updated asynchronously. When asynchronous mirrors are writable, applications must provide logic to resolve conflicts. On the academic side, the database replication literature is extensive; here we summarize relevant recent work. Replication schemes are classified on two axes <ref type="bibr" target="#b22">[23]</ref>: (1) who initiates updates (primary-copy vs update-anywhere), and (2) when updates propagate (eager vs lazy). With primary-copy, objects have a master host and only the master initiates updates; with update-anywhere, any host may initiate updates. With eager replication, updates propagate to the replicas before commit; with lazy replication, replicas receive updates asynchronously after commit. All four combinations of these two dimensions are possible. Eager replication is implemented using distributed two-phase commit <ref type="bibr" target="#b8">[9]</ref>. Later work considers primarycopy lazy replication and provides serializability by restricting the placement of each object's primary <ref type="bibr" target="#b12">[13]</ref>, or controlling when secondary nodes are updated <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b35">36]</ref>. Update-anywhere lazy replication is problematic because conflicting transactions can commit concurrently at different replicas. Thus, recent work considers hybrids between eager and lazy replication: updates propagate after commit (lazy), but replicas also coordinate during transaction execution or commit to deal with conflicts (eager). This coordination may involve a global graph to control conflicts <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b10">11]</ref>, or atomic broadcast to order transactions <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b36">37]</ref>. Later work considers snapshot isolation as a more efficient alternative to serializability <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b51">52]</ref>. Walter differs from the above works because they ensure a stronger isolation property-serializability or snapshot isolation-which inherently requires coordination across sites to commit, whereas Walter commits common transactions without such coordination.</p><p>Federated transaction management considers techniques to execute transactions that span multiple database systems <ref type="bibr" target="#b40">[41]</ref>. This work differs from Walter because it does not consider issues involving multiple sites and its main concern is to minimize changes to database systems, rather than avoiding coordination across sites.</p><p>Relaxed consistency. Some systems provide weaker consistency, where concurrent updates cause diverging versions that must be reconciled later by application-specific mechanisms <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b46">47]</ref>. Eventual consistency permits replicas to diverge but, if updates stop, replicas eventually converge again. Weak consistency may be tolerable <ref type="bibr" target="#b48">[49]</ref>, but it can lead to complex application logic. Inconsistency can also be quantified and bounded <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b53">54]</ref>, to improve the user experience. Fork consistency <ref type="bibr" target="#b32">[33]</ref> allows the observed operation history to fork and not converge again; it is intended for honest clients to detect the misbehavior of malicious servers rather than to provide efficient replication across sites.</p><p>Commutative data types. Prior work has shown how to exploit the semantics of data types to improve concurrency. In <ref type="bibr" target="#b49">[50]</ref>, abstract data types (such as sets, FIFO queues, and a bank account) are characterized using a table of commutativity relations where two operations conflict when they do not commute. In <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b41">42]</ref>, a lock compatibility table is used to serialize access to abstract data types, such as directory, set or FIFO queue, by exploiting the commutativity of their operations. Because these works aim to achieve serializability, not all operations on a set object are conflict-free (e.g., testing the membership of element a conflicts with the insertion of a in the set). As a result, operating on sets require coordination to check for potential conflicts. In contrast, since we aim to achieve the weaker PSI property, operations on Walter's cset objects are always free of conflicts, allowing each data center to read and modify these csets without any remote coordination.</p><p>Letia et al. <ref type="bibr" target="#b28">[29]</ref> have proposed the use of commutative replicated data types to avoid concurrency control and conflict resolution in replicated systems. Their work has inspired our use of csets. Subsequent recent work <ref type="bibr" target="#b42">[43]</ref> provides a theoretical treatment for such data types and others-which are together called conflict-free replicated data types or CRDTs-proposing sufficient conditions for replica convergence under a newly-defined strong eventual consistency model. While that work concerns replication of single operations/objects at a time, not transactions, one could imagine using general CRDTs with PSI and our protocols to replicate transactions efficiently. U-sets <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b52">53]</ref> are a type of set in which commutativity is achieved by preventing a removed element from being added again. In contrast, csets achieve commutativity by augmenting elements with counts. Csets are similar to Z-relations <ref type="bibr" target="#b24">[25]</ref>, which are mappings from tuples to integers, used to allow for decidability of equivalence of queries in the context of query optimization.</p><p>Escrow transactions <ref type="bibr" target="#b34">[35]</ref> update numeric data, such as account balances, by holding some amount in escrow to allow concurrent commutative updates. By exploiting commutativity, such transactions resemble transactions with csets, but they differ in two ways. First, escrow transactions operate on numeric data. Second, escrow transactions must coordinate among themselves to check the amounts in escrow, which does not serve our goal of avoiding coordination across distant sites.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">CONCLUSION</head><p>Walter is a transactional geo-replicated key-value store with properties that make it appealing as the storage system for web ap-plications. A key feature behind Walter is Parallel Snapshot Isolation (PSI), a precisely-stated isolation property that permits asynchronous replication across sites without the need for conflict resolution. Walter relies on techniques to avoid conflicts across sites, thereby allowing transactions to commit locally in a site. PSI thus permits an efficient implementation, while also providing strong guarantees to applications. We have demonstrated the usefulness of Walter by building a Facebook-like social networking application and porting a third-party Twitter clone. Both applications were simple to implement and achieved reasonable performance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: Transaction outcome in snapshot isolation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>51 ,</head><label>51</label><figDesc>Page 362]: SI PROPERTY 1. (Snapshot Read) All operations read the most recent committed version as of the time when the transaction began. SI PROPERTY 2. (No Write-Write Conflicts) The write sets of each pair of committed concurrent transactions must be disjoint.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Specification of PSI. function chooseOutcome(x)if some write-conflicting transaction has committed at site(x) after x started or is currently propagating to site(x) // text has definition of "propagating" then return ABORTED else if some write-conflicting transaction has aborted after x started or is currently executing then return (either ABORTED or COMMITTED ) else return COMMITTED</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Figure 5: Transaction outcome in PSI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Set operations in PSI specification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>T 1 T 2 T 3</head><label>123</label><figDesc>reads here</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>T 1 T 3 T 2</head><label>132</label><figDesc>reads here T 4 reads here T 5 reads here Conflicting fork. Transactions make concurrent conflicting updates causing the state to fork in a way that requires application-specific or ad-hoc rules to merge back. Example. Initially A=0. T1 writes A←1 and commits. Concurrently, T2 writes A←2 and commits. Some external logic determines that the value of A should be 3, and subsequently T3 reads A=3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Anomalies allowed by each isolation property.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Variables at server on each site.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Fast commit.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Slow commit.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Transaction replication.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Basic C++ API for Walter and C++ and PHP examples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: Transaction for befriend operation in WaltSocial.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 16 :Figure 17 :</head><label>1617</label><figDesc>Figure 16: Base read and write transaction throughput.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 18 :</head><label>18</label><figDesc>Figure 18: Fast commit latency on EC2 and our private cluster.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 19 :</head><label>19</label><figDesc>Figure 19: Replication latency for disaster-safe durability.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 20 :</head><label>20</label><figDesc>Figure 20: Latency of slow commit and replication.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 23 :</head><label>23</label><figDesc>Figure 23: Throughput of ReTwis using Redis and Walter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>A transaction reads the update made by another transaction that has not yet committed; the other transaction may later abort or rewrite the object, making the data read by the first transaction invalid. Example. Initially A=0. T1 writes A←1 and A←2 and commits; concurrently, T2 reads A=1. Non-repeatable read. A transaction reads the same object twice-once before and once after another transaction commits an update to it-obtaining different results. Example. Initially A=0. T1 writes A←1 and commits; concurrently T2 reads A=0 and then reads A=1. Lost update. Transactions make concurrent updates to some common object, causing one transaction to lose its updates. Example. Initially A=0. T1 reads A=0, writes A←1, and commits. Concurrently, T2 reads A=0, writes A←2, and commits.</figDesc><table><row><cell cols="4">Anomaly Eventual Dirty read. Short fork. Transactions make concur-Serializability Snapshot PSI</cell></row><row><cell cols="4">rent disjoint updates causing the state</cell></row><row><cell>to fork.</cell><cell cols="3">After committing, the state</cell></row><row><cell cols="2">is merged back.</cell><cell>Example.</cell><cell>Initially</cell></row><row><cell cols="4">A=B=0. T1 reads A=B=0, writes</cell></row><row><cell cols="4">A←1, and commits. Concurrently, T2</cell></row><row><cell cols="4">reads A=B=0, writes B←1, and com-</cell></row><row><cell cols="4">mits. Subsequently, T3 reads A=B=1.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>CommittedVTSi return OK operation write(x, oid, data): add oid, DATA (data) to x.updates; return OK operation setAdd(x, setid, id): add setid, ADD(id) to x.updates; return OK operation setDel(x, setid, id): add setid, DEL(id) to x.updates; return OK operation read(x, oid) if oid is locally replicated then return state of oid reflecting x.updates and all versions in History i [oid] visible to x.startVTS else return state of oid reflecting x.updates, the versions in History site(oid) [oid] visible to x.startVTS, and the versions in History i [oid] visible to x.startVTS</figDesc><table><row><cell>At Serveri:</cell><cell>/ / i denotes the site number</cell></row><row><cell>operation startTx(x)</cell><cell></cell></row><row><cell>x.tid ← unique transaction id</cell><cell></cell></row><row><cell cols="2">x.startVTS ← operation setRead(x, setid): same as read(x, oid)</cell></row><row><cell cols="2">Figure 10: Executing transactions.</cell></row><row><cell>CommittedVTSi[i] ← x.seqno</cell><cell></cell></row><row><cell>x.outcome ← COMMITTED</cell><cell></cell></row><row><cell>fork propagate(x)</cell><cell></cell></row><row><cell>else x.outcome ← ABORTED</cell><cell></cell></row><row><cell>return x.outcome</cell><cell></cell></row></table><note><p>At Serveri: / / i denotes the site number function unmodified(oid, VTS): true if oid unmodified since VTS function update(updates, version) for each oid, X ∈ updates do add X, version to History i [oid] operation commitTx(x) x.writeset ← {oid : oid, DATA ( * ) ∈ x.updates } // * is a wildcard if ∀oid ∈ x.writeset : site(oid) = i then return fastCommit(x) else return slowCommit(x) function fastCommit(x) if ∀oid ∈ x.writeset : unmodified(oid, startVTS) and oid not locked then x.seqno ← ++CurrSeqNo i // vertical bar indicates atomic region update(x.updates, i, x.seqno ) wait until CommittedVTSi[i] = x.seqno-1</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Nondeterminism in specifications allows implementations to have either behavior.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For example, suppose A=B=0 initially and transaction T1 writes A←1, transaction T2 writes B←1, and both commit concurrently. Then T1 and T2 do not conflict and can be ordered arbitrarily, so either (A=1, B=0) or (A=0, B=1) are valid snapshots for transactions to read. However, it is illegal for both snapshots to occur, because snapshot isolation either orders T1 before T2 or vice versa.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p><ref type="bibr" target="#b2">3</ref> A variant called weak snapshot isolation<ref type="bibr" target="#b14">[15]</ref> allows a transaction to remain invisible to others even after it commits, but that does not address the first issue above.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>In the PSI specification, data is replicated at every site, but an implementation need not do that, as long as it behaves identically in terms of responses to operations.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We are grateful to many people who helped us improve this work. Our shepherd Robbert van Renesse and the anonymous reviewers provided much useful feedback throughout the paper. Margo Seltzer made many suggestions on how to tune the performance of Berkeley DB. Frank Dabek, Wilson Hsieh, Frans Kaashoek, Christopher Mitchell, Rama Ramasubramanian, Mehul Shah, Chandramohan Thekkath, Michael Walfish, and Lidong Zhou provided several comments that helped us improve the presentation. This work was partially supported by NSF Award CNS-0720644.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Redis: an open-source advanced key-value store</title>
		<ptr target="http://redis.io" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://retwis.antirez.com" />
		<title level="m">A Twitter clone for the Redis key-value database</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A practical scalable distributed B-tree</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Aguilera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Golab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases</title>
		<imprint>
			<date type="published" when="2008-08">Aug. 2008</date>
			<biblScope unit="page" from="598" to="609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Sinfonia: A new paradigm for building scalable distributed systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Aguilera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Merchant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Veitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Karamanolis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="5" />
			<date type="published" when="2009-11">Nov. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Data caching issues in an information retrieval system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alonso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Barbará</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="359" to="384" />
			<date type="published" when="1990-09">Sept. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Replication, consistency, and practicality: are these mutually exclusive</title>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Breitbart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Korth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wool</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
			<biblScope unit="page" from="484" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Megastore: Providing scalable, highly available storage for interactive services</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th Conference on Innovative Data Systems Research</title>
		<imprint>
			<date type="published" when="2011-01">Jan. 2011</date>
			<biblScope unit="page" from="223" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A critique of ANSI SQL isolation levels</title>
		<author>
			<persName><forename type="first">H</forename><surname>Berenson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="1995-05">May 1995</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Concurrency Control and Recovery in Database Systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Hadzilacos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Update propagation protocols for replicated databases</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Breitbart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="1999-06">June 1999</date>
			<biblScope unit="page" from="97" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Replication and consistency in a distributed environment</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Breitbart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Korth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="69" />
			<date type="published" when="1999-08">Aug. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Bigtable: A distributed storage system for structured data</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2006-11">Nov. 2006</date>
			<biblScope unit="page" from="205" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Deferred updates and data placement in distributed databases</title>
		<author>
			<persName><forename type="first">P</forename><surname>Chundi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Rosenkrantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Ravi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Data Engineering</title>
		<imprint>
			<date type="published" when="1996-02">Feb. 1996</date>
			<biblScope unit="page" from="469" to="476" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">PNUTS: Yahoo!&apos;s hosted data serving platform</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Cooper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases</title>
		<imprint>
			<date type="published" when="2008-08">Aug. 2008</date>
			<biblScope unit="page" from="1277" to="1288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Lazy database replication with snapshot isolation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Daudjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Salem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases</title>
		<imprint>
			<date type="published" when="2006-09">Sept. 2006</date>
			<biblScope unit="page" from="715" to="726" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Dynamo: Amazon&apos;s highly available key-value store</title>
		<author>
			<persName><forename type="first">G</forename><surname>Decandia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="2007-10">Oct. 2007</date>
			<biblScope unit="page" from="205" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Tashkent: Uniting durability with transaction ordering for high-performance scalable database replication</title>
		<author>
			<persName><forename type="first">S</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dropsho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Computer Systems</title>
		<imprint>
			<date type="published" when="2006-04">Apr. 2006</date>
			<biblScope unit="page" from="117" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Tashkent+: Memory-aware load balancing and update filtering in replicated databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dropsho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Computer Systems</title>
		<imprint>
			<date type="published" when="2007-03">Mar. 2007</date>
			<biblScope unit="page" from="399" to="412" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Perdis: design, implementation, and use of a persistent distributed store</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ferreira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recent Advances in Distributed Systems</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000-02">Feb. 2000</date>
			<biblScope unit="volume">1752</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Using semantic knowledge for transaction processing in a distributed database</title>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="186" to="213" />
			<date type="published" when="1983-06">June 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The Google file system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gobioff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-T</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="2003-10">Oct. 2003</date>
			<biblScope unit="page" from="29" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Brewer&apos;s conjecture and the feasibility of consistent, available, partition tolerant web services</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGACT News</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="51" to="59" />
			<date type="published" when="2002-06">June 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The dangers of replication and a solution</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Helland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>O'neil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="1996-06">June 1996</date>
			<biblScope unit="page" from="173" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Transaction processing: concepts and techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Reuter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Morgan Kaufmann Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Reconcilable differences</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Digital Telecommunications</title>
		<imprint>
			<date type="published" when="2009-03">Mar. 2009</date>
			<biblScope unit="page" from="212" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Relaxed currency and consistency: How to say &quot;good enough&quot; in SQL</title>
		<author>
			<persName><forename type="first">H</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="2004-06">June 2004</date>
			<biblScope unit="page" from="815" to="826" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A new approach to developing and implementing eager database replication protocols</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kemme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="333" to="379" />
			<date type="published" when="2000-09">Sept. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Petal: Distributed virtual disks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">K</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Thekkath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<imprint>
			<date type="published" when="1996-10">Oct. 1996</date>
			<biblScope unit="page" from="84" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Consistency without concurrency control in large, dynamic systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Letia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Large Scale Distributed Systems and Middleware</title>
		<imprint>
			<date type="published" when="2009-10">Oct. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Middleware based data replication providing snapshot isolation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kemme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Martínez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jiménez-Peris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="2005-06">June 2005</date>
			<biblScope unit="page" from="419" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Don&apos;t settle for eventual: Stronger consistency for wide-area storage with cops</title>
		<author>
			<persName><forename type="first">W</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaminsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Andersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="2011-10">Oct. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Distributed Algorithms</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Morgan Kaufmann Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Building secure file systems out of byzantine storage</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Distributed Computing</title>
		<imprint>
			<date type="published" when="2002-07">July 2002</date>
			<biblScope unit="page" from="108" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Exploiting weak connectivity for mobile file access</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">B</forename><surname>Mummert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Eblig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="1995-12">Dec. 1995</date>
			<biblScope unit="page" from="143" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The escrow transactional method</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>O'neil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="405" to="430" />
			<date type="published" when="1986-12">Dec. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Fast algorithms for maintaining replica consistency in lazy master replicated databases</title>
		<author>
			<persName><forename type="first">E</forename><surname>Pacitti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Minet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Simon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases</title>
		<imprint>
			<date type="published" when="1999-09">Sept. 1999</date>
			<biblScope unit="page" from="126" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">MIDDLE-R: Consistent database replication at the middleware level</title>
		<author>
			<persName><forename type="first">M</forename><surname>Patino-Martinez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jiménez-Peris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kemme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="375" to="423" />
			<date type="published" when="2005-11">Nov. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Large-scale incremental processing using distributed transactions and notifications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dabek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2010-10">Oct. 2010</date>
			<biblScope unit="page" from="251" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Ganymed: Scalable replication for transactional web applications</title>
		<author>
			<persName><forename type="first">C</forename><surname>Plattner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Middleware Conference</title>
		<imprint>
			<date type="published" when="2004-10">Oct. 2004</date>
			<biblScope unit="page" from="155" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">FAB: building distributed enterprise disk arrays from commodity components</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Saito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<imprint>
			<date type="published" when="2004-10">Oct. 2004</date>
			<biblScope unit="page" from="48" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Federated transaction management with snapshot isolation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Schenkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Foundations of Models and Languages for Data and Objects, Transactions and Database Dynamics</title>
		<imprint>
			<date type="published" when="1999-09">Sept. 1999</date>
			<biblScope unit="page" from="1" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Synchronizing shared abstract types</title>
		<author>
			<persName><forename type="first">P</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Spector</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="223" to="250" />
			<date type="published" when="1984-08">Aug. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Conflict-free replicated data types</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Baquero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zawirski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Stabilization, Safety, and Security of Distributed Systems</title>
		<imprint>
			<date type="published" when="2011-10">Oct. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Zeno: Eventually consistent byzantine fault tolerance</title>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Maniatis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Networked Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2009-04">Apr. 2009</date>
			<biblScope unit="page" from="169" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Mariposa: a wide-area distributed database system</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases</title>
		<imprint>
			<date type="published" when="1996-01">Jan. 1996</date>
			<biblScope unit="page" from="48" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Simplifying wide-area application development with WheelFS</title>
		<author>
			<persName><forename type="first">J</forename><surname>Stribling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sovran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Pretzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Networked Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2009-04">Apr. 2009</date>
			<biblScope unit="page" from="43" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Managing update conflicts in Bayou, a weakly connected replicated storage system</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Terry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="1995-12">Dec. 1995</date>
			<biblScope unit="page" from="172" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Frangipani: A scalable distributed file system</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Thekkath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">K</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="1997-10">Oct. 1997</date>
			<biblScope unit="page" from="224" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Data access patterns in the amazon.com technology platform</title>
		<author>
			<persName><forename type="first">W</forename><surname>Vogels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases</title>
		<imprint>
			<date type="published" when="2007-09">Sept. 2007</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Commutativity-based concurrency control for abstract data types</title>
		<author>
			<persName><forename type="first">W</forename><surname>Weihl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1488" to="1505" />
			<date type="published" when="1988-12">Dec. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vossen</surname></persName>
		</author>
		<title level="m">Transactional Information Systems: Theory, Algorithms, and the Practice of Concurrency Control and Recovery</title>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Postgres-R(SI): Combining replica control with concurrency control based on snapshot isolation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kemme</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Data Engineering</title>
		<imprint>
			<date type="published" when="2005-04">Apr. 2005</date>
			<biblScope unit="page" from="422" to="433" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Efficient solutions to the replicated log and dictionart problems</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T J</forename><surname>Wuu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Distributed Computing</title>
		<imprint>
			<date type="published" when="1984-08">Aug. 1984</date>
			<biblScope unit="page" from="233" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Design and evaluation of a conit-based continuous consistency model for replicated services</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="239" to="282" />
			<date type="published" when="2002-08">Aug. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
