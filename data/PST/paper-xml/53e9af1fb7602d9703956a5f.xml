<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Set Theory for Verification: I. From Foundations to Functions *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Lawrence</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Laboratory</orgName>
								<orgName type="institution">University of Cambridge</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Set Theory for Verification: I. From Foundations to Functions *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">FE15558A38744DA999A8CF50DA075E0B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Isabelle</term>
					<term>set theory</term>
					<term>generic theorem proving</term>
					<term>Ramsey&apos;s Theorem</term>
					<term>higher-order syntax</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A logic for specification and verification is derived from the axioms of Zermelo-Fraenkel set theory. The proofs are performed using the proof assistant Isabelle. Isabelle is generic, supporting several different logics. Isabelle has the flexibility to adapt to variants of set theory. Its higher-order syntax supports the definition of new binding operators. Unknowns in subgoals can be instantiated incrementally. The paper describes the derivation of rules for descriptions, relations and functions, and discusses interactive proofs of Cantor's Theorem, the Composition of Homomorphisms challenge [9], and Ramsey's Theorem <ref type="bibr" target="#b4">[5]</ref>. A generic proof assistant can stand up against provers dedicated to particular logics.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Type theory has been highly successful in specification and verification. Higherorder logic (HOL) is the most popular form of type theory <ref type="bibr" target="#b11">[12]</ref>; consider for example Graham's correctness proofs about an SECD microprocessor <ref type="bibr" target="#b19">[20]</ref> using Gordon's HOL system <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. More recent type theories, based on the propositions-as-types principle, are being applied to the problem of deriving programs from specifications. Thompson <ref type="bibr" target="#b51">[52]</ref> presents examples using Martin-Löf Type Theory <ref type="bibr" target="#b32">[33]</ref>, while Leclerc and Paulin's work on streams <ref type="bibr" target="#b26">[27]</ref> is a typical application of the Calculus of Constructions.</p><p>Type theory contains a kind of set theory. A term p of type τ ⇒ bool represents a set, and the formula p(a) represents a ∈ p. Intersections, unions and so on are easily defined. But this is a typed set theory. Every element of p must have type τ . Lamport <ref type="bibr" target="#b25">[26]</ref> argues that types are harmful in specifications; I regard his view as unproven but deserving investigation. Set theory -the traditional, untyped version -has seldom been used for verification. An implementation of set theory could support untyped specification languages such as TLA <ref type="bibr" target="#b24">[25]</ref>.</p><p>Set theory is harder to automate than type theory. It is low-level, with strange definitions like a, b ≡ {{a}, {a, b}} and 3 ≡ {0, 1, 2}; and since it has no information hiding, it admits strange theorems like {a} ∈ a, b and 2 ∈ 3. The search space is larger in set theory than in type theory: set theory proofs need extra steps to perform type checking, and the lack of type constraints admits more terms as well-formed. Virtually all type theories satisfy strong normalization: every reduction sequence terminates in a normal form. The corresponding notion of reduction in set theory, which reduces t ∈ {x.ψ[x]} to ψ[t], admits expressions with no normal form <ref type="bibr" target="#b2">[3]</ref>. For example, {x . x ∈ x} ∈ {x . x ∈ x} reduces to itself <ref type="bibr">[10, page 295]</ref>. Type theory provers rely upon strong normalization; a set theory prover must do without this property.</p><p>Many existing set theory provers (surveyed in §11) employ domain-dependent knowledge and aim to model the reasoning methods of mathematicians. The present work aims to provide a productive environment for verification. While Part I of this paper treats familiar mathematical examples (Cantor's Theorem and Ramsey's Theorem), most of the effort in Part II <ref type="bibr" target="#b39">[40]</ref> concerns lists and other computational theories.</p><p>The implementation is based on Isabelle, a generic proof assistant <ref type="bibr" target="#b36">[37]</ref>. No other set theory prover simultaneously supports higher-order logic (HOL), Constructive Type Theory (CTT), the sequent calculus (LK), various modal logics, and the Logic for Computable Functions (LCF). Set theory, starting with the Zermelo-Fraenkel axioms (ZF), is built on Isabelle's implementation of classical first-order logic (FOL). The latter is built on Isabelle's intuitionistic first-order logic (IFOL). Figure <ref type="figure" target="#fig_0">1</ref> displays some of Isabelle's predefined object-logics; users may define new ones.</p><p>A generic theorem prover offers flexibility as logical formalisms evolve. Set theory has remained stable for decades; now variants are being proposed, such as nonwell-founded set theory <ref type="bibr" target="#b0">[1]</ref> and intuitionistic set theory (IZF) <ref type="bibr" target="#b27">[28]</ref>. Modifying a specialized set theory prover in order to support IZF would be difficult. With Isabelle, we simply copy the existing definition of ZF, modify the axioms as proposed, and base the new theory upon IFOL instead of FOL. Many IZF proofs could be obtained by modifying the corresponding ZF ones. Isabelle's generic facilities help in other ways. Its higher-order syntax handles variable-binding operators such as {x ∈ A . ψ[x]} and ιx . ψ <ref type="bibr">[x]</ref>. Its parser and pretty printer helps give these operators a readable concrete syntax. Isabelle handles axiom and theorem schemes, which abound in set theory. Isabelle's version of set theory includes derived theories of relations, functions and type constructions, which can be regarded as logics in their own right.</p><p>My work incorporates some of Noël's <ref type="bibr" target="#b31">[32]</ref>. Noël proved a large collection of examples by proof checking, demonstrating that Isabelle could cope with set theory. My contribution is to greatly improve Isabelle's level of automation, and to derive a theory that can serve as a platform for verifications.</p><p>This paper can be seen as an extended introduction to Isabelle. It describes how a logic is defined, how theorems are proved, and how theories are developed. Part I of the paper derives a computational logic inspired by Martin-Löf Type Theory <ref type="bibr" target="#b32">[33]</ref>. Part II continues the development to handle recursion <ref type="bibr" target="#b39">[40]</ref>.</p><p>Part I proceeds as follows. The next two sections introduce Isabelle and axiomatic set theory. Further sections sketch the Isabelle development of basic concepts such as relations and functions. Next come interactive proofs of three small examples: ordered pairing, Cantor's Theorem, and the Composition of Homomorphisms challenge <ref type="bibr" target="#b8">[9]</ref>. Ramsey's Theorem, a more realistic example, permits a comparison between Isabelle and other theorem provers <ref type="bibr" target="#b4">[5]</ref>. The remaining sections discuss related work and draw conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Isabelle</head><p>Here is a brief survey of Isabelle. For more information, please see the documentation <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b38">39]</ref>. Elsewhere <ref type="bibr" target="#b34">[35]</ref> I discuss how to formalize object-logics in the meta-logic, and how to prove that the formalization is correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The meta-logic</head><p>Isabelle works directly with schematic inference rules of the form [[φ 1 ; . . . ; φ n ]] =⇒ φ.</p><p>Rules are combined by a generalization of Horn clause resolution. Theorems are proved not by refutation, but in the affirmative. Joining rules by resolution constructs a proof tree, whose root is the conclusion.</p><p>Such rules are theorems of Isabelle's meta-logic, which is a fragment of intuitionistic higher-order logic. The φ i are formulae of the meta-logic, and are called propositions. Atomic propositions assert judgements of an object-logic, such as 'P is true', 'A is a well-formed type', or 'a has type A'. These typically involve user-declared predicates. Propositions are combined by the meta-level connectives =⇒, and ≡.</p><p>The connective =⇒ is meta-implication. It expresses entailment in rules, including assumption discharge for natural deduction. The notation [[φ 1 ; . . .</p><formula xml:id="formula_0">; φ n ]] =⇒ φ abbreviates φ 1 =⇒ (• • • =⇒ (φ n =⇒ φ) • • •).</formula><p>The connective is the meta-level universal quantifier. It expresses generality in rules. Locally -bound variables represent eigenvariables, formalizing the 'x not free in . . .' provisos typical of quantifier rules <ref type="bibr" target="#b34">[35]</ref>. Outermost -bound variables are schematic, although such quantifiers are usually dropped.</p><p>The connective ≡ is meta-equality. It expresses definitions.</p><p>The meta-logic includes a rule for ≡, which expands definitions explicitly. Although there are separate rules for =⇒ and , these connectives are also 'hard-wired' into Isabelle's resolution rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Variable binding</head><p>Expressions in the meta-logic are typed λ-terms, and λ-abstraction handles an object-logic's quantifiers and other variable-binding operators. Let us distinguish between substitution and application. Writing P [x] emphasizes the free occurrences of the variable x in P ; in this context, P [t] stands for the result of substituting t for x in P . On the other hand, P (t) simply stands for the application of P to t in Isabelle's λ-calculus. For P (t) to be well-typed, P must have type σ ⇒ τ and t must have type σ. In short, P [t] stands for substitution while P (t) stands for application. Because Isabelle reduces (λx . P [x])(t) to P [t], Isabelle theory definitions can express substitution by application. In Isabelle's set theory, where i is the type of sets and o is the type of formulae, the quantifiers could be declared where P is a variable of type i ⇒ o, standing for any unary property of sets. This paper writes ∀ x∈A . P (x) instead of Ball(A, P ) below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Basic proof methods</head><p>Isabelle uses higher-order unification <ref type="bibr" target="#b21">[22]</ref>, rather than ordinary unification, to find unifiers in the typed λ-calculus. Higher-order unification is undecidable in the general case but works well on the simpler cases that arise in practice. In particular, it handles quantifier reasoning <ref type="bibr" target="#b34">[35]</ref>. Unknowns may be shared among subgoals and may be instantiated incrementally.</p><p>For backward proof, a rule of the form [[φ 1 ; . . . ; φ n ]] =⇒ φ can represent a proof state; the ultimate goal is φ and the subgoals still unsolved are φ 1 , . . . , φ n . An initial proof state has the form φ =⇒ φ, with one subgoal, and a final proof state has the form φ, with no subgoals. The final proof state is itself the desired theorem.</p><p>Tactics are functions that transform proof states. A backward proof proceeds by applying tactics in succession to the initial state, reaching a final state. The tactic resolve_tac performs Isabelle's version of Horn clause resolution; it attempts to unify the conclusion of some inference rule with a subgoal, replacing it by the rule's instantiated premises. This is proof checking.</p><p>With derived rules, even proof checking can be effective. For example, three derived rules express that A ∩ B is the greatest lower bound of A and B:</p><formula xml:id="formula_1">A ∩ B ⊆ A A∩ B ⊆ B C ⊆ A C ⊆ B C ⊆ A ∩ B</formula><p>Another derived rule states that the ℘ operator, where ℘(A) is the set of all subsets of A, is monotonic:</p><formula xml:id="formula_2">A ⊆ B ℘(A) ⊆ ℘(B)</formula><p>These derived rules yield a simple proof of ℘(A ∩ B) ⊆ ℘(A) ∩ ℘(B); try it. In Isabelle, derived rules are indistinguishable in use from primitive ones.<ref type="foot" target="#foot_0">2</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Automated reasoning</head><p>Each tactic maps a proof state to a lazy list of possible next states. Backtracking is therefore possible and tactics can implement search strategies such as depth-first, best-first and iterative deepening. Tacticals are operators for combining tactics. They typically express control structures, ranging from basic sequencing to search strategies. Isabelle provides several powerful, generic tools:</p><p>• The classical reasoner applies naïve heuristics to prove theorems in the style of the sequent calculus. Despite its naïveté, it can prove nearly all of Pelletier's graded problems short of Schubert's Steamroller <ref type="bibr" target="#b40">[41]</ref>. As an interactive tool it is invaluable. It is not restricted to first-order logic, but exploits any natural deduction rules. It can prove several key lemmas for Ramsey's Theorem <ref type="bibr" target="#b4">[5]</ref>.</p><p>• The simplifier applies rewrite rules to a goal, then attempts to prove the rewritten goal using a user-supplied tactic. A conditional rewrite rule is applied only if recursive simplification proves the instantiated condition. Contextual information is also used, rewriting</p><formula xml:id="formula_3">x = t → ψ[x] to x = t → ψ[t].</formula><p>Rewriting works not just for equality, but for any reflexive/transitive relation enjoying congruence laws. Used with the classical reasoner, it can prove Boyer et al.'s challenge problem, that the composition of homomorphisms is a homomorphism <ref type="bibr" target="#b8">[9]</ref>.</p><p>Isabelle does not find proofs automatically. Proofs require a skilled user, who must decide which lemmas to prove and which tools to apply. If no tool is appropriate, proof checking is always available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Set theory</head><p>Axiomatic set theory was developed in response to paradoxes such as Russell's. Sets could not be arbitrary collections of the form {x . φ[x]}, pulled out of a hat. They had to be constructed, starting from a few given sets. Operations for constructing new sets included union, powerset and replacement. Replacement is the most powerful set constructor. Its parameters are a set A and a binary predicate φ(x, y) such that</p><formula xml:id="formula_4">∀ x∈A . ∀y z . φ(x, y) ∧ φ(x, z) → y = z.</formula><p>(We say that φ is single-valued for x in A.) Replacement yields the image of A under the predicate φ: there exists a set B, depending upon A and φ, such that</p><formula xml:id="formula_5">b ∈ B ↔ (∃ x∈A . φ(x, b)). The Isabelle formalization declares a constant R of type [i, [i, i] ⇒ o] ⇒ i; the replacement axiom concludes b ∈ R(A, φ) ↔ (∃ x∈A . φ(x, b)).</formula><p>The predicate φ typically has the form λx y . P ; thus R is a binding operator.</p><p>Replacement entails the principle of Separation. Let A be a set and ψ[x] a unary predicate. Separation yields a set, written {x ∈ A . ψ[x]}, consisting of those elements of A that satisfy ψ:</p><formula xml:id="formula_6">a ∈ {x ∈ A . ψ[x]} ↔ a ∈ A ∧ ψ[a]</formula><p>The class {x . ψ[x]} is an unrestricted collection of sets. Every set B is a class, namely {x . x ∈ B}. Many classes are too big to be sets, such as the universal class, V ≡ {x . x = x}. If V were a set then we could obtain Russell's Paradox via Separation: define the set</p><formula xml:id="formula_7">R ≡ {x ∈ V . x ∈ x}, then R ∈ R ↔ R ∈ R.</formula><p>We could define R as a class, namely R ≡ {x . x ∈ x}, but this yields no paradox because a proper class cannot be a member of another class: R ∈ R is false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Which axiom system?</head><p>The two main axiom systems for set theory, Zermelo-Fraenkel (ZF) and Bernays-Gödel (BG), differ in their treatment of classes. In ZF, variables range over sets; classes do not exist at all, but we may regard unary predicates as classes if we like. In BG, variables range over classes, and A ∈ V states that the class A is actually a set. Although ZF and BG are similar in strength, mathematicians generally consider ZF to be the standard system for set theory [14, page iii] [50, page 327]. BG frequently requires showing that certain classes are sets; a ∈ {a} holds only if a ∈ V .</p><p>One obstacle to automating ZF is that Replacement is an infinite axiom scheme. There is no finite axiom system for ZF, if ZF is consistent <ref type="bibr">[24, page 138]</ref>. Here is a proof sketch. The Reflection Theorem implies that every finite subset of the ZF axioms has a model in ZF. Assume, for contradiction, that ZF has a finite axiom system. By the Compactness Theorem, ZF has a finite axiom system Z 0 that is a subset of the ZF axioms. By the Reflection Theorem, Z 0 has a model in ZF. Thus ZF proves the consistency of Z 0 . Now Z 0 implies the whole of ZF, so Z 0 proves the consistency of itself; this contradicts Gödel's Incompleteness Theorem.</p><p>Boyer et al. <ref type="bibr" target="#b8">[9]</ref> advocate BG because it is a finite system of axioms; Quaife <ref type="bibr" target="#b43">[44]</ref> has proved hundreds of theorems in BG, using the resolution prover Otter. But the existence of a finite axiom system is perhaps irrelevant. Saaltink's set theory proofs <ref type="bibr" target="#b46">[47]</ref> employ ZF, adopting a simple device for invoking instances of axiom schemes; a resolution prover could do the same. Quaife notes that even BG requires schematic reasoning in normal use. The key issue, then, is not finiteness of the axiom system, but schematic reasoning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Schematic reasoning in set theory</head><p>Isabelle supports schematic reasoning through its higher-order meta-logic. In the axiom of Replacement, the binary predicate φ is a variable of type [i, i] ⇒ o, which is the type of functions that map two sets to a truth value. Separation can be defined in its schematic form, where the unary predicate ψ is a variable of type i ⇒ o. Rules about Separation can be proved schematically. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The Zermelo-Fraenkel axioms in Isabelle</head><p>The ZF axioms from Suppes [51, page 238] are expressed using Isabelle's formulation of classical first-order logic. For clarity, the exposition uses standard mathematical notation rather than Isabelle's ASCII substitutes (Figure <ref type="figure">2</ref>). We begin by defining the bounded quantifiers:</p><formula xml:id="formula_8">∀ x∈A . ψ(x) ≡ ∀x . x ∈ A → ψ(x) ∃ x∈A . ψ(x) ≡ ∃x . x ∈ A ∧ ψ(x)</formula><p>Taking membership (∈) as a primitive binary relation, we define the subset relation:</p><formula xml:id="formula_9">A ⊆ B ≡ ∀ x∈A . x ∈ B</formula><p>The following axioms are standard:</p><formula xml:id="formula_10">A = B ↔ A ⊆ B ∧ B ⊆ A (Extensionality) A ∈ (C) ↔ (∃ B∈C . A ∈ B) (Union) A ∈ ℘(B) ↔ A ⊆ B (Powerset) A = ∅ ∨ (∃ x∈A . ∀ y∈x . y ∈ A) (Foundation)</formula><p>Replacement is expressed by a rule whose premise asserts that φ is single-valued:</p><formula xml:id="formula_11">∀ x∈A . ∀y z . φ(x, y) ∧ φ(x, z) → y = z b ∈ R(A, φ) ↔ (∃ x∈A . φ(x, b)) (Replacement)</formula><p>These are all the axioms apart from Infinity, which is not discussed in this paper, and Choice, which I have not used at all. Figure <ref type="figure" target="#fig_1">3</ref> presents the axioms as they appear in the actual Isabelle theory definition. The constant PrimReplace is just R, while Ball and Bex are used in the internal representation of the bounded quantifiers. The file contains many other definitions. Isabelle accepts infix and mixfix declarations for defining new notation, hiding the internal representation. The parser and pretty printer need approximately 100 lines of ML to specify the translation of set theory's binding operators and other notation shown in Figure <ref type="figure">2</ref>.</p><p>Is this Isabelle formalization faithful to ZF? I am confident that it is, although I have not proved this formally. Let us consider some of the issues.</p><p>Notation. According to Devlin <ref type="bibr">[14, page 36]</ref>, the formal language of ZF consists of first-order formulae built up from x = y and x ∈ y; the only terms are variables. The Isabelle theory defines a rich language; its Replacement notation R(A, φ) has no counterpart in most texts. Extending the language risks making the theory stronger than ZF, since it creates additional instances of axiom schemes.</p><p>But the additional notation can be eliminated. If we can replace each formula of the form x ∈ C by an equivalent formula not mentioning C, then we can eliminate all mention of C. The Union and Powerset Axioms describe how to eliminate the symbols and ℘. My Replacement Axiom, following tradition, takes single-valued(φ) as a condition; it says nothing about R(A, φ) when φ is not single-valued. We can strengthen the axiom to force R(A, φ) = ∅ in that case:</p><formula xml:id="formula_12">b ∈ R(A, φ) ↔ (∃ x∈A . φ(x, b)) ∧ single-valued(φ) (Replacement')</formula><p>This stronger Axiom shows that the notation R(A, φ) can be eliminated from all formulae and is therefore harmless. Soundness of the meta-logic. I have previously proved the correctness of Isabelle's formulation of intuitionistic first-order logic <ref type="bibr" target="#b34">[35]</ref>, exhibiting a strong correspondence between meta-level and object-level proofs. By a standard result of proof theory, any proof in Isabelle's meta-logic can be put into normal form <ref type="bibr" target="#b42">[43]</ref>. Given a normal metaproof, we can read off the corresponding object-proof. The correspondence must be shown for each inference rule of the object-logic, but the argument is similar in each case. The approach works for all rules of the same general form, whose premises may discharge assumptions and have eigenvariables. It does not work for linear, relevance and modal logics, whose rules violate the structural framework of natural deduction (for instance, by stipulating that proofs must use each assumption).</p><p>The ZF formalization extends intuitionistic FOL with the double-negation rule (to obtain classical logic) and the ZF axioms. Let us continue to use the stronger form of Replacement. The previously demonstrated correspondence <ref type="bibr" target="#b34">[35]</ref> easily accommodates these extensions; the double-negation rule is a simple example of assumption discharge, while the ZF axioms and axiom schemes are mere formulae. Semantically this may seem strange -there is a world of difference between intuitionistic FOL and set theory -but proofs in both systems share the same syntactic structure. Isabelle's approach is unconcerned with models and can even handle inconsistent object-logics. We could formalize naive set theory in Isabelle's meta-logic and expect all proofs, including Russell's Paradox, to be faithfully represented.</p><p>Pragmatics. Obviously Isabelle itself contains bugs, since it is a large unverified program. The distinction between theory and implementation is not entirely clear; for instance, the Isabelle theory of FOL includes some constants and axioms whose sole purpose is to speed rewriting. There are many such details that look harmless and are too tiresome to consider explicitly. Although I have no comprehensive correctness proof for the Isabelle version of ZF, its theoretical basis appears to be firm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Natural deduction rules for set theory</head><p>The theory above is largely in the form of logical equivalences; perhaps we could develop a transformational calculus. I prefer to derive natural deduction rules. In natural deduction, each rule introduces or eliminates some constant. Repeatedly applying such rules breaks down a formula to atomic formulae; this can be automated, yielding a proof procedure resembling those for semantic tableaux. Such a proof procedure lies at the heart of Isabelle's classical reasoner.</p><p>From the definition A ⊆ B ≡ ∀ x∈A .x ∈ B we obtain introduction and elimination rules for ⊆:</p><formula xml:id="formula_13">[x ∈ A] x . . . . x ∈ B A ⊆ B (⊆I) A ⊆ B c ∈ A c ∈ B (⊆E)</formula><p>Rule (⊆I) discharges the assumption x ∈ A; it holds provided x is not free in the conclusion or other assumptions. Here and below, premises indicate such provisos by subscripting the affected variable.</p><p>From the Union axiom, we obtain introduction and elimination rules for :</p><formula xml:id="formula_14">B ∈ C A ∈ B A ∈ (C) ( I) A ∈ (C) [A ∈ X X ∈ C] X . . . . θ θ ( E)</formula><p>Rule ( E) discharges two assumptions, and has another 'not free' proviso on X.</p><p>Natural deduction rules are more compact than sequent calculus rules because they leave the context implicit: each rule mentions only the assumptions it discharges. They are certainly preferable to expanding the definitions of the constants. The style constrains the form of each rule and provides a naming convention. Binary intersection has a rather technical definition ( §7.1). Its natural deduction rules are straightforward:</p><formula xml:id="formula_15">c ∈ A c ∈ B c ∈ A ∩ B (∩I) c ∈ A ∩ B c ∈ A (∩E1) c ∈ A ∩ B c ∈ B (∩E2)</formula><p>For instance, A ∩ B = B ∩ A has a simple proof using these rules. Schmidt <ref type="bibr" target="#b48">[49]</ref> also advocates natural deduction in set theory. Isabelle uses natural deduction rules for reasoning backwards from the goal and for reasoning forwards from the assumptions. The rules (⊆I) and (⊆E) are formalized as the following theorems of Isabelle's meta-logic. In (⊆I), observe the use of to introduce an eigenvariable, and the use of =⇒ to discharge an assumption <ref type="bibr" target="#b34">[35]</ref>.</p><formula xml:id="formula_16">( x . x ∈ A =⇒ x ∈ B) =⇒ A ⊆ B (⊆I) [[A ⊆ B; c ∈ A]] =⇒ c ∈ B (⊆E)</formula><p>In Isabelle's ASCII syntax, they look like this:</p><formula xml:id="formula_17">(!!x.x:A ==&gt; x:B) ==&gt; A &lt;= B [| A &lt;= B; c:A |] ==&gt; c:B</formula><p>The Isabelle version of ZF derives natural deduction rules for all the primitives of set theory, including all the rules shown in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">From Replacement to Separation</head><p>Replacement is powerful but cumbersome. This section discusses three simpler forms of Replacement. The first is as powerful as the original, but facilitates reasoning about the single-valued property. The other two are special cases of Replacement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">A simpler single-valued property</head><p>The introduction and elimination rules for b ∈ R(A, φ) both require an additional premise stating that φ is single-valued. Defining a new form of Replacement reduces this proof burden. If φ(x, y) is a binary predicate, then let</p><formula xml:id="formula_18">φ (x, y) ≡ (∃!z . φ(x, z)) ∧ φ(x, y).</formula><p>Since ∃!z . φ(x, z) means there exists a unique z such that φ(x, z), the definition ensures that φ (x, y) is single-valued. Moreover, if φ(x, y) is already single-valued then the two predicates are equivalent. Isabelle expresses φ in terms of φ using meta-level λ-abstraction; we may define the new form of Replacement (with a nice notation) by</p><formula xml:id="formula_19">{y . x ∈ A, φ(x, y)} ≡ R(A, λx y . (∃!z . φ(x, z)) ∧ φ(x, y)).</formula><p>We easily obtain the equivalence</p><formula xml:id="formula_20">b ∈ {y . x ∈ A, φ(x, y)} ↔ (∃ x∈A . φ(x, b) ∧ (∀y . φ(x, y) → y = b)).</formula><p>This equivalence is unconditional. It never asks whether φ(x, y) is single-valued for all x in A, only for some value of x such that φ(x, b).</p><p>Using the new definition, we derive natural deduction rules. The introduction rule includes a simplified premise about the single-valued property. The elimination rule requires no such premise; on the contrary, it discharges an assumption involving this property. (The assumption, omitted below for clarity, is ∀y .</p><formula xml:id="formula_21">φ(x, y) → y = b.) a ∈ A φ(a, b) [φ(a, y)] y . . . . y = b b ∈ {y . x ∈ A, φ(x, y)} (RI) b ∈ {y . x ∈ A, φ(x, y)} [x ∈ A φ(x, b)] x . . . . θ θ (RE)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Functional Replacement</head><p>Suppose that f is a unary operator on sets -not a set-theoretic function, which is a set of pairs, but a meta-level function such as ℘ or . Since the predicate φ(x, y)</p><formula xml:id="formula_22">≡ (y = f (x)) is obviously single-valued, define {f (x) . x ∈ A} ≡ {y . x ∈ A, y = f (x)}.</formula><p>This form of Replacement illustrates why single-valued predicates are sometimes called class functions. Isabelle can express meta-level functions by abstraction in its typed λ-calculus. Functional replacement, with the basic operator, expresses a more familiar form of union:</p><formula xml:id="formula_23">x∈A B(x) ≡ ({B(x) . x ∈ A})</formula><p>The corresponding natural deduction rules are</p><formula xml:id="formula_24">a ∈ A b ∈ B(a) b ∈ ( x∈A .B(x)) ( RI) b ∈ ( x∈A .B(x)) [x ∈ A b ∈ B(x)] x . . . . θ θ ( RE)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Separation</head><p>Given a set A and a unary predicate ψ, Separation yields a set consisting of those elements of A that satisfy ψ. Separation is easily defined in terms of Replacement:</p><formula xml:id="formula_25">{x ∈ A . ψ(x)} ≡ {y . x ∈ A, x = y ∧ ψ(x)}</formula><p>The natural deduction rules have simple derivations:</p><formula xml:id="formula_26">a ∈ A ψ(a) a ∈ {x ∈ A . ψ(x)} a ∈ {x ∈ A . ψ(x)} a ∈ A a ∈ {x ∈ A . ψ(x)} ψ(a)</formula><p>Using Separation, we can define general intersection:</p><formula xml:id="formula_27">(C) ≡ {x ∈ (C) . ∀ Y ∈C . x ∈ Y }</formula><p>The empty intersection, (∅), causes difficulties. It would like to contain everything, but there is no universal set; (∅) should be undefined. But Isabelle's set theory does not formalize the notion of definedness; all terms are defined. Because (∅) = ∅, we obtain the perverse (but harmless) result (∅) = ∅.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">The Isabelle definitions</head><p>It may be instructive to see how these concepts are defined in the Isabelle theory file for ZF. First, the file declares constants for the three set formers:</p><formula xml:id="formula_28">3 Replace :: "[i, [i,i]=&gt;o] =&gt; i" RepFun :: "[i, i=&gt;i] =&gt; i" Collect :: "[i, i=&gt;o] =&gt; i"</formula><p>Later, the file defines the constants as described above (note that % is ASCII for the meta-level λ symbol):</p><p>Replace_def "Replace(A,P) == PrimReplace(A, %x y. (EX!z.P(x,z)) &amp; P(x,y))" RepFun_def "RepFun(A,f) == {y . x:A, y=f(x)}" Collect_def "Collect(A,P) == {y . x:A, x=y &amp; P(x)}"</p><p>These constants suffice to express the corresponding sets, but the notation leaves much to be desired. The file therefore goes on to define a readable syntax, with translations between {x:A. ψ[x]} and Collect(A, %x.ψ[x]) for example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Deriving a theory of functions</head><p>The next developments are tightly linked. We define unordered pairs, then binary unions and intersections, and obtain finite sets of arbitrary size. Then we can define descriptions and ordered pairs. Finally, we can define Cartesian products, binary relations and functions. The resulting theory includes a sort of λ-calculus with Π and Σ types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Finite sets and the boolean operators</head><p>Unordered pairing is frequently taken as primitive, but it can be defined in terms of Replacement <ref type="bibr">[51, page 237]</ref>. Observe that ℘(℘(∅)) contains two distinct elements, ∅ and ℘(∅).</p><formula xml:id="formula_29">Upair(a, b) ≡ {y . x ∈ ℘(℘(∅)), (x = ∅ ∧ y = a) ∨ (x = ℘(∅) ∧ y = b)}</formula><p>Tedious but elementary reasoning yields the key property:</p><formula xml:id="formula_30">c ∈ Upair(a, b) ↔ (c = a ∨ c = b).</formula><p>Now we can define binary union, intersection and (while we are at it) set difference: In Isabelle, the notation {a 1 , . . . , a n } expands to cons(a 1 , . . . , cons(a n , ∅) . . .).</p><formula xml:id="formula_31">A ∪ B ≡ (Upair(A, B)) A ∩ B ≡ (Upair(A, B)) A -B ≡ {x ∈ A . x ∈ B}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Descriptions</head><p>Compared with Suppes <ref type="bibr" target="#b50">[51]</ref>, Isabelle's axioms take one liberty. They do not merely assert the existence of powersets, unions and replacements, but give them names: ℘(A), (A) and R(A, φ). There is nothing wrong with assigning notation to objects, provided they are unique, and Suppes does so informally.</p><p>By introducing these names, we gain the power to define a general description operator:</p><formula xml:id="formula_32">ιx . ψ(x) ≡ {y . x ∈ {∅}, ψ(y)}</formula><p>Observe the peculiar usage of Replacement. The formula ψ(y) is single-valued provided there exists a unique a satisfying ψ(a), and ιx . ψ(x) equals a. (If there exists no such a then ιx . ψ(x) equals ∅, although this fact matters little.) Because it demands uniqueness, ιx . ψ(x) is much weaker than Hilbert's description x . ψ(x), which embodies a strong version of the Axiom of Choice. Unique descriptions are still useful, as we shall see; their properties are summed up by two derived rules:</p><formula xml:id="formula_33">ψ(a) [ψ(x)] x . . . . x = a (ιx . ψ(x)) = a (ι=) ∃!x . ψ(x) ψ(ιx . ψ(x)) (ιI)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Ordered pairs</head><p>The Isabelle's ZF actually defines fst and snd indirectly. Following Martin-Löf's Constructive Type Theory <ref type="bibr" target="#b32">[33]</ref>, it defines the variable-binding projection split(f, p), and proves the equation</p><formula xml:id="formula_34">split(f, a, b ) = f (a, b).</formula><p>Frequently split is more convenient than the usual projections, which we define using meta-level λ-abstraction: fst(p) ≡ split(λx y . x, p) snd(p) ≡ split(λx y . y, p) Like other destructors, split is defined using a description:</p><formula xml:id="formula_35">split(f, p) ≡ ιz . ∃x y . p = x, y ∧ z = f (x, y).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Cartesian products</head><p>The set A × B consists of all pairs a, b such that a ∈ A and b ∈ B. Many authors <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b50">51]</ref> define the Cartesian product in a cumbersome manner. If a ∈ A and b ∈ B then {{a}, {a, b}} ∈ ℘(℘(A ∪ B)), so they define A × B using Separation:</p><formula xml:id="formula_36">A × B ≡ {z ∈ ℘(℘(A ∪ B)) . ∃ x∈A . ∃ y∈B . z = x, y }</formula><p>There is a historical and pedagogical case for this definition, which postpones the introduction of Replacement. But Replacement is built into our notation, so we might as well take advantage of it: </p><formula xml:id="formula_37">A × B ≡ x∈A y∈B { x,</formula><formula xml:id="formula_38">a ∈ A b ∈ B(a) a, b ∈ ( x∈A .B(x)) ( I) c ∈ ( x∈A .B(x)) [x ∈ A y ∈ B(x) c = x, y ] x,y . . . . θ θ ( E) By ( E), if a, b ∈ ( x∈A .B(x)) then a ∈ A and b ∈ B(a).</formula><p>Now A × B is nothing but an abbreviation for x∈A .B(x) when B has no dependence upon x. Isabelle's parser and pretty printer handle these conventions, using an ML function to search for occurrences of the bound variable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Relations and functions</head><p>A binary relation is a set of ordered pairs. Isabelle's set theory defines the basic operations upon relations. These operations have the usual properties and require little discussion. Observe the usage of Replacement: </p><formula xml:id="formula_39">B(x) ≡ {f ∈ ℘(Σ x∈A . B(x)) . ∀ x∈A . ∃!y . x, y ∈ f }.</formula><p>Here A → B abbreviates x∈A .B(x) when B involves no dependence upon x. In particular, we have</p><formula xml:id="formula_40">(f ∈ A → B) ↔ f ⊆ A × B ∧ (∀ x∈A . ∃!y . x, y ∈ f ).</formula><p>We further define application and λ-abstraction. An explicit application operator is necessary; f 'a operates on the sets f and a. Observe how easily a description expresses the application operator:</p><formula xml:id="formula_41">f 'a ≡ ιy . a, y ∈ f λ x∈A . b(x) ≡ { x, b(x) . x ∈ A}</formula><p>Regarding functions as binary relations requires proving many tiresome lemmas, such as</p><formula xml:id="formula_42">f ∈ ( x∈A .B(x)) a, b ∈ f ↔ a ∈ A ∧ f 'a = b</formula><p>It takes much reasoning of this sort to derive high-level rules for functions, in the style of the λ-calculus.</p><formula xml:id="formula_43">[x ∈ A] x . . . . b(x) ∈ B(x) (λ x∈A . b(x)) ∈ ( x∈A .B(x)) (λΠI) f ∈ ( x∈A .B(x)) a ∈ A f 'a ∈ B(a) (λΠE) a ∈ A (λ x∈A . b(x))'a = b(a) (β) f ∈ ( x∈A .B(x)) (λ x∈A . f'x) = f (η)</formula><p>Injections, surjections and bijections are subsets of the total function space A → B. Isabelle's set theory also defines composition of relations and functions:</p><formula xml:id="formula_44">inj(A, B) ≡ {f ∈ A → B . ∀ w∈A . ∀ x∈A . f'w = f 'x → w = x} surj(A, B) ≡ {f ∈ A → B . ∀ y∈B . ∃ x∈A . f'x = y} bij(A, B) ≡ inj(A, B) ∩ surj(A, B) r • s ≡ {w ∈ domain(s) × range(r) . ∃x y z . w = x, z ∧ x, y ∈ s ∧ y, z ∈ r}</formula><p>The numerous derived rules include</p><formula xml:id="formula_45">f ∈ bij(A, B) converse(f ) ∈ bij(B, A) f ∈ inj(A, B) a ∈ A converse(f )'(f 'a) = a s ⊆ A × B r ⊆ B × C (r • s) ⊆ A × C g ∈ A → B f ∈ B → C (f • g) ∈ A → C (r • s) • t = r • (s • t)</formula><p>Thus, relations and functions are closed under composition. A similar property is proved for injections, surjections and bijections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Examples of set-theoretic reasoning</head><p>To give some idea of the level of reasoning possible in Isabelle, we shall examine three simple examples: ordered pairing, Cantor's Theorem, and the Composition of Homomorphisms challenge <ref type="bibr" target="#b8">[9]</ref>. The sessions given below are based on polished proofs from Isabelle's set theory. I have simplified the commands to make the proofs slightly longer and easier to follow. This section, which is intended for casual reading, describes the effect of each command in general terms. For details of the many Isabelle primitives that appear, please consult the documentation <ref type="bibr" target="#b37">[38]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Injectivity of ordered pairing</head><p>Proving that a, b ≡ {{a, a}, {a, b}} is a valid definition of ordered pairing is tiresome -see Halmos [21, page 23], for example. Here is a short machine proof using Isabelle's tools. We do not see all the details of a full proof (that happens internally) but we do see the key lemma. We now state this lemma, which concerns doubletons, to Isabelle:</p><formula xml:id="formula_46">goal ZF.thy "{a,b} = {c,d} &lt;-&gt; (a=c &amp; b=d) | (a=d &amp; b=c)"; Level 0 {a,b} = {c,d} &lt;-&gt; a = c &amp; b = d | a = d &amp; b = c 1. {a,b} = {c,d} &lt;-&gt; a = c &amp; b = d | a = d &amp; b = c</formula><p>This is the initial state of a backward proof. It has one subgoal, which is the same as the main or ultimate goal. Our first inference will apply the derived rule</p><formula xml:id="formula_47">P ↔ Q Q ↔ R P ↔ R</formula><p>to let us replace {a, b} = {c, d} by any equivalent formula:</p><p>by (resolve_tac [iff_trans] 1);</p><formula xml:id="formula_48">Level 1 {a,b} = {c,d} &lt;-&gt; a = c &amp; b = d | a = d &amp; b = c 1. {a,b} = {c,d} &lt;-&gt; ?Q 2. ?Q &lt;-&gt; a = c &amp; b = d | a = d &amp; b = c</formula><p>The one subgoal has become two, and the unknown intermediate formula appears as ?Q. The first occurrence of = in the main goal is one of the rare cases when the Axiom of Extensionality is directly useful. We replace {a, b} = {c, d} by the inclusions {a, b} ⊆ {c, d} and {c, d} ⊆ {a, b}, updating ?Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>by (resolve_tac [extension] 1);</head><formula xml:id="formula_49">Level 2 {a,b} = {c,d} &lt;-&gt; a = c &amp; b = d | a = d &amp; b = c 1. {a,b} &lt;= {c,d} &amp; {c,d} &lt;= {a,b} &lt;-&gt; a = c &amp; b = d | a = d &amp; b = c</formula><p>Subgoal 1 has vanished; subgoal 2 has taken its place; ?Q has become the conjunction of inclusions. The remaining subgoal requires a massive but essentially trivial case analysis. If {a, b} ⊆ {c, d} then the rule (⊆E) states that if x ∈ {a, b} then x ∈ {c, d}; putting x = a we obtain a = c ∨ a = d, and so forth. (Halmos's proof makes a much smaller case analysis.) The classical tactic fast_tac proves the subgoal. It takes the collection of natural deduction rules proved so far, packaged as upair_cs.</p><p>by (fast_tac upair_cs 1);</p><formula xml:id="formula_50">Level 3 {a,b} = {c,d} &lt;-&gt; a = c &amp; b = d | a = d &amp; b = c</formula><p>No subgoals! This automatic step takes about eight seconds. 4 Finally, we declare the resulting theorem as the ML identifier doubleton_iff:</p><formula xml:id="formula_51">val doubleton_iff = result();</formula><p>Now we prove the main theorem, that ordered pairing is injective. While stating the goal, we make Isabelle expand the definition Pair_def: The expanded subgoal 1 is full of doubletons. We rewrite it using our lemma (FOL_ss is a collection of standard rewrite rules for first-order logic):</p><p>by (simp_tac (FOL_ss addsimps [doubleton_iff]) 1);</p><formula xml:id="formula_52">Level 1 &lt;a,b&gt; = &lt;c,d&gt; &lt;-&gt; a = c &amp; b = d 1. a = c &amp; (b = d | c = d &amp; b = d) | (a = c &amp; c = d | a = d &amp; d = c) &amp; a = c &amp; b = c &lt;-&gt; a = c &amp; b = d</formula><p>The easiest way to prove the resulting subgoal involves further case analysis. This time, fast_tac requires only the rules of first-order logic, although supplying additional rules would do no harm.</p><p>by (fast_tac FOL_cs 1);</p><formula xml:id="formula_53">Level 2 &lt;a,b&gt; = &lt;c,d&gt; &lt;-&gt; a = c &amp; b = d No subgoals!</formula><p>Given the lemma, the total time to prove this theorem is about three seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Cantor's Theorem</head><p>Cantor's Theorem is one of the few major results in mathematics that can be proved automatically. Its proof, although deep, is short. The prover TPS <ref type="bibr" target="#b1">[2]</ref> can prove it in higher-order logic, where its statement is almost trivial. Some set theory systems can prove it too <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b9">10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>goal ZF.thy "ALL f: A-&gt;Pow(A). EX S: Pow(A). ALL x:A. ~f'x=S";</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Level 0 ALL f:A -&gt; Pow(A). EX S:Pow(A). ALL x:A. ~f ' x = S 1. ALL f:A -&gt; Pow(A). EX S:Pow(A). ALL x:A. ~f ' x = S</head><p>We begin by routine rule applications, using the introduction rules for the bounded quantifiers:</p><p>by (resolve_tac [ballI] 1);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Level 1 ALL f:A -&gt; Pow(A). EX S:Pow(A). ALL x:A. ~f ' x = S 1. !!f. f : A -&gt; Pow(A) ==&gt; EX S:Pow(A). ALL x:A. ~f ' x = S</head><p>Subgoal 1 requires showing ∃ S∈℘(A) . ∀ x∈A . f'x = S under the assumption f ∈ A → ℘(A), where f is arbitrary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>by (resolve_tac [bexI] 1);</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Level 2 ALL f:A -&gt; Pow(A). EX S:Pow(A). ALL x:A. ~f ' x = S 1. !!f. f : A -&gt; Pow(A) ==&gt; ALL x:A. ~f ' x = ?S1(f) 2. !!f. f : A -&gt; Pow(A) ==&gt; ?S1(f) : Pow(A)</head><p>Under the same assumption, we now have two subgoals. The first, crucial goal involves the term ?S1(f), which is a placeholder for something that may depend upon f . Proving the subgoal instantiates this term with Cantor's diagonal set. We can prove it automatically with best_tac, a classical reasoning tactic that employs best-first search. The search space is large and undirected. We must supply best_tac with a minimal collection of rules -though some readers might regard this as cheating. There are no heuristics for set theory; the diagonal set is found simply by brute force. Many of the subgoals consist largely of logical variables, for example ?a ∈ ?A. The search resembles that reported by Bailin and Barker-Plummer <ref type="bibr" target="#b3">[4]</ref>. Starting with FOL_cs -the rules for first-order logic -we add rules for the bounded quantifiers, powersets, the subset relation, Separation and extensional equality.</p><p>by (best_tac cantor_cs 1);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Level 3 ALL f:A -&gt; Pow(A). EX S:Pow(A). ALL x:A. ~f ' x = S 1. !!f. f : A -&gt; Pow(A) ==&gt; {x: A . ~x : f ' x} : Pow(A)</head><p>After five seconds, we have obtained the diagonal set, which is {x ∈ A.x ∈ f 'x}. The remaining subgoal is to show that the diagonal set belongs to ℘(A). This is trivial; we may employ depth-first search (via fast_tac) and supply a large collection of rules (ZF_cs):</p><p>by (fast_tac ZF_cs 1);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Level 4 ALL f:A -&gt; Pow(A). EX S:Pow(A). ALL x:A. ~f ' x = S No subgoals!</head><p>Quaife <ref type="bibr">[44, page 114</ref>] remarks that Otter could not construct the diagonal set; we have just seen Isabelle do so. Indeed, we could have proved Cantor's Theorem by a single call to best_tac. However, the classical reasoner is not designed to cope with such undirected searches. Equivalent forms of Cantor's Theorem cause the search to founder, even using the minimal collection of rules cantor_cs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Composition of Homomorphisms</head><p>Boyer et al. <ref type="bibr" target="#b8">[9]</ref> posed this as a challenge problem, and supplied a hand proof involving twenty-seven lemmas in BG set theory. Proving the theorem from the axioms alone might indeed be a challenge, but I found it easy in Isabelle's ZF set theory. The proof effort took about half an hour, much of which was spent keying in and correcting the conjecture. Most of the twenty-seven lemmas were already proved in Isabelle's set theory. Five concerned proving that certain classes were sets, which is necessary in BG but not in ZF. Other lemmas were perhaps proved on-the-fly by Isabelle's simplifier. My proof required no explicit lemmas. The definition of homomorphism can be put into a more conventional notation (making the problem slightly harder!) by making hom(A, f, B, g) denote the set of all homomorphisms from A to B:</p><formula xml:id="formula_54">hom(A, f, B, g) ≡ {H ∈ A → B . (f ∈ A × A → A) ∧ (g ∈ B × B → B) ∧ (∀ x∈A . ∀ y∈A . H'(f ' x, y ) = g' H'x, H'y )}</formula><p>The contrast between the previous example and this one is clear. Cantor's Theorem is fundamental; its proof is short, but difficult to find. The proof that homomorphisms are closed under composition is straightforward, but long. The proof is mainly by rewriting, with some propositional reasoning to break up the conjunctions. We can set up simp_tac such that it calls fast_tac to prove its rewritten formulae, even when trying conditional rewrite rules; a single invocation of simp_tac proves the theorem in about forty seconds. But the proof is easier to follow if we perform it in several steps. First we state the goal, binding the definition of homomorphism to the ML identifier hom_def:</p><formula xml:id="formula_55">val [hom_def] = goal Perm.thy "(!! A f B g. hom(A,f,B,g) == \ \ {H: A-&gt;B. f:A*A-&gt;A &amp; g:B*B-&gt;B &amp; \ \ (ALL x:A. ALL y:A. H'(f'&lt;x,y&gt;) = g'&lt;H'x,H'y&gt;)}) ==&gt; \ \ J : hom(A,f,B,g) &amp; K : hom(B,g,C,h) --&gt; \ \ (K O J) : hom(A,f,C,h)";</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Level 0 J : hom(A,f,B,g) &amp; K : hom(B,g,C,h) --&gt; K O J : hom(A,f,C,h) 1. J : hom(A,f,B,g) &amp; K : hom(B,g,C,h) --&gt; K O J : hom(A,f,C,h)</head><p>Next, we expand hom_def in the subgoal:</p><p>by (rewtac hom_def);</p><formula xml:id="formula_56">Level 1 J : hom(A,f,B,g) &amp; K : hom(B,g,C,h) --&gt; K O J : hom(A,f,C,h) 1. J : {H: A -&gt; B . f : A * A -&gt; A &amp; g : B * B -&gt; B &amp; (ALL x:A. ALL y:A. H ' (f ' &lt;x,y&gt;) = g ' &lt;H ' x,H ' y&gt;)} &amp; K : {H: B -&gt; C .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>g : B * B -&gt; B &amp; h : C * C -&gt; C &amp; (ALL x:B. ALL y:B. H ' (g ' &lt;x,y&gt;) = h ' &lt;H ' x,H ' y&gt;)} --&gt; K O J :</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>{H: A -&gt; C . f : A * A -&gt; A &amp; h : C * C -&gt; C &amp; (ALL x:A. ALL y:A. H ' (f ' &lt;x,y&gt;) = h ' &lt;H ' x,H ' y&gt;)}</head><p>Next we invoke a simple tactic from the classical reasoner, in order to break up conjunctions and remove the instances of Separation: by (safe_tac ZF_cs);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Level 2 J : hom(A,f,B,g) &amp; K : hom(B,g,C,h) --&gt; K O J : hom(A,f,C,h) 1. [| J : A -&gt; B; K : B -&gt; C; f : A * A -&gt; A; g : B * B -&gt; B; g : B * B -&gt; B; ALL x:A. ALL y:A. J ' (f ' &lt;x,y&gt;) = g ' &lt;J ' x,J ' y&gt;; h : C * C -&gt; C; ALL x:B. ALL y:B. K ' (g ' &lt;x,y&gt;) = h ' &lt;K ' x,K ' y&gt; |] ==&gt; K O J : A -&gt; C 2. !!x y. [| J : A -&gt; B; K : B -&gt; C; f : A * A -&gt; A; g : B * B -&gt; B; g : B * B -&gt; B; ALL x:A. ALL y:A. J ' (f ' &lt;x,y&gt;) = g ' &lt;J ' x,J ' y&gt;; h : C * C -&gt; C; ALL x:B. ALL y:B. K ' (g ' &lt;x,y&gt;) = h ' &lt;K ' x,K ' y&gt;; x : A; y : A |] ==&gt; (K O J) ' (f ' &lt;x,y&gt;) = h ' &lt;(K O J) ' x,(K O J) ' y&gt;</head><p>Next, we collect some rewrites to supply to the simplifier. The collection need not be minimal, so we begin with ZF_ss (a standard collection of rewrite rules) and add four relevant lemmas:</p><formula xml:id="formula_57">val hom_ss =</formula><p>ZF_ss addsimps [comp_func,comp_func_apply,SigmaI,apply_type];</p><p>Subgoal 1 is one of the lemmas, namely that functions are closed under composition.</p><p>Because simplification must employ the assumptions, in particular J ∈ A → B and K ∈ B → C, the correct tactic here is asm_simp_tac:</p><p>by (asm_simp_tac hom_ss 1); </p><formula xml:id="formula_58">Level 3 J : hom(A,f,B,g) &amp; K : hom(B,g,C,h) --&gt; K O J : hom(A,f,C,h) 1. !!x</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>K ' (g ' &lt;x,y&gt;) = h ' &lt;K ' x,K ' y&gt;; x : A; y : A |] ==&gt; (K O J) ' (f ' &lt;x,y&gt;) = h ' &lt;(K O J) ' x,(K O J) ' y&gt;</head><p>Finally, we must show that K • J maps applications of f to applications of h. The simplifier applies the rewrite</p><formula xml:id="formula_59">g ∈ A → B f ∈ B → C a ∈ A (f • g)'a = f '(g'a)</formula><p>and uses the quantified assumptions about J and K as further rewrites. These rewrites are all conditional. The simplifier verifies the conditions using lemmas and the assumptions; this is essentially type checking.</p><p>by (asm_simp_tac hom_ss 1);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Level 4 J : hom(A,f,B,g) &amp; K : hom(B,g,C,h) --&gt; K O J : hom(A,f,C,h) No subgoals!</head><p>The total execution time for this proof is about seven seconds. Plaisted and Potter's system can prove this theorem in BG <ref type="bibr" target="#b41">[42]</ref>; they also use rewriting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Ramsey's Theorem in ZF</head><p>Ramsey's Theorem is a profound generalization of the pigeon-hole principle. A special case of it, the finite exponent 2 version, has become something of a benchmark for theorem provers. Basin and Kaufmann <ref type="bibr" target="#b4">[5]</ref> compare proofs of this result using the Boyer/Moore Theorem Prover (called NQTHM) and Nuprl. The theorem is an informative example because its proof is both deep and long, involving graphs, sets and natural numbers. It covers a broad spectrum of reasoning issues. It is no toy example, but a major theorem with serious applications. NQTHM and Nuprl differ in many respects. Isabelle (with ZF) is much closer to Nuprl: both support interactive, goal-directed proof using tactics and tacticals; both employ full predicate logic and some form of set theory. But Nuprl implements Martin-Löf's Constructive Type Theory rather than classical set theory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">The natural numbers in Isabelle's set theory</head><p>In set theory, the natural number n is the n-element set {0, . . . , n -1}. The companion paper will describe the construction of the set of natural numbers, and the derivation of recursion and induction. Isabelle's set theory proves many facts in elementary arithmetic. Here is a summary of the things needed for Ramsey's Theorem. The addition and subtraction operators are ⊕ and because + andstand for disjoint union and set difference, respectively. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">The definitions in ZF</head><p>Rather than attempt to improve upon Basin and Kaufmann's description of Ramsey's Theorem, I briefly discuss the corresponding definitions. I have used these largely as abbreviations, rather than as abstract notions; in most of the Isabelle proofs, the definitions are expanded.</p><p>Basin and Kaufmann's version of the theorem requires the notion of undirected graph, whose edge set E is a symmetric binary relation. Sets of unordered pairs, instead of symmetric relations, would be more in harmony with the general finite version of Ramsey's Theorem <ref type="bibr" target="#b44">[45]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Symmetric(E) ≡ ∀x y . x, y ∈ E → y, x ∈ E</head><p>Let V be a set of vertices and E a symmetric edge relation. Then C is a clique if C ⊆ V and every pair of distinct nodes in C is joined by an edge in E. Dually, I is an independent set (or anticlique) if I ⊆ V and no pair of distinct nodes in I is joined by an edge in E.</p><formula xml:id="formula_60">Clique(C, V, E) ≡ C ⊆ V ∧ (∀ x∈C . ∀ y∈C . x = y → x, y ∈ E) Indept(I, V, E) ≡ I ⊆ V ∧ (∀ x∈I . ∀ y∈I . x = y → x, y ∈ E)</formula><p>Most of my efforts went to proving results that properly belong to a theory of cardinality. The NQTHM and Nuprl proofs both represent finite sets by lists without repetitions. This representation has disadvantages: it does not handle infinite sets; many of the laws for union and intersection fail. But the cardinality of such a 'set' is simply its length and many facts can be proved by routine inductions. Isabelle's ZF (as of this writing) does not define the cardinality of a set. Fortunately, the Ramsey proof requires only the notion 'S has at least n elements.' This is equivalent to 'there is an injection from n to S' because the natural number n has n elements:</p><formula xml:id="formula_61">Atleast(n, S) ≡ ∃f . f ∈ inj(n, S)</formula><p>Finally, we define a predicate for Ramsey numbers:</p><formula xml:id="formula_62">Ramsey(n, i, j) ≡ ∀V E . Symmetric(E) ∧ Atleast(n, V ) → (∃C . Clique(C, V, E) ∧ Atleast(i, C)) ∨ (∃I . Indept(I, V, E) ∧ Atleast(j, I))</formula><p>Now Ramsey's Theorem is easily stated:</p><formula xml:id="formula_63">i ∈ nat j ∈ nat ∃ n∈nat Ramsey(n, i, j) Originally I defined Graph(V, E) ≡ (E ⊆ V × V ) ∧ Symmetric(E)</formula><p>and put Graph(V, E) instead of Symmetric(E) in the definition of Ramsey, but this was a needless complication. Since E is universally quantified, the assertion holds for all E, including those such that E ⊆ V × V .</p><p>All the lemmas proved for Ramsey's Theorem -except five that have been moved to the general library -are discussed below. Many are proved automatically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">Cliques and independent sets</head><p>The classical reasoner (fast_tac) proves these four facts automatically, taking half a second in total.</p><p>Clique(∅, V, E) Indept(∅, V, E)</p><formula xml:id="formula_64">Clique(C, V , E) V ⊆ V Clique(C, V, E) Indept(I, V , E) V ⊆ V Indept(I, V, E)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4">Cardinality</head><p>The classical reasoner automatically proves (in under two seconds) that every set has at least zero elements: Atleast(0, A)</p><p>A useful rule for induction steps is derived by six explicit rule applications:</p><formula xml:id="formula_65">Atleast(succ(m), A) ∃ x∈A . Atleast(m, A -{x})</formula><p>A property of subsets has a short proof, using a related fact about injections:</p><formula xml:id="formula_66">Atleast(n, A) A ⊆ B Atleast(n, B)</formula><p>This rule for adding an element to a set (cons) is proved by five rule applications:</p><formula xml:id="formula_67">Atleast(m, B) b ∈ B Atleast(succ(m), cons(b, B))</formula><p>Using fast_tac and the previous two results quickly yields</p><formula xml:id="formula_68">Atleast(m, B -{x}) x ∈ B Atleast(succ(m), B)</formula><p>The following theorem is the pigeon-hole principle for two pigeon-holes. Proving it took up most of the time I devoted to Ramsey's Theorem. The proof involves induction on m and n with several case analyses; it consists of a complex mixture of proof checking with the tools fast_tac and asm_simp_tac.</p><formula xml:id="formula_69">m ∈ nat n ∈ nat Atleast(m ⊕ n, A ∪ B) Atleast(m, A) ∨ Atleast(n, B)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.5">Ramsey's Theorem: the inductive argument</head><p>Ramsey's Theorem requires a double induction. Using previous lemmas, fast_tac proves the two base cases automatically (taking under two seconds in total):</p><p>Ramsey(0, 0, j) Ramsey(0, i, 0)</p><p>Before we can tackle the induction step, we must prove three lemmas. The first is an instance of the pigeon-hole principle:</p><formula xml:id="formula_70">Atleast(m ⊕ n, A) m ∈ nat n ∈ nat Atleast(m, {x ∈ A . ¬P (x)}) ∨ Atleast(n, {x ∈ A . P (x)})</formula><p>The next two lemmas contain the key idea of Ramsey's Theorem. One gives a method of extending a certain independent set of size j to one of size succ(j); the other gives a similar method for cliques. Using the definitions of Symmetric, Indept, and Clique, the standard rules (ZF_cs), and a lemma above concerning Atleast, fast_tac proves both theorems automatically! Each proof takes over half a minute, accounting for most of the CPU time in the entire proof.</p><p>Symmetric(E) Indept(I, {z ∈ V -{a} . a, z ∈ E}, E) a ∈ V Atleast(j, I) Indept(cons(a, I), V, E) ∧ Atleast(succ(j), cons(a, I))</p><formula xml:id="formula_71">Symmetric(E) Clique(C, {z ∈ V -{a} . a, z ∈ E}, E) a ∈ V Atleast(j, C) Clique(cons(a, C), V, E) ∧ Atleast(succ(j), cons(a, C))</formula><p>The induction step of Ramsey's Theorem is tedious, even with all the lemmas. The proof involves a four-way case split, with many explicit rule applications as well as invocations of the classical reasoner:</p><p>Ramsey(m, succ(i), j) Ramsey(n, i, succ(j)) m ∈ nat n ∈ nat Ramsey(succ(m ⊕ n), succ(i), succ(j))</p><p>Finally, we prove the Theorem itself. This involves performing the double induction, invoking lemmas for the base cases and induction step:</p><p>i ∈ nat j ∈ nat ∃ n∈nat Ramsey(n, i, j)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.6">Discussion and comparison</head><p>The induction step and base cases constitute a Prolog program for Ramsey(n, i, j), which we may express in a functional style: r(0, j) = 0 r(i, 0) = 0 r(i + 1, j + 1) = r(i + 1, j) + r(i, j + 1) + 1 Since r(i, j) computes a number n satisfying Ramsey(n, i, j), it is called the witnessing function for Ramsey's Theorem. Basin and Kaufmann <ref type="bibr" target="#b4">[5]</ref> obtain slightly different Ramsey numbers; the definitions reflect details of the proofs.</p><p>Nuprl expresses Ramsey's Theorem using quantifiers, as here. Since its logic is constructive, Nuprl can extract a witnessing function from the proof. NQTHM lacks quantifiers; it expresses Ramsey's Theorem in terms of a witnessing function, obtained from a hand proof. Both the Nuprl and NQTHM proofs involve additional witnessing functions, which map a graph of sufficient size to a clique or independent set. The Isabelle proof follows the same reasoning as Basin and Kaufman's proofs; it does not make essential use of classical logic. Because it is conducted in classical ZF set theory, there is no way of extracting such witnessing functions from the proof.</p><p>The The figures for Isabelle include all the definitions and lemmas given above, and their proofs; they exclude the five lemmas that were moved to the general library. The Isabelle proof has the fewest definitions and lemmas. But NQTHM has the shortest replay time, since a Sun SPARCstation ELC is three or four times faster than a Sun 3/60. Kaufmann took seven hours to find the NQTHM proof; Basin required twenty hours, plus a further sixty for library development <ref type="bibr" target="#b4">[5]</ref>. I took about nine hours to develop the Isabelle proof, including all twenty-two original lemmas. Tokens were counted, after removal of comments, by the Unix command sed -e "s/[^A-Za-z0-9'_]/ /g" ramsey.ML | wc This counts identifiers but not symbols such as : and =, and is therefore an underestimate. It counts seven tokens in EX x:A. Atleast(m, A-{x}). Basin and Kaufmann each used different methods for counting tokens in their proofs. Figure <ref type="figure">4</ref> gives a more pessimistic impression of the token density of Isabelle proofs. One theorem is proved automatically. Another, which is the main induction step, has the second longest proof of the entire effort. The third is Ramsey's Theorem itself, with its inductions on i and j. Comparisons are difficult. There are discrepancies in the hardware, token counting methods, etc. Furthermore, each author of a proof was an expert with his system. We can hardly predict how the systems would compare if tested by novices. The proof requires familiarity with both the system and its library of theorems.</p><p>Given these reservations, what conclusions can we draw? Isabelle stands up against two extensively developed systems, despite its lack of arithmetic decision procedures and small size (about 9000 lines of Standard ML, excluding objectlogic definitions and proofs). More importantly, a generic proof assistant stands up against two systems designed for specific logics. This demonstrates the viability of generic theorem proving.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">A brief history of ZF in Isabelle</head><p>Isabelle has supported ZF set theory since its early days. My original version consisted of idiosyncratic axioms over the sequent calculus LK <ref type="bibr">[36, page 382</ref>]. Isabelle's set theory was developed only up to ordered pairs. Philippe Noël found both the axioms and the sequent calculus uncongenial. He adopted Suppes's axioms and natural deduction (then newly available). Noël went on to prove a large body of results: theorems about relations, functions, orderings, fixed points, recursion, and more <ref type="bibr" target="#b31">[32]</ref>. His priority was to develop as much mathematics as possible, not to create short and elegant proofs. Many of his proofs comprised ten, fifty or even 100 tactic steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1">The formalization of set theory</head><p>Noël generally worked by expanding definitions, which sometimes resulted in large formulae. The alternative to expanding definitions is to derive additional lemmas or rules. Deriving natural deduction rules for set theory ( §5) simplified many proofs.</p><p>The description ιx . ψ[x] is a name for the unique object a satisfying ψ[a], if such exists. Descriptions are seldom mentioned in the literature, yet they are much more convenient than direct calculations. We can define the first projection by</p><formula xml:id="formula_72">fst(p) ≡ ιx . ∃y . p = x, y instead of Noël's fst(p) ≡ ( (p)).</formula><p>The former definition is independent of the representation of ordered pairing; to show fst( a, b ) = a, we simply appeal to a previous theorem about the injectivity of a, b . The latter definition requires proving ( ({{a, a}, {a, b}})) = a. The second projection (snd) can be defined easily using ι, but otherwise requires a complex expression.</p><p>Simplifying the use of Replacement ( §6) afforded improvements to existing definitions. For instance, Noël defined the domain of a relation using Separation: domain(r) ≡ {x ∈ ( (r)) . ∃y . x, y ∈ r} Taking advantage of the simpler Replacement, I adopted domain(r) ≡ {x . w ∈ r, ∃y . w = x, y }. This is more concise, and is independent of the representation of ordered pair. <ref type="foot" target="#foot_2">5</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2">Tool development</head><p>When Noël started his work, Isabelle's simplifier and classical reasoner were crude. Noël developed a tactic that could prove many of his simpler theorems by expanding definitions <ref type="bibr" target="#b31">[32]</ref>.</p><p>Much later, I modified Isabelle's classical reasoner to be generic. I extended Isabelle with ways of controlling the instantiation of unknowns, to help prevent subgoals like t ∈ ?A from causing runaway instantiations (see §3.1). Tobias Nipkow installed his simplifier <ref type="bibr" target="#b30">[31]</ref>.</p><p>Although slower than specialized provers, Isabelle's tools are fast enough: they normally return in a few seconds. Because my proof style minimizes the expanding of definitions, defining new concepts does not make proofs slower.</p><p>Tools obviously improve user productivity; moreover, the resulting proofs are resilient. Proof checking causes brittleness: proofs 'break' (fail to replay) after the slightest change to a definition or axiom. Tools generally adapt to changes. For a striking example of resilience, recall the pigeon-hole principle:</p><formula xml:id="formula_73">m ∈ nat n ∈ nat Atleast(m ⊕ n, A ∪ B) Atleast(m, A) ∨ Atleast(n, B)</formula><p>The lemma can be strengthened: replace m ⊕ n by m ⊕ n 1, where 1 ≡ succ(0). When I did this, the previous proof (consisting of twenty-eight commands!) replayed perfectly. The nested inductions went precisely as before; the case analyses were identical. The • • • succ(0) caused no difficulties because all subgoals containing it were submitted to the simplifier, using a general collection of arithmetic rewrites. This was partly luck, but the new version of the pigeon-hole principle required only slight changes to the rest of Ramsey's Theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">Related work</head><p>Few people have applied set theory to verification. Indeed, there has been little work on proving theorems from the axioms of set theory. On the other hand, there has been much work on automating set-theoretic reasoning by specialized heuristics and algorithms. Below, I survey the main strands of research and discuss their connection with the present work. Noël's work has been discussed above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.1">Verification using axiomatic set theory</head><p>Corella's work on mechanizing set theory is closely connected with Isabelle's <ref type="bibr" target="#b12">[13]</ref>.</p><p>His proof assistant Watson embeds the Zermelo-Fraenkel axioms in higher-order logic (HOL), not first-order logic as is normally done. HOL supports the definition of variable-binding operators, as well as reasoning with axiom and theorem schemes. Isabelle uses a weak fragment of HOL for these purposes, but Watson uses full HOL. The combination of ZF and HOL contains a lot of redundancy, since HOL alone contains virtually the whole of mathematics. Watson is not generic, but perhaps could be made so; it provides strong support for notational shorthands. Watson is intended for verification and Corella demonstrates it with a small hardware proof. Saaltink is also applying axiomatic set theory to verification. The EVES theorem prover implements first-order logic, with the ZF axioms added <ref type="bibr" target="#b47">[48]</ref>. EVES seems to lack support for higher-order or schematic reasoning, but has a powerful simplifier. The EVES reducer can expand definitions and reason in various domains. EVES has a built-in mechanism for appealing to instances of axiom schemes. The EVES library <ref type="bibr" target="#b45">[46,</ref><ref type="bibr" target="#b46">47]</ref> derives a computational logic resembling Isabelle's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.2">Other proofs from the axioms of set theory</head><p>Frank M. Brown <ref type="bibr" target="#b9">[10]</ref> adopts Quine's variant of set theory, which (like BG) admits both sets and classes. Brown's prover implements first-order logic using sequent methods, and is largely domain-independent. Heuristics control the the expansion of quantifiers and definitions. This is perhaps the earliest prover to combine unification and bound variables, and to use the description ιx . ψ <ref type="bibr">[x]</ref>.</p><p>EXCHECK performs computer-aided instruction in set theory. It supports goaldirected proof checking and its resolution prover can be applied to subgoals. It can give advice and summarize proofs. EXCHECK contains considerable domain knowledge; McDonald and Suppes describe it as an expert system for set theory <ref type="bibr">[29, page 336</ref>].</p><p>Plaisted and Potter <ref type="bibr" target="#b41">[42]</ref> have generated a proof of the Composition of Homomorphisms challenge. They use a sequent-based theorem prover, coded in Prolog, and BG set theory. Their work concerns replacing predicates by their definitions without having to Skolemize quantifiers dynamically; instead, positive and negative forms of the predicate are Skolemized in a translation phase. <ref type="foot" target="#foot_3">6</ref> Their translations resemble Isabelle's natural deduction rules for set theory ( §5) -their rule for reducing the subgoal A ⊆ B is essentially (⊆I), while their rule for reducing the subgoal A ⊆ B is the contrapositive of (⊆E).</p><p>Quaife's resolution proofs in BG set theory using Otter <ref type="bibr" target="#b43">[44]</ref> are remarkable. In a classic paper, Bledsoe argued that hard theorems required domain-dependent knowledge, and that resolution was the wrong approach <ref type="bibr" target="#b5">[6]</ref>. Quaife encodes domaindependent knowledge in the form of previously proved theorems; UR-resolution ensures that they are only applied usefully. Quaife's success reflects two decades' advance in technology. It also reflects meticulous care: lemmas are sometimes stated in a technical form; weights are sometimes set. Equality reasoning using the rule A ⊆ B ∧ B ⊆ A → A = B is particularly tricky <ref type="bibr">[44, page 106</ref>]. Bledsoe's remark that resolution proofs are not "human-like" still applies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.3">Heuristics and algorithms for set-theoretic reasoning</head><p>Pastre's heuristics for set theory are based on "observation and imitation of the mathematicians' methods" <ref type="bibr" target="#b33">[34]</ref>. A graph represents the binary relations that hold within a formula. The axiomatic basis is apparently BG; some axioms are given explicitly, while others are built into the algorithms. Using its graphs, the program can perform intricate chains of reasoning.</p><p>Ontic uses a Lisp-like language for set theory expressions and proofs <ref type="bibr" target="#b15">[16]</ref>. A fragment of this language is executable. Sets, classes, and recursive functions may be defined. The ZF axioms are built into a knowledge base of facts about set theory. Ontic appeals to definitions and theorems automatically; the user never refers to them by name. The aim is to let users develop mathematics, requiring no knowledge of Ontic's inference mechanisms.</p><p>Cantone <ref type="bibr" target="#b10">[11]</ref> is one of several related papers on decision procedures for fragments of set theory. He treats propositional combinations of the formulae x = y ∪ z, x = yz, x ∈ y, x = {y} and x = ℘(y). Such decision procedures do not constitute a theorem prover for set theory, but they could be valuable components of one. In an appendix, Cantone illustrates how the decision procedures could lead to an automated proof of a theorem from topology.</p><p>Bledsoe has done much research on solving for set unknowns, finding maximal or minimal sets. An early paper <ref type="bibr" target="#b6">[7]</ref> presents examples from analysis. The work does not apply to untyped set theory -instantiations have the form {x . ψ[x]}, which need not denote a set -but rather to typed set theory. In later work, Bledsoe and Feng <ref type="bibr" target="#b7">[8]</ref> describe the method as a procedure for second-order logic. It could probably be generalized to higher-order logic.</p><p>Bailin and Barker-Plummer's Z-match rule <ref type="bibr" target="#b3">[4]</ref> finds instantiations of the form {x ∈ A . ψ[x]} for set unknowns. Their treatment of unknowns has three key features: (1) it can instantiate unknowns incrementally; (2) several subgoals may share an unknown and contribute to its instantiation; (3) a dual of Skolemization handles quantifiers. This treatment of unknowns has been invented independently twice before, in λProlog <ref type="bibr" target="#b29">[30]</ref> and Isabelle <ref type="bibr" target="#b34">[35]</ref>, two systems based on higher-order unification. λProlog is a logic programming language that can easily express theorem provers <ref type="bibr" target="#b14">[15]</ref>. Isabelle tactics using the ZF rules for Separation, such as eresolve_tac <ref type="bibr">[CollectI,</ref><ref type="bibr">CollectD1,</ref><ref type="bibr">CollectD2]</ref> have roughly the same effect as Z-match.</p><p>Bailin's unification algorithm for set theory is based on higher-order unification <ref type="bibr" target="#b2">[3]</ref>. Bailin has modified Huet's procedure <ref type="bibr" target="#b21">[22]</ref> to handle the reduction that takes t ∈ {x . ψ[x]} to ψ <ref type="bibr">[t]</ref>. Although Bailin's procedure can instantiate set variables, Bailin and Barker-Plummer <ref type="bibr" target="#b3">[4]</ref> remark that it cannot do so incrementally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.4">Comparison</head><p>Considering the proofs alone, Quaife <ref type="bibr" target="#b43">[44]</ref> and Saaltink <ref type="bibr" target="#b45">[46,</ref><ref type="bibr" target="#b46">47]</ref> have the most in common with the present paper. Both have developed set theory as far as functions, starting from the axioms. Quaife uses Otter with the BG axioms; his methods look formidable to me, but are perhaps common in the resolution world. Saaltink uses EVES with the ZF axioms; his paper <ref type="bibr" target="#b46">[47]</ref> consists mainly of commands with little commentary, but suggests a fairly high level of interaction.</p><p>Isabelle's strong point is its treatment of variable-binding operators. Recall the schematic definitions of the Replacement operators ( §6); Part II of this paper <ref type="bibr" target="#b39">[40]</ref> defines several new binding operators to handle recursion. Quaife forgoes the notation {x . ψ[x]} because Otter cannot handle it easily; he expresses classes using BG primitives in an obscure manner <ref type="bibr">[44, page 97]</ref>. Since sets of the form {x . ψ[x]} arise frequently in specifications, this is an obstacle to applying Quaife's method for verification. EVES also has difficulties with variable binding; defining a function by λ-abstraction takes half a page of commands <ref type="bibr" target="#b45">[46]</ref>. The Isabelle theory defines λ-abstraction and proves β-reduction, both schematically ( §7.5).</p><p>Ironically, Isabelle may not be suitable for BG set theory. In BG, the notation {x . ψ[x]} is not part of the formalization itself, but is a meta-notation justified by the meta-theorem of class existence. The proof is by structural induction on the formula ψ[x]. <ref type="foot" target="#foot_4">7</ref> Such meta-theorems cannot be proved in Isabelle except by explicitly formalizing the syntax of first-order logic within some other logic. We cannot even assume the class existence theorem as an additional axiom -it does not hold schematically for all formulae, only for those with no quantification over classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">Conclusions</head><p>Isabelle's version of ZF set theory, with its definitions, derived rules and tools, has reached a mature state of development. Problems can be stated in a reasonably familiar notation and approached using high-level steps.</p><p>Isabelle's set theory records roughly 1000 theorems. This paper discusses the formal development, starting from the ZF axioms, of a calculus of sets, pairs, relations and functions. The companion paper <ref type="bibr" target="#b39">[40]</ref> develops general principles for defining recursive data types, including the natural numbers -using, for the first time, the Axiom of Infinity! The resulting theory can express both specifications and computable functions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Isabelle's object logics</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The ZF axioms from the Isabelle theory file</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Finite</head><label></label><figDesc>sets are traditionally obtained as binary unions of unordered pairs. Isabelle's treatment is inspired by Lisp. Define cons(a, B) ≡ Upair(a, a) ∪ B. Thus cons(a, B) augments B with the element a; we obtain c ∈ cons(a, B) ↔ (c = a ∨ c ∈ B).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>definition a, b ≡ {{a}, {a, b}} is perhaps the most famous (or notorious) feature of set theory. Isabelle defines a, b ≡ {{a, a}, {a, b}}, which is equivalent but consists entirely of doubletons. This simplifies the proofwhich we shall examine later -of the key property a, b = c, d ↔ a = c ∧ b = d. The next step is to define the projections, fst and snd. Descriptions are extremely useful here. We could put fst(p) ≡ ιx . ∃y . p = x, y snd(p) ≡ ιy . ∃x . p = x, y To show fst( a, b ) = a by the rule (ι=), we must exhibit a unique x such that ∃y . a, b = x, y holds. Clearly x = a (with y = b) by uniqueness of pairing. The treatment of snd is similar. Descriptions are suitable for defining many other kinds of destructors, such as case analysis operators for disjoint unions, natural numbers and lists. Isabelle's classical reasoner can prove the resulting equations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>y } This definition is self-evident, independent of the underlying representation of pairs, and easy to reason about. Again, Isabelle actually defines A × B indirectly, following Martin-Löf's Type Theory. The disjoint union of a family of sets, x∈A .B(x), is a useful generalization of A × B. To generalize the definition above, we merely replace B by B(x): x∈A B(x) ≡ x∈A y∈B(x) { x, y } Natural deduction rules neatly summarize its properties:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>converse(r) ≡ {z . w ∈ r, ∃x y . w = x, y ∧ z = y, x } domain(r) ≡ {x . w ∈ r, ∃y . w = x, y } range(r) ≡ domain(converse(r)) field(r) ≡ domain(r) ∪ range(r) Image and inverse image are infix operators: r " A ≡ {y ∈ range(r) . ∃ x∈A . x, y ∈ r} r -" A ≡ converse(r)"A Functions are represented by their graphs, which are single-valued binary relations. The set of all functions from A to B is written A → B. Just as we generalized A × B to x∈A .B(x), we generalize A → B to x∈A .B(x), the product of a family of sets. This concept predates Martin-Löf's Type Theory; it has a long history. We define x∈A</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>goalw ZF.thy [Pair_def] "&lt;a,b&gt; = &lt;c,d&gt; &lt;-&gt; a=c &amp; b=d"; Level 0 &lt;a,b&gt; = &lt;c,d&gt; &lt;-&gt; a = c &amp; b = d 1. {{a,a},{a,b}} = {{c,c},{c,d}} &lt;-&gt; a = c &amp; b = d 4 All Isabelle timings are on a Sun SPARCstation ELC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>val cantor_cs = FOL_cs addSIs [ballI, CollectI, PowI, subsetI] addIs [bexI] addSEs [CollectE, equalityCE];</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>y. [| J : A -&gt; B; K : B -&gt; C; f : A * A -&gt; A; g : B * B -&gt; B; g : B * B -&gt; B; ALL x:A. ALL y:A. J ' (f ' &lt;x,y&gt;) = g ' &lt;J ' x,J ' y&gt;; h : C * C -&gt; C; ALL x:B. ALL y:B.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>to ∅, the empty set) m ⊕ n sum of the natural numbers m and n m n difference of the natural numbers m and n succ(m) the successor of m, namely m ⊕ 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>val prems = goalw Ramsey.thy [Symmetric_def,Clique_def] "[| Symmetric(E); Clique(C, {z: V-{a}. &lt;a,z&gt;:E}, E); a: V; \ \ Atleast(j,C) |] ==&gt; \ \ Clique(cons(a,C), V, E) &amp; Atleast(succ(j), cons(a,C))";</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>If P [x] is a formula (represented by a term of type o) and x is a variable of type i, then λx . P [x] has type i ⇒ o. Thus ∀(λx . P [x]) has type o, and represents the formula ∀x.P [x]. The description operator ι has type (i ⇒ o) ⇒ i; note that ιx.P [x] is a term rather than a formula. Function abstraction in set theory is represented by the constant Lambda of type [i, i ⇒ i] ⇒ i, where Lambda(A, λx . b[x]) denotes the function that returns b[a] for all a ∈ A. This paper writes λ x∈A . b[x] instead of Lambda(A, λx . b[x]) below, using the symbol λ with two distinct meanings. Isabelle's λ-calculus allows schematic definitions of variable-binding operators. Consider bounded quantification. Let Ball be a constant of type [i, i ⇒ o] ⇒ o. We may define Ball(A, P ) ≡ ∀x . x ∈ A → P (x)</figDesc><table /><note><p><p><p><p><p><p>1 </p>to have the type (i ⇒ o) ⇒ o:</p>∀, ∃ :: (i ⇒ o) ⇒ o</p>1 They actually have the polymorphic type (α ⇒ o) ⇒ o. Isabelle's type classes regulate polymorphism</p><ref type="bibr" target="#b36">[37]</ref></p>.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>table compares the NQTHM, Nuprl and Isabelle/ZF proofs:</figDesc><table><row><cell></cell><cell>NQTHM</cell><cell>Nuprl</cell><cell>Isabelle</cell></row><row><cell># Tokens</cell><cell>933</cell><cell>972</cell><cell>975</cell></row><row><cell># Definitions</cell><cell>10</cell><cell>24</cell><cell>5</cell></row><row><cell># Lemmas</cell><cell>26</cell><cell>25</cell><cell>17</cell></row><row><cell cols="3"># Replay Time 3.7 minutes 57 minutes</cell><cell>2.2 minutes</cell></row><row><cell></cell><cell>(Sun 3/60)</cell><cell cols="2">(Symbolics 3670) (SPARC ELC)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The Isabelle Logics Manual[39,  §3.9]  shows an interactive proof of ℘(A ∩ B) = ℘(A) ∩ ℘(B). This session contains the proof mentioned above; the opposite inclusion is equally elegant.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Collect has turned out to be an unfortunate name for the Separation constant -there is a variant of Replacement known as Collection.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>Unless r is known to be a binary relation, {fst(w) . w ∈ r} is not equivalent to domain(r).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>Kaufmann uses a similar approach to extend NQTHM with predicates defined by quantification<ref type="bibr" target="#b22">[23]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>See Gödel[17, pages 39-43]; Boyer et al.<ref type="bibr" target="#b8">[9]</ref> sketch the proof.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. Philippe Noël's version of set theory, modified by Martin Coen, was the starting point of the present theory. Tobias Nipkow made great contributions to Isabelle, including the simplifier. David Basin, Matt Kaufmann, Brian Monahan and Philippe Noël commented usefully on this work. Thanks are also due to Robert Boyer (the editor) and to the referees.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> *   <p>Research funded by the SERC (grants GR/G53279, GR/H40570) and by the ESPRIT Basic Research Actions 3245 'Logical Frameworks' and 6453 'Types'. Isabelle has enjoyed long-standing support from the British SERC, dating from the Alvey Programme (grant GR/E0355.7).</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>by (cut_facts_tac prems 1); by (fast_tac (ZF_cs addSEs [Atleast_succI]) 1); val Clique_succ = result(); val ram1::ram2::prems = goalw Ramsey.thy [Ramsey_def] "[| Ramsey(m,succ(i),j); Ramsey(n,i,succ(j)); m:nat; n:nat |] ==&gt; \ \ Ramsey(succ(m#+n), succ(i), succ(j))"; by (safe_tac ZF_cs); by (etac (Atleast_succD RS bexE) 1); by (eres_inst_tac [("P1","%z.&lt;x,z&gt;:E")] (Atleast_partition RS disjE) 1); by (REPEAT (resolve_tac prems 1)); (*case m*) by (rtac (ram1 RS spec RS spec RS mp RS disjE) 1); by (fast_tac ZF_cs 1); by (fast_tac (ZF_cs addEs [Clique_superset]) 1); (*we have a Clique*) by (safe_tac ZF_cs); by (eresolve_tac (swapify [exI]) 1); by (REPEAT (ares_tac [Indept_succ] 1)); (*make a bigger Indept*) (*case n*) by (rtac (ram2 RS spec RS spec RS mp RS disjE) 1); by (fast_tac ZF_cs 1); by (safe_tac ZF_cs); by (rtac exI 1); by (REPEAT (ares_tac [Clique_succ] 1)); (*make a bigger Clique*) by (fast_tac (ZF_cs addEs [Indept_superset]) 1); (*we have an Indept*) val Ramsey_step_lemma = result(); val prems = goal Ramsey.thy "i: nat ==&gt; ALL j: nat. EX n:nat. Ramsey(n,i,j)"; by (nat_ind_tac "i" prems 1); by (fast_tac (ZF_cs addSIs [nat_0_I,Ramsey00j]) 1); by (rtac ballI 1); by (nat_ind_tac "j" [] 1); by (fast_tac (ZF_cs addSIs [nat_0_I,Ramsey0i0]) 1); by (dres_inst_tac [("x","succ(j1)")] bspec 1); by (REPEAT (eresolve_tac [nat_succ_I,bexE] 1)); by (rtac bexI 1); by (rtac Ramsey_step_lemma 1); by (REPEAT (ares_tac [nat_succ_I,add_type] 1)); val ramsey = result();</p><p>Figure 4: Part of the Isabelle proof of Ramsey's Theorem</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Non-Well-Founded Sets</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Aczel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CSLI</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automating higher-order logic</title>
		<author>
			<persName><forename type="first">B</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dale</forename><forename type="middle">A</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eve</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Theorem Proving: After 25 Years</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Bledsoe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Loveland</surname></persName>
		</editor>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="169" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A λ-unifiability test for set theory</title>
		<author>
			<persName><forename type="first">Sidney</forename><forename type="middle">C</forename><surname>Bailin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="269" to="286" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Z-match: An inference rule for incrementally elaborating set instantiations</title>
		<author>
			<persName><forename type="first">Sidney</forename><forename type="middle">C</forename><surname>Bailin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dave</forename><surname>Barker-Plummer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="391" to="428" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Boyer-Moore prover and Nuprl: An experimental comparison</title>
		<author>
			<persName><forename type="first">David</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matt</forename><surname>Kaufmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logical Frameworks</title>
		<editor>
			<persName><forename type="first">Gérard</forename><surname>Huet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gordon</forename><surname>Plotkin</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="89" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Non-resolution theorem proving</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Bledsoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1" to="35" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A maximal method for set variables in automatic theoremproving</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Bledsoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Intelligence 9</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hayes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">I</forename><surname>Mikulich</surname></persName>
		</editor>
		<imprint>
			<publisher>Ellis Horwood Ltd</publisher>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="53" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">SET-VAR</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Bledsoe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="293" to="314" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Set theory in first-order logic: Clauses for Gödel&apos;s axioms</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Boyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ewing</forename><surname>Lusk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Mccune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ross</forename><surname>Overbeek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Stickel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lawrence</forename><surname>Wos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="287" to="327" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Toward the automation of set theory and its logic</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Malloy Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="281" to="316" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Decision procedures for elementary sublanguages of set theory: X. Multilevel syllogistic extended by the singleton and powerset operators</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cantone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="193" to="230" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J M</forename><surname>Claesen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J C</forename><surname>Gordon</surname></persName>
		</author>
		<title level="m">Higher Order Logic Theorem Proving and Its Applications</title>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Mechanizing set theory</title>
		<author>
			<persName><forename type="first">Francisco</forename><surname>Corella</surname></persName>
		</author>
		<idno>RC 14706 (#65927</idno>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>IBM Watson Research Center</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Fundamentals of Contemporary Set Theory</title>
		<author>
			<persName><forename type="first">J</forename><surname>Keith</surname></persName>
		</author>
		<author>
			<persName><surname>Devlin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A logic program for transforming sequent proofs to natural deduction proofs</title>
		<author>
			<persName><forename type="first">Amy</forename><surname>Felty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Extensions of Logic Programming</title>
		<editor>
			<persName><forename type="first">Peter</forename><surname>Schroeder-Heister</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">475</biblScope>
			<biblScope unit="page" from="157" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Ontic: Language specification and user&apos;s manual</title>
		<author>
			<persName><forename type="first">R</forename><surname>Givan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcallester</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Witty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zalondek</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>MIT</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>Draft 4</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The consistency of the axiom of choice and of the generalized continuum hypothesis with the axioms of set theory</title>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Gödel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Kurt Gödel: Collected Works</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Feferman</surname></persName>
		</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1940">1990. 1940</date>
			<biblScope unit="volume">II</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Why higher-order logic is a good formalism for specifying and verifying hardware</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Aspects of VLSI Design</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Milne</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Subrahmanyam</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="153" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">HOL: A proof generating system for higher-order logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLSI Specification, Verification and Synthesis</title>
		<editor>
			<persName><forename type="first">Graham</forename><surname>Birtwistle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Subrahmanyam</surname></persName>
		</editor>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="73" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">The SECD Microprocessor: A Verification Case Study</title>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">T</forename><surname>Graham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">R</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><surname>Halmos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1960">1960</date>
			<publisher>Van Nostrand</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Naive Set Theory</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A unification algorithm for typed λ-calculus</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Huet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="27" to="57" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An extension of the Boyer-Moore theorem prover to support first-order quantification</title>
		<author>
			<persName><forename type="first">Matt</forename><surname>Kaufmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="355" to="372" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Set Theory: An Introduction to Independence Proofs</title>
		<author>
			<persName><forename type="first">Kenneth</forename><surname>Kunen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The temporal logic of actions</title>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<pubPlace>Palo Alto</pubPlace>
		</imprint>
		<respStmt>
			<orgName>DEC Systems Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Types considered harmful</title>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<pubPlace>Palo Alto</pubPlace>
		</imprint>
		<respStmt>
			<orgName>DEC Systems Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>Draft</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Programming with streams in Coq. a case study: the sieve of Eratosthenes</title>
		<author>
			<persName><forename type="first">F</forename><surname>Leclerc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ch</forename><surname>Paulin-Mohring</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Types for Proofs and Programs: International Workshop TYPES &apos;93</title>
		<editor>
			<persName><forename type="first">Henk</forename><surname>Barendregt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">806</biblScope>
			<biblScope unit="page" from="191" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Realizability and recursive mathematics</title>
		<author>
			<persName><forename type="first">C</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><surname>Mccarty</surname></persName>
		</author>
		<idno>CMU-CS-84-131</idno>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
		<respStmt>
			<orgName>School of Computer Science, Carnegie-Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Student use of an interactive theorem prover</title>
		<author>
			<persName><forename type="first">James</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Suppes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Theorem Proving: After 25 Years</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Bledsoe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Loveland</surname></persName>
		</editor>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="315" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Unification under a mixed prefix</title>
		<author>
			<persName><forename type="first">Dale</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="321" to="358" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Constructive rewriting</title>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Journal</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="34" to="41" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Experimenting with Isabelle in ZF set theory</title>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Noël</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="15" to="58" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Programming in Martin-Löf&apos;s Type Theory. An Introduction</title>
		<author>
			<persName><forename type="first">Bengt</forename><surname>Nordström</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kent</forename><surname>Petersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Smith</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Automatic theorem proving in set theory</title>
		<author>
			<persName><forename type="first">Dominque</forename><surname>Pastre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The foundation of a generic theorem prover</title>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="363" to="397" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The next 700 theorem provers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lawrence</surname></persName>
		</author>
		<author>
			<persName><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName><surname>Isabelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic and Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Odifreddi</surname></persName>
		</editor>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="361" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Introduction to Isabelle</title>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
		<idno>280</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Computer Laboratory, University of Cambridge</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">The Isabelle reference manual</title>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
		<idno>283</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Computer Laboratory, University of Cambridge</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Isabelle&apos;s object-logics</title>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
		<idno>286</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Computer Laboratory, University of Cambridge</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Set theory for verification: II. Induction and recursion</title>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="167" to="215" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Seventy-five problems for testing automatic theorem provers</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Pelletier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">135</biblScope>
			<date type="published" when="1986">1986. 1988. 1997</date>
			<publisher>Errata</publisher>
		</imprint>
	</monogr>
	<note>JAR</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Term rewriting: Some experimental results</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Plaisted</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">C</forename><surname>Potter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="149" to="180" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Ideas and results in proof theory</title>
		<author>
			<persName><forename type="first">Dag</forename><surname>Prawitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second Scandinavian Logic Symposium</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Fenstad</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1971">1971</date>
			<biblScope unit="page" from="235" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Automated deduction in von Neumann-Bernays-Gödel set theory</title>
		<author>
			<persName><forename type="first">Art</forename><surname>Quaife</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="91" to="147" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Herbert</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryser</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Combinatorial Mathematics</title>
		<imprint>
			<date type="published" when="1963">1963</date>
			<publisher>Mathematical Association of America</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">The EVES library</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Saaltink</surname></persName>
		</author>
		<idno>TR-91-5449-03</idno>
	</analytic>
	<monogr>
		<title level="j">Suite</title>
		<imprint>
			<biblScope unit="volume">506</biblScope>
			<date type="published" when="1992">1992</date>
			<pubPlace>ORA Canada; Ottawa, Ontario</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>265 Carling Avanue</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">The EVES library models</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Saaltink</surname></persName>
		</author>
		<idno>TR-91-5449-04</idno>
	</analytic>
	<monogr>
		<title level="j">Suite</title>
		<imprint>
			<biblScope unit="volume">506</biblScope>
			<date type="published" when="1992">1992</date>
			<pubPlace>ORA Canada; Ottawa, Ontario</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>265 Carling Avanue</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">An EVES data abstraction example</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Saaltink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sentot</forename><surname>Kromodimoeljo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bill</forename><surname>Pase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Craigen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irwin</forename><surname>Meisels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FME &apos;93: Industrial-Strength Formal Methods</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C P</forename><surname>Woodcock</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">670</biblScope>
			<biblScope unit="page" from="578" to="596" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Natural deduction theorem proving in set theory</title>
		<author>
			<persName><forename type="first">David</forename><surname>Schmidt</surname></persName>
		</author>
		<idno>CSR-142-83</idno>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Axioms of set theory</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Shoenfield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Mathematical Logic</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Barwise</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="321" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Axiomatic Set Theory</title>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Suppes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Dover</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Type Theory and Functional Programming</title>
		<author>
			<persName><forename type="first">Simon</forename><surname>Thompson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
