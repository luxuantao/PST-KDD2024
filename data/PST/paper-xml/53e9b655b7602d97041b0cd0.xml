<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Combining Unit-level Symbolic Execution and System-level Concrete Execution for Testing NASA Software</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Corina</forename><forename type="middle">S P</forename><surname>Ȃs Ȃreanu</surname></persName>
							<email>corina.s.pasareanu@nasa.gov</email>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><forename type="middle">C</forename><surname>Mehlitz</surname></persName>
							<email>peter.c.mehlitz@nasa.gov</email>
						</author>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">H</forename><surname>Bushnell</surname></persName>
							<email>david.h.bushnell@nasa.gov</email>
						</author>
						<author>
							<persName><forename type="first">Karen</forename><surname>Gundy-Burlet</surname></persName>
							<email>karen.gundy-burlet@nasa.gov</email>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Lowry</surname></persName>
							<email>michael.r.lowry@nasa.gov</email>
						</author>
						<author>
							<persName><forename type="first">Suzette</forename><surname>Person</surname></persName>
							<email>sperson@cse.unl.edu</email>
						</author>
						<author>
							<persName><forename type="first">Mark</forename><surname>Pape</surname></persName>
							<email>mark.w.pape@nasa.gov</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">NASA Ames Research Center Moffett Field</orgName>
								<address>
									<postCode>94035-1000</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of Nebraska Lincoln</orgName>
								<address>
									<postCode>68588-0115</postCode>
									<region>NE</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">NASA Johnson Space</orgName>
								<address>
									<postCode>2101 NASA, 77058</postCode>
									<settlement>Parkway Houston</settlement>
									<region>TX</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<address>
									<settlement>Seattle, Washington</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Combining Unit-level Symbolic Execution and System-level Concrete Execution for Testing NASA Software</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2BC37CC221E357C63A8A7B96142D3FFB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Software Engineering]: Software/Program Verification; D.2.5 [Software Engineering]: Testing and Debugging Reliability</term>
					<term>Verification Symbolic Execution</term>
					<term>Software Model Checking</term>
					<term>Unit Testing</term>
					<term>System Testing</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe an approach to testing complex safety critical software that combines unit-level symbolic execution and system-level concrete execution for generating test cases that satisfy user-specified testing criteria. We have developed Symbolic Java PathFinder, a symbolic execution framework that implements a non-standard bytecode interpreter on top of the Java PathFinder model checking tool. The framework propagates the symbolic information via attributes associated with the program data. Furthermore, we use two techniques that leverage system-level concrete program executions to gather information about a unit's input to improve the precision of the unit-level test case generation.</p><p>We applied our approach to testing a prototype NASA flight software component. Our analysis helped discover a serious bug that resulted in design changes to the software. Although we give our presentation in the context of a NASA project, we believe that our work is relevant for other critical systems that require thorough testing.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Our work is motivated by an ongoing collaboration between NASA Ames and Johnson Space Center, whose goal is to develop automated techniques for error detection in complex, flight control software for manned space missions. Such software needs to be highly reliable. Techniques for checking software include model checking (e.g., <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b24">26,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b21">22]</ref>), static analysis (e.g., <ref type="bibr" target="#b27">[29]</ref>), and testing. Model checking exhaustively analyzes all program executions in a systematic way, but it suffers from scalability issues. Static analysis is scalable and exhaustive, but it may give many warnings that are spurious (i.e., do not correspond to real errors). Testing, on the other hand, reports errors that are real, but it may miss errors since it can only analyze some of the program executions. Furthermore, testing is the most widely used method for error detection at NASA, as well as elsewhere. We aim to combine the strengths of automated exhaustive techniques to make testing more effective.</p><p>Towards this end we have developed Symbolic Java Path Finder (Symbolic JPF), a framework that integrates symbolic execution <ref type="bibr" target="#b26">[28,</ref><ref type="bibr" target="#b10">11]</ref> with model checking to perform automated generation of test cases and to check properties of code during test case generation. Symbolic JPF generates test cases that obtain high coverage for flexible, user-defined, coverage metrics. Programs are executed on symbolic inputs that represent all possible concrete inputs. Values of variables are represented as numeric (mixed integer and real) constraints, encoding the conditions from the code. These constraints are then solved to generate test inputs guaranteed to exercise the analyzed code. Pre-conditions, when available, may be leveraged to reduce the size of the input data domains and to only generate test inputs that satisfy the pre-conditions. The framework uses the analysis engine of the Java PathFinder (JPF) model checking tool and it is available at <ref type="bibr" target="#b24">[26]</ref>, the symbc JPF extension. Unlike previous symbolic execution approaches (e.g., our own previous approach <ref type="bibr" target="#b25">[27,</ref><ref type="bibr" target="#b4">5]</ref> but also <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b30">32]</ref>) that work by code instrumentation, this new framework does not require such instrumentation, but instead implements a "nonstandard" interpreter of bytecodes. Moreover, the approach in <ref type="bibr" target="#b25">[27]</ref> requires an (approximate) type-based static analysis <ref type="bibr" target="#b3">[4]</ref> to determine if a program bytecode needs to be executed symbolically, and therefore needs to be instrumented. Symbolic JPF does not require such approximate analysis, since the symbolic information is stored in attributes associated with the program data and and is propagated dynamically during execution. As a result, our framework always maintains the most accurate information about the symbolic nature of the program data.</p><p>Symbolic JPF is quite general and it can be applied at different phases of software development, but it is most effective for unit (or sub-system) level testing. It is often the case that the input data to the unit is constrained by the environment, e.g., the calling context of a procedure representing the unit. To avoid generation of un-realistic test cases, such constraints would need to be encoded explicitly, which would require non-trivial additional manual effort from the software developers. We alleviate this problem in two ways.</p><p>• First, the new framework allows symbolic execution to be started at any point in the program and at any time during the concrete execution of a program. More specifically, one can let a program run in concrete execution mode within JPF's specialized Java virtual machine, and trigger symbolic execution based on some condition on the current concrete program state. Thus, the concrete execution of the system can be effectively used to set up the environment for the symbolic execution of a unit in the system. Furthermore, one can analyze a method/procedure symbolically, while some of the parameters and the calling context of the procedure are kept concrete.</p><p>• It is not always possible to run the whole program within the JPF's customized execution environment (due to sheer size, native libraries, hardware-software interaction, etc.). We therefore consider a second approach that uses actual system-level simulation runs to determine constraints on unit input data. Such constraints are then encoded as unit pre-conditions that help improve the precision of the unit-level symbolic analysis by avoiding generation of test cases that violate the constraints.</p><p>We describe the application of our techniques to a component of a NASA flight software system. Our symbolic framework generated in a few seconds a test suite that obtained full testing coverage, for a special coverage required by the developer. In contrast, random testing obtained only partial coverage while manual test case generation took approx. 20 hours to obtain not quite adequate coverage. During test generation, the framework also discovered errors that were later fixed by the developers. Furthermore, the generated test suite was applied to a new version of the code, where it helped uncover a subtle bug that led to the re-design of part of the flight software.</p><p>The rest of the paper is organized as follows. We begin with some background information on Java PathFinder (Section 2) and on symbolic execution -the enabling technique for test case generation (Section 3). We present our new framework for symbolic execution: we describe the extensions to Java PathFinder that were implemented to support this framework (Section 4) and we outline different mechanisms for combining system-level concrete program runs with unit-level symbolic execution (Section 5). We also discuss applications of our framework (Section 6), related work (Section 7) and conclusions (Section 8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">JAVA PATHFINDER (JPF)</head><p>JPF <ref type="bibr" target="#b24">[26]</ref> is an open-source runtime environment for verifying Java bytecode, i.e., programs written in Java's intermediate representation. JPF consists of a backtrackable, int x, y; <ref type="bibr" target="#b0">[1]</ref> if (x &gt; y) <ref type="bibr" target="#b1">[2]</ref> result = x -y; <ref type="bibr" target="#b2">[3]</ref> else <ref type="bibr" target="#b3">[4]</ref> result = y -x; <ref type="bibr" target="#b4">[5]</ref>  state matching and state storing virtual machine (VM), and a configurable search strategy object that drives the execution in the VM (see Figure <ref type="figure" target="#fig_0">1</ref>). The search and VM components together form the JPF core -a software model checker that can be directly applied to Java bytecode, to find property violations like unhandled exceptions, race conditions and deadlocks.</p><p>JPF employs a variety of mechanisms to reduce the number and storage costs of program states, such as on-the-fly partial order reduction and hash collapsing. Furthermore, JPF provides configurable extensions to define:</p><p>• operations that force the execution to branch (Choice Generators)</p><p>• code that should be executed outside JPF (Native Peers, e.g., for abstracting native libraries)</p><p>• code that allows changing the semantics of execution for bytecode instructions (Instruction Factories)</p><p>• code that non-intrusively monitors and controls JPF program execution (Listeners)</p><p>• properties to check for (such as no unhandled runtime exceptions)</p><p>In Section 4, we describe how we used JPF's configurable extensions to implement our symbolic execution framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SYMBOLIC EXECUTION</head><p>Symbolic execution <ref type="bibr" target="#b26">[28]</ref> is a form of program analysis that uses symbolic values instead of actual data as inputs and symbolic expressions to represent the values of program variables. As a result, the outputs computed by a program are expressed as a function of the symbolic inputs. The state of a symbolically executed program includes the (symbolic) values of program variables, a path condition (P C), and a program counter. The path condition is a boolean formula over the symbolic inputs, encoding the constraints which the inputs must satisfy in order for an execution to follow the particular associated path. The paths followed during the symbolic execution of a program are characterized by a symbolic execution tree.</p><p>To illustrate the difference between concrete and symbolic execution, consider the simple example in Figure <ref type="figure">2</ref> (left) that computes the absolute difference between two input integers x and y. Assume that the values of the input parameters are x=2 and y=1.</p><p>Concrete execution will follow only one program path, corresponding to the true branch of the if statement at line <ref type="bibr" target="#b0">[1]</ref>; this execution does not violate the assertion.</p><p>In contrast, symbolic execution starts with symbolic, rather than concrete, values, x = Symx, y = Symy, and the initial value of P C is true. The corresponding (simplified) execution tree is illustrated in Figure <ref type="figure">2</ref> (right). At each branch point, P C is updated with constraints on the inputs in order to choose between alternative paths. For example, after executing line <ref type="bibr" target="#b0">[1]</ref> in the code, both alternatives of the if statement are possible, and P C is updated accordingly. If the path condition becomes "false", it means that the corresponding path is infeasible (and symbolic execution does not continue for that path).</p><p>For our example, symbolic execution explores three different feasible paths, it determines that a fourth path is infeasible and it reports an assertion violation (for Path 3). For test case generation, the obtained path conditions are solved (using off-the-shelf decision procedures) and the solutions are used as test inputs that are guaranteed to exercise all the paths through this code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Generalized Symbolic Execution</head><p>In previous work <ref type="bibr" target="#b25">[27,</ref><ref type="bibr" target="#b4">5]</ref>, we have extended JPF to perform generalized symbolic execution for Java programs. The approach handles dynamically allocated data, arrays, and multi-threading. Programs are instrumented to enable JPF to perform symbolic execution; concrete types are replaced with corresponding symbolic types and concrete operations are replaced with calls to methods that implement corresponding operations on symbolic expressions. The model checker checks properties of the instrumented program using its usual state space exploration techniques. Several off-theshelf decision procedures are used to check satisfiability of numeric path conditions.</p><p>While quite general, our previous approach may result in sub-optimal execution since for each instrumented bytecode the model checker needs to check a set of bytecodes representing the symbolic counterpart. To minimize the instrumentation effort, a specialized type based analysis is proposed in <ref type="bibr" target="#b3">[4]</ref>. This analysis computes a conservative ap- proximation of type-dependence information that is used to locate the parts of the code that depend on the input symbolic variables. Therefore only those parts need to be transformed into their symbolic counterparts (the rest of the code remaining unchanged).</p><p>To address the problems described above, we have developed a new framework that does not require the code instrumentation and the approximate type based analysis. This framework is described in detail in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SYMBOLIC JAVA PATHFINDER</head><p>The symbolic execution framework is built as an extension of JPF -the framework performs a non-standard bytecode interpretation and uses JPF to systematically generate and execute the symbolic execution tree of the code under analysis. The key mechanisms that we used were:</p><p>• JPF's bytecode instruction factory and</p><p>• attributes associated with the program state.</p><p>The instruction factory allows replacing or extending the standard, concrete execution semantics of bytecodes with a non-standard (symbolic) execution, as desired. The symbolic information is stored in attributes associated with program data (fields, stack operands and local variables) and it is propagated as needed, during symbolic execution.</p><p>These mechanisms together allow dynamic modification of execution semantics, i.e., changing mid-stream from a system-level, concrete execution semantics to a symbolic execution semantics, thus providing the integrated test generation capability described later in this paper. We note also that they enable other types of integrated program analyses that we plan to pursue in future work.</p><p>Furthermore, we used JPF's choice generators, for handling branching conditions during symbolic execution, and listeners, for printing the results of the symbolic analysis (i.e., method summaries) and for enabling dynamic change of execution semantics. We also used native peers, for modeling native libraries, e.g., to capture java.lang.Math library calls and to send them to the constraint solver.</p><p>We describe some of these features in more detail below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">An Instruction Factory for Symbolic Execution of Bytecodes</head><p>JPF analyzes an input Java program (class files) by interpreting the Java bytecodes in a custom-made Virtual Machine. JPF implements a "default", concrete execution semantics that is based on a stack machine model, according to the Java VM specification <ref type="bibr" target="#b28">[30]</ref>. Furthermore, JPF allows replacing this standard execution semantics by using a configurable InstructionFactory (see Figure <ref type="figure" target="#fig_2">3</ref>).</p><p>For each method that is executed, JPF maintains an object (MethodInfo) that internally stores the associated bytecode as an array of Instruction objects, which are created from the bytecodes read from the corresponding class file. JPF imposes few constraints on Instruction classes other than requiring an execute() method.</p><p>JPF uses the abstract factory design pattern <ref type="bibr" target="#b15">[16]</ref> to instantiate its Instruction objects. We therefore created a SymbolicInstructionFactory containing instructions for the symbolic interpretation of Java bytecodes. The new Instruction classes are derived from the ones that come with the JPF core; they conditionally add new functionality and otherwise just delegate to their super classes. This enables simultaneous concrete-symbolic execution modes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Attributes</head><p>JPF maintains program states very similar to a standard Java VM. Each state consists of a call stack per thread, the values of the fields (i.e., the heap) and the scheduling information. The call stack contains stack frames corresponding to the methods that are being executed. Each stack frame stores information about the locals and the operands.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> illustrates the state representation in JPF core, including the heap and the stack frame for the currently executing method, i.e., the "callee", as well as the stack frame for the "caller" method. The values of the heap and the stack frames are manipulated via various bytecode operations, such as copy values between operand slots of Stack Frames (dup), between local variable slots and operand slots of Stack Frames (istore), and between operand slots and heap object fields (putfield and getfield). of JPF that associates so called slot attributes i.e., additional, state-stored information, with each of the locals and operands on the stack frame. This experimental extension was initially designed for verifying numeric properties.</p><p>We generalized this mechanism by providing support for field attributes (in addition to slot attributes). In our framework, the attributes are used to store the symbolic values and expressions that are created during symbolic execution.</p><p>Attributes are created or accessed by bytecode instructions, via accessors (e.g., methods setAttr, getAttr). They can also be created or accessed by listeners or native peers (see Figure <ref type="figure" target="#fig_3">4</ref>). Attribute manipulation is mainly done inside of the JPF core, within the various operations that modify and store the program states (such as dup, istore, putfield, and getfield).</p><p>Therefore, we only needed to override instruction classes that create or modify symbolic information, like numeric, compare-and-branch and type conversion operations. Other bytecode instructions, that only retrieve or store the symbolic information, remained un-changed.</p><p>Note that while this mechanism was developed in the context of our symbolic execution mode, it is now generalized sufficiently to allow arbitrary value and variable attributes, and therefore it can be useful for implementing other analyses (e.g., to keep track of physical dimensions and numeric error bounds or to perform concolic execution <ref type="bibr" target="#b18">[19]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Handling Branching Conditions</head><p>The symbolic execution of branching conditions involves creating a non-deterministic choice in JPF's search and adding the condition (or its negation) to the corresponding path condition. We achieved this by creating a new choice generator (PCChoiceGenerator) that branches the execution inside JPF. A path condition is associated with each choice generated by PCChoiceGenerator; the path condition is checked for satisfiability using a constraint solver. If the path condition becomes un-satisfiable, JPF is instructed to backtrack.</p><p>Our framework currently uses the choco constraint solver <ref type="bibr" target="#b9">[10]</ref> for integer and real constraints, and IASolver [25], an interval arithmetic solver that can handle complex Math functions. The two constraint solvers are integrated in Symbolic JPF via a common, generic, interface; the user can specify which one to use. We also plan to incorporate other decision procedures/constraint solvers in our analysis (similar to <ref type="bibr" target="#b4">[5]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Multi-threading, State-matching, Loops</head><p>As mentioned, our framework uses JPF to explore the symbolic execution tree of the analyzed program. JPF is also used to analyze thread interleavings and other forms of non-determinism that might be present in the code. We do not require the model checker to perform state matching (this is in general undecidable when states represent path conditions on un-bounded data). To limit the possibly infinite (symbolic) search state space that results from analyzing programs with loops or recursion, we put a limit on the model checker's search depth or on the number of constraints encoded in the path condition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Examples</head><p>We illustrate symbolic execution of bytecodes with two examples.</p><p>Let us first consider the IADD bytecode, that performs addition of two integers. The code in Figure <ref type="figure" target="#fig_4">5</ref> (left) shows the default JPF class that implements the concrete interpretation of the bytecode: the first two values on the operand stack are popped (lines <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b1">[2]</ref>), they are added and the result is pushed back on the stack (line <ref type="bibr" target="#b2">[3]</ref>). JPF is then instructed to execute the next bytecode (line <ref type="bibr" target="#b3">[4]</ref>).</p><p>Figure <ref type="figure" target="#fig_4">5</ref> (right) shows the (simplified) code that implements the"symbolic" counterpart. Class IntegerExpression implements symbolic integer expressions; a similar class, RealExpression, implements symbolic real expressions.</p><p>The symbolic information is propagated via attributes. Method execute first checks if the attributes associated with the two operands are null. If they are, then the two operands must be concrete and the execution follows according to standard execution semantics (line <ref type="bibr" target="#b4">[5]</ref>). Otherwise, if at least one of the operands is symbolic, then the result also becomes symbolic, and this is recorded in the result attribute that is pushed on the stack. Method _plus builds a new symbolic expression that represents the addition of its parameters. The attribute of the result is set to this new public class IADD extends Instruction { ... public Instruction execute (... ThreadInfo th){ <ref type="bibr" target="#b0">[1]</ref> int v1 = th.pop(); <ref type="bibr" target="#b1">[2]</ref> int v2 = th.pop(); <ref type="bibr" target="#b2">[3]</ref> th.push(v1 + v2, ...); <ref type="bibr" target="#b3">[4]</ref> return getNext(th); } } public class IADD extends ....bytecode.IADD { public Instruction execute (... ThreadInfo th) { <ref type="bibr" target="#b0">[1]</ref> IntegerExpression sym_v1, sym_v2; <ref type="bibr" target="#b1">[2]</ref> sym_v1 = ... .getOperandAttr(0); <ref type="bibr" target="#b2">[3]</ref> sym_v2 = ... .getOperandAttr(1); <ref type="bibr" target="#b3">[4]</ref> if (sym_v1 == null &amp;&amp; sym_v2 == null) // both values are concrete <ref type="bibr" target="#b4">[5]</ref> return super.execute(ss, ks, th); <ref type="bibr" target="#b5">[6]</ref> else { <ref type="bibr" target="#b6">[7]</ref> int v1 = th.pop(); <ref type="bibr" target="#b7">[8]</ref> int v2 = th.pop(); ... <ref type="bibr" target="#b8">[9]</ref> th.push(0, ...); // don't care about concrete value <ref type="bibr" target="#b9">[10]</ref> IntegerExpression result = IntegerExpression._plus(sym_v1,sym_v2); <ref type="bibr" target="#b10">[11]</ref> ... .setOperandAttr(result); <ref type="bibr" target="#b11">[12]</ref> return getNext(th); } } } condition = (th.pop() &gt;= 0); <ref type="bibr" target="#b1">[2]</ref> if (condition) <ref type="bibr" target="#b2">[3]</ref> next=getTarget(); <ref type="bibr" target="#b3">[4]</ref> else <ref type="bibr" target="#b4">[5]</ref> next=getNext(th); <ref type="bibr" target="#b5">[6]</ref> return next; } } public class IFGE extends ....bytecode.IFGE { public Instruction execute (... ThreadInfo th) { <ref type="bibr" target="#b0">[1]</ref> IntegerExpression sym_v = ... .getOperandAttr(); <ref type="bibr" target="#b1">[2]</ref> if(sym_v == null) <ref type="bibr" target="#b2">[3]</ref> // the condition is concrete <ref type="bibr" target="#b3">[4]</ref> return super.execute(... th); <ref type="bibr" target="#b4">[5]</ref> else { // the condition is symbolic <ref type="bibr" target="#b5">[6]</ref> PCChoiceGenerator cg = new PCChoiceGenerator(2); ... <ref type="bibr" target="#b6">[7]</ref> condition=cg.getNextChoice()==0?false:true; <ref type="bibr" target="#b7">[8]</ref> th.pop(); <ref type="bibr" target="#b8">[9]</ref> if (condition) { <ref type="bibr" target="#b9">[10]</ref> pc._add_GE(sym_v, 0); <ref type="bibr" target="#b10">[11]</ref> next = getTarget(); } <ref type="bibr" target="#b11">[12]</ref> else { <ref type="bibr" target="#b12">[13]</ref> pc._add_LT(sym_v, 0); <ref type="bibr" target="#b13">[14]</ref> next = getNext(th); } <ref type="bibr" target="#b14">[15]</ref> if(!pc.isSatisfiable()) <ref type="bibr" target="#b15">[16]</ref> ... // instruct JPF to backtrack <ref type="bibr" target="#b16">[17]</ref> else <ref type="bibr" target="#b17">[18]</ref> cg.setCurrentPC(pc); <ref type="bibr" target="#b18">[19]</ref> return next; } } } symbolic expression (line <ref type="bibr" target="#b10">[11]</ref>). Since the result becomes symbolic, its concrete value does not matter, so we set it to 0 (line <ref type="bibr" target="#b8">[9]</ref>).</p><p>We illustrate the use of choice generators in the symbolic execution of branching conditions with the IFGE bytecode. The code in Figure <ref type="figure" target="#fig_5">6</ref> (left) shows the concrete interpretation of the bytecode: the first popped value from the stack is compared with 0 to compute the associated condition. This condition determines the next instruction to be executed.</p><p>In symbolic execution (Figure <ref type="figure" target="#fig_5">6</ref> (right)), the concrete condition is no longer used to exclusively choose between program branches. Instead we create a choice generator (line <ref type="bibr" target="#b5">[6]</ref>) that introduces a non-deterministic choice (line <ref type="bibr" target="#b6">[7]</ref>) that allows both execution branches to be considered.</p><p>For each branch, the path condition is updated with the symbolic condition (line <ref type="bibr" target="#b9">[10]</ref>) or its negation (line <ref type="bibr" target="#b12">[13]</ref>). Method isSatisfiable uses a decision procedure to check if the path condition is satisfiable or not, in which case JPF backtracks (line <ref type="bibr" target="#b15">[16]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">USING SYSTEM-LEVEL CONCRETE EX-ECUTIONS</head><p>Symbolic JPF is quite general and it can be applied at different phases of software development, i.e., unit-level or system-level testing. However due to inherent limitations, such as availability of decision procedures for the application domains and number of constraints that can be handled by the constraint solver, our tool is most effective at unit (or sub-system) level. A unit is a Java method, or set of methods, but it can also be an arbitrary piece of code designated as such by the user. To simplify our discussion, we only consider here Java methods as units. It is often the case that the input data to the unit is constrained by the environment, e.g., the calling context of a procedure representing the unit. These environment constraints need to be encoded explicitly to avoid generation of un-realistic unit level test cases. We describe here two techniques that address this problem. Both techniques use system-level concrete execution to set-up the symbolic execution at the unit-level. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">"Any time" symbolic execution</head><p>In our framework, symbolic execution can start from any point in the program and it can perform symbolic execution of the unit, with mixed concrete and symbolic inputs. Furthermore, no special test driver needs to be created; it is sufficient to have an executable program that uses the unit.</p><p>To execute a method symbolically, the user needs to instruct JPF to use the SymbolicInstructionFactory and to specify the method name and the method inputs that are to be considered symbolic or concrete. These inputs include the method arguments and the globals (i.e., fields) that are accessed (i.e., read) by the method code.</p><p>The program begins execution using the concrete semantics, since all the symbolic bytecode Instruction classes simply delegate execution to the "concrete" super-class when there are no symbolic attributes associated with the data (see the examples in Figure <ref type="figure" target="#fig_4">5</ref> line <ref type="bibr" target="#b4">[5]</ref> and Figure <ref type="figure" target="#fig_5">6</ref> line <ref type="bibr" target="#b3">[4]</ref>). A listener monitors the concrete execution of the program within JPF's VM and it triggers symbolic execution the first time the method with the specified name is invoked, i.e., it "injects" new symbolic values in the attributes of the specified symbolic inputs (parameters and globals).</p><p>From that point on, the execution proceeds symbolically (e.g., the methods invoked by the designated method continue to process the symbolic information stored in the attributes). Once the method returns (or some user specified limit has been reached), JPF prints the method summary, i.e., a set of test cases characterizing the symbolic execution.</p><p>In general, one can trigger symbolic execution of a unit "any time" during concrete execution, by writing a specialized listener (see Figure <ref type="figure" target="#fig_6">7</ref>). The listener is watching for certain concrete variable conditions and method sequences that identify program states which should be analyzed symbolically and it starts symbolic execution when the conditions are met. It is also possible to switch back to concrete execution, i.e., solve the constraints in the current path condition, compute the corresponding concrete values of the program variables and continue execution in concrete mode. We plan to investigate this feature for handling native library calls.</p><p>Since the unit can be analyzed with mixed concrete and symbolic inputs, one can use the concrete execution of a program to set up different concrete global contexts for the unit-level symbolic analysis. The use of concrete correlated input values also reduces the complexity of path conditions in the symbolic analysis (which in turn improves the performance and rate of success of the constraint solver when computing solutions for the path conditions).</p><p>Furthermore, our approach allows us to generate tests that exercise "deep" system executions. An example where this could be useful would be a complex server application that can run for a very long time. Instead of trying to symbolically analyze the whole state space (which might be impossible), such an application could be executed in concrete mode until a certain condition is recognized that warrants closer inspection. At this point, symbolic execution can take over and provide the data for test cases that specifically stress the suspicious program states.</p><p>Moreover, we can use our mixed concrete-symbolic execution to extend existing tests. For example, this could be useful when generating test sequences for Java containers <ref type="bibr" target="#b31">[33]</ref>. A test in this case is a sequence of add and remove methods that add and remove elements to and from the container. One can use an existing test sequence to set-up the content of the heap for the container and subsequently execute add or remove symbolically to increase testing coverage. This would be much less expensive than executing the whole test sequence symbolically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Using system-level simulation runs</head><p>We consider here a second technique that uses actual systemlevel simulation runs to improve the precision of unit-level analysis. The technique is illustrated in Figure <ref type="figure" target="#fig_8">8</ref>. Multiple system runs are obtained via Monte Carlo simulations. The values of various system variables that form the unit's interface are monitored and the results are recorded in a log file that is then analyzed to determine "likely" correlations on unit input parameters. These correlations are then encoded as pre-conditions to the unit and they are asserted as initial path conditions for the symbolic execution of the unit. As a result, only test inputs that satisfy the input pre-conditions are generated.</p><p>As a simulation environment, we use ANTARES <ref type="bibr" target="#b0">[1]</ref> (the Advanced NASA Technology ARchitecture for Exploration Studies), a trajectory simulation tool used by the JSC Guidance Navigation and Control (GN&amp;C) community in support of NASA missions. ANTARES is a collection of spacecraft system related models and libraries that are assembled and executed by Trick, a C-based simulation environment.</p><p>Currently, ANTARES is used for spacecraft design assessment, performance analysis, requirements validation, Hardware in the Loop and Human in the Loop testing.</p><p>To execute a run in ANTARES, the user specifies an input file which contains all of the information that Trick needs to properly initialize the data in every model. There are several ANTARES input file templates that have been verified and validated, and the user typically needs only to modify one of these files for their specific task.</p><p>The input file also specifies the log file, which contains a list of the variables to be monitored during the run. The resulting data files can take up several gigabytes, depending on the number of variables and the frequency with which they are written to the log file.  One can also set up Monte Carlo simulations by writing an input file which specifies designated input variables, their probability distributions and how many cases one wishes to run while sampling from the probability distributions. This allowed us to obtain simulations with widely varying initial system data.</p><p>The correlation analysis uses machine learning techniques (e.g., <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b11">12]</ref>) to determine unit input constraints. For the case study presented in the next section, we only needed a simple analysis of the log file to determine simple correlations in terms of range restriction on unit inputs. However, for other, more complex applications, we are experimenting with the treatment learner from <ref type="bibr" target="#b29">[31]</ref> to determine more complex correlations.</p><p>We remark that this second technique can be combined with the first technique presented above in Section 5.1. Indeed, one can run a program within JPF and obtain input constraints for the unit, and then use these as pre-conditions during the symbolic execution analysis. In fact, an interface between JPF and the Daikon invariant detector tool <ref type="bibr" target="#b11">[12]</ref> already exists, and it can be used for our purpose.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CASE STUDY</head><p>In this section we describe the application of our approach to testing NASA software.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">On-board Abort Executive (OAE)</head><p>We applied our approach to a Java model of the Crew Exploration Vehicle's prototype ascent abort handling software, the Onboard Abort Executive (OAE). The OAE monitors the status of the vehicle during the ascent phase of flight. It decides the following:</p><p>• when an abort is required,</p><p>• which abort mode is currently safest for the astronauts,</p><p>• when to automatically initiate an ascent abort.</p><p>The high-level structure of the code is shown in Figure <ref type="figure" target="#fig_10">9</ref>. The OAE receives its inputs (e.g., current altitude, launch vehicle internal pressures, etc.) from sensors and other software components. The inputs are analyzed to determine if  any of the ascent flight rules have been broken, and to evaluate which ascent abort modes are currently possible. If multiple abort modes are currently possible, the OAE chooses the abort mode that is safest for the flight crew. The OAE also predicts what the vehicle's abort mode options will be in a short time. This gives the crew the opportunity to postpone abort initiation in favor of a safer abort mode in the near future. Once a flight rule is broken, and an abort mode is chosen, it is sent to the rest of the flight software for initiation. The analyzed code is approximately 600 lines of code, it has a large input space (approximately 65 input variables) and fairly complicated logic.</p><p>There are many ascent flight rules and abort modes, and encoding them correctly in software is difficult. Since the OAE is directly concerned with human safety, it is imperative that this code be correctly implemented and carefully verified. Currently, test generation is done by hand by JSC engineers, so it is time-consuming to ensure that all necessary test cases are created. Our goal was therefore to demonstrate that our approach can quickly and automatically generate all required test cases for the OAE. During test case generation, our approach also checked known safety properties derived from the requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Properties</head><p>Examples of safety properties that we checked for the OAE are:</p><p>• If a flight rule is violated, then an abort mode must be chosen.</p><p>• If no flight rules are violated, then an abort mode must not be chosen.</p><p>• If both performance and systems abort conditions exist, then the systems abort rules should apply.</p><p>We encoded these properties as assertions in the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Test Coverage</head><p>The OAE requires different kinds of code coverage for its test suite. These include abort coverage, flight rule coverage, combinations of abort/flight rules coverage, and branch coverage. Initially, we generated a maximal test suite that included test cases violating multiple flight rules. However, since the OAE was an early prototype, it was not designed to handle multiple simultaneous flight rule violations. We therefore generated a new set of test cases for single flight rule violations (by instructing JPF to backtrack when a second flight rule violation occurs). More generally, one can customize JPF's search to satisfy user-specified test coverage criteria (using JPF listeners).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Results</head><p>We used our symbolic execution framework to generate approximately 200 test cases to cover all aborts and flight rules. The total execution time was less than 1 minute. A typical test case required solving path conditions with between 70 and 85 clauses. During test case generation we also discovered an error (flight rules broken but no abort picked) which was later corrected by the OAE developers. Each test case includes the values of the input variables and the expected output abort mode.</p><p>Note that manual test case generation took more than 20 hours and did not cover all possible flight rule/abort combinations. We also experimented with random testing, which covered only a few flight rules and no aborts; this is not surprising, given the large input state space and the complicated conditions in the code.</p><p>The engineers at JSC used the test cases that we generated both as part of their test suite for this early version of OAE and as regression tests for later versions. This proved to be important as one of the generated test cases (run as a regression test) identified a significant design error in the next version of OAE and resulted in design changes that affected not just the flight rules and abort code, but also several other modules.</p><p>We also analyzed a later version of the OAE that implemented the predicted abort mode functionality. The analysis procedure was the same as for the original OAE model, and it generated approximately 300 test cases in less than 2 minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Input Constraints</head><p>In our case study, we analyzed the OAE component in isolation, by writing a driver that invokes the component. However, the OAE operates in a vehicle subject to real-world constraints, so some combinations of input parameters that might cause the code to detect flight rule violations are not physically possible. For example, we initially generated a test suite that contained a case that set the inertial velocity of the vehicle to 24000 ft/s, though the altitude of the vehicle was only 0 feet (a physically impossible combination). We therefore needed to encode such constraints explicitly to avoid generation of un-realistic test cases. The constraints were expressed as range restrictions on input variables or as simple functions of input variables. These were asserted as pre-conditions to the OAE code and were thereby automatically included in the path conditions. Some of the input constraints were directly provided by the domain experts, while other constraints, such as range restrictions, were determined from ANTARES simulation runs. For the OAE, we determined the minimum (min) and maximum (max) values of the pertinent OAE input variables.We used these values to encode the ranges [minδ . . . max + δ] as pre-conditions in the OAE code; we used the extra quantity δ to increase the chances that symbolic execution would discover failure cases. As a result, we were able to generate test suites that did not contain physically impossible test cases, but still achieved the desired coverage.</p><p>In the future, as we will need to analyze new, more complex versions of the OAE, we plan to use the treatment learner <ref type="bibr" target="#b29">[31]</ref> to correlate the ranges of the input variables with different phases of the abort logic.</p><p>In general, we should note that the analysis of the simulation data can only give "likely" correlations on the unit inputs. While these correlations help focus the symbolic execution, they need to be used with care, since they might mask unit behaviour. This is the reason we introduced the δ above. We need to investigate more how one can "expand" the input domains in the case of more complex correlations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>The work related to the topic of this paper is vast, and for brevity we only highlight here some of the closely related works.</p><p>Several approaches have been proposed that use model checking for test input generation <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b23">24]</ref>. In these approaches, one specifies as a (temporal) property that a specific coverage cannot be achieved and a model checker is used to produce counterexample traces, if they exist, that then can be transformed into test inputs to achieve the stated coverage.</p><p>Two popular software model checkers, BLAST and SLAM, have also been used for generating test inputs with the goal of covering a specific predicate or a combination of predicates <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b5">6]</ref>. Both these tools use over-approximation based predicate abstraction and use some form of symbolic evaluation for the analysis of (spurious) abstract counterexamples and refinement. We use a hybrid approach that combines model checking with symbolic execution and constraint solving for test case generation. Furthermore, we have shown how to use system-level concrete executions to improve unitlevel test case generation.</p><p>Program analysis based on symbolic execution has received a lot of attention recently, e.g., <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b32">34,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b8">9]</ref>.</p><p>The Extended Static Checker (ESC) <ref type="bibr" target="#b13">[14]</ref> uses a static analysis to verify partial correctness of Java classes. Although our focus here is on test case generation, we can also use our symbolic execution framework to check light-weight properties in a way similar to ESC. Symstra <ref type="bibr" target="#b32">[34]</ref> uses a specialized symbolic execution over numeric data for generating test sequences for (sequential) Java containers. We provide here a general framework for the symbolic execution of arbitrary Java bytecode. Symclat is an experimental implementation of symbolic execution in JPF that was done in the more general context of an empirical case study <ref type="bibr" target="#b2">[3]</ref>. Similar to Symbolic JPF, Symclat was done via changing the byte-code interpretation, but it did not use attributes or the instruction factory, and was limited to handling integer symbolic inputs. Bogor/Kiasan <ref type="bibr" target="#b12">[13]</ref> is similar to JPF-SE <ref type="bibr" target="#b4">[5]</ref>, but uses a "lazier" approach.</p><p>We are working towards making our framework supersede in functionality our previous tool <ref type="bibr" target="#b25">[27,</ref><ref type="bibr" target="#b4">5]</ref>, but without requiring the code instrumentation. Therefore, all the applications from our previous work, such as test sequence generation for Java containers <ref type="bibr" target="#b31">[33]</ref> should be possible with our new approach. Furthermore, the ability to alternate dynamically between concrete and symbolic execution (as described in Section 5) opens up a new set of applications that need to be explored.</p><p>Concolic execution <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b8">9]</ref> is an analysis technique that performs a concrete execution on random inputs and it collects the path constraints along the executed path. These path constraints are then used to compute new inputs that drive the program along alternative paths. Unlike concolic execution, which performs symbolic execution along a concrete execution, we use concrete execution to set-up the environment for symbolic execution. Furthermore, unlike our approach, the approaches described in <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b8">9]</ref> use code instrumentation and don't use model checking (that we use for analyzing multithreading systematically). We are not aware of any other techniques that combine symbolic and concrete execution in a way similar to our approach.</p><p>Our work is similar in spirit, but different methodologically to other hybrid approaches such as <ref type="bibr" target="#b33">[35,</ref><ref type="bibr" target="#b19">20]</ref>. These works combine abstraction techniques and theorem proving for program analysis and testing and do not address the problem of constraining the environment for unit analysis.</p><p>Finally, Symbolic JPF can be viewed as leveraging JPF to enable integration of mixed symbolic and concrete execution with the work on carving differential unit tests from system tests <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS AND FUTURE WORK</head><p>We presented a symbolic execution framework for test case generation that implements a non-standard interpreter on top of the JPF model checking tool. We proposed two techniques that use concrete system executions to improve the precision of the symbolic analysis. We described a case study that demonstrated the merits of our techniques.</p><p>In the future, we plan to work on a tighter integration of the symbolic execution with the system level simulations and to experiment with different machine learning techniques for correlation analysis. Furthermore, we want to investigate whether some of the constraints generated by the symbolic analysis can also be fed back to the simulator, to help it focus on complex, off-nominal scenarios.</p><p>We are actively working on extending the capabilities of our symbolic execution framework and applying it to testing new NASA software (e.g., a Java utility library for trajectory computation). We are also extending the tool's capabilities to generate test sequences for UML statecharts (using JPF's statechart extension).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: JPF high-level structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>3 PC:Figure 2 :</head><label>32</label><figDesc>Figure 2: Example for symbolic execution (left) and corresponding execution tree (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Bytecode factories for concrete vs. symbolic execution.</figDesc><graphic coords="4,189.89,130.70,272.76,97.58" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4</head><label>4</label><figDesc>Figure 4: Attributes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Concrete (left) and symbolic (right) execution for the IADD bytecode.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Concrete (left) and symbolic (right) execution for the IFGE bytecode.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Combining concrete and symbolic execution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Using system simulations to determine unit pre-conditions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: The OAE code structure.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">ACKNOWLEDGMENTS</head><p>We thank Willem Visser for his early guidance in this project and Hamed Jafari for helping with the translation of the OAE code. We also thank the reviewers for their detailed comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">ANTARES: Spacecraft simulation for multiple user communities and facilities</title>
		<author>
			<persName><forename type="first">A</forename><surname>Acevedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Othon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AIAA Modeling and Simulation Technologies Conference and Exhibit</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Using model checking to generate tests from specifications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ammann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Majurski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2nd IEEE International Conference on Formal Engineering Methods</title>
		<meeting>of the 2nd IEEE International Conference on Formal Engineering Methods</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An Empirical Comparison of Automated Generation and Classification</title>
		<author>
			<persName><forename type="first">M</forename><surname>Amorim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pacheco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21st ASE</title>
		<meeting>of the 21st ASE</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Type-dependence analysis and program transformation for symbolic execution</title>
		<author>
			<persName><forename type="first">S</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Harrold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th TACAS Conference</title>
		<meeting>of the 13th TACAS Conference</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">JPF-SE: A symbolic execution extension to Java PathFinder</title>
		<author>
			<persName><forename type="first">S</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pȃsȃreanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th TACAS Conference</title>
		<meeting>of the 13th TACAS Conference</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">A theory of predicate-complete test coverage and generation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<idno>MSR-TR-2004-28</idno>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note type="report_type">Microsoft Research Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The SLAM project: Debugging system software via static analysis</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th Annual ACM Symposium on the Principles of Programming Languages (POPL)</title>
		<meeting>29th Annual ACM Symposium on the Principles of Programming Languages (POPL)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="1" to="3" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Generating tests from counterexamples</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Chlipala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 26th International Conference on Software Engineering (ICSE)</title>
		<meeting>of the 26th International Conference on Software Engineering (ICSE)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">EXE: automatically generating inputs of death</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Pawlowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Conference on Computer and Communications Security</title>
		<meeting>ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
		<ptr target="http://choco.sourceforge.net/" />
	</analytic>
	<monogr>
		<title level="j">The Choco Constraint Solver</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A system to generate test data and symbolically execute programs</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="215" to="222" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<ptr target="http://groups.csail.mit.edu/pag/daikon//" />
		<title level="m">The Daikon invariant detector</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A k-bounded Symbolic Execution for Checking Strong Heap Properties of Open Systems</title>
		<author>
			<persName><forename type="first">X</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robby</forename><surname>Bogor/Kiasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21st ASE</title>
		<meeting>of the 21st ASE</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Extended static checking</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Research Report</title>
		<imprint>
			<biblScope unit="volume">159</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Compaq Systems Research Center</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Carving differential unit test cases from system test cases</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Elbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">N</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dokulil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGSOFT FSE</title>
		<meeting>of SIGSOFT FSE</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Design Patterns: Elements of Reusable Object-Oriented Software</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Using model checking to generate tests from requirements specifications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gargantini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Heitmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th European Software Engineering Conference, Held Jointly with the 7th ACM SIGSOFT Symposium on the Foundations of Software Engineering (ESEC/FSE)</title>
		<meeting>of the 7th European Software Engineering Conference, Held Jointly with the 7th ACM SIGSOFT Symposium on the Foundations of Software Engineering (ESEC/FSE)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Model checking for programming languages using VeriSoft</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Annual ACM Symposium on the Principles of Programming Languages (POPL)</title>
		<meeting>the 24th Annual ACM Symposium on the Principles of Programming Languages (POPL)<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-01">Jan. 1997</date>
			<biblScope unit="page" from="174" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">DART: directed automated random testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PLDI</title>
		<meeting>PLDI</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">SYNERGY: a new algorithm for property checking</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Gulavani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGSOFT FSE</title>
		<meeting>of SIGSOFT FSE</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Auto-generating test sequences using model checkers: A case study</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P E</forename><surname>Heimdahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rayadurgam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd International Workshop on Formal Approaches to Testing of Software (FATES)</title>
		<meeting>3rd International Workshop on Formal Approaches to Testing of Software (FATES)<address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10">Oct. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Software verification with blast</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sutre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth International Workshop on Model Checking of Software</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Tenth International Workshop on Model Checking of Software</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2648</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">The Spin Model Checker: Primer and Reference Manual</title>
		<author>
			<persName><forename type="first">G</forename><surname>Holzmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A temporal logic based theory of test coverage and generation</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sokolsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ural</surname></persName>
		</author>
		<ptr target="http://www.cs.brandeis.edu/~tim/Applets/IAsolver.html" />
	</analytic>
	<monogr>
		<title level="m">Proc. 8th International Conference on Tools and Algorithms for Construction and Analysis of Systems (TACAS)</title>
		<meeting>8th International Conference on Tools and Algorithms for Construction and Analysis of Systems (TACAS)<address><addrLine>Grenoble, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-04">April 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Java</forename><surname>Pathfinder</surname></persName>
		</author>
		<ptr target="http://javapathfinder.sourceforge.net" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Generalized symbolic execution for model checking and testing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Khurshid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pȃsȃreanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</title>
		<meeting>of the 9th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Symbolic execution and program testing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="385" to="394" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">TVLA: A system for implementing static analyses</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lev-Ami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Static Analysis Symposium</title>
		<meeting>Static Analysis Symposium<address><addrLine>Santa Barbara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">TM) Virtual Machine Specification</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lindholm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yellin</surname></persName>
		</author>
		<author>
			<persName><surname>Java</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Data mining for very busy people</title>
		<author>
			<persName><forename type="first">T</forename><surname>Menzies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="22" to="29" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">CUTE: a concolic unit testing engine for C</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ESEC/SIGSOFT FSE</title>
		<meeting>ESEC/SIGSOFT FSE</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Test input generation for java containers using state matching</title>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pelanek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISSTA</title>
		<meeting>ISSTA</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Symstra: A framework for generating object-oriented unit tests using symbolic execution</title>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schulte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Notkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 11th International Conference on Tools and Algorithms for Construction and Analysis of Systems (TACAS)</title>
		<meeting>of the 11th International Conference on Tools and Algorithms for Construction and Analysis of Systems (TACAS)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Testing, abstraction, theorem proving: better together</title>
		<author>
			<persName><forename type="first">G</forename><surname>Yorsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISSTA</title>
		<meeting>ISSTA</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
