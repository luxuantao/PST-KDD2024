<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Maximal Sound Predictive Race Detection with Control Flow Abstraction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jeff</forename><surname>Huang</surname></persName>
							<email>smhuang@illinois.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Patrick</forename><surname>O'</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Neil</forename><surname>Meredith</surname></persName>
							<email>pmeredit@illinois.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Grigore</forename><surname>Rosu</surname></persName>
							<email>grosu@illinois.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Maximal Sound Predictive Race Detection with Control Flow Abstraction</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">35DA4CC8629E369EA23D28CDF4F009C5</idno>
					<idno type="DOI">10.1145/2594291.2594315</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.5 [Software Engineering]: Testing and Debugging-Diagnostics; Debugging aids General Terms Algorithms</term>
					<term>Design</term>
					<term>Theory Maximal Sound</term>
					<term>Data Race</term>
					<term>Prediction</term>
					<term>Control Flow</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Despite the numerous static and dynamic program analysis techniques in the literature, data races remain one of the most common bugs in modern concurrent software. Further, the techniques that do exist either have limited detection capability or are unsound, meaning that they report false positives. We present a sound race detection technique that achieves a provably higher detection capability than existing sound techniques. A key insight of our technique is the inclusion of abstracted control flow information into the execution model, which increases the space of the causal model permitted by classical happens-before or causally-precedes based detectors. By encoding the control flow and a minimal set of feasibility constraints as a group of first-order logic formulae, we formulate race detection as a constraint solving problem. Moreover, we formally prove that our formulation achieves the maximal possible detection capability for any sound dynamic race detector with respect to the same input trace under the sequential consistency memory model. We demonstrate via extensive experimentation that our technique detects more races than the other state-of-the-art sound race detection techniques, and that it is scalable to executions of real world concurrent applications with tens of millions of critical events. These experiments also revealed several previously unknown races in real systems (e.g., Eclipse) that have been confirmed or fixed by the developers. Our tool is also adopted by Eclipse developers.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Some of the worst concurrency problems in multithreaded systems today are due to data races, which occur when there are unordered conflicting accesses in the program without proper synchrornization. Data races are particularly problematic because they manifest non-deterministically, often appearing only on very rare executions, making them notoriously difficult to test and debug. We shall refer to data races simply as races in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>initially x=y=0</head><p>resource z=0 Thread t1</p><p>Thread t2</p><p>1. fork t2 2. lock l 3. x = 1 4. y = 1 5. unlock l 6. { //begin 7. lock l 8. r1 = y 9. unlock l 10. r2 = x 11. if (r1 == r2) 12. z = 1 (auth) 13. } //end 14. join t2 15. r3 = z (use) <ref type="bibr" target="#b12">16</ref>. if (r3 == 0) 17.</p><p>Error Although researchers have proposed a wide spectrum of techniques <ref type="bibr" target="#b3">[7,</ref><ref type="bibr" target="#b6">10,</ref><ref type="bibr" target="#b9">13,</ref><ref type="bibr" target="#b10">14,</ref><ref type="bibr" target="#b15">19,</ref><ref type="bibr" target="#b17">21,</ref><ref type="bibr" target="#b20">24,</ref><ref type="bibr" target="#b24">28,</ref><ref type="bibr" target="#b26">30,</ref><ref type="bibr" target="#b27">31,</ref><ref type="bibr" target="#b31">35]</ref> to combat races, existing techniques are either unsound (by soundness we mean nofalse-positive in this paper) or have a limited detection capability. The school of lockset-based techniques <ref type="bibr" target="#b10">[14,</ref><ref type="bibr" target="#b17">21,</ref><ref type="bibr" target="#b24">28,</ref><ref type="bibr" target="#b27">31]</ref> popularized by Eraser <ref type="bibr" target="#b27">[31]</ref> is known to be unsound, whereas the happensbefore (HB) based approaches <ref type="bibr" target="#b3">[7,</ref><ref type="bibr" target="#b9">13,</ref><ref type="bibr" target="#b15">19,</ref><ref type="bibr" target="#b20">24]</ref> are often very limited in detecting races, due to extra overly conservative HB edges. Even though a recent development, causally-precedes (CP) <ref type="bibr" target="#b31">[35]</ref>, improves the detection power by soundly relaxing the HB edges between critical sections that have no conflicting accesses, it can still miss many races. Consider, for instance, an execution of the program in Figure <ref type="figure" target="#fig_0">1</ref>. The program contains a race between lines (3,10) that may cause an authentication failure of resource z at line 12, which in consequence causes an error to occur when z is used at line 15. Supposing the execution follows an order denoted by the line numbers, however, CP cannot detect this race because line 3 causally-precedes line 10, for the reason that the two lock regions contain conflicting accesses to y. PECAN <ref type="bibr" target="#b17">[21]</ref>, another representative technique that uses a hybrid algorithm combining lockset and a weaker form of HB, is able to detect this race by ignoring the HB edges between critical regions. However, the hybrid algorithm is unsound in general. For instance, if we switch lines 1 and 2, (3,10) is no longer a race (because then line 10 will always happen-after line 3), but PECAN will still report it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>initially x=y=0 y is volatile Thread t1</head><p>Thread t2 1. x = 1 2. y = 1 3. ¿ r1 = y ¡ while(y == 0); 4. r2 = x Figure <ref type="figure">2</ref>. The two cases ¿ and ¡ produce the same read/write trace. However, (1,4) is a race in case ¿ but not in case ¡.</p><p>In this work, we present a sound dynamic race detection technique that achieves a much higher detection capability than existing techniques. Our key observation is that the control flow information between events in the execution (which is often ignored by existing techniques) can help significantly improve the race detection ability. Consider the simple scenario in Figure <ref type="figure">2</ref> where y is volatile and line 3 has two cases: ¿ r1 = y and ¡ while(y == 0). For case ¿, (1,4) is a race on x; while for case ¡, it is not, because line 4 is control-dependent on the while loop at line 3. However, without considering the control dependence between operations, the dynamic execution traces for these two cases are identical (both following lines 1-2-3-4). Hence, a sound technique must conservatively assume that a value read by a thread influences all subsequent values produced by the same thread, which, in consequence, creates a HB edge from line 2 to line 3 and misses the race in case ¿. However, with the control flow information, we can tell that, in case ¿, line 4 is not control-dependent on line 3. In other words, regardless of what value line 3 reads, line 4 will always be executed. Therefore, we can safely drop the HB edge from line 2 to line 3, which enables detecting the race (1,4). Similarly, we are able to detect the race (3,10) in Figure <ref type="figure" target="#fig_0">1</ref> by dropping the HB edge from line 4 to line 8, because there is no control flow from line 8 to line 10 and hence no need to ensure line 8 should read value 1 (written by line 4).</p><p>Our first contribution is to add a new type of events-branchinto the execution model. Observing branch events is cheap at runtime, however, it provides an abstract view of the control flow information between events that enables a higher race detection power. Moreover, inspired by the theoretical maximal causal model <ref type="bibr" target="#b29">[33]</ref>, we develop a weaker maximal causal model that incorporates control flow information under the sequential consistency memory model. Underpinned by the new model, we design a maximal race detection algorithm that encodes all the valid trace reorderings allowed by the model as a set of first-order logical constraints, and uses an SMT solver to find races. By formulating race detection as a constraint solving problem, our technique is both sound and maximal: every race it detects is real, accompanying with a valid trace that can manifest it, and it detects all the possible races that can be detected by any sound technique based on the same trace.</p><p>Our race detection algorithm is inspired by the work of Said et al. <ref type="bibr" target="#b26">[30]</ref>, which also uses SMT-based analysis to detect races. Unlike our approach, <ref type="bibr" target="#b26">[30]</ref> does not consider control flow and it is non-maximal. To ensure soundness, <ref type="bibr" target="#b26">[30]</ref> requires the whole trace read-write consistency: every read returns the same value as that in the original trace (the value may be written by a different write, though). However, this requirement limits the race exploration to only a subset of the feasible traces. For example, <ref type="bibr" target="#b26">[30]</ref> cannot detect the race (1,4) in case ¿, because it requires line 3 to read the value 1 on y written by line 2, which rules out the incomplete trace 3-1-4 that can manifest the race (1,4). Similarly, <ref type="bibr" target="#b26">[30]</ref> cannot detect the the race (3,10) in Figure <ref type="figure" target="#fig_0">1</ref>, as line 10 can only read value 1 on x written by line 3. Instead, our technique is concerned with the readwrite consistency from the perspective of control dependence, and generates only the constraints with respect to the events that have control flow to the race related operations. Hence, our technique is able to detect races in all feasible incomplete traces as well.</p><p>We have implemented our technique for Java and conducted extensive evaluation and comparison with the state-of-the-art sound race detection techniques-HB, CP, and Said et al. <ref type="bibr" target="#b26">[30]</ref>-on a wide range of popular multithreaded benchmarks as well as real world large concurrent systems. Our results show that our technique detects significantly more races than the other approaches, demonstrating the theoretically higher race detection capability of our approach with the control flow abstraction. Moreover, our technique is practical: it has been applied to real complex executions with tens of millions of critical events and is highly effective in detecting real races. For the seven real systems, our tool detected 299 real races in total. Comparatively, HB, CP, and Said et al. only detected 68, 76, and 158 races, respectively. Our experiments also revealed 11 previously unknown races in these real systems that have been confirmed or fixed by the developers. Because of our bug reports in Eclipse [1, 2], the developers have adopted our tool on the codebase of Eclipse Virgo <ref type="bibr">[3]</ref>.</p><p>The following summarizes our contributions:</p><p>• We present a sound and maximal causal model incorporating the control flow information for general multithreaded programs under the sequential consistency memory model. This new causal model forms a foundation for maximal dynamic concurrency error detection with control flow. ( §2)</p><p>• We present a maximal sound dynamic race detection technique based on this new model. We formally prove that our technique is able to detect all races by any sound race detector based on the same execution trace. ( §3)</p><p>• We present an efficient implementation ( §4) and extensive evaluation of our technique, demonstrating the practicality and race detection capability in real world concurrent systems. ( §5)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Maximal Causal Model With Control Flow</head><p>In this section we present our main theoretical contribution, the maximal causal model with control flow, following the axiomatic approach pioneered in <ref type="bibr" target="#b29">[33]</ref> (there without control flow). This model paves the theoretical foundation for maximal dynamic concurrency error detectors, such as our race detection technique. Multithreaded programs P are abstracted as the prefix-closed sets of finite traces of events that they can produce when completely or partially executed, called P-feasible traces. Such sets of traces can be constructed for each P using, for example, a formal semantics of the target programming language. Regardless of the programming language and of how they are defined, the sets of P-feasible traces must obey some basic consistency axioms. We only consider sequential consistency in this paper. The axioms allow us to associate a sound and maximal causal model feasible(⌧ ) to any consistent trace ⌧ , which comprises precisely the traces that can be generated by all programs that can generate ⌧ . As shown in <ref type="bibr" target="#b29">[33]</ref>, conventional happens-before causal models consisting of all the legal interleavings of ⌧ and their prefixes are not maximal. The maximal causal model allows us to define a maximal notion of race: trace ⌧ has a race iff there is some ⌧ 0 2 feasible(⌧ ) which contains two consecutive events by different threads that access the same location, at least one of them corresponding to a write.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Events</head><p>The execution environment contains a set of concurrent objects (shared locations, locks, etc.), which are accessed by arbitrarily many threads to share data and synchronize. A concurrent object is behaviorally defined through a set of atomic operations and a serial specification of its legal behavior in isolation <ref type="bibr" target="#b16">[20]</ref>. For example, a shared memory location is a concurrent object with read and write operations, whose serial specification states that each read yields the same value as the one of the previous write. A (non-reentrant) lock is an object with acquire and release operations, whose serial specification consists of operation sequences in which the difference between the number of acquire and release operations is either 0 or 1 for each prefix, and all consecutive pairs of acquirerelease share the same thread. Virtually all concurrency constructs fall under this simple and general notion of concurrent object <ref type="bibr" target="#b16">[20]</ref> (including reentrant locks, fork/join, wait/notify, etc.).</p><formula xml:id="formula_0">Event ::= begin(t) | end(t) | write(t, x, v) | read(t, x, v) | acquire(t, l) | release(t, l) | fork(t, t 0 ) | join(t, t 0 ) | branch(t) t, t 0 2 Thread; x 2 Variable; l 2 Lock; v 2 Value</formula><p>Events are operations performed by threads on concurrent objects, abstracted as tuples of attribute-value pairs. For example, (thread = t 1, op = write, target = x, data = 1) is a write event by thread t1 to memory location x with value 1. When there is no confusion, we take the freedom to use any other meaningful notation for events; for example write(t1, x, 1). For any event e and attribute attr, attr(e) denotes the value corresponding to the attribute attr in e, and e[v/attr] denotes the event obtained from e by replacing the value of attribute attr by v. The theoretical results in this section hold for any types of events corresponding to any concurrent objects whose behaviors can be described with serial specifications. However, for clarity, we instantiate our subsequent notions and results to the following common event types:</p><p>• begin(t)/end(t): the first/last event of thread t;</p><p>• read(t, x, v)/write(t, x, v): read/write a value v on a variable x;</p><p>• acquire(t, l)/release(t, l): acquire/release a lock l;</p><p>• fork(t, t 0 ): fork a new thread t 0 ; • join(t, t 0 ): block until thread t 0 terminates;</p><p>In addition to the usual events above that have been extensively studied in previous work, we consider a new branch event:</p><p>• branch(t): jump to a new operation.</p><p>The semantics of this new type of event cannot be given as a serial specification. In fact, branch events can appear anywhere in the trace. Their formal semantics will be defined within the local determinism axiom shortly. To state briefly, the branch event serves as a guard of a possible control flow change, which determines the next operation to execute in a thread. The choice depends on some computation local to the thread, for example the result of an expression in a conditional statement, that is unknown in the event and is not visible to other threads. Hence, conservatively, we assume that the choice of branch(t) depends on all the previous read(t, x, v) operations executed by the same thread.</p><p>Figure <ref type="figure" target="#fig_1">3</ref> depicts all the event types discussed above and considered in the rest of the paper, highlighting the novel branch event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Traces</head><p>An execution trace is abstracted as a sequence of events. Given a trace ⌧ and any set S of concurrent objects, threads, or event types, we let ⌧ S denote the restriction of ⌧ to events involving one or more of the elements in S. For example, if o is a concurrent object then ⌧ o is the restriction of ⌧ to events involving o; if t is a thread then ⌧ t contains only the projection of ⌧ to events by thread t; ⌧ t,o is the projection of ⌧ to events by thread t involving object o; ⌧ t,read the projection to read events by thread t; etc. If e is an event in trace ⌧ then let ⌧e denote the prefix of ⌧ up to and including  e: if ⌧ = ⌧ 1e⌧2 then ⌧e is ⌧1e. Let lastop(⌧ ) be the last event of ⌧ corresponding to operation op; e.g., lastwrite(⌧ ) is the last write event of ⌧ .</p><formula xml:id="formula_1">initially x = y = z = 0 1. fork(t1,</formula><p>An interleaving of ⌧ is a trace ⌧ 0 such that ⌧ 0 t = ⌧ t for each thread t. Trace ⌧ is (sequentially) consistent iff ⌧ o satisfies o's serial specification for any object o <ref type="bibr" target="#b16">[20]</ref>. Despite its simplicity, this notion of consistency based on concurrent object serial specifications is quite general. If all the events considered are those in Figure <ref type="figure" target="#fig_1">3</ref>, then the consistency of ⌧ means precisely the following:</p><p>• Read Consistency A read event contains the value written by the most recent write event on the same memory location. Formally, if e is a read event of ⌧ then data(e) = data(lastwrite(⌧e target(e) )).</p><p>• Lock Mutual Exclusion Each release event is preceded by an acquire event on the same lock by the same thread, and each pair is not interleaved by any other acquire or release event on the same lock. Formally, for any lock l, if ⌧ l = e1e2 . . . en then op(e k ) = acquire for all odd indexes k  n, op(e k ) = release for all even indexes k  n, and thread(e k ) = thread(e k+1 ) for all odd indexes k with k &lt; n.</p><p>• Must Happen-Before A begin event can happen only as a first event in a thread and only after the thread is forked by another thread: for any event e = begin(t 0 ) in ⌧ , the trace ⌧ t 0 starts with e and there exists precisely one fork(t, t 0 ) event in ⌧e. An end event can happen only as the last event in a thread, and a join event can happen only after the end event of the joined thread: for any event e = end(t 0 ) in ⌧ , the trace ⌧ t 0 terminates with e; also, for any event e = join(t, t 0 ), the event end(t 0 ) is in ⌧e.</p><p>Since the branch events do not have serial specifications, they are allowed to appear anywhere in a trace without affecting the consistency of the trace. Figure <ref type="figure" target="#fig_2">4</ref> shows the (consistent) trace corresponding to our example in Figure <ref type="figure" target="#fig_0">1</ref>. Note that read and write to local data (i.e., r1, r2, r3) are not included, as they are not needed for race detection and are also expensive to track in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Feasibility Axioms</head><p>Consistency is a property of a trace alone, stating that all the serial specifications describing the legal behaviors of the involved concurrent objects are met. Any (complete or incomplete) trace produced by a running program is expected to be consistent. However, the various consistent traces that can be generated by a multithreaded program are not unrelated. Let feasible(P) be the set of all traces that can be produced by a hypothetical program P, which we call P-feasible traces. The most common characterizing axiom of feasible(P), rooted in Lamport's happens-before causality <ref type="bibr" target="#b18">[22]</ref> and Mazurkiewicz' trace theory <ref type="bibr" target="#b21">[25]</ref>, is to require feasible(P) be closed under consistent interleavings. For the trace in Figure <ref type="figure" target="#fig_2">4</ref>, e.g., this tells that consistent interleavings such as 1-6-2-3-4-5-7-8-9. . . and 1-2-6-3-4-5-7-8-9. . . , where we refer to events by their line numbers, are also P-feasible, regardless of the program P that generated the original trace. This axiom is, however, too strong. What we want is the weakest axioms of feasible(P), which will give the resulting concurrency error detection technique the largest coverage.</p><p>Two weaker axioms governing feasible(P) are proposed in <ref type="bibr" target="#b29">[33]</ref>: prefix closedness and local determinism. The former says that the prefixes of a P-feasible trace are also P-feasible. The latter says that each thread has a deterministic behavior, that is, only the previous events of a thread (and not other events of other threads) determine the next event of the thread, although if that event is a read then it is allowed to get its value from the latest write. Formally, if ⌧ 1e1, ⌧2 2 feasible(P) and ⌧1 thread(e 1 ) = ⌧2 thread(e 1 ) then (1) if ⌧2e1 is consistent then ⌧2e1 2 feasible(P), and (2) if op(e1) = read and there exists some event e2 with e2[data(e1)/data] = e1 and ⌧2e2 consistent, then ⌧2e2 2 feasible(P). Unlike the consistent interleavings axiom underlying the usual happens-before, these weaker axioms allow us to infer from the trace in Figure <ref type="figure" target="#fig_2">4</ref> that the consistent trace 1-6-7-8' is also P-feasible regardless of the program P that generated the original trace, where 8' is the event read(t2, y, 0) which reads 0, the value written initially to y, instead of 1 as the original event 8. Note, however, that the trace 1-6-7-8'-9 can not be inferred as P-feasible with the axioms and model in <ref type="bibr" target="#b29">[33]</ref> without control flow, because the projections of 1-6-7-8 and 1-6-7-8' to thread t2 are not equal. It would in fact be unsound to allow the trace 1-6-7-8'-9 to be inferred as P-feasible, because the read of 1 for y in event 8 may be part of the condition in a conditional statement in P, and the release event 9 generated by a branch that would not be taken if y were 0.</p><p>Our objective in the remainder of this section is to give the weakest possible axioms of feasibility that take into account our new branch events. Consider, for example, an assignment x = y + 1 inside a branch that has just been taken. The read of y and the write of x will happen unconditionally; other threads may at most change the data values of these events (in a sequentially consistent manner), but they cannot affect the existence of the events themselves. Moreover, the write of x event contains the same value, provided that the read of y event reads the same value. Similarly, the existence of concurrent operations inside the taken branch is conditioned only by global sequential consistency constraints, but not by the particular data values read or written by the current thread. Hence, the fact that the branch events alone determine the control flow in the original program allows us to significantly relax the requirement of the local determinism axiom of <ref type="bibr" target="#b29">[33]</ref> that traces ⌧ 1 and ⌧2 must have identical projections on e's thread t in order for ⌧1e P-feasible to determine the next event by t in the P-feasible extensions of ⌧2. Instead, we can now only require the two projections to be equal except for the data values in write and read events. However, since the branch and write events depend upon the evaluation of thread-local expressions which are not available in the execution trace, we conservatively assume that these events depend upon all the reads by the same thread.</p><p>Let F be a set of traces. Below we identify five axioms for F to be feasible. The intuition is that the set of traces that can be generated by a multithreaded program is such a feasible set.</p><formula xml:id="formula_2">Prefix Closedness F is prefix closed: if ⌧ 1⌧2 2 F then ⌧1 2 F.</formula><p>Prefix closedness ensures that events are generated in execution order, with the possibility of interleaving in-between any of them.</p><p>For the remaining axioms, suppose that ⌧ 1e1, ⌧2 2 F, that thread(e1) = t, and that ⌧1 t ⇡ ⌧2 t, where two traces are in the ⇡ relation, called data-abstract equivalence, iff they are equal except for the data values in read and write events. The next axioms state the thread-local determinism requirements. Specifically, they state that under the above thread-local data-abstract equivalence condition between ⌧ 1 and ⌧2, the trace ⌧2 can only continue with a well-determined event of t, which is data-abstract equivalent to e1.</p><p>Local Determinism Each event is determined by the previous events in the same thread and can occur at any consistent moment after them. There are four cases to distinguish:</p><p>• Branch. If op(e1) = branch and ⌧1 t,read = ⌧2 t,read , then</p><formula xml:id="formula_3">⌧2e1 2 F. • Read. If op(e1) = read and e2 is a (read) event such that e2[data(e1)/data] = e1 and ⌧2e2 is consistent, then ⌧2e2 2 F. • Write. If op(e1) = write then there is a v such that ⌧2e1[v/data] 2 F; moreover, if ⌧1 t,read = ⌧2 t,read then v = data(e1). • Other. If op(e1) 6 2 {branch, read, write} and ⌧2e1 is consistent, then ⌧2e1 2 F.</formula><p>DEFINITION 1. A set of traces F is feasible if it satisfies the prefix closedness and the local determinism axioms above.</p><p>In addition to all the consistent interleavings and feasible sets of traces according to <ref type="bibr" target="#b29">[33]</ref> derived from the trace ⌧ in Figure <ref type="figure" target="#fig_2">4</ref> discussed above, we can now show that any feasible F including ⌧ also includes many more other traces. For example, the trace 1-6-7-8'-9 with 8' the event read(t2, y, 0) which was not allowed before is allowed now as feasible, and so is the trace 1-6-7-8'-9-2-3-10, which shows a race on x by events 3 and 10. Note that there is no way to infer a trace in F that brings events 4 and 8 (race on y) or 12 and 15 (race on z) next to each other, because that would violate the lock-mutual exclusion or must happen-before consistency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Discussion</head><p>We have made two assumptions and adopted a deliberate limitation in our feasibility axioms above. First, we assumed that the branch events and the data values in write events depend only on the previous read events by the same thread. If there are other factors that determine these events in a particular language, such as random jumps or expressions, then one either needs to generate additional read events corresponding to those external factors or alternatively to explicitly consider them as special events and modify the axioms accordingly. Second, we assumed that all possible places where the control dependence may be changed are logged as explicit branch events, e.g., mutable pointer dereferences and array indexing. If there are implicit control flow points in a particular program that are activated by the data flow, such as an exception thrown when a division by zero is performed, then one needs to generate additional branch events after each such implicit control choice. Third, we conservatively assumed that each branch or write depends on all the previous read events by the same thread. In most cases branch and write events only depend on the values read within the evaluation of a particular expression. We could get even weaker axioms if we assumed a preceding window of events for each write and branch in which the read values matter for these events, but that would involve more complex events and axioms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Sound and Maximal Causal Model</head><p>Our objective here is to associate to any given consistent trace ⌧ a sound and maximal causal model, feasible(⌧ ), comprising precisely all the traces that can be generated by any program that can generate ⌧ . It is irrelevant at this stage how we represent such a model; in Section 3 we show a way to represent it by means of logical constraints. Soundness means that any program P that can produce ⌧ can also produce any of the traces of feasible(⌧ ).</p><p>Maximality means that for any trace ⌧ 0 which is not in feasible(⌧ ) there is some program P which can produce ⌧ but not ⌧ 0 .</p><p>Following <ref type="bibr" target="#b29">[33]</ref> (there without control flow), a natural choice for feasible(⌧ ) would be the smallest set of traces that includes ⌧ and is closed under the feasibility axioms. However, that simplistic approach does not work here, mainly because of the local write determinism axiom (Section 2.3): it would be unsound to pick any particular value v in the write event, because we have no further information about the program that generated the original trace ⌧ and thus it is impossible to know how it computes the written value. To avoid picking any particular value v, we instead modify the second case of the local data-abstract determinism axiom to introduce (fresh) symbolic values. We keep all the other axioms in Section 2.3 unchanged, but note that traces appearing in feasible(⌧ ) can contain symbolic values in their read and write events. For that reason, we call the new local determinism axioms local symbolic determinism. We use the symbolic axiom variant only to define our maximal causal model; for abstractions of programs P as their sets of traces we continue to use the non-symbolic axiom variant in Section 2.3. For clarity, below we give the formal definition of feasible(⌧ ).</p><p>Let Sym be an infinite set of symbolic values. For technical reasons we assume that given any trace ⌧ , we can always pick an arbitrary but fixed symbolic value sym ⌧ which is distinct from any other similar symbolic value: if</p><formula xml:id="formula_4">⌧1 6 = ⌧2 then sym ⌧ 1 6 = sym ⌧ 2 .</formula><p>DEFINITION 2. Given a consistent trace ⌧ , let feasible(⌧ ) be the feasibility closure of ⌧ defined as the smallest set of (symbolic) traces that includes ⌧ and is closed under the following operations:</p><formula xml:id="formula_5">1. Prefixes. if ⌧1⌧2 2 feasible(⌧ ) then ⌧1 2 feasible(⌧ ). 2. Local symbolic determinism. Assume that ⌧1e1, ⌧2 2 feasible(⌧ ),</formula><p>that thread(e1) = t, and that ⌧1 t ⇡ ⌧2 t. Then • Branch. If op(e1) = branch and ⌧1 t,read = ⌧2 t,read then ⌧2e1 2 feasible(⌧ ). • Read. If op(e1) = read and e2 is such that e2[data(e1)/data] = e1 and ⌧2e2 is consistent, then ⌧2e2 2 feasible(⌧ ). A trace in feasible(⌧ ) is called ⌧ -feasible.</p><p>It can be easily seen that for any mapping ✓ of symbolic values to concrete values, ✓(feasible(⌧ )) is a feasible set of traces, in the sense of Definition 1. Recall that we abstract multithreaded programs as feasible sets of traces, namely all complete or incomplete traces that they can produce when executed. We can think of feasible(⌧ ) as an abstract representation of all causal dependencies revealed by ⌧ in all programs that can produce ⌧ when executed, each ✓ corresponding to such a program. This intuition will be formally captured below, by our soundness and maximality results.</p><p>The next result states the soundness of our causal model: THEOREM 1 (Soundness). Suppose that F is a feasible set of (concrete) traces, like in Definition 1, and that ⌧ 2 F is a consistent trace. Then there exists a mapping ✓ of symbolic values into concrete values such that ✓(feasible(⌧ )) ✓ F.</p><p>PROOF: Since feasible(⌧ ) is the smallest set of traces closed under prefixes and the local symbolic determinism axioms in Definition 2, we can order the traces in feasible(⌧ ), say ⌧ 0 = ⌧ , ⌧ 1 , . . . , ⌧ n , . . . for n 2 N, so that each trace ⌧ n+1 can be derived from one (if a prefix) or from two (if a locally deterministic continuation) of the traces ⌧ 0 , ⌧ 1 , . . . , ⌧ n . We construct by induction on n a sequence of partial mappings</p><formula xml:id="formula_6">✓ 0 = ? v ✓1 v ✓2 v • • • v ✓n v • • • taking symbolic to concrete values, where f v g iff Dom(f ) ✓ Dom(g) and f (s) = g(s)</formula><p>for each s 2 Dom(f ), such that ✓n(⌧ n ) 2 F for all n 2 N. Note that ✓i(⌧ i ) = ✓j(⌧ i ) for any i  j. Then the result immediately holds, because we can take ✓ to be the least upper bound (lub) of the chain of these partial functions, F n2N ✓n. If n = 0 then we pick ✓0 = ?; since ⌧ 0 = ⌧ 2 F is a concrete trace, ✓0(⌧ 0 ) = ⌧ 0 2 F. Now suppose that the desired property holds for all indexes less than or equal to n, and let us prove it for n + 1. If ⌧ n+1 is derived as a prefix of some ⌧ 0 2 {⌧ 0 , ⌧ 1 , . . . , ⌧ n }, then let ✓n+1 be ✓n. By the induction hypothesis, ✓n(⌧ 0 ) 2 F, so ✓n+1(⌧ n+1 ) = ✓n(⌧ n+1 ) 2 F because F is prefix closed (Definition 1). If ⌧ n+1 is derived using a local symbolic determinism axiom, there there must exist two traces ⌧ 1e1, ⌧2 2 {⌧ 0 , ⌧ 1 , . . . , ⌧ n } such that ⌧1 t ⇡ ⌧2 t, where t = thread(e1). By the induction hypothesis, ✓n(⌧1e1), ✓n(⌧2) 2 F. Note also that ✓n(⌧1) t ⇡ ✓n(⌧2) t. If op(e1) = branch then it must be the case that ⌧1 t,read = ⌧2 t,read , so ✓n(⌧1) t,read = ✓n(⌧2) t,read , and that ⌧ n+1 = ⌧2e1. Let ✓n+1 be ✓n. Then ✓n+1(⌧ n+1 ) = ✓n(⌧2)e1 2 F because of the local branch determinism of F (Definition 1). If op(e1) = read then it must be the case that there is some event e2 such that e2[data(e1)/data] = e1, so ✓n(e2)[data(✓n(e1))/data] = ✓n(e1), ⌧2e2 is consistent, so ✓n(⌧2)✓n(e2) is consistent, and ⌧ n+1 = ⌧2e2. Let ✓n+1 be ✓n. Then ✓n+1(⌧ n+1 ) = ✓n(⌧2)✓n(e2) 2 F because of the local read determinism of F. Now suppose that op(e1) = write. There are two cases to distinguish. If ⌧1 t,read = ⌧2 t,read then it must be the case that ⌧ n+1 = ⌧2e1. In this case we let ✓n+1 be ✓n and ✓n+1 2 F follows similarly to the previous cases. If ⌧1 t,read 6 = ⌧2 t,read then it must be the case that ⌧ n+1 = ⌧2e1[sym ⌧ 2 /data]. By the local write determinism of F (Definition 1), there is some value v such that ✓ n(⌧2)✓n(e1)[v/data] 2 F. In this case we pick ✓n+1 to be equal to ✓n in all symbolic values in which ✓n is defined, and ✓n+1(sym ⌧ 2 ) = v. Note that ✓n+1 is well-defined because of our assumption that sym ⌧ 2 is uniquely determined by ⌧2. Finally, if op(e1) 6 2 {branch, read, write} then it must be the case that ⌧2e1 is consistent, so ✓n(⌧2)✓n(e1) is consistent, and that ⌧ n+1 = ⌧2e1. In this case we can again let ✓n+1 be ✓n. Then ✓n+1(⌧ n+1 ) = ✓n(⌧2)✓n(e1) 2 F also by the feasibility of F . ⇤ In words, the soundness theorem says that if a hypothetical program P (abstracted above by the complete or incomplete traces in F that it can produce) generates a trace ⌧ , then any ⌧ -feasible trace, which may contain symbolic data values, corresponds to some concrete trace ⌧ 0 that P can also generate, obtained by instantiating the symbolic values with some concrete ones. Therefore, if a dynamic error detection technique is based on our maximal causal model, say a data race detector, then any error reported by the technique is a real error, which can happen under a different thread schedule.</p><p>The next result states the maximality of our sound causal model: THEOREM 2 (Maximality). Suppose that ⌧, ⌧ 0 are concrete traces such that ⌧ is consistent and ⌧ 0 6 2 ✓(feasible(⌧ )) for any ✓ mapping symbolic values to concrete values. Then there is a multithreaded program P with ⌧ 2 feasible(P) and ⌧ 0 6 2 feasible(P).</p><p>PROOF: To refer to programs and their execution traces, we formally define a simple programming language that can produce all the events that we consider in our traces, noting that other events can similarly be supported and that this language is so basic that its instructions can easily be reproduced in any other language. The formal definition of the language is then used to show that the set of traces that any program P can produce when executed, feasible(P), is indeed a feasible set in the sense of Definition 1. Finally, given a consistent trace ⌧ we construct a program P ⌧ such that feasible(P⌧ ) ✓ S ✓ ✓(feasible(⌧ )). We next detail the above.</p><p>For brevity, we here describe the language and its semantics informally. The language has threads which can be forked and joined, (non-reentrant) locks which can be acquired and released, and both shared and thread-local variables. Shared variables can only be read and written with simple assignments r := x and x := r, respectively, where r is a local and x is shared. The trace semantics of the language is that all statements of the language produce corresponding events when executed, except for reads and writes of local variables. Complex assignments of the form r := (r 1 == v1)&amp;&amp; • • • &amp;&amp;(rn == vn)?v : v 0 are also allowed, where r, r1, ..., rn are locals and v1, ..., vn, v, v 0 are values, with the meaning that if ri equals vi for all 1  i  n then r takes the value v, otherwise v 0 . However, these generate no events. Finally, we also introduce a simple conditional statement to account for branch events: if(r). Its semantics is that it produces a branch event and the execution continues only if local variable r is 1; otherwise the execution gets stuck without a branch event. Using the language semantics, it is relatively easy (albeit tedious) to define the set feasible(P) of all complete or incomplete traces of a program P, and to show that it satisfies the feasibility axioms in Definition 1.</p><p>The only thing left is to construct a particular program P ⌧ from a consistent trace ⌧ such that feasible(P⌧ ) ✓ S ✓ ✓(feasible(⌧ )), where the union goes over all mappings ✓ from symbolic to concrete values. The idea is to traverse the trace ⌧ and generate the program P⌧ by replacing each event in ⌧ with one or more corresponding instructions in P⌧ . We discuss the read, write and branch events last. Each fork(t1, t2) event generates a corresponding fork statement in thread t1, making sure that all subsequent events of thread t2 are used to generate instructions in the forked thread. Similarly, each join(t1, t2) event generates a corresponding join statement in thread t1. Events acquire(t, l) and release(t, l) generate corresponding acquire and release instructions of lock l in thread t, and similarly for wait/notify events. The interesting events are the reads, writes and branches. For each event read(t, x, v), we generate an assignment statement r := x, where r is a fresh local variable that we keep track of in the generation algorithm that it is paired with value v. For each event write(t, x, v) we generate two instructions in thread t, r := (r 1 == v1)&amp;&amp; • • • &amp;&amp;(rn == vn)?v : v 0 x := r where (r1, v1), ..., (rn, vn) are all the pairs between a local variable and a value corresponding to read events as above that the generation algorithm stored for thread t so far, and where v 0 is a value distinct from v. Finally, for events branch(t) we generate the following instructions in thread t: r := (r 1 == v1)&amp;&amp; • • • &amp;&amp;(rn == vn)?1 : 0 if(r) In both cases above, the complex assignment ensures that r gets the expected value only if the thread's read history is the same as that in the original trace ⌧ . In the case of write, if that is the case then the precise value v that appeared in ⌧ is written, which accounts for the first case of the local write determinism axiom before Definition 1; otherwise a different value v 0 is written, which accounts for the second case of the local write determinism axiom. We need not worry about which particular value v 0 should be written to avoid having ⌧ 0 as a possible trace, because ⌧ 0 6 2 ✓(feasible(⌧ )) for any ✓ guarantees that no v 0 has this property. In the case of branch, the thread is allowed to continue only if its read history is identical to that of ⌧ ; otherwise the thread gets stuck without issuing a branch event. This accounts for the local branch determinism axiom.</p><p>The generated program P ⌧ is therefore quite simple, its instructions corresponding almost identically to the trace ⌧ and having no loops; in fact, our simple language is not even Turing-complete. Using the language semantics we can show that ⌧ 2 feasible(P⌧ ), and also that any trace ⌧ 00 in feasible(P⌧ ) is included in ✓(feasible(⌧ ))</p><p>for some mapping ✓ of symbolic to concrete values; specifically, it is a ✓ that maps symbolic values sym ⌧ 2 introduced by the second case of the local write determinism of the feasibility closure (see Definition 2) to (arbitrarily chosen) concrete values v 0 as in the corresponding instructions associated to the write event. Therefore, feasible(P⌧ ) ✓ S ✓ ✓(feasible(⌧ )), so P⌧ is such a multithreaded program P with ⌧ 2 feasible(P) and ⌧ 0 6 2 feasible(P). ⇤</p><p>In words, the maximality theorem says that for any concrete trace ⌧ 0 which is not an instance of a (possibly symbolic) ⌧ -feasible trace, there exists a "witness" program P that can produce ⌧ but not ⌧ 0 . Therefore, any dynamic error detection technique that produces counterexample traces which are not instances of ⌧ -feasible traces, must be unsound: there are programs for which they report false alarms. Of course, our soundness and maximality results are intrinsically based on the assumption that the traces generated by multithreaded programs obey our feasibility axioms for sequential consistency<ref type="foot" target="#foot_0">1</ref> (see also the discussion at the end of Section 2.3), and the statements of the target multithreaded programming language have the granularity of our events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Maximal Causal Properties</head><p>The existence of a maximal causal model allows us to define maximal variants of concurrency properties, such as races, atomicity, etc. In this paper we only focus on races, but the same maximal causal model approach can be used to define other notions. Consider again the trace ⌧ in Figure <ref type="figure" target="#fig_2">4</ref>. There are three conflicting pairs: COP(3, 10), COP(4, 8), and COP <ref type="bibr" target="#b8">(12,</ref><ref type="bibr" target="#b11">15)</ref>. However, only COP(3, 10) is a race because, as previously discussed, there is a consistent trace 1-6-7-8'-9-2-3-10 2 feasible(⌧ ), with 8' = read(t2, y, 0), in which event 3 is immediately before 10, and there is no way to bring events 4 and 8 (race on y) or 12 and 15 (race on z) next to each other without breaking consistency.</p><p>Theorem 1 implies that our notion of a race above is sound, so any dynamic race detection technique reporting only races among those in Definition 4 is sound (no false alarms). However, the key feature of our definition of a race is its maximality: the witness of the race in ⌧ is a (possibly symbolic) trace ⌧ 0 that belongs to the maximal causal model of ⌧ ; note that the symbolicity of ⌧ 0 is irrelevant for races. Therefore, any sound (not necessarily maximal) dynamic race detection technique can detect no races which are not captured by Definition 4. A technique that can detect precisely all the races in Definition 4, like our technique presented shortly in Section 3, is therefore both sound and maximal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Maximal Dynamic Race Detection</head><p>This section presents our technique for maximal dynamic race detection. We first give an illustrative technical overview, followed by the formal modeling of our technique based on the maximal causal model foundation presented in Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Technical Overview</head><p>Given an input trace ⌧ , the goal of dynamic race detection is to find a ⌧ -feasible trace ⌧ next to each other in ⌧ 0 (Definition 4). Since here we only discuss race detection, where the particular values written or read by events are irrelevant, to simplify the presentation we make no distinction between an event that appears in ⌧ and its data-abstractly equivalent variants appearing in ⌧ -feasible traces. We formulate the maximal race detection problem as a constraint solving problem. Specifically, we introduce an order variable O e for each event e in ⌧ , which represents the order of e in ⌧ 0 . Then we generate a formula over these variables corresponding to the race problem for ⌧ and COP(a, b), that is, one which is satisfiable iff O b Oa = 1 for some ⌧ 0 2 feasible(⌧ ). By solving using any constraint solver, we are able to determine whether (a, b) is a race or not.</p><p>For concreteness, we only consider the common concurrent objects that yield the event types in Figure <ref type="figure" target="#fig_1">3</ref>, whose serial specifications generate the consistency requirements spelled out at the end of Section 2.2. Figure <ref type="figure" target="#fig_4">5</ref> shows our constraint modeling of the example trace in Figure <ref type="figure" target="#fig_2">4</ref>. Let O i refer to the order variable of the event at line i. The constraints consist of three parts: (A) the must happen-before (MHB) constraints, (B) the locking constraints, and (C) the race constraints. A and B are common for all races, whereas C is race specific. For instance, the MHB constraints for the fork event at line 1 and the join event at line 14 are written as O 1 &lt; O6 ^O14 &gt; O13, meaning that the fork event should happen before the begin event of t2 at line 6, and the join event should happen after the end event of t2 at line 13, which are determined by the must happen-before consistency requirement in Section 2.2.</p><p>The locking constraints encode lock mutual exclusion consistency over acquire and release events. For example, O 5 &lt; O7 _ O9 &lt; O2 means that either t1 acquires the lock l first and t2 second, or t2 acquires l first and t1 second. If t1 first, then the acquire at line 7 must happen after the release at line 5; otherwise if t2 first, the acquire at line 2 should happen after the release at line 9.</p><p>The race constraints encode the race and control flow conditions specific to each COP. For example, for the COP (3,10), the race constraint is written as O 10 O3 = 1, and its control-flow condition is empty, because there is no branch event before the two events at lines 3 and 10. For <ref type="bibr" target="#b8">(12,</ref><ref type="bibr" target="#b11">15)</ref>, however, because there is a branch event (at line 11) before line 12, in addition to the race constraint O 15 O12 = 1, we need to ensure that the controlflow condition at the branch event is satisfied. To respect the local branch determinism axiom in Section 2.3, we require that all read events by t2 before this branch event read the same value as that in the original trace. Hence, we add the control-flow constraints O 3 &lt; O10 ^O4 &lt; O8 to ensure that the read event at line 10 reads value 1 on x, and that the read event at line 8 reads value 1 on y. This guarantees that the event at line 12 is feasible.</p><p>Putting all these constraints together, we invoke an SMT solver, such as Z3 <ref type="bibr" target="#b7">[11]</ref> or Yices <ref type="bibr" target="#b8">[12]</ref> in our current implementation, to compute a solution for these unknown order variables. For (3,10), the solver returns a solution which corresponds to the schedule 1-6-7-8-9-2-3-10, so (3,10) is a race. For <ref type="bibr" target="#b8">(12,</ref><ref type="bibr" target="#b11">15)</ref>, the solver reports no solution exists, so it is not a race.</p><p>The above example illustrates how our technique works in a nutshell. We present our implementation and optimization details in Section 4. We next formalize our constraint modeling in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Constraint Modeling</head><p>As mentioned, given an observed trace ⌧ , we encode the maximal race detection problem as a formula specifying all the ⌧ -feasible traces with respect to each race. contains only variables of the form O e corresponding to events e, which denote the order of the events in the to-be-computed ⌧ -feasible trace (if there exists one) that can manifest the race. Although we define a race of ⌧ as a property over the maximal causal model feasible(⌧ ) (Definition 4), for performance reasons we purposely do not follow the same approach here when generating the constraints. That is because the characterizing formula of feasible(⌧ ) would be unnecessarily complex for the bare task of detecting races, e.g., it would need to generate constraints for all branches, not only for those immediately guarding the events in a COP, and to account for the fact that the constraints corresponding to events following an invalidated branch do not influence the overall formula satisfiability. Thus, is constructed by a conjunction of three sub-formulae:</p><formula xml:id="formula_7">= mhb ^ lock ^ race MHB Constraints ( mhb )</formula><p>The must happen-before (MHB) consistency requirements discussed at the end of Section 2.2 cover all the trace consistency requirements except for those of the read/write and acquire/release events (which we treat differently). MHB, together with the total orders of the events in each thread, yield an obvious partial order on the events of ⌧ which must be respected by any ⌧ -feasible trace. Fortunately, can be specified quite easily as constraints over the O variables: we start with mhb ⌘ true and conjunct it with a constraint Oe 1 &lt; Oe 2 whenever e1 and e2 are events by the same thread and e1 occurs before e2, or when e1 is an event of the form fork(t, t 0 ) and e2 of the form begin(t 0 ), etc. We assume a background first-order theory where &lt; is transitive, like in Z3 and Yices, so we do not need to encode the transitivity of . The size of mhb is linear in the length of ⌧ .</p><p>Note that our MHB differs from Lamport's happens-before <ref type="bibr" target="#b18">[22]</ref> in two aspects: (1) read and write events by different threads are not included, because their order may be consistently commutable; (2) acquire and release events are not included, because the order between different lock regions may also be consistently commutable.</p><p>Locking Constraints ( lock ) Lock mutual exclusion consistency (Section 2.2) requires that two sequences of events protected by the same lock do not interleave. lock captures the ordering constraints over the lock acquire and release events. For each lock l, we extract the set S l of all the corresponding pairs (a, r) of acquire/release events on l, following the program order locking semantics: the release is paired with the most recent acquire on the same lock by the same thread. Then we conjunct lock with the formula (a,r),(a 0 ,r</p><formula xml:id="formula_8">0 )2S l (Or &lt; O a 0 _ O r 0 &lt; Oa)</formula><p>which is quadratic in the number acquire/release events on l in ⌧ .</p><p>Race Constraints ( race) For a COP(a, b), race contains two categories of constraints: the arithmetic constraint O b Oa = 1 that specifies the race condition, and a conjunction of two control-flow constraints ⇡ cf (a) ^ ⇡ cf (b) specifying the data-abstract feasibility of a and b. We next define ⇡ cf (e) for any read/write event e. Recall the local determinism axioms that the events appearing in ⌧ -feasible traces follow a deterministic order when projected on their thread, but the data values in read and write events are allowed to be different from those in ⌧ , in order to satisfy the read consistency requirement of the ⌧ -feasible trace. Making abstraction of the particular data values in read/write events, the only factor that can affect the feasibility of such an event e, in addition to the MHB and lock consistency requirements which are already encoded as detailed above, is that some event e 0 that must happen before e, i.e., e 0 e, is infeasible because of a previous branch by the same thread that is infeasible. Because of the local branch determinism axiom, the feasibility of a branch is determined by the complete read history of its thread, so we only need to consider the feasibility of the last branch event of each thread that must happen before e. Let B e be the set of last branch events e 0 of each thread with e 0 e. Then let</p><formula xml:id="formula_9">⇡ cf (e) = V e 0 2Be</formula><p>cf (e 0 ), op(e) 2 {read, write} be the formula stating that the data-abstract feasibility of a read or write event e reduces to the feasibility of all the branch events in Be. We next model the concrete feasibility of any read, write, or branch event e as a formula cf (e), where "concrete" means that e appears unchanged, including its data value, in the ⌧ -feasible trace.</p><p>According to the local branch and write determinism axioms, the concrete feasibility of branch and write events is determined by the complete read history of their thread, that is,</p><formula xml:id="formula_10">cf (e) = V r2⌧e t,read cf (r),</formula><p>op(e) 2 {branch, write}, t = thread(e)</p><p>So far, we have straightforwardly encoded the axioms of the maximal causal model in Section 2 using constraints. The part which does not follow explicitly from the axioms is how to encode the concrete feasibility of read events (needed in formula above). We need to ensure that a read(t, x, v) event reads the same value v written by a concretely feasible write( , x, v) event (" " means any thread). Specifically, if for a read event r, say read(t, x, v), we let W r be the set of write( , x, ) events in ⌧ , and W r v the set of write( , x, v) events in ⌧ , then we define the following:</p><formula xml:id="formula_11">cf (r) = W w2W r v ( cf (w) ^Ow &lt; Or V w6 =w 0 2W r (O w 0 &lt; Ow _ Or &lt; O w 0 ))</formula><p>The above states that the read event r = read(t, x, v) may read the value v on x written by any write event w = write( , x, v) in W r v (the top disjunction), subject to the condition that the order of w is smaller than that of r and there is no interfering write( , x, ) in between. Moreover, w itself must be concretely feasible, which is ensured by cf (w).</p><p>The size of cf , in the worst case, is cubic in the number of read and write events in ⌧ . Nevertheless, in practice, the size of cf can be significantly reduced by taking into consideration. Consider two write events w1 and w2 in W r v . If w1 w2 r, we can exclude w1 from W r v because it is impossible for r to read the value written by w1 due to the read consistency axiom. Similarly, for any w 0 2 W r , if r w 0 , then w 0 can be excluded from W r . Also, when constructing the constraints for matching an event w 2 W r v to r, if w 0 w, then w 0 can be skipped.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Soundness and Maximality</head><p>Our race detection technique above is sound and maximal. Soundness means every detected race is real. Maximality means that our technique does not miss any race that can be detected by any sound dynamic race detector based on the same trace.</p><p>It suffices to prove the following:</p><p>THEOREM 3 (Soundness and maximality). If is the first-order constraint associated to a given trace ⌧ as above, then is satisfiable iff (a, b) is a race in ⌧ in the maximal sense of Definition 4.</p><p>PROOF: Suppose that ⌧ = e1e2 . . . en. Note that ⇢ |= for some ⇢ : {Oe 1 , Oe 2 , . . . , Oe n } ! N iff ⇢ 0 |= for a bijective ⇢ 0 : {Oe 1 , Oe 2 , . . . , Oe n } ! {1, 2, . . . , n}. That is because the particular values assigned to the O variables are irrelevant, except for the race constraint O b Oa = 1, so we can find an ordering of ⇢(e1), ⇢(e2), ...⇢(en) such that ⇢(a) is followed by ⇢(b). Therefore, from here on we can only consider valuations of the form ⇢ : {Oe 1 , Oe 2 , . . . , Oe n } ! {1, 2, . . . , n}. Any ⇢ yields the permutation e ⇢(O 1 ) e ⇢(O 2 ) . . . e ⇢(On) of ⌧ , which we write <ref type="bibr">[⇢]</ref>.</p><p>It is easy to see that ⇢ |= mhb iff [⇢] satisfies the must happen-before consistency requirements, and that ⇢ |= lock iff [⇢] satisfies the lock mutual exclusion requirements. We can also show by induction on i that for any event ei of ⌧ with op(ei) 2 {branch, read, write} and t = thread(ei), it is the case that ⇢ |= cf (ei) iff [⇢]e i t,read = ⌧e i t,read and any read event in these trace projections satisfies the read consistency requirement in [⇢]e i : for branch and write events, the definition of cf reduces the property to previous read events, and for read events the definition of cf reduces the property to previous write events.</p><p>Let us first prove the soundness, that is, that if is satisfiable then (a, b) is a race in ⌧ . Let ⇢ |= . Then by the properties above and the definitions of ⇡ cf and of cf , the following hold: [⇢] satisfies the must happen-before and lock mutual exclusion consistency requirements; [⇢] b = [⇢]ab; and for all e 0 2 Ba, if t = thread(e 0 ) then [⇢] e 0 t,read = ⌧ e 0 t,read . We can then inductively build a trace ⌧1 over data-abstract variants of the events in the set {e | e a}, traversing them in the order they occur in [⇢], as follows, where e is the next such event: if e is not a read or a write then append it to ⌧1; if e is a read then to ensure read consistency we need to possibly change its value to the value written by the last event in ⌧1 so far, and then append e to ⌧1; if e is a write event then (1) if ⇢ |= cf (e) then append e to ⌧1, otherwise (2) change the value of e to the symbolic value sym ⌧ 1 and then append it to ⌧1. All the steps above preserve the consistency of ⌧1 and accord with the local determinism axioms characterizing feasible(⌧ ), so we can deduce that ⌧1 2 feasible(⌧ ). We can now extend ⌧1 with (possibly dataabstract variants of) a and b similarly to the above, and thus obtain that ⌧1ab 2 feasible(⌧ ), so (a, b) is a race in ⌧ .</p><p>Let us now show the maximality, that is, that if (a, b) is a race in ⌧ then is satisfiable. Let ⌧1ab 2 feasible(⌧ ) and let ⌧2 be the trace formed with the remaining elements of ⌧ , in the order in which they appeared in ⌧ . Although the trace ⌧ 0 = ⌧1ab⌧2 may not be ⌧ -feasible, it still respects the must-happen before and lock mutual exclusion consistency requirements. Let ⇢ be the valuation with [⇢] = ⌧ 0 . Then clearly ⇢ |= mhb ^ lock ^Ob Oa = 1. Since ⌧1ab is ⌧ -feasible, prefix closedness ensures that [⇢] e 0 is also ⌧ -feasible for each branch event e 0 2 Ba; the local branch determinism axiom then implies that [⇢] e 0 t,read = ⌧ e 0 t,read , so by the property above and the definition of ⇡ cf we conclude that ⇢ |= ⇡ cf (a). We can similarly show ⇢ |= ⇡ cf (b), so ⇢ |= . ⇤</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Implementation</head><p>We have implemented our technique in RVPredict, a runtime predictive analysis system for Java. Although the Java memory model (JMM <ref type="bibr" target="#b19">[23]</ref>) is not sequentially consistent, it does not affect the soundness of our implementation as any race in a sequential consistency model should also be a race in JMM. To properly model the Java language constructs (i.e., to ensure that the Java execution conforms to our abstract model), we make the following treatments in our implementation:</p><p>• branch -the branch events include not only explicit control flow statements, but also implicit data flow points that can affect the control flow. For example, both shared pointer dereferences (e.g., calling a method of a shared object) and array indexing statements (e.g., read/write to an array with a non-constant index) are considered as additional branch events.</p><formula xml:id="formula_12">initially x=0 Thread t1 Thread t2 1. lock l 2. a[x] = 2 3. unlock l 4. lock l 5. x = 1 6. unlock l 7. a[0] = 1</formula><p>Consider this program executed following the order of line numbers. Lines 2 and 7 are unordered and they both access a[0]. However, (2,7) is not a race, because if line 2 is scheduled next to line 7, line 2 will access a[1] instead of a[0]. Hence, we must ensure the same implicit data-flow for array accesses.</p><p>• wait-notify -Java's wait() and notify()/notifyAll() are usually not discussed in previous studies <ref type="bibr" target="#b14">[18,</ref><ref type="bibr" target="#b31">35]</ref>. In our implementation, we treat wait() as two consecutive release-acquire events, notifyAll() as multiple notify() where the number is equal to the number of currently waiting threads on the same signal, and keep a mapping from wait() to its corresponding notify() in the original execution. In the constraint, we ensure the order of the notify() is between that of the two consecutive release-acquire events of the corresponding wait(), but not between that of any other wait() on the same signal (to ensure that the notify() is matched with the same wait() as that in the original execution). Currently, we do not model spurious wakeups and lost notifications in our implementation. However, since they happen rarely in practice, this does not limit the usability of RVPredict. • re-entrant locking -To simplify the constraint, re-entrant lock acquire/release events are filtered out dynamically in the execution, i.e., discarding all but the outermost pair of acquire/release events on the same lock. • volatile variables -as concurrent conflicting accesses to volatile variables are not data races in Java, we do not report them.</p><p>RVPredict consists of two main phases: trace collection and predictive race analysis. In trace collection, we log a sequentially consistent trace of shared data accesses, thread synchronizations, and branch events. To support long running programs, traces are first stored event by event into a database. Note that trace collection can be performed at various levels, e.g., via static or dynamic code instrumentation, inside the VM, or at the hardware level. As trace collection is not our main concern here, our implementation is based on static instrumentation and is not optimized. Nevertheless, ideally, we can use hardware tracing techniques to minimize the runtime perturbation. In predictive race analysis, we first use a hybrid lockset and weaker HB algorithm (similar to PECAN <ref type="bibr" target="#b17">[21]</ref>) to perform a quick check on each conflicting operation pair (COP). Only if a COP passes the quick check, do we proceed to build constraints for it.</p><p>To optimize the constraint solving, instead of adding a conjunction O b Oa = 1 for each COP(a, b), we simply replace Oa by O b in the constraints. In this way, all constraints become simple ordering comparisons over integer variables, which can be solved efficiently using the Integer Difference Logic (IDL) (provided in both Z3 <ref type="bibr" target="#b7">[11]</ref> and Yices <ref type="bibr" target="#b8">[12]</ref>). We set the default constraint solving time to one minute for each COP. If the solver returns a solution within one minute, we report a race. In addition, to avoid redundant computation on races that have the same signature (from the same program locations), once a COP is reported as a race, we prune away all the other COPs with the same signature with no further analysis.</p><p>Handling long traces From an engineering perspective, handling long traces is challenging for any race detection technique. For real world applications, the trace is often too large to fit into the main memory. Moreover, for our approach, the generated constraints for long traces can be difficult to solve. Even with a high performance solver like Z3 or Yices, the constraints may still be too heavy to solve in a reasonable time budget. For practicality, we employ in RVPredict a windowing strategy similar to CP <ref type="bibr" target="#b31">[35]</ref>. We divide the trace into a sequence of fixed-size windows (typically 10K events in a window) and perform race analysis on each window separately. This simple strategy has two advantages for performance optimization: First, each time only a window size of events are processed, which can be easily loaded in memory. Second, the generated constraints for a window instead of the whole trace become much smaller, so that Z3 and Yices can solve them much easier. The downside of this strategy is that a race between operations in different windows will not be detected. Fortunately, because the likelihood for two operations to race dramatically decreases when the distance between them gets larger, we did not find many such cases in practice. Moreover, this windowing strategy does not affect the soundness of our implementation. All detected races by RVPredict are real, i.e., it does not report any false positive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Evaluation</head><p>Our evaluation aims to answer the following research questions: 1. Race detection capability -How many races can our technique detect in popular benchmarks and real world systems? As our technique is maximal, how many more races can it detect than the other state-of-the-art sound but non-maximal techniques? 2. Scalability -How efficient is our technique? Can it scale to real world executions?</p><p>To properly compare our technique with the state-of-the-art, we have also implemented HB <ref type="bibr" target="#b18">[22]</ref>, CP <ref type="bibr" target="#b31">[35]</ref>, and Said et al. <ref type="bibr" target="#b26">[30]</ref> in RVPredict. We attempted to conduct an unbiased comparison and faithfully implemented the techniques according to their representative publications <ref type="bibr" target="#b18">[22,</ref><ref type="bibr" target="#b26">30,</ref><ref type="bibr" target="#b31">35]</ref>. All our implementations are available at http://fsl.cs.illinois.edu/rvpredict/.</p><p>We evaluated these techniques on an extensive collection of widely used multithreaded benchmarks as well as several real world large concurrent systems, mostly from previous studies <ref type="bibr" target="#b1">[5,</ref><ref type="bibr" target="#b6">10,</ref><ref type="bibr" target="#b13">17,</ref><ref type="bibr" target="#b14">18,</ref><ref type="bibr" target="#b17">21,</ref><ref type="bibr" target="#b26">30,</ref><ref type="bibr" target="#b31">35,</ref><ref type="bibr" target="#b32">36]</ref>. To perform a fair comparison, for each benchmark, we collected one trace and ran different techniques on the same trace. To evaluate with long traces, because all techniques (including HB and CP) need the windowing strategy to scale, for all techniques and all benchmarks, we set the window size to 10K. This is sufficient to cover the traces of small benchmarks and at the same time to ensure that for large traces all techniques can finish within a reasonable time.</p><p>All experiments were conducted on a 8-core 3.50GHz Intel i7 machine with 32G memory and Linux version 3.2.0. The JVM is OpenJDK 1.7.0 64-Bit Server with 32G heap space. We next discuss our experimental results in detail as reported in Table <ref type="table" target="#tab_2">1</ref>.</p><p>Benchmarks and Traces Columns 1-2 list our benchmarks. The total source lines of code of these programs is more than 1.7M. The first row shows our example program in Figure <ref type="figure" target="#fig_0">1</ref>; the second set of small benchmarks are from IBM Contest benchmark suite <ref type="bibr" target="#b13">[17]</ref>; the third set contains three popular multithreaded Java Grande benchmarks; the last set contains real world large applications. The most substantial real systems include:</p><p>• FTPServer -Apache's high-performance FTP server;</p><p>• Jigsaw -W3C's web server; Columns 3-7 report metrics of the collected traces. The traces cover a wide range of complexity. The number of events in the traces ranges from hundreds in small benchmarks to as large as 14.8M in real systems. For most real systems, the traces contain more than 10 threads. The number of read/write, synchronization, and branch events is significant in the real systems, ranging between 40K-7.7M, 0.5K-650K, and 200K-6M, respectively. We are not aware of previous sound predictive race detector implementations that have been evaluated on executions with such a large scale.</p><p>Bug Detection Capability Column 8 reports the number of potential races that pass the quick check of a hybrid lockset and weaker HB algorithm. These races comprise a superset of all the real races that can be detected from the trace. Because the hybrid algorithm is unsound, some races in this set may be false positives. For instance, there are 18 potential races detected in bufwriter, but only 2 of them are real races. Columns 9-12 report the number of real races detected by different sound techniques.</p><p>The results show that, for every benchmark, our technique is able to detect more or at least the same number of races (i.e., a super set) as the other sound techniques. For instance, for derby, our technique (RV) detected 118 races, while Said et al. detected 15, CP detected 14, and CP detected 12. This demonstrates that our technique achieves a higher race detection capability not only theoretically, but also in practice. For Said et al., it detected more races than HB and CP in most benchmarks, with a few exceptions, though. For instance, for ftpserver, CP and HB detected 31 and 27 races, respectively, whereas Said et al. only detected 3. The reason for this, as explained in Section 1, is that the all read-write consistency prevents Said et al. from detecting races in feasible incomplete traces, though its SMT-based solution is able to explore more valid whole trace re-orderings than CP and HB. Between CP and HB, they detected the same number of races in the small benchmarks. This was because the lock regions in these small benchmarks typically have conflicting accesses. However, this does not hold for the real systems. In ftpserver, derby, and xalan, CP detected a few more races than HB.</p><p>For the real systems, our technique detected a total number of 299 real races. Notably, among these races, a number of them are previously unknown. For instance, we found three real races in eclipse, one is on the field variable activeSL of class org.eclipse.osgi.framework.internal.core.StartLevelManager, and the other two happen on the field elementCount of class org.eclipse.osgi.framework.util.KeyedHashSet. Interestingly, Keyed-HashSet is documented as thread unsafe. The Eclipse developers misused this class and created a shared instance by multiple threads without external synchronization. Shortly after we reported these races, the developers fixed them and also contacted us for adopting our tool. Now the team is using RVPredict to detect races in the codebase of Virgo. We also found eight previously unknown races in lusearch, all of which happen in the class org.apache.lucene.queryParser.QueryParserTokenManager. We first reported these races in the lucene bug database. However, the developer pointed out that QueryParserTokenManager is documented as thread unsafe. It turned out that this class was misused by the Dacapo developers in writing the lusearch benchmark.</p><p>Note that our technique is sound and fully automatic. Unlike many unsound techniques that report false warnings or even sound techniques that require manual post-processing for most races (e.g., CP <ref type="bibr" target="#b31">[35]</ref>), every race detected by our technique is real. This has been supported by our manual inspection: every reported race has been checked and confirmed to be real. On the other hand, because the maximality of our technique is concerned with sound race detection only, it is possible that our technique may miss some real races that can be reported by an unsound race detector. For example, not all the potential races reported in Column 8 are necessarily false alarms if they are not reported in Column 9 as well. However, if such a race exists, our technique guarantees that it cannot be reported by any sound technique using the same input trace. Note that any dynamic race detection technique (including ours) is sensitive to the observed execution trace. The results reported for different traces are incomparable. Therefore, it is possible for our technique to miss certain races reported in other studies, because the traces in our experiments may be different from those used in other's work.</p><p>Scalability The performance of our technique largely depends on the complexity of the constraints and the speed of the constraint solver, as the core computation of our technique takes place in the constraint solving phase. With the high performance solvers and our windowing strategy, our technique shows good scalability when dealing with large traces. Column 13 reports the total time for our technique to detect races in each program using Yices. The performance of Z3 was comparable with only slight variances. For most small benchmarks, our technique was able to finish in a few seconds. For most real systems, our technique finished within around a minute. The most time consuming case is derby, which our technique took around 30 minutes to process. The reason is that the trace of derby has a lot more potential races (469 COPs) and also it contains many fine-grained critical sections (38K synchronizations), making the generated constraints much more complex. Columns 14-16 report the race detection time for the other three techniques. Among the four techniques (including ours), HB and CP are comparable and are typically faster than Said et al. and our technique. This is expected because HB and CP do not rely on SMT solving and explore a much smaller set of trace re-orderings. Between our technique and Said et al., our technique typically has better performance. For instance, for the derby trace, Said et al. took more than one hour (timeout) without finishing, while our technique finished within around 30 minutes. The reason is that our technique generates less constraints to solve than Said et al. for capturing the read-write consistency. While Said et al. generate constraints for all read events in the trace to ensure the whole trace read-write consistency, our technique concerns only the read events that have control flow to the race events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>There is a rich body of race detection work in the literature. Our work is distinguished from other approaches in two main aspects: 1. we include control flow information -branch events -into the execution trace, enabling us to detect more races than other sound dynamic race detectors. 2. we encode the maximal causal model with control flow as a minimal set of feasibility constraints to achieve the maximal race detection capability. We next review important race detection techniques and discuss some representative recent work.</p><p>Predictive Trace Analysis Our technique belongs to the school of predictive trace analysis (PTA) approaches <ref type="bibr" target="#b6">[10,</ref><ref type="bibr" target="#b14">18,</ref><ref type="bibr" target="#b17">21,</ref><ref type="bibr" target="#b26">30,</ref><ref type="bibr" target="#b32">36]</ref>, which generate valid trace reorderings under certain scheduling constraints to find bugs unseen in the observed execution. The work by Said et al. <ref type="bibr" target="#b26">[30]</ref> is representative in this direction and inspired our technique. Both techniques rely on efficient encoding of the trace constraints and modern SMT solvers to explore feasible reorderings. The key difference, as we noted earlier in Section 1, is that from the perspective of control flow our technique is able to encode the minimal set of feasibility constraints to achieve maximality. Without considering the control flow, <ref type="bibr" target="#b26">[30]</ref> has to conservatively enforce the whole trace read-write consistency, which cannot detect races beyond fake control dependencies such as (3,10) in Figure <ref type="figure" target="#fig_0">1</ref> and also misses races in incomplete feasible traces such as (1,4) in Figure <ref type="figure">2</ref>. ExceptioNULL <ref type="bibr" target="#b14">[18]</ref> presents a PTA technique that predicts null-pointer dereferences using constraint solving. Similar to <ref type="bibr" target="#b26">[30]</ref>, it encodes the whole trace data-validity constraints and does not achieve maximality. jPredictor <ref type="bibr" target="#b6">[10]</ref> is another representative PTA technique that predict races and atomicity violations based on sliced causality <ref type="bibr" target="#b5">[9]</ref>, which is a sound causal model concerning precise data or control dependencies. Differently, jPredictor requires expensive static dependence analysis (hard to implement soundly in practice) and it is non-maximal.</p><p>Runtime Runtime detection techniques are typically designed for high runtime efficiency and do not perform comprehensive exploration of feasible trace permutations. Modern dynamic race detectors are often based on one or both of the lockset algorithm (first used in in Eraser <ref type="bibr" target="#b27">[31]</ref>) and Lamport's happens-before (HB) principle <ref type="bibr" target="#b18">[22]</ref>. Lockset-based approaches would detect all races detected by our technique but may also report many additional false alarms. It is unsound because many conflicting operations can be actually ordered by control flow even though they have different locksets. To address this problem, active testing techniques such as RaceFuzzer <ref type="bibr" target="#b28">[32]</ref> create concrete executions to expose real races by actively controlling a race-directed thread scheduler. PECAN <ref type="bibr" target="#b17">[21]</ref> statically generates racy schedules and uses a deterministic thread scheduler to create races. On the other hand, HB is precise but may miss races and is also more expensive. Numerous tools have been proposed to combine lockset with HB. For example, Choi and O'Callahan <ref type="bibr" target="#b24">[28]</ref> investigate a two-phase scheme that first uses lockset analysis to find out problematic fields and then performs HB analysis to produce precise detection. Goldilock <ref type="bibr" target="#b10">[14]</ref> uses lockset and HB to support continuous monitoring of race conditions in the JVM. To improve performance, FastTrack <ref type="bibr" target="#b15">[19]</ref> proposes an adaptive lightweight representation for HB, and IFRit <ref type="bibr" target="#b9">[13]</ref> uses static analysis to identify interference-free regions that reduce redundant instrumentations at compile time. Pacer <ref type="bibr" target="#b3">[7]</ref>, Lit-eRace <ref type="bibr" target="#b20">[24]</ref>, and DataCollider <ref type="bibr" target="#b12">[16]</ref> use sampling-based approaches to detect races with negligible runtime overheads.</p><p>Static analysis Many whole program static analysis techniques have been developed for identifying races in various languages, including C <ref type="bibr" target="#b11">[15,</ref><ref type="bibr" target="#b25">29,</ref><ref type="bibr" target="#b33">37,</ref><ref type="bibr" target="#b35">39]</ref>, Java <ref type="bibr" target="#b23">[27]</ref>, and SPMD programs <ref type="bibr" target="#b0">[4]</ref>. The primary advantage of static detection is that they can potentially explore all paths to find possible bugs. However, applying static analysis to large and complicated programs without producing many false alarms is challenging. Language and type systems <ref type="bibr" target="#b2">[6,</ref><ref type="bibr" target="#b4">8]</ref> have also been proposed to statically prevent races. These approaches typically require programmer annotations to specify property regions or have a limited language expressiveness.</p><p>Model checking An alternative way to achieve maximality in detecting races is to exhaustively explore the thread scheduling space, employed by model checking techniques <ref type="bibr" target="#b22">[26,</ref><ref type="bibr" target="#b30">34,</ref><ref type="bibr" target="#b34">38]</ref>. For instance, CHESS dynamically explores different thread schedules of the target program in a context-bounded way. Shacham et al. <ref type="bibr" target="#b30">[34]</ref> use a model checker to construct the witness for races reported by the lockset algorithm. Unfortunately, facing the exponentiality of both the program path and the scheduling space, it is still hard for model checking techniques to scale to large multithreaded programs. As our technique focuses on exploring races with respect to a single dynamic trace, it is much more scalable than model checking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>We have presented a sound predictive race detection technique based on a new foundation of maximal causal model incorporating the control flow that achieves the maximal detection capability for any sound race detector given the same execution trace under sequential consistency. We formulate race detection as a constraint solving problem over a minimal set of valid trace reordering constraints, and use an SMT solver to find all real races captured by the new maximal model. We have conducted extensive experiments with our technique and demonstrate that our technique is not only theoretically sound but also practically feasible. It is effective and scalable in detecting races in real world large concurrent systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. An example program with a race (3,10).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Event types in a multithreaded execution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. A trace corresponding to the example in Figure 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>DEFINITION 3 (</head><label>3</label><figDesc>COP). Events a and b form a conflicting operation pair, written COP(a, b), iff op(a) = write, op(b) 2 {write, read}, target(a) = target(b), and thread(a) 6 = thread(b). DEFINITION 4 (Data race). Consistent trace ⌧ has a race iff there is a consistent trace ⌧1ab 2 feasible(⌧ ) such that COP(a, b) 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Constraint modeling of the example trace in Figure 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Overall results -Columns 3-7 report metrics of the traces: the number of threads (#Thrd), total number of events (#Event), reads/writes (#RW), synchronizations (#Sync), and branch events (#Br). Column 8 (QC) reports the number of potential races that passes the quick check algorithm (a hybrid of lockset and weak HB). Columns 9-12 reports the number of real races detected by our technique (RV), Said et al.<ref type="bibr" target="#b26">[30]</ref> (Said), Causally-Precedes<ref type="bibr" target="#b31">[35]</ref> (CP), and Happens-Before<ref type="bibr" target="#b18">[22]</ref> (HB), respectively, and Columns 13-16 report the total race detection time taken by the corresponding techniques. For all the evaluated programs, our technique detected more or at least the same number of races as the other techniques. For the efficiency, HB and CP are faster than the other two, and our technique is faster than Said.</figDesc><table><row><cell>Sunflow, Xalan, Lusearch, Eclipse -popular multithreaded ap-</cell></row><row><cell>plications from Dacapo benchmark suite 9.12 [5].</cell></row></table><note><p>• Derby -Apache's widely used open source Java RDBMS; •</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Other memory models would require a different feasibility axiomatization.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Note that the dual case ⌧ 1 ba is equivalent and we can consider either one for defining a race and for race detection<ref type="bibr" target="#b26">[30]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank the FSL members and the anonymous reviewers for their valuable feedback on an early version of this paper. The work presented in this paper was supported in part by the NSF grant CCF-1218605, the NSA grant H98230-10-C-0294, the DARPA HACMS program as SRI subcontract 19-000222, the Rockwell Collins contract 4504813093, and the (Romanian) SMIS-CSNR 602-12516 contract no. 161/15.06.2010.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Barrier inference</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The dacapo benchmarks: Java benchmarking development and analysis</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Blackburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Garner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Khang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bentzur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Diwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Frampton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Z</forename><surname>Guyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hirzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hosking</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jump</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Phansalkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stefanović</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Vandrunen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dincklage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wiedermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A type and effect system for deterministic parallel Java</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Bocchino</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Heumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Komuravelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Overbey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Simmons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vakilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">PACER: Proportional detection of data races</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Coons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A parameterized type system for race-free java programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Parametric and sliced causality</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G. Ros</forename><surname>¸u</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">jPredictor: a predictive runtime analysis tool for Java</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Serbanuta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Z3: an efficient SMT solver</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">De</forename><surname>Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The Yices SMT solver</title>
		<author>
			<persName><forename type="first">B</forename><surname>Dutertre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Moura</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">IFRit: Interference-free regions for dynamic data-race detection</title>
		<author>
			<persName><forename type="first">L</forename><surname>Effinger-Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Goldilocks: a race and transaction-aware Java runtime</title>
		<author>
			<persName><forename type="first">T</forename><surname>Elmas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tasiran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">RacerX: Effective, static detection of race conditions and deadlocks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ashcraft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Effective data-race detection for the kernel</title>
		<author>
			<persName><forename type="first">J</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Burckhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Olynyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Concurrent bug patterns and how to test them</title>
		<author>
			<persName><forename type="first">E</forename><surname>Farchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Nir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IPDPS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Predicting null-pointer dereferences in concurrent programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farzan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Razavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sorrentino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">FastTrack: Efficient and precise dynamic race detection</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Linearizability: a correctness condition for concurrent objects</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOPLAS</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">PECAN: Persuasive prediction of concurrency access anomalies</title>
		<author>
			<persName><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISSTA</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Java memory model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Manson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">LiteRace: Effective sampling for lightweight data-race detection</title>
		<author>
			<persName><forename type="first">D</forename><surname>Marino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Trace theory</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mazurkiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Petri nets</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Finding and reproducing heisenbugs in concurrent programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Basler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Nainar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Neamtiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Effective static race detection for Java</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Whaley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Hybrid dynamic data race detection</title>
		<author>
			<persName><forename type="first">R</forename><surname>O'callahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Choi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PPoPP</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">LOCKSMITH: Contextsensitive correlation analysis for race detection</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pratikakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Generating data race witnesses by an smt-based analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Said</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NFM</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Eraser: a dynamic data race detector for multi-threaded programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sobalvarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOCS</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Race directed random testing of concurrent programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Maximal causal models for sequentially consistent systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Serbanuta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RV</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Scaling model checking of dataraces using dynamic information</title>
		<author>
			<persName><forename type="first">O</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schuster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PPoPP</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Sound predictive race detection in polynomial time</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Smaragdakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sadowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">PENELOPE: Weaving threads to expose atomicity violations</title>
		<author>
			<persName><forename type="first">F</forename><surname>Sorrentino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Farzan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Warlock: a static data race analysis tool</title>
		<author>
			<persName><forename type="first">N</forename><surname>Sterling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Winter Technical Conference</title>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Test input generation with Java pathfinder</title>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pǎsǎreanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khurshid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISSTA</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">RELAY: Static race detection on millions of lines of code</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Voung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>ESEC-FSE</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
