<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Heterogeneous Graph Transformer</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2020-03-03">3 Mar 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ziniu</forename><surname>Hu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Yuxiao</forename><surname>Dong</surname></persName>
							<email>yuxdong@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Kuansan</forename><surname>Wang</surname></persName>
							<email>kuansanw@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Yizhou</forename><surname>Sun</surname></persName>
							<email>yzsun@cs.ucla.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<settlement>Redmond</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<settlement>Redmond</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Heterogeneous Graph Transformer</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2020-03-03">3 Mar 2020</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3366423.3380027</idno>
					<idno type="arXiv">arXiv:2003.01332v1[cs.LG]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Graph Neural Networks</term>
					<term>Heterogeneous Information Networks</term>
					<term>Representation Learning</term>
					<term>Graph Embedding</term>
					<term>Graph Attention</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Recent years have witnessed the emerging success of graph neural networks (GNNs) for modeling structured data. However, most GNNs are designed for homogeneous graphs, in which all nodes and edges belong to the same types, making them infeasible to represent heterogeneous structures. In this paper, we present the Heterogeneous Graph Transformer (HGT) architecture for modeling Web-scale heterogeneous graphs. To model heterogeneity, we design node-and edge-type dependent parameters to characterize the heterogeneous attention over each edge, empowering HGT to maintain dedicated representations for different types of nodes and edges. To handle dynamic heterogeneous graphs, we introduce the relative temporal encoding technique into HGT, which is able to capture the dynamic structural dependency with arbitrary durations. To handle Web-scale graph data, we design the heterogeneous mini-batch graph sampling algorithm-HGSampling-for efficient and scalable training. Extensive experiments on the Open Academic Graph of 179 million nodes and 2 billion edges show that the proposed HGT model consistently outperforms all the state-of-the-art GNN baselines by 9%-21% on various downstream tasks. The dataset and source code of HGT are publicly available at https://github.com/acbull/pyHGT.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Heterogeneous graphs have been commonly used for abstracting and modeling complex systems, in which objects of different types Figure <ref type="figure">1</ref>: The schema and meta relations of Open Academic Graph (OAG). Given a Web-scale heterogeneous graph, e.g., an academic network, HGT takes only its one-hop edges as input without manually designing meta paths. interact with each other in various ways. Some prevalent instances of such systems include academic graphs, Facebook entity graph, LinkedIn economic graph, and broadly the Internet of Things network. For example, the Open Academic Graph (OAG) <ref type="bibr" target="#b27">[28]</ref> in Figure <ref type="figure">1</ref> contains five types of nodes: papers, authors, institutions, venues (journal, conference, or preprint), and fields, as well as different types of relationships between them.</p><p>Over the past decade, a significant line of research has been explored for mining heterogeneous graphs <ref type="bibr" target="#b16">[17]</ref>. One of the classical paradigms is to define and use meta paths to model heterogeneous structures, such as PathSim <ref type="bibr" target="#b17">[18]</ref> and metapath2vec <ref type="bibr" target="#b2">[3]</ref>. Recently, in view of graph neural networks' (GNNs) success <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b21">22]</ref>, there are several attempts to adopt GNNs to learn with heterogeneous networks <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b26">27]</ref>. However, these works face several issues: First, most of them involve the design of meta paths for each type of heterogeneous graphs, requiring specific domain knowledge; Second, they either simply assume that different types of nodes/edges share the same feature and representation space or keep distinct non-sharing weights for either node type or edge type alone, making them insufficient to capture heterogeneous graphs' properties; Third, most of them ignore the dynamic nature of every (heterogeneous) graph; Finally, their intrinsic design and implementation make them incapable of modeling Web-scale heterogeneous graphs.</p><p>Take OAG for example: First, the nodes and edges in OAG could have different feature distributions, e.g., papers have text features whereas institutions may have features from affiliated scholars, and coauthorships obviously differ from citation links; Second, OAG has been consistently evolving, e.g., 1) the volume of publications doubles every 12 years <ref type="bibr" target="#b3">[4]</ref>, and 2) the KDD conference was more related to database in the 1990s whereas more to machine learning in recent years; Finally, OAG contains hundreds of millions of nodes and billions of relationships, leaving existing heterogeneous GNNs not scalable for handling it.</p><p>In light of these limitations and challenges, we propose to study heterogeneous graph neural networks with the goal of maintaining node-and edge-type dependent representations, capturing network dynamics, avoiding customized meta paths, and being scalable to Web-scale graphs. In this work, we present the Heterogeneous Graph Transformer (HGT) architecture to deal with all these issues.</p><p>To handle graph heterogeneity, we introduce the node-and edgetype dependent attention mechanism. Instead of parameterizing each type of edges, the heterogeneous mutual attention in HGT is defined by breaking down each edge e = (s, t) based on its meta relation triplet, i.e., ⟨ node type of s, edge type of e between s &amp; t, node type of t⟩. Figure <ref type="figure">1</ref> illustrates the meta relations of heterogeneous academic graphs. In specific, we use these meta relations to parameterize the weight matrices for calculating attention over each edge. As a result, nodes and edges of different types are allowed to maintain their specific representation spaces. Meanwhile, connected nodes in different types can still interact, pass, and aggregate messages without being restricted by their distribution gaps. Due to the nature of its architecture, HGT can incorporate information from high-order neighbors of different types through message passing across layers, which can be regarded as "soft" meta paths. That said, even if HGT take only its one-hop edges as input without manually designing meta paths, the proposed attention mechanism can automatically and implicitly learn and extract "meta paths" that are important for different downstream tasks.</p><p>To handle graph dynamics, we enhance HGT by proposing the relative temporal encoding (RTE) strategy. Instead of slicing the input graph into different timestamps, we propose to maintain all the edges happening in different times as a whole, and design the RTE strategy to model structural temporal dependencies with any duration length, and even with unseen and future timestamps. By end-to-end training, RTE enables HGT to automatically learn the temporal dependency and evolution of heterogeneous graphs.</p><p>To handle Web-scale graph data, we design the first heterogeneous sub-graph sampling algorithm-HGSampling-for minibatch GNN training. Its main idea is to sample heterogeneous subgraphs in which different types of nodes are with similar proportions, since the direct usage of existing (homogeneous) GNN sampling methods, such as GraphSage <ref type="bibr" target="#b6">[7]</ref>, FastGCN <ref type="bibr" target="#b0">[1]</ref>, and LADIES <ref type="bibr" target="#b28">[29]</ref>, results in highly imbalanced ones regarding to both node and edge types. In addition, it is also designed to keep the sampled sub-graphs dense for minimizing the loss of information. With HGSampling, all the GNN models, including our proposed HGT, can train and infer on arbitrary-size heterogeneous graphs.</p><p>We demonstrate the effectiveness and efficiency of the proposed Heterogeneous Graph Transformer on the Web-scale Open Academic Graph comprised of 179 million nodes and 2 billion edges spanning from 1900 to 2019, making this the largest-scale and longest-spanning representation learning yet performed on heterogeneous graphs. Additionally, we also examine it on domain-specific graphs: the computer science and medicine academic graphs. Experimental results suggest that HGT can significantly improve various downstream tasks over state-of-the-art GNNs as well as dedicated heterogeneous models by 9-21%. We further conduct case studies to show the proposed method can indeed automatically capture the importance of implicit meta paths for different tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES AND RELATED WORK</head><p>In this section, we introduce the basic definition of heterogeneous graphs with network dynamics and review the recent development on graph neural networks (GNNs) and their heterogeneous variants. We also highlight the difference between HGT and existing attempts on heterogeneous graph neural networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Heterogeneous Graph Mining</head><p>Heterogeneous graphs <ref type="bibr" target="#b16">[17]</ref> (a.k.a., heterogeneous information networks) are an important abstraction for modeling relational data for many real-world complex systems. Formally, it is defined as: Definition 1. Heterogeneous Graph: A heterogeneous graph is defined as a directed graph G = (V, E, A, R) where each node v ∈ V and each edge e ∈ E are associated with their type mapping functions τ (v) : V → A and ϕ(e) : E → R, respectively. Meta Relation. For an edge e = (s, t) linked from source node s to target node t, its meta relation is denoted as ⟨τ (s), ϕ(e), τ (t)⟩. Naturally, ϕ(e) −1 represents the inverse of ϕ(e). The classical meta path paradigm <ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref> is defined as a sequence of such meta relation.</p><p>Notice that, to better model real-world heterogeneous networks, we assume that there may exist multiple types of relations between different types of nodes. For example, in OAG there are different types of relations between the author and paper nodes by considering the authorship order, i.e., "the first author of", "the second author of", and so on.</p><p>Dynamic Heterogeneous Graph. To model the dynamic nature of real-world (heterogeneous) graphs, we assign an edge e = (s, t) a timestamp T , when node s connects to node t at T . If s appears for the first time, T is also assigned to s. s can be associated with multiple timestamps if it builds connections over time.</p><p>In other words, we assume that the timestamp of an edge is unchanged, denoting the time it is created. For example, when a paper published on a conference at time T , T will be assigned to the edge between the paper and conference nodes. On the contrary, different timestamps can be assigned to a node accordingly. For example, the conference node "WWW" can be assigned any year. WWW @1994 means that we are considering the first edition of WWW, which focuses more on internet protocol and Web infrastructure, while WWW @2020 means the upcoming WWW, which expands its research topics to social analysis, ubiquitous computing, search &amp; IR, privacy and society, etc.</p><p>There have been significant lines of research on mining heterogenous graphs, such as node classification, clustering, ranking and representation learning <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref>, while the dynamic perspective of HGs has not been extensively explored and studied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Graph Neural Networks</head><p>Recent years have witnessed the success of graph neural networks for relational data <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b21">22]</ref>. Generally, a GNN can be regarded as using the input graph structure as the computation graph for message passing <ref type="bibr" target="#b5">[6]</ref>, during which the local neighborhood information is aggregated to get a more contextual representation. Formally, it has the following form: Definition 2. General GNN Framework: Suppose H l [t] is the node representation of node t at the (l)-th GNN layer, the update procedure from the (l-1)-th layer to the (l)-th layer is:</p><formula xml:id="formula_0">H l [t] ← Aggregate ∀s ∈N (t ),∀e ∈E(s,t ) Extract H l −1 [s]; H l −1 [t], e<label>(1)</label></formula><p>where N (t) denotes all the source nodes of node t and E(s, t) denotes all the edges from node s to t.</p><p>The most important GNN operators are Extract(•) and Aggregate(•). Extract(•) represents the neighbor information extractor. It extract useful information from source node's representation H l −1 [s], with the target node's representation H l −1 [t] and the edge e between the two nodes as query. Aggregate(•) gather the neighborhood information of souce nodes via some aggregation operators, such as mean, sum, and max, while more sophisticated pooling and normalization functions can be also designed.</p><p>Various (homogeneous) GNN architectures have been proposed following this framework. Kipf et al. <ref type="bibr" target="#b8">[9]</ref> propose graph convolutional network (GCN), which averages the one-hop neighbor of each node in the graph, followed by a linear projection and non-linear activation operations.  <ref type="bibr" target="#b21">[22]</ref> by introducing the attention mechanism into GNNs, which allows GAT to assign different importance to nodes within the same neighborhood.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Heterogeneous GNNs</head><p>Recently, studies have attempted to extend GNNs for modeling heterogeneous graphs. Schlichtkrull et al. <ref type="bibr" target="#b13">[14]</ref> propose the relational graph convolutional networks (RGCN) to model knowledge graphs. RGCN keeps a distinct linear projection weight for each edge type. Zhang et al. <ref type="bibr" target="#b26">[27]</ref> present the heterogeneous graph neural networks (HetGNN) that adopts different RNNs for different node types to integrate multi-modal features. Wang et al. <ref type="bibr" target="#b22">[23]</ref> extend graph attention networks by maintaining different weights for different meta-path-defined edges. They also use high-level semantic attention to differentiate and aggregate information from different meta paths.</p><p>Though these methods have shown to be empirically better than the vanilla GCN and GAT models, they have not fully utilized the heterogeneous graphs' properties. All of them use either node type or edge type alone to determine GNN weight matrices. However, the node or edge counts of different types can vary greatly. For relations that don't have sufficient occurrences, it's hard to learn accurate relation-specific weights. To address this, we propose to consider parameter sharing for a better generalization. Given an edge e = (s, t) with its meta relation as ⟨τ (s), ϕ(e), τ (t)⟩, if we use three interaction matrices to model the three corresponding elements τ (s), ϕ(e), and τ (t) in the meta relation, then the majority of weights could be shared. For example, in "the first author of" and "the second author of" relationships, their source and target node types are both author to paper, respectively. In other words, the knowledge about author and paper learned from one relation could be quickly transferred and adapted to the other one. Therefore, we integrate this idea with the powerful Transformer-like attention architecture, and propose Heterogeneous Graph Transformer.</p><p>To summarize, the key differences between HGT and existing attempts include:</p><p>(1) Instead of attending on node or edge type alone, we use the meta relation ⟨τ (s), ϕ(e), τ (t)⟩ to decompose the interaction and transform matrices, enabling HGT to capture both the common and specific patterns of different relationships using equal or even fewer parameters. (2) Different from most of the existing works that are based on customized meta paths, we rely on the nature of the neural architecture to incorporate high-order heterogeneous neighbor information, which automatically learns the importance of implicit meta paths. (3) Most previous works don't take the dynamic nature of (heterogeneous) graphs into consideration, while we propose the relative temporal encoding technique to incorporate temporal information by using limited computational resources. (4) None of the existing heterogeneous GNNs are designed for and experimented with Web-scale graphs, we therefore propose the heterogeneous Mini-Batch graph sampling algorithm designed for Web-scale graph training, enabling experiments on the billion-scale Open Academic Graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">HETEROGENEOUS GRAPH TRANSFORMER</head><p>In this section, we present the Heterogeneous Graph Transformer (HGT). Its idea is to use the meta relations of heterogeneous graphs to parameterize weight matrices for the heterogeneous mutual attention, message passing, and propagation steps. To further incorporate network dynamics, we introduce a relative temporal encoding mechanism into the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overall HGT Architecture</head><p>Figure <ref type="figure" target="#fig_0">2</ref> shows the overall architecture of Heterogeneous Graph Transformer. Given a sampled heterogeneous sub-graph (Cf. Section 4), HGT extracts all linked node pairs, where target node t is linked by source node s via edge e. The goal of HGT is to aggregate information from source nodes to get a contextualized representation for target node t. Such process can be decomposed into three components: Heterogeneous Mutual Attention, Heterogeneous Message Passing and Target-Specific Aggregation.</p><p>We denote the output of the (l)-th HGT layer as H (l ) , which is also the input of the (l+1)-th layer. By stacking L layers, we can get the node representations of the whole graph H (L) , which can be used for end-to-end training or fed into downstream tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Heterogeneous Mutual Attention</head><p>The first step is to calculate the mutual attention between source node s and target node t. We first give a brief introduction to the general attention-based GNNs as follows: where there are three basic operators: Attention, which estimates the importance of each source node; Message, which extracts the message by using only the source node s; and Aggregate, which aggregates the neighborhood message by the attention weight. For example, the Graph Attention Network (GAT) <ref type="bibr" target="#b21">[22]</ref> adopts an additive mechanism as Attention, uses the same weight for calculating Message, and leverages the simple average followed by a nonlinear activation for the Aggregate step. Formally, GAT has</p><formula xml:id="formula_1">H l [t] ← Aggregate ∀s ∈N (t ),∀e ∈E(s,t ) Attention(s, t) • Message(s)<label>(2)</label></formula><formula xml:id="formula_2">Attention GAT (s, t) = Softmax ∀s ∈N (t ) ì a W H l −1 [t] ∥ W H l −1 [s] Message GAT (s) = W H l −1 [s] Aggregate GAT (•) = σ Mean(•)</formula><p>Though GAT is effective to give high attention values to important nodes, it assumes that s and t have the same feature distributions by using one weight matrixW . Such an assumption, as we've discussed in Section 1, is usually incorrect for heterogeneous graphs, where each type of nodes can have its own feature distribution.</p><p>In view of this limitation, we design the Heterogeneous Mutual Attention mechanism. Given a target node t, and all its neighbors s ∈ N (t), which might belong to different distributions, we want to calculate their mutual attention grounded by their meta relations, i.e., the ⟨τ (s), ϕ(e), τ (t)⟩ triplets.</p><p>Inspired by the architecture design of Transformer <ref type="bibr" target="#b20">[21]</ref>, we map target node t into a Query vector, and source node s into a Key vector, and calculate their dot product as attention. The key difference is that the vanilla Transformer uses a single set of projections for all words, while in our case each meta relation should have a distinct set of projection weights. To maximize parameter sharing while still maintaining the specific characteristics of different relations, we propose to parameterize the weight matrices of the interaction operators into a source node projection, an edge projection, and a target node projection. Specifically, we calculate the h-head attention for each edge e = (s, t) (See Figure <ref type="figure" target="#fig_0">2</ref> (1)) by:</p><formula xml:id="formula_3">Attention H GT (s, e, t) = Softmax ∀s ∈N (t ) ∥ i ∈[1,h] ATT -head i (s, e, t)<label>(3)</label></formula><p>ATT -head i (s, e, t)</p><formula xml:id="formula_4">= K i (s) W AT T ϕ(e) Q i (t) T • µ ⟨τ (s),ϕ(e),τ (t )⟩ √ d K i (s) = K-Linear i τ (s) H (l −1) [s] Q i (t) = Q-Linear i τ (t ) H (l −1) [t]</formula><p>First, for the i-th attention head ATT -head i (s, e, t), we project the τ (s)-type source node s into the i-th Key vector K i (s) with a linear</p><formula xml:id="formula_5">projection K-Linear i τ (s) : R d → R d h</formula><p>, where h is the number of attention heads and d h is the vector dimension per head. Note that K-Linear i τ (s) is indexed by the source node s's type τ (s), meaning that each type of nodes has a unique linear projection to maximally model the distribution differences. Similarly, we also project the target node t with a linear projection Q-Linear i τ (t ) into the i−th Query vector.</p><p>Next, we need to calculate the similarity between the Query vector Q i (t) and Key vector K i (s). One unique characteristic of heterogeneous graphs is that there may exist different edge types (relations) between a node type pair, e.g., τ (s) and τ (t). Therefore, unlike the vanilla Transformer that directly calculates the dot product between the Query and Key vectors, we keep a distinct edgebased matrix</p><formula xml:id="formula_6">W AT T ϕ(e) ∈ R d h × d</formula><p>h for each edge type ϕ(e). In doing so, the model can capture different semantic relations even between the same node type pairs. Moreover, since not all the relationships contribute equally to the target nodes, we add a prior tensor µ ∈ R | A |× | R |× | A | to denote the general significance of each meta relation triplet, serving as an adaptive scaling to the attention.</p><p>Finally, we concatenate h attention heads together to get the attention vector for each node pair. Then, for each target node t, we gather all attention vectors from its neighbors N (t) and conduct softmax, making it fulfill ∀s ∈N (t ) Attention H GT (s, e, t) = 1 h×1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Heterogeneous Message Passing</head><p>Parallel to the calculation of mutual attention, we pass information from source nodes to target nodes (See Figure <ref type="figure" target="#fig_0">2</ref> (2)). Similar to the attention process, we would like to incorporate the meta relations of edges into the message passing process to alleviate the distribution differences of nodes and edges of different types. For a pair of nodes e = (s, t), we calculate its multi-head Message by:</p><formula xml:id="formula_7">Message H GT (s, e, t) = ∥ i ∈[1,h] MSG-head i (s, e, t)<label>(4)</label></formula><formula xml:id="formula_8">MSG-head i (s, e, t) = M-Linear i τ (s) H (l −1) [s] W MSG ϕ(e)</formula><p>To get the i-th message head MSG-head i (s, e, t), we first project the τ (s)-type source node s into the i-th message vector with a linear projection M-Linear i τ (s) : R d → R d h . It is then followed by a matrix</p><formula xml:id="formula_9">W M SG ϕ(e) ∈ R d h × d</formula><p>h for incorporating the edge dependency. The final step is to concat all h message heads to get the Message H GT (s, e, t) for each node pair.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Target-Specific Aggregation</head><p>With the heterogeneous multi-head attention and message calculated, we need to aggregate them from the source nodes to the target node (See Figure <ref type="figure" target="#fig_0">2</ref> (3)). Note that the softmax procedure in Eq. 3 has made the sum of each target node t's attention vectors to one, we can thus simply use the attention vector as the weight to average the corresponding messages from the source nodes and get the updated vector H (l ) [t] as:</p><formula xml:id="formula_10">H (l ) [t] = ⊕ ∀s ∈N (t )</formula><p>Attention H GT (s, e, t) • Message H GT (s, e, t) . This aggregates information to the target node t from all its neighbors (source nodes) of different feature distributions.</p><p>The final step is to map target node t's vector back to its typespecific distribution, indexed by its node type τ (t). To do so, we apply a linear projection A-Linear τ (t ) to the updated vector H (l ) [t], followed by residual connection <ref type="bibr" target="#b7">[8]</ref> as:</p><formula xml:id="formula_11">H (l ) [t] = A-Linear τ (t ) σ H (l ) [t] + H (l −1) [t].<label>(5)</label></formula><p>In this way, we get the l-th HGT layer's output H (l ) [t] for the target node t. Due to the "small-world" property of real-world graphs, stacking the HGT blocks for L layers (L being a small value) can enable each node reaching a large proportion of nodes-with different types and relations-in the full graph. That is, HGT generates a highly contextualized representation H (L) for each node, which can be fed into any models to conduct downstream heterogeneous network tasks, such as node classification and link prediction. Through the whole model architecture, we highly rely on using the meta relation-⟨τ (s), ϕ(e), τ (t)⟩-to parameterize the weight matrices separately. This can be interpreted as a trade-off between the model capacity and efficiency. Compared with the vanilla Transformer, our model distinguishes the operators for different relations and thus is more capable to handle the distribution differences in heterogeneous graphs. Compared with existing models that keep a distinct matrix for each meta relation as a whole, HGT's triplet parameterization can better leverage the heterogeneous graph schema to achieve parameter sharing. On one hand, relations with few occurrences can benefit from such parameter sharing for fast adaptation and generalization. On the other hand, different relationships' operators can still maintain their specific characteristics by using a much smaller parameter set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Relative Temporal Encoding</head><p>By far, we present HGT-a graph neural network for modeling heterogeneous graphs. Next, we introduce the Relative Temporal Encoding (RTE) technique for HGT to handle graph dynamic.</p><p>The traditional way to incorporate temporal information is to construct a separate graph for each time slot. However, such a procedure may lose a large portion of structural dependencies across different time slots. Meanwhile, the representation of a node at time t might rely on edges that happen at other time slots. Therefore, a proper way to model dynamic graphs is to maintain all the edges happening at different times and allow nodes and edges with different timestamps to interact with each other.</p><p>In light of this, we propose the Relative Temporal Encoding (RTE) mechanism to model the dynamic dependencies in heterogeneous graphs. RTE is inspired by Transformer's positional encoding method <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b20">21]</ref>, which has been shown successful to capture the sequential dependencies of words in long texts.</p><p>Specifically, given a source node s and a target node t, along with their corresponding timestamps T (s) and T (t), we denote the relative time gap ∆T (t, s) = T (t) − T (s) as an index to get a relative temporal encoding RT E(∆T (t, s)). Noted that the training dataset will not cover all possible time gaps, and thus RT E should be capable of generalizing to unseen times and time gaps. Therefore, we adopt a fixed set of sinusoid functions as basis, with a tunable linear projection T-Linear * : R d → R d as RT E:</p><p>Base ∆T (t, s), 2i = sin ∆T t,s /10000</p><formula xml:id="formula_12">2i d (6) Base ∆T (t, s), 2i + 1 = cos ∆T t,s /10000 2i +1 d (7) RT E ∆T (t, s) = T-Linear Base(∆T t,s )<label>(8)</label></formula><p>Finally, the temporal encoding relative to the target node t is added to the source node s' representation as follows:</p><formula xml:id="formula_13">H (l −1) [s] = H (l −1) [s] + RT E ∆T (t, s)<label>(9)</label></formula><p>In this way, the temporal augmented representation H (l −1) will capture the relative temporal information of source node s and target node t. The RTE procedure is illustrated in the Figure <ref type="figure" target="#fig_1">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">WEB-SCALE HGT TRAINING</head><p>In this section, we present HGT's strategies for training Webscale heterogeneous graphs with dynamic information, including an efficient Heterogeneous Mini-Batch Graph Sampling algorithm-HGSampling-and an inductive timestamp assignment method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">HGSampling</head><p>The full-batch GNN <ref type="bibr" target="#b8">[9]</ref> training requires the calculation of all node representations per layer, making it not scalable for Web-scale graphs. To address this issue, different sampling-based methods <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b28">29]</ref> have been proposed to train GNNs on a subset of nodes. However, directly using them for heterogeneous graphs is prone to get sub-graphs that are extremely imbalanced regarding different node types, due to that the degree distribution and the total number of nodes for each type can vary dramatically.</p><p>To address this issue, we propose an efficient Heterogeneous Mini-Batch Graph Sampling algorithm-HGSampling-to enable both HGT and traditional GNNs to handle Web-scale heterogeneous graphs. HGSampling is able to 1) keep a similar number of nodes and edges for each type and 2) keep the sampled sub-graph dense to minimize the information loss and reduce the sample variance.</p><p>Algorithm 1 outlines the HGSampling algorithm. Its basic idea is to keep a separate node budget B[τ ] for each node type τ and to sample an equal number of nodes per type with an importance sampling strategy to reduce variance. Given node t already sampled, we add all its direct neighbors into the corresponding budget with Algorithm 2, and add t's normalized degree to these neighbors in line 8, which will then be used to calculate the sampling probability. Such normalization is equivalent to accumulate the random walk probability of each sampled node to its neighborhood, avoiding the sampling being dominated by high-degree nodes. Intuitively, the higher such value is, the more a candidate node is correlated with the currently sampled nodes, and thus should be given a higher probability to be sampled. * For simplicity, we denote a linear projection L : R a → R b as a function to conduct linear transformation to vector x ∈ R a as: L(x ) = W x + b, where matrix W ∈ R a+b and bias b ∈ R b . W and b are learnable parameters for L.  After the budget is updated, we then calculate the sampling probability in Algorithm 1 line 9, where we calculate the square of the cumulative normalized degree of each node s in each budget. As proved in <ref type="bibr" target="#b28">[29]</ref>, using such sampling probability can reduce the sampling variance. Then, we sample n nodes in type τ by using the calculated probability, add them into the output node set, update its neighborhood to the budget, and remove it out of the budget in lines 12-15. Repeating such procedure for L times, we get a sampled sub-graph with L depth from the initial nodes. Finally, we reconstruct the adjacency matrix among the sampled nodes. By using the above algorithm, the sampled sub-graph contains a similar number of nodes per type (based on the separate node budget), and is sufficiently dense to reduce the sampling variance (based on the normalized degree and importance sampling), making it suitable for training GNNs on Web-scale heterogeneous graphs.</p><formula xml:id="formula_14">prob (l −1) [τ ][s] ← B[τ ][s] 2 ∥B[τ ] ∥ 2 2 //</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Inductive Timestamp Assignment</head><p>Till now we have assumed that each node t is assigned with a timestamp T (t). However, in real-world heterogeneous graphs, many nodes are not associated with a fixed time. Therefore, we need to assign different timestamps to it. We denote these nodes as plain nodes. For example, the WWW conference is held in both 1974 and 2019, and the WWW node in these two years has dramatically different research topics. Consequently, we need to decide which timestamp(s) to attach to the WWW node. Dt ← 1 / len A ⟨τ ,ϕ,τ (t )⟩ [t] // get normalized degree of added node t regarding to ⟨τ , ϕ, τ (t)⟩. end for 11: end for 12: return Updated Budget B There also exist event nodes in heterogeneous graphs that have an explicit timestamp associated with them. For example, the paper node should be associated with its publication behavior and therefore attached to its publication date.</p><p>We propose an inductive timestamp assignment algorithm to assign plain nodes timestamps based on event nodes that they are linked with. The algorithm is shown in Algorithm 2 line 6. The idea is that plan nodes inherit the timestamps from event nodes. We examine whether the candidate source node is an event node. If yes, like a paper published at a specific year, we keep its timestamp for capturing temporal dependency. If no, like a conference that can be associated with any timestamp, we inductively assign the associated node's timestamp, such as the published year of its paper, to this plain node. In this way, we can adaptively assign timestamps during the sub-graph sampling procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EVALUATION</head><p>In this section, we evaluate the proposed Heterogeneous Graph Transformer on three heterogeneous academic graph datasets. We conduct the Paper-Field prediction, Paper-Venue prediction, and Author Disambiguation tasks. We also take case studies to demonstrate how HGT can automatically learn and extract meta paths that are important for downstream tasks † .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Web-Scale Datasets</head><p>To examine the performance of the proposed model and its realworld applications, we use the Open Academic Graph (OAG) <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b27">28]</ref> as our experimental basis. OAG consists of more than 178 million nodes and 2.236 billion edges-the largest publicly available heterogeneous academic dataset. In addition, all papers in OAG are associated with their publication dates, spanning from 1900 to 2019.</p><p>To test the generalization of the proposed model, we also construct two domain-specific subgraphs from OAG: the Computer Science (CS) and Medicine (Med) academic graphs. The graph statistics are listed in Table <ref type="table">1</ref>, in which P-A, P-F, P-V, A-I, and P-P denote the edges between paper and author, paper and field, paper and venue, author and institute, and the citation links between two papers.</p><p>Both the CS and Med graphs contain tens of millions of nodes and hundreds of millions of edges, making them at least one magnitude larger than the other CS (e.g., DBLP) and Med (e.g., Pubmed) academic datasets that are commonly used in existing heterogeneous GNN and heterogeneous graph mining studies. Moreover, the three datasets used are far more distinguishable than previously wide-adopted small citation graphs used in GNN studies, such as † The dataset and code are publicly available at https://github.com/acbull/pyHGT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dataset</head><p>#nodes #edges #papers #authors #fields #venues #institutes #P-A #P-F #P-V #A-I #P-P Table <ref type="table">1</ref>: Open Academic Graph (OAG) Statistics.</p><p>Cora, Citeseer, and Pubmed <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b21">22]</ref>, which only contain thousands of nodes.</p><p>There are totally five node types: 'Paper', 'Author', 'Field', 'Venue', and 'Institute'. The 'Field' nodes in OAG are categorized into six levels from L 0 to L 5 , which are organized with a hierarchical tree. Therefore, we differentiate the 'Paper-Field' edges corresponding to the field level.</p><p>In addition, we differentiate the different author orders (i.e., the first author, the last one, and others) and venue types (i.e., journal, conference, and preprint) as well. Finally, the 'Self' type corresponds to the self-loop connection, which is widely added in GNN architectures. Except the 'Self' relationship, which are symmetric, all other relation types ϕ have a reverse relation type ϕ −1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experimental Setup</head><p>Tasks and Evaluation. We evaluate the HGT model on four different real-world downstream tasks: the prediction of Paper-Field (L 1 ), Paper-Field (L 2 ), and Paper-Venue, and Author Disambiguation. The goal of the first three node classification tasks is to predict the correct L 1 and L 2 fields that each paper belongs to or the venue it is published at, respectively. We use different GNNs to get the contextual node representation of the paper and use a softmax output layer to get its classification label. For author disambiguation, we select all the authors with the same name and their associated papers. The task is to conduct link prediction between these papers and candidate authors. After getting the paper and author node representations from GNNs, we use a Neural Tensor Network to get the probability of each author-paper pair to be linked.</p><p>For all tasks, we use papers published before the year 2015 as the training set, papers between 2015 and 2016 for validation, and papers between 2016 and 2019 as testing. We choose NDCG and MRR, which are two widely adopted ranking metrics <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, as the evaluation metrics. All models are trained for 5 times and, the mean and standard variance of test performance are reported.</p><p>Baselines. We compare HGT with two classes of state-of-art graph neural networks. All baselines as well as our own model, are implemented via the PyTorch Geometric (PyG) package <ref type="bibr" target="#b4">[5]</ref>.</p><p>The first class of GNN baselines is designed for homogeneous graphs, including:</p><p>• Graph Convolutional Networks (GCN) <ref type="bibr" target="#b8">[9]</ref>, which simply averages the neighbor's embedding followed by linear projection. We use the implementation provided in PyG. • Graph Attention Networks (GAT) <ref type="bibr" target="#b21">[22]</ref>, which adopts multihead additive attention on neighbors. We use the implementation provided in PyG.</p><p>The second class considered is several dedicated heterogeneous GNNs as baselines, including:</p><p>• Relational Graph Convolutional Networks (RGCN) <ref type="bibr" target="#b13">[14]</ref>, which keeps a different weight for each relationship, i.e., a relation triplet. We use the implementation provided in PyG. • Heterogeneous Graph Neural Networks (HetGNN) <ref type="bibr" target="#b26">[27]</ref>, which adopts different Bi-LSTMs for different node type for aggregating neighbor information. We re-implement this model in PyG following the authors' official code. • Heterogeneous Graph Attention Networks (HAN) <ref type="bibr" target="#b22">[23]</ref> design hierarchical attentions to aggregate neighbor information via different meta paths. We re-implement this model in PyG following the authors' official code.</p><p>In addition, to systematically analyze the effectiveness of the two major components of HGT, i.e., Heterogeneous weight parameterization (Heter) and Relative Temporal Encoding (RTE), we conduct an ablation study, but comparing with models that remove these components. Specifically, we use −Heter to denote models that uses the same set of weights for all meta relations, and use −RT E to denote models that doesn't include relative temporal encoding. By considering all the permutations, we have: HGT +H et er ‡ . We use our HGSampling algorithm proposed in Section 4 for all baseline GNNs to handle the large-scale OAG graph. To avoid data leakage, we remove out the links we aim to predict (e.g., the Paper-Field link as the label) from the sub-graph.</p><p>Input Features. As we don't assume the feature of each node type belongs to the same distribution, we are free to use the most appropriate features to represent each type of nodes. For each paper, we use a pre-trained XLNet <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25]</ref> to get the representation of each word in its title. We then average them weighted by each word's attention to get the title representation for each paper. The initial feature of each author is then simply an average of his/her published papers' representations. For the field, venue, and institute nodes, we use the metapath2vec model <ref type="bibr" target="#b2">[3]</ref> to train their node embeddings by reflecting the heterogeneous network structures.</p><p>The homogeneous GNN baselines assume the node features belong to the same distribution, while our feature extraction doesn't fulfill this assumption. To make a fair comparison, we add an adaptation layer between the input features and all used GNNs. This module simply conducts different linear projections for nodes of different types. Such a procedure can be regarded to map heterogeneous data into the same distribution, which is also adopted in literature <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>Implementation Details. We use 256 as the hidden dimension throughout the neural networks for all baselines. For all multi-head attention-based methods, we set the head number as 8. All GNNs keep 3 layers so that the receptive fields of each network are exactly ‡ Unless other stated, HGT refers to HGT +RT E +H e t e r .</p><p>GNN Models GCN <ref type="bibr" target="#b8">[9]</ref> RGCN <ref type="bibr" target="#b13">[14]</ref> GAT <ref type="bibr" target="#b21">[22]</ref> HetGNN <ref type="bibr" target="#b26">[27]</ref> HAN <ref type="bibr" target="#b22">[23]</ref> HGT the same. All baselines are optimized via the AdamW optimizer <ref type="bibr" target="#b12">[13]</ref> with the Cosine Annealing Learning Rate Scheduler <ref type="bibr" target="#b11">[12]</ref>. For each model, we train it for 200 epochs and select the one with the lowest validation loss as the reported model. We use the default parameters used in GNN literature and donot tune hyper-parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Experimental Results</head><p>We summarize the experimental results of the proposed model and baselines on three datasets in Table <ref type="table" target="#tab_5">2</ref>. All experiments for the four tasks are evaluated in terms of NDCG and MRR.</p><p>The results show that in terms of both metrics, the proposed HGT significantly and consistently outperforms all baselines for all tasks on all datasets. Take, for example, the Paper-Field (L 1 ) classification task on OAG, HGT achieves relative performance gains over baselines by 15-19% in terms of NDCG and 18-21% in terms of MRR (i.e., the performance gap divided by the baseline performance). When compared to HAN-the best baseline for most of the cases, the average relative NDCG improvements of HGT on the CS, Med and OAG datasets are 11%, 10% and 8%, respectively.</p><p>Overall, we observe that on average, HGT outperforms GCN, GAT, RGCN, HetGNN, and HAN by 20% for the four tasks on all three large-scale datasets. Moreover, HGT has fewer parameters and comparable batch time than all the heterogeneous graph neural network baselines, including RGCN, HetGNN, and HAN. This suggests that by modeling heterogeneous edges according to their meta relation schema, we are able to have better generalization with fewer resource consumption.</p><p>Ablation Study. The core component in HGT are the heterogeneous weight parameterization (Heter) and Relative Temporal Encoding (RTE). To further analyze their effects, we conduct an ablation study by removing them from HGT. Specifically, the model that removes heterogeneous weight parameterization, i.e., HGT +RT E −H et er , drops 4% of performance compared with the full model HGT +RT E +H et er . By removing RTE (i.e., HGT −RT E +H et er ), the performance has a 2% drop. The ablation study shows the significance of parameterizing with meta relations and using Relative Temporal Encoding.</p><p>In addition, we also try to implement a baseline that keeps a unique weight matrix for each relation. However, such a baseline contains too many parameters so that our experimental setting doesn't have enough GPU memory to optimize it. This also indicates that using the meta relation to parameterize weight matrices can achieve competitive performance with fewer resources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Case Study</head><p>To further evaluate how Relative Temporal Encoding (RTE) can help HGT to capture graph dynamics, we conduct a case study showing the evolution of conference topic. We select 100 conferences in computer science with the highest citations, assign them three different timestamps, i.e., 2000, 2010 and 2020, and construct sub-graphs initialized by them. Using a trained HGT, we can get the representations for these conferences, with which we can calculate the euclidean distances between them. We select WWW, KDD, and NeurIPS as illustration. For each of them, we pick the top-5 most similar conferences (i.e., the one with the smallest euclidean distance) to show how the conference's topics evolve over time.</p><p>As shown in Table <ref type="table">3</ref>, these venues' relationships have changed from 2000 to 2020. For example, WWW in 2000 was more related to some database conferences, i.e., SIGMOD and VLDB, and some networking conferences, i.e., NSDI and GLOBECOM. However, WWW in 2020 would become more related to some data mining and information retrieval conferences (KDD, SIGIR, and WSDM), in addition to SIGMOD and GLOBECOM. Also, KDD in 2000 was more related to traditional database and data mining venues, while in 2020 it will tend to correlate with a variety of topics, i.e. machine learning (NeurIPS), database (SIGMOD), Web (WWW), AI (AAAI), and NLP (EMNLP). Additionally, our HGT model can capture the difference brought by new conferences. For example, NeurIPS in 2020 would relate with ICLR, which is a newly organized deep learning conference. This case study shows that the relative temporal encoding can help capture the temporal evolution of the heterogeneous academic graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Visualize Meta Relation Attention</head><p>To illustrate how the incorporated meta relation schema can benefit the heterogeneous message passing process, we pick the schema that has the largest attention value in each of the first two HGT layers and plot the meta relation attention hierarchy tree in Figure <ref type="figure" target="#fig_4">5</ref>. For example, to calculate a paper's representation, ⟨Paper, is_published_at, Venue, is_published_at −1 , Paper⟩, ⟨Paper, has_L 2 _f ield_o f , Field, has_L 5 _f ield_o f −1 , Paper⟩, and ⟨Institute, is_a f f iliated_with −1 , Author, is_f irst_author _o f , Paper⟩ are the three most important meta relation sequences, which can be regarded as meta paths PVP, PFP, and IAP, respectively. Note that  these meta paths and their importance are automatically learned from the data without manual design. Another example of calculating an author node's representation is shown on the right. Such visualization demonstrates that Heterogeneous Graph Transformer is capable of implicitly learning to construct important meta paths for specific downstream tasks, without manual customization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>In this paper, we propose the Heterogeneous Graph Transformer (HGT) architecture for modeling Web-scale heterogeneous and dynamic graphs. To model heterogeneity, we use the meta relation ⟨τ (s), ϕ(e), τ (t)⟩ to decompose the interaction and transform matrices, enabling the model to have the similar modeling capacity with fewer resources. To capture graph dynamics, we present the relative temporal encoding (RTE) technique to incorporate temporal information using limited computational resources. To conduct efficient and scalable training of HGT on Web-scale data, we design the heterogeneous Mini-Batch graph sampling algorithm-HGSampling. We conduct comprehensive experiments on the Open Academic Graph, and show that the proposed HGT model can capture both heterogeneity and outperforms all the state-of-the-art GNN baselines on various downstream tasks.</p><p>In the future, we will explore whether HGT is able to generate heterogeneous graphs, e.g., predict new papers and their titles, and whether we can pre-train HGT to benefit tasks with scarce labels.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The Overall Architecture of Heterogeneous Graph Transformer. Given a sampled heterogeneous sub-graph with t as the target node, s 1 &amp; s 2 as source nodes, the HGT model takes its edges e 1 = (s 1 , t) &amp; e 2 = (s 2 , t) and their corresponding meta relations &lt; τ (s 1 ), ϕ(e 1 ), τ (t) &gt; &amp; &lt; τ (s 2 ), ϕ(e 2 ), τ (t) &gt; as input to learn a contextualized representation H (L) for each node, which can be used for downstream tasks. Color decodes the node type. HGT includes three components: (1) meta relation-aware heterogeneous mutual attention, (2) heterogeneous message passing from source nodes, and (3) target-specific heterogeneous message aggregation.</figDesc><graphic url="image-2.png" coords="4,57.56,83.68,496.84,194.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Relative Temporal Encoding (RTE) to model graph dynamic. Nodes are associated with timestamps T (•). After the RTE process, the temporal augmented representations are fed to the HGT model.</figDesc><graphic url="image-3.png" coords="5,318.35,83.69,239.46,150.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: HGSampling with Inductive Timestamp Assignment.</figDesc><graphic url="image-4.png" coords="7,53.80,83.68,504.40,199.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Table 3 :</head><label>3</label><figDesc>Temporal Evolution of Conference Similarity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Hierarchy of the learned meta relation attention.</figDesc><graphic url="image-5.png" coords="10,319.16,278.07,238.78,81.74" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Hamilton et al. propose GraphSAGE that generalizes GCN's aggregation operation from average to sum, max and a RNN unit. Velickovi et al. propose graph attention network (GAT)</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Algorithm 1 Heterogeneous Mini-Batch Graph Sampling Require: Adjacency matrix A for each ⟨τ (s), ϕ(e), τ (t)⟩ relation pair; Output node Set OS; Sample number n per node type; Sample depth L.</figDesc><table><row><cell cols="2">Ensure: Sampled node set N S; Sampled adjacency matrix Â.</cell></row><row><cell cols="2">1: N S ← OS // Initialize sampled node set as output node set.</cell></row><row><cell cols="2">2: Initialize an empty Budget B storing nodes for each node type</cell></row><row><cell></cell><cell>with normalized degree.</cell></row><row><cell cols="2">3: for t ∈ N S do</cell></row><row><cell>4:</cell><cell>Add-In-Budget(B, t, A, N S) // Add neighbors of t to B.</cell></row><row><cell cols="2">5: end for</cell></row><row><cell cols="2">6: for l ← 1 to L do</cell></row><row><cell>7:</cell><cell>for source node type τ ∈ B do</cell></row><row><cell>8:</cell><cell>for source node s ∈ B[τ ] do</cell></row><row><cell>9:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Calculate sampling probability for each source node s of node type τ .</figDesc><table><row><cell>10:</cell><cell>end for</cell></row><row><cell>11:</cell><cell></cell></row><row><cell>12:</cell><cell>for t ∈ {t i } n i=1 do</cell></row><row><cell>13:</cell><cell></cell></row><row><cell>16:</cell><cell>end for</cell></row><row><cell>17:</cell><cell>end for</cell></row><row><cell cols="2">18: end for</cell></row></table><note>Sample n nodes {t i } n i=1 from B[τ ] using prob (l −1) [τ ]. OS[τ ].add(t) // Add node t into Output node set. 14: Add-In-Budget(B, t, A, N S) // Add neighbors of t to B. 15: B[τ ].pop(t) // Remove sampled node t from Budget. 19: Reconstruct the sampled adjacency matrix Â among the sampled nodes OS from A. 20: return OS and Â;</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>−RT E −H et er , HGT +RT E −H et er , HGT −RT E +H et er and HGT +RT E</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>−RT E −H e t e r HGT +RT E −H e t e r HGT −RT E +H e t e r HGT +RT E Experimental results of different methods over the three datasets.</figDesc><table><row><cell>+H e t er</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We would like to thank Xiaodong Liu for helpful discussions. This work is partially supported by NSF III-1705169, NSF CAREER Award 1741634, NSF#1937599, Okawa Foundation Grant, and Amazon Research Award.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>CS 11,732,027 107,263,811 5,597,605 5,985,759 119,537 27,433 16,931 15,571,614 47,462,559 5,597,606 7,190,480 31,441,552 Med 51,044,324 451,468,375 21,931,587 28,779,507 289,930 25,044 18,256 85,620,479 149,728,483 21,931,588 28,779,507 165,408,318 OAG 178,663,927 2,236,196,802 89,606,257 88,364,081 615,228 53,073 25,288 300,853,688 657,049,405 89,606,258 167,449,933 1,021,237,518</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">FastGCN: Fast Learning with Graph Convolutional Networks via Importance Sampling</title>
		<author>
			<persName><forename type="first">Jie</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tengfei</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cao</forename><surname>Xiao</surname></persName>
		</author>
		<idno>ICLR&apos;18</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Stochastic Training of Graph Convolutional Networks with Variance Reduction</title>
		<author>
			<persName><forename type="first">Jianfei</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Le</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
				<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="941" to="949" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">metapath2vec: Scalable Representation Learning for Heterogeneous Networks</title>
		<author>
			<persName><forename type="first">Yuxiao</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nitesh</forename><forename type="middle">V</forename><surname>Chawla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ananthram</forename><surname>Swami</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Century of Science: Globalization of Scientific Collaborations, Citations, and Innovations</title>
		<author>
			<persName><forename type="first">Yuxiao</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhihong</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuansan</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD &apos;17</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1437" to="1446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast Graph Representation Learning with PyTorch Geometric</title>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Fey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Eric Lenssen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR 2019 Workshop: Representation Learning on Graphs and Manifolds</title>
				<imprint>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Neural Message Passing for Quantum Chemistry</title>
		<author>
			<persName><forename type="first">Justin</forename><surname>Gilmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><forename type="middle">S</forename><surname>Schoenholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><forename type="middle">F</forename><surname>Riley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">E</forename><surname>Dahl</surname></persName>
		</author>
		<idno>ICML. 1263-1272</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Inductive Representation Learning on Large Graphs</title>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">L</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhitao</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>In NeurIPS&apos;17</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Deep Residual Learning for Image Recognition</title>
		<author>
			<persName><forename type="first">Kaiming</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangyu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shaoqing</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jian</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR&apos;16</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Semi-Supervised Classification with Graph Convolutional Networks</title>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">N</forename><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Max</forename><surname>Welling</surname></persName>
		</author>
		<idno>ICLR&apos;17</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Learning to Rank for Information Retrieval and Natural Language Processing</title>
		<author>
			<persName><forename type="first">Hang</forename><surname>Li</surname></persName>
		</author>
		<idno type="DOI">10.2200/S00607ED2V01Y201410HLT026</idno>
		<ptr target="https://doi.org/10.2200/S00607ED2V01Y201410HLT026" />
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
		</imprint>
	</monogr>
	<note>Second Edition</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Learning to Rank for Information Retrieval</title>
		<author>
			<persName><forename type="first">Tie-Yan</forename><surname>Liu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">SGDR: Stochastic Gradient Descent with Warm Restarts</title>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Loshchilov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Hutter</surname></persName>
		</author>
		<idno>ICLR&apos;17</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Decoupled Weight Decay Regularization</title>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Loshchilov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Hutter</surname></persName>
		</author>
		<idno>ICLR&apos;19</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Modeling Relational Data with Graph Convolutional Networks</title>
		<author>
			<persName><forename type="first">Sejr</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">N</forename><surname>Schlichtkrull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rianne</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><surname>Van Den</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Max</forename><surname>Titov</surname></persName>
		</author>
		<author>
			<persName><surname>Welling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
				<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Self-Attention with Relative Position Representations</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Uszkoreit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Vaswani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NAACL-HLT</title>
				<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="464" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Overview of Microsoft Academic Service (MAS) and Applications</title>
		<author>
			<persName><forename type="first">Arnab</forename><surname>Sinha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhihong</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Darrin</forename><surname>Eide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo-June Paul</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuansan</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW Companion</title>
				<imprint>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Mining Heterogeneous Information Networks: Principles and Methodologies</title>
		<author>
			<persName><forename type="first">Yizhou</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Pathsim: Meta path-based top-k similarity search in heterogeneous information networks</title>
		<author>
			<persName><forename type="first">Yizhou</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xifeng</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tianyi</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB &apos;11</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Integrating meta-path selection with user-guided object clustering in heterogeneous information networks</title>
		<author>
			<persName><forename type="first">Yizhou</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brandon</forename><surname>Norick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xifeng</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD&apos;12</title>
				<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Arnetminer: extraction and mining of academic social networks</title>
		<author>
			<persName><forename type="first">Jie</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jing</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Limin</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juanzi</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhong</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Attention is All you Need</title>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noam</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niki</forename><surname>Parmar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Uszkoreit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Llion</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidan</forename><forename type="middle">N</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukasz</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Illia</forename><surname>Polosukhin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>In NeurIPS&apos;17</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Graph Attention Networks</title>
		<author>
			<persName><forename type="first">Petar</forename><surname>Velickovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guillem</forename><surname>Cucurull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arantxa</forename><surname>Casanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adriana</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pietro</forename><surname>Liò</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<idno>ICLR&apos;18</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Heterogeneous Graph Attention Network</title>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Houye</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chuan</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bai</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanfang</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peng</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD&apos;19</title>
				<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="2022" to="2032" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lysandre</forename><surname>Debut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Sanh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julien</forename><surname>Chaumond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clement</forename><surname>Delangue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Moi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierric</forename><surname>Cistac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Rault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rãľmi</forename><surname>Louf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Morgan</forename><surname>Funtowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jamie</forename><surname>Brew</surname></persName>
		</author>
		<idno>arXiv:cs.CL/1910.03771</idno>
		<title level="m">Transformers: State-of-the-art Natural Language Processing</title>
				<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">XLNet: Generalized Autoregressive Pretraining for Language Understanding</title>
		<author>
			<persName><forename type="first">Zhilin</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zihang</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yiming</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jaime</forename><forename type="middle">G</forename><surname>Carbonell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruslan</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Quoc</surname></persName>
		</author>
		<author>
			<persName><surname>Le</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note>In NeurIPS&apos;19</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Graph Transformer Networks</title>
		<author>
			<persName><forename type="first">Seongjun</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minbyul</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raehyun</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jaewoo</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyunwoo</forename><forename type="middle">J</forename><surname>Kim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note>In NeurIPS&apos;19</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Heterogeneous Graph Neural Network</title>
		<author>
			<persName><forename type="first">Chuxu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongjin</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chao</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ananthram</forename><surname>Swami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nitesh</forename><forename type="middle">V</forename><surname>Chawla</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note>In WWW&apos;19</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">OAG: Toward Linking Large-scale Heterogeneous Entity Graphs</title>
		<author>
			<persName><forename type="first">Fanjin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuxiao</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peiran</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaotao</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yan</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bin</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rui</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuansan</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD&apos;19</title>
				<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Layer-Dependent Importance Sampling for Training Deep and Large Graph Convolutional Networks</title>
		<author>
			<persName><forename type="first">Difan</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ziniu</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yewen</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Song</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yizhou</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Quanquan</forename><surname>Gu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note>In NeurIPS&apos;19</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
