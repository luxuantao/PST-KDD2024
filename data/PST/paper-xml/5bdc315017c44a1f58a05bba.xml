<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Noise Contrastive Estimation and Negative Sampling for Conditional Models: Consistency and Statistical Efficiency</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zhuang</forename><surname>Ma</surname></persName>
							<email>zhuangma@wharton.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Collins</surname></persName>
							<email>mjcollins@google.com</email>
							<affiliation key="aff1">
								<orgName type="department">Google AI Language</orgName>
								<orgName type="institution">Columbia University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Noise Contrastive Estimation and Negative Sampling for Conditional Models: Consistency and Statistical Efficiency</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Noise Contrastive Estimation (NCE) is a powerful parameter estimation method for loglinear models, which avoids calculation of the partition function or its derivatives at each training step, a computationally demanding step in many cases. It is closely related to negative sampling methods, now widely used in NLP. This paper considers NCE-based estimation of conditional models. Conditional models are frequently encountered in practice; however there has not been a rigorous theoretical analysis of NCE in this setting, and we will argue there are subtle but important questions when generalizing NCE to the conditional case. In particular, we analyze two variants of NCE for conditional models: one based on a classification objective, the other based on a ranking objective. We show that the rankingbased variant of NCE gives consistent parameter estimates under weaker assumptions than the classification-based method; we analyze the statistical efficiency of the ranking-based and classification-based variants of NCE; finally we describe experiments on synthetic data and language modeling showing the effectiveness and trade-offs of both methods.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>This paper considers parameter estimation in conditional models of the form p(y|x; ✓) = exp (s(x, y; ✓))</p><formula xml:id="formula_0">Z(x; ✓)<label>(1)</label></formula><p>where s(x, y; ✓) is the unnormalized score of label y in conjunction with input x under parameters ✓, Y is a finite set of possible labels, and Z(x; ✓) = P y2Y exp (s(x, y; ✓)) is the partition function for input x under parameters ✓.</p><p>It is hard to overstate the importance of models of this form in NLP. In log-linear models, including both the original work on maximum-entropy models <ref type="bibr" target="#b1">(Berger et al., 1996)</ref>, and later work on conditional random fields <ref type="bibr" target="#b5">(Lafferty et al., 2001)</ref>, the scoring function s(x, y; ✓) = ✓ • f (x, y) where f (x, y) 2 R d is a feature vector, and ✓ 2 R d are the parameters of the model. In more recent work on neural networks the function s(x, y; ✓) is a nonlinear function. In Word2Vec the scoring function is s(x, y; ✓) = ✓</p><p>x • ✓ 0 y where y is a word in the context of word x, and ✓</p><p>x 2 R d and ✓ 0 y 2 R d are "inside" and "outside" word embeddings x and y.</p><p>In many NLP applications the set Y is large. Maximum likelihood estimation (MLE) of the parameters ✓ requires calculation of Z(x; ✓) or its derivatives at each training step, thereby requiring a summation over all members of Y, which can be computationally expensive. This has led to many authors considering alternative methods, often referred to as "negative sampling methods", where a modified training objective is used that does not require summation over Y on each example. Instead negative examples are drawn from some distribution, and a objective function is derived based on binary classification or ranking. Prominent examples are the binary objective used in word2vec ( <ref type="bibr" target="#b8">(Mikolov et al., 2013)</ref>, see also <ref type="bibr" target="#b6">(Levy and Goldberg, 2014</ref>)), and the Noise Contrastive Estimation methods of <ref type="bibr" target="#b9">(Mnih and Teh, 2012;</ref><ref type="bibr" target="#b4">Jozefowicz et al., 2016)</ref> for estimation of language models.</p><p>In spite of the centrality of negative sampling methods, they are arguably not well understood from a theoretical standpoint. There are clear connections to noise contrastive estimation (NCE) (Gutmann and Hyvärinen, 2012), a negative sampling method for parameter estimation in joint models of the form p(y) = exp (s(y; ✓)) Z(✓) ; Z(✓) = X y2Y exp (s(y; ✓))</p><p>(2) However there has not been a rigorous theoretical analysis of NCE in the estimation of conditional models of the form in Eq. 1, and we will argue there are subtle but important questions when generalizing NCE to the conditional case. In particular, the joint model in Eq 2 has a single partition function Z(✓) which is estimated as a param-eter of the model <ref type="bibr" target="#b3">(Gutmann and Hyvärinen, 2012)</ref> whereas the conditional model in Eq 1 has a separate partition function Z(x; ✓) for each value of x. This difference is critical.</p><p>We show the following (throughout we define K 1 to be the number of negative examples sampled per training example):</p><p>• For any K 1, a binary classification variant of NCE, as used by <ref type="bibr" target="#b9">(Mnih and Teh, 2012;</ref><ref type="bibr" target="#b8">Mikolov et al., 2013)</ref>, gives consistent parameter estimates under the assumption that Z(x; ✓) is constant with respect to x (i.e., Z(x; ✓) = H(✓) for some function H). Equivalently, the method is consistent under the assumption that the function s(x, y; ✓) is powerful enough to incorporate log Z(x; ✓).</p><p>• For any K 1, a ranking-based variant of NCE, as used by <ref type="bibr" target="#b4">(Jozefowicz et al., 2016)</ref>, gives consistent parameter estimates under the much weaker assumption that Z(x; ✓) can vary with x. Equivalently, there is no need for s(x, y; ✓) to be powerful enough to incorporate log Z(x; ✓).</p><p>• We analyze the statistical efficiency of the ranking-based and classification-based NCE variants. Under respective assumptions, both variants achieve Fisher efficiency (the same asymptotic mean square error as the MLE) as K ! 1.</p><p>• We discuss application of our results to approaches of <ref type="bibr" target="#b9">(Mnih and Teh, 2012;</ref><ref type="bibr" target="#b8">Mikolov et al., 2013;</ref><ref type="bibr" target="#b6">Levy and Goldberg, 2014;</ref><ref type="bibr" target="#b4">Jozefowicz et al., 2016)</ref> giving a unified account of these methods.</p><p>• We describe experiments on synthetic data and language modeling evaluating the effectiveness of the two NCE variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Basic Assumptions</head><p>We assume the following setup throughout:</p><p>• We have sets X and Y, where X , Y are finite.</p><p>• There is some unknown joint distribution p X,Y (x, y) where x 2 X and y 2 Y. We assume that the marginal distributions satisfy p X (x) &gt; 0 for all x 2 X and p Y (y) &gt; 0 for all y 2 Y. • We have training examples {x (i) , y (i) } n i=1 drawn I.I.D. from p X,Y (x, y). • We have a scoring function s(x, y; ✓) where ✓ are the parameters of the model. For example, s(x, y; ✓) may be defined by a neural network.</p><p>• We use ⇥ to refer to the parameter space. We assume that ⇥ ✓ R d for some integer d.</p><p>• We use p N (y) to refer to a distribution from which negative examples are drawn in the NCE approach. We assume that p N satisfies p N (y) &gt; 0 for all y 2 Y.</p><p>We will consider estimation under the following two assumptions: Assumption 2.1 There exists some parameter value ✓ ⇤ 2 ⇥ such that for all (x, y) 2 X ⇥ Y,</p><formula xml:id="formula_1">p Y |X (y|x) = exp(s(x, y; ✓ ⇤ )) Z(x; ✓ ⇤ ) (3)</formula><p>where Z(x; ✓ ⇤ ) = P y2Y exp(s(x, y; ✓ ⇤</p><p>)).</p><p>Assumption 2.2 There exists some parameter value ✓ ⇤ 2 ⇥, and a constant ⇤ 2 R, such that for all (x, y) 2 X ⇥ Y,</p><formula xml:id="formula_2">p Y |X (y|x) = exp (s(x, y; ✓ ⇤ ) ⇤ ) . (4)</formula><p>Assumption 2.2 is stronger than Assumption 2.1. It requires log Z(x; ✓ ⇤ ) ⌘ ⇤ for all x 2 X , that is, the conditional distribution is perfectly self-normalized. Under Assumption 2.2, it must be the case that 8x 2 X Given a scoring function s(x, y; ✓) that satisfies assumption 2.1, we can derive a scoring function s 0 that satisfies assumption 2.2 by defining s 0 (x, y; ✓, {c x : x 2 X }) = s(x, y; ✓) c</p><p>x where c</p><p>x 2 R is a parameter for history x. Thus we introduce a new parameter c</p><p>x for each possible history x. This is the most straightforward extension of NCE to the conditional case; it is used by <ref type="bibr" target="#b9">(Mnih and Teh, 2012)</ref>. It has the clear drawback however of introducing a large number of additional parameters to the model. for binary objective, and L n R for ranking objective. Binary objective essentially corresponds to a problem where the scoring function s(x, y; ✓) is used to construct a binary classifier that discriminates between positive and negative examples. Ranking objective corresponds to a problem where the scoring function s(x, y; ✓) is used to rank the true label y (i) above negative examples y (i,1) . . . y (i,K)  for the input x (i) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Two Estimation Algorithms</head><p>Our main result is as follows:</p><p>Theorem 3.1 (Informal: see section 4 for a formal statement.) For any K 1, the binary classification-based algorithm in figure 1 is consistent under Assumption 2.2, but is not always consistent under the weaker Assumption 2.1. For any K 1, the ranking-based algorithm in figure 1 is consistent under either Assumption 2.1 or Assumption 2.2. Both algorithms achieve the same statistical efficiency as the maximum-likelihood estimate as K ! 1.</p><p>The remainder of this section gives a sketch of the argument underlying consistency, and discusses use of the two algorithms in previous work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">A Sketch of the Consistency Argument</head><p>for the Ranking-Based Algorithm In this section, in order to develop intuition underlying the ranking algorithm, we give a proof sketch of the following theorem:</p><formula xml:id="formula_3">Theorem 3.2 (First part of theorem 4.1 below.) Define L 1 R (✓) = E[L n R (✓)]. Under Assump- tion 2.1, ✓ 2 arg max ✓ L 1 R (✓) if and only if, for all (x, y) 2 X ⇥ Y, p Y |X (y|x) = exp(s(x, y; ✓))/Z(x, ✓).</formula><p>This theorem is key to the consistency argument. Intuitively as</p><formula xml:id="formula_4">n increases L n R (✓) converges to L 1 R (✓)</formula><p>, and the output to the algorithm converges to ✓ 0 such that p(y|x; ✓ 0 ) = p Y |X (y|x) for all x, y. Section 4 gives a formal argument.</p><p>We now give a proof sketch for theorem 3.2. Consider the algorithm in figure <ref type="figure" target="#fig_1">1</ref>. For convenience define ȳ(i) to be the vector (y (i,0) , y (i,1) , . . . , y (i,K)  ).</p><p>Define ↵(x, ȳ) =</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inputs:</head><p>Training examples {x (i)  , y (i) } n i=1 , sampling distribution pN (•) for generating negative examples, an integer K specifying the number of negative examples per training example, a scoring function s(x, y; ✓). Flags {BINARY = true, RANKING = false} if binary classification objective is used, {BINARY = false, RANKING = true} if ranking objective is used. Definitions: Define s(x, y; ✓) = s(x, y; ✓) log pN (y) Algorithm:</p><formula xml:id="formula_5">• For i = 1. . . n, k = 1. . . K, draw y (i,k) I.I.D.</formula><p>from the distribution pN (y). For convenience define</p><formula xml:id="formula_6">y (i,0) = y (i) . • If RANKING, define the ranking objective function L n R (✓) = 1 n n X i=1 log exp(s(x (i) , y (i,0) ; ✓)) P K k=0 exp(s(x (i) , y (i,k) ; ✓))</formula><p>, and the estimator b</p><formula xml:id="formula_7">✓R = argmax ✓2⇥ L n R (✓).</formula><p>• If BINARY, define the binary objective function Figure <ref type="figure" target="#fig_1">1</ref>: Two NCE-based estimation algorithms, using ranking objective and binary objective respectively.</p><formula xml:id="formula_8">L n B (✓, ) = 1 n n X i=1 n log g(x (i) , y (i,0) ; ✓, ) + K X k=1 log ⇣ 1 g(x (i) , y (i,k) ; ✓, )</formula><formula xml:id="formula_9">P K k=0 p X,Y (x, ȳk ) Q j6 =k p N (ȳ j ),<label>and</label></formula><formula xml:id="formula_10">q(k|x, ȳ; ✓) = exp(s(x, ȳk ; ✓)) P K k=0 exp(s(x, ȳk ; ✓)) , (k|x, ȳ) = p X,Y (x, ȳk ) Q j6 =k p N (ȳ j ) ↵(x, ȳ) = p Y |X (ȳ k |x)/p N (ȳ k ) P N k=0 p Y |X (ȳ k |x)/p N (ȳ k ) C(x, ȳ; ✓) = K X k=0 (k|x, ȳ) log q(k|x, ȳ; ✓)</formula><p>Intuitively, q(•|x, ȳ; ✓) and (•|x, ȳ) are posterior distributions over the true label k 2 {0 . . . K} given an input x, ȳ, under the parameters ✓ and the true distributions p X, Ȳ (x, ȳ) respectively; C(x, ȳ; ✓) is the negative cross-entropy between these two distributions.</p><p>The proof of theorem 3.2 rests on two identities. The first identity states that the objective function is the expectation of the negative crossentropy w.r.t. the density function 1 K+1 ↵(x, ȳ) (see Section B.1.1 of the supplementary material for derivation):</p><formula xml:id="formula_11">L 1 R (✓) = X x X ȳ 1 K + 1 ↵(x, ȳ)C(x, ȳ; ✓). (5)</formula><p>The second identity concerns the relationship between q(•|x, ȳ; ✓) and (•|x, ȳ). Under assumption 2.1, for all x, ȳ, k 2 {0 . . . K}, q(k|x, ȳ;</p><formula xml:id="formula_12">✓ ⇤ ) = p Y |X (ȳ k |x)Z(x; ✓ ⇤ )/p N (y k ) P K k=0 p Y |X (ȳ k |x)Z(x; ✓ ⇤ )/p N (y k ) = (k|x, ȳ)<label>(6)</label></formula><p>It follows immediately through the properties of negative cross entropy that</p><formula xml:id="formula_13">8x, ȳ, ✓ ⇤ 2 argmax ✓ C(x, ȳ; ✓) (7)</formula><p>The remainder of the argument is as follows:</p><p>• Eqs. 7 and 5 imply that</p><formula xml:id="formula_14">✓ ⇤ 2 argmax ✓ L 1 R (✓). • Assumption 2.1 implies that ↵(x, ȳ) &gt; 0 for all x, ȳ. It follows that any ✓ 0 2 arg max ✓ L 1 R (✓) satisfies for all x, ȳ, k, (8) q(k|x, ȳ; ✓ 0 ) = q(k|x, ȳ; ✓ ⇤ ) = (k|x, ȳ)</formula><p>Otherwise there would be some x,</p><formula xml:id="formula_15">ȳ such that C(x, ȳ; ✓ 0 ) &lt; C(x, ȳ; ✓ ⇤ ). • Eq. 8 implies that 8x, y, p(y|x; ✓ 0 ) = p(y|x; ✓ ⇤</formula><p>). See the proof of lemma B.3 in the supplementary material.</p><p>In summary, the identity in Eq. 5 is key: the objective function in the limit, L 1 R (✓), is related to a negative cross-entropy between the underlying distribution (•|x, ȳ) and a distribution under the parameters, q(•|x, ȳ; ✓). The parameters ✓ ⇤ maximize this negative cross entropy over the space of all distributions {q(•|x, ȳ; ✓), ✓ 2 ⇥}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Algorithms in Previous Work</head><p>To motivate the importance of the two algorithms, we now discuss their application in previous work. <ref type="bibr" target="#b9">Mnih and Teh (2012)</ref> consider language modeling, where x = w 1 w 2 . . . w n 1 is a history consisting of the previous n 1 words, and y is a word. The scoring function is defined as</p><formula xml:id="formula_16">s(x, y; ✓) = ( n 1 X i=1 C i r w i ) • q y + b y c x</formula><p>where r w i is an embedding (vector of parameters) for history word w i , q y is an embedding (vector of parameters) for word y, each C i for i = 1 . . . n 1 is a matrix of parameters specifying the contribution of r w i to the history representation, b y is a bias term for word y, and c</p><p>x is a parameter corresponding to the log normalization term for history x. Thus each history x has its own parameter c</p><p>x . The binary objective function is used in the NCE algorithm. The noise distribution p N (y) is set to be the unigram distribution over words in the vocabulary.</p><p>This method is a direct application of the original NCE method to conditional estimation, through introduction of the parameters c</p><p>x corresponding to normalization terms for each history. Interestingly, <ref type="bibr" target="#b9">Mnih and Teh (2012)</ref> acknowledge the difficulties in maintaining a separate parameter c</p><p>x for each history, and set c x = 0 for all x, noting that empirically this works well, but without giving justification. <ref type="bibr" target="#b8">Mikolov et al. (2013)</ref> consider an NCE-based method using the binary objective function for estimation of word embeddings. The skip-gram method described in the paper corresponds to a model where x is a word, and y is a word in the context. The vector v</p><p>x is the embedding for word x, and the vector v 0 y is an embedding for word y (separate embeddings are used for x and y). The method they describe uses</p><formula xml:id="formula_17">s(x, y; ✓) = v 0 y • v x or equivalently s(x, y; ✓) = v 0 y • v x + log p N (y)</formula><p>The negative-sampling distribution p N (y) was chosen as the unigram distribution p Y (y) raised to the power 3/4. The end goal of the method was to learn useful embeddings v w and v 0 w for each word in the vocabulary; however the method gives a consistent estimate for a model of the form</p><formula xml:id="formula_18">p(y|x) = exp v 0 y • v x + log p N (y) P y exp v 0 y • v x + log p N (y) = p N (y) exp v 0 y • v x Z(x; ✓)</formula><p>assuming that Assumption 2.2 holds, i.e. Z(x; ✓) = P y p N (y) exp v 0 y • v</p><p>x ⌘ H(✓) which does not vary with x.</p><p>Levy and Goldberg (2014) make a connection between the NCE-based method of <ref type="bibr" target="#b8">(Mikolov et al., 2013)</ref>, and factorization of a matrix of pointwise mutual information (PMI) values of (x, y) pairs. Consistency of the NCE-based method under assumption 2.2 implies a similar result, specifically: if we define p N (y) = p Y (y), and define s(x, y;</p><formula xml:id="formula_19">✓) = v 0 y • v x + log p N (y) implying s(x, y; ✓) = v 0 y • v x , then parameters v 0 y and v x converge to values such that p(y|x) = p Y (y) exp v 0 y • v x H(✓) or equivalently PMI(x, y) = log p(y|x) p(y) = v 0 y • v x log H(✓)</formula><p>That is, following <ref type="bibr" target="#b6">(Levy and Goldberg, 2014)</ref>, the inner product v 0 y • v</p><p>x is an estimate of the PMI up to a constant offset H(✓).</p><p>Finally, <ref type="bibr" target="#b4">Jozefowicz et al. (2016)</ref> introduce the ranking-based variant of NCE for the language modeling problem. This is the same as the ranking-based algorithm in figure 1. They do not, however, make the connection to assumptions 2.2 and 2.1, or derive the consistency or efficiency results in the current paper. <ref type="bibr" target="#b4">Jozefowicz et al. (2016)</ref> partially motivate the ranking-based variant throught the importance sampling viewpoint of <ref type="bibr" target="#b0">Bengio and Senécal (2008)</ref>. However there are two critical differences: 1) the algorithm of <ref type="bibr" target="#b0">Bengio and Senécal (2008)</ref> does not lead to the same objective L n R in the ranking-based variant of NCE; instead it uses importance sampling to derive an objective that is similar but not identical; 2) the importance sampling method leads to a biased estimate of the gradients of the log-likelihood function, with the bias going to zero only as K ! 1. In contrast the theorems in the current paper show that the NCE-based methods are consistent for any value of K. In summary, while it is tempting to view the ranking variant of NCE as an importance sampling method, the NCE-based view gives stronger guarantees for finite values of K.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Theory</head><p>This section states the main theorems. The supplementary material contains proofs. Throughout the paper, we use E</p><formula xml:id="formula_20">X [ • ], E Y [ • ], E X,Y [ • ], E Y |X=x [ • ] to represent the expectation w.r.t. p X (•), p Y (•), p X,Y (•, •), p Y |X (•|x).</formula><p>We use k • k to denote either the l 2 norm when the operand is a vector or the spectral norm when the operand is a matrix. Finally, we use ) to represent converge in distribution. Recall that we have defined s(x, y; ✓) = s(x, y; ✓) log p N (y).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Ranking</head><p>In this section, we study noise contrastive estimation with ranking objective under Assumption 2.1. First consider the following function:</p><formula xml:id="formula_21">L 1 R (✓) = X x,y 0 ,••• ,y K p X,Y (x, y 0 ) K Y i=1 p N (y i )</formula><p>⇥ log exp(s(x, y 0 ; ✓))</p><formula xml:id="formula_22">P K k=0 exp(s(x, y k ; ✓)) ! .</formula><p>By straightforward calculation, one can find that</p><formula xml:id="formula_23">L 1 R (✓) = E [L n R (✓)] . Under mild conditions, L n R (✓) converges to L 1 R (✓) as n ! 1. Denote the set of maximiz- ers of L 1 R (✓) by ⇥ ⇤ R , that is ⇥ ⇤ R = arg max ✓2⇥ L 1 R (✓) .</formula><p>The following theorem shows that any parameter vector ✓ 2 ⇥ ⇤ R if and only if it gives the correct conditional distribution p Y |X (y|x). Assumption 4.1 (Identifiability). For any ✓ 2 ⇥, if there exists a function c(x) such that s(x, y; ✓) s(x, y; ✓ ⇤ ) ⌘ c(x) for all (x, y) 2 X ⇥ Y, then ✓ = ✓ ⇤ and thus c(x) = 0 for all x.</p><formula xml:id="formula_24">Theorem 4.1 Under Assumption 2.1, ✓ 2 ⇥ ⇤ R if and only if, for all (x, y) 2 X ⇥ Y, p Y |X (y|x) = exp(s(x, y; ✓))/Z(x, ✓).</formula><p>In addition, ⇥ ⇤ R is a singleton if and only if Assumption 4.1 holds.</p><p>Next we consider consistency of the estimation algorithm based on the ranking objective under the following regularity assumptions: Assumption 4.2 (Continuity). s(x, y; ✓) is continuous w.r.t. ✓ for all (x, y) 2 X ⇥ Y.</p><formula xml:id="formula_25">Assumption 4.3 ⇥ ⇤ R is contained in the interior of a compact set ⇥ ⇢ R d . For a given estimate b p Y |X of the conditional dis- tribution p Y |X , define the error metric d(•, •) by d b p Y |X , p Y |X = X x2X ,y2Y p X,Y (x, y) ⇥ b p Y |X (y|x) p Y |X (y|x) 2 .</formula><p>For a sequence of IID observations (x (1) , y (1) ), (x (2) , y (2)  ), . . . , define the sequences of estimates</p><formula xml:id="formula_26">( b ✓ 1 R , b p 1 Y |X ), ( b ✓ 2 R , b p 2 Y |X ), . . . where the n th estimate ( b ✓ n R , b p n Y |X</formula><p>) is obtained by optimizing the ranking objective of figure <ref type="figure" target="#fig_1">1</ref> on</p><formula xml:id="formula_27">(x (1) , y (1)</formula><p>), (x (2) , y (2) ), . . . , (x (n) , y (n)  ).</p><p>Theorem 4.2 (Consistency) Under Assumptions 2.1, 4.2, 4.3, the estimates based on the ranking objective are strongly consistent in the sense that for any fixed K 1, P</p><formula xml:id="formula_28">n lim n!1 min ✓ ⇤ 2⇥ ⇤ R k b ✓ n R ✓ ⇤ k = 0 o = P n lim n!1 d ⇣ b p n Y |X , p Y |X ⌘ = 0 o = 1</formula><p>Further, if Assumption 4.1 holds, P</p><formula xml:id="formula_29">n lim n!1 b ✓ n R = ✓ ⇤ o = 1.</formula><p>Remark 4.1 Thoughout the paper, all NCE estimators are defined for some fixed K. We suppress the dependence on K to simplify notation (e.g. b</p><formula xml:id="formula_30">✓ n R should be interpreted as b ✓ n,K R ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Classification</head><p>Now we turn to the analysis of NCE with binary objective under Assumption 2.2. First consider the following function,</p><formula xml:id="formula_31">L 1 B (✓, ) = X x,y n p X,Y (x, y) log (g(x, y; ✓, )) + Kp X (x)p N (y) log (1 g(x, y; ✓, )) o One can find that L 1 B (✓, ) = E [L n B (✓, )] .</formula><p>Denote the set of maximizers of L 1 B (✓, ) by ⌦ ⇤ B :</p><formula xml:id="formula_32">⌦ ⇤ B = arg max ✓2⇥, 2 L 1 B (✓, ) .</formula><p>Parallel results of Theorem 4.1, 4.2 are established as follows.</p><p>Assumption 4.4 (Identifiability). For any ✓ 2 ⇥, if there exists some constant c such that s(x, y; ✓) s(x, y; ✓ ⇤ ) ⌘ c for all (x, y) 2 X ⇥Y, then ✓ = ✓ ⇤ and thus c = 0.</p><formula xml:id="formula_33">Assumption 4.5 ⌦ ⇤ B is in the interior of ⇥ ⇥ where ⇥ ⇢ R d , ⇢ R are compact sets. Theorem 4.3 Under Assumption 2.2, ( ✓, ¯ ) 2 ⌦ ⇤ B if and only if, for all (x, y) 2 X ⇥ Y, p Y |X (y|x) = exp(s(x, y; ✓) ¯ )</formula><p>for all (x, y). ⌦ ⇤ B is a singleton if and only if Assumption 4.4 holds.</p><p>Similarly we can define the sequence of estimates</p><formula xml:id="formula_34">( b ✓ 1 B , b 1 B , b p 1 Y |X ), ( b ✓ 2 B , b 2 B , b p 2 Y |X ), .</formula><p>. . based on the binary objective.</p><p>Theorem 4.4 (Consistency) Under Assumption 2.2, 4.2, 4.5, the estimates defined by the binary objective are strongly consistent in the sense that for any K 1, P</p><formula xml:id="formula_35">n lim n!1 min (✓ ⇤ , ⇤ )2⌦ ⇤ B k( b ✓ n B , b n B ) (✓ ⇤ , ⇤ )k = 0 o = P n lim n!1 d ⇣ b p n Y |X , p Y |X ⌘ = 0 o = 1</formula><p>If further Assumption 4.4 holds, P</p><formula xml:id="formula_36">n lim n!1 ( b ✓ n B , b n B ) = (✓ ⇤ , ⇤ ) o = 1.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Counterexample</head><p>In this section, we give a simple example to demonstrate that the binary classification approach fails to be consistent when assumption 2.1 holds but assumption 2.2 fails (i.e. the partition function depends on the input). Consider X 2 X = {x 1 , x 2 } with marginal distribution p X (x 1 ) = p X (x 2 ) = 1/2, and Y 2 Y = {y 1 , y 2 } generated by the conditional model specified in assumption 2.1 with the score function parametrized by ✓ = (✓ 1 , ✓ 2 ) and</p><formula xml:id="formula_37">s(x 1 , y 1 ; ✓) = log ✓ 1 , s(x 1 , y 2 ; ✓) = s(x 2 , y 1 ; ✓) = s(x 2 , y 2 ; ✓) = log ✓ 2 . Assume the true parameter is ✓ ⇤ = (✓ ⇤ 1 , ✓ ⇤ 2 ) = (1, 3). By simple calculation, Z(✓ ⇤ ; x 1 ) = 4, Z(✓ ⇤ ; x 2 ) = 6, p X,Y (x 1 , y 1 ) = 1/8, p X,Y (x 1 , y 2 ) = 3/8, p</formula><p>X,Y (x 2 , y 1 ) = p X,Y (x 2 , y 2 ) = 1/4. Suppose we choose the negative sampling distribution p N (y 1 ) = p N (y 2 ) = 1/2. For any K 1, by the Law of Large Numbers, as n goes to infinity, L n B (✓, ) will converge to L 1 B (✓, ). Substitute in the parameters above. One can show that</p><formula xml:id="formula_38">L 1 B (✓, ) = 1 8 log 2✓ 1 2✓ 1 + K exp( ) + K 4 log K exp( ) 2✓ 1 + K exp( ) + 7 8 log 2✓ 2 2✓ 2 + K exp( ) + 3K 4 log K exp( ) 2✓ 2 + K exp( ) .</formula><p>Setting the derivatives w.r.t. ✓ 1 , ✓ 2 to zero, one will obtain </p><formula xml:id="formula_39">✓ 1 = 1 4 exp( ), ✓ 2 =</formula><formula xml:id="formula_40">p Y |X (y 1 |x 1 ) p Y |X (y 2 |x 1 ) = p X,Y (x 1 , y 1 ) p X,Y (x 1 , y 2 ) = 1 3</formula><p>.</p><p>So the binary objective does not give consistent estimation of the conditional distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Asymptotic Normality and Statistical</head><p>Efficiency Noise Contrastive Estimation significantly reduces the computational complexity, especially when the label space |Y| is large. It is natural to ask: does such scalability come at a cost? Classical likelihood theory tells us, under mild conditions, the maximum likelihood estimator (MLE) has nice properties like asymptotic normality and Fisher efficiency. More specifically, as the sample size goes to infinity, the distribution of the MLE will converge to a multivariate normal distribution, and the mean square error of the MLE will achieve the Cramer-Rao lower bound <ref type="bibr" target="#b2">(Ferguson, 1996)</ref>.</p><p>We have shown the consistency of the NCE estimators in Theorem 4.2 and Theorem 4.4. In this part of the paper, we derive their asymptotic distribution and quantify their statistical efficiency. To this end, we restrict ourselves to the case where ✓ ⇤ is identifiable (i.e. Assumptions 4.1 or 4.4 hold) and the scoring function s(x, y; ✓) satisfies the following smoothness condition: Assumption 4.6 (Smoothness). The scoring function s(x, y; ✓) is twice continuous differentiable w.r.t. ✓ for all (x, y) 2 X ⇥ Y.</p><p>We first introduce the following maximumlikelihood estimator.</p><formula xml:id="formula_41">b ✓ MLE = arg min ✓ L n MLE (✓) := arg min ✓ n X i=1 log exp(s(x (i) , y (i) ; ✓)) P y2Y exp(s(x (i) , y; ✓))</formula><p>! .</p><p>Define the matrix</p><formula xml:id="formula_42">I ✓ ⇤ = E X ⇥ Var Y |X=x [r ✓ s(x, y; ✓ ⇤ )]</formula><p>⇤ .</p><p>As shown below, I ✓ ⇤ is essentially the Fisher information matrix under the conditional model. </p><formula xml:id="formula_43">I ✓ ⇤ is non-singular, as n ! 1 p n( b ✓ MLE ✓ ⇤ ) ) N(0, I 1 ✓ ⇤ ).</formula><p>For any given estimator b ✓, define the scaled asymptotic mean square error by</p><formula xml:id="formula_44">MSE 1 ( b ✓) = lim n!1 E " r n d ⇣ b ✓ ✓ ⇤ ⌘ 2 # ,</formula><p>where d is the dimension of the parameter ✓ ⇤ . Theorem 4.5 implies that,</p><formula xml:id="formula_45">MSE 1 ( b ✓ MLE ) = Tr(I 1 ✓ ⇤ )/d.</formula><p>where Tr(•) denotes the trace of a matrix. According to classical MLE theory <ref type="bibr" target="#b2">(Ferguson, 1996)</ref>, under certain regularity conditions, this is the best achievable mean square error. So the next question to answer is: can these NCE estimators approach this limit? </p><formula xml:id="formula_46">K K 0 , as n ! 1 p n ⇣ b ✓ R ✓ ⇤ ⌘ ) N(0, I 1 R,K ),<label>(9)</label></formula><p>for some matrix I R,K . There exists a constant C such that for all K K <ref type="bibr">4.4, 4.5, 4.6, 4.7</ref>, there exists an integer K 0 such that, for any</p><formula xml:id="formula_47">0 , | MSE 1 ( b ✓ R ) MSE 1 ( b ✓ MLE )|  C/ p K kI 1 R,K I 1 ✓ ⇤ k  C/ p K Theorem 4.7 (Binary) Under Assumption 2.2,</formula><formula xml:id="formula_48">K K 0 , as n ! 1 p n ⇣ b ✓ B ✓ ⇤ ⌘ ) N(0, I 1 B,K ),<label>(10)</label></formula><p>for some matrix I B,K . There exists a constant C such that for all K K 0 , </p><formula xml:id="formula_49">| MSE 1 ( b ✓ B ) MSE 1 ( b ✓ MLE )|  C/K kI 1 B,K I 1 ✓ ⇤ k  C/K.<label>Remark</label></formula><formula xml:id="formula_50">✓ = (✓ 1 , • • • , ✓ my ) 2 R my⇥d .</formula><p>Then for any given sample size n, we can generate observations (x (i) , y (i)  ) by first sampling x (i) uniformly from X and then sampling y We first consider the estimation of ✓ by MLE and NCE-ranking. We fix d = 4, m x = 200, m y = 100 and generate X and the parameter ✓ from separate mixtures of Gaussians. We try different configurations of (n, K) and report the KL divergence between the estimated distribution and true distribution, as summarized in the left panel of figure <ref type="figure">2</ref>. The observations are:</p><p>• The NCE estimators are consistent for any fixed K. For a fixed sample size, the NCE estimators become comparable to MLE as K increases.</p><p>• The larger the sample size, the less sensitive are the NCE estimators to K. A very small value of K seems to suffice for large sample size.</p><p>Apparently, under the parametrization above, the model is not self-normalized. To use NCEbinary, we add an extra x-dependent bias parameter b</p><p>x to the score function (i.e. s(x, y; ✓) = x 0 ✓ y + b x ) to make the model self-normalized or else the algorithm will not be consistent. Similar patterns to figure 2 are observed when varying sample size and K (see Section A.1 of the supplementary material). However this makes NCE-binary not directly comparable to NCE-ranking/MLE since its performance will be compromised by estimating extra parameters and the number of extra parameters depends on the richness of the feature space X . To make this clear, we fix n = 16000, d = 4, m y = 100, K = 32 and experiment with m x = 100, 200, 300, 400. The results are summarized on the right panel of figure 2. As |X | increases, the KL divergence will grow while the performance of NCE-ranking/MLE is independent of |X |. Without the x-dependent bias term for NCE-binary, the KL divergence will be much higher due to lack of consistency (0.19, 0.21, 0.24, 0.26 respectively).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Language Modeling</head><p>We evaluate the performance of the two NCE algorithms on a language modeling problem, using the Penn Treebank (PTB) dataset <ref type="bibr" target="#b7">(Marcus et al., 1993)</ref>. We choose <ref type="bibr" target="#b11">(Zaremba et al., 2014)</ref> as the benchmark where the conditional distribution is modeled by two-layer LSTMs and the parameters are estimated by MLE (note that the current state-of-the-art is <ref type="bibr" target="#b10">(Yang et al., 2018)</ref>). <ref type="bibr" target="#b11">Zaremba et al. (2014)</ref> implemented 3 model configurations: "Small" , "Medium" and "Large", which have 200, 650 and 1500 units per layer respectively. We follow their setup (model size, unrolled steps, dropout ratio, etc) but train the model by maximiz-</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>There are |X | constraints but only d + 1 free parameters. Therefore self-normalization is a nontrivial assumption when |X | d. In the case of language modeling, |X | = |V | k d + 1, where |V | is the vocabulary size and k is the length of the context. The number of constraints grows exponentially fast.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1</head><label>1</label><figDesc>Figure 1 shows two NCE-based parameter estimation algorithms, based respectively on binary objective and ranking objective. The input to either algorithm is a set of training examples {x (i) , y (i) } n i=1 , a parameter K specifying the number of negative examples per training example, and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>, ), where g(x, y; ✓, ) = exp (s(x, y; ✓) ) exp (s(x, y; ✓) ) + K . • Define b ✓ = b ✓R if RANKING and b ✓ = b ✓B otherwise. Return b ✓ and b p Y |X (y|x) = exp(s(x, y; b ✓)) P y2Y exp(s(x, y; b ✓))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>(i) 2 Y by the condional modelp(y|x; ✓) = exp(x 0 ✓ y )/ my X y=1 exp(x 0 ✓ y ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Assumption 4.7 There exist positive constants c, C such that min (I</figDesc><table><row><cell></cell><cell></cell><cell>✓ ⇤</cell><cell>) c and</cell></row><row><cell>max (x,y)2X ⇥Y</cell><cell>n</cell><cell cols="2">|s(x, y; ✓ ⇤ r 2 )|, kr ✓ s(x, y; ✓ ⇤ ✓ s(x, y; ✓ ⇤ o )  C. )k ,</cell></row><row><cell cols="4">where min (•) denotes the smallest singular value.</cell></row><row><cell cols="4">Theorem 4.6 (Ranking) Under Assumption 2.1,</cell></row><row><cell cols="4">4.1, 4.3, 4.6, 4.7, there exists an integer K 0 such</cell></row><row><cell>that for all</cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors thank Emily Pitler and Ali Elkahky for many useful conversations about the work, and David Weiss for comments on an earlier draft of the paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An interesting observation is, without regularization, the binary classification approach outperforms both ranking and MLE. This suggests the model space (two-layer LSTMs) is rich enough as to approximately incorporate the x-dependent partition function Z(✓; x), thus making the model approximately self-normalized. This motivates us to modify the ranking and MLE objectives by adding the following regularization term:</p><p>where e y (i,j) , 1  j  m are sampled from the noise distribution p N (•). This regularization term promotes a constant partition function, that is Z(x; ✓) ⇡ 1 for all x 2 X . In our experiments, we fix m to be 1/10 of the vocabulary size, K = 1600 and tune the regularization parameter ↵. As shown in the last three rows of the table, regularization significantly improves the performance of both the ranking approach and the MLE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>In this paper we have analyzed binary and ranking variants of NCE for estimation of conditional models p(y|x; ✓). The ranking-based variant is consistent for a broader class of models than the binary-based algorithm. Both algorithms achieve Fisher efficiency as the number of negative examples increases. Experiments show that both algorithms outperform MLE on a language modeling task. The ranking-based variant of NCE outperforms the binary-based variant once a regularizer is introduced that encourages self-normalization.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Adaptive importance sampling to accelerate training of a neural probabilistic language model</title>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Sébastien</forename><surname>Senécal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Neural Networks</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="713" to="722" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A maximum entropy approach to natural language processing</title>
		<author>
			<persName><forename type="first">Adam</forename><forename type="middle">L</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><forename type="middle">J</forename><surname>Della Pietra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">A</forename><surname>Della</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pietra</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Linguist</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="71" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A course in large sample theory</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Shelburne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ferguson</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Chapman &amp; Hall London</publisher>
			<biblScope unit="volume">49</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Noise-contrastive estimation of unnormalized statistical models, with applications to natural image statistics</title>
		<author>
			<persName><forename type="first">Aapo</forename><surname>Michael U Gutmann</surname></persName>
		</author>
		<author>
			<persName><surname>Hyvärinen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="307" to="361" />
			<date type="published" when="2012-02">2012. Feb</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Exploring the limits of language modeling</title>
		<author>
			<persName><forename type="first">Rafal</forename><surname>Jozefowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noam</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yonghui</forename><surname>Wu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1602.02410</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Conditional random fields: Probabilistic models for segmenting and labeling sequence data</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">D</forename><surname>Lafferty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><forename type="middle">C N</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighteenth International Conference on Machine Learning, ICML &apos;01</title>
				<meeting>the Eighteenth International Conference on Machine Learning, ICML &apos;01<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="282" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Neural word embedding as implicit matrix factorization</title>
		<author>
			<persName><forename type="first">Omer</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th International Conference on Neural Information Processing Systems</title>
				<meeting>the 27th International Conference on Neural Information Processing Systems<address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="2177" to="2185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Building a large annotated corpus of english: The penn treebank</title>
		<author>
			<persName><forename type="first">Mary</forename><surname>Mitchell P Marcus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ann</forename><surname>Marcinkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Beatrice</forename><surname>Santorini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational linguistics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="313" to="330" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Distributed representations of words and phrases and their compositionality</title>
		<author>
			<persName><forename type="first">Tomas</forename><surname>Mikolov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on Neural Information Processing Systems</title>
				<meeting>the 26th International Conference on Neural Information Processing Systems<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>Curran Associates Inc</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="3111" to="3119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A fast and simple algorithm for training neural probabilistic language models</title>
		<author>
			<persName><forename type="first">Andriy</forename><surname>Mnih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yee</forename><forename type="middle">W</forename><surname>Teh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Conference on Machine Learning (ICML-12)</title>
				<meeting>the 29th International Conference on Machine Learning (ICML-12)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1751" to="1758" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Breaking the softmax bottleneck: A high-rank RNN language model</title>
		<author>
			<persName><forename type="first">Zhilin</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zihang</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruslan</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">W</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.2329</idno>
		<title level="m">Recurrent neural network regularization</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
