<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Security of Symmetric Encryption against Mass Surveillance</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California San Diego</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kenneth</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Information Security Group</orgName>
								<orgName type="institution" key="instit1">Royal Holloway</orgName>
								<orgName type="institution" key="instit2">University of London</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Phillip</forename><surname>Rogaway</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">University of California Davis</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Security of Symmetric Encryption against Mass Surveillance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">82398E6AD2BBD27B4685AA11A2CB0A67</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Motivated by revelations concerning population-wide surveillance of encrypted communications, we formalize and investigate the resistance of symmetric encryption schemes to mass surveillance. The focus is on algorithm-substitution attacks (ASAs), where a subverted encryption algorithm replaces the real one. We assume that the goal of "big brother" is undetectable subversion, meaning that ciphertexts produced by the subverted encryption algorithm should reveal plaintexts to big brother yet be indistinguishable to users from those produced by the real encryption scheme. We formalize security notions to capture this goal and then offer both attacks and defenses. In the first category we show that successful (from the point of view of big brother) ASAs may be mounted on a large class of common symmetric encryption schemes. In the second category we show how to design symmetric encryption schemes that avoid such attacks and meet our notion of security. The lesson that emerges is the danger of choice: randomized, stateless schemes are subject to attack while deterministic, stateful ones are not. M. Bellare, K.G. Paterson, and P. Rogaway be naïve <ref type="bibr" target="#b0">[1]</ref>. ASAs may well be going on today, possibly on a massive scale. In this light we aim to provide a formal and practical treatment of ASAs, with a focus on symmetric encryption, an attractive target for real-world attacks. Building on, yet going further than, prior work, we fully and formally define security goals. We then come at ASAs from both ends, showing on the one hand how successful (from the point of view of big brother) ASAs may be mounted on standard schemes, and showing on the other hand how to design schemes that provably resist them. Our findings surface what we call the danger of choice: the trend towards flexibility and open-ended choices in protocols, often present for vendor flexibility or political compromise, works against us with regard to protection against ASAs, which are best defeated by stateful, deterministic encryption that curtails randomness and choice.</p><p>Model and definitions. The real encryption algorithm E takes, as usual, user key K, message M , and associated data A. It returns a ciphertext C. The subverted algorithm E that substitutes for E takes the same inputs but also an additional, big-brother key, K. It also returns a ciphertext.</p><p>With no restrictions on E, there would appear to be no hope of security, for E can fold K into the ciphertext, say encrypted under K, and big brother can use K to recover K. However, such an attack would be detected by users, who would see that ciphertexts fail to decrypt normally. Big brother aims to achieve compromise without detection: subverted ciphertexts should look like real ones, yet enable recovery of K or M . ASAs, in this view, live in a tension between detectability and success, the former working to curtail the latter. We will formally define metrics of both detectability and success.</p><p>We will require that ciphertexts produced by E decrypt normally under the decryption algorithm D of the base scheme. This decryptability condition is the most basic form of undetectability. But we expect that big brother will aim to evade more sophisticated forms of detection. We formalize detection security as requiring that real and subverted ciphertexts are indistinguishable even to a test that knows some users' keys but does not know K.</p><p>Success refers to big brother's ability to obtain knowledge about user data from subverted ciphertexts. Certainly an ASA allowing big brother to recover the user key K from any ciphertext is successful, but for positive results (defeating big brother) we want more. We formalize surveillance security as the requirement that big brother, even with its key K, cannot differentiate real ciphertexts from subverted ones.</p><p>The duality between detection and surveillance security is reflected in our formalizations. Both require indistinguishability of real and subverted ciphertexts to an adversary, the difference being that in detection the adversary knows the user keys but not the big-brother key, and in surveillance it's the other way around. We remark that, in both cases, our formalizations are multi-user, meaning there are many users (but a single subverter).</p><p>Mounting ASAs. We show that most symmetric encryption schemes succumb to damaging ASAs. Our attacks recover the user key K from subverted</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Overview. This paper is about the troubling possibility of mass surveillance by algorithm-substitution attack (ASA). Suppose that encryption scheme Π = (K, E, D) is to be implemented in closed-source software-think, for example, of implementing the CBC-AES encryption underlying the TLS record layer within Microsoft's Internet Explorer or Apple's Safari browsers, or in corresponding server-side code. An ASA replaces the executable code for the desired encryption algorithm E with, for example, the code of an NSA-authored alternative E.</p><p>ASAs have been discussed before, under various names, in particular falling under the banner of kleptography. This prescient idea was developed by Young and Yung starting in the 1990s <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b27">28]</ref>. While some cryptographers seem to have dismissed kleptography as far-fetched, recent revelations suggest this attitude to ciphertexts while remaining undetectable. These attacks apply to base schemes that are randomized and stateless. Building on <ref type="bibr" target="#b8">[9]</ref>, we first describe what we call IV-replacement attacks, where the initial vector in a blockcipher mode of operation is used to communicate to big brother an encryption under K of the user key K. Then we describe a more general ASA that we call the biased-ciphertext attack. This makes few assumptions on the structure of the base scheme and succeeds by creating ciphertexts that are not distributed quite like real ones. They are biased in a way that reveals bits of the user key to a holder of K, but we show that the bias is undetectable without knowledge of K. The difficulty here is showing undetectability even for tests that know the user key K, and for the analysis we prove an information-theoretic lemma about biased functions. Beyond presenting generic attacks <ref type="bibr" target="#b3">[4]</ref>, we discuss how encryption in SSL/TLS, IPsec, and SSH can be subverted by these means. The conclusion is that randomized, stateless schemes, including deployed ones, invariably fall to even generic ASAs.</p><p>Defeating ASAs. We aim to build symmetric encryption schemes that resist ASAs, meaning achieve surveillance security in the formal sense we define. Given the above, such schemes need to be stateful and deterministic. But not every such scheme works. The difficulty with provably achieving surveillance security is that standard security properties of the base scheme, such as its privacy or authenticity, are of no particular use towards the new goal. The reason is that these properties rely on the adversary not knowing the key K. But in the surveillance setting, the subverted ciphertexts are being created by an algorithm, E, that knows K, and can thus compromise privacy or authenticity to make subverted ciphertexts look different from real ones, and in a way useful to big brother. Nonetheless, we show that security is achievable by relying on combinatorial properties of the scheme. We define what it means for a base symmetric encryption scheme to have unique ciphertexts and then show that every unique-ciphertext scheme meeting the decryptability condition is secure against ASAs. This provides a strong anti-surveillance guarantee: no ASA will succeed in differentiating real from subverted ciphertexts, let alone recovering the message or a user's key. We show this assuming only minimal undetectabilitydecryptability, meaning that subverted ciphertexts must remain decryptable by the decryption algorithm of the base scheme.</p><p>To realize concrete benefits from this general result, we need to find uniqueciphertext symmetric encryption schemes. Here we give a simple construction based on a variable-input-length PRP. In <ref type="bibr" target="#b3">[4]</ref>, we present a more practical result, showing how any nonce-based symmetric encryption scheme <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b22">23]</ref> may be transformed into a unique ciphertext stateful deterministic scheme while preserving efficiency. Using existing nonce-based encryption schemes like CCM, GCM, or OCB, this yields practical designs of surveillance-resistant symmetric encryption.</p><p>Asymmetric ASAs. For simplicity, our main definitions only capture the case in which big brother embeds a symmetric key K into subverted software. It is obviously useful to replace this with a public key, the corresponding secret key being held by big brother, so that reverse engineering of a subverted encryption algorithm will not confer the capabilities that big brother aims to keep to itself. The necessary definitional extensions, which are small, are described in <ref type="bibr" target="#b3">[4]</ref>.</p><p>Scope. Our paper is deliberately of restricted scope: we consider ASAs only for symmetric encryption schemes. In reality, encryption schemes are deployed as part of larger cryptographic protocols and these protocols will afford additional opportunities for algorithmic subversion. To pick one example, a protocol might involve the transmission of a nonce for authentication purposes during a keyexchange phase. This nonce could be chosen so as to directly leak an ensuing session key. Or it could be chosen to leak the internal state of a back-doored PRNG, indirectly revealing future session keys. This technique has been posited as a subversion method for SSL/TLS <ref type="bibr" target="#b6">[7]</ref>.</p><p>Our scope also means that we exclude subversion attempts that exploit sidechannels in implementations. For example, our model does not capture timing information, so attacks in which the encryption key is leaked through finegrained timing behaviour of the encryption algorithm fall outside our notions. Big brother's subverted E could stutter the times at which ciphertexts or their blocks are produced; this might be sufficient to build a covert channel with adequate bandwidth to convey the session key. Such timing approaches have been used to infer information about user keystrokes over SSH connections <ref type="bibr" target="#b24">[25]</ref>.</p><p>The limitations on scope imply that our positive security results are certainly not definitive in terms of eliminating all subversion possibilities for a symmetric encryption scheme deployed within a real-world system. Still, a limited scope has merit. First, symmetric encryption is fundamental to secure communications, so it's important to study this primitive's susceptibility to subversion. Second, our model fits well within the scenario where an agency subverts encryption software, like a crypto library, rather than a particular protocol built on that library. Third, the positive results we provide, showing that ASAs on certain schemes are impossible, confine big brother to other avenues of attack, which may be less attractive. Finally, we aim to lay foundational results, in the modern, provable-security style, that can be built upon by succeeding researchers to broaden the scope of surveillance-resistant protocols to include tasks such as authenticated key exchange. It should eventually be possible to have a corpus of protocols, and even system-level code analysis, to provide strong guarantees on the ineffectiveness ASAs.</p><p>The danger of choice. The characteristic of modern encryption schemes that makes ASAs possible is the freedom-of-choice routinely provided by protocols, as well as the unverifiability of mandated randomness. Consider a symmetric encryption scheme that requires a user to select a 128-bit IV. The specification might say that the IV should be chosen uniformly at random, or it might even say that it must be so chosen. But, either way, the black-box behavior of the encryption scheme will never reveal if uniform random bits were used. Because of this, there is no way to ensure that the IV is not selected in a manner that will covertly communicate a session key to an agency engaged in mass surveillancewhich we exploit in our IV-replacement attack. Similarly, if a scheme permits variable-length padding there will be no way to ensure that the amount of padding is not used as a covert channel to transmit a user's key.</p><p>The ultimate conclusion of this paper is that unverifiable algorithmic choice can be a significant liability. We have in some sense come full-circle. In their classical paper on probabilistic encryption <ref type="bibr" target="#b9">[10]</ref>, Goldwasser and Micali explained the danger of deterministic public-key encryption: leaking that one ciphertext is the repetition of another, or allowing a ciphertext to be decrypted by trialencryption. But these threats can be eliminated without the use of probabilismnamely, through the use of state. For the most conventional setting in symmetric encryption-realizing a reliable, encrypted channel-ASAs provide one motivation for deterministic, stateful schemes, for sender and receiver both. We believe that there are further benefits to such schemes, including improved utility for software testing and the elimination of any need, post key-generation, to harvest unpredictable random bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work. Young and Yung have developed an extensive body of work on</head><p>what they call kleptography, beginning with <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b27">28]</ref>. This concerns the deliberate subversion of cryptosystems to provide backdoor capabilities; our work is a special case. While much of their work has focused on the public-key setting, Young and Yung have also considered attacks on protocols like Kerberos, and developed blockciphers containing backdoors for the black-box setting (ie, where the code of the blockcipher is not made available for inspection) <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b29">30]</ref>. In the light of recent revelations, we contend that kleptography deserves to play a larger role in the future development of our field. Additional work on back-doored blockciphers can be found in <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20]</ref>. This entire line of work has focused on building schemes with deliberately-inserted and hard-to-detect backdoors. By contrast, we also provide positive results, constructing schemes that are provably hard to subvert.</p><p>Goh, Boneh, Pinkas and Golle <ref type="bibr" target="#b8">[9]</ref> consider the problem of adding key recovery to the SSL/TLS and SSH protocols. Some passages of this 2003 paper now sound prophetic: The government can convince major software vendors to distribute SSL/TLS or SSH2 implementations with hidden and unfilterable key recovery. . . . Users will not notice the key recovery mechanism because the scheme is hidden. [9, Section 2.2]. Goh et al. suggest that when the server needs a random nonce, it can use in its place an encryption of the session key computed under the escrow key. We build on this idea to consider more general classes of attack on symmetric encryption schemes.</p><p>The problem of inserting backdoors and key-recovery defects into cryptographic schemes is closely related to the topic of subliminal channels, whose extensive literature begins with <ref type="bibr" target="#b23">[24]</ref> and the study of covert channels <ref type="bibr" target="#b16">[17]</ref>. There is a similarly extensive body of work on the exploitation, measurement, and elimination of timing side channels, both in cryptographic and non-cryptographic settings, with representative examples including <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b14">15]</ref>.</p><p>Further remarks. We posed our initial question in the context of closedsource software. However the sheer complexity of cryptographic libraries like OpenSSL, and the small number of experts who review such code, makes it plausible that ASAs might be carried out against open-source software. Note too that even when code appears to be "clean," there's always the possibility of code being subverted at compilation or run time, by subverting the compiler or interpreter <ref type="bibr" target="#b25">[26]</ref>. And there's certainly the possibility of performing ASAs on hardware-based cryptography, a prospect rendered all the easier by the widespread use of countermeasures intended to shield algorithmic internals from inspection.</p><p>We do not know if ASAs are among the techniques used to make TLSencrypted traffic available under warrantless surveillance <ref type="bibr" target="#b0">[1]</ref>. We offer no empirical evidence in this direction. We hope that other researchers are seeking it out, which is necessary for understanding the actual nature of our communication infrastructure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Notation. A string means a member of {0, 1} * , and ⊥ ∈ {0, 1} * denotes a special symbol standing for "invalid" or "reject." If S is a set then x S denotes sampling x uniformly at random from S. Syntax. Our syntax for symmetric encryption encompasses encryption that is probabilistic, deterministic, or stateful; and decryption that is deterministic or stateful. We allow associated data (AD), in order that our basic syntax encompass this practically-important component of authenticated encryption.</p><p>A scheme for symmetric encryption is a triple Π = (K, E, D). The key space K is a finite nonempty set. The encryption algorithm E is a possibly randomized algorithm that maps a four-tuple of strings K, M, A, σ to a pair of strings (C, σ ) E(K, M, A, σ). The arguments to E represent the key, message (plaintext), associated data and current state. The output consists of the ciphertext C and revised state σ . The decryption algorithm D is a deterministic algorithm that maps a four-tuple of strings (K, C, A, σ) to a pair of strings (M, σ ) ← D(K, C, A, σ).</p><p>Algorithms E and D are said to reject if they return a pair with first component of ⊥, and to accept otherwise. We may write E K (M, A, σ) and D K (C, A, σ) for <ref type="figure">E(K, M, A, σ)</ref> and<ref type="figure">D(K, C, A, σ</ref>), respectively. We adopt the convention that E and D return (⊥, ⊥) if any argument is ⊥. In addition, whether or not</p><formula xml:id="formula_0">C i = ⊥ is allowed to depend only on |M 1 |, |A 1 |, . . ., |M i-1 |, and |A i-1 |. This eliminates pointless degeneracies.</formula><p>We say that E is stateless if the second component of any output of E on any inputs is ε, and likewise for D. We say that Π is stateless if both E and D are stateless. In this case, we drop the second component of the output of both algorithms, so that E now returns just a ciphertext and D just a message. We also drop the last (state) input to D and, for E, think of it as the coins of the algorithm, dropping which is regarded as having the coins being chosen at random. In this way, when Π is stateless, we recover the conventional syntax.</p><p>It is well understood that encryption must be stateful or probabilistic to achieve IND-CPA privacy and decryption must be stateful to avoid replay attacks. Our work will show that decryption must be stateful to avoid algorithmsubstitution attacks.</p><p>Correctness. We say that Π = (K, E, D) is correct, or meets the correctness condition, if, when the sender encrypts a sequence of messages and the receiver decrypts the resulting sequence of ciphertexts in order, the receiver will get back what the sender started with. To be clear what this means in our current stateful context, we now proceed more formally. Saying that encryption scheme Π = (K, E, D) is correct means that for all q, all M 1 , . . . , M q ∈ {0, 1} * and all A 1 , . . . , A q ∈ {0, 1} * , the following game returns true with probability zero:</p><formula xml:id="formula_1">σ 0 , τ 0 ← ε For i = 1, . . . , q do (C i , σ i ) E(K, M i , A i , σ i-1 ); (M i , τ i ) ← D(K, C i , A i , τ i-1 ) Return ((∀i : C i = ⊥) and (∃i : M i = M i ))</formula><p>We will only consider schemes that are correct in this sense.</p><p>Security notions. We recall a standard notion of privacy for symmetric encryption <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b21">22]</ref>. Let Π = (K, E, D) be a symmetric encryption scheme and let A be an adversary. Consider the following game:</p><formula xml:id="formula_2">Game PRIV A Π K K; σ ← ε; b {0, 1} b ← A Enc ; Return (b = b ) Enc(M, A) If b = 1 then (C, σ) E(K, M, A, σ) Else (C, σ) E(K, 0 |M| , A, σ) Return C Let Adv priv Π (A ) = 2 Pr[PRIV A Π ⇒ true]</formula><p>-1 be the privacy advantage of adversary A . Positive results will provide schemes secure in this sense and also resistant to surveillance as we will define in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Subverting Encryption</head><p>We now ask what it would mean for a symmetric encryption scheme Π = (K, E, D) to fall to an algorithm substitution attack (ASA). An attacker B (for "big brother") wants to subvert an encryption scheme en masse. We assume it is able to arrange that subverted encryption code E K is used in place of E. (The subscript indicates that a key K chosen by B may be embedded in the code.) B wants its subversion to be successful and yet undetected. The former means that from observing only ciphertexts computed under the subverted algorithm, B can compromise privacy. (For example, it can, using K, efficiently recover the plaintexts underlying the ciphertexts.) This captures the relevant attack scenario where B is able, through mass surveillance of network traffic, to intercept bulk ciphertexts at will. The latter means that the subverted encryption algorithm should produce ciphertexts that look alright. The most basic form of the latter requirement is that they correctly decrypt under the decryption algorithm D of the base scheme, but we expect that big brother would prefer to evade even more sophisticated attempts at detection. One can consider subverting an encryption scheme's privacy, authenticity, or both. One can also consider subversion for public-key schemes or for other cryptographic goals, like key exchange. There are possibilities for algorithmsubstitution attacks (ASAs) in all these settings. Here we limit the scope to subversion aimed at compromising the privacy of a symmetric encryption scheme. The extensions to cover additional schemes is an obvious and important target for future research.</p><p>Subversions. Let Π = (K, E, D) be a symmetric encryption scheme. A subversion of Π is a triple Π = ( K, E, D). The master-key space K is a finite nonempty set. The subverted encryption algorithm E is a (possibly randomized) algorithm that maps a six-tuple of strings ( K, K, M, A, σ, i) to a pair of strings (C, σ ).</p><p>Here σ and σ are the current and updated states, respectively, indicating that E may be stateful. The input i represents some public information identifying a user encrypting under K and is assumed different for all keys. Such information is usually available in a system, perhaps a MAC address or an IP address, and we allow E to take it as input because we cannot realistically disallow a subverter from having or using such information.</p><p>The plaintext-recovery algorithm D takes K, C, A, i where C is a vector of ciphertexts, A is a vector of associated data and i is again the identity associated to the key K whose usage is being subverted. The algorithm attempts to produce a vector of corresponding plaintexts M . How effectively it does this will vary. For example, the plaintext-recovery algorithm D may always find the plaintext, for every ciphertext in the list, regardless of the length of the list. Or it may effectively perform a key recovery attack first, then simply decrypt the ciphertexts, but require many ciphertexts. In describing the severity of a practical ASA, we will explicitly specify D and quantify how good a job it does-a break that always finds the plaintext, or something else. For defining our security notion, however, we will ignore D, for the very strong notion we shall give implies the inexistence of any practical plaintext-recovery algorithm D.</p><p>Decryptability. We say that Π = ( K, E, D) satisfies the decryptability condition relative to Π = (K, E, D) if ( K × K, E, D ) is a correct encryption scheme where D is defined by D (( K, K), C, A, σ) = D(K, C, A, σ). Thus, although algorithm E operates on a key ( K, K) different from the key K of the base scheme Π, a party possessing only K can decrypt E-encrypted plaintexts using the legitimate decryption algorithm D. This represents the most basic form of resistance to detection, and we will assume any subversion must meet it.</p><p>Detection advantage. By detectability, we refer to the ability of ordinary users-they know their secret keys, but not the master key-to tell, from the ciphertexts, if encryption is happening by the real or subverted algorithm. In the absence of any detectability condition, subversion is always possible. The decryptability condition we gave above embodies a particularly basic form of detection, in that failure to meet this condition is likely to lead to detection. However, we expect that big brother wants to evade not just this, but more</p><formula xml:id="formula_3">Game DETECT U Π, Π b {0, 1}; K K; b U Key,Enc</formula><p>Return (b = b )  <ref type="figure" target="#fig_0">1</ref>. This measures the ability of test U to detect an ASA. In this game, U must detect whether it receives ciphertexts produced by E or by E. Via oracle Key the test U can obtain keys, reflecting that users may use their own keys in detection. The test of course does not have access to the subversion key K. A subversion Π in which this advantage is negligible for all practical tests U is said to be undetectable and would be one that evades detection in a powerful way. If such a subversion permitted plaintext recovery, big brother would consider it a very successful one. Attacks we will present in Section 4 show that such subversion is possible for a broad class of schemes Π.</p><formula xml:id="formula_4">Key(i) If (Ki = ⊥) then Ki K; σi ← ε Return Ki Enc (M, A, i) If (Ki = ⊥) then return ⊥ If (b = 1) then (C, σi) E (Ki, M, A, σi) Else (C, σi) E( K, Ki, M, A, σi, i) Return C Game SURV B Π, Π b {0, 1}; K K; b B Key,Enc ( K) Return (b = b ) Key(i) If (Ki = ⊥) then Ki K; σi ← ε Return ε Enc (M, A, i) If (Ki = ⊥) then return ⊥ If (b = 1) then (C, σi) E (Ki, M, A, σi) Else (C, σi) E ( K, Ki, M, A, σi, i) Return C</formula><p>We emphasize that the above definition captures the users' inability to know which encryption scheme is being used, the real one or the subverted one, even if it knows the private underlying keys. The adversary U in this setting might be regarded as the good guys-the population of users intent on seeing if they are all being surveilled based on the input/output behavior of the encryption code. We note that even if the detection advantage above is large, it is not clear that users would actually be able to detect subversion: for one thing, they probably wouldn't know what to look for. Thus detection advantage is only interesting when, for a scheme, it is demonstrably small. In that case big-brother has effectively forced detection to work by way of reverse-engineering the subverted code, not by looking at its black-box behavior.</p><p>Surveillance advantage. Now we want to define what it means for a scheme Π to resist, meaning be secure against, ASAs. The first thought is to ask that big brother, even given its subversion key K, cannot recover the plaintexts underlying subverted ciphertexts. We ask for something stronger, namely that big brother, even given K, cannot tell whether ciphertexts are being produced by the real encryption algorithm E or by the subverted algorithm E. Formally let Π = (K, E, D) be an encryption scheme and let Π = ( K, E, D) be a subversion of it. Let B be an adversary representing big brother. Let Adv srv Π, Π (B) = 2 Pr[SURV B Π, Π ⇒ true] -1 where game SURV is shown on the right of Fig. <ref type="figure" target="#fig_0">1</ref>. In the game, adversary B is given the subversion key K, but is not given user keys K 1 , K 2 , . . .. (We remark that the SURV and DETECT games are very similar, effectively duals of each other, the Enc oracle in particular being the same. The difference is that in the former the adversary gets K but not K 1 , K 2 , . . . while in the latter it is the other way around.) For Π to be secure against surveillance requires that this advantage is small for all subversions Π of Π and all B. This is the desired notion for positive results, and we will present schemes secure in this sense in Section 5. (We will assume minimal detection security in the form of the decryptability condition. Without some resistance to detection, surveillance security is not possible.) In offering a scheme secure in this sense we are asserting that big-brother can't come close to achieving surveillance en masse.</p><p>We have formulated surveillance security with multiple users, but a hybrid argument shows that the advantage relative to the one-user game can grow by at most a factor of the number of users. We will use this result to simplify proofs, which will restrict attention to the game with a single user. We remark that a similar claim is not true for detection security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Mounting ASAs</head><p>This section shows that typical randomized, stateless encryption schemes are subvertible. We first describe an attack on modes of operation that surface their IV. Then we describe what we call a universal attack, so named because it applies regardless of the specifics of the scheme being attacked. In <ref type="bibr" target="#b3">[4]</ref> we explain to what extent such attacks are applicable to the most important secure communications protocols for the Internet, namely SSL/TLS, IPsec, and SSH.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">IV-Replacement Attacks</head><p>Following Young and Yung <ref type="bibr" target="#b27">[28]</ref>, Goh, Boneh, Pinkas and Golle <ref type="bibr" target="#b8">[9]</ref> consider the problem of adding a hidden key recovery to protocols. They suggest that when the server needs a random nonce, it can use in its place an encryption of the session key computed under the escrow key. We expand on this idea, letting the escrow key be the subversion key. We show how to subvert stateleless encryption schemes that put a random nonce into the ciphertext.</p><p>We consider randomized, stateless schemes Π = (K, E, D), writing C ← E(K, M, A; IV ), where we now surface the randomness input IV (for initial vector, IV) to the encryption algorithm and suppress the state input. Such a scheme is said to surface its IV if there is an efficient algorithm X such that X (E(K, M, A; IV )) = IV for all K, M, A, IV . The condition says that X can recover the IV from the ciphertext. A simple example of a scheme that surfaces its IV is CBC$, namely CBC mode with random IV. Another example is CTR$, counter mode with random starting point.</p><p>The first requirement of a subversion attack is undetectability, but other attributes are relevant too. We will describe two attacks.</p><p>Stateful attack. This is the simplest attack, in which the IV is simply replaced by an encipherment, under the subversion key K, of the encryption key K. For simplicity of presentation, we assume that the IV length and key length are the same. (The attack extends easily to accommodate cases where the key length is greater than the IV length.) In order to prevent repeated IVs being seen across ciphertexts, we must limit the IV substitution to one ciphertext. This necessitates the use of a stateful subversion scheme. To avoid this repetition, one might consider replacing the IV by the encryption of K under a randomized symmetric encryption scheme that is IND$-CPA secure, but, since this encryption will usually be longer than the IV and thus cannot replace the IV in a single ciphertext, we would need to adopt a stateful approach to implement it too.</p><p>In more detail, let the bit length of the IV and key be n and assume we have a blockcipher E : K × {0, 1} n → {0, 1} n with block length n. The subversion of Π is the triple Π = ( K, E, D) where: <ref type="figure">E( K,</ref><ref type="figure">K,</ref><ref type="figure">M,</ref><ref type="figure">A,</ref><ref type="figure">σ,</ref><ref type="figure">i</ref>)</p><formula xml:id="formula_5">If σ = 0 then IV ← E( K, K) Else IV {0, 1} n C ← E(K, M, A, IV ) σ ← σ + 1; Return C D( K, C, A, i) IV ← X (C[1]) K ← E -1 ( K, IV ) M [1] ← D(K, C[1], A[1]) Return M</formula><p>The state σ maintained by E is an integer initialized at 0. When the state has this initial value, E sets the IV to an encryption of the key K, and otherwise performs no subversion, picking the IV at random. Now assume user i has requested an encryption of a message M <ref type="bibr" target="#b0">[1]</ref> under associated data A <ref type="bibr" target="#b0">[1]</ref> </p><formula xml:id="formula_6">with σ = 0, resulting in ciphertext C[1] = E( K, K, M [1], A[1], 0, i).</formula><p>The subverter's decryption algorithm gets input K together with i and the length-one vectors C, A, and recovers the key K as shown. Once obtained, the key can be used to decrypt not only the current but any future ciphertexts.</p><p>This subversion Π meets the decryptability condition. Furthermore, as long as E is a PRP/PRF, the subverted IV is indistinguishable from a random one, even to an observer that knows K (the observer does not know K), making the subversion undetectable. Formally: Theorem 1. Let Π = ({0, 1} n , E, D) be a randomized, stateless symmetric encryption scheme that surfaces an IV of length n. Let E : K × {0, 1} n → {0, 1} n be a blockcipher. Let the subversion Π = ( K, E, D) of Π be defined as above. Let U be a test that makes q queries to its Key oracle. Then we can construct an adversary A such that Adv det Π, Π (U ) ≤ q 2 /2 n +Adv prf E (A ). Adversary A makes q oracle queries and its running time is that of U .</p><p>The q 2 /2 n term corresponds to the chance that two users have the same key, in which case their subverted IVs will be the same while the real ones would be random and independent.</p><p>Suppose, however, that a user system, and hence the state of E, is reset. Then the subverted IV will be recreated and the observer detects a repeated IV, something not likely to happen in the absence of the subversion (though plausibly explainable as a randomness failure). This reduces the effectiveness of this simple attack. One solution to this problem is to adopt the above-mentioned idea of replacing the IV by the encryption of K under a randomized symmetric encryption scheme. This would result in a subversion ( K, E, D) that is both randomized and stateful. This subversion would have the practical advantage of being able to continuously leak the key K, rather than relying on big brother to intercept ciphertext C <ref type="bibr" target="#b0">[1]</ref>. In our next attack, we present a subversion that preserves this property and only requires randomisation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Stateless attack.</head><p>We present an attack where E is stateless. In this attack the subversion is undetectable even under resets of the encryptor system, making the attack harder to detect in practice. Let k be the key length of Π and let v = log 2 (k) . (For example if k = 128 as for AES then v = 7.) Let E : K × {0, 1} n → {0, 1} n be a blockcipher where n is the length of the IV of Π as before. The subversion of Π is the triple Π = ( K, E, D) where:</p><formula xml:id="formula_7">E( K, K, M, A, i) [1..k] R {0, 1} n-v-1 IV ← E( K, K[ ] R) C ← E(K, M, A, IV ) Return C D( K, C, A, i) For j = 1, . . . , |C| do b R ← E -1 ( K, X (C[j])); K [ ] ← b For j = 1, . . . , |C| do M [j] ← D(K , C[j], A[j]) Return M In computing E( K, K[ ] R</formula><p>) the integer is encoded as a v-bit string. After around k ln(k) encryptions, we expect that every ∈ [1..k] has been chosen at least once, so that if a vector of this many ciphertexts is passed to D, the latter will succeed. Undetectability again follows if E is a PRP/PRF, exploiting the fact that the observer does not know K: Theorem 2. Let Π = ({0, 1} k , E, D) be a randomized, stateless symmetric encryption scheme that surfaces an IV of length n. Let E : K × {0, 1} n → {0, 1} n be a blockcipher. Let v = log 2 (k) . Let the subversion Π = ( K, E, D) of Π be defined as above. Let U be a test that makes q queries to its Enc oracle.</p><p>Then we can construct an adversary A such that Adv det Π, Π (U ) ≤ q 2 /2 n-v-1 + Adv prf E (A ). It makes q oracle queries and its running time is that of U . This subversion achieves an even stronger form of undetectability than Theorem 2 captures. Since the subversion is stateless, reset of the system does not lead to detection. (It is assumed that the subvertor has access to fresh coins at every invocation. If a reset results in re-use of coins, our claim would no longer be true.) The subversion obviously extends to one leaking more than bit of K per ciphertext, at the cost of a weaker bound on detection advantage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Biased-Ciphertext Attack</head><p>The above IV-replacement attacks apply to several common modes in their "textbook" form and to some of their deployments in Internet protocols, but there are many encryption schemes to which they do not apply. These include schemes that do not surface the IV, for example encrypted-IV schemes like CBC2 <ref type="bibr" target="#b22">[23]</ref>, IACBC <ref type="bibr" target="#b13">[14]</ref> and XCBC$ <ref type="bibr" target="#b7">[8]</ref>.</p><p>In this section we present a more general attack that we call the biased ciphertext attack. This attack is "universal" in that it applies to any randomized and stateless encryption scheme Π = (K, E, D) that uses a minimal amount of randomness, say 7 bits. Undetectability holds in a strong form, namely even under reset of the state of the subverter.</p><p>Suppose the user asks its system to use this scheme to encrypt a message M with key K and associated data A, which means that the system is expected to pick coins δ at random from the space D of coins for E and return ciphertext C ← E(K, M, A; δ) (where we now replace IV by δ to emphasise the fact that δ may not be surfaced). Our subverted encryption algorithm will compute C the same way, except that δ will not be chosen quite at random. Instead, it will be chosen to ensure that F ( K, C) = K[j] is the j-bit of the key, where F is a PRF. The subverter decryption algorithm, on receiving C, will recompute K[j] as F ( K, C). The counter j will be maintained by the subverter algorithms in their state, so that over |K| encryptions, the entire key is leaked. The challenge here is showing that the bias created in the distribution of C is not detectable, even given the key K. Exploiting PRF security, we can move to a setting where F ( K, •) is replaced by a random function. Then we use an information-theoretic argument to show that the statistical distance between the real and subverted ciphertexts is small even given K. In terms of our formal definitions, big brother is undetectable.</p><p>We highlight the following features of the attack. First, big brother does not pick, or care, what messages or associated data is encrypted -this is no chosenmessage attack. Big brother will succeed no matter what the user chooses to encrypt, as long as it encrypts |K| or more messages. Second, the attack does not merely distinguish between real and subverted ciphertexts; rather, it recovers the encryption key. Although presented as a key recovery attack, it is not hard to see that, in terms of our formal definitions, big brother has surveillance advantage close to 1.</p><p>Let us say that Π is coin injective if the mapping of coins to ciphertext, for each fixed key, message and associated data, is injective. The analysis in our current proof of undetectability requires that Π have this property. The assumption is not particularly restrictive. Schemes that surface their IV are coin injective, not just the ones to which the IV-replacement attack applies, but also ones like OCB with random nonce that, as we indicated, were harder to handle. Schemes that encrypt the IV are also coin injective and thus covered. More generally, our analysis applies when the mapping is not injective but is regular.</p><p>Proceeding, suppose g : D → R where D ⊆ {0, 1} * , and f : {0, 1} * → {0, 1}. For b ∈ {0, 1} we let S f,g (b, D) = {δ ∈ D : f (g(δ)) = b}. Here think of g as taking coins δ and returning an encryption under them, the key, message, and associated data being fixed as part of g. Let F : K × {0, 1} * → {0, 1} be a PRF that returns a bit. The subversion of Π is the triple Π = ( K, E, D) where:</p><formula xml:id="formula_8">E( K, K, M, A, σ, i) j ← σ mod |K|; j ← j + 1 g(•) ← E(K, M, A; •) σ i δ S F ( K,•),g(•) (K[j], D) C ← E(K, M, A; δ) σ ← σ + 1; Return C D( K, C, A, i) For j = 1, . . . , |C| do K [j] ← F ( K, C[j] j -1 i) For j = 1, . . . , |C| do M [j] ← D(K , C[j], A[j]) Return M</formula><p>The state σ maintained by E is an integer, initially zero. Encryption lets g be the function that has K, M, A, j, σ, i hardwired and on input coins δ in the space D of coins of E, returns E(K, M, A; δ) σ i, the last two components ensuring no collisions in output values of the function across different users and states. Picking δ at random from the indicated set means that the ciphertext C = E(K, M, A; δ) will satisfy F ( K, C j -1 i) = K[j], except with some probability of error when the set is empty.</p><p>Let k = |K|. Now assume that user i has requested encryptions of messages</p><formula xml:id="formula_9">M [1], . . . , M [k] under associated data A[1], . . . , A[k], respectively, to result in ciphertexts C[1], . . . , C[k], created via C[j] = E( K, K, M [j], A[j], j-1, i) for j = 1, . . . , k.</formula><p>The big-brother decryption algorithm gets input K, C, A, i and recovers the key K as shown. It then decrypts under the true decryption algorithm to return the corresponding vector of messages. Except in the case of an error, the event K = K whose probability we will bound below, not only does decryption succeed, but the process does more, recovering the key, and once this is done the key can be stored and further ciphertexts decrypted directly. The error probability of the key recovery attack is at most e</p><formula xml:id="formula_10">1 + • • • + e k where e j = Pr[K [j] = K[j]] = Pr[S F ( K,•),g(•) (K[j], D) = ∅].</formula><p>Assuming F is a good PRF, our estimate can be made with a random function f in its place. Due to the inclusion of σ i in the argument to f , the applications of f are independent. Assuming g is injective, each time, the set has chance 2 -d to be empty where d = |D|, so the error probability is at most k2 -d . This is small as long as the scheme uses a minimal amount of randomness, for example 7 bits, resulting in d = 2 7 = 128. (A randomized mode will typically use 96-128 bits of randomness, in which case the error probability is entirely negligible.) A similar analysis can be carried out for the formal surveillance attack.</p><p>We claim that the subversion is undetectable. Our analysis first uses the PRF security of F to replace F ( K, •) with a random function f . The key claim is then the following information theoretic lemma. The proof is in <ref type="bibr" target="#b3">[4]</ref>. We use this lemma to estimate the undetectability of the subversion: Theorem 3. Let Π = (K, E, D) be a randomized, stateless, coin-injective symmetric encryption scheme with randomness-length r, and let d = 2 r . Let F : K × {0, 1} * → {0, 1} be a PRF. Let the subversion Π = ( K, E, D) of Π be defined as above. Let U be a test that makes q queries to its Enc oracle. Then we can construct an adversary A such that Adv det Π, Π (U ) ≤ q/2 d + Adv prf F (A ). Adversary A makes q oracle queries and its running time is that of U . So again as long as the scheme uses a non-trivial amount of randomness, for example r ≥ 7 bits resulting in d ≥ 128, Theorem 3 implies that the subversion is undetectable. The proof makes crucial use of Lemma 1, which, letting D = {0, 1} r be the space of coins of E, implies that the statistical distance between the real and subverted ciphertexts is 2 -d . A reset of the state will lead to increased detection ability for an observer, but if Π draws its coins from a reasonably large space, this increase does not appear to be enough to lead to actual detection. However the attack continues to be randomized, so if a system reset results in re-use of entropy, detection becomes possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Defeating ASAs</head><p>We turn to finding schemes that resist ASAs. Given the results of Section 4, such schemes must be deterministic and stateful. But not any such scheme works. The challenge here is that security properties of a scheme, such as privacy and authenticity, are of no evident use in showing resistance to ASAs, for these properties hold relative to adversaries that do not know the key K, while in the surveillance game, the subverted encryption algorithm has the key K. Thus surveillance security will rely on combinatorial properties of the scheme. We pinpoint one such property, defining what it means for a symmetric encryption scheme to have unique ciphertexts. We then show that any such scheme is surveillance-resistant. We then present some designs of unique-ciphertext, and thus surveillance-secure, schemes.</p><p>Unique ciphertexts. Let Π = (K, E, D) be a symmetric encryption scheme. For any possible state τ of D with respect to key K, any message M ∈ {0, 1} * and our context is instead the following, which says that Π has unique ciphertexts. This makes no security assumptions on P or F . The proof is in <ref type="bibr" target="#b3">[4]</ref>.</p><p>Theorem 5. Let P : {0, 1} k × {0, 1} * → {0, 1} * be a family of permutations and F : {0, 1} k × {0, 1} * → {0, 1} t a family of functions. Let Π = (K, E, D) be the symmetric encryption scheme associated to them as above. Then Π satisfies the correctness condition and has unique ciphertexts.</p><p>Surveillance-resistance from nonce-based schemes. Above we gave a simple scheme to illustrate that surveillance-resistance is possible. However, likely candidates to instantiate the PRP are two pass <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref>, making the scheme potentially slower than standard, deployed ones. In <ref type="bibr" target="#b3">[4]</ref> we describe a better solution. We show that any nonce-based scheme meeting a natural non-degeneracy condition, called "tidiness" in <ref type="bibr" target="#b17">[18]</ref>, can be turned into a stateful symmetric encryption scheme (by using the nonce as a counter) that has unique ciphertexts. Most existing and practical nonce-based schemes meet our condition, so this results in a number of surveillance-secure schemes that may be easily deployed.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Games used to define detection and surveillance security of subversion Π = ( K, E, D) of encryption scheme Π = (K, E , D)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 1 . 1 ) 2 )</head><label>112</label><figDesc>Suppose g : D → R. Let b ∈ {0, 1} and δ ∈ D. Let d = |D|. Let p = Pr[δ = δ] where we first draw f : g(D) → {0, 1} at random and then draw δ at random from S f,g (b, D) = {δ ∈ D : f (g(δ)) = b}. (If g is injective then p = (1 -2 -d )/d. (More generally, if g is k-regular, then p = (1 -2 -d/k )/d.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. Bellare was supported in part by NSF grants CNS-1228890 and CNS-1116800, Paterson by EPSRC Leadership Fellowship EP/H005455/1, and Rogaway by NSF grants CNS-1228828 and CNS-1314885.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>any associated data A ∈ {0, 1} * , let C Π (K, M, A, τ ) be the set of all ciphertexts C such that D(K, C, A, τ ) accepts with message M , meaning its output is (M, τ ) for some τ . We say that Π has unique ciphertexts if the set C Π (K, M, A, τ ) has size at most one for all K, M, A, τ . This means that, for any given key, message, associated data and state, there exists at most one ciphertext that the decryptor will decrypt to the message in question.</p><p>Due to the correctness condition, any unique-ciphertext scheme is deterministic. The converse is not true, meaning Π being deterministic does not necessarily mean it has unique ciphertexts. If Π is deterministic there is only one ciphertext an honest encryptor will produce given a particular key, message, associated data and state, but determinism does not ensure that there is not some other ciphertext that the decryptor will decrypt to the same message. As an analogy, the difference is the same as between deterministic and unique signature schemes <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>Surveillance-security. The following says that a unique-ciphertext scheme cannot be subverted without violating the decryptability condition. The proof is in <ref type="bibr" target="#b3">[4]</ref>. A unique-ciphertext scheme. We give an example of a symmetric encryption scheme that has unique ciphertexts and hence, by Theorem 4, is not subvertible. Our scheme is based on the encode-then-encipher paradigm of <ref type="bibr" target="#b4">[5]</ref> which we extend to allow associated data. Let P : {0, 1} k × {0, 1} * → {0, 1} * be a family of permutations. By P -1 we denote the inverse of P , satisfying P -1 K (P K (x)) = x for all x ∈ {0, 1} * . We also let F : {0, 1} k × {0, 1} * → {0, 1} t be a family of functions. (It will be used as a MAC.) The state σ in our scheme will be a counter, and we denote by σ its representation as a -bit string. Our symmetric encryption scheme Π = (K, E, D) has key space K = {0, 1} 2k and encryption and decryption algorithms defined as follows: <ref type="figure">E(K,</ref><ref type="figure">M,</ref><ref type="figure">A,</ref><ref type="figure">σ</ref>)</p><p>In the 4th line of the code of D, we are interpreting the first bits of x as the binary encoding of an integer denoted σ, and letting M be the rest of the bits of x. If P is a PRP and F is a PRF then Π is a secure authenticated encryption scheme. This is a standard claim that can be proved following <ref type="bibr" target="#b4">[5]</ref>. Of interest in</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Revealed: How US and UK Spy Agencies Defeat Internet Security and Privacy</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Borger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Greenwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Guardian</title>
		<imprint>
			<date type="published" when="2013-09-05">September 5, 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Concrete Security Treatment of Symmetric Encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Jokipii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th FOCS</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page">38</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Authenticated Encryption in SSH: Provably Fixing the SSH Binary Packet Protocol</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kohno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Namprempre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Security of Symmetric Encryption against Mass Surveillance</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Report</title>
		<imprint>
			<biblScope unit="page">438</biblScope>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
	<note>Full version of this paper. Cryptology ePrint Archive</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Encode-then-Encipher Encryption: How to Exploit Nonces or Redundancy in Plaintexts for Efficient Cryptography</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2000</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1976">1976. 2000</date>
			<biblScope unit="page" from="317" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">IP Covert Channel Detection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cabuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Brodley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Shields</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inf. Syst. Secur</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On the Practical Exploitability of Dual EC in TLS Implementations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Checkoway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fredrikson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Niederhagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Everspaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Maskiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fast Encryption and Authentication: XCBC Encryption and XECB Authentication Modes</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Gligor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Donescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2001</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2355</biblScope>
			<biblScope unit="page" from="92" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Design and Implementation of Protocol-Based Hidden Key Recovery</title>
		<author>
			<persName><forename type="first">E.-J</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Golle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISC 2003</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Boyd</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Mao</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2851</biblScope>
			<biblScope unit="page" from="165" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Probabilistic Encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="270" to="299" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Invariant Signatures and Non-Interactive Zero-Knowledge Proofs are Equivalent (Extended Abstract)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1992</title>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Brickell</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">740</biblScope>
			<biblScope unit="page" from="228" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A Tweakable Enciphering Mode</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="482" to="499" />
		</imprint>
	</monogr>
	<note>CRYPTO 2003</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Parallelizable Enciphering Mode</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA 2004</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2964</biblScope>
			<biblScope unit="page" from="292" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Encryption Modes with Almost Free Message Integrity</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jutla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="547" to="578" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Kocher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1996</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Koblitz</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1109</biblScope>
			<biblScope unit="page" from="104" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Unique Signatures and Verifiable Random Functions from the DH-DDH Separation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lysyanskaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2002</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2442</biblScope>
			<biblScope unit="page" from="597" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">20 years of Covert Channel Modeling and Analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Millen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Reconsidering Generic Composition</title>
		<author>
			<persName><forename type="first">C</forename><surname>Namprempre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2014</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8441</biblScope>
			<biblScope unit="page" from="257" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Asymmetric Cryptography with S-Boxes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Patarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Goubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICICS 1997</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Han</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Quing</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1334</biblScope>
			<biblScope unit="page" from="369" to="380" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Imprimitive Permutation Groups and Trapdoors in Iterated Block Ciphers</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 1999</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1636</biblScope>
			<biblScope unit="page" from="201" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A Family of Trapdoor Ciphers</title>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 1997</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1267</biblScope>
			<biblScope unit="page" from="139" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Authenticated-Encryption with Associated-Data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Nonce-Based Symmetric Encryption</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2004</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3017</biblScope>
			<biblScope unit="page" from="348" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The Prisoners&apos; Problem and the Subliminal Channel</title>
		<author>
			<persName><forename type="first">G</forename><surname>Simmons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<date type="published" when="1983">1983. 1983</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Timing Analysis of Keystrokes and Timing Attacks on SSH</title>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Reflections on Trusting Trust</title>
		<author>
			<persName><forename type="first">K</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="761" to="763" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The Dark Side of &quot;Black-Box&quot; Cryptography, or: Should We Trust Capstone?</title>
		<author>
			<persName><forename type="first">A</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1996</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Koblitz</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1109</biblScope>
			<biblScope unit="page" from="89" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Kleptography: Using cryptography against Cryptography</title>
		<author>
			<persName><forename type="first">A</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1997</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Fumy</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="62" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Monkey: Black-Box Symmetric Ciphers Designed for MONopolizing KEYs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 1998</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1372</biblScope>
			<biblScope unit="page">122</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A Subliminal Channel in Secret Block Ciphers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC 2004</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Handschuh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hasan</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3357</biblScope>
			<biblScope unit="page" from="198" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Backdoor Attacks on Black-Box Ciphers Exploiting Low-Entropy Plaintexts</title>
		<author>
			<persName><forename type="first">A</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACISP 2003</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Safavi-Naini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Seberry</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2727</biblScope>
			<biblScope unit="page" from="297" to="311" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
